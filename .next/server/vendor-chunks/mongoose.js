/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mongoose";
exports.ids = ["vendor-chunks/mongoose"];
exports.modules = {

/***/ "../backend/node_modules/mongoose/index.js":
/*!*************************************************!*\
  !*** ../backend/node_modules/mongoose/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Export lib/mongoose\n *\n */\n\n\n\nconst mongoose = __webpack_require__(/*! ./lib/ */ \"../backend/node_modules/mongoose/lib/index.js\");\n\nmodule.exports = mongoose;\nmodule.exports[\"default\"] = mongoose;\nmodule.exports.mongoose = mongoose;\n\n// Re-export for ESM support\nmodule.exports.cast = mongoose.cast;\nmodule.exports.STATES = mongoose.STATES;\nmodule.exports.setDriver = mongoose.setDriver;\nmodule.exports.set = mongoose.set;\nmodule.exports.get = mongoose.get;\nmodule.exports.createConnection = mongoose.createConnection;\nmodule.exports.connect = mongoose.connect;\nmodule.exports.disconnect = mongoose.disconnect;\nmodule.exports.startSession = mongoose.startSession;\nmodule.exports.pluralize = mongoose.pluralize;\nmodule.exports.model = mongoose.model;\nmodule.exports.deleteModel = mongoose.deleteModel;\nmodule.exports.modelNames = mongoose.modelNames;\nmodule.exports.plugin = mongoose.plugin;\nmodule.exports.connections = mongoose.connections;\nmodule.exports.version = mongoose.version;\nmodule.exports.Mongoose = mongoose.Mongoose;\nmodule.exports.Schema = mongoose.Schema;\nmodule.exports.SchemaType = mongoose.SchemaType;\nmodule.exports.SchemaTypes = mongoose.SchemaTypes;\nmodule.exports.VirtualType = mongoose.VirtualType;\nmodule.exports.Types = mongoose.Types;\nmodule.exports.Query = mongoose.Query;\nmodule.exports.Model = mongoose.Model;\nmodule.exports.Document = mongoose.Document;\nmodule.exports.ObjectId = mongoose.ObjectId;\nmodule.exports.isValidObjectId = mongoose.isValidObjectId;\nmodule.exports.isObjectIdOrHexString = mongoose.isObjectIdOrHexString;\nmodule.exports.syncIndexes = mongoose.syncIndexes;\nmodule.exports.Decimal128 = mongoose.Decimal128;\nmodule.exports.Mixed = mongoose.Mixed;\nmodule.exports.Date = mongoose.Date;\nmodule.exports.Number = mongoose.Number;\nmodule.exports.Error = mongoose.Error;\nmodule.exports.MongooseError = mongoose.MongooseError;\nmodule.exports.now = mongoose.now;\nmodule.exports.CastError = mongoose.CastError;\nmodule.exports.SchemaTypeOptions = mongoose.SchemaTypeOptions;\nmodule.exports.mongo = mongoose.mongo;\nmodule.exports.mquery = mongoose.mquery;\nmodule.exports.sanitizeFilter = mongoose.sanitizeFilter;\nmodule.exports.trusted = mongoose.trusted;\nmodule.exports.skipMiddlewareFunction = mongoose.skipMiddlewareFunction;\nmodule.exports.overwriteMiddlewareResult = mongoose.overwriteMiddlewareResult;\n\n// The following properties are not exported using ESM because `setDriver()` can mutate these\n// module.exports.connection = mongoose.connection;\n// module.exports.Collection = mongoose.Collection;\n// module.exports.Connection = mongoose.Connection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsaUJBQWlCLG1CQUFPLENBQUMsNkRBQVE7O0FBRWpDO0FBQ0EseUJBQXNCO0FBQ3RCLHVCQUF1Qjs7QUFFdkI7QUFDQSxtQkFBbUI7QUFDbkIscUJBQXFCO0FBQ3JCLHdCQUF3QjtBQUN4QixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLCtCQUErQjtBQUMvQixzQkFBc0I7QUFDdEIseUJBQXlCO0FBQ3pCLDJCQUEyQjtBQUMzQix3QkFBd0I7QUFDeEIsb0JBQW9CO0FBQ3BCLDBCQUEwQjtBQUMxQix5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLDBCQUEwQjtBQUMxQixzQkFBc0I7QUFDdEIsdUJBQXVCO0FBQ3ZCLHFCQUFxQjtBQUNyQix5QkFBeUI7QUFDekIsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQix1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLDhCQUE4QjtBQUM5QixvQ0FBb0M7QUFDcEMsMEJBQTBCO0FBQzFCLHlCQUF5QjtBQUN6QixvQkFBb0I7QUFDcEIsbUJBQW1CO0FBQ25CLHFCQUFxQjtBQUNyQixvQkFBb0I7QUFDcEIsNEJBQTRCO0FBQzVCLGtCQUFrQjtBQUNsQix3QkFBd0I7QUFDeEIsZ0NBQWdDO0FBQ2hDLG9CQUFvQjtBQUNwQixxQkFBcUI7QUFDckIsNkJBQTZCO0FBQzdCLHNCQUFzQjtBQUN0QixxQ0FBcUM7QUFDckMsd0NBQXdDOztBQUV4QztBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2luZGV4LmpzP2Y5YmIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFeHBvcnQgbGliL21vbmdvb3NlXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgbW9uZ29vc2UgPSByZXF1aXJlKCcuL2xpYi8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBtb25nb29zZTtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBtb25nb29zZTtcbm1vZHVsZS5leHBvcnRzLm1vbmdvb3NlID0gbW9uZ29vc2U7XG5cbi8vIFJlLWV4cG9ydCBmb3IgRVNNIHN1cHBvcnRcbm1vZHVsZS5leHBvcnRzLmNhc3QgPSBtb25nb29zZS5jYXN0O1xubW9kdWxlLmV4cG9ydHMuU1RBVEVTID0gbW9uZ29vc2UuU1RBVEVTO1xubW9kdWxlLmV4cG9ydHMuc2V0RHJpdmVyID0gbW9uZ29vc2Uuc2V0RHJpdmVyO1xubW9kdWxlLmV4cG9ydHMuc2V0ID0gbW9uZ29vc2Uuc2V0O1xubW9kdWxlLmV4cG9ydHMuZ2V0ID0gbW9uZ29vc2UuZ2V0O1xubW9kdWxlLmV4cG9ydHMuY3JlYXRlQ29ubmVjdGlvbiA9IG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb247XG5tb2R1bGUuZXhwb3J0cy5jb25uZWN0ID0gbW9uZ29vc2UuY29ubmVjdDtcbm1vZHVsZS5leHBvcnRzLmRpc2Nvbm5lY3QgPSBtb25nb29zZS5kaXNjb25uZWN0O1xubW9kdWxlLmV4cG9ydHMuc3RhcnRTZXNzaW9uID0gbW9uZ29vc2Uuc3RhcnRTZXNzaW9uO1xubW9kdWxlLmV4cG9ydHMucGx1cmFsaXplID0gbW9uZ29vc2UucGx1cmFsaXplO1xubW9kdWxlLmV4cG9ydHMubW9kZWwgPSBtb25nb29zZS5tb2RlbDtcbm1vZHVsZS5leHBvcnRzLmRlbGV0ZU1vZGVsID0gbW9uZ29vc2UuZGVsZXRlTW9kZWw7XG5tb2R1bGUuZXhwb3J0cy5tb2RlbE5hbWVzID0gbW9uZ29vc2UubW9kZWxOYW1lcztcbm1vZHVsZS5leHBvcnRzLnBsdWdpbiA9IG1vbmdvb3NlLnBsdWdpbjtcbm1vZHVsZS5leHBvcnRzLmNvbm5lY3Rpb25zID0gbW9uZ29vc2UuY29ubmVjdGlvbnM7XG5tb2R1bGUuZXhwb3J0cy52ZXJzaW9uID0gbW9uZ29vc2UudmVyc2lvbjtcbm1vZHVsZS5leHBvcnRzLk1vbmdvb3NlID0gbW9uZ29vc2UuTW9uZ29vc2U7XG5tb2R1bGUuZXhwb3J0cy5TY2hlbWEgPSBtb25nb29zZS5TY2hlbWE7XG5tb2R1bGUuZXhwb3J0cy5TY2hlbWFUeXBlID0gbW9uZ29vc2UuU2NoZW1hVHlwZTtcbm1vZHVsZS5leHBvcnRzLlNjaGVtYVR5cGVzID0gbW9uZ29vc2UuU2NoZW1hVHlwZXM7XG5tb2R1bGUuZXhwb3J0cy5WaXJ0dWFsVHlwZSA9IG1vbmdvb3NlLlZpcnR1YWxUeXBlO1xubW9kdWxlLmV4cG9ydHMuVHlwZXMgPSBtb25nb29zZS5UeXBlcztcbm1vZHVsZS5leHBvcnRzLlF1ZXJ5ID0gbW9uZ29vc2UuUXVlcnk7XG5tb2R1bGUuZXhwb3J0cy5Nb2RlbCA9IG1vbmdvb3NlLk1vZGVsO1xubW9kdWxlLmV4cG9ydHMuRG9jdW1lbnQgPSBtb25nb29zZS5Eb2N1bWVudDtcbm1vZHVsZS5leHBvcnRzLk9iamVjdElkID0gbW9uZ29vc2UuT2JqZWN0SWQ7XG5tb2R1bGUuZXhwb3J0cy5pc1ZhbGlkT2JqZWN0SWQgPSBtb25nb29zZS5pc1ZhbGlkT2JqZWN0SWQ7XG5tb2R1bGUuZXhwb3J0cy5pc09iamVjdElkT3JIZXhTdHJpbmcgPSBtb25nb29zZS5pc09iamVjdElkT3JIZXhTdHJpbmc7XG5tb2R1bGUuZXhwb3J0cy5zeW5jSW5kZXhlcyA9IG1vbmdvb3NlLnN5bmNJbmRleGVzO1xubW9kdWxlLmV4cG9ydHMuRGVjaW1hbDEyOCA9IG1vbmdvb3NlLkRlY2ltYWwxMjg7XG5tb2R1bGUuZXhwb3J0cy5NaXhlZCA9IG1vbmdvb3NlLk1peGVkO1xubW9kdWxlLmV4cG9ydHMuRGF0ZSA9IG1vbmdvb3NlLkRhdGU7XG5tb2R1bGUuZXhwb3J0cy5OdW1iZXIgPSBtb25nb29zZS5OdW1iZXI7XG5tb2R1bGUuZXhwb3J0cy5FcnJvciA9IG1vbmdvb3NlLkVycm9yO1xubW9kdWxlLmV4cG9ydHMuTW9uZ29vc2VFcnJvciA9IG1vbmdvb3NlLk1vbmdvb3NlRXJyb3I7XG5tb2R1bGUuZXhwb3J0cy5ub3cgPSBtb25nb29zZS5ub3c7XG5tb2R1bGUuZXhwb3J0cy5DYXN0RXJyb3IgPSBtb25nb29zZS5DYXN0RXJyb3I7XG5tb2R1bGUuZXhwb3J0cy5TY2hlbWFUeXBlT3B0aW9ucyA9IG1vbmdvb3NlLlNjaGVtYVR5cGVPcHRpb25zO1xubW9kdWxlLmV4cG9ydHMubW9uZ28gPSBtb25nb29zZS5tb25nbztcbm1vZHVsZS5leHBvcnRzLm1xdWVyeSA9IG1vbmdvb3NlLm1xdWVyeTtcbm1vZHVsZS5leHBvcnRzLnNhbml0aXplRmlsdGVyID0gbW9uZ29vc2Uuc2FuaXRpemVGaWx0ZXI7XG5tb2R1bGUuZXhwb3J0cy50cnVzdGVkID0gbW9uZ29vc2UudHJ1c3RlZDtcbm1vZHVsZS5leHBvcnRzLnNraXBNaWRkbGV3YXJlRnVuY3Rpb24gPSBtb25nb29zZS5za2lwTWlkZGxld2FyZUZ1bmN0aW9uO1xubW9kdWxlLmV4cG9ydHMub3ZlcndyaXRlTWlkZGxld2FyZVJlc3VsdCA9IG1vbmdvb3NlLm92ZXJ3cml0ZU1pZGRsZXdhcmVSZXN1bHQ7XG5cbi8vIFRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBhcmUgbm90IGV4cG9ydGVkIHVzaW5nIEVTTSBiZWNhdXNlIGBzZXREcml2ZXIoKWAgY2FuIG11dGF0ZSB0aGVzZVxuLy8gbW9kdWxlLmV4cG9ydHMuY29ubmVjdGlvbiA9IG1vbmdvb3NlLmNvbm5lY3Rpb247XG4vLyBtb2R1bGUuZXhwb3J0cy5Db2xsZWN0aW9uID0gbW9uZ29vc2UuQ29sbGVjdGlvbjtcbi8vIG1vZHVsZS5leHBvcnRzLkNvbm5lY3Rpb24gPSBtb25nb29zZS5Db25uZWN0aW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/index.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/aggregate.js":
/*!*********************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/aggregate.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies\n */\n\nconst AggregationCursor = __webpack_require__(/*! ./cursor/aggregationCursor */ \"../backend/node_modules/mongoose/lib/cursor/aggregationCursor.js\");\nconst MongooseError = __webpack_require__(/*! ./error/mongooseError */ \"../backend/node_modules/mongoose/lib/error/mongooseError.js\");\nconst Query = __webpack_require__(/*! ./query */ \"../backend/node_modules/mongoose/lib/query.js\");\nconst { applyGlobalMaxTimeMS, applyGlobalDiskUse } = __webpack_require__(/*! ./helpers/query/applyGlobalOption */ \"../backend/node_modules/mongoose/lib/helpers/query/applyGlobalOption.js\");\nconst clone = __webpack_require__(/*! ./helpers/clone */ \"../backend/node_modules/mongoose/lib/helpers/clone.js\");\nconst getConstructorName = __webpack_require__(/*! ./helpers/getConstructorName */ \"../backend/node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst prepareDiscriminatorPipeline = __webpack_require__(/*! ./helpers/aggregate/prepareDiscriminatorPipeline */ \"../backend/node_modules/mongoose/lib/helpers/aggregate/prepareDiscriminatorPipeline.js\");\nconst stringifyFunctionOperators = __webpack_require__(/*! ./helpers/aggregate/stringifyFunctionOperators */ \"../backend/node_modules/mongoose/lib/helpers/aggregate/stringifyFunctionOperators.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\nconst read = Query.prototype.read;\nconst readConcern = Query.prototype.readConcern;\n\nconst validRedactStringValues = new Set(['$$DESCEND', '$$PRUNE', '$$KEEP']);\n\n/**\n * Aggregate constructor used for building aggregation pipelines. Do not\n * instantiate this class directly, use [Model.aggregate()](https://mongoosejs.com/docs/api/model.html#Model.aggregate()) instead.\n *\n * #### Example:\n *\n *     const aggregate = Model.aggregate([\n *       { $project: { a: 1, b: 1 } },\n *       { $skip: 5 }\n *     ]);\n *\n *     Model.\n *       aggregate([{ $match: { age: { $gte: 21 }}}]).\n *       unwind('tags').\n *       exec();\n *\n * #### Note:\n *\n * - The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).\n * - Mongoose does **not** cast pipeline stages. The below will **not** work unless `_id` is a string in the database\n *\n *     new Aggregate([{ $match: { _id: '00000000000000000000000a' } }]);\n *     // Do this instead to cast to an ObjectId\n *     new Aggregate([{ $match: { _id: new mongoose.Types.ObjectId('00000000000000000000000a') } }]);\n *\n * @see MongoDB https://www.mongodb.com/docs/manual/applications/aggregation/\n * @see driver https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#aggregate\n * @param {Array} [pipeline] aggregation pipeline as an array of objects\n * @param {Model} [model] the model to use with this aggregate.\n * @api public\n */\n\nfunction Aggregate(pipeline, model) {\n  this._pipeline = [];\n  this._model = model;\n  this.options = {};\n\n  if (arguments.length === 1 && Array.isArray(pipeline)) {\n    this.append.apply(this, pipeline);\n  }\n}\n\n/**\n * Contains options passed down to the [aggregate command](https://www.mongodb.com/docs/manual/reference/command/aggregate/).\n * Supported options are:\n *\n * - [`allowDiskUse`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.allowDiskUse())\n * - `bypassDocumentValidation`\n * - [`collation`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.collation())\n * - `comment`\n * - [`cursor`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.cursor())\n * - [`explain`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.explain())\n * - `fieldsAsRaw`\n * - [`hint`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.hint())\n * - `let`\n * - `maxTimeMS`\n * - `raw`\n * - [`readConcern`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.readConcern())\n * - `readPreference`\n * - [`session`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.session())\n * - `writeConcern`\n *\n * @property options\n * @memberOf Aggregate\n * @api public\n */\n\nAggregate.prototype.options;\n\n/**\n * Get/set the model that this aggregation will execute on.\n *\n * #### Example:\n *\n *     const aggregate = MyModel.aggregate([{ $match: { answer: 42 } }]);\n *     aggregate.model() === MyModel; // true\n *\n *     // Change the model. There's rarely any reason to do this.\n *     aggregate.model(SomeOtherModel);\n *     aggregate.model() === SomeOtherModel; // true\n *\n * @param {Model} [model] Set the model associated with this aggregate. If not provided, returns the already stored model.\n * @return {Model}\n * @api public\n */\n\nAggregate.prototype.model = function(model) {\n  if (arguments.length === 0) {\n    return this._model;\n  }\n\n  this._model = model;\n  if (model.schema != null) {\n    if (this.options.readPreference == null &&\n      model.schema.options.read != null) {\n      this.options.readPreference = model.schema.options.read;\n    }\n    if (this.options.collation == null &&\n      model.schema.options.collation != null) {\n      this.options.collation = model.schema.options.collation;\n    }\n  }\n\n  return model;\n};\n\n/**\n * Appends new operators to this aggregate pipeline\n *\n * #### Example:\n *\n *     aggregate.append({ $project: { field: 1 }}, { $limit: 2 });\n *\n *     // or pass an array\n *     const pipeline = [{ $match: { daw: 'Logic Audio X' }} ];\n *     aggregate.append(pipeline);\n *\n * @param {...Object|Object[]} ops operator(s) to append. Can either be a spread of objects or a single parameter of a object array.\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.append = function() {\n  const args = (arguments.length === 1 && Array.isArray(arguments[0]))\n    ? arguments[0]\n    : [...arguments];\n\n  if (!args.every(isOperator)) {\n    throw new Error('Arguments must be aggregate pipeline operators');\n  }\n\n  this._pipeline = this._pipeline.concat(args);\n\n  return this;\n};\n\n/**\n * Appends a new $addFields operator to this aggregate pipeline.\n * Requires MongoDB v3.4+ to work\n *\n * #### Example:\n *\n *     // adding new fields based on existing fields\n *     aggregate.addFields({\n *         newField: '$b.nested'\n *       , plusTen: { $add: ['$val', 10]}\n *       , sub: {\n *            name: '$a'\n *         }\n *     })\n *\n *     // etc\n *     aggregate.addFields({ salary_k: { $divide: [ \"$salary\", 1000 ] } });\n *\n * @param {Object} arg field specification\n * @see $addFields https://www.mongodb.com/docs/manual/reference/operator/aggregation/addFields/\n * @return {Aggregate}\n * @api public\n */\nAggregate.prototype.addFields = function(arg) {\n  if (typeof arg !== 'object' || arg === null || Array.isArray(arg)) {\n    throw new Error('Invalid addFields() argument. Must be an object');\n  }\n  return this.append({ $addFields: Object.assign({}, arg) });\n};\n\n/**\n * Appends a new $project operator to this aggregate pipeline.\n *\n * Mongoose query [selection syntax](https://mongoosejs.com/docs/api/query.html#Query.prototype.select()) is also supported.\n *\n * #### Example:\n *\n *     // include a, include b, exclude _id\n *     aggregate.project(\"a b -_id\");\n *\n *     // or you may use object notation, useful when\n *     // you have keys already prefixed with a \"-\"\n *     aggregate.project({a: 1, b: 1, _id: 0});\n *\n *     // reshaping documents\n *     aggregate.project({\n *         newField: '$b.nested'\n *       , plusTen: { $add: ['$val', 10]}\n *       , sub: {\n *            name: '$a'\n *         }\n *     })\n *\n *     // etc\n *     aggregate.project({ salary_k: { $divide: [ \"$salary\", 1000 ] } });\n *\n * @param {Object|String} arg field specification\n * @see projection https://www.mongodb.com/docs/manual/reference/aggregation/project/\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.project = function(arg) {\n  const fields = {};\n\n  if (typeof arg === 'object' && !Array.isArray(arg)) {\n    Object.keys(arg).forEach(function(field) {\n      fields[field] = arg[field];\n    });\n  } else if (arguments.length === 1 && typeof arg === 'string') {\n    arg.split(/\\s+/).forEach(function(field) {\n      if (!field) {\n        return;\n      }\n      const include = field[0] === '-' ? 0 : 1;\n      if (include === 0) {\n        field = field.substring(1);\n      }\n      fields[field] = include;\n    });\n  } else {\n    throw new Error('Invalid project() argument. Must be string or object');\n  }\n\n  return this.append({ $project: fields });\n};\n\n/**\n * Appends a new custom $group operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *     aggregate.group({ _id: \"$department\" });\n *\n * @see $group https://www.mongodb.com/docs/manual/reference/aggregation/group/\n * @method group\n * @memberOf Aggregate\n * @instance\n * @param {Object} arg $group operator contents\n * @return {Aggregate}\n * @api public\n */\n\n/**\n * Appends a new custom $match operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *     aggregate.match({ department: { $in: [ \"sales\", \"engineering\" ] } });\n *\n * @see $match https://www.mongodb.com/docs/manual/reference/aggregation/match/\n * @method match\n * @memberOf Aggregate\n * @instance\n * @param {Object} arg $match operator contents\n * @return {Aggregate}\n * @api public\n */\n\n/**\n * Appends a new $skip operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *     aggregate.skip(10);\n *\n * @see $skip https://www.mongodb.com/docs/manual/reference/aggregation/skip/\n * @method skip\n * @memberOf Aggregate\n * @instance\n * @param {Number} num number of records to skip before next stage\n * @return {Aggregate}\n * @api public\n */\n\n/**\n * Appends a new $limit operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *     aggregate.limit(10);\n *\n * @see $limit https://www.mongodb.com/docs/manual/reference/aggregation/limit/\n * @method limit\n * @memberOf Aggregate\n * @instance\n * @param {Number} num maximum number of records to pass to the next stage\n * @return {Aggregate}\n * @api public\n */\n\n\n/**\n * Appends a new $densify operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *      aggregate.densify({\n *        field: 'timestamp',\n *        range: {\n *          step: 1,\n *          unit: 'hour',\n *          bounds: [new Date('2021-05-18T00:00:00.000Z'), new Date('2021-05-18T08:00:00.000Z')]\n *        }\n *      });\n *\n * @see $densify https://www.mongodb.com/docs/manual/reference/operator/aggregation/densify/\n * @method densify\n * @memberOf Aggregate\n * @instance\n * @param {Object} arg $densify operator contents\n * @return {Aggregate}\n * @api public\n */\n\n/**\n * Appends a new $fill operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *      aggregate.fill({\n *        output: {\n *          bootsSold: { value: 0 },\n *          sandalsSold: { value: 0 },\n *          sneakersSold: { value: 0 }\n *        }\n *      });\n *\n * @see $fill https://www.mongodb.com/docs/manual/reference/operator/aggregation/fill/\n * @method fill\n * @memberOf Aggregate\n * @instance\n * @param {Object} arg $fill operator contents\n * @return {Aggregate}\n * @api public\n */\n\n/**\n * Appends a new $geoNear operator to this aggregate pipeline.\n *\n * #### Note:\n *\n * **MUST** be used as the first operator in the pipeline.\n *\n * #### Example:\n *\n *     aggregate.near({\n *       near: { type: 'Point', coordinates: [40.724, -73.997] },\n *       distanceField: \"dist.calculated\", // required\n *       maxDistance: 0.008,\n *       query: { type: \"public\" },\n *       includeLocs: \"dist.location\",\n *       spherical: true,\n *     });\n *\n * @see $geoNear https://www.mongodb.com/docs/manual/reference/aggregation/geoNear/\n * @method near\n * @memberOf Aggregate\n * @instance\n * @param {Object} arg\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.near = function(arg) {\n  const op = {};\n  op.$geoNear = arg;\n  return this.append(op);\n};\n\n/*!\n * define methods\n */\n\n'group match skip limit out densify fill'.split(' ').forEach(function($operator) {\n  Aggregate.prototype[$operator] = function(arg) {\n    const op = {};\n    op['$' + $operator] = arg;\n    return this.append(op);\n  };\n});\n\n/**\n * Appends new custom $unwind operator(s) to this aggregate pipeline.\n *\n * Note that the `$unwind` operator requires the path name to start with '$'.\n * Mongoose will prepend '$' if the specified field doesn't start '$'.\n *\n * #### Example:\n *\n *     aggregate.unwind(\"tags\");\n *     aggregate.unwind(\"a\", \"b\", \"c\");\n *     aggregate.unwind({ path: '$tags', preserveNullAndEmptyArrays: true });\n *\n * @see $unwind https://www.mongodb.com/docs/manual/reference/aggregation/unwind/\n * @param {String|Object|String[]|Object[]} fields the field(s) to unwind, either as field names or as [objects with options](https://www.mongodb.com/docs/manual/reference/operator/aggregation/unwind/#document-operand-with-options). If passing a string, prefixing the field name with '$' is optional. If passing an object, `path` must start with '$'.\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.unwind = function() {\n  const args = [...arguments];\n\n  const res = [];\n  for (const arg of args) {\n    if (arg && typeof arg === 'object') {\n      res.push({ $unwind: arg });\n    } else if (typeof arg === 'string') {\n      res.push({\n        $unwind: (arg[0] === '$') ? arg : '$' + arg\n      });\n    } else {\n      throw new Error('Invalid arg \"' + arg + '\" to unwind(), ' +\n        'must be string or object');\n    }\n  }\n\n  return this.append.apply(this, res);\n};\n\n/**\n * Appends a new $replaceRoot operator to this aggregate pipeline.\n *\n * Note that the `$replaceRoot` operator requires field strings to start with '$'.\n * If you are passing in a string Mongoose will prepend '$' if the specified field doesn't start '$'.\n * If you are passing in an object the strings in your expression will not be altered.\n *\n * #### Example:\n *\n *     aggregate.replaceRoot(\"user\");\n *\n *     aggregate.replaceRoot({ x: { $concat: ['$this', '$that'] } });\n *\n * @see $replaceRoot https://www.mongodb.com/docs/manual/reference/operator/aggregation/replaceRoot\n * @param {String|Object} newRoot the field or document which will become the new root document\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.replaceRoot = function(newRoot) {\n  let ret;\n\n  if (typeof newRoot === 'string') {\n    ret = newRoot.startsWith('$') ? newRoot : '$' + newRoot;\n  } else {\n    ret = newRoot;\n  }\n\n  return this.append({\n    $replaceRoot: {\n      newRoot: ret\n    }\n  });\n};\n\n/**\n * Appends a new $count operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *     aggregate.count(\"userCount\");\n *\n * @see $count https://www.mongodb.com/docs/manual/reference/operator/aggregation/count\n * @param {String} fieldName The name of the output field which has the count as its value. It must be a non-empty string, must not start with $ and must not contain the . character.\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.count = function(fieldName) {\n  return this.append({ $count: fieldName });\n};\n\n/**\n * Appends a new $sortByCount operator to this aggregate pipeline. Accepts either a string field name\n * or a pipeline object.\n *\n * Note that the `$sortByCount` operator requires the new root to start with '$'.\n * Mongoose will prepend '$' if the specified field name doesn't start with '$'.\n *\n * #### Example:\n *\n *     aggregate.sortByCount('users');\n *     aggregate.sortByCount({ $mergeObjects: [ \"$employee\", \"$business\" ] })\n *\n * @see $sortByCount https://www.mongodb.com/docs/manual/reference/operator/aggregation/sortByCount/\n * @param {Object|String} arg\n * @return {Aggregate} this\n * @api public\n */\n\nAggregate.prototype.sortByCount = function(arg) {\n  if (arg && typeof arg === 'object') {\n    return this.append({ $sortByCount: arg });\n  } else if (typeof arg === 'string') {\n    return this.append({\n      $sortByCount: (arg[0] === '$') ? arg : '$' + arg\n    });\n  } else {\n    throw new TypeError('Invalid arg \"' + arg + '\" to sortByCount(), ' +\n      'must be string or object');\n  }\n};\n\n/**\n * Appends new custom $lookup operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *     aggregate.lookup({ from: 'users', localField: 'userId', foreignField: '_id', as: 'users' });\n *\n * @see $lookup https://www.mongodb.com/docs/manual/reference/operator/aggregation/lookup/#pipe._S_lookup\n * @param {Object} options to $lookup as described in the above link\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.lookup = function(options) {\n  return this.append({ $lookup: options });\n};\n\n/**\n * Appends new custom $graphLookup operator(s) to this aggregate pipeline, performing a recursive search on a collection.\n *\n * Note that graphLookup can only consume at most 100MB of memory, and does not allow disk use even if `{ allowDiskUse: true }` is specified.\n *\n * #### Example:\n *\n *      // Suppose we have a collection of courses, where a document might look like `{ _id: 0, name: 'Calculus', prerequisite: 'Trigonometry'}` and `{ _id: 0, name: 'Trigonometry', prerequisite: 'Algebra' }`\n *      aggregate.graphLookup({ from: 'courses', startWith: '$prerequisite', connectFromField: 'prerequisite', connectToField: 'name', as: 'prerequisites', maxDepth: 3 }) // this will recursively search the 'courses' collection up to 3 prerequisites\n *\n * @see $graphLookup https://www.mongodb.com/docs/manual/reference/operator/aggregation/graphLookup/#pipe._S_graphLookup\n * @param {Object} options to $graphLookup as described in the above link\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.graphLookup = function(options) {\n  const cloneOptions = {};\n  if (options) {\n    if (!utils.isObject(options)) {\n      throw new TypeError('Invalid graphLookup() argument. Must be an object.');\n    }\n\n    utils.mergeClone(cloneOptions, options);\n    const startWith = cloneOptions.startWith;\n\n    if (startWith && typeof startWith === 'string') {\n      cloneOptions.startWith = cloneOptions.startWith.startsWith('$') ?\n        cloneOptions.startWith :\n        '$' + cloneOptions.startWith;\n    }\n\n  }\n  return this.append({ $graphLookup: cloneOptions });\n};\n\n/**\n * Appends new custom $sample operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *     aggregate.sample(3); // Add a pipeline that picks 3 random documents\n *\n * @see $sample https://www.mongodb.com/docs/manual/reference/operator/aggregation/sample/#pipe._S_sample\n * @param {Number} size number of random documents to pick\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.sample = function(size) {\n  return this.append({ $sample: { size: size } });\n};\n\n/**\n * Appends a new $sort operator to this aggregate pipeline.\n *\n * If an object is passed, values allowed are `asc`, `desc`, `ascending`, `descending`, `1`, and `-1`.\n *\n * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.\n *\n * #### Example:\n *\n *     // these are equivalent\n *     aggregate.sort({ field: 'asc', test: -1 });\n *     aggregate.sort('field -test');\n *\n * @see $sort https://www.mongodb.com/docs/manual/reference/aggregation/sort/\n * @param {Object|String} arg\n * @return {Aggregate} this\n * @api public\n */\n\nAggregate.prototype.sort = function(arg) {\n  // TODO refactor to reuse the query builder logic\n\n  const sort = {};\n\n  if (getConstructorName(arg) === 'Object') {\n    const desc = ['desc', 'descending', -1];\n    Object.keys(arg).forEach(function(field) {\n      // If sorting by text score, skip coercing into 1/-1\n      if (arg[field] instanceof Object && arg[field].$meta) {\n        sort[field] = arg[field];\n        return;\n      }\n      sort[field] = desc.indexOf(arg[field]) === -1 ? 1 : -1;\n    });\n  } else if (arguments.length === 1 && typeof arg === 'string') {\n    arg.split(/\\s+/).forEach(function(field) {\n      if (!field) {\n        return;\n      }\n      const ascend = field[0] === '-' ? -1 : 1;\n      if (ascend === -1) {\n        field = field.substring(1);\n      }\n      sort[field] = ascend;\n    });\n  } else {\n    throw new TypeError('Invalid sort() argument. Must be a string or object.');\n  }\n\n  return this.append({ $sort: sort });\n};\n\n/**\n * Appends new $unionWith operator to this aggregate pipeline.\n *\n * #### Example:\n *\n *     aggregate.unionWith({ coll: 'users', pipeline: [ { $match: { _id: 1 } } ] });\n *\n * @see $unionWith https://www.mongodb.com/docs/manual/reference/operator/aggregation/unionWith\n * @param {Object} options to $unionWith query as described in the above link\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.unionWith = function(options) {\n  return this.append({ $unionWith: options });\n};\n\n\n/**\n * Sets the readPreference option for the aggregation query.\n *\n * #### Example:\n *\n *     await Model.aggregate(pipeline).read('primaryPreferred');\n *\n * @param {String|ReadPreference} pref one of the listed preference options or their aliases\n * @param {Array} [tags] optional tags for this query.\n * @return {Aggregate} this\n * @api public\n * @see mongodb https://www.mongodb.com/docs/manual/applications/replication/#read-preference\n */\n\nAggregate.prototype.read = function(pref, tags) {\n  read.call(this, pref, tags);\n  return this;\n};\n\n/**\n * Sets the readConcern level for the aggregation query.\n *\n * #### Example:\n *\n *     await Model.aggregate(pipeline).readConcern('majority');\n *\n * @param {String} level one of the listed read concern level or their aliases\n * @see mongodb https://www.mongodb.com/docs/manual/reference/read-concern/\n * @return {Aggregate} this\n * @api public\n */\n\nAggregate.prototype.readConcern = function(level) {\n  readConcern.call(this, level);\n  return this;\n};\n\n/**\n * Appends a new $redact operator to this aggregate pipeline.\n *\n * If 3 arguments are supplied, Mongoose will wrap them with if-then-else of $cond operator respectively\n * If `thenExpr` or `elseExpr` is string, make sure it starts with $$, like `$$DESCEND`, `$$PRUNE` or `$$KEEP`.\n *\n * #### Example:\n *\n *     await Model.aggregate(pipeline).redact({\n *       $cond: {\n *         if: { $eq: [ '$level', 5 ] },\n *         then: '$$PRUNE',\n *         else: '$$DESCEND'\n *       }\n *     });\n *\n *     // $redact often comes with $cond operator, you can also use the following syntax provided by mongoose\n *     await Model.aggregate(pipeline).redact({ $eq: [ '$level', 5 ] }, '$$PRUNE', '$$DESCEND');\n *\n * @param {Object} expression redact options or conditional expression\n * @param {String|Object} [thenExpr] true case for the condition\n * @param {String|Object} [elseExpr] false case for the condition\n * @return {Aggregate} this\n * @see $redact https://www.mongodb.com/docs/manual/reference/operator/aggregation/redact/\n * @api public\n */\n\nAggregate.prototype.redact = function(expression, thenExpr, elseExpr) {\n  if (arguments.length === 3) {\n    if ((typeof thenExpr === 'string' && !validRedactStringValues.has(thenExpr)) ||\n      (typeof elseExpr === 'string' && !validRedactStringValues.has(elseExpr))) {\n      throw new Error('If thenExpr or elseExpr is string, it must be either $$DESCEND, $$PRUNE or $$KEEP');\n    }\n\n    expression = {\n      $cond: {\n        if: expression,\n        then: thenExpr,\n        else: elseExpr\n      }\n    };\n  } else if (arguments.length !== 1) {\n    throw new TypeError('Invalid arguments');\n  }\n\n  return this.append({ $redact: expression });\n};\n\n/**\n * Execute the aggregation with explain\n *\n * #### Example:\n *\n *     Model.aggregate(..).explain()\n *\n * @param {String} [verbosity]\n * @return {Promise}\n */\n\nAggregate.prototype.explain = async function explain(verbosity) {\n  if (typeof verbosity === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Aggregate.prototype.explain() no longer accepts a callback');\n  }\n  const model = this._model;\n\n  if (!this._pipeline.length) {\n    throw new Error('Aggregate has empty pipeline');\n  }\n\n  prepareDiscriminatorPipeline(this._pipeline, this._model.schema);\n\n  await new Promise((resolve, reject) => {\n    model.hooks.execPre('aggregate', this, error => {\n      if (error) {\n        const _opts = { error: error };\n        return model.hooks.execPost('aggregate', this, [null], _opts, error => {\n          reject(error);\n        });\n      } else {\n        resolve();\n      }\n    });\n  });\n\n  const cursor = model.collection.aggregate(this._pipeline, this.options);\n\n  if (verbosity == null) {\n    verbosity = true;\n  }\n\n  let result = null;\n  try {\n    result = await cursor.explain(verbosity);\n  } catch (error) {\n    await new Promise((resolve, reject) => {\n      const _opts = { error: error };\n      model.hooks.execPost('aggregate', this, [null], _opts, error => {\n        if (error) {\n          return reject(error);\n        }\n        return resolve();\n      });\n    });\n  }\n\n  const _opts = { error: null };\n  await new Promise((resolve, reject) => {\n    model.hooks.execPost('aggregate', this, [result], _opts, error => {\n      if (error) {\n        return reject(error);\n      }\n      return resolve();\n    });\n  });\n\n  return result;\n};\n\n/**\n * Sets the allowDiskUse option for the aggregation query\n *\n * #### Example:\n *\n *     await Model.aggregate([{ $match: { foo: 'bar' } }]).allowDiskUse(true);\n *\n * @param {Boolean} value Should tell server it can use hard drive to store data during aggregation.\n * @return {Aggregate} this\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/aggregate/\n */\n\nAggregate.prototype.allowDiskUse = function(value) {\n  this.options.allowDiskUse = value;\n  return this;\n};\n\n/**\n * Sets the hint option for the aggregation query\n *\n * #### Example:\n *\n *     Model.aggregate(..).hint({ qty: 1, category: 1 }).exec();\n *\n * @param {Object|String} value a hint object or the index name\n * @return {Aggregate} this\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/aggregate/\n */\n\nAggregate.prototype.hint = function(value) {\n  this.options.hint = value;\n  return this;\n};\n\n/**\n * Sets the session for this aggregation. Useful for [transactions](https://mongoosejs.com/docs/transactions.html).\n *\n * #### Example:\n *\n *     const session = await Model.startSession();\n *     await Model.aggregate(..).session(session);\n *\n * @param {ClientSession} session\n * @return {Aggregate} this\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/aggregate/\n */\n\nAggregate.prototype.session = function(session) {\n  if (session == null) {\n    delete this.options.session;\n  } else {\n    this.options.session = session;\n  }\n  return this;\n};\n\n/**\n * Lets you set arbitrary options, for middleware or plugins.\n *\n * #### Example:\n *\n *     const agg = Model.aggregate(..).option({ allowDiskUse: true }); // Set the `allowDiskUse` option\n *     agg.options; // `{ allowDiskUse: true }`\n *\n * @param {Object} options keys to merge into current options\n * @param {Number} [options.maxTimeMS] number limits the time this aggregation will run, see [MongoDB docs on `maxTimeMS`](https://www.mongodb.com/docs/manual/reference/operator/meta/maxTimeMS/)\n * @param {Boolean} [options.allowDiskUse] boolean if true, the MongoDB server will use the hard drive to store data during this aggregation\n * @param {Object} [options.collation] object see [`Aggregate.prototype.collation()`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.collation())\n * @param {ClientSession} [options.session] ClientSession see [`Aggregate.prototype.session()`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.session())\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/aggregate/\n * @return {Aggregate} this\n * @api public\n */\n\nAggregate.prototype.option = function(value) {\n  for (const key in value) {\n    this.options[key] = value[key];\n  }\n  return this;\n};\n\n/**\n * Sets the `cursor` option and executes this aggregation, returning an aggregation cursor.\n * Cursors are useful if you want to process the results of the aggregation one-at-a-time\n * because the aggregation result is too big to fit into memory.\n *\n * #### Example:\n *\n *     const cursor = Model.aggregate(..).cursor({ batchSize: 1000 });\n *     cursor.eachAsync(function(doc, i) {\n *       // use doc\n *     });\n *\n * @param {Object} options\n * @param {Number} [options.batchSize] set the cursor batch size\n * @param {Boolean} [options.useMongooseAggCursor] use experimental mongoose-specific aggregation cursor (for `eachAsync()` and other query cursor semantics)\n * @return {AggregationCursor} cursor representing this aggregation\n * @api public\n * @see mongodb https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html\n */\n\nAggregate.prototype.cursor = function(options) {\n  this.options.cursor = options || {};\n  return new AggregationCursor(this); // return this;\n};\n\n/**\n * Adds a collation\n *\n * #### Example:\n *\n *     const res = await Model.aggregate(pipeline).collation({ locale: 'en_US', strength: 1 });\n *\n * @param {Object} collation options\n * @return {Aggregate} this\n * @api public\n * @see mongodb https://mongodb.github.io/node-mongodb-native/4.9/interfaces/CollationOptions.html\n */\n\nAggregate.prototype.collation = function(collation) {\n  this.options.collation = collation;\n  return this;\n};\n\n/**\n * Combines multiple aggregation pipelines.\n *\n * #### Example:\n *\n *     const res = await Model.aggregate().facet({\n *       books: [{ groupBy: '$author' }],\n *       price: [{ $bucketAuto: { groupBy: '$price', buckets: 2 } }]\n *     });\n *\n *     // Output: { books: [...], price: [{...}, {...}] }\n *\n * @param {Object} facet options\n * @return {Aggregate} this\n * @see $facet https://www.mongodb.com/docs/manual/reference/operator/aggregation/facet/\n * @api public\n */\n\nAggregate.prototype.facet = function(options) {\n  return this.append({ $facet: options });\n};\n\n/**\n * Helper for [Atlas Text Search](https://www.mongodb.com/docs/atlas/atlas-search/tutorial/)'s\n * `$search` stage.\n *\n * #### Example:\n *\n *     const res = await Model.aggregate().\n *      search({\n *        text: {\n *          query: 'baseball',\n *          path: 'plot'\n *        }\n *      });\n *\n *     // Output: [{ plot: '...', title: '...' }]\n *\n * @param {Object} $search options\n * @return {Aggregate} this\n * @see $search https://www.mongodb.com/docs/atlas/atlas-search/tutorial/\n * @api public\n */\n\nAggregate.prototype.search = function(options) {\n  return this.append({ $search: options });\n};\n\n/**\n * Returns the current pipeline\n *\n * #### Example:\n *\n *     MyModel.aggregate().match({ test: 1 }).pipeline(); // [{ $match: { test: 1 } }]\n *\n * @return {Array} The current pipeline similar to the operation that will be executed\n * @api public\n */\n\nAggregate.prototype.pipeline = function() {\n  return this._pipeline;\n};\n\n/**\n * Executes the aggregate pipeline on the currently bound Model.\n *\n * #### Example:\n *     const result = await aggregate.exec();\n *\n * @return {Promise}\n * @api public\n */\n\nAggregate.prototype.exec = async function exec() {\n  if (!this._model) {\n    throw new Error('Aggregate not bound to any Model');\n  }\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('Aggregate.prototype.exec() no longer accepts a callback');\n  }\n  const model = this._model;\n  const collection = this._model.collection;\n\n  applyGlobalMaxTimeMS(this.options, model.db.options, model.base.options);\n  applyGlobalDiskUse(this.options, model.db.options, model.base.options);\n\n  if (this.options && this.options.cursor) {\n    return new AggregationCursor(this);\n  }\n\n  prepareDiscriminatorPipeline(this._pipeline, this._model.schema);\n  stringifyFunctionOperators(this._pipeline);\n\n  await new Promise((resolve, reject) => {\n    model.hooks.execPre('aggregate', this, error => {\n      if (error) {\n        const _opts = { error: error };\n        return model.hooks.execPost('aggregate', this, [null], _opts, error => {\n          reject(error);\n        });\n      } else {\n        resolve();\n      }\n    });\n  });\n\n  if (!this._pipeline.length) {\n    throw new MongooseError('Aggregate has empty pipeline');\n  }\n\n  const options = clone(this.options || {});\n  let result;\n  try {\n    const cursor = await collection.aggregate(this._pipeline, options);\n    result = await cursor.toArray();\n  } catch (error) {\n    await new Promise((resolve, reject) => {\n      const _opts = { error: error };\n      model.hooks.execPost('aggregate', this, [null], _opts, (error) => {\n        if (error) {\n          return reject(error);\n        }\n\n        resolve();\n      });\n    });\n  }\n\n  const _opts = { error: null };\n  await new Promise((resolve, reject) => {\n    model.hooks.execPost('aggregate', this, [result], _opts, error => {\n      if (error) {\n        return reject(error);\n      }\n      return resolve();\n    });\n  });\n\n  return result;\n};\n\n/**\n * Provides a Promise-like `then` function, which will call `.exec` without a callback\n * Compatible with `await`.\n *\n * #### Example:\n *\n *     Model.aggregate(..).then(successCallback, errorCallback);\n *\n * @param {Function} [resolve] successCallback\n * @param {Function} [reject]  errorCallback\n * @return {Promise}\n */\nAggregate.prototype.then = function(resolve, reject) {\n  return this.exec().then(resolve, reject);\n};\n\n/**\n * Executes the aggregation returning a `Promise` which will be\n * resolved with either the doc(s) or rejected with the error.\n * Like [`.then()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.then), but only takes a rejection handler.\n * Compatible with `await`.\n *\n * @param {Function} [reject]\n * @return {Promise}\n * @api public\n */\n\nAggregate.prototype.catch = function(reject) {\n  return this.exec().then(null, reject);\n};\n\n/**\n * Executes the aggregate returning a `Promise` which will be\n * resolved with `.finally()` chained.\n *\n * More about [Promise `finally()` in JavaScript](https://thecodebarbarian.com/using-promise-finally-in-node-js.html).\n *\n * @param {Function} [onFinally]\n * @return {Promise}\n * @api public\n */\n\nAggregate.prototype.finally = function(onFinally) {\n  return this.exec().finally(onFinally);\n};\n\n/**\n * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js)\n * You do not need to call this function explicitly, the JavaScript runtime\n * will call it for you.\n *\n * #### Example:\n *\n *     const agg = Model.aggregate([{ $match: { age: { $gte: 25 } } }]);\n *     for await (const doc of agg) {\n *       console.log(doc.name);\n *     }\n *\n * Node.js 10.x supports async iterators natively without any flags. You can\n * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\n *\n * **Note:** This function is not set if `Symbol.asyncIterator` is undefined. If\n * `Symbol.asyncIterator` is undefined, that means your Node.js version does not\n * support async iterators.\n *\n * @method [Symbol.asyncIterator]\n * @memberOf Aggregate\n * @instance\n * @api public\n */\n\nif (Symbol.asyncIterator != null) {\n  Aggregate.prototype[Symbol.asyncIterator] = function() {\n    return this.cursor({ useMongooseAggCursor: true }).transformNull()._transformForAsyncIterator();\n  };\n}\n\n/*!\n * Helpers\n */\n\n/**\n * Checks whether an object is likely a pipeline operator\n *\n * @param {Object} obj object to check\n * @return {Boolean}\n * @api private\n */\n\nfunction isOperator(obj) {\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n\n  const k = Object.keys(obj);\n\n  return k.length === 1 && k[0][0] === '$';\n}\n\n/**\n * Adds the appropriate `$match` pipeline step to the top of an aggregate's\n * pipeline, should it's model is a non-root discriminator type. This is\n * analogous to the `prepareDiscriminatorCriteria` function in `lib/query.js`.\n *\n * @param {Aggregate} aggregate Aggregate to prepare\n * @api private\n */\n\nAggregate._prepareDiscriminatorPipeline = prepareDiscriminatorPipeline;\n\n/*!\n * Exports\n */\n\nmodule.exports = Aggregate;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2FnZ3JlZ2F0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLG1CQUFPLENBQUMsb0dBQTRCO0FBQzlELHNCQUFzQixtQkFBTyxDQUFDLDBGQUF1QjtBQUNyRCxjQUFjLG1CQUFPLENBQUMsOERBQVM7QUFDL0IsUUFBUSwyQ0FBMkMsRUFBRSxtQkFBTyxDQUFDLGtIQUFtQztBQUNoRyxjQUFjLG1CQUFPLENBQUMsOEVBQWlCO0FBQ3ZDLDJCQUEyQixtQkFBTyxDQUFDLHdHQUE4QjtBQUNqRSxxQ0FBcUMsbUJBQU8sQ0FBQyxnSkFBa0Q7QUFDL0YsbUNBQW1DLG1CQUFPLENBQUMsNElBQWdEO0FBQzNGLGNBQWMsbUJBQU8sQ0FBQyw4REFBUztBQUMvQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZLGNBQWM7QUFDckMsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixVQUFVLE9BQU8sWUFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFVBQVUsbUNBQW1DO0FBQ3JFO0FBQ0Esd0JBQXdCLFVBQVUsZ0VBQWdFO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxVQUFVLGNBQWM7QUFDdEUsc0NBQXNDO0FBQ3RD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bEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFVBQVUsT0FBTyxjQUFjO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsNEJBQTRCO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvYWdncmVnYXRlLmpzPzZlMjciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG5jb25zdCBBZ2dyZWdhdGlvbkN1cnNvciA9IHJlcXVpcmUoJy4vY3Vyc29yL2FnZ3JlZ2F0aW9uQ3Vyc29yJyk7XG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9tb25nb29zZUVycm9yJyk7XG5jb25zdCBRdWVyeSA9IHJlcXVpcmUoJy4vcXVlcnknKTtcbmNvbnN0IHsgYXBwbHlHbG9iYWxNYXhUaW1lTVMsIGFwcGx5R2xvYmFsRGlza1VzZSB9ID0gcmVxdWlyZSgnLi9oZWxwZXJzL3F1ZXJ5L2FwcGx5R2xvYmFsT3B0aW9uJyk7XG5jb25zdCBjbG9uZSA9IHJlcXVpcmUoJy4vaGVscGVycy9jbG9uZScpO1xuY29uc3QgZ2V0Q29uc3RydWN0b3JOYW1lID0gcmVxdWlyZSgnLi9oZWxwZXJzL2dldENvbnN0cnVjdG9yTmFtZScpO1xuY29uc3QgcHJlcGFyZURpc2NyaW1pbmF0b3JQaXBlbGluZSA9IHJlcXVpcmUoJy4vaGVscGVycy9hZ2dyZWdhdGUvcHJlcGFyZURpc2NyaW1pbmF0b3JQaXBlbGluZScpO1xuY29uc3Qgc3RyaW5naWZ5RnVuY3Rpb25PcGVyYXRvcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMvYWdncmVnYXRlL3N0cmluZ2lmeUZ1bmN0aW9uT3BlcmF0b3JzJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbmNvbnN0IHJlYWQgPSBRdWVyeS5wcm90b3R5cGUucmVhZDtcbmNvbnN0IHJlYWRDb25jZXJuID0gUXVlcnkucHJvdG90eXBlLnJlYWRDb25jZXJuO1xuXG5jb25zdCB2YWxpZFJlZGFjdFN0cmluZ1ZhbHVlcyA9IG5ldyBTZXQoWyckJERFU0NFTkQnLCAnJCRQUlVORScsICckJEtFRVAnXSk7XG5cbi8qKlxuICogQWdncmVnYXRlIGNvbnN0cnVjdG9yIHVzZWQgZm9yIGJ1aWxkaW5nIGFnZ3JlZ2F0aW9uIHBpcGVsaW5lcy4gRG8gbm90XG4gKiBpbnN0YW50aWF0ZSB0aGlzIGNsYXNzIGRpcmVjdGx5LCB1c2UgW01vZGVsLmFnZ3JlZ2F0ZSgpXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vZGVsLmh0bWwjTW9kZWwuYWdncmVnYXRlKCkpIGluc3RlYWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBhZ2dyZWdhdGUgPSBNb2RlbC5hZ2dyZWdhdGUoW1xuICogICAgICAgeyAkcHJvamVjdDogeyBhOiAxLCBiOiAxIH0gfSxcbiAqICAgICAgIHsgJHNraXA6IDUgfVxuICogICAgIF0pO1xuICpcbiAqICAgICBNb2RlbC5cbiAqICAgICAgIGFnZ3JlZ2F0ZShbeyAkbWF0Y2g6IHsgYWdlOiB7ICRndGU6IDIxIH19fV0pLlxuICogICAgICAgdW53aW5kKCd0YWdzJykuXG4gKiAgICAgICBleGVjKCk7XG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIC0gVGhlIGRvY3VtZW50cyByZXR1cm5lZCBhcmUgcGxhaW4gamF2YXNjcmlwdCBvYmplY3RzLCBub3QgbW9uZ29vc2UgZG9jdW1lbnRzIChzaW5jZSBhbnkgc2hhcGUgb2YgZG9jdW1lbnQgY2FuIGJlIHJldHVybmVkKS5cbiAqIC0gTW9uZ29vc2UgZG9lcyAqKm5vdCoqIGNhc3QgcGlwZWxpbmUgc3RhZ2VzLiBUaGUgYmVsb3cgd2lsbCAqKm5vdCoqIHdvcmsgdW5sZXNzIGBfaWRgIGlzIGEgc3RyaW5nIGluIHRoZSBkYXRhYmFzZVxuICpcbiAqICAgICBuZXcgQWdncmVnYXRlKFt7ICRtYXRjaDogeyBfaWQ6ICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGEnIH0gfV0pO1xuICogICAgIC8vIERvIHRoaXMgaW5zdGVhZCB0byBjYXN0IHRvIGFuIE9iamVjdElkXG4gKiAgICAgbmV3IEFnZ3JlZ2F0ZShbeyAkbWF0Y2g6IHsgX2lkOiBuZXcgbW9uZ29vc2UuVHlwZXMuT2JqZWN0SWQoJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwYScpIH0gfV0pO1xuICpcbiAqIEBzZWUgTW9uZ29EQiBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9hcHBsaWNhdGlvbnMvYWdncmVnYXRpb24vXG4gKiBAc2VlIGRyaXZlciBodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvQ29sbGVjdGlvbi5odG1sI2FnZ3JlZ2F0ZVxuICogQHBhcmFtIHtBcnJheX0gW3BpcGVsaW5lXSBhZ2dyZWdhdGlvbiBwaXBlbGluZSBhcyBhbiBhcnJheSBvZiBvYmplY3RzXG4gKiBAcGFyYW0ge01vZGVsfSBbbW9kZWxdIHRoZSBtb2RlbCB0byB1c2Ugd2l0aCB0aGlzIGFnZ3JlZ2F0ZS5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gQWdncmVnYXRlKHBpcGVsaW5lLCBtb2RlbCkge1xuICB0aGlzLl9waXBlbGluZSA9IFtdO1xuICB0aGlzLl9tb2RlbCA9IG1vZGVsO1xuICB0aGlzLm9wdGlvbnMgPSB7fTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KHBpcGVsaW5lKSkge1xuICAgIHRoaXMuYXBwZW5kLmFwcGx5KHRoaXMsIHBpcGVsaW5lKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnRhaW5zIG9wdGlvbnMgcGFzc2VkIGRvd24gdG8gdGhlIFthZ2dyZWdhdGUgY29tbWFuZF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2NvbW1hbmQvYWdncmVnYXRlLykuXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogLSBbYGFsbG93RGlza1VzZWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvYWdncmVnYXRlLmh0bWwjQWdncmVnYXRlLnByb3RvdHlwZS5hbGxvd0Rpc2tVc2UoKSlcbiAqIC0gYGJ5cGFzc0RvY3VtZW50VmFsaWRhdGlvbmBcbiAqIC0gW2Bjb2xsYXRpb25gXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2FnZ3JlZ2F0ZS5odG1sI0FnZ3JlZ2F0ZS5wcm90b3R5cGUuY29sbGF0aW9uKCkpXG4gKiAtIGBjb21tZW50YFxuICogLSBbYGN1cnNvcmBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvYWdncmVnYXRlLmh0bWwjQWdncmVnYXRlLnByb3RvdHlwZS5jdXJzb3IoKSlcbiAqIC0gW2BleHBsYWluYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9hZ2dyZWdhdGUuaHRtbCNBZ2dyZWdhdGUucHJvdG90eXBlLmV4cGxhaW4oKSlcbiAqIC0gYGZpZWxkc0FzUmF3YFxuICogLSBbYGhpbnRgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2FnZ3JlZ2F0ZS5odG1sI0FnZ3JlZ2F0ZS5wcm90b3R5cGUuaGludCgpKVxuICogLSBgbGV0YFxuICogLSBgbWF4VGltZU1TYFxuICogLSBgcmF3YFxuICogLSBbYHJlYWRDb25jZXJuYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9hZ2dyZWdhdGUuaHRtbCNBZ2dyZWdhdGUucHJvdG90eXBlLnJlYWRDb25jZXJuKCkpXG4gKiAtIGByZWFkUHJlZmVyZW5jZWBcbiAqIC0gW2BzZXNzaW9uYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9hZ2dyZWdhdGUuaHRtbCNBZ2dyZWdhdGUucHJvdG90eXBlLnNlc3Npb24oKSlcbiAqIC0gYHdyaXRlQ29uY2VybmBcbiAqXG4gKiBAcHJvcGVydHkgb3B0aW9uc1xuICogQG1lbWJlck9mIEFnZ3JlZ2F0ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLm9wdGlvbnM7XG5cbi8qKlxuICogR2V0L3NldCB0aGUgbW9kZWwgdGhhdCB0aGlzIGFnZ3JlZ2F0aW9uIHdpbGwgZXhlY3V0ZSBvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGFnZ3JlZ2F0ZSA9IE15TW9kZWwuYWdncmVnYXRlKFt7ICRtYXRjaDogeyBhbnN3ZXI6IDQyIH0gfV0pO1xuICogICAgIGFnZ3JlZ2F0ZS5tb2RlbCgpID09PSBNeU1vZGVsOyAvLyB0cnVlXG4gKlxuICogICAgIC8vIENoYW5nZSB0aGUgbW9kZWwuIFRoZXJlJ3MgcmFyZWx5IGFueSByZWFzb24gdG8gZG8gdGhpcy5cbiAqICAgICBhZ2dyZWdhdGUubW9kZWwoU29tZU90aGVyTW9kZWwpO1xuICogICAgIGFnZ3JlZ2F0ZS5tb2RlbCgpID09PSBTb21lT3RoZXJNb2RlbDsgLy8gdHJ1ZVxuICpcbiAqIEBwYXJhbSB7TW9kZWx9IFttb2RlbF0gU2V0IHRoZSBtb2RlbCBhc3NvY2lhdGVkIHdpdGggdGhpcyBhZ2dyZWdhdGUuIElmIG5vdCBwcm92aWRlZCwgcmV0dXJucyB0aGUgYWxyZWFkeSBzdG9yZWQgbW9kZWwuXG4gKiBAcmV0dXJuIHtNb2RlbH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS5tb2RlbCA9IGZ1bmN0aW9uKG1vZGVsKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGVsO1xuICB9XG5cbiAgdGhpcy5fbW9kZWwgPSBtb2RlbDtcbiAgaWYgKG1vZGVsLnNjaGVtYSAhPSBudWxsKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZWFkUHJlZmVyZW5jZSA9PSBudWxsICYmXG4gICAgICBtb2RlbC5zY2hlbWEub3B0aW9ucy5yZWFkICE9IG51bGwpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5yZWFkUHJlZmVyZW5jZSA9IG1vZGVsLnNjaGVtYS5vcHRpb25zLnJlYWQ7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuY29sbGF0aW9uID09IG51bGwgJiZcbiAgICAgIG1vZGVsLnNjaGVtYS5vcHRpb25zLmNvbGxhdGlvbiAhPSBudWxsKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuY29sbGF0aW9uID0gbW9kZWwuc2NoZW1hLm9wdGlvbnMuY29sbGF0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtb2RlbDtcbn07XG5cbi8qKlxuICogQXBwZW5kcyBuZXcgb3BlcmF0b3JzIHRvIHRoaXMgYWdncmVnYXRlIHBpcGVsaW5lXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhZ2dyZWdhdGUuYXBwZW5kKHsgJHByb2plY3Q6IHsgZmllbGQ6IDEgfX0sIHsgJGxpbWl0OiAyIH0pO1xuICpcbiAqICAgICAvLyBvciBwYXNzIGFuIGFycmF5XG4gKiAgICAgY29uc3QgcGlwZWxpbmUgPSBbeyAkbWF0Y2g6IHsgZGF3OiAnTG9naWMgQXVkaW8gWCcgfX0gXTtcbiAqICAgICBhZ2dyZWdhdGUuYXBwZW5kKHBpcGVsaW5lKTtcbiAqXG4gKiBAcGFyYW0gey4uLk9iamVjdHxPYmplY3RbXX0gb3BzIG9wZXJhdG9yKHMpIHRvIGFwcGVuZC4gQ2FuIGVpdGhlciBiZSBhIHNwcmVhZCBvZiBvYmplY3RzIG9yIGEgc2luZ2xlIHBhcmFtZXRlciBvZiBhIG9iamVjdCBhcnJheS5cbiAqIEByZXR1cm4ge0FnZ3JlZ2F0ZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgYXJncyA9IChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSlcbiAgICA/IGFyZ3VtZW50c1swXVxuICAgIDogWy4uLmFyZ3VtZW50c107XG5cbiAgaWYgKCFhcmdzLmV2ZXJ5KGlzT3BlcmF0b3IpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBhZ2dyZWdhdGUgcGlwZWxpbmUgb3BlcmF0b3JzJyk7XG4gIH1cblxuICB0aGlzLl9waXBlbGluZSA9IHRoaXMuX3BpcGVsaW5lLmNvbmNhdChhcmdzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQXBwZW5kcyBhIG5ldyAkYWRkRmllbGRzIG9wZXJhdG9yIHRvIHRoaXMgYWdncmVnYXRlIHBpcGVsaW5lLlxuICogUmVxdWlyZXMgTW9uZ29EQiB2My40KyB0byB3b3JrXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBhZGRpbmcgbmV3IGZpZWxkcyBiYXNlZCBvbiBleGlzdGluZyBmaWVsZHNcbiAqICAgICBhZ2dyZWdhdGUuYWRkRmllbGRzKHtcbiAqICAgICAgICAgbmV3RmllbGQ6ICckYi5uZXN0ZWQnXG4gKiAgICAgICAsIHBsdXNUZW46IHsgJGFkZDogWyckdmFsJywgMTBdfVxuICogICAgICAgLCBzdWI6IHtcbiAqICAgICAgICAgICAgbmFtZTogJyRhJ1xuICogICAgICAgICB9XG4gKiAgICAgfSlcbiAqXG4gKiAgICAgLy8gZXRjXG4gKiAgICAgYWdncmVnYXRlLmFkZEZpZWxkcyh7IHNhbGFyeV9rOiB7ICRkaXZpZGU6IFsgXCIkc2FsYXJ5XCIsIDEwMDAgXSB9IH0pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmcgZmllbGQgc3BlY2lmaWNhdGlvblxuICogQHNlZSAkYWRkRmllbGRzIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9hZ2dyZWdhdGlvbi9hZGRGaWVsZHMvXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGV9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5BZ2dyZWdhdGUucHJvdG90eXBlLmFkZEZpZWxkcyA9IGZ1bmN0aW9uKGFyZykge1xuICBpZiAodHlwZW9mIGFyZyAhPT0gJ29iamVjdCcgfHwgYXJnID09PSBudWxsIHx8IEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZGRGaWVsZHMoKSBhcmd1bWVudC4gTXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgfVxuICByZXR1cm4gdGhpcy5hcHBlbmQoeyAkYWRkRmllbGRzOiBPYmplY3QuYXNzaWduKHt9LCBhcmcpIH0pO1xufTtcblxuLyoqXG4gKiBBcHBlbmRzIGEgbmV3ICRwcm9qZWN0IG9wZXJhdG9yIHRvIHRoaXMgYWdncmVnYXRlIHBpcGVsaW5lLlxuICpcbiAqIE1vbmdvb3NlIHF1ZXJ5IFtzZWxlY3Rpb24gc3ludGF4XShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNlbGVjdCgpKSBpcyBhbHNvIHN1cHBvcnRlZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIGluY2x1ZGUgYSwgaW5jbHVkZSBiLCBleGNsdWRlIF9pZFxuICogICAgIGFnZ3JlZ2F0ZS5wcm9qZWN0KFwiYSBiIC1faWRcIik7XG4gKlxuICogICAgIC8vIG9yIHlvdSBtYXkgdXNlIG9iamVjdCBub3RhdGlvbiwgdXNlZnVsIHdoZW5cbiAqICAgICAvLyB5b3UgaGF2ZSBrZXlzIGFscmVhZHkgcHJlZml4ZWQgd2l0aCBhIFwiLVwiXG4gKiAgICAgYWdncmVnYXRlLnByb2plY3Qoe2E6IDEsIGI6IDEsIF9pZDogMH0pO1xuICpcbiAqICAgICAvLyByZXNoYXBpbmcgZG9jdW1lbnRzXG4gKiAgICAgYWdncmVnYXRlLnByb2plY3Qoe1xuICogICAgICAgICBuZXdGaWVsZDogJyRiLm5lc3RlZCdcbiAqICAgICAgICwgcGx1c1RlbjogeyAkYWRkOiBbJyR2YWwnLCAxMF19XG4gKiAgICAgICAsIHN1Yjoge1xuICogICAgICAgICAgICBuYW1lOiAnJGEnXG4gKiAgICAgICAgIH1cbiAqICAgICB9KVxuICpcbiAqICAgICAvLyBldGNcbiAqICAgICBhZ2dyZWdhdGUucHJvamVjdCh7IHNhbGFyeV9rOiB7ICRkaXZpZGU6IFsgXCIkc2FsYXJ5XCIsIDEwMDAgXSB9IH0pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gYXJnIGZpZWxkIHNwZWNpZmljYXRpb25cbiAqIEBzZWUgcHJvamVjdGlvbiBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvYWdncmVnYXRpb24vcHJvamVjdC9cbiAqIEByZXR1cm4ge0FnZ3JlZ2F0ZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS5wcm9qZWN0ID0gZnVuY3Rpb24oYXJnKSB7XG4gIGNvbnN0IGZpZWxkcyA9IHt9O1xuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgT2JqZWN0LmtleXMoYXJnKS5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgICBmaWVsZHNbZmllbGRdID0gYXJnW2ZpZWxkXTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgYXJnLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbihmaWVsZCkge1xuICAgICAgaWYgKCFmaWVsZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpbmNsdWRlID0gZmllbGRbMF0gPT09ICctJyA/IDAgOiAxO1xuICAgICAgaWYgKGluY2x1ZGUgPT09IDApIHtcbiAgICAgICAgZmllbGQgPSBmaWVsZC5zdWJzdHJpbmcoMSk7XG4gICAgICB9XG4gICAgICBmaWVsZHNbZmllbGRdID0gaW5jbHVkZTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJvamVjdCgpIGFyZ3VtZW50LiBNdXN0IGJlIHN0cmluZyBvciBvYmplY3QnKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmFwcGVuZCh7ICRwcm9qZWN0OiBmaWVsZHMgfSk7XG59O1xuXG4vKipcbiAqIEFwcGVuZHMgYSBuZXcgY3VzdG9tICRncm91cCBvcGVyYXRvciB0byB0aGlzIGFnZ3JlZ2F0ZSBwaXBlbGluZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGFnZ3JlZ2F0ZS5ncm91cCh7IF9pZDogXCIkZGVwYXJ0bWVudFwiIH0pO1xuICpcbiAqIEBzZWUgJGdyb3VwIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9hZ2dyZWdhdGlvbi9ncm91cC9cbiAqIEBtZXRob2QgZ3JvdXBcbiAqIEBtZW1iZXJPZiBBZ2dyZWdhdGVcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R9IGFyZyAkZ3JvdXAgb3BlcmF0b3IgY29udGVudHNcbiAqIEByZXR1cm4ge0FnZ3JlZ2F0ZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBBcHBlbmRzIGEgbmV3IGN1c3RvbSAkbWF0Y2ggb3BlcmF0b3IgdG8gdGhpcyBhZ2dyZWdhdGUgcGlwZWxpbmUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhZ2dyZWdhdGUubWF0Y2goeyBkZXBhcnRtZW50OiB7ICRpbjogWyBcInNhbGVzXCIsIFwiZW5naW5lZXJpbmdcIiBdIH0gfSk7XG4gKlxuICogQHNlZSAkbWF0Y2ggaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2FnZ3JlZ2F0aW9uL21hdGNoL1xuICogQG1ldGhvZCBtYXRjaFxuICogQG1lbWJlck9mIEFnZ3JlZ2F0ZVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge09iamVjdH0gYXJnICRtYXRjaCBvcGVyYXRvciBjb250ZW50c1xuICogQHJldHVybiB7QWdncmVnYXRlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIEFwcGVuZHMgYSBuZXcgJHNraXAgb3BlcmF0b3IgdG8gdGhpcyBhZ2dyZWdhdGUgcGlwZWxpbmUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhZ2dyZWdhdGUuc2tpcCgxMCk7XG4gKlxuICogQHNlZSAkc2tpcCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvYWdncmVnYXRpb24vc2tpcC9cbiAqIEBtZXRob2Qgc2tpcFxuICogQG1lbWJlck9mIEFnZ3JlZ2F0ZVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge051bWJlcn0gbnVtIG51bWJlciBvZiByZWNvcmRzIHRvIHNraXAgYmVmb3JlIG5leHQgc3RhZ2VcbiAqIEByZXR1cm4ge0FnZ3JlZ2F0ZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBBcHBlbmRzIGEgbmV3ICRsaW1pdCBvcGVyYXRvciB0byB0aGlzIGFnZ3JlZ2F0ZSBwaXBlbGluZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGFnZ3JlZ2F0ZS5saW1pdCgxMCk7XG4gKlxuICogQHNlZSAkbGltaXQgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2FnZ3JlZ2F0aW9uL2xpbWl0L1xuICogQG1ldGhvZCBsaW1pdFxuICogQG1lbWJlck9mIEFnZ3JlZ2F0ZVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge051bWJlcn0gbnVtIG1heGltdW0gbnVtYmVyIG9mIHJlY29yZHMgdG8gcGFzcyB0byB0aGUgbmV4dCBzdGFnZVxuICogQHJldHVybiB7QWdncmVnYXRlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cbi8qKlxuICogQXBwZW5kcyBhIG5ldyAkZGVuc2lmeSBvcGVyYXRvciB0byB0aGlzIGFnZ3JlZ2F0ZSBwaXBlbGluZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgICBhZ2dyZWdhdGUuZGVuc2lmeSh7XG4gKiAgICAgICAgZmllbGQ6ICd0aW1lc3RhbXAnLFxuICogICAgICAgIHJhbmdlOiB7XG4gKiAgICAgICAgICBzdGVwOiAxLFxuICogICAgICAgICAgdW5pdDogJ2hvdXInLFxuICogICAgICAgICAgYm91bmRzOiBbbmV3IERhdGUoJzIwMjEtMDUtMThUMDA6MDA6MDAuMDAwWicpLCBuZXcgRGF0ZSgnMjAyMS0wNS0xOFQwODowMDowMC4wMDBaJyldXG4gKiAgICAgICAgfVxuICogICAgICB9KTtcbiAqXG4gKiBAc2VlICRkZW5zaWZ5IGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9hZ2dyZWdhdGlvbi9kZW5zaWZ5L1xuICogQG1ldGhvZCBkZW5zaWZ5XG4gKiBAbWVtYmVyT2YgQWdncmVnYXRlXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmcgJGRlbnNpZnkgb3BlcmF0b3IgY29udGVudHNcbiAqIEByZXR1cm4ge0FnZ3JlZ2F0ZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBBcHBlbmRzIGEgbmV3ICRmaWxsIG9wZXJhdG9yIHRvIHRoaXMgYWdncmVnYXRlIHBpcGVsaW5lLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgIGFnZ3JlZ2F0ZS5maWxsKHtcbiAqICAgICAgICBvdXRwdXQ6IHtcbiAqICAgICAgICAgIGJvb3RzU29sZDogeyB2YWx1ZTogMCB9LFxuICogICAgICAgICAgc2FuZGFsc1NvbGQ6IHsgdmFsdWU6IDAgfSxcbiAqICAgICAgICAgIHNuZWFrZXJzU29sZDogeyB2YWx1ZTogMCB9XG4gKiAgICAgICAgfVxuICogICAgICB9KTtcbiAqXG4gKiBAc2VlICRmaWxsIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9hZ2dyZWdhdGlvbi9maWxsL1xuICogQG1ldGhvZCBmaWxsXG4gKiBAbWVtYmVyT2YgQWdncmVnYXRlXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmcgJGZpbGwgb3BlcmF0b3IgY29udGVudHNcbiAqIEByZXR1cm4ge0FnZ3JlZ2F0ZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBBcHBlbmRzIGEgbmV3ICRnZW9OZWFyIG9wZXJhdG9yIHRvIHRoaXMgYWdncmVnYXRlIHBpcGVsaW5lLlxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiAqKk1VU1QqKiBiZSB1c2VkIGFzIHRoZSBmaXJzdCBvcGVyYXRvciBpbiB0aGUgcGlwZWxpbmUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhZ2dyZWdhdGUubmVhcih7XG4gKiAgICAgICBuZWFyOiB7IHR5cGU6ICdQb2ludCcsIGNvb3JkaW5hdGVzOiBbNDAuNzI0LCAtNzMuOTk3XSB9LFxuICogICAgICAgZGlzdGFuY2VGaWVsZDogXCJkaXN0LmNhbGN1bGF0ZWRcIiwgLy8gcmVxdWlyZWRcbiAqICAgICAgIG1heERpc3RhbmNlOiAwLjAwOCxcbiAqICAgICAgIHF1ZXJ5OiB7IHR5cGU6IFwicHVibGljXCIgfSxcbiAqICAgICAgIGluY2x1ZGVMb2NzOiBcImRpc3QubG9jYXRpb25cIixcbiAqICAgICAgIHNwaGVyaWNhbDogdHJ1ZSxcbiAqICAgICB9KTtcbiAqXG4gKiBAc2VlICRnZW9OZWFyIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9hZ2dyZWdhdGlvbi9nZW9OZWFyL1xuICogQG1ldGhvZCBuZWFyXG4gKiBAbWVtYmVyT2YgQWdncmVnYXRlXG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmdcbiAqIEByZXR1cm4ge0FnZ3JlZ2F0ZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS5uZWFyID0gZnVuY3Rpb24oYXJnKSB7XG4gIGNvbnN0IG9wID0ge307XG4gIG9wLiRnZW9OZWFyID0gYXJnO1xuICByZXR1cm4gdGhpcy5hcHBlbmQob3ApO1xufTtcblxuLyohXG4gKiBkZWZpbmUgbWV0aG9kc1xuICovXG5cbidncm91cCBtYXRjaCBza2lwIGxpbWl0IG91dCBkZW5zaWZ5IGZpbGwnLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbigkb3BlcmF0b3IpIHtcbiAgQWdncmVnYXRlLnByb3RvdHlwZVskb3BlcmF0b3JdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgY29uc3Qgb3AgPSB7fTtcbiAgICBvcFsnJCcgKyAkb3BlcmF0b3JdID0gYXJnO1xuICAgIHJldHVybiB0aGlzLmFwcGVuZChvcCk7XG4gIH07XG59KTtcblxuLyoqXG4gKiBBcHBlbmRzIG5ldyBjdXN0b20gJHVud2luZCBvcGVyYXRvcihzKSB0byB0aGlzIGFnZ3JlZ2F0ZSBwaXBlbGluZS5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIGAkdW53aW5kYCBvcGVyYXRvciByZXF1aXJlcyB0aGUgcGF0aCBuYW1lIHRvIHN0YXJ0IHdpdGggJyQnLlxuICogTW9uZ29vc2Ugd2lsbCBwcmVwZW5kICckJyBpZiB0aGUgc3BlY2lmaWVkIGZpZWxkIGRvZXNuJ3Qgc3RhcnQgJyQnLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYWdncmVnYXRlLnVud2luZChcInRhZ3NcIik7XG4gKiAgICAgYWdncmVnYXRlLnVud2luZChcImFcIiwgXCJiXCIsIFwiY1wiKTtcbiAqICAgICBhZ2dyZWdhdGUudW53aW5kKHsgcGF0aDogJyR0YWdzJywgcHJlc2VydmVOdWxsQW5kRW1wdHlBcnJheXM6IHRydWUgfSk7XG4gKlxuICogQHNlZSAkdW53aW5kIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9hZ2dyZWdhdGlvbi91bndpbmQvXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8U3RyaW5nW118T2JqZWN0W119IGZpZWxkcyB0aGUgZmllbGQocykgdG8gdW53aW5kLCBlaXRoZXIgYXMgZmllbGQgbmFtZXMgb3IgYXMgW29iamVjdHMgd2l0aCBvcHRpb25zXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvYWdncmVnYXRpb24vdW53aW5kLyNkb2N1bWVudC1vcGVyYW5kLXdpdGgtb3B0aW9ucykuIElmIHBhc3NpbmcgYSBzdHJpbmcsIHByZWZpeGluZyB0aGUgZmllbGQgbmFtZSB3aXRoICckJyBpcyBvcHRpb25hbC4gSWYgcGFzc2luZyBhbiBvYmplY3QsIGBwYXRoYCBtdXN0IHN0YXJ0IHdpdGggJyQnLlxuICogQHJldHVybiB7QWdncmVnYXRlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLnVud2luZCA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBhcmdzID0gWy4uLmFyZ3VtZW50c107XG5cbiAgY29uc3QgcmVzID0gW107XG4gIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHtcbiAgICBpZiAoYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXMucHVzaCh7ICR1bndpbmQ6IGFyZyB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXMucHVzaCh7XG4gICAgICAgICR1bndpbmQ6IChhcmdbMF0gPT09ICckJykgPyBhcmcgOiAnJCcgKyBhcmdcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJnIFwiJyArIGFyZyArICdcIiB0byB1bndpbmQoKSwgJyArXG4gICAgICAgICdtdXN0IGJlIHN0cmluZyBvciBvYmplY3QnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcy5hcHBlbmQuYXBwbHkodGhpcywgcmVzKTtcbn07XG5cbi8qKlxuICogQXBwZW5kcyBhIG5ldyAkcmVwbGFjZVJvb3Qgb3BlcmF0b3IgdG8gdGhpcyBhZ2dyZWdhdGUgcGlwZWxpbmUuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBgJHJlcGxhY2VSb290YCBvcGVyYXRvciByZXF1aXJlcyBmaWVsZCBzdHJpbmdzIHRvIHN0YXJ0IHdpdGggJyQnLlxuICogSWYgeW91IGFyZSBwYXNzaW5nIGluIGEgc3RyaW5nIE1vbmdvb3NlIHdpbGwgcHJlcGVuZCAnJCcgaWYgdGhlIHNwZWNpZmllZCBmaWVsZCBkb2Vzbid0IHN0YXJ0ICckJy5cbiAqIElmIHlvdSBhcmUgcGFzc2luZyBpbiBhbiBvYmplY3QgdGhlIHN0cmluZ3MgaW4geW91ciBleHByZXNzaW9uIHdpbGwgbm90IGJlIGFsdGVyZWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhZ2dyZWdhdGUucmVwbGFjZVJvb3QoXCJ1c2VyXCIpO1xuICpcbiAqICAgICBhZ2dyZWdhdGUucmVwbGFjZVJvb3QoeyB4OiB7ICRjb25jYXQ6IFsnJHRoaXMnLCAnJHRoYXQnXSB9IH0pO1xuICpcbiAqIEBzZWUgJHJlcGxhY2VSb290IGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9hZ2dyZWdhdGlvbi9yZXBsYWNlUm9vdFxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBuZXdSb290IHRoZSBmaWVsZCBvciBkb2N1bWVudCB3aGljaCB3aWxsIGJlY29tZSB0aGUgbmV3IHJvb3QgZG9jdW1lbnRcbiAqIEByZXR1cm4ge0FnZ3JlZ2F0ZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS5yZXBsYWNlUm9vdCA9IGZ1bmN0aW9uKG5ld1Jvb3QpIHtcbiAgbGV0IHJldDtcblxuICBpZiAodHlwZW9mIG5ld1Jvb3QgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0ID0gbmV3Um9vdC5zdGFydHNXaXRoKCckJykgPyBuZXdSb290IDogJyQnICsgbmV3Um9vdDtcbiAgfSBlbHNlIHtcbiAgICByZXQgPSBuZXdSb290O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuYXBwZW5kKHtcbiAgICAkcmVwbGFjZVJvb3Q6IHtcbiAgICAgIG5ld1Jvb3Q6IHJldFxuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIEFwcGVuZHMgYSBuZXcgJGNvdW50IG9wZXJhdG9yIHRvIHRoaXMgYWdncmVnYXRlIHBpcGVsaW5lLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYWdncmVnYXRlLmNvdW50KFwidXNlckNvdW50XCIpO1xuICpcbiAqIEBzZWUgJGNvdW50IGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9hZ2dyZWdhdGlvbi9jb3VudFxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkTmFtZSBUaGUgbmFtZSBvZiB0aGUgb3V0cHV0IGZpZWxkIHdoaWNoIGhhcyB0aGUgY291bnQgYXMgaXRzIHZhbHVlLiBJdCBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZywgbXVzdCBub3Qgc3RhcnQgd2l0aCAkIGFuZCBtdXN0IG5vdCBjb250YWluIHRoZSAuIGNoYXJhY3Rlci5cbiAqIEByZXR1cm4ge0FnZ3JlZ2F0ZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uKGZpZWxkTmFtZSkge1xuICByZXR1cm4gdGhpcy5hcHBlbmQoeyAkY291bnQ6IGZpZWxkTmFtZSB9KTtcbn07XG5cbi8qKlxuICogQXBwZW5kcyBhIG5ldyAkc29ydEJ5Q291bnQgb3BlcmF0b3IgdG8gdGhpcyBhZ2dyZWdhdGUgcGlwZWxpbmUuIEFjY2VwdHMgZWl0aGVyIGEgc3RyaW5nIGZpZWxkIG5hbWVcbiAqIG9yIGEgcGlwZWxpbmUgb2JqZWN0LlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgYCRzb3J0QnlDb3VudGAgb3BlcmF0b3IgcmVxdWlyZXMgdGhlIG5ldyByb290IHRvIHN0YXJ0IHdpdGggJyQnLlxuICogTW9uZ29vc2Ugd2lsbCBwcmVwZW5kICckJyBpZiB0aGUgc3BlY2lmaWVkIGZpZWxkIG5hbWUgZG9lc24ndCBzdGFydCB3aXRoICckJy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGFnZ3JlZ2F0ZS5zb3J0QnlDb3VudCgndXNlcnMnKTtcbiAqICAgICBhZ2dyZWdhdGUuc29ydEJ5Q291bnQoeyAkbWVyZ2VPYmplY3RzOiBbIFwiJGVtcGxveWVlXCIsIFwiJGJ1c2luZXNzXCIgXSB9KVxuICpcbiAqIEBzZWUgJHNvcnRCeUNvdW50IGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9hZ2dyZWdhdGlvbi9zb3J0QnlDb3VudC9cbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gYXJnXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGV9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS5zb3J0QnlDb3VudCA9IGZ1bmN0aW9uKGFyZykge1xuICBpZiAoYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHRoaXMuYXBwZW5kKHsgJHNvcnRCeUNvdW50OiBhcmcgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdGhpcy5hcHBlbmQoe1xuICAgICAgJHNvcnRCeUNvdW50OiAoYXJnWzBdID09PSAnJCcpID8gYXJnIDogJyQnICsgYXJnXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmcgXCInICsgYXJnICsgJ1wiIHRvIHNvcnRCeUNvdW50KCksICcgK1xuICAgICAgJ211c3QgYmUgc3RyaW5nIG9yIG9iamVjdCcpO1xuICB9XG59O1xuXG4vKipcbiAqIEFwcGVuZHMgbmV3IGN1c3RvbSAkbG9va3VwIG9wZXJhdG9yIHRvIHRoaXMgYWdncmVnYXRlIHBpcGVsaW5lLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYWdncmVnYXRlLmxvb2t1cCh7IGZyb206ICd1c2VycycsIGxvY2FsRmllbGQ6ICd1c2VySWQnLCBmb3JlaWduRmllbGQ6ICdfaWQnLCBhczogJ3VzZXJzJyB9KTtcbiAqXG4gKiBAc2VlICRsb29rdXAgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2FnZ3JlZ2F0aW9uL2xvb2t1cC8jcGlwZS5fU19sb29rdXBcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRvICRsb29rdXAgYXMgZGVzY3JpYmVkIGluIHRoZSBhYm92ZSBsaW5rXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGV9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUubG9va3VwID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICByZXR1cm4gdGhpcy5hcHBlbmQoeyAkbG9va3VwOiBvcHRpb25zIH0pO1xufTtcblxuLyoqXG4gKiBBcHBlbmRzIG5ldyBjdXN0b20gJGdyYXBoTG9va3VwIG9wZXJhdG9yKHMpIHRvIHRoaXMgYWdncmVnYXRlIHBpcGVsaW5lLCBwZXJmb3JtaW5nIGEgcmVjdXJzaXZlIHNlYXJjaCBvbiBhIGNvbGxlY3Rpb24uXG4gKlxuICogTm90ZSB0aGF0IGdyYXBoTG9va3VwIGNhbiBvbmx5IGNvbnN1bWUgYXQgbW9zdCAxMDBNQiBvZiBtZW1vcnksIGFuZCBkb2VzIG5vdCBhbGxvdyBkaXNrIHVzZSBldmVuIGlmIGB7IGFsbG93RGlza1VzZTogdHJ1ZSB9YCBpcyBzcGVjaWZpZWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAgLy8gU3VwcG9zZSB3ZSBoYXZlIGEgY29sbGVjdGlvbiBvZiBjb3Vyc2VzLCB3aGVyZSBhIGRvY3VtZW50IG1pZ2h0IGxvb2sgbGlrZSBgeyBfaWQ6IDAsIG5hbWU6ICdDYWxjdWx1cycsIHByZXJlcXVpc2l0ZTogJ1RyaWdvbm9tZXRyeSd9YCBhbmQgYHsgX2lkOiAwLCBuYW1lOiAnVHJpZ29ub21ldHJ5JywgcHJlcmVxdWlzaXRlOiAnQWxnZWJyYScgfWBcbiAqICAgICAgYWdncmVnYXRlLmdyYXBoTG9va3VwKHsgZnJvbTogJ2NvdXJzZXMnLCBzdGFydFdpdGg6ICckcHJlcmVxdWlzaXRlJywgY29ubmVjdEZyb21GaWVsZDogJ3ByZXJlcXVpc2l0ZScsIGNvbm5lY3RUb0ZpZWxkOiAnbmFtZScsIGFzOiAncHJlcmVxdWlzaXRlcycsIG1heERlcHRoOiAzIH0pIC8vIHRoaXMgd2lsbCByZWN1cnNpdmVseSBzZWFyY2ggdGhlICdjb3Vyc2VzJyBjb2xsZWN0aW9uIHVwIHRvIDMgcHJlcmVxdWlzaXRlc1xuICpcbiAqIEBzZWUgJGdyYXBoTG9va3VwIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9hZ2dyZWdhdGlvbi9ncmFwaExvb2t1cC8jcGlwZS5fU19ncmFwaExvb2t1cFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdG8gJGdyYXBoTG9va3VwIGFzIGRlc2NyaWJlZCBpbiB0aGUgYWJvdmUgbGlua1xuICogQHJldHVybiB7QWdncmVnYXRlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLmdyYXBoTG9va3VwID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBjb25zdCBjbG9uZU9wdGlvbnMgPSB7fTtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAoIXV0aWxzLmlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGdyYXBoTG9va3VwKCkgYXJndW1lbnQuIE11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgIH1cblxuICAgIHV0aWxzLm1lcmdlQ2xvbmUoY2xvbmVPcHRpb25zLCBvcHRpb25zKTtcbiAgICBjb25zdCBzdGFydFdpdGggPSBjbG9uZU9wdGlvbnMuc3RhcnRXaXRoO1xuXG4gICAgaWYgKHN0YXJ0V2l0aCAmJiB0eXBlb2Ygc3RhcnRXaXRoID09PSAnc3RyaW5nJykge1xuICAgICAgY2xvbmVPcHRpb25zLnN0YXJ0V2l0aCA9IGNsb25lT3B0aW9ucy5zdGFydFdpdGguc3RhcnRzV2l0aCgnJCcpID9cbiAgICAgICAgY2xvbmVPcHRpb25zLnN0YXJ0V2l0aCA6XG4gICAgICAgICckJyArIGNsb25lT3B0aW9ucy5zdGFydFdpdGg7XG4gICAgfVxuXG4gIH1cbiAgcmV0dXJuIHRoaXMuYXBwZW5kKHsgJGdyYXBoTG9va3VwOiBjbG9uZU9wdGlvbnMgfSk7XG59O1xuXG4vKipcbiAqIEFwcGVuZHMgbmV3IGN1c3RvbSAkc2FtcGxlIG9wZXJhdG9yIHRvIHRoaXMgYWdncmVnYXRlIHBpcGVsaW5lLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYWdncmVnYXRlLnNhbXBsZSgzKTsgLy8gQWRkIGEgcGlwZWxpbmUgdGhhdCBwaWNrcyAzIHJhbmRvbSBkb2N1bWVudHNcbiAqXG4gKiBAc2VlICRzYW1wbGUgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2FnZ3JlZ2F0aW9uL3NhbXBsZS8jcGlwZS5fU19zYW1wbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBzaXplIG51bWJlciBvZiByYW5kb20gZG9jdW1lbnRzIHRvIHBpY2tcbiAqIEByZXR1cm4ge0FnZ3JlZ2F0ZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS5zYW1wbGUgPSBmdW5jdGlvbihzaXplKSB7XG4gIHJldHVybiB0aGlzLmFwcGVuZCh7ICRzYW1wbGU6IHsgc2l6ZTogc2l6ZSB9IH0pO1xufTtcblxuLyoqXG4gKiBBcHBlbmRzIGEgbmV3ICRzb3J0IG9wZXJhdG9yIHRvIHRoaXMgYWdncmVnYXRlIHBpcGVsaW5lLlxuICpcbiAqIElmIGFuIG9iamVjdCBpcyBwYXNzZWQsIHZhbHVlcyBhbGxvd2VkIGFyZSBgYXNjYCwgYGRlc2NgLCBgYXNjZW5kaW5nYCwgYGRlc2NlbmRpbmdgLCBgMWAsIGFuZCBgLTFgLlxuICpcbiAqIElmIGEgc3RyaW5nIGlzIHBhc3NlZCwgaXQgbXVzdCBiZSBhIHNwYWNlIGRlbGltaXRlZCBsaXN0IG9mIHBhdGggbmFtZXMuIFRoZSBzb3J0IG9yZGVyIG9mIGVhY2ggcGF0aCBpcyBhc2NlbmRpbmcgdW5sZXNzIHRoZSBwYXRoIG5hbWUgaXMgcHJlZml4ZWQgd2l0aCBgLWAgd2hpY2ggd2lsbCBiZSB0cmVhdGVkIGFzIGRlc2NlbmRpbmcuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyB0aGVzZSBhcmUgZXF1aXZhbGVudFxuICogICAgIGFnZ3JlZ2F0ZS5zb3J0KHsgZmllbGQ6ICdhc2MnLCB0ZXN0OiAtMSB9KTtcbiAqICAgICBhZ2dyZWdhdGUuc29ydCgnZmllbGQgLXRlc3QnKTtcbiAqXG4gKiBAc2VlICRzb3J0IGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9hZ2dyZWdhdGlvbi9zb3J0L1xuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBhcmdcbiAqIEByZXR1cm4ge0FnZ3JlZ2F0ZX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbihhcmcpIHtcbiAgLy8gVE9ETyByZWZhY3RvciB0byByZXVzZSB0aGUgcXVlcnkgYnVpbGRlciBsb2dpY1xuXG4gIGNvbnN0IHNvcnQgPSB7fTtcblxuICBpZiAoZ2V0Q29uc3RydWN0b3JOYW1lKGFyZykgPT09ICdPYmplY3QnKSB7XG4gICAgY29uc3QgZGVzYyA9IFsnZGVzYycsICdkZXNjZW5kaW5nJywgLTFdO1xuICAgIE9iamVjdC5rZXlzKGFyZykuZm9yRWFjaChmdW5jdGlvbihmaWVsZCkge1xuICAgICAgLy8gSWYgc29ydGluZyBieSB0ZXh0IHNjb3JlLCBza2lwIGNvZXJjaW5nIGludG8gMS8tMVxuICAgICAgaWYgKGFyZ1tmaWVsZF0gaW5zdGFuY2VvZiBPYmplY3QgJiYgYXJnW2ZpZWxkXS4kbWV0YSkge1xuICAgICAgICBzb3J0W2ZpZWxkXSA9IGFyZ1tmaWVsZF07XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNvcnRbZmllbGRdID0gZGVzYy5pbmRleE9mKGFyZ1tmaWVsZF0pID09PSAtMSA/IDEgOiAtMTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgYXJnLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbihmaWVsZCkge1xuICAgICAgaWYgKCFmaWVsZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBhc2NlbmQgPSBmaWVsZFswXSA9PT0gJy0nID8gLTEgOiAxO1xuICAgICAgaWYgKGFzY2VuZCA9PT0gLTEpIHtcbiAgICAgICAgZmllbGQgPSBmaWVsZC5zdWJzdHJpbmcoMSk7XG4gICAgICB9XG4gICAgICBzb3J0W2ZpZWxkXSA9IGFzY2VuZDtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHNvcnQoKSBhcmd1bWVudC4gTXVzdCBiZSBhIHN0cmluZyBvciBvYmplY3QuJyk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5hcHBlbmQoeyAkc29ydDogc29ydCB9KTtcbn07XG5cbi8qKlxuICogQXBwZW5kcyBuZXcgJHVuaW9uV2l0aCBvcGVyYXRvciB0byB0aGlzIGFnZ3JlZ2F0ZSBwaXBlbGluZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGFnZ3JlZ2F0ZS51bmlvbldpdGgoeyBjb2xsOiAndXNlcnMnLCBwaXBlbGluZTogWyB7ICRtYXRjaDogeyBfaWQ6IDEgfSB9IF0gfSk7XG4gKlxuICogQHNlZSAkdW5pb25XaXRoIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9hZ2dyZWdhdGlvbi91bmlvbldpdGhcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRvICR1bmlvbldpdGggcXVlcnkgYXMgZGVzY3JpYmVkIGluIHRoZSBhYm92ZSBsaW5rXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGV9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUudW5pb25XaXRoID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICByZXR1cm4gdGhpcy5hcHBlbmQoeyAkdW5pb25XaXRoOiBvcHRpb25zIH0pO1xufTtcblxuXG4vKipcbiAqIFNldHMgdGhlIHJlYWRQcmVmZXJlbmNlIG9wdGlvbiBmb3IgdGhlIGFnZ3JlZ2F0aW9uIHF1ZXJ5LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYXdhaXQgTW9kZWwuYWdncmVnYXRlKHBpcGVsaW5lKS5yZWFkKCdwcmltYXJ5UHJlZmVycmVkJyk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd8UmVhZFByZWZlcmVuY2V9IHByZWYgb25lIG9mIHRoZSBsaXN0ZWQgcHJlZmVyZW5jZSBvcHRpb25zIG9yIHRoZWlyIGFsaWFzZXNcbiAqIEBwYXJhbSB7QXJyYXl9IFt0YWdzXSBvcHRpb25hbCB0YWdzIGZvciB0aGlzIHF1ZXJ5LlxuICogQHJldHVybiB7QWdncmVnYXRlfSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICogQHNlZSBtb25nb2RiIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL2FwcGxpY2F0aW9ucy9yZXBsaWNhdGlvbi8jcmVhZC1wcmVmZXJlbmNlXG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24ocHJlZiwgdGFncykge1xuICByZWFkLmNhbGwodGhpcywgcHJlZiwgdGFncyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSByZWFkQ29uY2VybiBsZXZlbCBmb3IgdGhlIGFnZ3JlZ2F0aW9uIHF1ZXJ5LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYXdhaXQgTW9kZWwuYWdncmVnYXRlKHBpcGVsaW5lKS5yZWFkQ29uY2VybignbWFqb3JpdHknKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbGV2ZWwgb25lIG9mIHRoZSBsaXN0ZWQgcmVhZCBjb25jZXJuIGxldmVsIG9yIHRoZWlyIGFsaWFzZXNcbiAqIEBzZWUgbW9uZ29kYiBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvcmVhZC1jb25jZXJuL1xuICogQHJldHVybiB7QWdncmVnYXRlfSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUucmVhZENvbmNlcm4gPSBmdW5jdGlvbihsZXZlbCkge1xuICByZWFkQ29uY2Vybi5jYWxsKHRoaXMsIGxldmVsKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFwcGVuZHMgYSBuZXcgJHJlZGFjdCBvcGVyYXRvciB0byB0aGlzIGFnZ3JlZ2F0ZSBwaXBlbGluZS5cbiAqXG4gKiBJZiAzIGFyZ3VtZW50cyBhcmUgc3VwcGxpZWQsIE1vbmdvb3NlIHdpbGwgd3JhcCB0aGVtIHdpdGggaWYtdGhlbi1lbHNlIG9mICRjb25kIG9wZXJhdG9yIHJlc3BlY3RpdmVseVxuICogSWYgYHRoZW5FeHByYCBvciBgZWxzZUV4cHJgIGlzIHN0cmluZywgbWFrZSBzdXJlIGl0IHN0YXJ0cyB3aXRoICQkLCBsaWtlIGAkJERFU0NFTkRgLCBgJCRQUlVORWAgb3IgYCQkS0VFUGAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhd2FpdCBNb2RlbC5hZ2dyZWdhdGUocGlwZWxpbmUpLnJlZGFjdCh7XG4gKiAgICAgICAkY29uZDoge1xuICogICAgICAgICBpZjogeyAkZXE6IFsgJyRsZXZlbCcsIDUgXSB9LFxuICogICAgICAgICB0aGVuOiAnJCRQUlVORScsXG4gKiAgICAgICAgIGVsc2U6ICckJERFU0NFTkQnXG4gKiAgICAgICB9XG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vICRyZWRhY3Qgb2Z0ZW4gY29tZXMgd2l0aCAkY29uZCBvcGVyYXRvciwgeW91IGNhbiBhbHNvIHVzZSB0aGUgZm9sbG93aW5nIHN5bnRheCBwcm92aWRlZCBieSBtb25nb29zZVxuICogICAgIGF3YWl0IE1vZGVsLmFnZ3JlZ2F0ZShwaXBlbGluZSkucmVkYWN0KHsgJGVxOiBbICckbGV2ZWwnLCA1IF0gfSwgJyQkUFJVTkUnLCAnJCRERVNDRU5EJyk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGV4cHJlc3Npb24gcmVkYWN0IG9wdGlvbnMgb3IgY29uZGl0aW9uYWwgZXhwcmVzc2lvblxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBbdGhlbkV4cHJdIHRydWUgY2FzZSBmb3IgdGhlIGNvbmRpdGlvblxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBbZWxzZUV4cHJdIGZhbHNlIGNhc2UgZm9yIHRoZSBjb25kaXRpb25cbiAqIEByZXR1cm4ge0FnZ3JlZ2F0ZX0gdGhpc1xuICogQHNlZSAkcmVkYWN0IGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9hZ2dyZWdhdGlvbi9yZWRhY3QvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUucmVkYWN0ID0gZnVuY3Rpb24oZXhwcmVzc2lvbiwgdGhlbkV4cHIsIGVsc2VFeHByKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgaWYgKCh0eXBlb2YgdGhlbkV4cHIgPT09ICdzdHJpbmcnICYmICF2YWxpZFJlZGFjdFN0cmluZ1ZhbHVlcy5oYXModGhlbkV4cHIpKSB8fFxuICAgICAgKHR5cGVvZiBlbHNlRXhwciA9PT0gJ3N0cmluZycgJiYgIXZhbGlkUmVkYWN0U3RyaW5nVmFsdWVzLmhhcyhlbHNlRXhwcikpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lmIHRoZW5FeHByIG9yIGVsc2VFeHByIGlzIHN0cmluZywgaXQgbXVzdCBiZSBlaXRoZXIgJCRERVNDRU5ELCAkJFBSVU5FIG9yICQkS0VFUCcpO1xuICAgIH1cblxuICAgIGV4cHJlc3Npb24gPSB7XG4gICAgICAkY29uZDoge1xuICAgICAgICBpZjogZXhwcmVzc2lvbixcbiAgICAgICAgdGhlbjogdGhlbkV4cHIsXG4gICAgICAgIGVsc2U6IGVsc2VFeHByXG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhcmd1bWVudHMnKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmFwcGVuZCh7ICRyZWRhY3Q6IGV4cHJlc3Npb24gfSk7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgdGhlIGFnZ3JlZ2F0aW9uIHdpdGggZXhwbGFpblxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgTW9kZWwuYWdncmVnYXRlKC4uKS5leHBsYWluKClcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3ZlcmJvc2l0eV1cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS5leHBsYWluID0gYXN5bmMgZnVuY3Rpb24gZXhwbGFpbih2ZXJib3NpdHkpIHtcbiAgaWYgKHR5cGVvZiB2ZXJib3NpdHkgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdBZ2dyZWdhdGUucHJvdG90eXBlLmV4cGxhaW4oKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cbiAgY29uc3QgbW9kZWwgPSB0aGlzLl9tb2RlbDtcblxuICBpZiAoIXRoaXMuX3BpcGVsaW5lLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQWdncmVnYXRlIGhhcyBlbXB0eSBwaXBlbGluZScpO1xuICB9XG5cbiAgcHJlcGFyZURpc2NyaW1pbmF0b3JQaXBlbGluZSh0aGlzLl9waXBlbGluZSwgdGhpcy5fbW9kZWwuc2NoZW1hKTtcblxuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgbW9kZWwuaG9va3MuZXhlY1ByZSgnYWdncmVnYXRlJywgdGhpcywgZXJyb3IgPT4ge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IF9vcHRzID0geyBlcnJvcjogZXJyb3IgfTtcbiAgICAgICAgcmV0dXJuIG1vZGVsLmhvb2tzLmV4ZWNQb3N0KCdhZ2dyZWdhdGUnLCB0aGlzLCBbbnVsbF0sIF9vcHRzLCBlcnJvciA9PiB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGNvbnN0IGN1cnNvciA9IG1vZGVsLmNvbGxlY3Rpb24uYWdncmVnYXRlKHRoaXMuX3BpcGVsaW5lLCB0aGlzLm9wdGlvbnMpO1xuXG4gIGlmICh2ZXJib3NpdHkgPT0gbnVsbCkge1xuICAgIHZlcmJvc2l0eSA9IHRydWU7XG4gIH1cblxuICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgdHJ5IHtcbiAgICByZXN1bHQgPSBhd2FpdCBjdXJzb3IuZXhwbGFpbih2ZXJib3NpdHkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IF9vcHRzID0geyBlcnJvcjogZXJyb3IgfTtcbiAgICAgIG1vZGVsLmhvb2tzLmV4ZWNQb3N0KCdhZ2dyZWdhdGUnLCB0aGlzLCBbbnVsbF0sIF9vcHRzLCBlcnJvciA9PiB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IF9vcHRzID0geyBlcnJvcjogbnVsbCB9O1xuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgbW9kZWwuaG9va3MuZXhlY1Bvc3QoJ2FnZ3JlZ2F0ZScsIHRoaXMsIFtyZXN1bHRdLCBfb3B0cywgZXJyb3IgPT4ge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgYWxsb3dEaXNrVXNlIG9wdGlvbiBmb3IgdGhlIGFnZ3JlZ2F0aW9uIHF1ZXJ5XG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhd2FpdCBNb2RlbC5hZ2dyZWdhdGUoW3sgJG1hdGNoOiB7IGZvbzogJ2JhcicgfSB9XSkuYWxsb3dEaXNrVXNlKHRydWUpO1xuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgU2hvdWxkIHRlbGwgc2VydmVyIGl0IGNhbiB1c2UgaGFyZCBkcml2ZSB0byBzdG9yZSBkYXRhIGR1cmluZyBhZ2dyZWdhdGlvbi5cbiAqIEByZXR1cm4ge0FnZ3JlZ2F0ZX0gdGhpc1xuICogQHNlZSBtb25nb2RiIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9jb21tYW5kL2FnZ3JlZ2F0ZS9cbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLmFsbG93RGlza1VzZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHRoaXMub3B0aW9ucy5hbGxvd0Rpc2tVc2UgPSB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGhpbnQgb3B0aW9uIGZvciB0aGUgYWdncmVnYXRpb24gcXVlcnlcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIE1vZGVsLmFnZ3JlZ2F0ZSguLikuaGludCh7IHF0eTogMSwgY2F0ZWdvcnk6IDEgfSkuZXhlYygpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gdmFsdWUgYSBoaW50IG9iamVjdCBvciB0aGUgaW5kZXggbmFtZVxuICogQHJldHVybiB7QWdncmVnYXRlfSB0aGlzXG4gKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2NvbW1hbmQvYWdncmVnYXRlL1xuICovXG5cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUuaGludCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHRoaXMub3B0aW9ucy5oaW50ID0gdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBzZXNzaW9uIGZvciB0aGlzIGFnZ3JlZ2F0aW9uLiBVc2VmdWwgZm9yIFt0cmFuc2FjdGlvbnNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90cmFuc2FjdGlvbnMuaHRtbCkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgTW9kZWwuc3RhcnRTZXNzaW9uKCk7XG4gKiAgICAgYXdhaXQgTW9kZWwuYWdncmVnYXRlKC4uKS5zZXNzaW9uKHNlc3Npb24pO1xuICpcbiAqIEBwYXJhbSB7Q2xpZW50U2Vzc2lvbn0gc2Vzc2lvblxuICogQHJldHVybiB7QWdncmVnYXRlfSB0aGlzXG4gKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2NvbW1hbmQvYWdncmVnYXRlL1xuICovXG5cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUuc2Vzc2lvbiA9IGZ1bmN0aW9uKHNlc3Npb24pIHtcbiAgaWYgKHNlc3Npb24gPT0gbnVsbCkge1xuICAgIGRlbGV0ZSB0aGlzLm9wdGlvbnMuc2Vzc2lvbjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9wdGlvbnMuc2Vzc2lvbiA9IHNlc3Npb247XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIExldHMgeW91IHNldCBhcmJpdHJhcnkgb3B0aW9ucywgZm9yIG1pZGRsZXdhcmUgb3IgcGx1Z2lucy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGFnZyA9IE1vZGVsLmFnZ3JlZ2F0ZSguLikub3B0aW9uKHsgYWxsb3dEaXNrVXNlOiB0cnVlIH0pOyAvLyBTZXQgdGhlIGBhbGxvd0Rpc2tVc2VgIG9wdGlvblxuICogICAgIGFnZy5vcHRpb25zOyAvLyBgeyBhbGxvd0Rpc2tVc2U6IHRydWUgfWBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBrZXlzIHRvIG1lcmdlIGludG8gY3VycmVudCBvcHRpb25zXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4VGltZU1TXSBudW1iZXIgbGltaXRzIHRoZSB0aW1lIHRoaXMgYWdncmVnYXRpb24gd2lsbCBydW4sIHNlZSBbTW9uZ29EQiBkb2NzIG9uIGBtYXhUaW1lTVNgXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvbWV0YS9tYXhUaW1lTVMvKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxvd0Rpc2tVc2VdIGJvb2xlYW4gaWYgdHJ1ZSwgdGhlIE1vbmdvREIgc2VydmVyIHdpbGwgdXNlIHRoZSBoYXJkIGRyaXZlIHRvIHN0b3JlIGRhdGEgZHVyaW5nIHRoaXMgYWdncmVnYXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5jb2xsYXRpb25dIG9iamVjdCBzZWUgW2BBZ2dyZWdhdGUucHJvdG90eXBlLmNvbGxhdGlvbigpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9hZ2dyZWdhdGUuaHRtbCNBZ2dyZWdhdGUucHJvdG90eXBlLmNvbGxhdGlvbigpKVxuICogQHBhcmFtIHtDbGllbnRTZXNzaW9ufSBbb3B0aW9ucy5zZXNzaW9uXSBDbGllbnRTZXNzaW9uIHNlZSBbYEFnZ3JlZ2F0ZS5wcm90b3R5cGUuc2Vzc2lvbigpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9hZ2dyZWdhdGUuaHRtbCNBZ2dyZWdhdGUucHJvdG90eXBlLnNlc3Npb24oKSlcbiAqIEBzZWUgbW9uZ29kYiBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvY29tbWFuZC9hZ2dyZWdhdGUvXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGV9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS5vcHRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgIHRoaXMub3B0aW9uc1trZXldID0gdmFsdWVba2V5XTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgYGN1cnNvcmAgb3B0aW9uIGFuZCBleGVjdXRlcyB0aGlzIGFnZ3JlZ2F0aW9uLCByZXR1cm5pbmcgYW4gYWdncmVnYXRpb24gY3Vyc29yLlxuICogQ3Vyc29ycyBhcmUgdXNlZnVsIGlmIHlvdSB3YW50IHRvIHByb2Nlc3MgdGhlIHJlc3VsdHMgb2YgdGhlIGFnZ3JlZ2F0aW9uIG9uZS1hdC1hLXRpbWVcbiAqIGJlY2F1c2UgdGhlIGFnZ3JlZ2F0aW9uIHJlc3VsdCBpcyB0b28gYmlnIHRvIGZpdCBpbnRvIG1lbW9yeS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGN1cnNvciA9IE1vZGVsLmFnZ3JlZ2F0ZSguLikuY3Vyc29yKHsgYmF0Y2hTaXplOiAxMDAwIH0pO1xuICogICAgIGN1cnNvci5lYWNoQXN5bmMoZnVuY3Rpb24oZG9jLCBpKSB7XG4gKiAgICAgICAvLyB1c2UgZG9jXG4gKiAgICAgfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5iYXRjaFNpemVdIHNldCB0aGUgY3Vyc29yIGJhdGNoIHNpemVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXNlTW9uZ29vc2VBZ2dDdXJzb3JdIHVzZSBleHBlcmltZW50YWwgbW9uZ29vc2Utc3BlY2lmaWMgYWdncmVnYXRpb24gY3Vyc29yIChmb3IgYGVhY2hBc3luYygpYCBhbmQgb3RoZXIgcXVlcnkgY3Vyc29yIHNlbWFudGljcylcbiAqIEByZXR1cm4ge0FnZ3JlZ2F0aW9uQ3Vyc29yfSBjdXJzb3IgcmVwcmVzZW50aW5nIHRoaXMgYWdncmVnYXRpb25cbiAqIEBhcGkgcHVibGljXG4gKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0FnZ3JlZ2F0aW9uQ3Vyc29yLmh0bWxcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLmN1cnNvciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zLmN1cnNvciA9IG9wdGlvbnMgfHwge307XG4gIHJldHVybiBuZXcgQWdncmVnYXRpb25DdXJzb3IodGhpcyk7IC8vIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgY29sbGF0aW9uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCByZXMgPSBhd2FpdCBNb2RlbC5hZ2dyZWdhdGUocGlwZWxpbmUpLmNvbGxhdGlvbih7IGxvY2FsZTogJ2VuX1VTJywgc3RyZW5ndGg6IDEgfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbGxhdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGV9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL0NvbGxhdGlvbk9wdGlvbnMuaHRtbFxuICovXG5cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUuY29sbGF0aW9uID0gZnVuY3Rpb24oY29sbGF0aW9uKSB7XG4gIHRoaXMub3B0aW9ucy5jb2xsYXRpb24gPSBjb2xsYXRpb247XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb21iaW5lcyBtdWx0aXBsZSBhZ2dyZWdhdGlvbiBwaXBlbGluZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCByZXMgPSBhd2FpdCBNb2RlbC5hZ2dyZWdhdGUoKS5mYWNldCh7XG4gKiAgICAgICBib29rczogW3sgZ3JvdXBCeTogJyRhdXRob3InIH1dLFxuICogICAgICAgcHJpY2U6IFt7ICRidWNrZXRBdXRvOiB7IGdyb3VwQnk6ICckcHJpY2UnLCBidWNrZXRzOiAyIH0gfV1cbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gT3V0cHV0OiB7IGJvb2tzOiBbLi4uXSwgcHJpY2U6IFt7Li4ufSwgey4uLn1dIH1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZmFjZXQgb3B0aW9uc1xuICogQHJldHVybiB7QWdncmVnYXRlfSB0aGlzXG4gKiBAc2VlICRmYWNldCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvYWdncmVnYXRpb24vZmFjZXQvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUuZmFjZXQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHJldHVybiB0aGlzLmFwcGVuZCh7ICRmYWNldDogb3B0aW9ucyB9KTtcbn07XG5cbi8qKlxuICogSGVscGVyIGZvciBbQXRsYXMgVGV4dCBTZWFyY2hdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvYXRsYXMvYXRsYXMtc2VhcmNoL3R1dG9yaWFsLyknc1xuICogYCRzZWFyY2hgIHN0YWdlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcmVzID0gYXdhaXQgTW9kZWwuYWdncmVnYXRlKCkuXG4gKiAgICAgIHNlYXJjaCh7XG4gKiAgICAgICAgdGV4dDoge1xuICogICAgICAgICAgcXVlcnk6ICdiYXNlYmFsbCcsXG4gKiAgICAgICAgICBwYXRoOiAncGxvdCdcbiAqICAgICAgICB9XG4gKiAgICAgIH0pO1xuICpcbiAqICAgICAvLyBPdXRwdXQ6IFt7IHBsb3Q6ICcuLi4nLCB0aXRsZTogJy4uLicgfV1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gJHNlYXJjaCBvcHRpb25zXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGV9IHRoaXNcbiAqIEBzZWUgJHNlYXJjaCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL2F0bGFzL2F0bGFzLXNlYXJjaC90dXRvcmlhbC9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQWdncmVnYXRlLnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHJldHVybiB0aGlzLmFwcGVuZCh7ICRzZWFyY2g6IG9wdGlvbnMgfSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgcGlwZWxpbmVcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIE15TW9kZWwuYWdncmVnYXRlKCkubWF0Y2goeyB0ZXN0OiAxIH0pLnBpcGVsaW5lKCk7IC8vIFt7ICRtYXRjaDogeyB0ZXN0OiAxIH0gfV1cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGN1cnJlbnQgcGlwZWxpbmUgc2ltaWxhciB0byB0aGUgb3BlcmF0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLnBpcGVsaW5lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9waXBlbGluZTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgdGhlIGFnZ3JlZ2F0ZSBwaXBlbGluZSBvbiB0aGUgY3VycmVudGx5IGJvdW5kIE1vZGVsLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhZ2dyZWdhdGUuZXhlYygpO1xuICpcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkFnZ3JlZ2F0ZS5wcm90b3R5cGUuZXhlYyA9IGFzeW5jIGZ1bmN0aW9uIGV4ZWMoKSB7XG4gIGlmICghdGhpcy5fbW9kZWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FnZ3JlZ2F0ZSBub3QgYm91bmQgdG8gYW55IE1vZGVsJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignQWdncmVnYXRlLnByb3RvdHlwZS5leGVjKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG4gIGNvbnN0IG1vZGVsID0gdGhpcy5fbW9kZWw7XG4gIGNvbnN0IGNvbGxlY3Rpb24gPSB0aGlzLl9tb2RlbC5jb2xsZWN0aW9uO1xuXG4gIGFwcGx5R2xvYmFsTWF4VGltZU1TKHRoaXMub3B0aW9ucywgbW9kZWwuZGIub3B0aW9ucywgbW9kZWwuYmFzZS5vcHRpb25zKTtcbiAgYXBwbHlHbG9iYWxEaXNrVXNlKHRoaXMub3B0aW9ucywgbW9kZWwuZGIub3B0aW9ucywgbW9kZWwuYmFzZS5vcHRpb25zKTtcblxuICBpZiAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5jdXJzb3IpIHtcbiAgICByZXR1cm4gbmV3IEFnZ3JlZ2F0aW9uQ3Vyc29yKHRoaXMpO1xuICB9XG5cbiAgcHJlcGFyZURpc2NyaW1pbmF0b3JQaXBlbGluZSh0aGlzLl9waXBlbGluZSwgdGhpcy5fbW9kZWwuc2NoZW1hKTtcbiAgc3RyaW5naWZ5RnVuY3Rpb25PcGVyYXRvcnModGhpcy5fcGlwZWxpbmUpO1xuXG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBtb2RlbC5ob29rcy5leGVjUHJlKCdhZ2dyZWdhdGUnLCB0aGlzLCBlcnJvciA9PiB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgX29wdHMgPSB7IGVycm9yOiBlcnJvciB9O1xuICAgICAgICByZXR1cm4gbW9kZWwuaG9va3MuZXhlY1Bvc3QoJ2FnZ3JlZ2F0ZScsIHRoaXMsIFtudWxsXSwgX29wdHMsIGVycm9yID0+IHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgaWYgKCF0aGlzLl9waXBlbGluZS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignQWdncmVnYXRlIGhhcyBlbXB0eSBwaXBlbGluZScpO1xuICB9XG5cbiAgY29uc3Qgb3B0aW9ucyA9IGNsb25lKHRoaXMub3B0aW9ucyB8fCB7fSk7XG4gIGxldCByZXN1bHQ7XG4gIHRyeSB7XG4gICAgY29uc3QgY3Vyc29yID0gYXdhaXQgY29sbGVjdGlvbi5hZ2dyZWdhdGUodGhpcy5fcGlwZWxpbmUsIG9wdGlvbnMpO1xuICAgIHJlc3VsdCA9IGF3YWl0IGN1cnNvci50b0FycmF5KCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgX29wdHMgPSB7IGVycm9yOiBlcnJvciB9O1xuICAgICAgbW9kZWwuaG9va3MuZXhlY1Bvc3QoJ2FnZ3JlZ2F0ZScsIHRoaXMsIFtudWxsXSwgX29wdHMsIChlcnJvcikgPT4ge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgY29uc3QgX29wdHMgPSB7IGVycm9yOiBudWxsIH07XG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBtb2RlbC5ob29rcy5leGVjUG9zdCgnYWdncmVnYXRlJywgdGhpcywgW3Jlc3VsdF0sIF9vcHRzLCBlcnJvciA9PiB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBQcm92aWRlcyBhIFByb21pc2UtbGlrZSBgdGhlbmAgZnVuY3Rpb24sIHdoaWNoIHdpbGwgY2FsbCBgLmV4ZWNgIHdpdGhvdXQgYSBjYWxsYmFja1xuICogQ29tcGF0aWJsZSB3aXRoIGBhd2FpdGAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBNb2RlbC5hZ2dyZWdhdGUoLi4pLnRoZW4oc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZV0gc3VjY2Vzc0NhbGxiYWNrXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVqZWN0XSAgZXJyb3JDYWxsYmFja1xuICogQHJldHVybiB7UHJvbWlzZX1cbiAqL1xuQWdncmVnYXRlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gIHJldHVybiB0aGlzLmV4ZWMoKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIHRoZSBhZ2dyZWdhdGlvbiByZXR1cm5pbmcgYSBgUHJvbWlzZWAgd2hpY2ggd2lsbCBiZVxuICogcmVzb2x2ZWQgd2l0aCBlaXRoZXIgdGhlIGRvYyhzKSBvciByZWplY3RlZCB3aXRoIHRoZSBlcnJvci5cbiAqIExpa2UgW2AudGhlbigpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS50aGVuKSwgYnV0IG9ubHkgdGFrZXMgYSByZWplY3Rpb24gaGFuZGxlci5cbiAqIENvbXBhdGlibGUgd2l0aCBgYXdhaXRgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZWplY3RdXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLmNhdGNoID0gZnVuY3Rpb24ocmVqZWN0KSB7XG4gIHJldHVybiB0aGlzLmV4ZWMoKS50aGVuKG51bGwsIHJlamVjdCk7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIHRoZSBhZ2dyZWdhdGUgcmV0dXJuaW5nIGEgYFByb21pc2VgIHdoaWNoIHdpbGwgYmVcbiAqIHJlc29sdmVkIHdpdGggYC5maW5hbGx5KClgIGNoYWluZWQuXG4gKlxuICogTW9yZSBhYm91dCBbUHJvbWlzZSBgZmluYWxseSgpYCBpbiBKYXZhU2NyaXB0XShodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tL3VzaW5nLXByb21pc2UtZmluYWxseS1pbi1ub2RlLWpzLmh0bWwpLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkZpbmFsbHldXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BZ2dyZWdhdGUucHJvdG90eXBlLmZpbmFsbHkgPSBmdW5jdGlvbihvbkZpbmFsbHkpIHtcbiAgcmV0dXJuIHRoaXMuZXhlYygpLmZpbmFsbHkob25GaW5hbGx5KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBhc3luY0l0ZXJhdG9yIGZvciB1c2Ugd2l0aCBbYGZvci9hd2FpdC9vZmAgbG9vcHNdKGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vZ2V0dGluZy1zdGFydGVkLXdpdGgtYXN5bmMtaXRlcmF0b3JzLWluLW5vZGUtanMpXG4gKiBZb3UgZG8gbm90IG5lZWQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIGV4cGxpY2l0bHksIHRoZSBKYXZhU2NyaXB0IHJ1bnRpbWVcbiAqIHdpbGwgY2FsbCBpdCBmb3IgeW91LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgYWdnID0gTW9kZWwuYWdncmVnYXRlKFt7ICRtYXRjaDogeyBhZ2U6IHsgJGd0ZTogMjUgfSB9IH1dKTtcbiAqICAgICBmb3IgYXdhaXQgKGNvbnN0IGRvYyBvZiBhZ2cpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKGRvYy5uYW1lKTtcbiAqICAgICB9XG4gKlxuICogTm9kZS5qcyAxMC54IHN1cHBvcnRzIGFzeW5jIGl0ZXJhdG9ycyBuYXRpdmVseSB3aXRob3V0IGFueSBmbGFncy4gWW91IGNhblxuICogZW5hYmxlIGFzeW5jIGl0ZXJhdG9ycyBpbiBOb2RlLmpzIDgueCB1c2luZyB0aGUgW2AtLWhhcm1vbnlfYXN5bmNfaXRlcmF0aW9uYCBmbGFnXShodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1hc3luYy1pdGVyYXRpb24vaXNzdWVzLzExNyNpc3N1ZWNvbW1lbnQtMzQ2Njk1MTg3KS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyBub3Qgc2V0IGlmIGBTeW1ib2wuYXN5bmNJdGVyYXRvcmAgaXMgdW5kZWZpbmVkLiBJZlxuICogYFN5bWJvbC5hc3luY0l0ZXJhdG9yYCBpcyB1bmRlZmluZWQsIHRoYXQgbWVhbnMgeW91ciBOb2RlLmpzIHZlcnNpb24gZG9lcyBub3RcbiAqIHN1cHBvcnQgYXN5bmMgaXRlcmF0b3JzLlxuICpcbiAqIEBtZXRob2QgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXVxuICogQG1lbWJlck9mIEFnZ3JlZ2F0ZVxuICogQGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmlmIChTeW1ib2wuYXN5bmNJdGVyYXRvciAhPSBudWxsKSB7XG4gIEFnZ3JlZ2F0ZS5wcm90b3R5cGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY3Vyc29yKHsgdXNlTW9uZ29vc2VBZ2dDdXJzb3I6IHRydWUgfSkudHJhbnNmb3JtTnVsbCgpLl90cmFuc2Zvcm1Gb3JBc3luY0l0ZXJhdG9yKCk7XG4gIH07XG59XG5cbi8qIVxuICogSGVscGVyc1xuICovXG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYW4gb2JqZWN0IGlzIGxpa2VseSBhIHBpcGVsaW5lIG9wZXJhdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBvYmplY3QgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc09wZXJhdG9yKG9iaikge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgayA9IE9iamVjdC5rZXlzKG9iaik7XG5cbiAgcmV0dXJuIGsubGVuZ3RoID09PSAxICYmIGtbMF1bMF0gPT09ICckJztcbn1cblxuLyoqXG4gKiBBZGRzIHRoZSBhcHByb3ByaWF0ZSBgJG1hdGNoYCBwaXBlbGluZSBzdGVwIHRvIHRoZSB0b3Agb2YgYW4gYWdncmVnYXRlJ3NcbiAqIHBpcGVsaW5lLCBzaG91bGQgaXQncyBtb2RlbCBpcyBhIG5vbi1yb290IGRpc2NyaW1pbmF0b3IgdHlwZS4gVGhpcyBpc1xuICogYW5hbG9nb3VzIHRvIHRoZSBgcHJlcGFyZURpc2NyaW1pbmF0b3JDcml0ZXJpYWAgZnVuY3Rpb24gaW4gYGxpYi9xdWVyeS5qc2AuXG4gKlxuICogQHBhcmFtIHtBZ2dyZWdhdGV9IGFnZ3JlZ2F0ZSBBZ2dyZWdhdGUgdG8gcHJlcGFyZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQWdncmVnYXRlLl9wcmVwYXJlRGlzY3JpbWluYXRvclBpcGVsaW5lID0gcHJlcGFyZURpc2NyaW1pbmF0b3JQaXBlbGluZTtcblxuLyohXG4gKiBFeHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBBZ2dyZWdhdGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/aggregate.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/browserDocument.js":
/*!***************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/browserDocument.js ***!
  \***************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst NodeJSDocument = __webpack_require__(/*! ./document */ \"../backend/node_modules/mongoose/lib/document.js\");\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst MongooseError = __webpack_require__(/*! ./error/index */ \"../backend/node_modules/mongoose/lib/error/index.js\");\nconst Schema = __webpack_require__(/*! ./schema */ \"../backend/node_modules/mongoose/lib/schema.js\");\nconst ObjectId = __webpack_require__(/*! ./types/objectid */ \"../backend/node_modules/mongoose/lib/types/objectid.js\");\nconst ValidationError = MongooseError.ValidationError;\nconst applyHooks = __webpack_require__(/*! ./helpers/model/applyHooks */ \"../backend/node_modules/mongoose/lib/helpers/model/applyHooks.js\");\nconst isObject = __webpack_require__(/*! ./helpers/isObject */ \"../backend/node_modules/mongoose/lib/helpers/isObject.js\");\n\n/**\n * Document constructor.\n *\n * @param {Object} obj the values to set\n * @param {Object} schema\n * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data\n * @param {Boolean} [skipId] bool, should we auto create an ObjectId _id\n * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#class-eventemitter\n * @event `init`: Emitted on a document after it has was retrieved from the db and fully hydrated by Mongoose.\n * @event `save`: Emitted when the document is successfully saved\n * @api private\n */\n\nfunction Document(obj, schema, fields, skipId, skipInit) {\n  if (!(this instanceof Document)) {\n    return new Document(obj, schema, fields, skipId, skipInit);\n  }\n\n  if (isObject(schema) && !schema.instanceOfSchema) {\n    schema = new Schema(schema);\n  }\n\n  // When creating EmbeddedDocument, it already has the schema and he doesn't need the _id\n  schema = this.schema || schema;\n\n  // Generate ObjectId if it is missing, but it requires a scheme\n  if (!this.schema && schema.options._id) {\n    obj = obj || {};\n\n    if (obj._id === undefined) {\n      obj._id = new ObjectId();\n    }\n  }\n\n  if (!schema) {\n    throw new MongooseError.MissingSchemaError();\n  }\n\n  this.$__setSchema(schema);\n\n  NodeJSDocument.call(this, obj, fields, skipId, skipInit);\n\n  applyHooks(this, schema, { decorateDoc: true });\n\n  // apply methods\n  for (const m in schema.methods) {\n    this[m] = schema.methods[m];\n  }\n  // apply statics\n  for (const s in schema.statics) {\n    this[s] = schema.statics[s];\n  }\n}\n\n/*!\n * Inherit from the NodeJS document\n */\n\nDocument.prototype = Object.create(NodeJSDocument.prototype);\nDocument.prototype.constructor = Document;\n\n/*!\n * ignore\n */\n\nDocument.events = new EventEmitter();\n\n/*!\n * Browser doc exposes the event emitter API\n */\n\nDocument.$emitter = new EventEmitter();\n\n['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners',\n  'removeAllListeners', 'addListener'].forEach(function(emitterFn) {\n  Document[emitterFn] = function() {\n    return Document.$emitter[emitterFn].apply(Document.$emitter, arguments);\n  };\n});\n\n/*!\n * Module exports.\n */\n\nDocument.ValidationError = ValidationError;\nmodule.exports = exports = Document;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Jyb3dzZXJEb2N1bWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsdUJBQXVCLG1CQUFPLENBQUMsb0VBQVk7QUFDM0MscUJBQXFCLDBEQUE4QjtBQUNuRCxzQkFBc0IsbUJBQU8sQ0FBQywwRUFBZTtBQUM3QyxlQUFlLG1CQUFPLENBQUMsZ0VBQVU7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMsZ0ZBQWtCO0FBQzNDO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsb0dBQTRCO0FBQ3ZELGlCQUFpQixtQkFBTyxDQUFDLG9GQUFvQjs7QUFFN0M7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw2QkFBNkIsbUJBQW1COztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9icm93c2VyRG9jdW1lbnQuanM/MmRmNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBOb2RlSlNEb2N1bWVudCA9IHJlcXVpcmUoJy4vZG9jdW1lbnQnKTtcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL2luZGV4Jyk7XG5jb25zdCBTY2hlbWEgPSByZXF1aXJlKCcuL3NjaGVtYScpO1xuY29uc3QgT2JqZWN0SWQgPSByZXF1aXJlKCcuL3R5cGVzL29iamVjdGlkJyk7XG5jb25zdCBWYWxpZGF0aW9uRXJyb3IgPSBNb25nb29zZUVycm9yLlZhbGlkYXRpb25FcnJvcjtcbmNvbnN0IGFwcGx5SG9va3MgPSByZXF1aXJlKCcuL2hlbHBlcnMvbW9kZWwvYXBwbHlIb29rcycpO1xuY29uc3QgaXNPYmplY3QgPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNPYmplY3QnKTtcblxuLyoqXG4gKiBEb2N1bWVudCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIHRoZSB2YWx1ZXMgdG8gc2V0XG4gKiBAcGFyYW0ge09iamVjdH0gc2NoZW1hXG4gKiBAcGFyYW0ge09iamVjdH0gW2ZpZWxkc10gb3B0aW9uYWwgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZpZWxkcyB3aGljaCB3ZXJlIHNlbGVjdGVkIGluIHRoZSBxdWVyeSByZXR1cm5pbmcgdGhpcyBkb2N1bWVudCBhbmQgYW55IHBvcHVsYXRlZCBwYXRocyBkYXRhXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtza2lwSWRdIGJvb2wsIHNob3VsZCB3ZSBhdXRvIGNyZWF0ZSBhbiBPYmplY3RJZCBfaWRcbiAqIEBpbmhlcml0cyBOb2RlSlMgRXZlbnRFbWl0dGVyIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZXZlbnRzLmh0bWwjY2xhc3MtZXZlbnRlbWl0dGVyXG4gKiBAZXZlbnQgYGluaXRgOiBFbWl0dGVkIG9uIGEgZG9jdW1lbnQgYWZ0ZXIgaXQgaGFzIHdhcyByZXRyaWV2ZWQgZnJvbSB0aGUgZGIgYW5kIGZ1bGx5IGh5ZHJhdGVkIGJ5IE1vbmdvb3NlLlxuICogQGV2ZW50IGBzYXZlYDogRW1pdHRlZCB3aGVuIHRoZSBkb2N1bWVudCBpcyBzdWNjZXNzZnVsbHkgc2F2ZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIERvY3VtZW50KG9iaiwgc2NoZW1hLCBmaWVsZHMsIHNraXBJZCwgc2tpcEluaXQpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERvY3VtZW50KSkge1xuICAgIHJldHVybiBuZXcgRG9jdW1lbnQob2JqLCBzY2hlbWEsIGZpZWxkcywgc2tpcElkLCBza2lwSW5pdCk7XG4gIH1cblxuICBpZiAoaXNPYmplY3Qoc2NoZW1hKSAmJiAhc2NoZW1hLmluc3RhbmNlT2ZTY2hlbWEpIHtcbiAgICBzY2hlbWEgPSBuZXcgU2NoZW1hKHNjaGVtYSk7XG4gIH1cblxuICAvLyBXaGVuIGNyZWF0aW5nIEVtYmVkZGVkRG9jdW1lbnQsIGl0IGFscmVhZHkgaGFzIHRoZSBzY2hlbWEgYW5kIGhlIGRvZXNuJ3QgbmVlZCB0aGUgX2lkXG4gIHNjaGVtYSA9IHRoaXMuc2NoZW1hIHx8IHNjaGVtYTtcblxuICAvLyBHZW5lcmF0ZSBPYmplY3RJZCBpZiBpdCBpcyBtaXNzaW5nLCBidXQgaXQgcmVxdWlyZXMgYSBzY2hlbWVcbiAgaWYgKCF0aGlzLnNjaGVtYSAmJiBzY2hlbWEub3B0aW9ucy5faWQpIHtcbiAgICBvYmogPSBvYmogfHwge307XG5cbiAgICBpZiAob2JqLl9pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvYmouX2lkID0gbmV3IE9iamVjdElkKCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFzY2hlbWEpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvci5NaXNzaW5nU2NoZW1hRXJyb3IoKTtcbiAgfVxuXG4gIHRoaXMuJF9fc2V0U2NoZW1hKHNjaGVtYSk7XG5cbiAgTm9kZUpTRG9jdW1lbnQuY2FsbCh0aGlzLCBvYmosIGZpZWxkcywgc2tpcElkLCBza2lwSW5pdCk7XG5cbiAgYXBwbHlIb29rcyh0aGlzLCBzY2hlbWEsIHsgZGVjb3JhdGVEb2M6IHRydWUgfSk7XG5cbiAgLy8gYXBwbHkgbWV0aG9kc1xuICBmb3IgKGNvbnN0IG0gaW4gc2NoZW1hLm1ldGhvZHMpIHtcbiAgICB0aGlzW21dID0gc2NoZW1hLm1ldGhvZHNbbV07XG4gIH1cbiAgLy8gYXBwbHkgc3RhdGljc1xuICBmb3IgKGNvbnN0IHMgaW4gc2NoZW1hLnN0YXRpY3MpIHtcbiAgICB0aGlzW3NdID0gc2NoZW1hLnN0YXRpY3Nbc107XG4gIH1cbn1cblxuLyohXG4gKiBJbmhlcml0IGZyb20gdGhlIE5vZGVKUyBkb2N1bWVudFxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZUpTRG9jdW1lbnQucHJvdG90eXBlKTtcbkRvY3VtZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERvY3VtZW50O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbkRvY3VtZW50LmV2ZW50cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuLyohXG4gKiBCcm93c2VyIGRvYyBleHBvc2VzIHRoZSBldmVudCBlbWl0dGVyIEFQSVxuICovXG5cbkRvY3VtZW50LiRlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5bJ29uJywgJ29uY2UnLCAnZW1pdCcsICdsaXN0ZW5lcnMnLCAncmVtb3ZlTGlzdGVuZXInLCAnc2V0TWF4TGlzdGVuZXJzJyxcbiAgJ3JlbW92ZUFsbExpc3RlbmVycycsICdhZGRMaXN0ZW5lciddLmZvckVhY2goZnVuY3Rpb24oZW1pdHRlckZuKSB7XG4gIERvY3VtZW50W2VtaXR0ZXJGbl0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gRG9jdW1lbnQuJGVtaXR0ZXJbZW1pdHRlckZuXS5hcHBseShEb2N1bWVudC4kZW1pdHRlciwgYXJndW1lbnRzKTtcbiAgfTtcbn0pO1xuXG4vKiFcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbkRvY3VtZW50LlZhbGlkYXRpb25FcnJvciA9IFZhbGlkYXRpb25FcnJvcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IERvY3VtZW50O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/browserDocument.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/cast.js":
/*!****************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/cast.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = __webpack_require__(/*! ./error/cast */ \"../backend/node_modules/mongoose/lib/error/cast.js\");\nconst StrictModeError = __webpack_require__(/*! ./error/strict */ \"../backend/node_modules/mongoose/lib/error/strict.js\");\nconst Types = __webpack_require__(/*! ./schema/index */ \"../backend/node_modules/mongoose/lib/schema/index.js\");\nconst cast$expr = __webpack_require__(/*! ./helpers/query/cast$expr */ \"../backend/node_modules/mongoose/lib/helpers/query/cast$expr.js\");\nconst castTextSearch = __webpack_require__(/*! ./schema/operators/text */ \"../backend/node_modules/mongoose/lib/schema/operators/text.js\");\nconst get = __webpack_require__(/*! ./helpers/get */ \"../backend/node_modules/mongoose/lib/helpers/get.js\");\nconst getSchemaDiscriminatorByValue = __webpack_require__(/*! ./helpers/discriminator/getSchemaDiscriminatorByValue */ \"../backend/node_modules/mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js\");\nconst isOperator = __webpack_require__(/*! ./helpers/query/isOperator */ \"../backend/node_modules/mongoose/lib/helpers/query/isOperator.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst isObject = __webpack_require__(/*! ./helpers/isObject */ \"../backend/node_modules/mongoose/lib/helpers/isObject.js\");\nconst isMongooseObject = __webpack_require__(/*! ./helpers/isMongooseObject */ \"../backend/node_modules/mongoose/lib/helpers/isMongooseObject.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\n\nconst ALLOWED_GEOWITHIN_GEOJSON_TYPES = ['Polygon', 'MultiPolygon'];\n\n/**\n * Handles internal casting for query filters.\n *\n * @param {Schema} schema\n * @param {Object} obj Object to cast\n * @param {Object} [options] the query options\n * @param {Boolean|\"throw\"} [options.strict] Wheter to enable all strict options\n * @param {Boolean|\"throw\"} [options.strictQuery] Enable strict Queries\n * @param {Boolean} [options.upsert]\n * @param {Query} [context] passed to setters\n * @api private\n */\nmodule.exports = function cast(schema, obj, options, context) {\n  if (Array.isArray(obj)) {\n    throw new Error('Query filter must be an object, got an array ', util.inspect(obj));\n  }\n\n  if (obj == null) {\n    return obj;\n  }\n\n  if (schema != null && schema.discriminators != null && obj[schema.options.discriminatorKey] != null) {\n    schema = getSchemaDiscriminatorByValue(schema, obj[schema.options.discriminatorKey]) || schema;\n  }\n\n  const paths = Object.keys(obj);\n  let i = paths.length;\n  let _keys;\n  let any$conditionals;\n  let schematype;\n  let nested;\n  let path;\n  let type;\n  let val;\n\n  options = options || {};\n\n  while (i--) {\n    path = paths[i];\n    val = obj[path];\n\n    if (path === '$or' || path === '$nor' || path === '$and') {\n      if (!Array.isArray(val)) {\n        throw new CastError('Array', val, path);\n      }\n      for (let k = 0; k < val.length; ++k) {\n        if (val[k] == null || typeof val[k] !== 'object') {\n          throw new CastError('Object', val[k], path + '.' + k);\n        }\n        const discriminatorValue = val[k][schema.options.discriminatorKey];\n        if (discriminatorValue == null) {\n          val[k] = cast(schema, val[k], options, context);\n        } else {\n          const discriminatorSchema = getSchemaDiscriminatorByValue(context.schema, discriminatorValue);\n          val[k] = cast(discriminatorSchema ? discriminatorSchema : schema, val[k], options, context);\n        }\n      }\n    } else if (path === '$where') {\n      type = typeof val;\n\n      if (type !== 'string' && type !== 'function') {\n        throw new Error('Must have a string or function for $where');\n      }\n\n      if (type === 'function') {\n        obj[path] = val.toString();\n      }\n\n      continue;\n    } else if (path === '$expr') {\n      val = cast$expr(val, schema);\n      continue;\n    } else if (path === '$elemMatch') {\n      val = cast(schema, val, options, context);\n    } else if (path === '$text') {\n      val = castTextSearch(val, path);\n    } else {\n      if (!schema) {\n        // no casting for Mixed types\n        continue;\n      }\n\n      schematype = schema.path(path);\n\n      // Check for embedded discriminator paths\n      if (!schematype) {\n        const split = path.split('.');\n        let j = split.length;\n        while (j--) {\n          const pathFirstHalf = split.slice(0, j).join('.');\n          const pathLastHalf = split.slice(j).join('.');\n          const _schematype = schema.path(pathFirstHalf);\n          const discriminatorKey = _schematype &&\n            _schematype.schema &&\n            _schematype.schema.options &&\n            _schematype.schema.options.discriminatorKey;\n\n          // gh-6027: if we haven't found the schematype but this path is\n          // underneath an embedded discriminator and the embedded discriminator\n          // key is in the query, use the embedded discriminator schema\n          if (_schematype != null &&\n            (_schematype.schema && _schematype.schema.discriminators) != null &&\n            discriminatorKey != null &&\n            pathLastHalf !== discriminatorKey) {\n            const discriminatorVal = get(obj, pathFirstHalf + '.' + discriminatorKey);\n            const discriminators = _schematype.schema.discriminators;\n            if (typeof discriminatorVal === 'string' && discriminators[discriminatorVal] != null) {\n\n              schematype = discriminators[discriminatorVal].path(pathLastHalf);\n            } else if (discriminatorVal != null &&\n              Object.keys(discriminatorVal).length === 1 &&\n              Array.isArray(discriminatorVal.$in) &&\n              discriminatorVal.$in.length === 1 &&\n              typeof discriminatorVal.$in[0] === 'string' &&\n              discriminators[discriminatorVal.$in[0]] != null) {\n              schematype = discriminators[discriminatorVal.$in[0]].path(pathLastHalf);\n            }\n          }\n        }\n      }\n\n      if (!schematype) {\n        // Handle potential embedded array queries\n        const split = path.split('.');\n        let j = split.length;\n        let pathFirstHalf;\n        let pathLastHalf;\n        let remainingConds;\n\n        // Find the part of the var path that is a path of the Schema\n        while (j--) {\n          pathFirstHalf = split.slice(0, j).join('.');\n          schematype = schema.path(pathFirstHalf);\n          if (schematype) {\n            break;\n          }\n        }\n\n        // If a substring of the input path resolves to an actual real path...\n        if (schematype) {\n          // Apply the casting; similar code for $elemMatch in schema/array.js\n          if (schematype.caster && schematype.caster.schema) {\n            remainingConds = {};\n            pathLastHalf = split.slice(j).join('.');\n            remainingConds[pathLastHalf] = val;\n\n            const ret = cast(schematype.caster.schema, remainingConds, options, context)[pathLastHalf];\n            if (ret === void 0) {\n              delete obj[path];\n            } else {\n              obj[path] = ret;\n            }\n          } else {\n            obj[path] = val;\n          }\n          continue;\n        }\n\n        if (isObject(val)) {\n          // handle geo schemas that use object notation\n          // { loc: { long: Number, lat: Number }\n\n          let geo = '';\n          if (val.$near) {\n            geo = '$near';\n          } else if (val.$nearSphere) {\n            geo = '$nearSphere';\n          } else if (val.$within) {\n            geo = '$within';\n          } else if (val.$geoIntersects) {\n            geo = '$geoIntersects';\n          } else if (val.$geoWithin) {\n            geo = '$geoWithin';\n          }\n\n          if (geo) {\n            const numbertype = new Types.Number('__QueryCasting__');\n            let value = val[geo];\n\n            if (val.$maxDistance != null) {\n              val.$maxDistance = numbertype.castForQuery(\n                null,\n                val.$maxDistance,\n                context\n              );\n            }\n            if (val.$minDistance != null) {\n              val.$minDistance = numbertype.castForQuery(\n                null,\n                val.$minDistance,\n                context\n              );\n            }\n\n            if (geo === '$within') {\n              const withinType = value.$center\n                  || value.$centerSphere\n                  || value.$box\n                  || value.$polygon;\n\n              if (!withinType) {\n                throw new Error('Bad $within parameter: ' + JSON.stringify(val));\n              }\n\n              value = withinType;\n            } else if (geo === '$near' &&\n                typeof value.type === 'string' && Array.isArray(value.coordinates)) {\n              // geojson; cast the coordinates\n              value = value.coordinates;\n            } else if ((geo === '$near' || geo === '$nearSphere' || geo === '$geoIntersects') &&\n                value.$geometry && typeof value.$geometry.type === 'string' &&\n                Array.isArray(value.$geometry.coordinates)) {\n              if (value.$maxDistance != null) {\n                value.$maxDistance = numbertype.castForQuery(\n                  null,\n                  value.$maxDistance,\n                  context\n                );\n              }\n              if (value.$minDistance != null) {\n                value.$minDistance = numbertype.castForQuery(\n                  null,\n                  value.$minDistance,\n                  context\n                );\n              }\n              if (isMongooseObject(value.$geometry)) {\n                value.$geometry = value.$geometry.toObject({\n                  transform: false,\n                  virtuals: false\n                });\n              }\n              value = value.$geometry.coordinates;\n            } else if (geo === '$geoWithin') {\n              if (value.$geometry) {\n                if (isMongooseObject(value.$geometry)) {\n                  value.$geometry = value.$geometry.toObject({ virtuals: false });\n                }\n                const geoWithinType = value.$geometry.type;\n                if (ALLOWED_GEOWITHIN_GEOJSON_TYPES.indexOf(geoWithinType) === -1) {\n                  throw new Error('Invalid geoJSON type for $geoWithin \"' +\n                    geoWithinType + '\", must be \"Polygon\" or \"MultiPolygon\"');\n                }\n                value = value.$geometry.coordinates;\n              } else {\n                value = value.$box || value.$polygon || value.$center ||\n                  value.$centerSphere;\n                if (isMongooseObject(value)) {\n                  value = value.toObject({ virtuals: false });\n                }\n              }\n            }\n\n            _cast(value, numbertype, context);\n            continue;\n          }\n        }\n\n        if (schema.nested[path]) {\n          continue;\n        }\n\n        const strict = 'strict' in options ? options.strict : schema.options.strict;\n        const strictQuery = getStrictQuery(options, schema._userProvidedOptions, schema.options, context);\n        if (options.upsert && strict) {\n          if (strict === 'throw') {\n            throw new StrictModeError(path);\n          }\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' +\n            'schema, strict mode is `true`, and upsert is `true`.');\n        } if (strictQuery === 'throw') {\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' +\n            'schema and strictQuery is \\'throw\\'.');\n        } else if (strictQuery) {\n          delete obj[path];\n        }\n      } else if (val == null) {\n        continue;\n      } else if (utils.isPOJO(val)) {\n        any$conditionals = Object.keys(val).some(isOperator);\n\n        if (!any$conditionals) {\n          obj[path] = schematype.castForQuery(\n            null,\n            val,\n            context\n          );\n        } else {\n          const ks = Object.keys(val);\n          let $cond;\n          let k = ks.length;\n\n          while (k--) {\n            $cond = ks[k];\n            nested = val[$cond];\n            if ($cond === '$elemMatch') {\n              if (nested && schematype != null && schematype.schema != null) {\n                cast(schematype.schema, nested, options, context);\n              } else if (nested && schematype != null && schematype.$isMongooseArray) {\n                if (utils.isPOJO(nested) && nested.$not != null) {\n                  cast(schema, nested, options, context);\n                } else {\n                  val[$cond] = schematype.castForQuery(\n                    $cond,\n                    nested,\n                    context\n                  );\n                }\n              }\n            } else if ($cond === '$not') {\n              if (nested && schematype) {\n                _keys = Object.keys(nested);\n                if (_keys.length && isOperator(_keys[0])) {\n                  for (const key in nested) {\n                    nested[key] = schematype.castForQuery(\n                      key,\n                      nested[key],\n                      context\n                    );\n                  }\n                } else {\n                  val[$cond] = schematype.castForQuery(\n                    $cond,\n                    nested,\n                    context\n                  );\n                }\n                continue;\n              }\n            } else {\n              val[$cond] = schematype.castForQuery(\n                $cond,\n                nested,\n                context\n              );\n            }\n\n          }\n        }\n      } else if (Array.isArray(val) && ['Buffer', 'Array'].indexOf(schematype.instance) === -1) {\n        const casted = [];\n        const valuesArray = val;\n\n        for (const _val of valuesArray) {\n          casted.push(schematype.castForQuery(\n            null,\n            _val,\n            context\n          ));\n        }\n\n        obj[path] = { $in: casted };\n      } else {\n        obj[path] = schematype.castForQuery(\n          null,\n          val,\n          context\n        );\n      }\n    }\n  }\n\n  return obj;\n};\n\nfunction _cast(val, numbertype, context) {\n  if (Array.isArray(val)) {\n    val.forEach(function(item, i) {\n      if (Array.isArray(item) || isObject(item)) {\n        return _cast(item, numbertype, context);\n      }\n      val[i] = numbertype.castForQuery(null, item, context);\n    });\n  } else {\n    const nearKeys = Object.keys(val);\n    let nearLen = nearKeys.length;\n    while (nearLen--) {\n      const nkey = nearKeys[nearLen];\n      const item = val[nkey];\n      if (Array.isArray(item) || isObject(item)) {\n        _cast(item, numbertype, context);\n        val[nkey] = item;\n      } else {\n        val[nkey] = numbertype.castForQuery({ val: item, context: context });\n      }\n    }\n  }\n}\n\nfunction getStrictQuery(queryOptions, schemaUserProvidedOptions, schemaOptions, context) {\n  if ('strictQuery' in queryOptions) {\n    return queryOptions.strictQuery;\n  }\n  if ('strictQuery' in schemaUserProvidedOptions) {\n    return schemaUserProvidedOptions.strictQuery;\n  }\n  const mongooseOptions = context &&\n    context.mongooseCollection &&\n    context.mongooseCollection.conn &&\n    context.mongooseCollection.conn.base &&\n    context.mongooseCollection.conn.base.options;\n  if (mongooseOptions) {\n    if ('strictQuery' in mongooseOptions) {\n      return mongooseOptions.strictQuery;\n    }\n  }\n  return schemaOptions.strictQuery;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Nhc3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixtQkFBTyxDQUFDLHdFQUFjO0FBQ3hDLHdCQUF3QixtQkFBTyxDQUFDLDRFQUFnQjtBQUNoRCxjQUFjLG1CQUFPLENBQUMsNEVBQWdCO0FBQ3RDLGtCQUFrQixtQkFBTyxDQUFDLGtHQUEyQjtBQUNyRCx1QkFBdUIsbUJBQU8sQ0FBQyw4RkFBeUI7QUFDeEQsWUFBWSxtQkFBTyxDQUFDLDBFQUFlO0FBQ25DLHNDQUFzQyxtQkFBTyxDQUFDLDBKQUF1RDtBQUNyRyxtQkFBbUIsbUJBQU8sQ0FBQyxvR0FBNEI7QUFDdkQsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGlCQUFpQixtQkFBTyxDQUFDLG9GQUFvQjtBQUM3Qyx5QkFBeUIsbUJBQU8sQ0FBQyxvR0FBNEI7QUFDN0QsY0FBYyxtQkFBTyxDQUFDLDhEQUFTOztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY2FzdC5qcz9kMmIyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IENhc3RFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3IvY2FzdCcpO1xuY29uc3QgU3RyaWN0TW9kZUVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9zdHJpY3QnKTtcbmNvbnN0IFR5cGVzID0gcmVxdWlyZSgnLi9zY2hlbWEvaW5kZXgnKTtcbmNvbnN0IGNhc3QkZXhwciA9IHJlcXVpcmUoJy4vaGVscGVycy9xdWVyeS9jYXN0JGV4cHInKTtcbmNvbnN0IGNhc3RUZXh0U2VhcmNoID0gcmVxdWlyZSgnLi9zY2hlbWEvb3BlcmF0b3JzL3RleHQnKTtcbmNvbnN0IGdldCA9IHJlcXVpcmUoJy4vaGVscGVycy9nZXQnKTtcbmNvbnN0IGdldFNjaGVtYURpc2NyaW1pbmF0b3JCeVZhbHVlID0gcmVxdWlyZSgnLi9oZWxwZXJzL2Rpc2NyaW1pbmF0b3IvZ2V0U2NoZW1hRGlzY3JpbWluYXRvckJ5VmFsdWUnKTtcbmNvbnN0IGlzT3BlcmF0b3IgPSByZXF1aXJlKCcuL2hlbHBlcnMvcXVlcnkvaXNPcGVyYXRvcicpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9oZWxwZXJzL2lzT2JqZWN0Jyk7XG5jb25zdCBpc01vbmdvb3NlT2JqZWN0ID0gcmVxdWlyZSgnLi9oZWxwZXJzL2lzTW9uZ29vc2VPYmplY3QnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5jb25zdCBBTExPV0VEX0dFT1dJVEhJTl9HRU9KU09OX1RZUEVTID0gWydQb2x5Z29uJywgJ011bHRpUG9seWdvbiddO1xuXG4vKipcbiAqIEhhbmRsZXMgaW50ZXJuYWwgY2FzdGluZyBmb3IgcXVlcnkgZmlsdGVycy5cbiAqXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIE9iamVjdCB0byBjYXN0XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIHRoZSBxdWVyeSBvcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW58XCJ0aHJvd1wifSBbb3B0aW9ucy5zdHJpY3RdIFdoZXRlciB0byBlbmFibGUgYWxsIHN0cmljdCBvcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW58XCJ0aHJvd1wifSBbb3B0aW9ucy5zdHJpY3RRdWVyeV0gRW5hYmxlIHN0cmljdCBRdWVyaWVzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnVwc2VydF1cbiAqIEBwYXJhbSB7UXVlcnl9IFtjb250ZXh0XSBwYXNzZWQgdG8gc2V0dGVyc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FzdChzY2hlbWEsIG9iaiwgb3B0aW9ucywgY29udGV4dCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdRdWVyeSBmaWx0ZXIgbXVzdCBiZSBhbiBvYmplY3QsIGdvdCBhbiBhcnJheSAnLCB1dGlsLmluc3BlY3Qob2JqKSk7XG4gIH1cblxuICBpZiAob2JqID09IG51bGwpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgaWYgKHNjaGVtYSAhPSBudWxsICYmIHNjaGVtYS5kaXNjcmltaW5hdG9ycyAhPSBudWxsICYmIG9ialtzY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5XSAhPSBudWxsKSB7XG4gICAgc2NoZW1hID0gZ2V0U2NoZW1hRGlzY3JpbWluYXRvckJ5VmFsdWUoc2NoZW1hLCBvYmpbc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleV0pIHx8IHNjaGVtYTtcbiAgfVxuXG4gIGNvbnN0IHBhdGhzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgbGV0IGkgPSBwYXRocy5sZW5ndGg7XG4gIGxldCBfa2V5cztcbiAgbGV0IGFueSRjb25kaXRpb25hbHM7XG4gIGxldCBzY2hlbWF0eXBlO1xuICBsZXQgbmVzdGVkO1xuICBsZXQgcGF0aDtcbiAgbGV0IHR5cGU7XG4gIGxldCB2YWw7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIHBhdGggPSBwYXRoc1tpXTtcbiAgICB2YWwgPSBvYmpbcGF0aF07XG5cbiAgICBpZiAocGF0aCA9PT0gJyRvcicgfHwgcGF0aCA9PT0gJyRub3InIHx8IHBhdGggPT09ICckYW5kJykge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IENhc3RFcnJvcignQXJyYXknLCB2YWwsIHBhdGgpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCB2YWwubGVuZ3RoOyArK2spIHtcbiAgICAgICAgaWYgKHZhbFtrXSA9PSBudWxsIHx8IHR5cGVvZiB2YWxba10gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IENhc3RFcnJvcignT2JqZWN0JywgdmFsW2tdLCBwYXRoICsgJy4nICsgayk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvclZhbHVlID0gdmFsW2tdW3NjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXldO1xuICAgICAgICBpZiAoZGlzY3JpbWluYXRvclZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICB2YWxba10gPSBjYXN0KHNjaGVtYSwgdmFsW2tdLCBvcHRpb25zLCBjb250ZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yU2NoZW1hID0gZ2V0U2NoZW1hRGlzY3JpbWluYXRvckJ5VmFsdWUoY29udGV4dC5zY2hlbWEsIGRpc2NyaW1pbmF0b3JWYWx1ZSk7XG4gICAgICAgICAgdmFsW2tdID0gY2FzdChkaXNjcmltaW5hdG9yU2NoZW1hID8gZGlzY3JpbWluYXRvclNjaGVtYSA6IHNjaGVtYSwgdmFsW2tdLCBvcHRpb25zLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGF0aCA9PT0gJyR3aGVyZScpIHtcbiAgICAgIHR5cGUgPSB0eXBlb2YgdmFsO1xuXG4gICAgICBpZiAodHlwZSAhPT0gJ3N0cmluZycgJiYgdHlwZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgaGF2ZSBhIHN0cmluZyBvciBmdW5jdGlvbiBmb3IgJHdoZXJlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9ialtwYXRoXSA9IHZhbC50b1N0cmluZygpO1xuICAgICAgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKHBhdGggPT09ICckZXhwcicpIHtcbiAgICAgIHZhbCA9IGNhc3QkZXhwcih2YWwsIHNjaGVtYSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKHBhdGggPT09ICckZWxlbU1hdGNoJykge1xuICAgICAgdmFsID0gY2FzdChzY2hlbWEsIHZhbCwgb3B0aW9ucywgY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChwYXRoID09PSAnJHRleHQnKSB7XG4gICAgICB2YWwgPSBjYXN0VGV4dFNlYXJjaCh2YWwsIHBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXNjaGVtYSkge1xuICAgICAgICAvLyBubyBjYXN0aW5nIGZvciBNaXhlZCB0eXBlc1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc2NoZW1hdHlwZSA9IHNjaGVtYS5wYXRoKHBhdGgpO1xuXG4gICAgICAvLyBDaGVjayBmb3IgZW1iZWRkZWQgZGlzY3JpbWluYXRvciBwYXRoc1xuICAgICAgaWYgKCFzY2hlbWF0eXBlKSB7XG4gICAgICAgIGNvbnN0IHNwbGl0ID0gcGF0aC5zcGxpdCgnLicpO1xuICAgICAgICBsZXQgaiA9IHNwbGl0Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGotLSkge1xuICAgICAgICAgIGNvbnN0IHBhdGhGaXJzdEhhbGYgPSBzcGxpdC5zbGljZSgwLCBqKS5qb2luKCcuJyk7XG4gICAgICAgICAgY29uc3QgcGF0aExhc3RIYWxmID0gc3BsaXQuc2xpY2Uoaikuam9pbignLicpO1xuICAgICAgICAgIGNvbnN0IF9zY2hlbWF0eXBlID0gc2NoZW1hLnBhdGgocGF0aEZpcnN0SGFsZik7XG4gICAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvcktleSA9IF9zY2hlbWF0eXBlICYmXG4gICAgICAgICAgICBfc2NoZW1hdHlwZS5zY2hlbWEgJiZcbiAgICAgICAgICAgIF9zY2hlbWF0eXBlLnNjaGVtYS5vcHRpb25zICYmXG4gICAgICAgICAgICBfc2NoZW1hdHlwZS5zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5O1xuXG4gICAgICAgICAgLy8gZ2gtNjAyNzogaWYgd2UgaGF2ZW4ndCBmb3VuZCB0aGUgc2NoZW1hdHlwZSBidXQgdGhpcyBwYXRoIGlzXG4gICAgICAgICAgLy8gdW5kZXJuZWF0aCBhbiBlbWJlZGRlZCBkaXNjcmltaW5hdG9yIGFuZCB0aGUgZW1iZWRkZWQgZGlzY3JpbWluYXRvclxuICAgICAgICAgIC8vIGtleSBpcyBpbiB0aGUgcXVlcnksIHVzZSB0aGUgZW1iZWRkZWQgZGlzY3JpbWluYXRvciBzY2hlbWFcbiAgICAgICAgICBpZiAoX3NjaGVtYXR5cGUgIT0gbnVsbCAmJlxuICAgICAgICAgICAgKF9zY2hlbWF0eXBlLnNjaGVtYSAmJiBfc2NoZW1hdHlwZS5zY2hlbWEuZGlzY3JpbWluYXRvcnMpICE9IG51bGwgJiZcbiAgICAgICAgICAgIGRpc2NyaW1pbmF0b3JLZXkgIT0gbnVsbCAmJlxuICAgICAgICAgICAgcGF0aExhc3RIYWxmICE9PSBkaXNjcmltaW5hdG9yS2V5KSB7XG4gICAgICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsID0gZ2V0KG9iaiwgcGF0aEZpcnN0SGFsZiArICcuJyArIGRpc2NyaW1pbmF0b3JLZXkpO1xuICAgICAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvcnMgPSBfc2NoZW1hdHlwZS5zY2hlbWEuZGlzY3JpbWluYXRvcnM7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRpc2NyaW1pbmF0b3JWYWwgPT09ICdzdHJpbmcnICYmIGRpc2NyaW1pbmF0b3JzW2Rpc2NyaW1pbmF0b3JWYWxdICE9IG51bGwpIHtcblxuICAgICAgICAgICAgICBzY2hlbWF0eXBlID0gZGlzY3JpbWluYXRvcnNbZGlzY3JpbWluYXRvclZhbF0ucGF0aChwYXRoTGFzdEhhbGYpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkaXNjcmltaW5hdG9yVmFsICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZGlzY3JpbWluYXRvclZhbCkubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoZGlzY3JpbWluYXRvclZhbC4kaW4pICYmXG4gICAgICAgICAgICAgIGRpc2NyaW1pbmF0b3JWYWwuJGluLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgICB0eXBlb2YgZGlzY3JpbWluYXRvclZhbC4kaW5bMF0gPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgIGRpc2NyaW1pbmF0b3JzW2Rpc2NyaW1pbmF0b3JWYWwuJGluWzBdXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHNjaGVtYXR5cGUgPSBkaXNjcmltaW5hdG9yc1tkaXNjcmltaW5hdG9yVmFsLiRpblswXV0ucGF0aChwYXRoTGFzdEhhbGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXNjaGVtYXR5cGUpIHtcbiAgICAgICAgLy8gSGFuZGxlIHBvdGVudGlhbCBlbWJlZGRlZCBhcnJheSBxdWVyaWVzXG4gICAgICAgIGNvbnN0IHNwbGl0ID0gcGF0aC5zcGxpdCgnLicpO1xuICAgICAgICBsZXQgaiA9IHNwbGl0Lmxlbmd0aDtcbiAgICAgICAgbGV0IHBhdGhGaXJzdEhhbGY7XG4gICAgICAgIGxldCBwYXRoTGFzdEhhbGY7XG4gICAgICAgIGxldCByZW1haW5pbmdDb25kcztcblxuICAgICAgICAvLyBGaW5kIHRoZSBwYXJ0IG9mIHRoZSB2YXIgcGF0aCB0aGF0IGlzIGEgcGF0aCBvZiB0aGUgU2NoZW1hXG4gICAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgICBwYXRoRmlyc3RIYWxmID0gc3BsaXQuc2xpY2UoMCwgaikuam9pbignLicpO1xuICAgICAgICAgIHNjaGVtYXR5cGUgPSBzY2hlbWEucGF0aChwYXRoRmlyc3RIYWxmKTtcbiAgICAgICAgICBpZiAoc2NoZW1hdHlwZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgYSBzdWJzdHJpbmcgb2YgdGhlIGlucHV0IHBhdGggcmVzb2x2ZXMgdG8gYW4gYWN0dWFsIHJlYWwgcGF0aC4uLlxuICAgICAgICBpZiAoc2NoZW1hdHlwZSkge1xuICAgICAgICAgIC8vIEFwcGx5IHRoZSBjYXN0aW5nOyBzaW1pbGFyIGNvZGUgZm9yICRlbGVtTWF0Y2ggaW4gc2NoZW1hL2FycmF5LmpzXG4gICAgICAgICAgaWYgKHNjaGVtYXR5cGUuY2FzdGVyICYmIHNjaGVtYXR5cGUuY2FzdGVyLnNjaGVtYSkge1xuICAgICAgICAgICAgcmVtYWluaW5nQ29uZHMgPSB7fTtcbiAgICAgICAgICAgIHBhdGhMYXN0SGFsZiA9IHNwbGl0LnNsaWNlKGopLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIHJlbWFpbmluZ0NvbmRzW3BhdGhMYXN0SGFsZl0gPSB2YWw7XG5cbiAgICAgICAgICAgIGNvbnN0IHJldCA9IGNhc3Qoc2NoZW1hdHlwZS5jYXN0ZXIuc2NoZW1hLCByZW1haW5pbmdDb25kcywgb3B0aW9ucywgY29udGV4dClbcGF0aExhc3RIYWxmXTtcbiAgICAgICAgICAgIGlmIChyZXQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBkZWxldGUgb2JqW3BhdGhdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb2JqW3BhdGhdID0gcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmpbcGF0aF0gPSB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgICAvLyBoYW5kbGUgZ2VvIHNjaGVtYXMgdGhhdCB1c2Ugb2JqZWN0IG5vdGF0aW9uXG4gICAgICAgICAgLy8geyBsb2M6IHsgbG9uZzogTnVtYmVyLCBsYXQ6IE51bWJlciB9XG5cbiAgICAgICAgICBsZXQgZ2VvID0gJyc7XG4gICAgICAgICAgaWYgKHZhbC4kbmVhcikge1xuICAgICAgICAgICAgZ2VvID0gJyRuZWFyJztcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbC4kbmVhclNwaGVyZSkge1xuICAgICAgICAgICAgZ2VvID0gJyRuZWFyU3BoZXJlJztcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbC4kd2l0aGluKSB7XG4gICAgICAgICAgICBnZW8gPSAnJHdpdGhpbic7XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWwuJGdlb0ludGVyc2VjdHMpIHtcbiAgICAgICAgICAgIGdlbyA9ICckZ2VvSW50ZXJzZWN0cyc7XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWwuJGdlb1dpdGhpbikge1xuICAgICAgICAgICAgZ2VvID0gJyRnZW9XaXRoaW4nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChnZW8pIHtcbiAgICAgICAgICAgIGNvbnN0IG51bWJlcnR5cGUgPSBuZXcgVHlwZXMuTnVtYmVyKCdfX1F1ZXJ5Q2FzdGluZ19fJyk7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB2YWxbZ2VvXTtcblxuICAgICAgICAgICAgaWYgKHZhbC4kbWF4RGlzdGFuY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YWwuJG1heERpc3RhbmNlID0gbnVtYmVydHlwZS5jYXN0Rm9yUXVlcnkoXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICB2YWwuJG1heERpc3RhbmNlLFxuICAgICAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWwuJG1pbkRpc3RhbmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFsLiRtaW5EaXN0YW5jZSA9IG51bWJlcnR5cGUuY2FzdEZvclF1ZXJ5KFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgdmFsLiRtaW5EaXN0YW5jZSxcbiAgICAgICAgICAgICAgICBjb250ZXh0XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChnZW8gPT09ICckd2l0aGluJykge1xuICAgICAgICAgICAgICBjb25zdCB3aXRoaW5UeXBlID0gdmFsdWUuJGNlbnRlclxuICAgICAgICAgICAgICAgICAgfHwgdmFsdWUuJGNlbnRlclNwaGVyZVxuICAgICAgICAgICAgICAgICAgfHwgdmFsdWUuJGJveFxuICAgICAgICAgICAgICAgICAgfHwgdmFsdWUuJHBvbHlnb247XG5cbiAgICAgICAgICAgICAgaWYgKCF3aXRoaW5UeXBlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYWQgJHdpdGhpbiBwYXJhbWV0ZXI6ICcgKyBKU09OLnN0cmluZ2lmeSh2YWwpKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhbHVlID0gd2l0aGluVHlwZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZ2VvID09PSAnJG5lYXInICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlLnR5cGUgPT09ICdzdHJpbmcnICYmIEFycmF5LmlzQXJyYXkodmFsdWUuY29vcmRpbmF0ZXMpKSB7XG4gICAgICAgICAgICAgIC8vIGdlb2pzb247IGNhc3QgdGhlIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuY29vcmRpbmF0ZXM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChnZW8gPT09ICckbmVhcicgfHwgZ2VvID09PSAnJG5lYXJTcGhlcmUnIHx8IGdlbyA9PT0gJyRnZW9JbnRlcnNlY3RzJykgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZS4kZ2VvbWV0cnkgJiYgdHlwZW9mIHZhbHVlLiRnZW9tZXRyeS50eXBlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodmFsdWUuJGdlb21ldHJ5LmNvb3JkaW5hdGVzKSkge1xuICAgICAgICAgICAgICBpZiAodmFsdWUuJG1heERpc3RhbmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS4kbWF4RGlzdGFuY2UgPSBudW1iZXJ0eXBlLmNhc3RGb3JRdWVyeShcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICB2YWx1ZS4kbWF4RGlzdGFuY2UsXG4gICAgICAgICAgICAgICAgICBjb250ZXh0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodmFsdWUuJG1pbkRpc3RhbmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS4kbWluRGlzdGFuY2UgPSBudW1iZXJ0eXBlLmNhc3RGb3JRdWVyeShcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICB2YWx1ZS4kbWluRGlzdGFuY2UsXG4gICAgICAgICAgICAgICAgICBjb250ZXh0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNNb25nb29zZU9iamVjdCh2YWx1ZS4kZ2VvbWV0cnkpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUuJGdlb21ldHJ5ID0gdmFsdWUuJGdlb21ldHJ5LnRvT2JqZWN0KHtcbiAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICB2aXJ0dWFsczogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLiRnZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZ2VvID09PSAnJGdlb1dpdGhpbicpIHtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlLiRnZW9tZXRyeSkge1xuICAgICAgICAgICAgICAgIGlmIChpc01vbmdvb3NlT2JqZWN0KHZhbHVlLiRnZW9tZXRyeSkpIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlLiRnZW9tZXRyeSA9IHZhbHVlLiRnZW9tZXRyeS50b09iamVjdCh7IHZpcnR1YWxzOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZ2VvV2l0aGluVHlwZSA9IHZhbHVlLiRnZW9tZXRyeS50eXBlO1xuICAgICAgICAgICAgICAgIGlmIChBTExPV0VEX0dFT1dJVEhJTl9HRU9KU09OX1RZUEVTLmluZGV4T2YoZ2VvV2l0aGluVHlwZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZ2VvSlNPTiB0eXBlIGZvciAkZ2VvV2l0aGluIFwiJyArXG4gICAgICAgICAgICAgICAgICAgIGdlb1dpdGhpblR5cGUgKyAnXCIsIG11c3QgYmUgXCJQb2x5Z29uXCIgb3IgXCJNdWx0aVBvbHlnb25cIicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLiRnZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLiRib3ggfHwgdmFsdWUuJHBvbHlnb24gfHwgdmFsdWUuJGNlbnRlciB8fFxuICAgICAgICAgICAgICAgICAgdmFsdWUuJGNlbnRlclNwaGVyZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNNb25nb29zZU9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9PYmplY3QoeyB2aXJ0dWFsczogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jYXN0KHZhbHVlLCBudW1iZXJ0eXBlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzY2hlbWEubmVzdGVkW3BhdGhdKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdHJpY3QgPSAnc3RyaWN0JyBpbiBvcHRpb25zID8gb3B0aW9ucy5zdHJpY3QgOiBzY2hlbWEub3B0aW9ucy5zdHJpY3Q7XG4gICAgICAgIGNvbnN0IHN0cmljdFF1ZXJ5ID0gZ2V0U3RyaWN0UXVlcnkob3B0aW9ucywgc2NoZW1hLl91c2VyUHJvdmlkZWRPcHRpb25zLCBzY2hlbWEub3B0aW9ucywgY29udGV4dCk7XG4gICAgICAgIGlmIChvcHRpb25zLnVwc2VydCAmJiBzdHJpY3QpIHtcbiAgICAgICAgICBpZiAoc3RyaWN0ID09PSAndGhyb3cnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3RyaWN0TW9kZUVycm9yKHBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgU3RyaWN0TW9kZUVycm9yKHBhdGgsICdQYXRoIFwiJyArIHBhdGggKyAnXCIgaXMgbm90IGluICcgK1xuICAgICAgICAgICAgJ3NjaGVtYSwgc3RyaWN0IG1vZGUgaXMgYHRydWVgLCBhbmQgdXBzZXJ0IGlzIGB0cnVlYC4nKTtcbiAgICAgICAgfSBpZiAoc3RyaWN0UXVlcnkgPT09ICd0aHJvdycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3RyaWN0TW9kZUVycm9yKHBhdGgsICdQYXRoIFwiJyArIHBhdGggKyAnXCIgaXMgbm90IGluICcgK1xuICAgICAgICAgICAgJ3NjaGVtYSBhbmQgc3RyaWN0UXVlcnkgaXMgXFwndGhyb3dcXCcuJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0UXVlcnkpIHtcbiAgICAgICAgICBkZWxldGUgb2JqW3BhdGhdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmICh1dGlscy5pc1BPSk8odmFsKSkge1xuICAgICAgICBhbnkkY29uZGl0aW9uYWxzID0gT2JqZWN0LmtleXModmFsKS5zb21lKGlzT3BlcmF0b3IpO1xuXG4gICAgICAgIGlmICghYW55JGNvbmRpdGlvbmFscykge1xuICAgICAgICAgIG9ialtwYXRoXSA9IHNjaGVtYXR5cGUuY2FzdEZvclF1ZXJ5KFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGtzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICAgICAgICBsZXQgJGNvbmQ7XG4gICAgICAgICAgbGV0IGsgPSBrcy5sZW5ndGg7XG5cbiAgICAgICAgICB3aGlsZSAoay0tKSB7XG4gICAgICAgICAgICAkY29uZCA9IGtzW2tdO1xuICAgICAgICAgICAgbmVzdGVkID0gdmFsWyRjb25kXTtcbiAgICAgICAgICAgIGlmICgkY29uZCA9PT0gJyRlbGVtTWF0Y2gnKSB7XG4gICAgICAgICAgICAgIGlmIChuZXN0ZWQgJiYgc2NoZW1hdHlwZSAhPSBudWxsICYmIHNjaGVtYXR5cGUuc2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjYXN0KHNjaGVtYXR5cGUuc2NoZW1hLCBuZXN0ZWQsIG9wdGlvbnMsIGNvbnRleHQpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5lc3RlZCAmJiBzY2hlbWF0eXBlICE9IG51bGwgJiYgc2NoZW1hdHlwZS4kaXNNb25nb29zZUFycmF5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHV0aWxzLmlzUE9KTyhuZXN0ZWQpICYmIG5lc3RlZC4kbm90ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGNhc3Qoc2NoZW1hLCBuZXN0ZWQsIG9wdGlvbnMsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YWxbJGNvbmRdID0gc2NoZW1hdHlwZS5jYXN0Rm9yUXVlcnkoXG4gICAgICAgICAgICAgICAgICAgICRjb25kLFxuICAgICAgICAgICAgICAgICAgICBuZXN0ZWQsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCRjb25kID09PSAnJG5vdCcpIHtcbiAgICAgICAgICAgICAgaWYgKG5lc3RlZCAmJiBzY2hlbWF0eXBlKSB7XG4gICAgICAgICAgICAgICAgX2tleXMgPSBPYmplY3Qua2V5cyhuZXN0ZWQpO1xuICAgICAgICAgICAgICAgIGlmIChfa2V5cy5sZW5ndGggJiYgaXNPcGVyYXRvcihfa2V5c1swXSkpIHtcbiAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5lc3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBuZXN0ZWRba2V5XSA9IHNjaGVtYXR5cGUuY2FzdEZvclF1ZXJ5KFxuICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICBuZXN0ZWRba2V5XSxcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhbFskY29uZF0gPSBzY2hlbWF0eXBlLmNhc3RGb3JRdWVyeShcbiAgICAgICAgICAgICAgICAgICAgJGNvbmQsXG4gICAgICAgICAgICAgICAgICAgIG5lc3RlZCxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhbFskY29uZF0gPSBzY2hlbWF0eXBlLmNhc3RGb3JRdWVyeShcbiAgICAgICAgICAgICAgICAkY29uZCxcbiAgICAgICAgICAgICAgICBuZXN0ZWQsXG4gICAgICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsKSAmJiBbJ0J1ZmZlcicsICdBcnJheSddLmluZGV4T2Yoc2NoZW1hdHlwZS5pbnN0YW5jZSkgPT09IC0xKSB7XG4gICAgICAgIGNvbnN0IGNhc3RlZCA9IFtdO1xuICAgICAgICBjb25zdCB2YWx1ZXNBcnJheSA9IHZhbDtcblxuICAgICAgICBmb3IgKGNvbnN0IF92YWwgb2YgdmFsdWVzQXJyYXkpIHtcbiAgICAgICAgICBjYXN0ZWQucHVzaChzY2hlbWF0eXBlLmNhc3RGb3JRdWVyeShcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBfdmFsLFxuICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgICkpO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqW3BhdGhdID0geyAkaW46IGNhc3RlZCB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW3BhdGhdID0gc2NoZW1hdHlwZS5jYXN0Rm9yUXVlcnkoXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICB2YWwsXG4gICAgICAgICAgY29udGV4dFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5mdW5jdGlvbiBfY2FzdCh2YWwsIG51bWJlcnR5cGUsIGNvbnRleHQpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHZhbC5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0sIGkpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pIHx8IGlzT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgIHJldHVybiBfY2FzdChpdGVtLCBudW1iZXJ0eXBlLCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIHZhbFtpXSA9IG51bWJlcnR5cGUuY2FzdEZvclF1ZXJ5KG51bGwsIGl0ZW0sIGNvbnRleHQpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5lYXJLZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICBsZXQgbmVhckxlbiA9IG5lYXJLZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAobmVhckxlbi0tKSB7XG4gICAgICBjb25zdCBua2V5ID0gbmVhcktleXNbbmVhckxlbl07XG4gICAgICBjb25zdCBpdGVtID0gdmFsW25rZXldO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkgfHwgaXNPYmplY3QoaXRlbSkpIHtcbiAgICAgICAgX2Nhc3QoaXRlbSwgbnVtYmVydHlwZSwgY29udGV4dCk7XG4gICAgICAgIHZhbFtua2V5XSA9IGl0ZW07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWxbbmtleV0gPSBudW1iZXJ0eXBlLmNhc3RGb3JRdWVyeSh7IHZhbDogaXRlbSwgY29udGV4dDogY29udGV4dCB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U3RyaWN0UXVlcnkocXVlcnlPcHRpb25zLCBzY2hlbWFVc2VyUHJvdmlkZWRPcHRpb25zLCBzY2hlbWFPcHRpb25zLCBjb250ZXh0KSB7XG4gIGlmICgnc3RyaWN0UXVlcnknIGluIHF1ZXJ5T3B0aW9ucykge1xuICAgIHJldHVybiBxdWVyeU9wdGlvbnMuc3RyaWN0UXVlcnk7XG4gIH1cbiAgaWYgKCdzdHJpY3RRdWVyeScgaW4gc2NoZW1hVXNlclByb3ZpZGVkT3B0aW9ucykge1xuICAgIHJldHVybiBzY2hlbWFVc2VyUHJvdmlkZWRPcHRpb25zLnN0cmljdFF1ZXJ5O1xuICB9XG4gIGNvbnN0IG1vbmdvb3NlT3B0aW9ucyA9IGNvbnRleHQgJiZcbiAgICBjb250ZXh0Lm1vbmdvb3NlQ29sbGVjdGlvbiAmJlxuICAgIGNvbnRleHQubW9uZ29vc2VDb2xsZWN0aW9uLmNvbm4gJiZcbiAgICBjb250ZXh0Lm1vbmdvb3NlQ29sbGVjdGlvbi5jb25uLmJhc2UgJiZcbiAgICBjb250ZXh0Lm1vbmdvb3NlQ29sbGVjdGlvbi5jb25uLmJhc2Uub3B0aW9ucztcbiAgaWYgKG1vbmdvb3NlT3B0aW9ucykge1xuICAgIGlmICgnc3RyaWN0UXVlcnknIGluIG1vbmdvb3NlT3B0aW9ucykge1xuICAgICAgcmV0dXJuIG1vbmdvb3NlT3B0aW9ucy5zdHJpY3RRdWVyeTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNjaGVtYU9wdGlvbnMuc3RyaWN0UXVlcnk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/cast.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/cast/bigint.js":
/*!***********************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/cast/bigint.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst { Long } = __webpack_require__(/*! bson */ \"../backend/node_modules/bson/lib/bson.cjs\");\n\n/**\n * Given a value, cast it to a BigInt, or throw an `Error` if the value\n * cannot be casted. `null` and `undefined` are considered valid.\n *\n * @param {Any} value\n * @return {Number}\n * @throws {Error} if `value` is not one of the allowed values\n * @api private\n */\n\nmodule.exports = function castBigInt(val) {\n  if (val == null) {\n    return val;\n  }\n  if (val === '') {\n    return null;\n  }\n  if (typeof val === 'bigint') {\n    return val;\n  }\n\n  if (val instanceof Long) {\n    return val.toBigInt();\n  }\n\n  if (typeof val === 'string' || typeof val === 'number') {\n    return BigInt(val);\n  }\n\n  assert.ok(false);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Nhc3QvYmlnaW50LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixRQUFRLE9BQU8sRUFBRSxtQkFBTyxDQUFDLHVEQUFNOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixZQUFZO0FBQ1osWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Nhc3QvYmlnaW50LmpzP2RmOTYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbmNvbnN0IHsgTG9uZyB9ID0gcmVxdWlyZSgnYnNvbicpO1xuXG4vKipcbiAqIEdpdmVuIGEgdmFsdWUsIGNhc3QgaXQgdG8gYSBCaWdJbnQsIG9yIHRocm93IGFuIGBFcnJvcmAgaWYgdGhlIHZhbHVlXG4gKiBjYW5ub3QgYmUgY2FzdGVkLiBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIGFyZSBjb25zaWRlcmVkIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZVxuICogQHJldHVybiB7TnVtYmVyfVxuICogQHRocm93cyB7RXJyb3J9IGlmIGB2YWx1ZWAgaXMgbm90IG9uZSBvZiB0aGUgYWxsb3dlZCB2YWx1ZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FzdEJpZ0ludCh2YWwpIHtcbiAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBpZiAodmFsID09PSAnJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsID09PSAnYmlnaW50Jykge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBpZiAodmFsIGluc3RhbmNlb2YgTG9uZykge1xuICAgIHJldHVybiB2YWwudG9CaWdJbnQoKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBCaWdJbnQodmFsKTtcbiAgfVxuXG4gIGFzc2VydC5vayhmYWxzZSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/cast/bigint.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/cast/boolean.js":
/*!************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/cast/boolean.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst CastError = __webpack_require__(/*! ../error/cast */ \"../backend/node_modules/mongoose/lib/error/cast.js\");\n\n/**\n * Given a value, cast it to a boolean, or throw a `CastError` if the value\n * cannot be casted. `null` and `undefined` are considered valid.\n *\n * @param {Any} value\n * @param {String} [path] optional the path to set on the CastError\n * @return {Boolean|null|undefined}\n * @throws {CastError} if `value` is not one of the allowed values\n * @api private\n */\n\nmodule.exports = function castBoolean(value, path) {\n  if (module.exports.convertToTrue.has(value)) {\n    return true;\n  }\n  if (module.exports.convertToFalse.has(value)) {\n    return false;\n  }\n\n  if (value == null) {\n    return value;\n  }\n\n  throw new CastError('boolean', value, path);\n};\n\nmodule.exports.convertToTrue = new Set([true, 'true', 1, '1', 'yes']);\nmodule.exports.convertToFalse = new Set([false, 'false', 0, '0', 'no']);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Nhc3QvYm9vbGVhbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixrQkFBa0IsbUJBQU8sQ0FBQyx5RUFBZTs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWixZQUFZLFdBQVc7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUIsNkJBQTZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Nhc3QvYm9vbGVhbi5qcz8xNDJlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQ2FzdEVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvY2FzdCcpO1xuXG4vKipcbiAqIEdpdmVuIGEgdmFsdWUsIGNhc3QgaXQgdG8gYSBib29sZWFuLCBvciB0aHJvdyBhIGBDYXN0RXJyb3JgIGlmIHRoZSB2YWx1ZVxuICogY2Fubm90IGJlIGNhc3RlZC4gYG51bGxgIGFuZCBgdW5kZWZpbmVkYCBhcmUgY29uc2lkZXJlZCB2YWxpZC5cbiAqXG4gKiBAcGFyYW0ge0FueX0gdmFsdWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF0gb3B0aW9uYWwgdGhlIHBhdGggdG8gc2V0IG9uIHRoZSBDYXN0RXJyb3JcbiAqIEByZXR1cm4ge0Jvb2xlYW58bnVsbHx1bmRlZmluZWR9XG4gKiBAdGhyb3dzIHtDYXN0RXJyb3J9IGlmIGB2YWx1ZWAgaXMgbm90IG9uZSBvZiB0aGUgYWxsb3dlZCB2YWx1ZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FzdEJvb2xlYW4odmFsdWUsIHBhdGgpIHtcbiAgaWYgKG1vZHVsZS5leHBvcnRzLmNvbnZlcnRUb1RydWUuaGFzKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChtb2R1bGUuZXhwb3J0cy5jb252ZXJ0VG9GYWxzZS5oYXModmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdib29sZWFuJywgdmFsdWUsIHBhdGgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMuY29udmVydFRvVHJ1ZSA9IG5ldyBTZXQoW3RydWUsICd0cnVlJywgMSwgJzEnLCAneWVzJ10pO1xubW9kdWxlLmV4cG9ydHMuY29udmVydFRvRmFsc2UgPSBuZXcgU2V0KFtmYWxzZSwgJ2ZhbHNlJywgMCwgJzAnLCAnbm8nXSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/cast/boolean.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/cast/date.js":
/*!*********************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/cast/date.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! assert */ \"assert\");\n\nmodule.exports = function castDate(value) {\n  // Support empty string because of empty form values. Originally introduced\n  // in https://github.com/Automattic/mongoose/commit/efc72a1898fc3c33a319d915b8c5463a22938dfe\n  if (value == null || value === '') {\n    return null;\n  }\n\n  if (value instanceof Date) {\n    assert.ok(!isNaN(value.valueOf()));\n\n    return value;\n  }\n\n  let date;\n\n  assert.ok(typeof value !== 'boolean');\n\n  if (value instanceof Number || typeof value === 'number') {\n    date = new Date(value);\n  } else if (typeof value === 'string' && !isNaN(Number(value)) && (Number(value) >= 275761 || Number(value) < -271820)) {\n    // string representation of milliseconds take this path\n    date = new Date(Number(value));\n  } else if (typeof value.valueOf === 'function') {\n    // support for moment.js. This is also the path strings will take because\n    // strings have a `valueOf()`\n    date = new Date(value.valueOf());\n  } else {\n    // fallback\n    date = new Date(value);\n  }\n\n  if (!isNaN(date.valueOf())) {\n    return date;\n  }\n\n  assert.ok(false);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Nhc3QvZGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsc0JBQVE7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY2FzdC9kYXRlLmpzPzIyMTYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYXN0RGF0ZSh2YWx1ZSkge1xuICAvLyBTdXBwb3J0IGVtcHR5IHN0cmluZyBiZWNhdXNlIG9mIGVtcHR5IGZvcm0gdmFsdWVzLiBPcmlnaW5hbGx5IGludHJvZHVjZWRcbiAgLy8gaW4gaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvbW9uZ29vc2UvY29tbWl0L2VmYzcyYTE4OThmYzNjMzNhMzE5ZDkxNWI4YzU0NjNhMjI5MzhkZmVcbiAgaWYgKHZhbHVlID09IG51bGwgfHwgdmFsdWUgPT09ICcnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgYXNzZXJ0Lm9rKCFpc05hTih2YWx1ZS52YWx1ZU9mKCkpKTtcblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGxldCBkYXRlO1xuXG4gIGFzc2VydC5vayh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJyk7XG5cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICBkYXRlID0gbmV3IERhdGUodmFsdWUpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgIWlzTmFOKE51bWJlcih2YWx1ZSkpICYmIChOdW1iZXIodmFsdWUpID49IDI3NTc2MSB8fCBOdW1iZXIodmFsdWUpIDwgLTI3MTgyMCkpIHtcbiAgICAvLyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgbWlsbGlzZWNvbmRzIHRha2UgdGhpcyBwYXRoXG4gICAgZGF0ZSA9IG5ldyBEYXRlKE51bWJlcih2YWx1ZSkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gc3VwcG9ydCBmb3IgbW9tZW50LmpzLiBUaGlzIGlzIGFsc28gdGhlIHBhdGggc3RyaW5ncyB3aWxsIHRha2UgYmVjYXVzZVxuICAgIC8vIHN0cmluZ3MgaGF2ZSBhIGB2YWx1ZU9mKClgXG4gICAgZGF0ZSA9IG5ldyBEYXRlKHZhbHVlLnZhbHVlT2YoKSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZmFsbGJhY2tcbiAgICBkYXRlID0gbmV3IERhdGUodmFsdWUpO1xuICB9XG5cbiAgaWYgKCFpc05hTihkYXRlLnZhbHVlT2YoKSkpIHtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuXG4gIGFzc2VydC5vayhmYWxzZSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/cast/date.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/cast/decimal128.js":
/*!***************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/cast/decimal128.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Decimal128Type = __webpack_require__(/*! ../types/decimal128 */ \"../backend/node_modules/mongoose/lib/types/decimal128.js\");\nconst assert = __webpack_require__(/*! assert */ \"assert\");\n\nmodule.exports = function castDecimal128(value) {\n  if (value == null) {\n    return value;\n  }\n\n  if (typeof value === 'object' && typeof value.$numberDecimal === 'string') {\n    return Decimal128Type.fromString(value.$numberDecimal);\n  }\n\n  if (value instanceof Decimal128Type) {\n    return value;\n  }\n\n  if (typeof value === 'string') {\n    return Decimal128Type.fromString(value);\n  }\n\n  if (typeof Buffer === 'function' && Buffer.isBuffer(value)) {\n    return new Decimal128Type(value);\n  }\n  if (typeof Uint8Array === 'function' && value instanceof Uint8Array) {\n    return new Decimal128Type(value);\n  }\n\n  if (typeof value === 'number') {\n    return Decimal128Type.fromString(String(value));\n  }\n\n  if (typeof value.valueOf === 'function' && typeof value.valueOf() === 'string') {\n    return Decimal128Type.fromString(value.valueOf());\n  }\n\n  assert.ok(false);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Nhc3QvZGVjaW1hbDEyOC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYix1QkFBdUIsbUJBQU8sQ0FBQyxxRkFBcUI7QUFDcEQsZUFBZSxtQkFBTyxDQUFDLHNCQUFROztBQUUvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Nhc3QvZGVjaW1hbDEyOC5qcz82ZTkzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRGVjaW1hbDEyOFR5cGUgPSByZXF1aXJlKCcuLi90eXBlcy9kZWNpbWFsMTI4Jyk7XG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYXN0RGVjaW1hbDEyOCh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZS4kbnVtYmVyRGVjaW1hbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gRGVjaW1hbDEyOFR5cGUuZnJvbVN0cmluZyh2YWx1ZS4kbnVtYmVyRGVjaW1hbCk7XG4gIH1cblxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEZWNpbWFsMTI4VHlwZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIERlY2ltYWwxMjhUeXBlLmZyb21TdHJpbmcodmFsdWUpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgIHJldHVybiBuZXcgRGVjaW1hbDEyOFR5cGUodmFsdWUpO1xuICB9XG4gIGlmICh0eXBlb2YgVWludDhBcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gbmV3IERlY2ltYWwxMjhUeXBlKHZhbHVlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIERlY2ltYWwxMjhUeXBlLmZyb21TdHJpbmcoU3RyaW5nKHZhbHVlKSk7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlLnZhbHVlT2YgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLnZhbHVlT2YoKSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gRGVjaW1hbDEyOFR5cGUuZnJvbVN0cmluZyh2YWx1ZS52YWx1ZU9mKCkpO1xuICB9XG5cbiAgYXNzZXJ0Lm9rKGZhbHNlKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/cast/decimal128.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/cast/number.js":
/*!***********************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/cast/number.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! assert */ \"assert\");\n\n/**\n * Given a value, cast it to a number, or throw an `Error` if the value\n * cannot be casted. `null` and `undefined` are considered valid.\n *\n * @param {Any} value\n * @return {Number}\n * @throws {Error} if `value` is not one of the allowed values\n * @api private\n */\n\nmodule.exports = function castNumber(val) {\n  if (val == null) {\n    return val;\n  }\n  if (val === '') {\n    return null;\n  }\n\n  if (typeof val === 'string' || typeof val === 'boolean') {\n    val = Number(val);\n  }\n\n  assert.ok(!isNaN(val));\n  if (val instanceof Number) {\n    return val.valueOf();\n  }\n  if (typeof val === 'number') {\n    return val;\n  }\n  if (!Array.isArray(val) && typeof val.valueOf === 'function') {\n    return Number(val.valueOf());\n  }\n  if (val.toString && !Array.isArray(val) && val.toString() == Number(val)) {\n    return Number(val);\n  }\n\n  assert.ok(false);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Nhc3QvbnVtYmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsWUFBWTtBQUNaLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Nhc3QvbnVtYmVyLmpzP2UwNjgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcblxuLyoqXG4gKiBHaXZlbiBhIHZhbHVlLCBjYXN0IGl0IHRvIGEgbnVtYmVyLCBvciB0aHJvdyBhbiBgRXJyb3JgIGlmIHRoZSB2YWx1ZVxuICogY2Fubm90IGJlIGNhc3RlZC4gYG51bGxgIGFuZCBgdW5kZWZpbmVkYCBhcmUgY29uc2lkZXJlZCB2YWxpZC5cbiAqXG4gKiBAcGFyYW0ge0FueX0gdmFsdWVcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBgdmFsdWVgIGlzIG5vdCBvbmUgb2YgdGhlIGFsbG93ZWQgdmFsdWVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhc3ROdW1iZXIodmFsKSB7XG4gIGlmICh2YWwgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgaWYgKHZhbCA9PT0gJycpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcbiAgICB2YWwgPSBOdW1iZXIodmFsKTtcbiAgfVxuXG4gIGFzc2VydC5vayghaXNOYU4odmFsKSk7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICByZXR1cm4gdmFsLnZhbHVlT2YoKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWwpICYmIHR5cGVvZiB2YWwudmFsdWVPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBOdW1iZXIodmFsLnZhbHVlT2YoKSk7XG4gIH1cbiAgaWYgKHZhbC50b1N0cmluZyAmJiAhQXJyYXkuaXNBcnJheSh2YWwpICYmIHZhbC50b1N0cmluZygpID09IE51bWJlcih2YWwpKSB7XG4gICAgcmV0dXJuIE51bWJlcih2YWwpO1xuICB9XG5cbiAgYXNzZXJ0Lm9rKGZhbHNlKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/cast/number.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/cast/objectid.js":
/*!*************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/cast/objectid.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst isBsonType = __webpack_require__(/*! ../helpers/isBsonType */ \"../backend/node_modules/mongoose/lib/helpers/isBsonType.js\");\nconst ObjectId = __webpack_require__(/*! ../types/objectid */ \"../backend/node_modules/mongoose/lib/types/objectid.js\");\n\nmodule.exports = function castObjectId(value) {\n  if (value == null) {\n    return value;\n  }\n\n  if (isBsonType(value, 'ObjectId')) {\n    return value;\n  }\n\n  if (value._id) {\n    if (isBsonType(value._id, 'ObjectId')) {\n      return value._id;\n    }\n    if (value._id.toString instanceof Function) {\n      return new ObjectId(value._id.toString());\n    }\n  }\n\n  if (value.toString instanceof Function) {\n    return new ObjectId(value.toString());\n  }\n\n  return new ObjectId(value);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Nhc3Qvb2JqZWN0aWQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsbUJBQW1CLG1CQUFPLENBQUMseUZBQXVCO0FBQ2xELGlCQUFpQixtQkFBTyxDQUFDLGlGQUFtQjs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY2FzdC9vYmplY3RpZC5qcz82YTJiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaXNCc29uVHlwZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvaXNCc29uVHlwZScpO1xuY29uc3QgT2JqZWN0SWQgPSByZXF1aXJlKCcuLi90eXBlcy9vYmplY3RpZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhc3RPYmplY3RJZCh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmIChpc0Jzb25UeXBlKHZhbHVlLCAnT2JqZWN0SWQnKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmICh2YWx1ZS5faWQpIHtcbiAgICBpZiAoaXNCc29uVHlwZSh2YWx1ZS5faWQsICdPYmplY3RJZCcpKSB7XG4gICAgICByZXR1cm4gdmFsdWUuX2lkO1xuICAgIH1cbiAgICBpZiAodmFsdWUuX2lkLnRvU3RyaW5nIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIHJldHVybiBuZXcgT2JqZWN0SWQodmFsdWUuX2lkLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh2YWx1ZS50b1N0cmluZyBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBPYmplY3RJZCh2YWx1ZS50b1N0cmluZygpKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgT2JqZWN0SWQodmFsdWUpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/cast/objectid.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/cast/string.js":
/*!***********************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/cast/string.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst CastError = __webpack_require__(/*! ../error/cast */ \"../backend/node_modules/mongoose/lib/error/cast.js\");\n\n/**\n * Given a value, cast it to a string, or throw a `CastError` if the value\n * cannot be casted. `null` and `undefined` are considered valid.\n *\n * @param {Any} value\n * @param {String} [path] optional the path to set on the CastError\n * @return {string|null|undefined}\n * @throws {CastError}\n * @api private\n */\n\nmodule.exports = function castString(value, path) {\n  // If null or undefined\n  if (value == null) {\n    return value;\n  }\n\n  // handle documents being passed\n  if (value._id && typeof value._id === 'string') {\n    return value._id;\n  }\n\n  // Re: gh-647 and gh-3030, we're ok with casting using `toString()`\n  // **unless** its the default Object.toString, because \"[object Object]\"\n  // doesn't really qualify as useful data\n  if (value.toString &&\n      value.toString !== Object.prototype.toString &&\n      !Array.isArray(value)) {\n    return value.toString();\n  }\n\n  throw new CastError('string', value, path);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Nhc3Qvc3RyaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGtCQUFrQixtQkFBTyxDQUFDLHlFQUFlOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Nhc3Qvc3RyaW5nLmpzPzRjYmUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBDYXN0RXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci9jYXN0Jyk7XG5cbi8qKlxuICogR2l2ZW4gYSB2YWx1ZSwgY2FzdCBpdCB0byBhIHN0cmluZywgb3IgdGhyb3cgYSBgQ2FzdEVycm9yYCBpZiB0aGUgdmFsdWVcbiAqIGNhbm5vdCBiZSBjYXN0ZWQuIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgYXJlIGNvbnNpZGVyZWQgdmFsaWQuXG4gKlxuICogQHBhcmFtIHtBbnl9IHZhbHVlXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdIG9wdGlvbmFsIHRoZSBwYXRoIHRvIHNldCBvbiB0aGUgQ2FzdEVycm9yXG4gKiBAcmV0dXJuIHtzdHJpbmd8bnVsbHx1bmRlZmluZWR9XG4gKiBAdGhyb3dzIHtDYXN0RXJyb3J9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhc3RTdHJpbmcodmFsdWUsIHBhdGgpIHtcbiAgLy8gSWYgbnVsbCBvciB1bmRlZmluZWRcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvLyBoYW5kbGUgZG9jdW1lbnRzIGJlaW5nIHBhc3NlZFxuICBpZiAodmFsdWUuX2lkICYmIHR5cGVvZiB2YWx1ZS5faWQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlLl9pZDtcbiAgfVxuXG4gIC8vIFJlOiBnaC02NDcgYW5kIGdoLTMwMzAsIHdlJ3JlIG9rIHdpdGggY2FzdGluZyB1c2luZyBgdG9TdHJpbmcoKWBcbiAgLy8gKip1bmxlc3MqKiBpdHMgdGhlIGRlZmF1bHQgT2JqZWN0LnRvU3RyaW5nLCBiZWNhdXNlIFwiW29iamVjdCBPYmplY3RdXCJcbiAgLy8gZG9lc24ndCByZWFsbHkgcXVhbGlmeSBhcyB1c2VmdWwgZGF0YVxuICBpZiAodmFsdWUudG9TdHJpbmcgJiZcbiAgICAgIHZhbHVlLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nICYmXG4gICAgICAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuXG4gIHRocm93IG5ldyBDYXN0RXJyb3IoJ3N0cmluZycsIHZhbHVlLCBwYXRoKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/cast/string.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/collection.js":
/*!**********************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/collection.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst STATES = __webpack_require__(/*! ./connectionState */ \"../backend/node_modules/mongoose/lib/connectionState.js\");\nconst immediate = __webpack_require__(/*! ./helpers/immediate */ \"../backend/node_modules/mongoose/lib/helpers/immediate.js\");\n\n/**\n * Abstract Collection constructor\n *\n * This is the base class that drivers inherit from and implement.\n *\n * @param {String} name name of the collection\n * @param {Connection} conn A MongooseConnection instance\n * @param {Object} [opts] optional collection options\n * @api public\n */\n\nfunction Collection(name, conn, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  this.opts = opts;\n  this.name = name;\n  this.collectionName = name;\n  this.conn = conn;\n  this.queue = [];\n  this.buffer = true;\n  this.emitter = new EventEmitter();\n\n  if (STATES.connected === this.conn.readyState) {\n    this.onOpen();\n  }\n}\n\n/**\n * The collection name\n *\n * @api public\n * @property name\n */\n\nCollection.prototype.name;\n\n/**\n * The collection name\n *\n * @api public\n * @property collectionName\n */\n\nCollection.prototype.collectionName;\n\n/**\n * The Connection instance\n *\n * @api public\n * @property conn\n */\n\nCollection.prototype.conn;\n\n/**\n * Called when the database connects\n *\n * @api private\n */\n\nCollection.prototype.onOpen = function() {\n  this.buffer = false;\n  immediate(() => this.doQueue());\n};\n\n/**\n * Called when the database disconnects\n *\n * @api private\n */\n\nCollection.prototype.onClose = function() {};\n\n/**\n * Queues a method for later execution when its\n * database connection opens.\n *\n * @param {String} name name of the method to queue\n * @param {Array} args arguments to pass to the method when executed\n * @api private\n */\n\nCollection.prototype.addQueue = function(name, args) {\n  this.queue.push([name, args]);\n  return this;\n};\n\n/**\n * Removes a queued method\n *\n * @param {String} name name of the method to queue\n * @param {Array} args arguments to pass to the method when executed\n * @api private\n */\n\nCollection.prototype.removeQueue = function(name, args) {\n  const index = this.queue.findIndex(v => v[0] === name && v[1] === args);\n  if (index === -1) {\n    return false;\n  }\n  this.queue.splice(index, 1);\n  return true;\n};\n\n/**\n * Executes all queued methods and clears the queue.\n *\n * @api private\n */\n\nCollection.prototype.doQueue = function() {\n  for (const method of this.queue) {\n    if (typeof method[0] === 'function') {\n      method[0].apply(this, method[1]);\n    } else {\n      this[method[0]].apply(this, method[1]);\n    }\n  }\n  this.queue = [];\n  const _this = this;\n  immediate(function() {\n    _this.emitter.emit('queue');\n  });\n  return this;\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.ensureIndex = function() {\n  throw new Error('Collection#ensureIndex unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.createIndex = function() {\n  throw new Error('Collection#createIndex unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.findAndModify = function() {\n  throw new Error('Collection#findAndModify unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.findOneAndUpdate = function() {\n  throw new Error('Collection#findOneAndUpdate unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.findOneAndDelete = function() {\n  throw new Error('Collection#findOneAndDelete unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.findOneAndReplace = function() {\n  throw new Error('Collection#findOneAndReplace unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.findOne = function() {\n  throw new Error('Collection#findOne unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.find = function() {\n  throw new Error('Collection#find unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.insert = function() {\n  throw new Error('Collection#insert unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.insertOne = function() {\n  throw new Error('Collection#insertOne unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.insertMany = function() {\n  throw new Error('Collection#insertMany unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.save = function() {\n  throw new Error('Collection#save unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.updateOne = function() {\n  throw new Error('Collection#updateOne unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.updateMany = function() {\n  throw new Error('Collection#updateMany unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.deleteOne = function() {\n  throw new Error('Collection#deleteOne unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.deleteMany = function() {\n  throw new Error('Collection#deleteMany unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.getIndexes = function() {\n  throw new Error('Collection#getIndexes unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.watch = function() {\n  throw new Error('Collection#watch unimplemented by driver');\n};\n\n/*!\n * ignore\n */\n\nCollection.prototype._shouldBufferCommands = function _shouldBufferCommands() {\n  const opts = this.opts;\n\n  if (opts.bufferCommands != null) {\n    return opts.bufferCommands;\n  }\n  if (opts && opts.schemaUserProvidedOptions != null && opts.schemaUserProvidedOptions.bufferCommands != null) {\n    return opts.schemaUserProvidedOptions.bufferCommands;\n  }\n\n  return this.conn._shouldBufferCommands();\n};\n\n/*!\n * ignore\n */\n\nCollection.prototype._getBufferTimeoutMS = function _getBufferTimeoutMS() {\n  const conn = this.conn;\n  const opts = this.opts;\n\n  if (opts.bufferTimeoutMS != null) {\n    return opts.bufferTimeoutMS;\n  }\n  if (opts && opts.schemaUserProvidedOptions != null && opts.schemaUserProvidedOptions.bufferTimeoutMS != null) {\n    return opts.schemaUserProvidedOptions.bufferTimeoutMS;\n  }\n  if (conn.config.bufferTimeoutMS != null) {\n    return conn.config.bufferTimeoutMS;\n  }\n  if (conn.base != null && conn.base.get('bufferTimeoutMS') != null) {\n    return conn.base.get('bufferTimeoutMS');\n  }\n  return 10000;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = Collection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2NvbGxlY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLHFCQUFxQiwwREFBOEI7QUFDbkQsZUFBZSxtQkFBTyxDQUFDLGtGQUFtQjtBQUMxQyxrQkFBa0IsbUJBQU8sQ0FBQyxzRkFBcUI7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9jb2xsZWN0aW9uLmpzPzRkMzciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuY29uc3QgU1RBVEVTID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uU3RhdGUnKTtcbmNvbnN0IGltbWVkaWF0ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9pbW1lZGlhdGUnKTtcblxuLyoqXG4gKiBBYnN0cmFjdCBDb2xsZWN0aW9uIGNvbnN0cnVjdG9yXG4gKlxuICogVGhpcyBpcyB0aGUgYmFzZSBjbGFzcyB0aGF0IGRyaXZlcnMgaW5oZXJpdCBmcm9tIGFuZCBpbXBsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgY29sbGVjdGlvblxuICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uIEEgTW9uZ29vc2VDb25uZWN0aW9uIGluc3RhbmNlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIG9wdGlvbmFsIGNvbGxlY3Rpb24gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBDb2xsZWN0aW9uKG5hbWUsIGNvbm4sIG9wdHMpIHtcbiAgaWYgKG9wdHMgPT09IHZvaWQgMCkge1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuXG4gIHRoaXMub3B0cyA9IG9wdHM7XG4gIHRoaXMubmFtZSA9IG5hbWU7XG4gIHRoaXMuY29sbGVjdGlvbk5hbWUgPSBuYW1lO1xuICB0aGlzLmNvbm4gPSBjb25uO1xuICB0aGlzLnF1ZXVlID0gW107XG4gIHRoaXMuYnVmZmVyID0gdHJ1ZTtcbiAgdGhpcy5lbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIGlmIChTVEFURVMuY29ubmVjdGVkID09PSB0aGlzLmNvbm4ucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMub25PcGVuKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgY29sbGVjdGlvbiBuYW1lXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBuYW1lXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUubmFtZTtcblxuLyoqXG4gKiBUaGUgY29sbGVjdGlvbiBuYW1lXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBjb2xsZWN0aW9uTmFtZVxuICovXG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLmNvbGxlY3Rpb25OYW1lO1xuXG4vKipcbiAqIFRoZSBDb25uZWN0aW9uIGluc3RhbmNlXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBjb25uXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUuY29ubjtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiB0aGUgZGF0YWJhc2UgY29ubmVjdHNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5vbk9wZW4gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5idWZmZXIgPSBmYWxzZTtcbiAgaW1tZWRpYXRlKCgpID0+IHRoaXMuZG9RdWV1ZSgpKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gdGhlIGRhdGFiYXNlIGRpc2Nvbm5lY3RzXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uKCkge307XG5cbi8qKlxuICogUXVldWVzIGEgbWV0aG9kIGZvciBsYXRlciBleGVjdXRpb24gd2hlbiBpdHNcbiAqIGRhdGFiYXNlIGNvbm5lY3Rpb24gb3BlbnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgbWV0aG9kIHRvIHF1ZXVlXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBtZXRob2Qgd2hlbiBleGVjdXRlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUuYWRkUXVldWUgPSBmdW5jdGlvbihuYW1lLCBhcmdzKSB7XG4gIHRoaXMucXVldWUucHVzaChbbmFtZSwgYXJnc10pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIHF1ZXVlZCBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBtZXRob2QgdG8gcXVldWVcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIG1ldGhvZCB3aGVuIGV4ZWN1dGVkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVRdWV1ZSA9IGZ1bmN0aW9uKG5hbWUsIGFyZ3MpIHtcbiAgY29uc3QgaW5kZXggPSB0aGlzLnF1ZXVlLmZpbmRJbmRleCh2ID0+IHZbMF0gPT09IG5hbWUgJiYgdlsxXSA9PT0gYXJncyk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdGhpcy5xdWV1ZS5zcGxpY2UoaW5kZXgsIDEpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgYWxsIHF1ZXVlZCBtZXRob2RzIGFuZCBjbGVhcnMgdGhlIHF1ZXVlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLmRvUXVldWUgPSBmdW5jdGlvbigpIHtcbiAgZm9yIChjb25zdCBtZXRob2Qgb2YgdGhpcy5xdWV1ZSkge1xuICAgIGlmICh0eXBlb2YgbWV0aG9kWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBtZXRob2RbMF0uYXBwbHkodGhpcywgbWV0aG9kWzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1ttZXRob2RbMF1dLmFwcGx5KHRoaXMsIG1ldGhvZFsxXSk7XG4gICAgfVxuICB9XG4gIHRoaXMucXVldWUgPSBbXTtcbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICBpbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgX3RoaXMuZW1pdHRlci5lbWl0KCdxdWV1ZScpO1xuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFic3RyYWN0IG1ldGhvZCB0aGF0IGRyaXZlcnMgbXVzdCBpbXBsZW1lbnQuXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUuZW5zdXJlSW5kZXggPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdDb2xsZWN0aW9uI2Vuc3VyZUluZGV4IHVuaW1wbGVtZW50ZWQgYnkgZHJpdmVyJyk7XG59O1xuXG4vKipcbiAqIEFic3RyYWN0IG1ldGhvZCB0aGF0IGRyaXZlcnMgbXVzdCBpbXBsZW1lbnQuXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUuY3JlYXRlSW5kZXggPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdDb2xsZWN0aW9uI2NyZWF0ZUluZGV4IHVuaW1wbGVtZW50ZWQgYnkgZHJpdmVyJyk7XG59O1xuXG4vKipcbiAqIEFic3RyYWN0IG1ldGhvZCB0aGF0IGRyaXZlcnMgbXVzdCBpbXBsZW1lbnQuXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUuZmluZEFuZE1vZGlmeSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jZmluZEFuZE1vZGlmeSB1bmltcGxlbWVudGVkIGJ5IGRyaXZlcicpO1xufTtcblxuLyoqXG4gKiBBYnN0cmFjdCBtZXRob2QgdGhhdCBkcml2ZXJzIG11c3QgaW1wbGVtZW50LlxuICovXG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLmZpbmRPbmVBbmRVcGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdDb2xsZWN0aW9uI2ZpbmRPbmVBbmRVcGRhdGUgdW5pbXBsZW1lbnRlZCBieSBkcml2ZXInKTtcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgbWV0aG9kIHRoYXQgZHJpdmVycyBtdXN0IGltcGxlbWVudC5cbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5maW5kT25lQW5kRGVsZXRlID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBFcnJvcignQ29sbGVjdGlvbiNmaW5kT25lQW5kRGVsZXRlIHVuaW1wbGVtZW50ZWQgYnkgZHJpdmVyJyk7XG59O1xuXG4vKipcbiAqIEFic3RyYWN0IG1ldGhvZCB0aGF0IGRyaXZlcnMgbXVzdCBpbXBsZW1lbnQuXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUuZmluZE9uZUFuZFJlcGxhY2UgPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdDb2xsZWN0aW9uI2ZpbmRPbmVBbmRSZXBsYWNlIHVuaW1wbGVtZW50ZWQgYnkgZHJpdmVyJyk7XG59O1xuXG4vKipcbiAqIEFic3RyYWN0IG1ldGhvZCB0aGF0IGRyaXZlcnMgbXVzdCBpbXBsZW1lbnQuXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUuZmluZE9uZSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jZmluZE9uZSB1bmltcGxlbWVudGVkIGJ5IGRyaXZlcicpO1xufTtcblxuLyoqXG4gKiBBYnN0cmFjdCBtZXRob2QgdGhhdCBkcml2ZXJzIG11c3QgaW1wbGVtZW50LlxuICovXG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdDb2xsZWN0aW9uI2ZpbmQgdW5pbXBsZW1lbnRlZCBieSBkcml2ZXInKTtcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgbWV0aG9kIHRoYXQgZHJpdmVycyBtdXN0IGltcGxlbWVudC5cbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdDb2xsZWN0aW9uI2luc2VydCB1bmltcGxlbWVudGVkIGJ5IGRyaXZlcicpO1xufTtcblxuLyoqXG4gKiBBYnN0cmFjdCBtZXRob2QgdGhhdCBkcml2ZXJzIG11c3QgaW1wbGVtZW50LlxuICovXG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLmluc2VydE9uZSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jaW5zZXJ0T25lIHVuaW1wbGVtZW50ZWQgYnkgZHJpdmVyJyk7XG59O1xuXG4vKipcbiAqIEFic3RyYWN0IG1ldGhvZCB0aGF0IGRyaXZlcnMgbXVzdCBpbXBsZW1lbnQuXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUuaW5zZXJ0TWFueSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvbGxlY3Rpb24jaW5zZXJ0TWFueSB1bmltcGxlbWVudGVkIGJ5IGRyaXZlcicpO1xufTtcblxuLyoqXG4gKiBBYnN0cmFjdCBtZXRob2QgdGhhdCBkcml2ZXJzIG11c3QgaW1wbGVtZW50LlxuICovXG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdDb2xsZWN0aW9uI3NhdmUgdW5pbXBsZW1lbnRlZCBieSBkcml2ZXInKTtcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgbWV0aG9kIHRoYXQgZHJpdmVycyBtdXN0IGltcGxlbWVudC5cbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS51cGRhdGVPbmUgPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdDb2xsZWN0aW9uI3VwZGF0ZU9uZSB1bmltcGxlbWVudGVkIGJ5IGRyaXZlcicpO1xufTtcblxuLyoqXG4gKiBBYnN0cmFjdCBtZXRob2QgdGhhdCBkcml2ZXJzIG11c3QgaW1wbGVtZW50LlxuICovXG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLnVwZGF0ZU1hbnkgPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdDb2xsZWN0aW9uI3VwZGF0ZU1hbnkgdW5pbXBsZW1lbnRlZCBieSBkcml2ZXInKTtcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgbWV0aG9kIHRoYXQgZHJpdmVycyBtdXN0IGltcGxlbWVudC5cbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5kZWxldGVPbmUgPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdDb2xsZWN0aW9uI2RlbGV0ZU9uZSB1bmltcGxlbWVudGVkIGJ5IGRyaXZlcicpO1xufTtcblxuLyoqXG4gKiBBYnN0cmFjdCBtZXRob2QgdGhhdCBkcml2ZXJzIG11c3QgaW1wbGVtZW50LlxuICovXG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLmRlbGV0ZU1hbnkgPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdDb2xsZWN0aW9uI2RlbGV0ZU1hbnkgdW5pbXBsZW1lbnRlZCBieSBkcml2ZXInKTtcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgbWV0aG9kIHRoYXQgZHJpdmVycyBtdXN0IGltcGxlbWVudC5cbiAqL1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5nZXRJbmRleGVzID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IG5ldyBFcnJvcignQ29sbGVjdGlvbiNnZXRJbmRleGVzIHVuaW1wbGVtZW50ZWQgYnkgZHJpdmVyJyk7XG59O1xuXG4vKipcbiAqIEFic3RyYWN0IG1ldGhvZCB0aGF0IGRyaXZlcnMgbXVzdCBpbXBsZW1lbnQuXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUud2F0Y2ggPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdDb2xsZWN0aW9uI3dhdGNoIHVuaW1wbGVtZW50ZWQgYnkgZHJpdmVyJyk7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLl9zaG91bGRCdWZmZXJDb21tYW5kcyA9IGZ1bmN0aW9uIF9zaG91bGRCdWZmZXJDb21tYW5kcygpIHtcbiAgY29uc3Qgb3B0cyA9IHRoaXMub3B0cztcblxuICBpZiAob3B0cy5idWZmZXJDb21tYW5kcyAhPSBudWxsKSB7XG4gICAgcmV0dXJuIG9wdHMuYnVmZmVyQ29tbWFuZHM7XG4gIH1cbiAgaWYgKG9wdHMgJiYgb3B0cy5zY2hlbWFVc2VyUHJvdmlkZWRPcHRpb25zICE9IG51bGwgJiYgb3B0cy5zY2hlbWFVc2VyUHJvdmlkZWRPcHRpb25zLmJ1ZmZlckNvbW1hbmRzICE9IG51bGwpIHtcbiAgICByZXR1cm4gb3B0cy5zY2hlbWFVc2VyUHJvdmlkZWRPcHRpb25zLmJ1ZmZlckNvbW1hbmRzO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuY29ubi5fc2hvdWxkQnVmZmVyQ29tbWFuZHMoKTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUuX2dldEJ1ZmZlclRpbWVvdXRNUyA9IGZ1bmN0aW9uIF9nZXRCdWZmZXJUaW1lb3V0TVMoKSB7XG4gIGNvbnN0IGNvbm4gPSB0aGlzLmNvbm47XG4gIGNvbnN0IG9wdHMgPSB0aGlzLm9wdHM7XG5cbiAgaWYgKG9wdHMuYnVmZmVyVGltZW91dE1TICE9IG51bGwpIHtcbiAgICByZXR1cm4gb3B0cy5idWZmZXJUaW1lb3V0TVM7XG4gIH1cbiAgaWYgKG9wdHMgJiYgb3B0cy5zY2hlbWFVc2VyUHJvdmlkZWRPcHRpb25zICE9IG51bGwgJiYgb3B0cy5zY2hlbWFVc2VyUHJvdmlkZWRPcHRpb25zLmJ1ZmZlclRpbWVvdXRNUyAhPSBudWxsKSB7XG4gICAgcmV0dXJuIG9wdHMuc2NoZW1hVXNlclByb3ZpZGVkT3B0aW9ucy5idWZmZXJUaW1lb3V0TVM7XG4gIH1cbiAgaWYgKGNvbm4uY29uZmlnLmJ1ZmZlclRpbWVvdXRNUyAhPSBudWxsKSB7XG4gICAgcmV0dXJuIGNvbm4uY29uZmlnLmJ1ZmZlclRpbWVvdXRNUztcbiAgfVxuICBpZiAoY29ubi5iYXNlICE9IG51bGwgJiYgY29ubi5iYXNlLmdldCgnYnVmZmVyVGltZW91dE1TJykgIT0gbnVsbCkge1xuICAgIHJldHVybiBjb25uLmJhc2UuZ2V0KCdidWZmZXJUaW1lb3V0TVMnKTtcbiAgfVxuICByZXR1cm4gMTAwMDA7XG59O1xuXG4vKiFcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gQ29sbGVjdGlvbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/collection.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/connection.js":
/*!**********************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/connection.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst ChangeStream = __webpack_require__(/*! ./cursor/changeStream */ \"../backend/node_modules/mongoose/lib/cursor/changeStream.js\");\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Schema = __webpack_require__(/*! ./schema */ \"../backend/node_modules/mongoose/lib/schema.js\");\nconst STATES = __webpack_require__(/*! ./connectionState */ \"../backend/node_modules/mongoose/lib/connectionState.js\");\nconst MongooseError = __webpack_require__(/*! ./error/index */ \"../backend/node_modules/mongoose/lib/error/index.js\");\nconst ServerSelectionError = __webpack_require__(/*! ./error/serverSelection */ \"../backend/node_modules/mongoose/lib/error/serverSelection.js\");\nconst SyncIndexesError = __webpack_require__(/*! ./error/syncIndexes */ \"../backend/node_modules/mongoose/lib/error/syncIndexes.js\");\nconst applyPlugins = __webpack_require__(/*! ./helpers/schema/applyPlugins */ \"../backend/node_modules/mongoose/lib/helpers/schema/applyPlugins.js\");\nconst clone = __webpack_require__(/*! ./helpers/clone */ \"../backend/node_modules/mongoose/lib/helpers/clone.js\");\nconst driver = __webpack_require__(/*! ./driver */ \"../backend/node_modules/mongoose/lib/driver.js\");\nconst get = __webpack_require__(/*! ./helpers/get */ \"../backend/node_modules/mongoose/lib/helpers/get.js\");\nconst immediate = __webpack_require__(/*! ./helpers/immediate */ \"../backend/node_modules/mongoose/lib/helpers/immediate.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\nconst CreateCollectionsError = __webpack_require__(/*! ./error/createCollectionsError */ \"../backend/node_modules/mongoose/lib/error/createCollectionsError.js\");\n\nconst arrayAtomicsSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsSymbol);\nconst sessionNewDocuments = (__webpack_require__(/*! ./helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").sessionNewDocuments);\n\n/**\n * A list of authentication mechanisms that don't require a password for authentication.\n * This is used by the authMechanismDoesNotRequirePassword method.\n *\n * @api private\n */\nconst noPasswordAuthMechanisms = [\n  'MONGODB-X509'\n];\n\n/**\n * Connection constructor\n *\n * For practical reasons, a Connection equals a Db.\n *\n * @param {Mongoose} base a mongoose instance\n * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#class-eventemitter\n * @event `connecting`: Emitted when `connection.openUri()` is executed on this connection.\n * @event `connected`: Emitted when this connection successfully connects to the db. May be emitted _multiple_ times in `reconnected` scenarios.\n * @event `open`: Emitted after we `connected` and `onOpen` is executed on all of this connection's models.\n * @event `disconnecting`: Emitted when `connection.close()` was executed.\n * @event `disconnected`: Emitted after getting disconnected from the db.\n * @event `close`: Emitted after we `disconnected` and `onClose` executed on all of this connection's models.\n * @event `reconnected`: Emitted after we `connected` and subsequently `disconnected`, followed by successfully another successful connection.\n * @event `error`: Emitted when an error occurs on this connection.\n * @event `fullsetup`: Emitted after the driver has connected to primary and all secondaries if specified in the connection string.\n * @api public\n */\n\nfunction Connection(base) {\n  this.base = base;\n  this.collections = {};\n  this.models = {};\n  this.config = {};\n  this.replica = false;\n  this.options = null;\n  this.otherDbs = []; // FIXME: To be replaced with relatedDbs\n  this.relatedDbs = {}; // Hashmap of other dbs that share underlying connection\n  this.states = STATES;\n  this._readyState = STATES.disconnected;\n  this._closeCalled = false;\n  this._hasOpened = false;\n  this.plugins = [];\n  if (typeof base === 'undefined' || !base.connections.length) {\n    this.id = 0;\n  } else {\n    this.id = base.nextConnectionId;\n  }\n  this._queue = [];\n}\n\n/*!\n * Inherit from EventEmitter\n */\n\nObject.setPrototypeOf(Connection.prototype, EventEmitter.prototype);\n\n/**\n * Connection ready state\n *\n * - 0 = disconnected\n * - 1 = connected\n * - 2 = connecting\n * - 3 = disconnecting\n *\n * Each state change emits its associated event name.\n *\n * #### Example:\n *\n *     conn.on('connected', callback);\n *     conn.on('disconnected', callback);\n *\n * @property readyState\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'readyState', {\n  get: function() {\n    return this._readyState;\n  },\n  set: function(val) {\n    if (!(val in STATES)) {\n      throw new Error('Invalid connection state: ' + val);\n    }\n\n    if (this._readyState !== val) {\n      this._readyState = val;\n      // [legacy] loop over the otherDbs on this connection and change their state\n      for (const db of this.otherDbs) {\n        db.readyState = val;\n      }\n\n      if (STATES.connected === val) {\n        this._hasOpened = true;\n      }\n\n      this.emit(STATES[val]);\n    }\n  }\n});\n\n/**\n * Gets the value of the option `key`. Equivalent to `conn.options[key]`\n *\n * #### Example:\n *\n *     conn.get('test'); // returns the 'test' value\n *\n * @param {String} key\n * @method get\n * @api public\n */\n\nConnection.prototype.get = function(key) {\n  if (this.config.hasOwnProperty(key)) {\n    return this.config[key];\n  }\n\n  return get(this.options, key);\n};\n\n/**\n * Sets the value of the option `key`. Equivalent to `conn.options[key] = val`\n *\n * Supported options include:\n *\n * - `maxTimeMS`: Set [`maxTimeMS`](https://mongoosejs.com/docs/api/query.html#Query.prototype.maxTimeMS()) for all queries on this connection.\n * - 'debug': If `true`, prints the operations mongoose sends to MongoDB to the console. If a writable stream is passed, it will log to that stream, without colorization. If a callback function is passed, it will receive the collection name, the method name, then all arugments passed to the method. For example, if you wanted to replicate the default logging, you could output from the callback `Mongoose: ${collectionName}.${methodName}(${methodArgs.join(', ')})`.\n *\n * #### Example:\n *\n *     conn.set('test', 'foo');\n *     conn.get('test'); // 'foo'\n *     conn.options.test; // 'foo'\n *\n * @param {String} key\n * @param {Any} val\n * @method set\n * @api public\n */\n\nConnection.prototype.set = function(key, val) {\n  if (this.config.hasOwnProperty(key)) {\n    this.config[key] = val;\n    return val;\n  }\n\n  this.options = this.options || {};\n  this.options[key] = val;\n  return val;\n};\n\n/**\n * A hash of the collections associated with this connection\n *\n * @property collections\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.collections;\n\n/**\n * The name of the database this connection points to.\n *\n * #### Example:\n *\n *     mongoose.createConnection('mongodb://127.0.0.1:27017/mydb').name; // \"mydb\"\n *\n * @property name\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.name;\n\n/**\n * A [POJO](https://masteringjs.io/tutorials/fundamentals/pojo) containing\n * a map from model names to models. Contains all models that have been\n * added to this connection using [`Connection#model()`](https://mongoosejs.com/docs/api/connection.html#Connection.prototype.model()).\n *\n * #### Example:\n *\n *     const conn = mongoose.createConnection();\n *     const Test = conn.model('Test', mongoose.Schema({ name: String }));\n *\n *     Object.keys(conn.models).length; // 1\n *     conn.models.Test === Test; // true\n *\n * @property models\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.models;\n\n/**\n * A number identifier for this connection. Used for debugging when\n * you have [multiple connections](https://mongoosejs.com/docs/connections.html#multiple_connections).\n *\n * #### Example:\n *\n *     // The default connection has `id = 0`\n *     mongoose.connection.id; // 0\n *\n *     // If you create a new connection, Mongoose increments id\n *     const conn = mongoose.createConnection();\n *     conn.id; // 1\n *\n * @property id\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.id;\n\n/**\n * The plugins that will be applied to all models created on this connection.\n *\n * #### Example:\n *\n *     const db = mongoose.createConnection('mongodb://127.0.0.1:27017/mydb');\n *     db.plugin(() => console.log('Applied'));\n *     db.plugins.length; // 1\n *\n *     db.model('Test', new Schema({})); // Prints \"Applied\"\n *\n * @property plugins\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'plugins', {\n  configurable: false,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The host name portion of the URI. If multiple hosts, such as a replica set,\n * this will contain the first host name in the URI\n *\n * #### Example:\n *\n *     mongoose.createConnection('mongodb://127.0.0.1:27017/mydb').host; // \"127.0.0.1\"\n *\n * @property host\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'host', {\n  configurable: true,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The port portion of the URI. If multiple hosts, such as a replica set,\n * this will contain the port from the first host name in the URI.\n *\n * #### Example:\n *\n *     mongoose.createConnection('mongodb://127.0.0.1:27017/mydb').port; // 27017\n *\n * @property port\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'port', {\n  configurable: true,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The username specified in the URI\n *\n * #### Example:\n *\n *     mongoose.createConnection('mongodb://val:psw@127.0.0.1:27017/mydb').user; // \"val\"\n *\n * @property user\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'user', {\n  configurable: true,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The password specified in the URI\n *\n * #### Example:\n *\n *     mongoose.createConnection('mongodb://val:psw@127.0.0.1:27017/mydb').pass; // \"psw\"\n *\n * @property pass\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'pass', {\n  configurable: true,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The mongodb.Db instance, set when the connection is opened\n *\n * @property db\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.db;\n\n/**\n * The MongoClient instance this connection uses to talk to MongoDB. Mongoose automatically sets this property\n * when the connection is opened.\n *\n * @property client\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.client;\n\n/**\n * A hash of the global options that are associated with this connection\n *\n * @property config\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.config;\n\n/**\n * Helper for `createCollection()`. Will explicitly create the given collection\n * with specified options. Used to create [capped collections](https://www.mongodb.com/docs/manual/core/capped-collections/)\n * and [views](https://www.mongodb.com/docs/manual/core/views/) from mongoose.\n *\n * Options are passed down without modification to the [MongoDB driver's `createCollection()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createCollection)\n *\n * @method createCollection\n * @param {string} collection The collection to create\n * @param {Object} [options] see [MongoDB driver docs](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createCollection)\n * @return {Promise}\n * @api public\n */\n\nConnection.prototype.createCollection = async function createCollection(collection, options) {\n  if (typeof options === 'function' || (arguments.length >= 3 && typeof arguments[2] === 'function')) {\n    throw new MongooseError('Connection.prototype.createCollection() no longer accepts a callback');\n  }\n\n  if ((this.readyState === STATES.connecting || this.readyState === STATES.disconnected) && this._shouldBufferCommands()) {\n    await new Promise(resolve => {\n      this._queue.push({ fn: resolve });\n    });\n  }\n\n  return this.db.createCollection(collection, options);\n};\n\n/**\n * Calls `createCollection()` on a models in a series.\n *\n * @method createCollections\n * @param {Boolean} continueOnError When true, will continue to create collections and create a new error class for the collections that errored.\n * @returns {Promise}\n * @api public\n */\n\nConnection.prototype.createCollections = async function createCollections(options = {}) {\n  const result = {};\n  const errorsMap = { };\n\n  const { continueOnError } = options;\n  delete options.continueOnError;\n  for (const model of Object.values(this.models)) {\n    try {\n      result[model.modelName] = await model.createCollection({});\n    } catch (err) {\n      if (!continueOnError) {\n        errorsMap[model.modelName] = err;\n        break;\n      } else {\n        result[model.modelName] = err;\n      }\n    }\n  }\n\n  if (!continueOnError && Object.keys(errorsMap).length) {\n    const message = Object.entries(errorsMap).map(([modelName, err]) => `${modelName}: ${err.message}`).join(', ');\n    const createCollectionsError = new CreateCollectionsError(message, errorsMap);\n    throw createCollectionsError;\n  }\n  return result;\n};\n\n/**\n * A convenience wrapper for `connection.client.withSession()`.\n *\n * #### Example:\n *\n *     await conn.withSession(async session => {\n *       const doc = await TestModel.findOne().session(session);\n *     });\n *\n * @method withSession\n * @param {Function} executor called with 1 argument: a `ClientSession` instance\n * @return {Promise} resolves to the return value of the executor function\n * @api public\n */\n\nConnection.prototype.withSession = async function withSession(executor) {\n  if (arguments.length === 0) {\n    throw new Error('Please provide an executor function');\n  }\n  return await this.client.withSession(executor);\n};\n\n/**\n * _Requires MongoDB >= 3.6.0._ Starts a [MongoDB session](https://www.mongodb.com/docs/manual/release-notes/3.6/#client-sessions)\n * for benefits like causal consistency, [retryable writes](https://www.mongodb.com/docs/manual/core/retryable-writes/),\n * and [transactions](https://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html).\n *\n * #### Example:\n *\n *     const session = await conn.startSession();\n *     let doc = await Person.findOne({ name: 'Ned Stark' }, null, { session });\n *     await doc.remove();\n *     // `doc` will always be null, even if reading from a replica set\n *     // secondary. Without causal consistency, it is possible to\n *     // get a doc back from the below query if the query reads from a\n *     // secondary that is experiencing replication lag.\n *     doc = await Person.findOne({ name: 'Ned Stark' }, null, { session, readPreference: 'secondary' });\n *\n *\n * @method startSession\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#startSession)\n * @param {Boolean} [options.causalConsistency=true] set to false to disable causal consistency\n * @return {Promise<ClientSession>} promise that resolves to a MongoDB driver `ClientSession`\n * @api public\n */\n\nConnection.prototype.startSession = async function startSession(options) {\n  if (arguments.length >= 2 && typeof arguments[1] === 'function') {\n    throw new MongooseError('Connection.prototype.startSession() no longer accepts a callback');\n  }\n\n  if ((this.readyState === STATES.connecting || this.readyState === STATES.disconnected) && this._shouldBufferCommands()) {\n    await new Promise(resolve => {\n      this._queue.push({ fn: resolve });\n    });\n  }\n\n  const session = this.client.startSession(options);\n  return session;\n};\n\n/**\n * _Requires MongoDB >= 3.6.0._ Executes the wrapped async function\n * in a transaction. Mongoose will commit the transaction if the\n * async function executes successfully and attempt to retry if\n * there was a retriable error.\n *\n * Calls the MongoDB driver's [`session.withTransaction()`](https://mongodb.github.io/node-mongodb-native/4.9/classes/ClientSession.html#withTransaction),\n * but also handles resetting Mongoose document state as shown below.\n *\n * #### Example:\n *\n *     const doc = new Person({ name: 'Will Riker' });\n *     await db.transaction(async function setRank(session) {\n *       doc.rank = 'Captain';\n *       await doc.save({ session });\n *       doc.isNew; // false\n *\n *       // Throw an error to abort the transaction\n *       throw new Error('Oops!');\n *     },{ readPreference: 'primary' }).catch(() => {});\n *\n *     // true, `transaction()` reset the document's state because the\n *     // transaction was aborted.\n *     doc.isNew;\n *\n * @method transaction\n * @param {Function} fn Function to execute in a transaction\n * @param {mongodb.TransactionOptions} [options] Optional settings for the transaction\n * @return {Promise<Any>} promise that is fulfilled if Mongoose successfully committed the transaction, or rejects if the transaction was aborted or if Mongoose failed to commit the transaction. If fulfilled, the promise resolves to a MongoDB command result.\n * @api public\n */\n\nConnection.prototype.transaction = function transaction(fn, options) {\n  return this.startSession().then(session => {\n    session[sessionNewDocuments] = new Map();\n    return session.withTransaction(() => _wrapUserTransaction(fn, session), options).\n      then(res => {\n        delete session[sessionNewDocuments];\n        return res;\n      }).\n      catch(err => {\n        delete session[sessionNewDocuments];\n        throw err;\n      }).\n      finally(() => {\n        session.endSession().catch(() => {});\n      });\n  });\n};\n\n/*!\n * Reset document state in between transaction retries re: gh-13698\n */\n\nasync function _wrapUserTransaction(fn, session) {\n  try {\n    const res = await fn(session);\n    return res;\n  } catch (err) {\n    _resetSessionDocuments(session);\n    throw err;\n  }\n}\n\n/*!\n * If transaction was aborted, we need to reset newly inserted documents' `isNew`.\n */\nfunction _resetSessionDocuments(session) {\n  for (const doc of session[sessionNewDocuments].keys()) {\n    const state = session[sessionNewDocuments].get(doc);\n    if (state.hasOwnProperty('isNew')) {\n      doc.$isNew = state.isNew;\n    }\n    if (state.hasOwnProperty('versionKey')) {\n      doc.set(doc.schema.options.versionKey, state.versionKey);\n    }\n\n    if (state.modifiedPaths.length > 0 && doc.$__.activePaths.states.modify == null) {\n      doc.$__.activePaths.states.modify = {};\n    }\n    for (const path of state.modifiedPaths) {\n      const currentState = doc.$__.activePaths.paths[path];\n      if (currentState != null) {\n        delete doc.$__.activePaths[currentState][path];\n      }\n      doc.$__.activePaths.paths[path] = 'modify';\n      doc.$__.activePaths.states.modify[path] = true;\n    }\n\n    for (const path of state.atomics.keys()) {\n      const val = doc.$__getValue(path);\n      if (val == null) {\n        continue;\n      }\n      val[arrayAtomicsSymbol] = state.atomics.get(path);\n    }\n  }\n}\n\n/**\n * Helper for `dropCollection()`. Will delete the given collection, including\n * all documents and indexes.\n *\n * @method dropCollection\n * @param {string} collection The collection to delete\n * @return {Promise}\n * @api public\n */\n\nConnection.prototype.dropCollection = async function dropCollection(collection) {\n  if (arguments.length >= 2 && typeof arguments[1] === 'function') {\n    throw new MongooseError('Connection.prototype.dropCollection() no longer accepts a callback');\n  }\n\n  if ((this.readyState === STATES.connecting || this.readyState === STATES.disconnected) && this._shouldBufferCommands()) {\n    await new Promise(resolve => {\n      this._queue.push({ fn: resolve });\n    });\n  }\n\n  return this.db.dropCollection(collection);\n};\n\n/**\n * Helper for MongoDB Node driver's `listCollections()`.\n * Returns an array of collection objects.\n *\n * @method listCollections\n * @return {Promise<Collection[]>}\n * @api public\n */\n\nConnection.prototype.listCollections = async function listCollections() {\n  if ((this.readyState === STATES.connecting || this.readyState === STATES.disconnected) && this._shouldBufferCommands()) {\n    await new Promise(resolve => {\n      this._queue.push({ fn: resolve });\n    });\n  }\n\n  const cursor = this.db.listCollections();\n  return await cursor.toArray();\n};\n\n/**\n * Helper for `dropDatabase()`. Deletes the given database, including all\n * collections, documents, and indexes.\n *\n * #### Example:\n *\n *     const conn = mongoose.createConnection('mongodb://127.0.0.1:27017/mydb');\n *     // Deletes the entire 'mydb' database\n *     await conn.dropDatabase();\n *\n * @method dropDatabase\n * @return {Promise}\n * @api public\n */\n\nConnection.prototype.dropDatabase = async function dropDatabase() {\n  if (arguments.length >= 1 && typeof arguments[0] === 'function') {\n    throw new MongooseError('Connection.prototype.dropDatabase() no longer accepts a callback');\n  }\n\n  if ((this.readyState === STATES.connecting || this.readyState === STATES.disconnected) && this._shouldBufferCommands()) {\n    await new Promise(resolve => {\n      this._queue.push({ fn: resolve });\n    });\n  }\n\n  // If `dropDatabase()` is called, this model's collection will not be\n  // init-ed. It is sufficiently common to call `dropDatabase()` after\n  // `mongoose.connect()` but before creating models that we want to\n  // support this. See gh-6796\n  for (const model of Object.values(this.models)) {\n    delete model.$init;\n  }\n\n  return this.db.dropDatabase();\n};\n\n/*!\n * ignore\n */\n\nConnection.prototype._shouldBufferCommands = function _shouldBufferCommands() {\n  if (this.config.bufferCommands != null) {\n    return this.config.bufferCommands;\n  }\n  if (this.base.get('bufferCommands') != null) {\n    return this.base.get('bufferCommands');\n  }\n  return true;\n};\n\n/**\n * error\n *\n * Graceful error handling, passes error to callback\n * if available, else emits error on the connection.\n *\n * @param {Error} err\n * @param {Function} callback optional\n * @emits \"error\" Emits the `error` event with the given `err`, unless a callback is specified\n * @returns {Promise|null} Returns a rejected Promise if no `callback` is given.\n * @api private\n */\n\nConnection.prototype.error = function(err, callback) {\n  if (callback) {\n    callback(err);\n    return null;\n  }\n  if (this.listeners('error').length > 0) {\n    this.emit('error', err);\n  }\n  return Promise.reject(err);\n};\n\n/**\n * Called when the connection is opened\n *\n * @api private\n */\n\nConnection.prototype.onOpen = function() {\n  this.readyState = STATES.connected;\n\n  for (const d of this._queue) {\n    d.fn.apply(d.ctx, d.args);\n  }\n  this._queue = [];\n\n  // avoid having the collection subscribe to our event emitter\n  // to prevent 0.3 warning\n  for (const i in this.collections) {\n    if (utils.object.hasOwnProperty(this.collections, i)) {\n      this.collections[i].onOpen();\n    }\n  }\n\n  this.emit('open');\n};\n\n/**\n * Opens the connection with a URI using `MongoClient.connect()`.\n *\n * @param {String} uri The URI to connect with.\n * @param {Object} [options] Passed on to [`MongoClient.connect`](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#connect-1)\n * @param {Boolean} [options.bufferCommands=true] Mongoose specific option. Set to false to [disable buffering](https://mongoosejs.com/docs/faq.html#callback_never_executes) on all models associated with this connection.\n * @param {Number} [options.bufferTimeoutMS=10000] Mongoose specific option. If `bufferCommands` is true, Mongoose will throw an error after `bufferTimeoutMS` if the operation is still buffered.\n * @param {String} [options.dbName] The name of the database we want to use. If not provided, use database name from connection string.\n * @param {String} [options.user] username for authentication, equivalent to `options.auth.user`. Maintained for backwards compatibility.\n * @param {String} [options.pass] password for authentication, equivalent to `options.auth.password`. Maintained for backwards compatibility.\n * @param {Number} [options.maxPoolSize=100] The maximum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).\n * @param {Number} [options.minPoolSize=0] The minimum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).\n * @param {Number} [options.serverSelectionTimeoutMS] If `useUnifiedTopology = true`, the MongoDB driver will try to find a server to send any given operation to, and keep retrying for `serverSelectionTimeoutMS` milliseconds before erroring out. If not set, the MongoDB driver defaults to using `30000` (30 seconds).\n * @param {Number} [options.heartbeatFrequencyMS] If `useUnifiedTopology = true`, the MongoDB driver sends a heartbeat every `heartbeatFrequencyMS` to check on the status of the connection. A heartbeat is subject to `serverSelectionTimeoutMS`, so the MongoDB driver will retry failed heartbeats for up to 30 seconds by default. Mongoose only emits a `'disconnected'` event after a heartbeat has failed, so you may want to decrease this setting to reduce the time between when your server goes down and when Mongoose emits `'disconnected'`. We recommend you do **not** set this setting below 1000, too many heartbeats can lead to performance degradation.\n * @param {Boolean} [options.autoIndex=true] Mongoose-specific option. Set to false to disable automatic index creation for all models associated with this connection.\n * @param {Class} [options.promiseLibrary] Sets the [underlying driver's promise library](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html#promiseLibrary).\n * @param {Number} [options.socketTimeoutMS=0] How long the MongoDB driver will wait before killing a socket due to inactivity _after initial connection_. A socket may be inactive because of either no activity or a long-running operation. `socketTimeoutMS` defaults to 0, which means Node.js will not time out the socket due to inactivity. This option is passed to [Node.js `socket#setTimeout()` function](https://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback) after the MongoDB driver successfully completes.\n * @param {Number} [options.family=0] Passed transparently to [Node.js' `dns.lookup()`](https://nodejs.org/api/dns.html#dns_dns_lookup_hostname_options_callback) function. May be either `0, `4`, or `6`. `4` means use IPv4 only, `6` means use IPv6 only, `0` means try both.\n * @param {Boolean} [options.autoCreate=false] Set to `true` to make Mongoose automatically call `createCollection()` on every model created on this connection.\n * @returns {Promise<Connection>}\n * @api public\n */\n\nConnection.prototype.openUri = async function openUri(uri, options) {\n  if (this.readyState === STATES.connecting || this.readyState === STATES.connected) {\n    if (this._connectionString === uri) {\n      return this;\n    }\n  }\n\n  this._closeCalled = false;\n\n  // Internal option to skip `await this.$initialConnection` in\n  // this function for `createConnection()`. Because otherwise\n  // `createConnection()` would have an uncatchable error.\n  let _fireAndForget = false;\n  if (options && '_fireAndForget' in options) {\n    _fireAndForget = options._fireAndForget;\n    delete options._fireAndForget;\n  }\n\n  try {\n    _validateArgs.apply(arguments);\n  } catch (err) {\n    if (_fireAndForget) {\n      throw err;\n    }\n    this.$initialConnection = Promise.reject(err);\n    throw err;\n  }\n\n  this.$initialConnection = this.createClient(uri, options).\n    then(() => this).\n    catch(err => {\n      this.readyState = STATES.disconnected;\n      if (this.listeners('error').length > 0) {\n        immediate(() => this.emit('error', err));\n      }\n      throw err;\n    });\n\n  for (const model of Object.values(this.models)) {\n    // Errors handled internally, so safe to ignore error\n    model.init().catch(function $modelInitNoop() {});\n  }\n\n  // `createConnection()` calls this `openUri()` function without\n  // awaiting on the result, so we set this option to rely on\n  // `asPromise()` to handle any errors.\n  if (_fireAndForget) {\n    return this;\n  }\n\n  try {\n    await this.$initialConnection;\n  } catch (err) {\n    throw _handleConnectionErrors(err);\n  }\n\n  return this;\n};\n\n/*!\n * Treat `on('error')` handlers as handling the initialConnection promise\n * to avoid uncaught exceptions when using `on('error')`. See gh-14377.\n */\n\nConnection.prototype.on = function on(event, callback) {\n  if (event === 'error' && this.$initialConnection) {\n    this.$initialConnection.catch(() => {});\n  }\n  return EventEmitter.prototype.on.call(this, event, callback);\n};\n\n/*!\n * Treat `once('error')` handlers as handling the initialConnection promise\n * to avoid uncaught exceptions when using `on('error')`. See gh-14377.\n */\n\nConnection.prototype.once = function on(event, callback) {\n  if (event === 'error' && this.$initialConnection) {\n    this.$initialConnection.catch(() => {});\n  }\n  return EventEmitter.prototype.once.call(this, event, callback);\n};\n\n/*!\n * ignore\n */\n\nfunction _validateArgs(uri, options, callback) {\n  if (typeof options === 'function' && callback == null) {\n    throw new MongooseError('Connection.prototype.openUri() no longer accepts a callback');\n  } else if (typeof callback === 'function') {\n    throw new MongooseError('Connection.prototype.openUri() no longer accepts a callback');\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _handleConnectionErrors(err) {\n  if (err?.name === 'MongoServerSelectionError') {\n    const originalError = err;\n    err = new ServerSelectionError();\n    err.assimilateError(originalError);\n  }\n\n  return err;\n}\n\n/**\n * Destroy the connection. Similar to [`.close`](https://mongoosejs.com/docs/api/connection.html#Connection.prototype.close()),\n * but also removes the connection from Mongoose's `connections` list and prevents the\n * connection from ever being re-opened.\n *\n * @param {Boolean} [force]\n * @returns {Promise}\n */\n\nConnection.prototype.destroy = async function destroy(force) {\n  if (typeof force === 'function' || (arguments.length === 2 && typeof arguments[1] === 'function')) {\n    throw new MongooseError('Connection.prototype.destroy() no longer accepts a callback');\n  }\n\n  if (force != null && typeof force === 'object') {\n    this.$wasForceClosed = !!force.force;\n  } else {\n    this.$wasForceClosed = !!force;\n  }\n\n  return this._close(force, true);\n};\n\n/**\n * Closes the connection\n *\n * @param {Boolean} [force] optional\n * @return {Promise}\n * @api public\n */\n\nConnection.prototype.close = async function close(force) {\n  if (typeof force === 'function' || (arguments.length === 2 && typeof arguments[1] === 'function')) {\n    throw new MongooseError('Connection.prototype.close() no longer accepts a callback');\n  }\n\n  if (force != null && typeof force === 'object') {\n    this.$wasForceClosed = !!force.force;\n  } else {\n    this.$wasForceClosed = !!force;\n  }\n\n  for (const model of Object.values(this.models)) {\n    // If manually disconnecting, make sure to clear each model's `$init`\n    // promise, so Mongoose knows to re-run `init()` in case the\n    // connection is re-opened. See gh-12047.\n    delete model.$init;\n  }\n\n  return this._close(force, false);\n};\n\n/**\n * Handles closing the connection\n *\n * @param {Boolean} force\n * @param {Boolean} destroy\n * @returns {Connection} this\n * @api private\n */\nConnection.prototype._close = async function _close(force, destroy) {\n  const _this = this;\n  const closeCalled = this._closeCalled;\n  this._closeCalled = true;\n  this._destroyCalled = destroy;\n  if (this.client != null) {\n    this.client._closeCalled = true;\n    this.client._destroyCalled = destroy;\n  }\n\n  const conn = this;\n  switch (this.readyState) {\n    case STATES.disconnected:\n      if (destroy && this.base.connections.indexOf(conn) !== -1) {\n        this.base.connections.splice(this.base.connections.indexOf(conn), 1);\n      }\n      if (!closeCalled) {\n        await this.doClose(force);\n        this.onClose(force);\n      }\n      break;\n\n    case STATES.connected:\n      this.readyState = STATES.disconnecting;\n      await this.doClose(force);\n      if (destroy && _this.base.connections.indexOf(conn) !== -1) {\n        this.base.connections.splice(this.base.connections.indexOf(conn), 1);\n      }\n      this.onClose(force);\n\n      break;\n    case STATES.connecting:\n      return new Promise((resolve, reject) => {\n        const _rerunClose = () => {\n          this.removeListener('open', _rerunClose);\n          this.removeListener('error', _rerunClose);\n          if (destroy) {\n            this.destroy(force).then(resolve, reject);\n          } else {\n            this.close(force).then(resolve, reject);\n          }\n        };\n\n        this.once('open', _rerunClose);\n        this.once('error', _rerunClose);\n      });\n\n    case STATES.disconnecting:\n      return new Promise(resolve => {\n        this.once('close', () => {\n          if (destroy && this.base.connections.indexOf(conn) !== -1) {\n            this.base.connections.splice(this.base.connections.indexOf(conn), 1);\n          }\n          resolve();\n        });\n      });\n  }\n\n  return this;\n};\n\n/**\n * Abstract method that drivers must implement.\n *\n * @api private\n */\n\nConnection.prototype.doClose = function() {\n  throw new Error('Connection#doClose unimplemented by driver');\n};\n\n/**\n * Called when the connection closes\n *\n * @api private\n */\n\nConnection.prototype.onClose = function(force) {\n  this.readyState = STATES.disconnected;\n\n  // avoid having the collection subscribe to our event emitter\n  // to prevent 0.3 warning\n  for (const i in this.collections) {\n    if (utils.object.hasOwnProperty(this.collections, i)) {\n      this.collections[i].onClose(force);\n    }\n  }\n\n  this.emit('close', force);\n\n  for (const db of this.otherDbs) {\n    this._destroyCalled ? db.destroy({ force: force, skipCloseClient: true }) : db.close({ force: force, skipCloseClient: true });\n  }\n};\n\n/**\n * Retrieves a raw collection instance, creating it if not cached.\n * This method returns a thin wrapper around a [MongoDB Node.js driver collection]([MongoDB Node.js driver collection](https://mongodb.github.io/node-mongodb-native/Next/classes/Collection.html)).\n * Using a Collection bypasses Mongoose middleware, validation, and casting,\n * letting you use [MongoDB Node.js driver](https://mongodb.github.io/node-mongodb-native/) functionality directly.\n *\n * @param {String} name of the collection\n * @param {Object} [options] optional collection options\n * @return {Collection} collection instance\n * @api public\n */\n\nConnection.prototype.collection = function(name, options) {\n  const defaultOptions = {\n    autoIndex: this.config.autoIndex != null ? this.config.autoIndex : this.base.options.autoIndex,\n    autoCreate: this.config.autoCreate != null ? this.config.autoCreate : this.base.options.autoCreate,\n    autoSearchIndex: this.config.autoSearchIndex != null ? this.config.autoSearchIndex : this.base.options.autoSearchIndex\n  };\n  options = Object.assign({}, defaultOptions, options ? clone(options) : {});\n  options.$wasForceClosed = this.$wasForceClosed;\n  const Collection = this.base && this.base.__driver && this.base.__driver.Collection || driver.get().Collection;\n  if (!(name in this.collections)) {\n    this.collections[name] = new Collection(name, this, options);\n  }\n  return this.collections[name];\n};\n\n/**\n * Declares a plugin executed on all schemas you pass to `conn.model()`\n *\n * Equivalent to calling `.plugin(fn)` on each schema you create.\n *\n * #### Example:\n *\n *     const db = mongoose.createConnection('mongodb://127.0.0.1:27017/mydb');\n *     db.plugin(() => console.log('Applied'));\n *     db.plugins.length; // 1\n *\n *     db.model('Test', new Schema({})); // Prints \"Applied\"\n *\n * @param {Function} fn plugin callback\n * @param {Object} [opts] optional options\n * @return {Connection} this\n * @see plugins https://mongoosejs.com/docs/plugins.html\n * @api public\n */\n\nConnection.prototype.plugin = function(fn, opts) {\n  this.plugins.push([fn, opts]);\n  return this;\n};\n\n/**\n * Defines or retrieves a model.\n *\n *     const mongoose = require('mongoose');\n *     const db = mongoose.createConnection(..);\n *     db.model('Venue', new Schema(..));\n *     const Ticket = db.model('Ticket', new Schema(..));\n *     const Venue = db.model('Venue');\n *\n * _When no `collection` argument is passed, Mongoose produces a collection name by passing the model `name` to the `utils.toCollectionName` method. This method pluralizes the name. If you don't like this behavior, either pass a collection name or set your schemas collection name option._\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String }, { collection: 'actor' });\n *\n *     // or\n *\n *     schema.set('collection', 'actor');\n *\n *     // or\n *\n *     const collectionName = 'actor'\n *     const M = conn.model('Actor', schema, collectionName)\n *\n * @param {String|Function} name the model name or class extending Model\n * @param {Schema} [schema] a schema. necessary when defining a model\n * @param {String} [collection] name of mongodb collection (optional) if not given it will be induced from model name\n * @param {Object} [options]\n * @param {Boolean} [options.overwriteModels=false] If true, overwrite existing models with the same name to avoid `OverwriteModelError`\n * @see Mongoose#model https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.model()\n * @return {Model} The compiled model\n * @api public\n */\n\nConnection.prototype.model = function(name, schema, collection, options) {\n  if (!(this instanceof Connection)) {\n    throw new MongooseError('`connection.model()` should not be run with ' +\n      '`new`. If you are doing `new db.model(foo)(bar)`, use ' +\n      '`db.model(foo)(bar)` instead');\n  }\n\n  let fn;\n  if (typeof name === 'function') {\n    fn = name;\n    name = fn.name;\n  }\n\n  // collection name discovery\n  if (typeof schema === 'string') {\n    collection = schema;\n    schema = false;\n  }\n\n  if (utils.isObject(schema)) {\n    if (!schema.instanceOfSchema) {\n      schema = new Schema(schema);\n    } else if (!(schema instanceof this.base.Schema)) {\n      schema = schema._clone(this.base.Schema);\n    }\n  }\n  if (schema && !schema.instanceOfSchema) {\n    throw new Error('The 2nd parameter to `mongoose.model()` should be a ' +\n      'schema or a POJO');\n  }\n\n  const defaultOptions = { cache: false, overwriteModels: this.base.options.overwriteModels };\n  const opts = Object.assign(defaultOptions, options, { connection: this });\n  if (this.models[name] && !collection && opts.overwriteModels !== true) {\n    // model exists but we are not subclassing with custom collection\n    if (schema && schema.instanceOfSchema && schema !== this.models[name].schema) {\n      throw new MongooseError.OverwriteModelError(name);\n    }\n    return this.models[name];\n  }\n\n  let model;\n\n  if (schema && schema.instanceOfSchema) {\n    applyPlugins(schema, this.plugins, null, '$connectionPluginsApplied');\n\n    // compile a model\n    model = this.base._model(fn || name, schema, collection, opts);\n\n    // only the first model with this name is cached to allow\n    // for one-offs with custom collection names etc.\n    if (!this.models[name]) {\n      this.models[name] = model;\n    }\n\n    // Errors handled internally, so safe to ignore error\n    model.init().catch(function $modelInitNoop() {});\n\n    return model;\n  }\n\n  if (this.models[name] && collection) {\n    // subclassing current model with alternate collection\n    model = this.models[name];\n    schema = model.prototype.schema;\n    const sub = model.__subclass(this, schema, collection);\n    // do not cache the sub model\n    return sub;\n  }\n\n  if (arguments.length === 1) {\n    model = this.models[name];\n    if (!model) {\n      throw new MongooseError.MissingSchemaError(name);\n    }\n    return model;\n  }\n\n  if (!model) {\n    throw new MongooseError.MissingSchemaError(name);\n  }\n\n  if (this === model.prototype.db\n      && (!collection || collection === model.collection.name)) {\n    // model already uses this connection.\n\n    // only the first model with this name is cached to allow\n    // for one-offs with custom collection names etc.\n    if (!this.models[name]) {\n      this.models[name] = model;\n    }\n\n    return model;\n  }\n  this.models[name] = model.__subclass(this, schema, collection);\n  return this.models[name];\n};\n\n/**\n * Removes the model named `name` from this connection, if it exists. You can\n * use this function to clean up any models you created in your tests to\n * prevent OverwriteModelErrors.\n *\n * #### Example:\n *\n *     conn.model('User', new Schema({ name: String }));\n *     console.log(conn.model('User')); // Model object\n *     conn.deleteModel('User');\n *     console.log(conn.model('User')); // undefined\n *\n *     // Usually useful in a Mocha `afterEach()` hook\n *     afterEach(function() {\n *       conn.deleteModel(/.+/); // Delete every model\n *     });\n *\n * @api public\n * @param {String|RegExp} name if string, the name of the model to remove. If regexp, removes all models whose name matches the regexp.\n * @return {Connection} this\n */\n\nConnection.prototype.deleteModel = function(name) {\n  if (typeof name === 'string') {\n    const model = this.model(name);\n    if (model == null) {\n      return this;\n    }\n    const collectionName = model.collection.name;\n    delete this.models[name];\n    delete this.collections[collectionName];\n\n    this.emit('deleteModel', model);\n  } else if (name instanceof RegExp) {\n    const pattern = name;\n    const names = this.modelNames();\n    for (const name of names) {\n      if (pattern.test(name)) {\n        this.deleteModel(name);\n      }\n    }\n  } else {\n    throw new Error('First parameter to `deleteModel()` must be a string ' +\n      'or regexp, got \"' + name + '\"');\n  }\n\n  return this;\n};\n\n/**\n * Watches the entire underlying database for changes. Similar to\n * [`Model.watch()`](https://mongoosejs.com/docs/api/model.html#Model.watch()).\n *\n * This function does **not** trigger any middleware. In particular, it\n * does **not** trigger aggregate middleware.\n *\n * The ChangeStream object is an event emitter that emits the following events:\n *\n * - 'change': A change occurred, see below example\n * - 'error': An unrecoverable error occurred. In particular, change streams currently error out if they lose connection to the replica set primary. Follow [this GitHub issue](https://github.com/Automattic/mongoose/issues/6799) for updates.\n * - 'end': Emitted if the underlying stream is closed\n * - 'close': Emitted if the underlying stream is closed\n *\n * #### Example:\n *\n *     const User = conn.model('User', new Schema({ name: String }));\n *\n *     const changeStream = conn.watch().on('change', data => console.log(data));\n *\n *     // Triggers a 'change' event on the change stream.\n *     await User.create({ name: 'test' });\n *\n * @api public\n * @param {Array} [pipeline]\n * @param {Object} [options] passed without changes to [the MongoDB driver's `Db#watch()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#watch)\n * @return {ChangeStream} mongoose-specific change stream wrapper, inherits from EventEmitter\n */\n\nConnection.prototype.watch = function(pipeline, options) {\n  const changeStreamThunk = cb => {\n    immediate(() => {\n      if (this.readyState === STATES.connecting) {\n        this.once('open', function() {\n          const driverChangeStream = this.db.watch(pipeline, options);\n          cb(null, driverChangeStream);\n        });\n      } else {\n        const driverChangeStream = this.db.watch(pipeline, options);\n        cb(null, driverChangeStream);\n      }\n    });\n  };\n\n  const changeStream = new ChangeStream(changeStreamThunk, pipeline, options);\n  return changeStream;\n};\n\n/**\n * Returns a promise that resolves when this connection\n * successfully connects to MongoDB, or rejects if this connection failed\n * to connect.\n *\n * #### Example:\n *\n *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/test').\n *       asPromise();\n *     conn.readyState; // 1, means Mongoose is connected\n *\n * @api public\n * @return {Promise}\n */\n\nConnection.prototype.asPromise = async function asPromise() {\n  try {\n    await this.$initialConnection;\n    return this;\n  } catch (err) {\n    throw _handleConnectionErrors(err);\n  }\n};\n\n/**\n * Returns an array of model names created on this connection.\n * @api public\n * @return {String[]}\n */\n\nConnection.prototype.modelNames = function() {\n  return Object.keys(this.models);\n};\n\n/**\n * Returns if the connection requires authentication after it is opened. Generally if a\n * username and password are both provided than authentication is needed, but in some cases a\n * password is not required.\n *\n * @api private\n * @return {Boolean} true if the connection should be authenticated after it is opened, otherwise false.\n */\nConnection.prototype.shouldAuthenticate = function() {\n  return this.user != null &&\n    (this.pass != null || this.authMechanismDoesNotRequirePassword());\n};\n\n/**\n * Returns a boolean value that specifies if the current authentication mechanism needs a\n * password to authenticate according to the auth objects passed into the openUri methods.\n *\n * @api private\n * @return {Boolean} true if the authentication mechanism specified in the options object requires\n *  a password, otherwise false.\n */\nConnection.prototype.authMechanismDoesNotRequirePassword = function() {\n  if (this.options && this.options.auth) {\n    return noPasswordAuthMechanisms.indexOf(this.options.auth.authMechanism) >= 0;\n  }\n  return true;\n};\n\n/**\n * Returns a boolean value that specifies if the provided objects object provides enough\n * data to authenticate with. Generally this is true if the username and password are both specified\n * but in some authentication methods, a password is not required for authentication so only a username\n * is required.\n *\n * @param {Object} [options] the options object passed into the openUri methods.\n * @api private\n * @return {Boolean} true if the provided options object provides enough data to authenticate with,\n *   otherwise false.\n */\nConnection.prototype.optionsProvideAuthenticationData = function(options) {\n  return (options) &&\n      (options.user) &&\n      ((options.pass) || this.authMechanismDoesNotRequirePassword());\n};\n\n/**\n * Returns the [MongoDB driver `MongoClient`](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html) instance\n * that this connection uses to talk to MongoDB.\n *\n * #### Example:\n *\n *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/test').\n *       asPromise();\n *\n *     conn.getClient(); // MongoClient { ... }\n *\n * @api public\n * @return {MongoClient}\n */\n\nConnection.prototype.getClient = function getClient() {\n  return this.client;\n};\n\n/**\n * Set the [MongoDB driver `MongoClient`](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html) instance\n * that this connection uses to talk to MongoDB. This is useful if you already have a MongoClient instance, and want to\n * reuse it.\n *\n * #### Example:\n *\n *     const client = await mongodb.MongoClient.connect('mongodb://127.0.0.1:27017/test');\n *\n *     const conn = mongoose.createConnection().setClient(client);\n *\n *     conn.getClient(); // MongoClient { ... }\n *     conn.readyState; // 1, means 'CONNECTED'\n *\n * @api public\n * @param {MongClient} client The Client to set to be used.\n * @return {Connection} this\n */\n\nConnection.prototype.setClient = function setClient() {\n  throw new MongooseError('Connection#setClient not implemented by driver');\n};\n\n/*!\n * Called internally by `openUri()` to create a MongoClient instance.\n */\n\nConnection.prototype.createClient = function createClient() {\n  throw new MongooseError('Connection#createClient not implemented by driver');\n};\n\n/**\n * Syncs all the indexes for the models registered with this connection.\n *\n * @param {Object} [options]\n * @param {Boolean} [options.continueOnError] `false` by default. If set to `true`, mongoose will not throw an error if one model syncing failed, and will return an object where the keys are the names of the models, and the values are the results/errors for each model.\n * @return {Promise<Object>} Returns a Promise, when the Promise resolves the value is a list of the dropped indexes.\n */\nConnection.prototype.syncIndexes = async function syncIndexes(options = {}) {\n  const result = {};\n  const errorsMap = { };\n\n  const { continueOnError } = options;\n  delete options.continueOnError;\n\n  for (const model of Object.values(this.models)) {\n    try {\n      result[model.modelName] = await model.syncIndexes(options);\n    } catch (err) {\n      if (!continueOnError) {\n        errorsMap[model.modelName] = err;\n        break;\n      } else {\n        result[model.modelName] = err;\n      }\n    }\n  }\n\n  if (!continueOnError && Object.keys(errorsMap).length) {\n    const message = Object.entries(errorsMap).map(([modelName, err]) => `${modelName}: ${err.message}`).join(', ');\n    const syncIndexesError = new SyncIndexesError(message, errorsMap);\n    throw syncIndexesError;\n  }\n\n  return result;\n};\n\n/**\n * Switches to a different database using the same [connection pool](https://mongoosejs.com/docs/api/connectionshtml#connection_pools).\n *\n * Returns a new connection object, with the new db.\n *\n * #### Example:\n *\n *     // Connect to `initialdb` first\n *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/initialdb').asPromise();\n *\n *     // Creates an un-cached connection to `mydb`\n *     const db = conn.useDb('mydb');\n *     // Creates a cached connection to `mydb2`. All calls to `conn.useDb('mydb2', { useCache: true })` will return the same\n *     // connection instance as opposed to creating a new connection instance\n *     const db2 = conn.useDb('mydb2', { useCache: true });\n *\n * @method useDb\n * @memberOf Connection\n * @param {String} name The database name\n * @param {Object} [options]\n * @param {Boolean} [options.useCache=false] If true, cache results so calling `useDb()` multiple times with the same name only creates 1 connection object.\n * @param {Boolean} [options.noListener=false] If true, the connection object will not make the db listen to events on the original connection. See [issue #9961](https://github.com/Automattic/mongoose/issues/9961).\n * @return {Connection} New Connection Object\n * @api public\n */\n\n/**\n * Removes the database connection with the given name created with with `useDb()`.\n *\n * Throws an error if the database connection was not found.\n *\n * #### Example:\n *\n *     // Connect to `initialdb` first\n *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/initialdb').asPromise();\n *\n *     // Creates an un-cached connection to `mydb`\n *     const db = conn.useDb('mydb');\n *\n *     // Closes `db`, and removes `db` from `conn.relatedDbs` and `conn.otherDbs`\n *     await conn.removeDb('mydb');\n *\n * @method removeDb\n * @memberOf Connection\n * @param {String} name The database name\n * @return {Connection} this\n * @api public\n */\n\n/*!\n * Module exports.\n */\n\nConnection.STATES = STATES;\nmodule.exports = Connection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Nvbm5lY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixtQkFBTyxDQUFDLDBGQUF1QjtBQUNwRCxxQkFBcUIsMERBQThCO0FBQ25ELGVBQWUsbUJBQU8sQ0FBQyxnRUFBVTtBQUNqQyxlQUFlLG1CQUFPLENBQUMsa0ZBQW1CO0FBQzFDLHNCQUFzQixtQkFBTyxDQUFDLDBFQUFlO0FBQzdDLDZCQUE2QixtQkFBTyxDQUFDLDhGQUF5QjtBQUM5RCx5QkFBeUIsbUJBQU8sQ0FBQyxzRkFBcUI7QUFDdEQscUJBQXFCLG1CQUFPLENBQUMsMEdBQStCO0FBQzVELGNBQWMsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDdkMsZUFBZSxtQkFBTyxDQUFDLGdFQUFVO0FBQ2pDLFlBQVksbUJBQU8sQ0FBQywwRUFBZTtBQUNuQyxrQkFBa0IsbUJBQU8sQ0FBQyxzRkFBcUI7QUFDL0MsY0FBYyxtQkFBTyxDQUFDLDhEQUFTO0FBQy9CLCtCQUErQixtQkFBTyxDQUFDLDRHQUFnQzs7QUFFdkUsMkJBQTJCLDRIQUErQztBQUMxRSw0QkFBNEIsNkhBQWdEOztBQUU1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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UUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixZQUFZLFlBQVk7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY29ubmVjdGlvbi5qcz84YWRhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IENoYW5nZVN0cmVhbSA9IHJlcXVpcmUoJy4vY3Vyc29yL2NoYW5nZVN0cmVhbScpO1xuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuY29uc3QgU2NoZW1hID0gcmVxdWlyZSgnLi9zY2hlbWEnKTtcbmNvbnN0IFNUQVRFUyA9IHJlcXVpcmUoJy4vY29ubmVjdGlvblN0YXRlJyk7XG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9pbmRleCcpO1xuY29uc3QgU2VydmVyU2VsZWN0aW9uRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL3NlcnZlclNlbGVjdGlvbicpO1xuY29uc3QgU3luY0luZGV4ZXNFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3Ivc3luY0luZGV4ZXMnKTtcbmNvbnN0IGFwcGx5UGx1Z2lucyA9IHJlcXVpcmUoJy4vaGVscGVycy9zY2hlbWEvYXBwbHlQbHVnaW5zJyk7XG5jb25zdCBjbG9uZSA9IHJlcXVpcmUoJy4vaGVscGVycy9jbG9uZScpO1xuY29uc3QgZHJpdmVyID0gcmVxdWlyZSgnLi9kcml2ZXInKTtcbmNvbnN0IGdldCA9IHJlcXVpcmUoJy4vaGVscGVycy9nZXQnKTtcbmNvbnN0IGltbWVkaWF0ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9pbW1lZGlhdGUnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuY29uc3QgQ3JlYXRlQ29sbGVjdGlvbnNFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3IvY3JlYXRlQ29sbGVjdGlvbnNFcnJvcicpO1xuXG5jb25zdCBhcnJheUF0b21pY3NTeW1ib2wgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ltYm9scycpLmFycmF5QXRvbWljc1N5bWJvbDtcbmNvbnN0IHNlc3Npb25OZXdEb2N1bWVudHMgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ltYm9scycpLnNlc3Npb25OZXdEb2N1bWVudHM7XG5cbi8qKlxuICogQSBsaXN0IG9mIGF1dGhlbnRpY2F0aW9uIG1lY2hhbmlzbXMgdGhhdCBkb24ndCByZXF1aXJlIGEgcGFzc3dvcmQgZm9yIGF1dGhlbnRpY2F0aW9uLlxuICogVGhpcyBpcyB1c2VkIGJ5IHRoZSBhdXRoTWVjaGFuaXNtRG9lc05vdFJlcXVpcmVQYXNzd29yZCBtZXRob2QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmNvbnN0IG5vUGFzc3dvcmRBdXRoTWVjaGFuaXNtcyA9IFtcbiAgJ01PTkdPREItWDUwOSdcbl07XG5cbi8qKlxuICogQ29ubmVjdGlvbiBjb25zdHJ1Y3RvclxuICpcbiAqIEZvciBwcmFjdGljYWwgcmVhc29ucywgYSBDb25uZWN0aW9uIGVxdWFscyBhIERiLlxuICpcbiAqIEBwYXJhbSB7TW9uZ29vc2V9IGJhc2UgYSBtb25nb29zZSBpbnN0YW5jZVxuICogQGluaGVyaXRzIE5vZGVKUyBFdmVudEVtaXR0ZXIgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9ldmVudHMuaHRtbCNjbGFzcy1ldmVudGVtaXR0ZXJcbiAqIEBldmVudCBgY29ubmVjdGluZ2A6IEVtaXR0ZWQgd2hlbiBgY29ubmVjdGlvbi5vcGVuVXJpKClgIGlzIGV4ZWN1dGVkIG9uIHRoaXMgY29ubmVjdGlvbi5cbiAqIEBldmVudCBgY29ubmVjdGVkYDogRW1pdHRlZCB3aGVuIHRoaXMgY29ubmVjdGlvbiBzdWNjZXNzZnVsbHkgY29ubmVjdHMgdG8gdGhlIGRiLiBNYXkgYmUgZW1pdHRlZCBfbXVsdGlwbGVfIHRpbWVzIGluIGByZWNvbm5lY3RlZGAgc2NlbmFyaW9zLlxuICogQGV2ZW50IGBvcGVuYDogRW1pdHRlZCBhZnRlciB3ZSBgY29ubmVjdGVkYCBhbmQgYG9uT3BlbmAgaXMgZXhlY3V0ZWQgb24gYWxsIG9mIHRoaXMgY29ubmVjdGlvbidzIG1vZGVscy5cbiAqIEBldmVudCBgZGlzY29ubmVjdGluZ2A6IEVtaXR0ZWQgd2hlbiBgY29ubmVjdGlvbi5jbG9zZSgpYCB3YXMgZXhlY3V0ZWQuXG4gKiBAZXZlbnQgYGRpc2Nvbm5lY3RlZGA6IEVtaXR0ZWQgYWZ0ZXIgZ2V0dGluZyBkaXNjb25uZWN0ZWQgZnJvbSB0aGUgZGIuXG4gKiBAZXZlbnQgYGNsb3NlYDogRW1pdHRlZCBhZnRlciB3ZSBgZGlzY29ubmVjdGVkYCBhbmQgYG9uQ2xvc2VgIGV4ZWN1dGVkIG9uIGFsbCBvZiB0aGlzIGNvbm5lY3Rpb24ncyBtb2RlbHMuXG4gKiBAZXZlbnQgYHJlY29ubmVjdGVkYDogRW1pdHRlZCBhZnRlciB3ZSBgY29ubmVjdGVkYCBhbmQgc3Vic2VxdWVudGx5IGBkaXNjb25uZWN0ZWRgLCBmb2xsb3dlZCBieSBzdWNjZXNzZnVsbHkgYW5vdGhlciBzdWNjZXNzZnVsIGNvbm5lY3Rpb24uXG4gKiBAZXZlbnQgYGVycm9yYDogRW1pdHRlZCB3aGVuIGFuIGVycm9yIG9jY3VycyBvbiB0aGlzIGNvbm5lY3Rpb24uXG4gKiBAZXZlbnQgYGZ1bGxzZXR1cGA6IEVtaXR0ZWQgYWZ0ZXIgdGhlIGRyaXZlciBoYXMgY29ubmVjdGVkIHRvIHByaW1hcnkgYW5kIGFsbCBzZWNvbmRhcmllcyBpZiBzcGVjaWZpZWQgaW4gdGhlIGNvbm5lY3Rpb24gc3RyaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBDb25uZWN0aW9uKGJhc2UpIHtcbiAgdGhpcy5iYXNlID0gYmFzZTtcbiAgdGhpcy5jb2xsZWN0aW9ucyA9IHt9O1xuICB0aGlzLm1vZGVscyA9IHt9O1xuICB0aGlzLmNvbmZpZyA9IHt9O1xuICB0aGlzLnJlcGxpY2EgPSBmYWxzZTtcbiAgdGhpcy5vcHRpb25zID0gbnVsbDtcbiAgdGhpcy5vdGhlckRicyA9IFtdOyAvLyBGSVhNRTogVG8gYmUgcmVwbGFjZWQgd2l0aCByZWxhdGVkRGJzXG4gIHRoaXMucmVsYXRlZERicyA9IHt9OyAvLyBIYXNobWFwIG9mIG90aGVyIGRicyB0aGF0IHNoYXJlIHVuZGVybHlpbmcgY29ubmVjdGlvblxuICB0aGlzLnN0YXRlcyA9IFNUQVRFUztcbiAgdGhpcy5fcmVhZHlTdGF0ZSA9IFNUQVRFUy5kaXNjb25uZWN0ZWQ7XG4gIHRoaXMuX2Nsb3NlQ2FsbGVkID0gZmFsc2U7XG4gIHRoaXMuX2hhc09wZW5lZCA9IGZhbHNlO1xuICB0aGlzLnBsdWdpbnMgPSBbXTtcbiAgaWYgKHR5cGVvZiBiYXNlID09PSAndW5kZWZpbmVkJyB8fCAhYmFzZS5jb25uZWN0aW9ucy5sZW5ndGgpIHtcbiAgICB0aGlzLmlkID0gMDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmlkID0gYmFzZS5uZXh0Q29ubmVjdGlvbklkO1xuICB9XG4gIHRoaXMuX3F1ZXVlID0gW107XG59XG5cbi8qIVxuICogSW5oZXJpdCBmcm9tIEV2ZW50RW1pdHRlclxuICovXG5cbk9iamVjdC5zZXRQcm90b3R5cGVPZihDb25uZWN0aW9uLnByb3RvdHlwZSwgRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5cbi8qKlxuICogQ29ubmVjdGlvbiByZWFkeSBzdGF0ZVxuICpcbiAqIC0gMCA9IGRpc2Nvbm5lY3RlZFxuICogLSAxID0gY29ubmVjdGVkXG4gKiAtIDIgPSBjb25uZWN0aW5nXG4gKiAtIDMgPSBkaXNjb25uZWN0aW5nXG4gKlxuICogRWFjaCBzdGF0ZSBjaGFuZ2UgZW1pdHMgaXRzIGFzc29jaWF0ZWQgZXZlbnQgbmFtZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbm4ub24oJ2Nvbm5lY3RlZCcsIGNhbGxiYWNrKTtcbiAqICAgICBjb25uLm9uKCdkaXNjb25uZWN0ZWQnLCBjYWxsYmFjayk7XG4gKlxuICogQHByb3BlcnR5IHJlYWR5U3RhdGVcbiAqIEBtZW1iZXJPZiBDb25uZWN0aW9uXG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbm5lY3Rpb24ucHJvdG90eXBlLCAncmVhZHlTdGF0ZScsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZHlTdGF0ZTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICBpZiAoISh2YWwgaW4gU1RBVEVTKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvbm5lY3Rpb24gc3RhdGU6ICcgKyB2YWwpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9yZWFkeVN0YXRlICE9PSB2YWwpIHtcbiAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSB2YWw7XG4gICAgICAvLyBbbGVnYWN5XSBsb29wIG92ZXIgdGhlIG90aGVyRGJzIG9uIHRoaXMgY29ubmVjdGlvbiBhbmQgY2hhbmdlIHRoZWlyIHN0YXRlXG4gICAgICBmb3IgKGNvbnN0IGRiIG9mIHRoaXMub3RoZXJEYnMpIHtcbiAgICAgICAgZGIucmVhZHlTdGF0ZSA9IHZhbDtcbiAgICAgIH1cblxuICAgICAgaWYgKFNUQVRFUy5jb25uZWN0ZWQgPT09IHZhbCkge1xuICAgICAgICB0aGlzLl9oYXNPcGVuZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVtaXQoU1RBVEVTW3ZhbF0pO1xuICAgIH1cbiAgfVxufSk7XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgb2YgdGhlIG9wdGlvbiBga2V5YC4gRXF1aXZhbGVudCB0byBgY29ubi5vcHRpb25zW2tleV1gXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25uLmdldCgndGVzdCcpOyAvLyByZXR1cm5zIHRoZSAndGVzdCcgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAbWV0aG9kIGdldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgaWYgKHRoaXMuY29uZmlnLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWdba2V5XTtcbiAgfVxuXG4gIHJldHVybiBnZXQodGhpcy5vcHRpb25zLCBrZXkpO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgb3B0aW9uIGBrZXlgLiBFcXVpdmFsZW50IHRvIGBjb25uLm9wdGlvbnNba2V5XSA9IHZhbGBcbiAqXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBpbmNsdWRlOlxuICpcbiAqIC0gYG1heFRpbWVNU2A6IFNldCBbYG1heFRpbWVNU2BdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUubWF4VGltZU1TKCkpIGZvciBhbGwgcXVlcmllcyBvbiB0aGlzIGNvbm5lY3Rpb24uXG4gKiAtICdkZWJ1Zyc6IElmIGB0cnVlYCwgcHJpbnRzIHRoZSBvcGVyYXRpb25zIG1vbmdvb3NlIHNlbmRzIHRvIE1vbmdvREIgdG8gdGhlIGNvbnNvbGUuIElmIGEgd3JpdGFibGUgc3RyZWFtIGlzIHBhc3NlZCwgaXQgd2lsbCBsb2cgdG8gdGhhdCBzdHJlYW0sIHdpdGhvdXQgY29sb3JpemF0aW9uLiBJZiBhIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIHBhc3NlZCwgaXQgd2lsbCByZWNlaXZlIHRoZSBjb2xsZWN0aW9uIG5hbWUsIHRoZSBtZXRob2QgbmFtZSwgdGhlbiBhbGwgYXJ1Z21lbnRzIHBhc3NlZCB0byB0aGUgbWV0aG9kLiBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnRlZCB0byByZXBsaWNhdGUgdGhlIGRlZmF1bHQgbG9nZ2luZywgeW91IGNvdWxkIG91dHB1dCBmcm9tIHRoZSBjYWxsYmFjayBgTW9uZ29vc2U6ICR7Y29sbGVjdGlvbk5hbWV9LiR7bWV0aG9kTmFtZX0oJHttZXRob2RBcmdzLmpvaW4oJywgJyl9KWAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25uLnNldCgndGVzdCcsICdmb28nKTtcbiAqICAgICBjb25uLmdldCgndGVzdCcpOyAvLyAnZm9vJ1xuICogICAgIGNvbm4ub3B0aW9ucy50ZXN0OyAvLyAnZm9vJ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7QW55fSB2YWxcbiAqIEBtZXRob2Qgc2V0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gIGlmICh0aGlzLmNvbmZpZy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgdGhpcy5jb25maWdba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgdGhpcy5vcHRpb25zID0gdGhpcy5vcHRpb25zIHx8IHt9O1xuICB0aGlzLm9wdGlvbnNba2V5XSA9IHZhbDtcbiAgcmV0dXJuIHZhbDtcbn07XG5cbi8qKlxuICogQSBoYXNoIG9mIHRoZSBjb2xsZWN0aW9ucyBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb25uZWN0aW9uXG4gKlxuICogQHByb3BlcnR5IGNvbGxlY3Rpb25zXG4gKiBAbWVtYmVyT2YgQ29ubmVjdGlvblxuICogQGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmNvbGxlY3Rpb25zO1xuXG4vKipcbiAqIFRoZSBuYW1lIG9mIHRoZSBkYXRhYmFzZSB0aGlzIGNvbm5lY3Rpb24gcG9pbnRzIHRvLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbignbW9uZ29kYjovLzEyNy4wLjAuMToyNzAxNy9teWRiJykubmFtZTsgLy8gXCJteWRiXCJcbiAqXG4gKiBAcHJvcGVydHkgbmFtZVxuICogQG1lbWJlck9mIENvbm5lY3Rpb25cbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5uYW1lO1xuXG4vKipcbiAqIEEgW1BPSk9dKGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy9wb2pvKSBjb250YWluaW5nXG4gKiBhIG1hcCBmcm9tIG1vZGVsIG5hbWVzIHRvIG1vZGVscy4gQ29udGFpbnMgYWxsIG1vZGVscyB0aGF0IGhhdmUgYmVlblxuICogYWRkZWQgdG8gdGhpcyBjb25uZWN0aW9uIHVzaW5nIFtgQ29ubmVjdGlvbiNtb2RlbCgpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9jb25uZWN0aW9uLmh0bWwjQ29ubmVjdGlvbi5wcm90b3R5cGUubW9kZWwoKSkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBjb25uID0gbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbigpO1xuICogICAgIGNvbnN0IFRlc3QgPSBjb25uLm1vZGVsKCdUZXN0JywgbW9uZ29vc2UuU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0pKTtcbiAqXG4gKiAgICAgT2JqZWN0LmtleXMoY29ubi5tb2RlbHMpLmxlbmd0aDsgLy8gMVxuICogICAgIGNvbm4ubW9kZWxzLlRlc3QgPT09IFRlc3Q7IC8vIHRydWVcbiAqXG4gKiBAcHJvcGVydHkgbW9kZWxzXG4gKiBAbWVtYmVyT2YgQ29ubmVjdGlvblxuICogQGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLm1vZGVscztcblxuLyoqXG4gKiBBIG51bWJlciBpZGVudGlmaWVyIGZvciB0aGlzIGNvbm5lY3Rpb24uIFVzZWQgZm9yIGRlYnVnZ2luZyB3aGVuXG4gKiB5b3UgaGF2ZSBbbXVsdGlwbGUgY29ubmVjdGlvbnNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9jb25uZWN0aW9ucy5odG1sI211bHRpcGxlX2Nvbm5lY3Rpb25zKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIFRoZSBkZWZhdWx0IGNvbm5lY3Rpb24gaGFzIGBpZCA9IDBgXG4gKiAgICAgbW9uZ29vc2UuY29ubmVjdGlvbi5pZDsgLy8gMFxuICpcbiAqICAgICAvLyBJZiB5b3UgY3JlYXRlIGEgbmV3IGNvbm5lY3Rpb24sIE1vbmdvb3NlIGluY3JlbWVudHMgaWRcbiAqICAgICBjb25zdCBjb25uID0gbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbigpO1xuICogICAgIGNvbm4uaWQ7IC8vIDFcbiAqXG4gKiBAcHJvcGVydHkgaWRcbiAqIEBtZW1iZXJPZiBDb25uZWN0aW9uXG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuaWQ7XG5cbi8qKlxuICogVGhlIHBsdWdpbnMgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gYWxsIG1vZGVscyBjcmVhdGVkIG9uIHRoaXMgY29ubmVjdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGRiID0gbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbignbW9uZ29kYjovLzEyNy4wLjAuMToyNzAxNy9teWRiJyk7XG4gKiAgICAgZGIucGx1Z2luKCgpID0+IGNvbnNvbGUubG9nKCdBcHBsaWVkJykpO1xuICogICAgIGRiLnBsdWdpbnMubGVuZ3RoOyAvLyAxXG4gKlxuICogICAgIGRiLm1vZGVsKCdUZXN0JywgbmV3IFNjaGVtYSh7fSkpOyAvLyBQcmludHMgXCJBcHBsaWVkXCJcbiAqXG4gKiBAcHJvcGVydHkgcGx1Z2luc1xuICogQG1lbWJlck9mIENvbm5lY3Rpb25cbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ29ubmVjdGlvbi5wcm90b3R5cGUsICdwbHVnaW5zJywge1xuICBjb25maWd1cmFibGU6IGZhbHNlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZVxufSk7XG5cbi8qKlxuICogVGhlIGhvc3QgbmFtZSBwb3J0aW9uIG9mIHRoZSBVUkkuIElmIG11bHRpcGxlIGhvc3RzLCBzdWNoIGFzIGEgcmVwbGljYSBzZXQsXG4gKiB0aGlzIHdpbGwgY29udGFpbiB0aGUgZmlyc3QgaG9zdCBuYW1lIGluIHRoZSBVUklcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oJ21vbmdvZGI6Ly8xMjcuMC4wLjE6MjcwMTcvbXlkYicpLmhvc3Q7IC8vIFwiMTI3LjAuMC4xXCJcbiAqXG4gKiBAcHJvcGVydHkgaG9zdFxuICogQG1lbWJlck9mIENvbm5lY3Rpb25cbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ29ubmVjdGlvbi5wcm90b3R5cGUsICdob3N0Jywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlXG59KTtcblxuLyoqXG4gKiBUaGUgcG9ydCBwb3J0aW9uIG9mIHRoZSBVUkkuIElmIG11bHRpcGxlIGhvc3RzLCBzdWNoIGFzIGEgcmVwbGljYSBzZXQsXG4gKiB0aGlzIHdpbGwgY29udGFpbiB0aGUgcG9ydCBmcm9tIHRoZSBmaXJzdCBob3N0IG5hbWUgaW4gdGhlIFVSSS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oJ21vbmdvZGI6Ly8xMjcuMC4wLjE6MjcwMTcvbXlkYicpLnBvcnQ7IC8vIDI3MDE3XG4gKlxuICogQHByb3BlcnR5IHBvcnRcbiAqIEBtZW1iZXJPZiBDb25uZWN0aW9uXG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbm5lY3Rpb24ucHJvdG90eXBlLCAncG9ydCcsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZVxufSk7XG5cbi8qKlxuICogVGhlIHVzZXJuYW1lIHNwZWNpZmllZCBpbiB0aGUgVVJJXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBtb25nb29zZS5jcmVhdGVDb25uZWN0aW9uKCdtb25nb2RiOi8vdmFsOnBzd0AxMjcuMC4wLjE6MjcwMTcvbXlkYicpLnVzZXI7IC8vIFwidmFsXCJcbiAqXG4gKiBAcHJvcGVydHkgdXNlclxuICogQG1lbWJlck9mIENvbm5lY3Rpb25cbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ29ubmVjdGlvbi5wcm90b3R5cGUsICd1c2VyJywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlXG59KTtcblxuLyoqXG4gKiBUaGUgcGFzc3dvcmQgc3BlY2lmaWVkIGluIHRoZSBVUklcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oJ21vbmdvZGI6Ly92YWw6cHN3QDEyNy4wLjAuMToyNzAxNy9teWRiJykucGFzczsgLy8gXCJwc3dcIlxuICpcbiAqIEBwcm9wZXJ0eSBwYXNzXG4gKiBAbWVtYmVyT2YgQ29ubmVjdGlvblxuICogQGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25uZWN0aW9uLnByb3RvdHlwZSwgJ3Bhc3MnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWVcbn0pO1xuXG4vKipcbiAqIFRoZSBtb25nb2RiLkRiIGluc3RhbmNlLCBzZXQgd2hlbiB0aGUgY29ubmVjdGlvbiBpcyBvcGVuZWRcbiAqXG4gKiBAcHJvcGVydHkgZGJcbiAqIEBtZW1iZXJPZiBDb25uZWN0aW9uXG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuZGI7XG5cbi8qKlxuICogVGhlIE1vbmdvQ2xpZW50IGluc3RhbmNlIHRoaXMgY29ubmVjdGlvbiB1c2VzIHRvIHRhbGsgdG8gTW9uZ29EQi4gTW9uZ29vc2UgYXV0b21hdGljYWxseSBzZXRzIHRoaXMgcHJvcGVydHlcbiAqIHdoZW4gdGhlIGNvbm5lY3Rpb24gaXMgb3BlbmVkLlxuICpcbiAqIEBwcm9wZXJ0eSBjbGllbnRcbiAqIEBtZW1iZXJPZiBDb25uZWN0aW9uXG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuY2xpZW50O1xuXG4vKipcbiAqIEEgaGFzaCBvZiB0aGUgZ2xvYmFsIG9wdGlvbnMgdGhhdCBhcmUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29ubmVjdGlvblxuICpcbiAqIEBwcm9wZXJ0eSBjb25maWdcbiAqIEBtZW1iZXJPZiBDb25uZWN0aW9uXG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuY29uZmlnO1xuXG4vKipcbiAqIEhlbHBlciBmb3IgYGNyZWF0ZUNvbGxlY3Rpb24oKWAuIFdpbGwgZXhwbGljaXRseSBjcmVhdGUgdGhlIGdpdmVuIGNvbGxlY3Rpb25cbiAqIHdpdGggc3BlY2lmaWVkIG9wdGlvbnMuIFVzZWQgdG8gY3JlYXRlIFtjYXBwZWQgY29sbGVjdGlvbnNdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL2NvcmUvY2FwcGVkLWNvbGxlY3Rpb25zLylcbiAqIGFuZCBbdmlld3NdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL2NvcmUvdmlld3MvKSBmcm9tIG1vbmdvb3NlLlxuICpcbiAqIE9wdGlvbnMgYXJlIHBhc3NlZCBkb3duIHdpdGhvdXQgbW9kaWZpY2F0aW9uIHRvIHRoZSBbTW9uZ29EQiBkcml2ZXIncyBgY3JlYXRlQ29sbGVjdGlvbigpYCBmdW5jdGlvbl0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0RiLmh0bWwjY3JlYXRlQ29sbGVjdGlvbilcbiAqXG4gKiBAbWV0aG9kIGNyZWF0ZUNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGNyZWF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBzZWUgW01vbmdvREIgZHJpdmVyIGRvY3NdKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9EYi5odG1sI2NyZWF0ZUNvbGxlY3Rpb24pXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVDb2xsZWN0aW9uID0gYXN5bmMgZnVuY3Rpb24gY3JlYXRlQ29sbGVjdGlvbihjb2xsZWN0aW9uLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fCAoYXJndW1lbnRzLmxlbmd0aCA+PSAzICYmIHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0Nvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZUNvbGxlY3Rpb24oKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBpZiAoKHRoaXMucmVhZHlTdGF0ZSA9PT0gU1RBVEVTLmNvbm5lY3RpbmcgfHwgdGhpcy5yZWFkeVN0YXRlID09PSBTVEFURVMuZGlzY29ubmVjdGVkKSAmJiB0aGlzLl9zaG91bGRCdWZmZXJDb21tYW5kcygpKSB7XG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLl9xdWV1ZS5wdXNoKHsgZm46IHJlc29sdmUgfSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5kYi5jcmVhdGVDb2xsZWN0aW9uKGNvbGxlY3Rpb24sIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDYWxscyBgY3JlYXRlQ29sbGVjdGlvbigpYCBvbiBhIG1vZGVscyBpbiBhIHNlcmllcy5cbiAqXG4gKiBAbWV0aG9kIGNyZWF0ZUNvbGxlY3Rpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNvbnRpbnVlT25FcnJvciBXaGVuIHRydWUsIHdpbGwgY29udGludWUgdG8gY3JlYXRlIGNvbGxlY3Rpb25zIGFuZCBjcmVhdGUgYSBuZXcgZXJyb3IgY2xhc3MgZm9yIHRoZSBjb2xsZWN0aW9ucyB0aGF0IGVycm9yZWQuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlQ29sbGVjdGlvbnMgPSBhc3luYyBmdW5jdGlvbiBjcmVhdGVDb2xsZWN0aW9ucyhvcHRpb25zID0ge30pIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGNvbnN0IGVycm9yc01hcCA9IHsgfTtcblxuICBjb25zdCB7IGNvbnRpbnVlT25FcnJvciB9ID0gb3B0aW9ucztcbiAgZGVsZXRlIG9wdGlvbnMuY29udGludWVPbkVycm9yO1xuICBmb3IgKGNvbnN0IG1vZGVsIG9mIE9iamVjdC52YWx1ZXModGhpcy5tb2RlbHMpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdFttb2RlbC5tb2RlbE5hbWVdID0gYXdhaXQgbW9kZWwuY3JlYXRlQ29sbGVjdGlvbih7fSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoIWNvbnRpbnVlT25FcnJvcikge1xuICAgICAgICBlcnJvcnNNYXBbbW9kZWwubW9kZWxOYW1lXSA9IGVycjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbbW9kZWwubW9kZWxOYW1lXSA9IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbnRpbnVlT25FcnJvciAmJiBPYmplY3Qua2V5cyhlcnJvcnNNYXApLmxlbmd0aCkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuZW50cmllcyhlcnJvcnNNYXApLm1hcCgoW21vZGVsTmFtZSwgZXJyXSkgPT4gYCR7bW9kZWxOYW1lfTogJHtlcnIubWVzc2FnZX1gKS5qb2luKCcsICcpO1xuICAgIGNvbnN0IGNyZWF0ZUNvbGxlY3Rpb25zRXJyb3IgPSBuZXcgQ3JlYXRlQ29sbGVjdGlvbnNFcnJvcihtZXNzYWdlLCBlcnJvcnNNYXApO1xuICAgIHRocm93IGNyZWF0ZUNvbGxlY3Rpb25zRXJyb3I7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQSBjb252ZW5pZW5jZSB3cmFwcGVyIGZvciBgY29ubmVjdGlvbi5jbGllbnQud2l0aFNlc3Npb24oKWAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhd2FpdCBjb25uLndpdGhTZXNzaW9uKGFzeW5jIHNlc3Npb24gPT4ge1xuICogICAgICAgY29uc3QgZG9jID0gYXdhaXQgVGVzdE1vZGVsLmZpbmRPbmUoKS5zZXNzaW9uKHNlc3Npb24pO1xuICogICAgIH0pO1xuICpcbiAqIEBtZXRob2Qgd2l0aFNlc3Npb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGV4ZWN1dG9yIGNhbGxlZCB3aXRoIDEgYXJndW1lbnQ6IGEgYENsaWVudFNlc3Npb25gIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtQcm9taXNlfSByZXNvbHZlcyB0byB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBleGVjdXRvciBmdW5jdGlvblxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS53aXRoU2Vzc2lvbiA9IGFzeW5jIGZ1bmN0aW9uIHdpdGhTZXNzaW9uKGV4ZWN1dG9yKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgcHJvdmlkZSBhbiBleGVjdXRvciBmdW5jdGlvbicpO1xuICB9XG4gIHJldHVybiBhd2FpdCB0aGlzLmNsaWVudC53aXRoU2Vzc2lvbihleGVjdXRvcik7XG59O1xuXG4vKipcbiAqIF9SZXF1aXJlcyBNb25nb0RCID49IDMuNi4wLl8gU3RhcnRzIGEgW01vbmdvREIgc2Vzc2lvbl0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVsZWFzZS1ub3Rlcy8zLjYvI2NsaWVudC1zZXNzaW9ucylcbiAqIGZvciBiZW5lZml0cyBsaWtlIGNhdXNhbCBjb25zaXN0ZW5jeSwgW3JldHJ5YWJsZSB3cml0ZXNdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL2NvcmUvcmV0cnlhYmxlLXdyaXRlcy8pLFxuICogYW5kIFt0cmFuc2FjdGlvbnNdKGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vYS1ub2RlLWpzLXBlcnNwZWN0aXZlLW9uLW1vbmdvZGItNC10cmFuc2FjdGlvbnMuaHRtbCkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgY29ubi5zdGFydFNlc3Npb24oKTtcbiAqICAgICBsZXQgZG9jID0gYXdhaXQgUGVyc29uLmZpbmRPbmUoeyBuYW1lOiAnTmVkIFN0YXJrJyB9LCBudWxsLCB7IHNlc3Npb24gfSk7XG4gKiAgICAgYXdhaXQgZG9jLnJlbW92ZSgpO1xuICogICAgIC8vIGBkb2NgIHdpbGwgYWx3YXlzIGJlIG51bGwsIGV2ZW4gaWYgcmVhZGluZyBmcm9tIGEgcmVwbGljYSBzZXRcbiAqICAgICAvLyBzZWNvbmRhcnkuIFdpdGhvdXQgY2F1c2FsIGNvbnNpc3RlbmN5LCBpdCBpcyBwb3NzaWJsZSB0b1xuICogICAgIC8vIGdldCBhIGRvYyBiYWNrIGZyb20gdGhlIGJlbG93IHF1ZXJ5IGlmIHRoZSBxdWVyeSByZWFkcyBmcm9tIGFcbiAqICAgICAvLyBzZWNvbmRhcnkgdGhhdCBpcyBleHBlcmllbmNpbmcgcmVwbGljYXRpb24gbGFnLlxuICogICAgIGRvYyA9IGF3YWl0IFBlcnNvbi5maW5kT25lKHsgbmFtZTogJ05lZCBTdGFyaycgfSwgbnVsbCwgeyBzZXNzaW9uLCByZWFkUHJlZmVyZW5jZTogJ3NlY29uZGFyeScgfSk7XG4gKlxuICpcbiAqIEBtZXRob2Qgc3RhcnRTZXNzaW9uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIHNlZSB0aGUgW21vbmdvZGIgZHJpdmVyIG9wdGlvbnNdKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9Nb25nb0NsaWVudC5odG1sI3N0YXJ0U2Vzc2lvbilcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2F1c2FsQ29uc2lzdGVuY3k9dHJ1ZV0gc2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgY2F1c2FsIGNvbnNpc3RlbmN5XG4gKiBAcmV0dXJuIHtQcm9taXNlPENsaWVudFNlc3Npb24+fSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBNb25nb0RCIGRyaXZlciBgQ2xpZW50U2Vzc2lvbmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuc3RhcnRTZXNzaW9uID0gYXN5bmMgZnVuY3Rpb24gc3RhcnRTZXNzaW9uKG9wdGlvbnMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMiAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0Nvbm5lY3Rpb24ucHJvdG90eXBlLnN0YXJ0U2Vzc2lvbigpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGlmICgodGhpcy5yZWFkeVN0YXRlID09PSBTVEFURVMuY29ubmVjdGluZyB8fCB0aGlzLnJlYWR5U3RhdGUgPT09IFNUQVRFUy5kaXNjb25uZWN0ZWQpICYmIHRoaXMuX3Nob3VsZEJ1ZmZlckNvbW1hbmRzKCkpIHtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMuX3F1ZXVlLnB1c2goeyBmbjogcmVzb2x2ZSB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IHNlc3Npb24gPSB0aGlzLmNsaWVudC5zdGFydFNlc3Npb24ob3B0aW9ucyk7XG4gIHJldHVybiBzZXNzaW9uO1xufTtcblxuLyoqXG4gKiBfUmVxdWlyZXMgTW9uZ29EQiA+PSAzLjYuMC5fIEV4ZWN1dGVzIHRoZSB3cmFwcGVkIGFzeW5jIGZ1bmN0aW9uXG4gKiBpbiBhIHRyYW5zYWN0aW9uLiBNb25nb29zZSB3aWxsIGNvbW1pdCB0aGUgdHJhbnNhY3Rpb24gaWYgdGhlXG4gKiBhc3luYyBmdW5jdGlvbiBleGVjdXRlcyBzdWNjZXNzZnVsbHkgYW5kIGF0dGVtcHQgdG8gcmV0cnkgaWZcbiAqIHRoZXJlIHdhcyBhIHJldHJpYWJsZSBlcnJvci5cbiAqXG4gKiBDYWxscyB0aGUgTW9uZ29EQiBkcml2ZXIncyBbYHNlc3Npb24ud2l0aFRyYW5zYWN0aW9uKClgXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvQ2xpZW50U2Vzc2lvbi5odG1sI3dpdGhUcmFuc2FjdGlvbiksXG4gKiBidXQgYWxzbyBoYW5kbGVzIHJlc2V0dGluZyBNb25nb29zZSBkb2N1bWVudCBzdGF0ZSBhcyBzaG93biBiZWxvdy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGRvYyA9IG5ldyBQZXJzb24oeyBuYW1lOiAnV2lsbCBSaWtlcicgfSk7XG4gKiAgICAgYXdhaXQgZGIudHJhbnNhY3Rpb24oYXN5bmMgZnVuY3Rpb24gc2V0UmFuayhzZXNzaW9uKSB7XG4gKiAgICAgICBkb2MucmFuayA9ICdDYXB0YWluJztcbiAqICAgICAgIGF3YWl0IGRvYy5zYXZlKHsgc2Vzc2lvbiB9KTtcbiAqICAgICAgIGRvYy5pc05ldzsgLy8gZmFsc2VcbiAqXG4gKiAgICAgICAvLyBUaHJvdyBhbiBlcnJvciB0byBhYm9ydCB0aGUgdHJhbnNhY3Rpb25cbiAqICAgICAgIHRocm93IG5ldyBFcnJvcignT29wcyEnKTtcbiAqICAgICB9LHsgcmVhZFByZWZlcmVuY2U6ICdwcmltYXJ5JyB9KS5jYXRjaCgoKSA9PiB7fSk7XG4gKlxuICogICAgIC8vIHRydWUsIGB0cmFuc2FjdGlvbigpYCByZXNldCB0aGUgZG9jdW1lbnQncyBzdGF0ZSBiZWNhdXNlIHRoZVxuICogICAgIC8vIHRyYW5zYWN0aW9uIHdhcyBhYm9ydGVkLlxuICogICAgIGRvYy5pc05ldztcbiAqXG4gKiBAbWV0aG9kIHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBleGVjdXRlIGluIGEgdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7bW9uZ29kYi5UcmFuc2FjdGlvbk9wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25hbCBzZXR0aW5ncyBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gKiBAcmV0dXJuIHtQcm9taXNlPEFueT59IHByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgaWYgTW9uZ29vc2Ugc3VjY2Vzc2Z1bGx5IGNvbW1pdHRlZCB0aGUgdHJhbnNhY3Rpb24sIG9yIHJlamVjdHMgaWYgdGhlIHRyYW5zYWN0aW9uIHdhcyBhYm9ydGVkIG9yIGlmIE1vbmdvb3NlIGZhaWxlZCB0byBjb21taXQgdGhlIHRyYW5zYWN0aW9uLiBJZiBmdWxmaWxsZWQsIHRoZSBwcm9taXNlIHJlc29sdmVzIHRvIGEgTW9uZ29EQiBjb21tYW5kIHJlc3VsdC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUudHJhbnNhY3Rpb24gPSBmdW5jdGlvbiB0cmFuc2FjdGlvbihmbiwgb3B0aW9ucykge1xuICByZXR1cm4gdGhpcy5zdGFydFNlc3Npb24oKS50aGVuKHNlc3Npb24gPT4ge1xuICAgIHNlc3Npb25bc2Vzc2lvbk5ld0RvY3VtZW50c10gPSBuZXcgTWFwKCk7XG4gICAgcmV0dXJuIHNlc3Npb24ud2l0aFRyYW5zYWN0aW9uKCgpID0+IF93cmFwVXNlclRyYW5zYWN0aW9uKGZuLCBzZXNzaW9uKSwgb3B0aW9ucykuXG4gICAgICB0aGVuKHJlcyA9PiB7XG4gICAgICAgIGRlbGV0ZSBzZXNzaW9uW3Nlc3Npb25OZXdEb2N1bWVudHNdO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSkuXG4gICAgICBjYXRjaChlcnIgPT4ge1xuICAgICAgICBkZWxldGUgc2Vzc2lvbltzZXNzaW9uTmV3RG9jdW1lbnRzXTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfSkuXG4gICAgICBmaW5hbGx5KCgpID0+IHtcbiAgICAgICAgc2Vzc2lvbi5lbmRTZXNzaW9uKCkuY2F0Y2goKCkgPT4ge30pO1xuICAgICAgfSk7XG4gIH0pO1xufTtcblxuLyohXG4gKiBSZXNldCBkb2N1bWVudCBzdGF0ZSBpbiBiZXR3ZWVuIHRyYW5zYWN0aW9uIHJldHJpZXMgcmU6IGdoLTEzNjk4XG4gKi9cblxuYXN5bmMgZnVuY3Rpb24gX3dyYXBVc2VyVHJhbnNhY3Rpb24oZm4sIHNlc3Npb24pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmbihzZXNzaW9uKTtcbiAgICByZXR1cm4gcmVzO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfcmVzZXRTZXNzaW9uRG9jdW1lbnRzKHNlc3Npb24pO1xuICAgIHRocm93IGVycjtcbiAgfVxufVxuXG4vKiFcbiAqIElmIHRyYW5zYWN0aW9uIHdhcyBhYm9ydGVkLCB3ZSBuZWVkIHRvIHJlc2V0IG5ld2x5IGluc2VydGVkIGRvY3VtZW50cycgYGlzTmV3YC5cbiAqL1xuZnVuY3Rpb24gX3Jlc2V0U2Vzc2lvbkRvY3VtZW50cyhzZXNzaW9uKSB7XG4gIGZvciAoY29uc3QgZG9jIG9mIHNlc3Npb25bc2Vzc2lvbk5ld0RvY3VtZW50c10ua2V5cygpKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBzZXNzaW9uW3Nlc3Npb25OZXdEb2N1bWVudHNdLmdldChkb2MpO1xuICAgIGlmIChzdGF0ZS5oYXNPd25Qcm9wZXJ0eSgnaXNOZXcnKSkge1xuICAgICAgZG9jLiRpc05ldyA9IHN0YXRlLmlzTmV3O1xuICAgIH1cbiAgICBpZiAoc3RhdGUuaGFzT3duUHJvcGVydHkoJ3ZlcnNpb25LZXknKSkge1xuICAgICAgZG9jLnNldChkb2Muc2NoZW1hLm9wdGlvbnMudmVyc2lvbktleSwgc3RhdGUudmVyc2lvbktleSk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLm1vZGlmaWVkUGF0aHMubGVuZ3RoID4gMCAmJiBkb2MuJF9fLmFjdGl2ZVBhdGhzLnN0YXRlcy5tb2RpZnkgPT0gbnVsbCkge1xuICAgICAgZG9jLiRfXy5hY3RpdmVQYXRocy5zdGF0ZXMubW9kaWZ5ID0ge307XG4gICAgfVxuICAgIGZvciAoY29uc3QgcGF0aCBvZiBzdGF0ZS5tb2RpZmllZFBhdGhzKSB7XG4gICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBkb2MuJF9fLmFjdGl2ZVBhdGhzLnBhdGhzW3BhdGhdO1xuICAgICAgaWYgKGN1cnJlbnRTdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZSBkb2MuJF9fLmFjdGl2ZVBhdGhzW2N1cnJlbnRTdGF0ZV1bcGF0aF07XG4gICAgICB9XG4gICAgICBkb2MuJF9fLmFjdGl2ZVBhdGhzLnBhdGhzW3BhdGhdID0gJ21vZGlmeSc7XG4gICAgICBkb2MuJF9fLmFjdGl2ZVBhdGhzLnN0YXRlcy5tb2RpZnlbcGF0aF0gPSB0cnVlO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgcGF0aCBvZiBzdGF0ZS5hdG9taWNzLmtleXMoKSkge1xuICAgICAgY29uc3QgdmFsID0gZG9jLiRfX2dldFZhbHVlKHBhdGgpO1xuICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFsW2FycmF5QXRvbWljc1N5bWJvbF0gPSBzdGF0ZS5hdG9taWNzLmdldChwYXRoKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgZm9yIGBkcm9wQ29sbGVjdGlvbigpYC4gV2lsbCBkZWxldGUgdGhlIGdpdmVuIGNvbGxlY3Rpb24sIGluY2x1ZGluZ1xuICogYWxsIGRvY3VtZW50cyBhbmQgaW5kZXhlcy5cbiAqXG4gKiBAbWV0aG9kIGRyb3BDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBkZWxldGVcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmRyb3BDb2xsZWN0aW9uID0gYXN5bmMgZnVuY3Rpb24gZHJvcENvbGxlY3Rpb24oY29sbGVjdGlvbikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAyICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignQ29ubmVjdGlvbi5wcm90b3R5cGUuZHJvcENvbGxlY3Rpb24oKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBpZiAoKHRoaXMucmVhZHlTdGF0ZSA9PT0gU1RBVEVTLmNvbm5lY3RpbmcgfHwgdGhpcy5yZWFkeVN0YXRlID09PSBTVEFURVMuZGlzY29ubmVjdGVkKSAmJiB0aGlzLl9zaG91bGRCdWZmZXJDb21tYW5kcygpKSB7XG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLl9xdWV1ZS5wdXNoKHsgZm46IHJlc29sdmUgfSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5kYi5kcm9wQ29sbGVjdGlvbihjb2xsZWN0aW9uKTtcbn07XG5cbi8qKlxuICogSGVscGVyIGZvciBNb25nb0RCIE5vZGUgZHJpdmVyJ3MgYGxpc3RDb2xsZWN0aW9ucygpYC5cbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgY29sbGVjdGlvbiBvYmplY3RzLlxuICpcbiAqIEBtZXRob2QgbGlzdENvbGxlY3Rpb25zXG4gKiBAcmV0dXJuIHtQcm9taXNlPENvbGxlY3Rpb25bXT59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmxpc3RDb2xsZWN0aW9ucyA9IGFzeW5jIGZ1bmN0aW9uIGxpc3RDb2xsZWN0aW9ucygpIHtcbiAgaWYgKCh0aGlzLnJlYWR5U3RhdGUgPT09IFNUQVRFUy5jb25uZWN0aW5nIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gU1RBVEVTLmRpc2Nvbm5lY3RlZCkgJiYgdGhpcy5fc2hvdWxkQnVmZmVyQ29tbWFuZHMoKSkge1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgdGhpcy5fcXVldWUucHVzaCh7IGZuOiByZXNvbHZlIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgY29uc3QgY3Vyc29yID0gdGhpcy5kYi5saXN0Q29sbGVjdGlvbnMoKTtcbiAgcmV0dXJuIGF3YWl0IGN1cnNvci50b0FycmF5KCk7XG59O1xuXG4vKipcbiAqIEhlbHBlciBmb3IgYGRyb3BEYXRhYmFzZSgpYC4gRGVsZXRlcyB0aGUgZ2l2ZW4gZGF0YWJhc2UsIGluY2x1ZGluZyBhbGxcbiAqIGNvbGxlY3Rpb25zLCBkb2N1bWVudHMsIGFuZCBpbmRleGVzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgY29ubiA9IG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oJ21vbmdvZGI6Ly8xMjcuMC4wLjE6MjcwMTcvbXlkYicpO1xuICogICAgIC8vIERlbGV0ZXMgdGhlIGVudGlyZSAnbXlkYicgZGF0YWJhc2VcbiAqICAgICBhd2FpdCBjb25uLmRyb3BEYXRhYmFzZSgpO1xuICpcbiAqIEBtZXRob2QgZHJvcERhdGFiYXNlXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5kcm9wRGF0YWJhc2UgPSBhc3luYyBmdW5jdGlvbiBkcm9wRGF0YWJhc2UoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDEgJiYgdHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdDb25uZWN0aW9uLnByb3RvdHlwZS5kcm9wRGF0YWJhc2UoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBpZiAoKHRoaXMucmVhZHlTdGF0ZSA9PT0gU1RBVEVTLmNvbm5lY3RpbmcgfHwgdGhpcy5yZWFkeVN0YXRlID09PSBTVEFURVMuZGlzY29ubmVjdGVkKSAmJiB0aGlzLl9zaG91bGRCdWZmZXJDb21tYW5kcygpKSB7XG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLl9xdWV1ZS5wdXNoKHsgZm46IHJlc29sdmUgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBJZiBgZHJvcERhdGFiYXNlKClgIGlzIGNhbGxlZCwgdGhpcyBtb2RlbCdzIGNvbGxlY3Rpb24gd2lsbCBub3QgYmVcbiAgLy8gaW5pdC1lZC4gSXQgaXMgc3VmZmljaWVudGx5IGNvbW1vbiB0byBjYWxsIGBkcm9wRGF0YWJhc2UoKWAgYWZ0ZXJcbiAgLy8gYG1vbmdvb3NlLmNvbm5lY3QoKWAgYnV0IGJlZm9yZSBjcmVhdGluZyBtb2RlbHMgdGhhdCB3ZSB3YW50IHRvXG4gIC8vIHN1cHBvcnQgdGhpcy4gU2VlIGdoLTY3OTZcbiAgZm9yIChjb25zdCBtb2RlbCBvZiBPYmplY3QudmFsdWVzKHRoaXMubW9kZWxzKSkge1xuICAgIGRlbGV0ZSBtb2RlbC4kaW5pdDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmRiLmRyb3BEYXRhYmFzZSgpO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5fc2hvdWxkQnVmZmVyQ29tbWFuZHMgPSBmdW5jdGlvbiBfc2hvdWxkQnVmZmVyQ29tbWFuZHMoKSB7XG4gIGlmICh0aGlzLmNvbmZpZy5idWZmZXJDb21tYW5kcyAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmJ1ZmZlckNvbW1hbmRzO1xuICB9XG4gIGlmICh0aGlzLmJhc2UuZ2V0KCdidWZmZXJDb21tYW5kcycpICE9IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlLmdldCgnYnVmZmVyQ29tbWFuZHMnKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogZXJyb3JcbiAqXG4gKiBHcmFjZWZ1bCBlcnJvciBoYW5kbGluZywgcGFzc2VzIGVycm9yIHRvIGNhbGxiYWNrXG4gKiBpZiBhdmFpbGFibGUsIGVsc2UgZW1pdHMgZXJyb3Igb24gdGhlIGNvbm5lY3Rpb24uXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBvcHRpb25hbFxuICogQGVtaXRzIFwiZXJyb3JcIiBFbWl0cyB0aGUgYGVycm9yYCBldmVudCB3aXRoIHRoZSBnaXZlbiBgZXJyYCwgdW5sZXNzIGEgY2FsbGJhY2sgaXMgc3BlY2lmaWVkXG4gKiBAcmV0dXJucyB7UHJvbWlzZXxudWxsfSBSZXR1cm5zIGEgcmVqZWN0ZWQgUHJvbWlzZSBpZiBubyBgY2FsbGJhY2tgIGlzIGdpdmVuLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbihlcnIsIGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKGVycik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHRoaXMubGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aCA+IDApIHtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfVxuICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gdGhlIGNvbm5lY3Rpb24gaXMgb3BlbmVkXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUub25PcGVuID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmVhZHlTdGF0ZSA9IFNUQVRFUy5jb25uZWN0ZWQ7XG5cbiAgZm9yIChjb25zdCBkIG9mIHRoaXMuX3F1ZXVlKSB7XG4gICAgZC5mbi5hcHBseShkLmN0eCwgZC5hcmdzKTtcbiAgfVxuICB0aGlzLl9xdWV1ZSA9IFtdO1xuXG4gIC8vIGF2b2lkIGhhdmluZyB0aGUgY29sbGVjdGlvbiBzdWJzY3JpYmUgdG8gb3VyIGV2ZW50IGVtaXR0ZXJcbiAgLy8gdG8gcHJldmVudCAwLjMgd2FybmluZ1xuICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5jb2xsZWN0aW9ucykge1xuICAgIGlmICh1dGlscy5vYmplY3QuaGFzT3duUHJvcGVydHkodGhpcy5jb2xsZWN0aW9ucywgaSkpIHtcbiAgICAgIHRoaXMuY29sbGVjdGlvbnNbaV0ub25PcGVuKCk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5lbWl0KCdvcGVuJyk7XG59O1xuXG4vKipcbiAqIE9wZW5zIHRoZSBjb25uZWN0aW9uIHdpdGggYSBVUkkgdXNpbmcgYE1vbmdvQ2xpZW50LmNvbm5lY3QoKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVyaSBUaGUgVVJJIHRvIGNvbm5lY3Qgd2l0aC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gUGFzc2VkIG9uIHRvIFtgTW9uZ29DbGllbnQuY29ubmVjdGBdKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9Nb25nb0NsaWVudC5odG1sI2Nvbm5lY3QtMSlcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYnVmZmVyQ29tbWFuZHM9dHJ1ZV0gTW9uZ29vc2Ugc3BlY2lmaWMgb3B0aW9uLiBTZXQgdG8gZmFsc2UgdG8gW2Rpc2FibGUgYnVmZmVyaW5nXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZmFxLmh0bWwjY2FsbGJhY2tfbmV2ZXJfZXhlY3V0ZXMpIG9uIGFsbCBtb2RlbHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29ubmVjdGlvbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5idWZmZXJUaW1lb3V0TVM9MTAwMDBdIE1vbmdvb3NlIHNwZWNpZmljIG9wdGlvbi4gSWYgYGJ1ZmZlckNvbW1hbmRzYCBpcyB0cnVlLCBNb25nb29zZSB3aWxsIHRocm93IGFuIGVycm9yIGFmdGVyIGBidWZmZXJUaW1lb3V0TVNgIGlmIHRoZSBvcGVyYXRpb24gaXMgc3RpbGwgYnVmZmVyZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZGJOYW1lXSBUaGUgbmFtZSBvZiB0aGUgZGF0YWJhc2Ugd2Ugd2FudCB0byB1c2UuIElmIG5vdCBwcm92aWRlZCwgdXNlIGRhdGFiYXNlIG5hbWUgZnJvbSBjb25uZWN0aW9uIHN0cmluZy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy51c2VyXSB1c2VybmFtZSBmb3IgYXV0aGVudGljYXRpb24sIGVxdWl2YWxlbnQgdG8gYG9wdGlvbnMuYXV0aC51c2VyYC4gTWFpbnRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGFzc10gcGFzc3dvcmQgZm9yIGF1dGhlbnRpY2F0aW9uLCBlcXVpdmFsZW50IHRvIGBvcHRpb25zLmF1dGgucGFzc3dvcmRgLiBNYWludGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhQb29sU2l6ZT0xMDBdIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzb2NrZXRzIHRoZSBNb25nb0RCIGRyaXZlciB3aWxsIGtlZXAgb3BlbiBmb3IgdGhpcyBjb25uZWN0aW9uLiBLZWVwIGluIG1pbmQgdGhhdCBNb25nb0RCIG9ubHkgYWxsb3dzIG9uZSBvcGVyYXRpb24gcGVyIHNvY2tldCBhdCBhIHRpbWUsIHNvIHlvdSBtYXkgd2FudCB0byBpbmNyZWFzZSB0aGlzIGlmIHlvdSBmaW5kIHlvdSBoYXZlIGEgZmV3IHNsb3cgcXVlcmllcyB0aGF0IGFyZSBibG9ja2luZyBmYXN0ZXIgcXVlcmllcyBmcm9tIHByb2NlZWRpbmcuIFNlZSBbU2xvdyBUcmFpbnMgaW4gTW9uZ29EQiBhbmQgTm9kZS5qc10oaHR0cHM6Ly90aGVjb2RlYmFyYmFyaWFuLmNvbS9zbG93LXRyYWlucy1pbi1tb25nb2RiLWFuZC1ub2RlanMpLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1pblBvb2xTaXplPTBdIFRoZSBtaW5pbXVtIG51bWJlciBvZiBzb2NrZXRzIHRoZSBNb25nb0RCIGRyaXZlciB3aWxsIGtlZXAgb3BlbiBmb3IgdGhpcyBjb25uZWN0aW9uLiBLZWVwIGluIG1pbmQgdGhhdCBNb25nb0RCIG9ubHkgYWxsb3dzIG9uZSBvcGVyYXRpb24gcGVyIHNvY2tldCBhdCBhIHRpbWUsIHNvIHlvdSBtYXkgd2FudCB0byBpbmNyZWFzZSB0aGlzIGlmIHlvdSBmaW5kIHlvdSBoYXZlIGEgZmV3IHNsb3cgcXVlcmllcyB0aGF0IGFyZSBibG9ja2luZyBmYXN0ZXIgcXVlcmllcyBmcm9tIHByb2NlZWRpbmcuIFNlZSBbU2xvdyBUcmFpbnMgaW4gTW9uZ29EQiBhbmQgTm9kZS5qc10oaHR0cHM6Ly90aGVjb2RlYmFyYmFyaWFuLmNvbS9zbG93LXRyYWlucy1pbi1tb25nb2RiLWFuZC1ub2RlanMpLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNlcnZlclNlbGVjdGlvblRpbWVvdXRNU10gSWYgYHVzZVVuaWZpZWRUb3BvbG9neSA9IHRydWVgLCB0aGUgTW9uZ29EQiBkcml2ZXIgd2lsbCB0cnkgdG8gZmluZCBhIHNlcnZlciB0byBzZW5kIGFueSBnaXZlbiBvcGVyYXRpb24gdG8sIGFuZCBrZWVwIHJldHJ5aW5nIGZvciBgc2VydmVyU2VsZWN0aW9uVGltZW91dE1TYCBtaWxsaXNlY29uZHMgYmVmb3JlIGVycm9yaW5nIG91dC4gSWYgbm90IHNldCwgdGhlIE1vbmdvREIgZHJpdmVyIGRlZmF1bHRzIHRvIHVzaW5nIGAzMDAwMGAgKDMwIHNlY29uZHMpLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlYXJ0YmVhdEZyZXF1ZW5jeU1TXSBJZiBgdXNlVW5pZmllZFRvcG9sb2d5ID0gdHJ1ZWAsIHRoZSBNb25nb0RCIGRyaXZlciBzZW5kcyBhIGhlYXJ0YmVhdCBldmVyeSBgaGVhcnRiZWF0RnJlcXVlbmN5TVNgIHRvIGNoZWNrIG9uIHRoZSBzdGF0dXMgb2YgdGhlIGNvbm5lY3Rpb24uIEEgaGVhcnRiZWF0IGlzIHN1YmplY3QgdG8gYHNlcnZlclNlbGVjdGlvblRpbWVvdXRNU2AsIHNvIHRoZSBNb25nb0RCIGRyaXZlciB3aWxsIHJldHJ5IGZhaWxlZCBoZWFydGJlYXRzIGZvciB1cCB0byAzMCBzZWNvbmRzIGJ5IGRlZmF1bHQuIE1vbmdvb3NlIG9ubHkgZW1pdHMgYSBgJ2Rpc2Nvbm5lY3RlZCdgIGV2ZW50IGFmdGVyIGEgaGVhcnRiZWF0IGhhcyBmYWlsZWQsIHNvIHlvdSBtYXkgd2FudCB0byBkZWNyZWFzZSB0aGlzIHNldHRpbmcgdG8gcmVkdWNlIHRoZSB0aW1lIGJldHdlZW4gd2hlbiB5b3VyIHNlcnZlciBnb2VzIGRvd24gYW5kIHdoZW4gTW9uZ29vc2UgZW1pdHMgYCdkaXNjb25uZWN0ZWQnYC4gV2UgcmVjb21tZW5kIHlvdSBkbyAqKm5vdCoqIHNldCB0aGlzIHNldHRpbmcgYmVsb3cgMTAwMCwgdG9vIG1hbnkgaGVhcnRiZWF0cyBjYW4gbGVhZCB0byBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvbi5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYXV0b0luZGV4PXRydWVdIE1vbmdvb3NlLXNwZWNpZmljIG9wdGlvbi4gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgYXV0b21hdGljIGluZGV4IGNyZWF0aW9uIGZvciBhbGwgbW9kZWxzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbm5lY3Rpb24uXG4gKiBAcGFyYW0ge0NsYXNzfSBbb3B0aW9ucy5wcm9taXNlTGlicmFyeV0gU2V0cyB0aGUgW3VuZGVybHlpbmcgZHJpdmVyJ3MgcHJvbWlzZSBsaWJyYXJ5XShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvTW9uZ29DbGllbnRPcHRpb25zLmh0bWwjcHJvbWlzZUxpYnJhcnkpLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNvY2tldFRpbWVvdXRNUz0wXSBIb3cgbG9uZyB0aGUgTW9uZ29EQiBkcml2ZXIgd2lsbCB3YWl0IGJlZm9yZSBraWxsaW5nIGEgc29ja2V0IGR1ZSB0byBpbmFjdGl2aXR5IF9hZnRlciBpbml0aWFsIGNvbm5lY3Rpb25fLiBBIHNvY2tldCBtYXkgYmUgaW5hY3RpdmUgYmVjYXVzZSBvZiBlaXRoZXIgbm8gYWN0aXZpdHkgb3IgYSBsb25nLXJ1bm5pbmcgb3BlcmF0aW9uLiBgc29ja2V0VGltZW91dE1TYCBkZWZhdWx0cyB0byAwLCB3aGljaCBtZWFucyBOb2RlLmpzIHdpbGwgbm90IHRpbWUgb3V0IHRoZSBzb2NrZXQgZHVlIHRvIGluYWN0aXZpdHkuIFRoaXMgb3B0aW9uIGlzIHBhc3NlZCB0byBbTm9kZS5qcyBgc29ja2V0I3NldFRpbWVvdXQoKWAgZnVuY3Rpb25dKGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvbmV0Lmh0bWwjbmV0X3NvY2tldF9zZXR0aW1lb3V0X3RpbWVvdXRfY2FsbGJhY2spIGFmdGVyIHRoZSBNb25nb0RCIGRyaXZlciBzdWNjZXNzZnVsbHkgY29tcGxldGVzLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZhbWlseT0wXSBQYXNzZWQgdHJhbnNwYXJlbnRseSB0byBbTm9kZS5qcycgYGRucy5sb29rdXAoKWBdKGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZG5zLmh0bWwjZG5zX2Ruc19sb29rdXBfaG9zdG5hbWVfb3B0aW9uc19jYWxsYmFjaykgZnVuY3Rpb24uIE1heSBiZSBlaXRoZXIgYDAsIGA0YCwgb3IgYDZgLiBgNGAgbWVhbnMgdXNlIElQdjQgb25seSwgYDZgIG1lYW5zIHVzZSBJUHY2IG9ubHksIGAwYCBtZWFucyB0cnkgYm90aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYXV0b0NyZWF0ZT1mYWxzZV0gU2V0IHRvIGB0cnVlYCB0byBtYWtlIE1vbmdvb3NlIGF1dG9tYXRpY2FsbHkgY2FsbCBgY3JlYXRlQ29sbGVjdGlvbigpYCBvbiBldmVyeSBtb2RlbCBjcmVhdGVkIG9uIHRoaXMgY29ubmVjdGlvbi5cbiAqIEByZXR1cm5zIHtQcm9taXNlPENvbm5lY3Rpb24+fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5vcGVuVXJpID0gYXN5bmMgZnVuY3Rpb24gb3BlblVyaSh1cmksIG9wdGlvbnMpIHtcbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU1RBVEVTLmNvbm5lY3RpbmcgfHwgdGhpcy5yZWFkeVN0YXRlID09PSBTVEFURVMuY29ubmVjdGVkKSB7XG4gICAgaWYgKHRoaXMuX2Nvbm5lY3Rpb25TdHJpbmcgPT09IHVyaSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fY2xvc2VDYWxsZWQgPSBmYWxzZTtcblxuICAvLyBJbnRlcm5hbCBvcHRpb24gdG8gc2tpcCBgYXdhaXQgdGhpcy4kaW5pdGlhbENvbm5lY3Rpb25gIGluXG4gIC8vIHRoaXMgZnVuY3Rpb24gZm9yIGBjcmVhdGVDb25uZWN0aW9uKClgLiBCZWNhdXNlIG90aGVyd2lzZVxuICAvLyBgY3JlYXRlQ29ubmVjdGlvbigpYCB3b3VsZCBoYXZlIGFuIHVuY2F0Y2hhYmxlIGVycm9yLlxuICBsZXQgX2ZpcmVBbmRGb3JnZXQgPSBmYWxzZTtcbiAgaWYgKG9wdGlvbnMgJiYgJ19maXJlQW5kRm9yZ2V0JyBpbiBvcHRpb25zKSB7XG4gICAgX2ZpcmVBbmRGb3JnZXQgPSBvcHRpb25zLl9maXJlQW5kRm9yZ2V0O1xuICAgIGRlbGV0ZSBvcHRpb25zLl9maXJlQW5kRm9yZ2V0O1xuICB9XG5cbiAgdHJ5IHtcbiAgICBfdmFsaWRhdGVBcmdzLmFwcGx5KGFyZ3VtZW50cyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChfZmlyZUFuZEZvcmdldCkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICB0aGlzLiRpbml0aWFsQ29ubmVjdGlvbiA9IFByb21pc2UucmVqZWN0KGVycik7XG4gICAgdGhyb3cgZXJyO1xuICB9XG5cbiAgdGhpcy4kaW5pdGlhbENvbm5lY3Rpb24gPSB0aGlzLmNyZWF0ZUNsaWVudCh1cmksIG9wdGlvbnMpLlxuICAgIHRoZW4oKCkgPT4gdGhpcykuXG4gICAgY2F0Y2goZXJyID0+IHtcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNUQVRFUy5kaXNjb25uZWN0ZWQ7XG4gICAgICBpZiAodGhpcy5saXN0ZW5lcnMoJ2Vycm9yJykubGVuZ3RoID4gMCkge1xuICAgICAgICBpbW1lZGlhdGUoKCkgPT4gdGhpcy5lbWl0KCdlcnJvcicsIGVycikpO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xuXG4gIGZvciAoY29uc3QgbW9kZWwgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLm1vZGVscykpIHtcbiAgICAvLyBFcnJvcnMgaGFuZGxlZCBpbnRlcm5hbGx5LCBzbyBzYWZlIHRvIGlnbm9yZSBlcnJvclxuICAgIG1vZGVsLmluaXQoKS5jYXRjaChmdW5jdGlvbiAkbW9kZWxJbml0Tm9vcCgpIHt9KTtcbiAgfVxuXG4gIC8vIGBjcmVhdGVDb25uZWN0aW9uKClgIGNhbGxzIHRoaXMgYG9wZW5VcmkoKWAgZnVuY3Rpb24gd2l0aG91dFxuICAvLyBhd2FpdGluZyBvbiB0aGUgcmVzdWx0LCBzbyB3ZSBzZXQgdGhpcyBvcHRpb24gdG8gcmVseSBvblxuICAvLyBgYXNQcm9taXNlKClgIHRvIGhhbmRsZSBhbnkgZXJyb3JzLlxuICBpZiAoX2ZpcmVBbmRGb3JnZXQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRyeSB7XG4gICAgYXdhaXQgdGhpcy4kaW5pdGlhbENvbm5lY3Rpb247XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IF9oYW5kbGVDb25uZWN0aW9uRXJyb3JzKGVycik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qIVxuICogVHJlYXQgYG9uKCdlcnJvcicpYCBoYW5kbGVycyBhcyBoYW5kbGluZyB0aGUgaW5pdGlhbENvbm5lY3Rpb24gcHJvbWlzZVxuICogdG8gYXZvaWQgdW5jYXVnaHQgZXhjZXB0aW9ucyB3aGVuIHVzaW5nIGBvbignZXJyb3InKWAuIFNlZSBnaC0xNDM3Ny5cbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBjYWxsYmFjaykge1xuICBpZiAoZXZlbnQgPT09ICdlcnJvcicgJiYgdGhpcy4kaW5pdGlhbENvbm5lY3Rpb24pIHtcbiAgICB0aGlzLiRpbml0aWFsQ29ubmVjdGlvbi5jYXRjaCgoKSA9PiB7fSk7XG4gIH1cbiAgcmV0dXJuIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldmVudCwgY2FsbGJhY2spO1xufTtcblxuLyohXG4gKiBUcmVhdCBgb25jZSgnZXJyb3InKWAgaGFuZGxlcnMgYXMgaGFuZGxpbmcgdGhlIGluaXRpYWxDb25uZWN0aW9uIHByb21pc2VcbiAqIHRvIGF2b2lkIHVuY2F1Z2h0IGV4Y2VwdGlvbnMgd2hlbiB1c2luZyBgb24oJ2Vycm9yJylgLiBTZWUgZ2gtMTQzNzcuXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBjYWxsYmFjaykge1xuICBpZiAoZXZlbnQgPT09ICdlcnJvcicgJiYgdGhpcy4kaW5pdGlhbENvbm5lY3Rpb24pIHtcbiAgICB0aGlzLiRpbml0aWFsQ29ubmVjdGlvbi5jYXRjaCgoKSA9PiB7fSk7XG4gIH1cbiAgcmV0dXJuIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZS5jYWxsKHRoaXMsIGV2ZW50LCBjYWxsYmFjayk7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF92YWxpZGF0ZUFyZ3ModXJpLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgJiYgY2FsbGJhY2sgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdDb25uZWN0aW9uLnByb3RvdHlwZS5vcGVuVXJpKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdDb25uZWN0aW9uLnByb3RvdHlwZS5vcGVuVXJpKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2hhbmRsZUNvbm5lY3Rpb25FcnJvcnMoZXJyKSB7XG4gIGlmIChlcnI/Lm5hbWUgPT09ICdNb25nb1NlcnZlclNlbGVjdGlvbkVycm9yJykge1xuICAgIGNvbnN0IG9yaWdpbmFsRXJyb3IgPSBlcnI7XG4gICAgZXJyID0gbmV3IFNlcnZlclNlbGVjdGlvbkVycm9yKCk7XG4gICAgZXJyLmFzc2ltaWxhdGVFcnJvcihvcmlnaW5hbEVycm9yKTtcbiAgfVxuXG4gIHJldHVybiBlcnI7XG59XG5cbi8qKlxuICogRGVzdHJveSB0aGUgY29ubmVjdGlvbi4gU2ltaWxhciB0byBbYC5jbG9zZWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvY29ubmVjdGlvbi5odG1sI0Nvbm5lY3Rpb24ucHJvdG90eXBlLmNsb3NlKCkpLFxuICogYnV0IGFsc28gcmVtb3ZlcyB0aGUgY29ubmVjdGlvbiBmcm9tIE1vbmdvb3NlJ3MgYGNvbm5lY3Rpb25zYCBsaXN0IGFuZCBwcmV2ZW50cyB0aGVcbiAqIGNvbm5lY3Rpb24gZnJvbSBldmVyIGJlaW5nIHJlLW9wZW5lZC5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZV1cbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmRlc3Ryb3kgPSBhc3luYyBmdW5jdGlvbiBkZXN0cm95KGZvcmNlKSB7XG4gIGlmICh0eXBlb2YgZm9yY2UgPT09ICdmdW5jdGlvbicgfHwgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignQ29ubmVjdGlvbi5wcm90b3R5cGUuZGVzdHJveSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGlmIChmb3JjZSAhPSBudWxsICYmIHR5cGVvZiBmb3JjZSA9PT0gJ29iamVjdCcpIHtcbiAgICB0aGlzLiR3YXNGb3JjZUNsb3NlZCA9ICEhZm9yY2UuZm9yY2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy4kd2FzRm9yY2VDbG9zZWQgPSAhIWZvcmNlO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2Nsb3NlKGZvcmNlLCB0cnVlKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VdIG9wdGlvbmFsXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5jbG9zZSA9IGFzeW5jIGZ1bmN0aW9uIGNsb3NlKGZvcmNlKSB7XG4gIGlmICh0eXBlb2YgZm9yY2UgPT09ICdmdW5jdGlvbicgfHwgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignQ29ubmVjdGlvbi5wcm90b3R5cGUuY2xvc2UoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBpZiAoZm9yY2UgIT0gbnVsbCAmJiB0eXBlb2YgZm9yY2UgPT09ICdvYmplY3QnKSB7XG4gICAgdGhpcy4kd2FzRm9yY2VDbG9zZWQgPSAhIWZvcmNlLmZvcmNlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuJHdhc0ZvcmNlQ2xvc2VkID0gISFmb3JjZTtcbiAgfVxuXG4gIGZvciAoY29uc3QgbW9kZWwgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLm1vZGVscykpIHtcbiAgICAvLyBJZiBtYW51YWxseSBkaXNjb25uZWN0aW5nLCBtYWtlIHN1cmUgdG8gY2xlYXIgZWFjaCBtb2RlbCdzIGAkaW5pdGBcbiAgICAvLyBwcm9taXNlLCBzbyBNb25nb29zZSBrbm93cyB0byByZS1ydW4gYGluaXQoKWAgaW4gY2FzZSB0aGVcbiAgICAvLyBjb25uZWN0aW9uIGlzIHJlLW9wZW5lZC4gU2VlIGdoLTEyMDQ3LlxuICAgIGRlbGV0ZSBtb2RlbC4kaW5pdDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9jbG9zZShmb3JjZSwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBIYW5kbGVzIGNsb3NpbmcgdGhlIGNvbm5lY3Rpb25cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRlc3Ryb3lcbiAqIEByZXR1cm5zIHtDb25uZWN0aW9ufSB0aGlzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUuX2Nsb3NlID0gYXN5bmMgZnVuY3Rpb24gX2Nsb3NlKGZvcmNlLCBkZXN0cm95KSB7XG4gIGNvbnN0IF90aGlzID0gdGhpcztcbiAgY29uc3QgY2xvc2VDYWxsZWQgPSB0aGlzLl9jbG9zZUNhbGxlZDtcbiAgdGhpcy5fY2xvc2VDYWxsZWQgPSB0cnVlO1xuICB0aGlzLl9kZXN0cm95Q2FsbGVkID0gZGVzdHJveTtcbiAgaWYgKHRoaXMuY2xpZW50ICE9IG51bGwpIHtcbiAgICB0aGlzLmNsaWVudC5fY2xvc2VDYWxsZWQgPSB0cnVlO1xuICAgIHRoaXMuY2xpZW50Ll9kZXN0cm95Q2FsbGVkID0gZGVzdHJveTtcbiAgfVxuXG4gIGNvbnN0IGNvbm4gPSB0aGlzO1xuICBzd2l0Y2ggKHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGNhc2UgU1RBVEVTLmRpc2Nvbm5lY3RlZDpcbiAgICAgIGlmIChkZXN0cm95ICYmIHRoaXMuYmFzZS5jb25uZWN0aW9ucy5pbmRleE9mKGNvbm4pICE9PSAtMSkge1xuICAgICAgICB0aGlzLmJhc2UuY29ubmVjdGlvbnMuc3BsaWNlKHRoaXMuYmFzZS5jb25uZWN0aW9ucy5pbmRleE9mKGNvbm4pLCAxKTtcbiAgICAgIH1cbiAgICAgIGlmICghY2xvc2VDYWxsZWQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5kb0Nsb3NlKGZvcmNlKTtcbiAgICAgICAgdGhpcy5vbkNsb3NlKGZvcmNlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBTVEFURVMuY29ubmVjdGVkOlxuICAgICAgdGhpcy5yZWFkeVN0YXRlID0gU1RBVEVTLmRpc2Nvbm5lY3Rpbmc7XG4gICAgICBhd2FpdCB0aGlzLmRvQ2xvc2UoZm9yY2UpO1xuICAgICAgaWYgKGRlc3Ryb3kgJiYgX3RoaXMuYmFzZS5jb25uZWN0aW9ucy5pbmRleE9mKGNvbm4pICE9PSAtMSkge1xuICAgICAgICB0aGlzLmJhc2UuY29ubmVjdGlvbnMuc3BsaWNlKHRoaXMuYmFzZS5jb25uZWN0aW9ucy5pbmRleE9mKGNvbm4pLCAxKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub25DbG9zZShmb3JjZSk7XG5cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU1RBVEVTLmNvbm5lY3Rpbmc6XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBfcmVydW5DbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdvcGVuJywgX3JlcnVuQ2xvc2UpO1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgX3JlcnVuQ2xvc2UpO1xuICAgICAgICAgIGlmIChkZXN0cm95KSB7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3koZm9yY2UpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbG9zZShmb3JjZSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLm9uY2UoJ29wZW4nLCBfcmVydW5DbG9zZSk7XG4gICAgICAgIHRoaXMub25jZSgnZXJyb3InLCBfcmVydW5DbG9zZSk7XG4gICAgICB9KTtcblxuICAgIGNhc2UgU1RBVEVTLmRpc2Nvbm5lY3Rpbmc6XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHRoaXMub25jZSgnY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgaWYgKGRlc3Ryb3kgJiYgdGhpcy5iYXNlLmNvbm5lY3Rpb25zLmluZGV4T2YoY29ubikgIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UuY29ubmVjdGlvbnMuc3BsaWNlKHRoaXMuYmFzZS5jb25uZWN0aW9ucy5pbmRleE9mKGNvbm4pLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFic3RyYWN0IG1ldGhvZCB0aGF0IGRyaXZlcnMgbXVzdCBpbXBsZW1lbnQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24jZG9DbG9zZSB1bmltcGxlbWVudGVkIGJ5IGRyaXZlcicpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiB0aGUgY29ubmVjdGlvbiBjbG9zZXNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24oZm9yY2UpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gU1RBVEVTLmRpc2Nvbm5lY3RlZDtcblxuICAvLyBhdm9pZCBoYXZpbmcgdGhlIGNvbGxlY3Rpb24gc3Vic2NyaWJlIHRvIG91ciBldmVudCBlbWl0dGVyXG4gIC8vIHRvIHByZXZlbnQgMC4zIHdhcm5pbmdcbiAgZm9yIChjb25zdCBpIGluIHRoaXMuY29sbGVjdGlvbnMpIHtcbiAgICBpZiAodXRpbHMub2JqZWN0Lmhhc093blByb3BlcnR5KHRoaXMuY29sbGVjdGlvbnMsIGkpKSB7XG4gICAgICB0aGlzLmNvbGxlY3Rpb25zW2ldLm9uQ2xvc2UoZm9yY2UpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuZW1pdCgnY2xvc2UnLCBmb3JjZSk7XG5cbiAgZm9yIChjb25zdCBkYiBvZiB0aGlzLm90aGVyRGJzKSB7XG4gICAgdGhpcy5fZGVzdHJveUNhbGxlZCA/IGRiLmRlc3Ryb3koeyBmb3JjZTogZm9yY2UsIHNraXBDbG9zZUNsaWVudDogdHJ1ZSB9KSA6IGRiLmNsb3NlKHsgZm9yY2U6IGZvcmNlLCBza2lwQ2xvc2VDbGllbnQ6IHRydWUgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0cmlldmVzIGEgcmF3IGNvbGxlY3Rpb24gaW5zdGFuY2UsIGNyZWF0aW5nIGl0IGlmIG5vdCBjYWNoZWQuXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgdGhpbiB3cmFwcGVyIGFyb3VuZCBhIFtNb25nb0RCIE5vZGUuanMgZHJpdmVyIGNvbGxlY3Rpb25dKFtNb25nb0RCIE5vZGUuanMgZHJpdmVyIGNvbGxlY3Rpb25dKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS9OZXh0L2NsYXNzZXMvQ29sbGVjdGlvbi5odG1sKSkuXG4gKiBVc2luZyBhIENvbGxlY3Rpb24gYnlwYXNzZXMgTW9uZ29vc2UgbWlkZGxld2FyZSwgdmFsaWRhdGlvbiwgYW5kIGNhc3RpbmcsXG4gKiBsZXR0aW5nIHlvdSB1c2UgW01vbmdvREIgTm9kZS5qcyBkcml2ZXJdKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS8pIGZ1bmN0aW9uYWxpdHkgZGlyZWN0bHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgdGhlIGNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgY29sbGVjdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJuIHtDb2xsZWN0aW9ufSBjb2xsZWN0aW9uIGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmNvbGxlY3Rpb24gPSBmdW5jdGlvbihuYW1lLCBvcHRpb25zKSB7XG4gIGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIGF1dG9JbmRleDogdGhpcy5jb25maWcuYXV0b0luZGV4ICE9IG51bGwgPyB0aGlzLmNvbmZpZy5hdXRvSW5kZXggOiB0aGlzLmJhc2Uub3B0aW9ucy5hdXRvSW5kZXgsXG4gICAgYXV0b0NyZWF0ZTogdGhpcy5jb25maWcuYXV0b0NyZWF0ZSAhPSBudWxsID8gdGhpcy5jb25maWcuYXV0b0NyZWF0ZSA6IHRoaXMuYmFzZS5vcHRpb25zLmF1dG9DcmVhdGUsXG4gICAgYXV0b1NlYXJjaEluZGV4OiB0aGlzLmNvbmZpZy5hdXRvU2VhcmNoSW5kZXggIT0gbnVsbCA/IHRoaXMuY29uZmlnLmF1dG9TZWFyY2hJbmRleCA6IHRoaXMuYmFzZS5vcHRpb25zLmF1dG9TZWFyY2hJbmRleFxuICB9O1xuICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMgPyBjbG9uZShvcHRpb25zKSA6IHt9KTtcbiAgb3B0aW9ucy4kd2FzRm9yY2VDbG9zZWQgPSB0aGlzLiR3YXNGb3JjZUNsb3NlZDtcbiAgY29uc3QgQ29sbGVjdGlvbiA9IHRoaXMuYmFzZSAmJiB0aGlzLmJhc2UuX19kcml2ZXIgJiYgdGhpcy5iYXNlLl9fZHJpdmVyLkNvbGxlY3Rpb24gfHwgZHJpdmVyLmdldCgpLkNvbGxlY3Rpb247XG4gIGlmICghKG5hbWUgaW4gdGhpcy5jb2xsZWN0aW9ucykpIHtcbiAgICB0aGlzLmNvbGxlY3Rpb25zW25hbWVdID0gbmV3IENvbGxlY3Rpb24obmFtZSwgdGhpcywgb3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbnNbbmFtZV07XG59O1xuXG4vKipcbiAqIERlY2xhcmVzIGEgcGx1Z2luIGV4ZWN1dGVkIG9uIGFsbCBzY2hlbWFzIHlvdSBwYXNzIHRvIGBjb25uLm1vZGVsKClgXG4gKlxuICogRXF1aXZhbGVudCB0byBjYWxsaW5nIGAucGx1Z2luKGZuKWAgb24gZWFjaCBzY2hlbWEgeW91IGNyZWF0ZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGRiID0gbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbignbW9uZ29kYjovLzEyNy4wLjAuMToyNzAxNy9teWRiJyk7XG4gKiAgICAgZGIucGx1Z2luKCgpID0+IGNvbnNvbGUubG9nKCdBcHBsaWVkJykpO1xuICogICAgIGRiLnBsdWdpbnMubGVuZ3RoOyAvLyAxXG4gKlxuICogICAgIGRiLm1vZGVsKCdUZXN0JywgbmV3IFNjaGVtYSh7fSkpOyAvLyBQcmludHMgXCJBcHBsaWVkXCJcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBwbHVnaW4gY2FsbGJhY2tcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gb3B0aW9uYWwgb3B0aW9uc1xuICogQHJldHVybiB7Q29ubmVjdGlvbn0gdGhpc1xuICogQHNlZSBwbHVnaW5zIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9wbHVnaW5zLmh0bWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUucGx1Z2luID0gZnVuY3Rpb24oZm4sIG9wdHMpIHtcbiAgdGhpcy5wbHVnaW5zLnB1c2goW2ZuLCBvcHRzXSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEZWZpbmVzIG9yIHJldHJpZXZlcyBhIG1vZGVsLlxuICpcbiAqICAgICBjb25zdCBtb25nb29zZSA9IHJlcXVpcmUoJ21vbmdvb3NlJyk7XG4gKiAgICAgY29uc3QgZGIgPSBtb25nb29zZS5jcmVhdGVDb25uZWN0aW9uKC4uKTtcbiAqICAgICBkYi5tb2RlbCgnVmVudWUnLCBuZXcgU2NoZW1hKC4uKSk7XG4gKiAgICAgY29uc3QgVGlja2V0ID0gZGIubW9kZWwoJ1RpY2tldCcsIG5ldyBTY2hlbWEoLi4pKTtcbiAqICAgICBjb25zdCBWZW51ZSA9IGRiLm1vZGVsKCdWZW51ZScpO1xuICpcbiAqIF9XaGVuIG5vIGBjb2xsZWN0aW9uYCBhcmd1bWVudCBpcyBwYXNzZWQsIE1vbmdvb3NlIHByb2R1Y2VzIGEgY29sbGVjdGlvbiBuYW1lIGJ5IHBhc3NpbmcgdGhlIG1vZGVsIGBuYW1lYCB0byB0aGUgYHV0aWxzLnRvQ29sbGVjdGlvbk5hbWVgIG1ldGhvZC4gVGhpcyBtZXRob2QgcGx1cmFsaXplcyB0aGUgbmFtZS4gSWYgeW91IGRvbid0IGxpa2UgdGhpcyBiZWhhdmlvciwgZWl0aGVyIHBhc3MgYSBjb2xsZWN0aW9uIG5hbWUgb3Igc2V0IHlvdXIgc2NoZW1hcyBjb2xsZWN0aW9uIG5hbWUgb3B0aW9uLl9cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSwgeyBjb2xsZWN0aW9uOiAnYWN0b3InIH0pO1xuICpcbiAqICAgICAvLyBvclxuICpcbiAqICAgICBzY2hlbWEuc2V0KCdjb2xsZWN0aW9uJywgJ2FjdG9yJyk7XG4gKlxuICogICAgIC8vIG9yXG4gKlxuICogICAgIGNvbnN0IGNvbGxlY3Rpb25OYW1lID0gJ2FjdG9yJ1xuICogICAgIGNvbnN0IE0gPSBjb25uLm1vZGVsKCdBY3RvcicsIHNjaGVtYSwgY29sbGVjdGlvbk5hbWUpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IG5hbWUgdGhlIG1vZGVsIG5hbWUgb3IgY2xhc3MgZXh0ZW5kaW5nIE1vZGVsXG4gKiBAcGFyYW0ge1NjaGVtYX0gW3NjaGVtYV0gYSBzY2hlbWEuIG5lY2Vzc2FyeSB3aGVuIGRlZmluaW5nIGEgbW9kZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBbY29sbGVjdGlvbl0gbmFtZSBvZiBtb25nb2RiIGNvbGxlY3Rpb24gKG9wdGlvbmFsKSBpZiBub3QgZ2l2ZW4gaXQgd2lsbCBiZSBpbmR1Y2VkIGZyb20gbW9kZWwgbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vdmVyd3JpdGVNb2RlbHM9ZmFsc2VdIElmIHRydWUsIG92ZXJ3cml0ZSBleGlzdGluZyBtb2RlbHMgd2l0aCB0aGUgc2FtZSBuYW1lIHRvIGF2b2lkIGBPdmVyd3JpdGVNb2RlbEVycm9yYFxuICogQHNlZSBNb25nb29zZSNtb2RlbCBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vbmdvb3NlLmh0bWwjTW9uZ29vc2UucHJvdG90eXBlLm1vZGVsKClcbiAqIEByZXR1cm4ge01vZGVsfSBUaGUgY29tcGlsZWQgbW9kZWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUubW9kZWwgPSBmdW5jdGlvbihuYW1lLCBzY2hlbWEsIGNvbGxlY3Rpb24sIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENvbm5lY3Rpb24pKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ2Bjb25uZWN0aW9uLm1vZGVsKClgIHNob3VsZCBub3QgYmUgcnVuIHdpdGggJyArXG4gICAgICAnYG5ld2AuIElmIHlvdSBhcmUgZG9pbmcgYG5ldyBkYi5tb2RlbChmb28pKGJhcilgLCB1c2UgJyArXG4gICAgICAnYGRiLm1vZGVsKGZvbykoYmFyKWAgaW5zdGVhZCcpO1xuICB9XG5cbiAgbGV0IGZuO1xuICBpZiAodHlwZW9mIG5hbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmbiA9IG5hbWU7XG4gICAgbmFtZSA9IGZuLm5hbWU7XG4gIH1cblxuICAvLyBjb2xsZWN0aW9uIG5hbWUgZGlzY292ZXJ5XG4gIGlmICh0eXBlb2Ygc2NoZW1hID09PSAnc3RyaW5nJykge1xuICAgIGNvbGxlY3Rpb24gPSBzY2hlbWE7XG4gICAgc2NoZW1hID0gZmFsc2U7XG4gIH1cblxuICBpZiAodXRpbHMuaXNPYmplY3Qoc2NoZW1hKSkge1xuICAgIGlmICghc2NoZW1hLmluc3RhbmNlT2ZTY2hlbWEpIHtcbiAgICAgIHNjaGVtYSA9IG5ldyBTY2hlbWEoc2NoZW1hKTtcbiAgICB9IGVsc2UgaWYgKCEoc2NoZW1hIGluc3RhbmNlb2YgdGhpcy5iYXNlLlNjaGVtYSkpIHtcbiAgICAgIHNjaGVtYSA9IHNjaGVtYS5fY2xvbmUodGhpcy5iYXNlLlNjaGVtYSk7XG4gICAgfVxuICB9XG4gIGlmIChzY2hlbWEgJiYgIXNjaGVtYS5pbnN0YW5jZU9mU2NoZW1hKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgMm5kIHBhcmFtZXRlciB0byBgbW9uZ29vc2UubW9kZWwoKWAgc2hvdWxkIGJlIGEgJyArXG4gICAgICAnc2NoZW1hIG9yIGEgUE9KTycpO1xuICB9XG5cbiAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7IGNhY2hlOiBmYWxzZSwgb3ZlcndyaXRlTW9kZWxzOiB0aGlzLmJhc2Uub3B0aW9ucy5vdmVyd3JpdGVNb2RlbHMgfTtcbiAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMsIHsgY29ubmVjdGlvbjogdGhpcyB9KTtcbiAgaWYgKHRoaXMubW9kZWxzW25hbWVdICYmICFjb2xsZWN0aW9uICYmIG9wdHMub3ZlcndyaXRlTW9kZWxzICE9PSB0cnVlKSB7XG4gICAgLy8gbW9kZWwgZXhpc3RzIGJ1dCB3ZSBhcmUgbm90IHN1YmNsYXNzaW5nIHdpdGggY3VzdG9tIGNvbGxlY3Rpb25cbiAgICBpZiAoc2NoZW1hICYmIHNjaGVtYS5pbnN0YW5jZU9mU2NoZW1hICYmIHNjaGVtYSAhPT0gdGhpcy5tb2RlbHNbbmFtZV0uc2NoZW1hKSB7XG4gICAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvci5PdmVyd3JpdGVNb2RlbEVycm9yKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tb2RlbHNbbmFtZV07XG4gIH1cblxuICBsZXQgbW9kZWw7XG5cbiAgaWYgKHNjaGVtYSAmJiBzY2hlbWEuaW5zdGFuY2VPZlNjaGVtYSkge1xuICAgIGFwcGx5UGx1Z2lucyhzY2hlbWEsIHRoaXMucGx1Z2lucywgbnVsbCwgJyRjb25uZWN0aW9uUGx1Z2luc0FwcGxpZWQnKTtcblxuICAgIC8vIGNvbXBpbGUgYSBtb2RlbFxuICAgIG1vZGVsID0gdGhpcy5iYXNlLl9tb2RlbChmbiB8fCBuYW1lLCBzY2hlbWEsIGNvbGxlY3Rpb24sIG9wdHMpO1xuXG4gICAgLy8gb25seSB0aGUgZmlyc3QgbW9kZWwgd2l0aCB0aGlzIG5hbWUgaXMgY2FjaGVkIHRvIGFsbG93XG4gICAgLy8gZm9yIG9uZS1vZmZzIHdpdGggY3VzdG9tIGNvbGxlY3Rpb24gbmFtZXMgZXRjLlxuICAgIGlmICghdGhpcy5tb2RlbHNbbmFtZV0pIHtcbiAgICAgIHRoaXMubW9kZWxzW25hbWVdID0gbW9kZWw7XG4gICAgfVxuXG4gICAgLy8gRXJyb3JzIGhhbmRsZWQgaW50ZXJuYWxseSwgc28gc2FmZSB0byBpZ25vcmUgZXJyb3JcbiAgICBtb2RlbC5pbml0KCkuY2F0Y2goZnVuY3Rpb24gJG1vZGVsSW5pdE5vb3AoKSB7fSk7XG5cbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cblxuICBpZiAodGhpcy5tb2RlbHNbbmFtZV0gJiYgY29sbGVjdGlvbikge1xuICAgIC8vIHN1YmNsYXNzaW5nIGN1cnJlbnQgbW9kZWwgd2l0aCBhbHRlcm5hdGUgY29sbGVjdGlvblxuICAgIG1vZGVsID0gdGhpcy5tb2RlbHNbbmFtZV07XG4gICAgc2NoZW1hID0gbW9kZWwucHJvdG90eXBlLnNjaGVtYTtcbiAgICBjb25zdCBzdWIgPSBtb2RlbC5fX3N1YmNsYXNzKHRoaXMsIHNjaGVtYSwgY29sbGVjdGlvbik7XG4gICAgLy8gZG8gbm90IGNhY2hlIHRoZSBzdWIgbW9kZWxcbiAgICByZXR1cm4gc3ViO1xuICB9XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBtb2RlbCA9IHRoaXMubW9kZWxzW25hbWVdO1xuICAgIGlmICghbW9kZWwpIHtcbiAgICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yLk1pc3NpbmdTY2hlbWFFcnJvcihuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG5cbiAgaWYgKCFtb2RlbCkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yLk1pc3NpbmdTY2hlbWFFcnJvcihuYW1lKTtcbiAgfVxuXG4gIGlmICh0aGlzID09PSBtb2RlbC5wcm90b3R5cGUuZGJcbiAgICAgICYmICghY29sbGVjdGlvbiB8fCBjb2xsZWN0aW9uID09PSBtb2RlbC5jb2xsZWN0aW9uLm5hbWUpKSB7XG4gICAgLy8gbW9kZWwgYWxyZWFkeSB1c2VzIHRoaXMgY29ubmVjdGlvbi5cblxuICAgIC8vIG9ubHkgdGhlIGZpcnN0IG1vZGVsIHdpdGggdGhpcyBuYW1lIGlzIGNhY2hlZCB0byBhbGxvd1xuICAgIC8vIGZvciBvbmUtb2ZmcyB3aXRoIGN1c3RvbSBjb2xsZWN0aW9uIG5hbWVzIGV0Yy5cbiAgICBpZiAoIXRoaXMubW9kZWxzW25hbWVdKSB7XG4gICAgICB0aGlzLm1vZGVsc1tuYW1lXSA9IG1vZGVsO1xuICAgIH1cblxuICAgIHJldHVybiBtb2RlbDtcbiAgfVxuICB0aGlzLm1vZGVsc1tuYW1lXSA9IG1vZGVsLl9fc3ViY2xhc3ModGhpcywgc2NoZW1hLCBjb2xsZWN0aW9uKTtcbiAgcmV0dXJuIHRoaXMubW9kZWxzW25hbWVdO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBtb2RlbCBuYW1lZCBgbmFtZWAgZnJvbSB0aGlzIGNvbm5lY3Rpb24sIGlmIGl0IGV4aXN0cy4gWW91IGNhblxuICogdXNlIHRoaXMgZnVuY3Rpb24gdG8gY2xlYW4gdXAgYW55IG1vZGVscyB5b3UgY3JlYXRlZCBpbiB5b3VyIHRlc3RzIHRvXG4gKiBwcmV2ZW50IE92ZXJ3cml0ZU1vZGVsRXJyb3JzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29ubi5tb2RlbCgnVXNlcicsIG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSkpO1xuICogICAgIGNvbnNvbGUubG9nKGNvbm4ubW9kZWwoJ1VzZXInKSk7IC8vIE1vZGVsIG9iamVjdFxuICogICAgIGNvbm4uZGVsZXRlTW9kZWwoJ1VzZXInKTtcbiAqICAgICBjb25zb2xlLmxvZyhjb25uLm1vZGVsKCdVc2VyJykpOyAvLyB1bmRlZmluZWRcbiAqXG4gKiAgICAgLy8gVXN1YWxseSB1c2VmdWwgaW4gYSBNb2NoYSBgYWZ0ZXJFYWNoKClgIGhvb2tcbiAqICAgICBhZnRlckVhY2goZnVuY3Rpb24oKSB7XG4gKiAgICAgICBjb25uLmRlbGV0ZU1vZGVsKC8uKy8pOyAvLyBEZWxldGUgZXZlcnkgbW9kZWxcbiAqICAgICB9KTtcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBuYW1lIGlmIHN0cmluZywgdGhlIG5hbWUgb2YgdGhlIG1vZGVsIHRvIHJlbW92ZS4gSWYgcmVnZXhwLCByZW1vdmVzIGFsbCBtb2RlbHMgd2hvc2UgbmFtZSBtYXRjaGVzIHRoZSByZWdleHAuXG4gKiBAcmV0dXJuIHtDb25uZWN0aW9ufSB0aGlzXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuZGVsZXRlTW9kZWwgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBtb2RlbCA9IHRoaXMubW9kZWwobmFtZSk7XG4gICAgaWYgKG1vZGVsID09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCBjb2xsZWN0aW9uTmFtZSA9IG1vZGVsLmNvbGxlY3Rpb24ubmFtZTtcbiAgICBkZWxldGUgdGhpcy5tb2RlbHNbbmFtZV07XG4gICAgZGVsZXRlIHRoaXMuY29sbGVjdGlvbnNbY29sbGVjdGlvbk5hbWVdO1xuXG4gICAgdGhpcy5lbWl0KCdkZWxldGVNb2RlbCcsIG1vZGVsKTtcbiAgfSBlbHNlIGlmIChuYW1lIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgY29uc3QgcGF0dGVybiA9IG5hbWU7XG4gICAgY29uc3QgbmFtZXMgPSB0aGlzLm1vZGVsTmFtZXMoKTtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgbmFtZXMpIHtcbiAgICAgIGlmIChwYXR0ZXJuLnRlc3QobmFtZSkpIHtcbiAgICAgICAgdGhpcy5kZWxldGVNb2RlbChuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBwYXJhbWV0ZXIgdG8gYGRlbGV0ZU1vZGVsKClgIG11c3QgYmUgYSBzdHJpbmcgJyArXG4gICAgICAnb3IgcmVnZXhwLCBnb3QgXCInICsgbmFtZSArICdcIicpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFdhdGNoZXMgdGhlIGVudGlyZSB1bmRlcmx5aW5nIGRhdGFiYXNlIGZvciBjaGFuZ2VzLiBTaW1pbGFyIHRvXG4gKiBbYE1vZGVsLndhdGNoKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vZGVsLmh0bWwjTW9kZWwud2F0Y2goKSkuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBkb2VzICoqbm90KiogdHJpZ2dlciBhbnkgbWlkZGxld2FyZS4gSW4gcGFydGljdWxhciwgaXRcbiAqIGRvZXMgKipub3QqKiB0cmlnZ2VyIGFnZ3JlZ2F0ZSBtaWRkbGV3YXJlLlxuICpcbiAqIFRoZSBDaGFuZ2VTdHJlYW0gb2JqZWN0IGlzIGFuIGV2ZW50IGVtaXR0ZXIgdGhhdCBlbWl0cyB0aGUgZm9sbG93aW5nIGV2ZW50czpcbiAqXG4gKiAtICdjaGFuZ2UnOiBBIGNoYW5nZSBvY2N1cnJlZCwgc2VlIGJlbG93IGV4YW1wbGVcbiAqIC0gJ2Vycm9yJzogQW4gdW5yZWNvdmVyYWJsZSBlcnJvciBvY2N1cnJlZC4gSW4gcGFydGljdWxhciwgY2hhbmdlIHN0cmVhbXMgY3VycmVudGx5IGVycm9yIG91dCBpZiB0aGV5IGxvc2UgY29ubmVjdGlvbiB0byB0aGUgcmVwbGljYSBzZXQgcHJpbWFyeS4gRm9sbG93IFt0aGlzIEdpdEh1YiBpc3N1ZV0oaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvbW9uZ29vc2UvaXNzdWVzLzY3OTkpIGZvciB1cGRhdGVzLlxuICogLSAnZW5kJzogRW1pdHRlZCBpZiB0aGUgdW5kZXJseWluZyBzdHJlYW0gaXMgY2xvc2VkXG4gKiAtICdjbG9zZSc6IEVtaXR0ZWQgaWYgdGhlIHVuZGVybHlpbmcgc3RyZWFtIGlzIGNsb3NlZFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgVXNlciA9IGNvbm4ubW9kZWwoJ1VzZXInLCBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0pKTtcbiAqXG4gKiAgICAgY29uc3QgY2hhbmdlU3RyZWFtID0gY29ubi53YXRjaCgpLm9uKCdjaGFuZ2UnLCBkYXRhID0+IGNvbnNvbGUubG9nKGRhdGEpKTtcbiAqXG4gKiAgICAgLy8gVHJpZ2dlcnMgYSAnY2hhbmdlJyBldmVudCBvbiB0aGUgY2hhbmdlIHN0cmVhbS5cbiAqICAgICBhd2FpdCBVc2VyLmNyZWF0ZSh7IG5hbWU6ICd0ZXN0JyB9KTtcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHBhcmFtIHtBcnJheX0gW3BpcGVsaW5lXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBwYXNzZWQgd2l0aG91dCBjaGFuZ2VzIHRvIFt0aGUgTW9uZ29EQiBkcml2ZXIncyBgRGIjd2F0Y2goKWAgZnVuY3Rpb25dKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9EYi5odG1sI3dhdGNoKVxuICogQHJldHVybiB7Q2hhbmdlU3RyZWFtfSBtb25nb29zZS1zcGVjaWZpYyBjaGFuZ2Ugc3RyZWFtIHdyYXBwZXIsIGluaGVyaXRzIGZyb20gRXZlbnRFbWl0dGVyXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUud2F0Y2ggPSBmdW5jdGlvbihwaXBlbGluZSwgb3B0aW9ucykge1xuICBjb25zdCBjaGFuZ2VTdHJlYW1UaHVuayA9IGNiID0+IHtcbiAgICBpbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU1RBVEVTLmNvbm5lY3RpbmcpIHtcbiAgICAgICAgdGhpcy5vbmNlKCdvcGVuJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY29uc3QgZHJpdmVyQ2hhbmdlU3RyZWFtID0gdGhpcy5kYi53YXRjaChwaXBlbGluZSwgb3B0aW9ucyk7XG4gICAgICAgICAgY2IobnVsbCwgZHJpdmVyQ2hhbmdlU3RyZWFtKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBkcml2ZXJDaGFuZ2VTdHJlYW0gPSB0aGlzLmRiLndhdGNoKHBpcGVsaW5lLCBvcHRpb25zKTtcbiAgICAgICAgY2IobnVsbCwgZHJpdmVyQ2hhbmdlU3RyZWFtKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBjb25zdCBjaGFuZ2VTdHJlYW0gPSBuZXcgQ2hhbmdlU3RyZWFtKGNoYW5nZVN0cmVhbVRodW5rLCBwaXBlbGluZSwgb3B0aW9ucyk7XG4gIHJldHVybiBjaGFuZ2VTdHJlYW07XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGlzIGNvbm5lY3Rpb25cbiAqIHN1Y2Nlc3NmdWxseSBjb25uZWN0cyB0byBNb25nb0RCLCBvciByZWplY3RzIGlmIHRoaXMgY29ubmVjdGlvbiBmYWlsZWRcbiAqIHRvIGNvbm5lY3QuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBjb25uID0gYXdhaXQgbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbignbW9uZ29kYjovLzEyNy4wLjAuMToyNzAxNy90ZXN0JykuXG4gKiAgICAgICBhc1Byb21pc2UoKTtcbiAqICAgICBjb25uLnJlYWR5U3RhdGU7IC8vIDEsIG1lYW5zIE1vbmdvb3NlIGlzIGNvbm5lY3RlZFxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmFzUHJvbWlzZSA9IGFzeW5jIGZ1bmN0aW9uIGFzUHJvbWlzZSgpIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCB0aGlzLiRpbml0aWFsQ29ubmVjdGlvbjtcbiAgICByZXR1cm4gdGhpcztcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgX2hhbmRsZUNvbm5lY3Rpb25FcnJvcnMoZXJyKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIG1vZGVsIG5hbWVzIGNyZWF0ZWQgb24gdGhpcyBjb25uZWN0aW9uLlxuICogQGFwaSBwdWJsaWNcbiAqIEByZXR1cm4ge1N0cmluZ1tdfVxuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLm1vZGVsTmFtZXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMubW9kZWxzKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBpZiB0aGUgY29ubmVjdGlvbiByZXF1aXJlcyBhdXRoZW50aWNhdGlvbiBhZnRlciBpdCBpcyBvcGVuZWQuIEdlbmVyYWxseSBpZiBhXG4gKiB1c2VybmFtZSBhbmQgcGFzc3dvcmQgYXJlIGJvdGggcHJvdmlkZWQgdGhhbiBhdXRoZW50aWNhdGlvbiBpcyBuZWVkZWQsIGJ1dCBpbiBzb21lIGNhc2VzIGFcbiAqIHBhc3N3b3JkIGlzIG5vdCByZXF1aXJlZC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIGNvbm5lY3Rpb24gc2hvdWxkIGJlIGF1dGhlbnRpY2F0ZWQgYWZ0ZXIgaXQgaXMgb3BlbmVkLCBvdGhlcndpc2UgZmFsc2UuXG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnNob3VsZEF1dGhlbnRpY2F0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy51c2VyICE9IG51bGwgJiZcbiAgICAodGhpcy5wYXNzICE9IG51bGwgfHwgdGhpcy5hdXRoTWVjaGFuaXNtRG9lc05vdFJlcXVpcmVQYXNzd29yZCgpKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGJvb2xlYW4gdmFsdWUgdGhhdCBzcGVjaWZpZXMgaWYgdGhlIGN1cnJlbnQgYXV0aGVudGljYXRpb24gbWVjaGFuaXNtIG5lZWRzIGFcbiAqIHBhc3N3b3JkIHRvIGF1dGhlbnRpY2F0ZSBhY2NvcmRpbmcgdG8gdGhlIGF1dGggb2JqZWN0cyBwYXNzZWQgaW50byB0aGUgb3BlblVyaSBtZXRob2RzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgYXV0aGVudGljYXRpb24gbWVjaGFuaXNtIHNwZWNpZmllZCBpbiB0aGUgb3B0aW9ucyBvYmplY3QgcmVxdWlyZXNcbiAqICBhIHBhc3N3b3JkLCBvdGhlcndpc2UgZmFsc2UuXG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmF1dGhNZWNoYW5pc21Eb2VzTm90UmVxdWlyZVBhc3N3b3JkID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLmF1dGgpIHtcbiAgICByZXR1cm4gbm9QYXNzd29yZEF1dGhNZWNoYW5pc21zLmluZGV4T2YodGhpcy5vcHRpb25zLmF1dGguYXV0aE1lY2hhbmlzbSkgPj0gMDtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGJvb2xlYW4gdmFsdWUgdGhhdCBzcGVjaWZpZXMgaWYgdGhlIHByb3ZpZGVkIG9iamVjdHMgb2JqZWN0IHByb3ZpZGVzIGVub3VnaFxuICogZGF0YSB0byBhdXRoZW50aWNhdGUgd2l0aC4gR2VuZXJhbGx5IHRoaXMgaXMgdHJ1ZSBpZiB0aGUgdXNlcm5hbWUgYW5kIHBhc3N3b3JkIGFyZSBib3RoIHNwZWNpZmllZFxuICogYnV0IGluIHNvbWUgYXV0aGVudGljYXRpb24gbWV0aG9kcywgYSBwYXNzd29yZCBpcyBub3QgcmVxdWlyZWQgZm9yIGF1dGhlbnRpY2F0aW9uIHNvIG9ubHkgYSB1c2VybmFtZVxuICogaXMgcmVxdWlyZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSB0aGUgb3B0aW9ucyBvYmplY3QgcGFzc2VkIGludG8gdGhlIG9wZW5VcmkgbWV0aG9kcy5cbiAqIEBhcGkgcHJpdmF0ZVxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgb3B0aW9ucyBvYmplY3QgcHJvdmlkZXMgZW5vdWdoIGRhdGEgdG8gYXV0aGVudGljYXRlIHdpdGgsXG4gKiAgIG90aGVyd2lzZSBmYWxzZS5cbiAqL1xuQ29ubmVjdGlvbi5wcm90b3R5cGUub3B0aW9uc1Byb3ZpZGVBdXRoZW50aWNhdGlvbkRhdGEgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHJldHVybiAob3B0aW9ucykgJiZcbiAgICAgIChvcHRpb25zLnVzZXIpICYmXG4gICAgICAoKG9wdGlvbnMucGFzcykgfHwgdGhpcy5hdXRoTWVjaGFuaXNtRG9lc05vdFJlcXVpcmVQYXNzd29yZCgpKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgW01vbmdvREIgZHJpdmVyIGBNb25nb0NsaWVudGBdKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9Nb25nb0NsaWVudC5odG1sKSBpbnN0YW5jZVxuICogdGhhdCB0aGlzIGNvbm5lY3Rpb24gdXNlcyB0byB0YWxrIHRvIE1vbmdvREIuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBjb25uID0gYXdhaXQgbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbignbW9uZ29kYjovLzEyNy4wLjAuMToyNzAxNy90ZXN0JykuXG4gKiAgICAgICBhc1Byb21pc2UoKTtcbiAqXG4gKiAgICAgY29ubi5nZXRDbGllbnQoKTsgLy8gTW9uZ29DbGllbnQgeyAuLi4gfVxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcmV0dXJuIHtNb25nb0NsaWVudH1cbiAqL1xuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5nZXRDbGllbnQgPSBmdW5jdGlvbiBnZXRDbGllbnQoKSB7XG4gIHJldHVybiB0aGlzLmNsaWVudDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBbTW9uZ29EQiBkcml2ZXIgYE1vbmdvQ2xpZW50YF0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL01vbmdvQ2xpZW50Lmh0bWwpIGluc3RhbmNlXG4gKiB0aGF0IHRoaXMgY29ubmVjdGlvbiB1c2VzIHRvIHRhbGsgdG8gTW9uZ29EQi4gVGhpcyBpcyB1c2VmdWwgaWYgeW91IGFscmVhZHkgaGF2ZSBhIE1vbmdvQ2xpZW50IGluc3RhbmNlLCBhbmQgd2FudCB0b1xuICogcmV1c2UgaXQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBjbGllbnQgPSBhd2FpdCBtb25nb2RiLk1vbmdvQ2xpZW50LmNvbm5lY3QoJ21vbmdvZGI6Ly8xMjcuMC4wLjE6MjcwMTcvdGVzdCcpO1xuICpcbiAqICAgICBjb25zdCBjb25uID0gbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbigpLnNldENsaWVudChjbGllbnQpO1xuICpcbiAqICAgICBjb25uLmdldENsaWVudCgpOyAvLyBNb25nb0NsaWVudCB7IC4uLiB9XG4gKiAgICAgY29ubi5yZWFkeVN0YXRlOyAvLyAxLCBtZWFucyAnQ09OTkVDVEVEJ1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcGFyYW0ge01vbmdDbGllbnR9IGNsaWVudCBUaGUgQ2xpZW50IHRvIHNldCB0byBiZSB1c2VkLlxuICogQHJldHVybiB7Q29ubmVjdGlvbn0gdGhpc1xuICovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnNldENsaWVudCA9IGZ1bmN0aW9uIHNldENsaWVudCgpIHtcbiAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0Nvbm5lY3Rpb24jc2V0Q2xpZW50IG5vdCBpbXBsZW1lbnRlZCBieSBkcml2ZXInKTtcbn07XG5cbi8qIVxuICogQ2FsbGVkIGludGVybmFsbHkgYnkgYG9wZW5VcmkoKWAgdG8gY3JlYXRlIGEgTW9uZ29DbGllbnQgaW5zdGFuY2UuXG4gKi9cblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlQ2xpZW50ID0gZnVuY3Rpb24gY3JlYXRlQ2xpZW50KCkge1xuICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignQ29ubmVjdGlvbiNjcmVhdGVDbGllbnQgbm90IGltcGxlbWVudGVkIGJ5IGRyaXZlcicpO1xufTtcblxuLyoqXG4gKiBTeW5jcyBhbGwgdGhlIGluZGV4ZXMgZm9yIHRoZSBtb2RlbHMgcmVnaXN0ZXJlZCB3aXRoIHRoaXMgY29ubmVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNvbnRpbnVlT25FcnJvcl0gYGZhbHNlYCBieSBkZWZhdWx0LiBJZiBzZXQgdG8gYHRydWVgLCBtb25nb29zZSB3aWxsIG5vdCB0aHJvdyBhbiBlcnJvciBpZiBvbmUgbW9kZWwgc3luY2luZyBmYWlsZWQsIGFuZCB3aWxsIHJldHVybiBhbiBvYmplY3Qgd2hlcmUgdGhlIGtleXMgYXJlIHRoZSBuYW1lcyBvZiB0aGUgbW9kZWxzLCBhbmQgdGhlIHZhbHVlcyBhcmUgdGhlIHJlc3VsdHMvZXJyb3JzIGZvciBlYWNoIG1vZGVsLlxuICogQHJldHVybiB7UHJvbWlzZTxPYmplY3Q+fSBSZXR1cm5zIGEgUHJvbWlzZSwgd2hlbiB0aGUgUHJvbWlzZSByZXNvbHZlcyB0aGUgdmFsdWUgaXMgYSBsaXN0IG9mIHRoZSBkcm9wcGVkIGluZGV4ZXMuXG4gKi9cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnN5bmNJbmRleGVzID0gYXN5bmMgZnVuY3Rpb24gc3luY0luZGV4ZXMob3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBjb25zdCBlcnJvcnNNYXAgPSB7IH07XG5cbiAgY29uc3QgeyBjb250aW51ZU9uRXJyb3IgfSA9IG9wdGlvbnM7XG4gIGRlbGV0ZSBvcHRpb25zLmNvbnRpbnVlT25FcnJvcjtcblxuICBmb3IgKGNvbnN0IG1vZGVsIG9mIE9iamVjdC52YWx1ZXModGhpcy5tb2RlbHMpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdFttb2RlbC5tb2RlbE5hbWVdID0gYXdhaXQgbW9kZWwuc3luY0luZGV4ZXMob3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoIWNvbnRpbnVlT25FcnJvcikge1xuICAgICAgICBlcnJvcnNNYXBbbW9kZWwubW9kZWxOYW1lXSA9IGVycjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbbW9kZWwubW9kZWxOYW1lXSA9IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbnRpbnVlT25FcnJvciAmJiBPYmplY3Qua2V5cyhlcnJvcnNNYXApLmxlbmd0aCkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBPYmplY3QuZW50cmllcyhlcnJvcnNNYXApLm1hcCgoW21vZGVsTmFtZSwgZXJyXSkgPT4gYCR7bW9kZWxOYW1lfTogJHtlcnIubWVzc2FnZX1gKS5qb2luKCcsICcpO1xuICAgIGNvbnN0IHN5bmNJbmRleGVzRXJyb3IgPSBuZXcgU3luY0luZGV4ZXNFcnJvcihtZXNzYWdlLCBlcnJvcnNNYXApO1xuICAgIHRocm93IHN5bmNJbmRleGVzRXJyb3I7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBTd2l0Y2hlcyB0byBhIGRpZmZlcmVudCBkYXRhYmFzZSB1c2luZyB0aGUgc2FtZSBbY29ubmVjdGlvbiBwb29sXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2Nvbm5lY3Rpb25zaHRtbCNjb25uZWN0aW9uX3Bvb2xzKS5cbiAqXG4gKiBSZXR1cm5zIGEgbmV3IGNvbm5lY3Rpb24gb2JqZWN0LCB3aXRoIHRoZSBuZXcgZGIuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBDb25uZWN0IHRvIGBpbml0aWFsZGJgIGZpcnN0XG4gKiAgICAgY29uc3QgY29ubiA9IGF3YWl0IG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oJ21vbmdvZGI6Ly8xMjcuMC4wLjE6MjcwMTcvaW5pdGlhbGRiJykuYXNQcm9taXNlKCk7XG4gKlxuICogICAgIC8vIENyZWF0ZXMgYW4gdW4tY2FjaGVkIGNvbm5lY3Rpb24gdG8gYG15ZGJgXG4gKiAgICAgY29uc3QgZGIgPSBjb25uLnVzZURiKCdteWRiJyk7XG4gKiAgICAgLy8gQ3JlYXRlcyBhIGNhY2hlZCBjb25uZWN0aW9uIHRvIGBteWRiMmAuIEFsbCBjYWxscyB0byBgY29ubi51c2VEYignbXlkYjInLCB7IHVzZUNhY2hlOiB0cnVlIH0pYCB3aWxsIHJldHVybiB0aGUgc2FtZVxuICogICAgIC8vIGNvbm5lY3Rpb24gaW5zdGFuY2UgYXMgb3Bwb3NlZCB0byBjcmVhdGluZyBhIG5ldyBjb25uZWN0aW9uIGluc3RhbmNlXG4gKiAgICAgY29uc3QgZGIyID0gY29ubi51c2VEYignbXlkYjInLCB7IHVzZUNhY2hlOiB0cnVlIH0pO1xuICpcbiAqIEBtZXRob2QgdXNlRGJcbiAqIEBtZW1iZXJPZiBDb25uZWN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgZGF0YWJhc2UgbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy51c2VDYWNoZT1mYWxzZV0gSWYgdHJ1ZSwgY2FjaGUgcmVzdWx0cyBzbyBjYWxsaW5nIGB1c2VEYigpYCBtdWx0aXBsZSB0aW1lcyB3aXRoIHRoZSBzYW1lIG5hbWUgb25seSBjcmVhdGVzIDEgY29ubmVjdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm5vTGlzdGVuZXI9ZmFsc2VdIElmIHRydWUsIHRoZSBjb25uZWN0aW9uIG9iamVjdCB3aWxsIG5vdCBtYWtlIHRoZSBkYiBsaXN0ZW4gdG8gZXZlbnRzIG9uIHRoZSBvcmlnaW5hbCBjb25uZWN0aW9uLiBTZWUgW2lzc3VlICM5OTYxXShodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9tb25nb29zZS9pc3N1ZXMvOTk2MSkuXG4gKiBAcmV0dXJuIHtDb25uZWN0aW9ufSBOZXcgQ29ubmVjdGlvbiBPYmplY3RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBkYXRhYmFzZSBjb25uZWN0aW9uIHdpdGggdGhlIGdpdmVuIG5hbWUgY3JlYXRlZCB3aXRoIHdpdGggYHVzZURiKClgLlxuICpcbiAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgZGF0YWJhc2UgY29ubmVjdGlvbiB3YXMgbm90IGZvdW5kLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gQ29ubmVjdCB0byBgaW5pdGlhbGRiYCBmaXJzdFxuICogICAgIGNvbnN0IGNvbm4gPSBhd2FpdCBtb25nb29zZS5jcmVhdGVDb25uZWN0aW9uKCdtb25nb2RiOi8vMTI3LjAuMC4xOjI3MDE3L2luaXRpYWxkYicpLmFzUHJvbWlzZSgpO1xuICpcbiAqICAgICAvLyBDcmVhdGVzIGFuIHVuLWNhY2hlZCBjb25uZWN0aW9uIHRvIGBteWRiYFxuICogICAgIGNvbnN0IGRiID0gY29ubi51c2VEYignbXlkYicpO1xuICpcbiAqICAgICAvLyBDbG9zZXMgYGRiYCwgYW5kIHJlbW92ZXMgYGRiYCBmcm9tIGBjb25uLnJlbGF0ZWREYnNgIGFuZCBgY29ubi5vdGhlckRic2BcbiAqICAgICBhd2FpdCBjb25uLnJlbW92ZURiKCdteWRiJyk7XG4gKlxuICogQG1ldGhvZCByZW1vdmVEYlxuICogQG1lbWJlck9mIENvbm5lY3Rpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBkYXRhYmFzZSBuYW1lXG4gKiBAcmV0dXJuIHtDb25uZWN0aW9ufSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxuQ29ubmVjdGlvbi5TVEFURVMgPSBTVEFURVM7XG5tb2R1bGUuZXhwb3J0cyA9IENvbm5lY3Rpb247XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/connection.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/connectionState.js":
/*!***************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/connectionState.js ***!
  \***************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\n/*!\n * Connection states\n */\n\n\n\nconst STATES = module.exports = exports = Object.create(null);\n\nconst disconnected = 'disconnected';\nconst connected = 'connected';\nconst connecting = 'connecting';\nconst disconnecting = 'disconnecting';\nconst uninitialized = 'uninitialized';\n\nSTATES[0] = disconnected;\nSTATES[1] = connected;\nSTATES[2] = connecting;\nSTATES[3] = disconnecting;\nSTATES[99] = uninitialized;\n\nSTATES[disconnected] = 0;\nSTATES[connected] = 1;\nSTATES[connecting] = 2;\nSTATES[disconnecting] = 3;\nSTATES[uninitialized] = 99;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Nvbm5lY3Rpb25TdGF0ZS5qcyIsIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Nvbm5lY3Rpb25TdGF0ZS5qcz82NzdiIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyohXG4gKiBDb25uZWN0aW9uIHN0YXRlc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgU1RBVEVTID0gbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuY29uc3QgZGlzY29ubmVjdGVkID0gJ2Rpc2Nvbm5lY3RlZCc7XG5jb25zdCBjb25uZWN0ZWQgPSAnY29ubmVjdGVkJztcbmNvbnN0IGNvbm5lY3RpbmcgPSAnY29ubmVjdGluZyc7XG5jb25zdCBkaXNjb25uZWN0aW5nID0gJ2Rpc2Nvbm5lY3RpbmcnO1xuY29uc3QgdW5pbml0aWFsaXplZCA9ICd1bmluaXRpYWxpemVkJztcblxuU1RBVEVTWzBdID0gZGlzY29ubmVjdGVkO1xuU1RBVEVTWzFdID0gY29ubmVjdGVkO1xuU1RBVEVTWzJdID0gY29ubmVjdGluZztcblNUQVRFU1szXSA9IGRpc2Nvbm5lY3Rpbmc7XG5TVEFURVNbOTldID0gdW5pbml0aWFsaXplZDtcblxuU1RBVEVTW2Rpc2Nvbm5lY3RlZF0gPSAwO1xuU1RBVEVTW2Nvbm5lY3RlZF0gPSAxO1xuU1RBVEVTW2Nvbm5lY3RpbmddID0gMjtcblNUQVRFU1tkaXNjb25uZWN0aW5nXSA9IDM7XG5TVEFURVNbdW5pbml0aWFsaXplZF0gPSA5OTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/connectionState.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/constants.js":
/*!*********************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/constants.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nconst queryOperations = Object.freeze([\n  // Read\n  'countDocuments',\n  'distinct',\n  'estimatedDocumentCount',\n  'find',\n  'findOne',\n  // Update\n  'findOneAndReplace',\n  'findOneAndUpdate',\n  'replaceOne',\n  'updateMany',\n  'updateOne',\n  // Delete\n  'deleteMany',\n  'deleteOne',\n  'findOneAndDelete'\n]);\n\nexports.queryOperations = queryOperations;\n\n/*!\n * ignore\n */\n\nconst queryMiddlewareFunctions = queryOperations.concat([\n  'validate'\n]);\n\nexports.queryMiddlewareFunctions = queryMiddlewareFunctions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY29uc3RhbnRzLmpzPzRhMDciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmNvbnN0IHF1ZXJ5T3BlcmF0aW9ucyA9IE9iamVjdC5mcmVlemUoW1xuICAvLyBSZWFkXG4gICdjb3VudERvY3VtZW50cycsXG4gICdkaXN0aW5jdCcsXG4gICdlc3RpbWF0ZWREb2N1bWVudENvdW50JyxcbiAgJ2ZpbmQnLFxuICAnZmluZE9uZScsXG4gIC8vIFVwZGF0ZVxuICAnZmluZE9uZUFuZFJlcGxhY2UnLFxuICAnZmluZE9uZUFuZFVwZGF0ZScsXG4gICdyZXBsYWNlT25lJyxcbiAgJ3VwZGF0ZU1hbnknLFxuICAndXBkYXRlT25lJyxcbiAgLy8gRGVsZXRlXG4gICdkZWxldGVNYW55JyxcbiAgJ2RlbGV0ZU9uZScsXG4gICdmaW5kT25lQW5kRGVsZXRlJ1xuXSk7XG5cbmV4cG9ydHMucXVlcnlPcGVyYXRpb25zID0gcXVlcnlPcGVyYXRpb25zO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmNvbnN0IHF1ZXJ5TWlkZGxld2FyZUZ1bmN0aW9ucyA9IHF1ZXJ5T3BlcmF0aW9ucy5jb25jYXQoW1xuICAndmFsaWRhdGUnXG5dKTtcblxuZXhwb3J0cy5xdWVyeU1pZGRsZXdhcmVGdW5jdGlvbnMgPSBxdWVyeU1pZGRsZXdhcmVGdW5jdGlvbnM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/constants.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/cursor/aggregationCursor.js":
/*!************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/cursor/aggregationCursor.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ../error/mongooseError */ \"../backend/node_modules/mongoose/lib/error/mongooseError.js\");\nconst Readable = (__webpack_require__(/*! stream */ \"stream\").Readable);\nconst eachAsync = __webpack_require__(/*! ../helpers/cursor/eachAsync */ \"../backend/node_modules/mongoose/lib/helpers/cursor/eachAsync.js\");\nconst immediate = __webpack_require__(/*! ../helpers/immediate */ \"../backend/node_modules/mongoose/lib/helpers/immediate.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\n/**\n * An AggregationCursor is a concurrency primitive for processing aggregation\n * results one document at a time. It is analogous to QueryCursor.\n *\n * An AggregationCursor fulfills the Node.js streams3 API,\n * in addition to several other mechanisms for loading documents from MongoDB\n * one at a time.\n *\n * Creating an AggregationCursor executes the model's pre aggregate hooks,\n * but **not** the model's post aggregate hooks.\n *\n * Unless you're an advanced user, do **not** instantiate this class directly.\n * Use [`Aggregate#cursor()`](https://mongoosejs.com/docs/api/aggregate.html#Aggregate.prototype.cursor()) instead.\n *\n * @param {Aggregate} agg\n * @inherits Readable https://nodejs.org/api/stream.html#class-streamreadable\n * @event `cursor`: Emitted when the cursor is created\n * @event `error`: Emitted when an error occurred\n * @event `data`: Emitted when the stream is flowing and the next doc is ready\n * @event `end`: Emitted when the stream is exhausted\n * @api public\n */\n\nfunction AggregationCursor(agg) {\n  // set autoDestroy=true because on node 12 it's by default false\n  // gh-10902 need autoDestroy to destroy correctly and emit 'close' event\n  Readable.call(this, { autoDestroy: true, objectMode: true });\n\n  this.cursor = null;\n  this.agg = agg;\n  this._transforms = [];\n  const model = agg._model;\n  delete agg.options.cursor.useMongooseAggCursor;\n  this._mongooseOptions = {};\n\n  _init(model, this, agg);\n}\n\nutil.inherits(AggregationCursor, Readable);\n\n/*!\n * ignore\n */\n\nfunction _init(model, c, agg) {\n  if (!model.collection.buffer) {\n    model.hooks.execPre('aggregate', agg, function() {\n      if (typeof agg.options?.cursor?.transform === 'function') {\n        c._transforms.push(agg.options.cursor.transform);\n      }\n\n      c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});\n      c.emit('cursor', c.cursor);\n    });\n  } else {\n    model.collection.emitter.once('queue', function() {\n      model.hooks.execPre('aggregate', agg, function() {\n        if (typeof agg.options?.cursor?.transform === 'function') {\n          c._transforms.push(agg.options.cursor.transform);\n        }\n\n        c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});\n        c.emit('cursor', c.cursor);\n      });\n    });\n  }\n}\n\n/**\n * Necessary to satisfy the Readable API\n * @method _read\n * @memberOf AggregationCursor\n * @instance\n * @api private\n */\n\nAggregationCursor.prototype._read = function() {\n  const _this = this;\n  _next(this, function(error, doc) {\n    if (error) {\n      return _this.emit('error', error);\n    }\n    if (!doc) {\n      _this.push(null);\n      _this.cursor.close(function(error) {\n        if (error) {\n          return _this.emit('error', error);\n        }\n      });\n      return;\n    }\n    _this.push(doc);\n  });\n};\n\nif (Symbol.asyncIterator != null) {\n  const msg = 'Mongoose does not support using async iterators with an ' +\n    'existing aggregation cursor. See https://bit.ly/mongoose-async-iterate-aggregation';\n\n  AggregationCursor.prototype[Symbol.asyncIterator] = function() {\n    throw new MongooseError(msg);\n  };\n}\n\n/**\n * Registers a transform function which subsequently maps documents retrieved\n * via the streams interface or `.next()`\n *\n * #### Example:\n *\n *     // Map documents returned by `data` events\n *     Thing.\n *       find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *        doc.foo = \"bar\";\n *        return doc;\n *       })\n *       on('data', function(doc) { console.log(doc.foo); });\n *\n *     // Or map documents returned by `.next()`\n *     const cursor = Thing.find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *         doc.foo = \"bar\";\n *         return doc;\n *       });\n *     cursor.next(function(error, doc) {\n *       console.log(doc.foo);\n *     });\n *\n * @param {Function} fn\n * @return {AggregationCursor}\n * @memberOf AggregationCursor\n * @api public\n * @method map\n */\n\nObject.defineProperty(AggregationCursor.prototype, 'map', {\n  value: function(fn) {\n    this._transforms.push(fn);\n    return this;\n  },\n  enumerable: true,\n  configurable: true,\n  writable: true\n});\n\n/**\n * Marks this cursor as errored\n * @method _markError\n * @instance\n * @memberOf AggregationCursor\n * @api private\n */\n\nAggregationCursor.prototype._markError = function(error) {\n  this._error = error;\n  return this;\n};\n\n/**\n * Marks this cursor as closed. Will stop streaming and subsequent calls to\n * `next()` will error.\n *\n * @param {Function} callback\n * @return {Promise}\n * @api public\n * @method close\n * @emits close\n * @see AggregationCursor.close https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html#close\n */\n\nAggregationCursor.prototype.close = async function close() {\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('AggregationCursor.prototype.close() no longer accepts a callback');\n  }\n  try {\n    await this.cursor.close();\n  } catch (error) {\n    this.listeners('error').length > 0 && this.emit('error', error);\n    throw error;\n  }\n  this.emit('close');\n};\n\n/**\n * Get the next document from this cursor. Will return `null` when there are\n * no documents left.\n *\n * @return {Promise}\n * @api public\n * @method next\n */\n\nAggregationCursor.prototype.next = async function next() {\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('AggregationCursor.prototype.next() no longer accepts a callback');\n  }\n  return new Promise((resolve, reject) => {\n    _next(this, (err, res) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n};\n\n/**\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\n * will wait for the promise to resolve before iterating on to the next one.\n * Returns a promise that resolves when done.\n *\n * @param {Function} fn\n * @param {Object} [options]\n * @param {Number} [options.parallel] the number of promises to execute in parallel. Defaults to 1.\n * @param {Number} [options.batchSize=null] if set, Mongoose will call `fn` with an array of at most `batchSize` documents, instead of a single document\n * @param {Boolean} [options.continueOnError=false] if true, `eachAsync()` iterates through all docs even if `fn` throws an error. If false, `eachAsync()` throws an error immediately if the given function `fn()` throws an error.\n * @return {Promise}\n * @api public\n * @method eachAsync\n */\n\nAggregationCursor.prototype.eachAsync = function(fn, opts) {\n  if (typeof arguments[2] === 'function') {\n    throw new MongooseError('AggregationCursor.prototype.eachAsync() no longer accepts a callback');\n  }\n  const _this = this;\n  if (typeof opts === 'function') {\n    opts = {};\n  }\n  opts = opts || {};\n\n  return eachAsync(function(cb) { return _next(_this, cb); }, fn, opts);\n};\n\n/**\n * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js)\n * You do not need to call this function explicitly, the JavaScript runtime\n * will call it for you.\n *\n * #### Example:\n *\n *     // Async iterator without explicitly calling `cursor()`. Mongoose still\n *     // creates an AggregationCursor instance internally.\n *     const agg = Model.aggregate([{ $match: { age: { $gte: 25 } } }]);\n *     for await (const doc of agg) {\n *       console.log(doc.name);\n *     }\n *\n *     // You can also use an AggregationCursor instance for async iteration\n *     const cursor = Model.aggregate([{ $match: { age: { $gte: 25 } } }]).cursor();\n *     for await (const doc of cursor) {\n *       console.log(doc.name);\n *     }\n *\n * Node.js 10.x supports async iterators natively without any flags. You can\n * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\n *\n * **Note:** This function is not set if `Symbol.asyncIterator` is undefined. If\n * `Symbol.asyncIterator` is undefined, that means your Node.js version does not\n * support async iterators.\n *\n * @method [Symbol.asyncIterator]\n * @memberOf AggregationCursor\n * @instance\n * @api public\n */\n\nif (Symbol.asyncIterator != null) {\n  AggregationCursor.prototype[Symbol.asyncIterator] = function() {\n    return this.transformNull()._transformForAsyncIterator();\n  };\n}\n\n/*!\n * ignore\n */\n\nAggregationCursor.prototype._transformForAsyncIterator = function() {\n  if (this._transforms.indexOf(_transformForAsyncIterator) === -1) {\n    this.map(_transformForAsyncIterator);\n  }\n  return this;\n};\n\n/*!\n * ignore\n */\n\nAggregationCursor.prototype.transformNull = function(val) {\n  if (arguments.length === 0) {\n    val = true;\n  }\n  this._mongooseOptions.transformNull = val;\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _transformForAsyncIterator(doc) {\n  return doc == null ? { done: true } : { value: doc, done: false };\n}\n\n/**\n * Adds a [cursor flag](https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html#addCursorFlag).\n * Useful for setting the `noCursorTimeout` and `tailable` flags.\n *\n * @param {String} flag\n * @param {Boolean} value\n * @return {AggregationCursor} this\n * @api public\n * @method addCursorFlag\n */\n\nAggregationCursor.prototype.addCursorFlag = function(flag, value) {\n  const _this = this;\n  _waitForCursor(this, function() {\n    _this.cursor.addCursorFlag(flag, value);\n  });\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _waitForCursor(ctx, cb) {\n  if (ctx.cursor) {\n    return cb();\n  }\n  ctx.once('cursor', function() {\n    cb();\n  });\n}\n\n/**\n * Get the next doc from the underlying cursor and mongooseify it\n * (populate, etc.)\n * @param {Any} ctx\n * @param {Function} cb\n * @api private\n */\n\nfunction _next(ctx, cb) {\n  let callback = cb;\n  if (ctx._transforms.length) {\n    callback = function(err, doc) {\n      if (err || (doc === null && !ctx._mongooseOptions.transformNull)) {\n        return cb(err, doc);\n      }\n      cb(err, ctx._transforms.reduce(function(doc, fn) {\n        return fn(doc);\n      }, doc));\n    };\n  }\n\n  if (ctx._error) {\n    return immediate(function() {\n      callback(ctx._error);\n    });\n  }\n\n  if (ctx.cursor) {\n    return ctx.cursor.next().then(\n      doc => {\n        if (!doc) {\n          return callback(null, null);\n        }\n\n        callback(null, doc);\n      },\n      err => callback(err)\n    );\n  } else {\n    ctx.once('cursor', function() {\n      _next(ctx, cb);\n    });\n  }\n}\n\nmodule.exports = AggregationCursor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2N1cnNvci9hZ2dyZWdhdGlvbkN1cnNvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsMkZBQXdCO0FBQ3RELGlCQUFpQixzREFBMEI7QUFDM0Msa0JBQWtCLG1CQUFPLENBQUMscUdBQTZCO0FBQ3ZELGtCQUFrQixtQkFBTyxDQUFDLHVGQUFzQjtBQUNoRCxhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFDQUFxQzs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0RUFBNEU7QUFDNUU7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEVBQThFO0FBQzlFO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLG9DQUFvQyx1QkFBdUI7QUFDM0Q7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQywwQkFBMEI7QUFDNUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFVBQVUsT0FBTyxjQUFjO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsVUFBVSxPQUFPLGNBQWM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsYUFBYSxJQUFJO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLFVBQVU7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2N1cnNvci9hZ2dyZWdhdGlvbkN1cnNvci5qcz8yNDVlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci9tb25nb29zZUVycm9yJyk7XG5jb25zdCBSZWFkYWJsZSA9IHJlcXVpcmUoJ3N0cmVhbScpLlJlYWRhYmxlO1xuY29uc3QgZWFjaEFzeW5jID0gcmVxdWlyZSgnLi4vaGVscGVycy9jdXJzb3IvZWFjaEFzeW5jJyk7XG5jb25zdCBpbW1lZGlhdGUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2ltbWVkaWF0ZScpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLyoqXG4gKiBBbiBBZ2dyZWdhdGlvbkN1cnNvciBpcyBhIGNvbmN1cnJlbmN5IHByaW1pdGl2ZSBmb3IgcHJvY2Vzc2luZyBhZ2dyZWdhdGlvblxuICogcmVzdWx0cyBvbmUgZG9jdW1lbnQgYXQgYSB0aW1lLiBJdCBpcyBhbmFsb2dvdXMgdG8gUXVlcnlDdXJzb3IuXG4gKlxuICogQW4gQWdncmVnYXRpb25DdXJzb3IgZnVsZmlsbHMgdGhlIE5vZGUuanMgc3RyZWFtczMgQVBJLFxuICogaW4gYWRkaXRpb24gdG8gc2V2ZXJhbCBvdGhlciBtZWNoYW5pc21zIGZvciBsb2FkaW5nIGRvY3VtZW50cyBmcm9tIE1vbmdvREJcbiAqIG9uZSBhdCBhIHRpbWUuXG4gKlxuICogQ3JlYXRpbmcgYW4gQWdncmVnYXRpb25DdXJzb3IgZXhlY3V0ZXMgdGhlIG1vZGVsJ3MgcHJlIGFnZ3JlZ2F0ZSBob29rcyxcbiAqIGJ1dCAqKm5vdCoqIHRoZSBtb2RlbCdzIHBvc3QgYWdncmVnYXRlIGhvb2tzLlxuICpcbiAqIFVubGVzcyB5b3UncmUgYW4gYWR2YW5jZWQgdXNlciwgZG8gKipub3QqKiBpbnN0YW50aWF0ZSB0aGlzIGNsYXNzIGRpcmVjdGx5LlxuICogVXNlIFtgQWdncmVnYXRlI2N1cnNvcigpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9hZ2dyZWdhdGUuaHRtbCNBZ2dyZWdhdGUucHJvdG90eXBlLmN1cnNvcigpKSBpbnN0ZWFkLlxuICpcbiAqIEBwYXJhbSB7QWdncmVnYXRlfSBhZ2dcbiAqIEBpbmhlcml0cyBSZWFkYWJsZSBodHRwczovL25vZGVqcy5vcmcvYXBpL3N0cmVhbS5odG1sI2NsYXNzLXN0cmVhbXJlYWRhYmxlXG4gKiBAZXZlbnQgYGN1cnNvcmA6IEVtaXR0ZWQgd2hlbiB0aGUgY3Vyc29yIGlzIGNyZWF0ZWRcbiAqIEBldmVudCBgZXJyb3JgOiBFbWl0dGVkIHdoZW4gYW4gZXJyb3Igb2NjdXJyZWRcbiAqIEBldmVudCBgZGF0YWA6IEVtaXR0ZWQgd2hlbiB0aGUgc3RyZWFtIGlzIGZsb3dpbmcgYW5kIHRoZSBuZXh0IGRvYyBpcyByZWFkeVxuICogQGV2ZW50IGBlbmRgOiBFbWl0dGVkIHdoZW4gdGhlIHN0cmVhbSBpcyBleGhhdXN0ZWRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gQWdncmVnYXRpb25DdXJzb3IoYWdnKSB7XG4gIC8vIHNldCBhdXRvRGVzdHJveT10cnVlIGJlY2F1c2Ugb24gbm9kZSAxMiBpdCdzIGJ5IGRlZmF1bHQgZmFsc2VcbiAgLy8gZ2gtMTA5MDIgbmVlZCBhdXRvRGVzdHJveSB0byBkZXN0cm95IGNvcnJlY3RseSBhbmQgZW1pdCAnY2xvc2UnIGV2ZW50XG4gIFJlYWRhYmxlLmNhbGwodGhpcywgeyBhdXRvRGVzdHJveTogdHJ1ZSwgb2JqZWN0TW9kZTogdHJ1ZSB9KTtcblxuICB0aGlzLmN1cnNvciA9IG51bGw7XG4gIHRoaXMuYWdnID0gYWdnO1xuICB0aGlzLl90cmFuc2Zvcm1zID0gW107XG4gIGNvbnN0IG1vZGVsID0gYWdnLl9tb2RlbDtcbiAgZGVsZXRlIGFnZy5vcHRpb25zLmN1cnNvci51c2VNb25nb29zZUFnZ0N1cnNvcjtcbiAgdGhpcy5fbW9uZ29vc2VPcHRpb25zID0ge307XG5cbiAgX2luaXQobW9kZWwsIHRoaXMsIGFnZyk7XG59XG5cbnV0aWwuaW5oZXJpdHMoQWdncmVnYXRpb25DdXJzb3IsIFJlYWRhYmxlKTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfaW5pdChtb2RlbCwgYywgYWdnKSB7XG4gIGlmICghbW9kZWwuY29sbGVjdGlvbi5idWZmZXIpIHtcbiAgICBtb2RlbC5ob29rcy5leGVjUHJlKCdhZ2dyZWdhdGUnLCBhZ2csIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHR5cGVvZiBhZ2cub3B0aW9ucz8uY3Vyc29yPy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgYy5fdHJhbnNmb3Jtcy5wdXNoKGFnZy5vcHRpb25zLmN1cnNvci50cmFuc2Zvcm0pO1xuICAgICAgfVxuXG4gICAgICBjLmN1cnNvciA9IG1vZGVsLmNvbGxlY3Rpb24uYWdncmVnYXRlKGFnZy5fcGlwZWxpbmUsIGFnZy5vcHRpb25zIHx8IHt9KTtcbiAgICAgIGMuZW1pdCgnY3Vyc29yJywgYy5jdXJzb3IpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG1vZGVsLmNvbGxlY3Rpb24uZW1pdHRlci5vbmNlKCdxdWV1ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgbW9kZWwuaG9va3MuZXhlY1ByZSgnYWdncmVnYXRlJywgYWdnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhZ2cub3B0aW9ucz8uY3Vyc29yPy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjLl90cmFuc2Zvcm1zLnB1c2goYWdnLm9wdGlvbnMuY3Vyc29yLnRyYW5zZm9ybSk7XG4gICAgICAgIH1cblxuICAgICAgICBjLmN1cnNvciA9IG1vZGVsLmNvbGxlY3Rpb24uYWdncmVnYXRlKGFnZy5fcGlwZWxpbmUsIGFnZy5vcHRpb25zIHx8IHt9KTtcbiAgICAgICAgYy5lbWl0KCdjdXJzb3InLCBjLmN1cnNvcik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIE5lY2Vzc2FyeSB0byBzYXRpc2Z5IHRoZSBSZWFkYWJsZSBBUElcbiAqIEBtZXRob2QgX3JlYWRcbiAqIEBtZW1iZXJPZiBBZ2dyZWdhdGlvbkN1cnNvclxuICogQGluc3RhbmNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5BZ2dyZWdhdGlvbkN1cnNvci5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICBfbmV4dCh0aGlzLCBmdW5jdGlvbihlcnJvciwgZG9jKSB7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICByZXR1cm4gX3RoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgfVxuICAgIGlmICghZG9jKSB7XG4gICAgICBfdGhpcy5wdXNoKG51bGwpO1xuICAgICAgX3RoaXMuY3Vyc29yLmNsb3NlKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIF90aGlzLnB1c2goZG9jKTtcbiAgfSk7XG59O1xuXG5pZiAoU3ltYm9sLmFzeW5jSXRlcmF0b3IgIT0gbnVsbCkge1xuICBjb25zdCBtc2cgPSAnTW9uZ29vc2UgZG9lcyBub3Qgc3VwcG9ydCB1c2luZyBhc3luYyBpdGVyYXRvcnMgd2l0aCBhbiAnICtcbiAgICAnZXhpc3RpbmcgYWdncmVnYXRpb24gY3Vyc29yLiBTZWUgaHR0cHM6Ly9iaXQubHkvbW9uZ29vc2UtYXN5bmMtaXRlcmF0ZS1hZ2dyZWdhdGlvbic7XG5cbiAgQWdncmVnYXRpb25DdXJzb3IucHJvdG90eXBlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKG1zZyk7XG4gIH07XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHdoaWNoIHN1YnNlcXVlbnRseSBtYXBzIGRvY3VtZW50cyByZXRyaWV2ZWRcbiAqIHZpYSB0aGUgc3RyZWFtcyBpbnRlcmZhY2Ugb3IgYC5uZXh0KClgXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYXAgZG9jdW1lbnRzIHJldHVybmVkIGJ5IGBkYXRhYCBldmVudHNcbiAqICAgICBUaGluZy5cbiAqICAgICAgIGZpbmQoeyBuYW1lOiAvXmhlbGxvLyB9KS5cbiAqICAgICAgIGN1cnNvcigpLlxuICogICAgICAgbWFwKGZ1bmN0aW9uIChkb2MpIHtcbiAqICAgICAgICBkb2MuZm9vID0gXCJiYXJcIjtcbiAqICAgICAgICByZXR1cm4gZG9jO1xuICogICAgICAgfSlcbiAqICAgICAgIG9uKCdkYXRhJywgZnVuY3Rpb24oZG9jKSB7IGNvbnNvbGUubG9nKGRvYy5mb28pOyB9KTtcbiAqXG4gKiAgICAgLy8gT3IgbWFwIGRvY3VtZW50cyByZXR1cm5lZCBieSBgLm5leHQoKWBcbiAqICAgICBjb25zdCBjdXJzb3IgPSBUaGluZy5maW5kKHsgbmFtZTogL15oZWxsby8gfSkuXG4gKiAgICAgICBjdXJzb3IoKS5cbiAqICAgICAgIG1hcChmdW5jdGlvbiAoZG9jKSB7XG4gKiAgICAgICAgIGRvYy5mb28gPSBcImJhclwiO1xuICogICAgICAgICByZXR1cm4gZG9jO1xuICogICAgICAgfSk7XG4gKiAgICAgY3Vyc29yLm5leHQoZnVuY3Rpb24oZXJyb3IsIGRvYykge1xuICogICAgICAgY29uc29sZS5sb2coZG9jLmZvbyk7XG4gKiAgICAgfSk7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0FnZ3JlZ2F0aW9uQ3Vyc29yfVxuICogQG1lbWJlck9mIEFnZ3JlZ2F0aW9uQ3Vyc29yXG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCBtYXBcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQWdncmVnYXRpb25DdXJzb3IucHJvdG90eXBlLCAnbWFwJywge1xuICB2YWx1ZTogZnVuY3Rpb24oZm4pIHtcbiAgICB0aGlzLl90cmFuc2Zvcm1zLnB1c2goZm4pO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlXG59KTtcblxuLyoqXG4gKiBNYXJrcyB0aGlzIGN1cnNvciBhcyBlcnJvcmVkXG4gKiBAbWV0aG9kIF9tYXJrRXJyb3JcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlck9mIEFnZ3JlZ2F0aW9uQ3Vyc29yXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5BZ2dyZWdhdGlvbkN1cnNvci5wcm90b3R5cGUuX21hcmtFcnJvciA9IGZ1bmN0aW9uKGVycm9yKSB7XG4gIHRoaXMuX2Vycm9yID0gZXJyb3I7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBNYXJrcyB0aGlzIGN1cnNvciBhcyBjbG9zZWQuIFdpbGwgc3RvcCBzdHJlYW1pbmcgYW5kIHN1YnNlcXVlbnQgY2FsbHMgdG9cbiAqIGBuZXh0KClgIHdpbGwgZXJyb3IuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCBjbG9zZVxuICogQGVtaXRzIGNsb3NlXG4gKiBAc2VlIEFnZ3JlZ2F0aW9uQ3Vyc29yLmNsb3NlIGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9BZ2dyZWdhdGlvbkN1cnNvci5odG1sI2Nsb3NlXG4gKi9cblxuQWdncmVnYXRpb25DdXJzb3IucHJvdG90eXBlLmNsb3NlID0gYXN5bmMgZnVuY3Rpb24gY2xvc2UoKSB7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0FnZ3JlZ2F0aW9uQ3Vyc29yLnByb3RvdHlwZS5jbG9zZSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuICB0cnkge1xuICAgIGF3YWl0IHRoaXMuY3Vyc29yLmNsb3NlKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMoJ2Vycm9yJykubGVuZ3RoID4gMCAmJiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG4gIHRoaXMuZW1pdCgnY2xvc2UnKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBuZXh0IGRvY3VtZW50IGZyb20gdGhpcyBjdXJzb3IuIFdpbGwgcmV0dXJuIGBudWxsYCB3aGVuIHRoZXJlIGFyZVxuICogbm8gZG9jdW1lbnRzIGxlZnQuXG4gKlxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kIG5leHRcbiAqL1xuXG5BZ2dyZWdhdGlvbkN1cnNvci5wcm90b3R5cGUubmV4dCA9IGFzeW5jIGZ1bmN0aW9uIG5leHQoKSB7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0FnZ3JlZ2F0aW9uQ3Vyc29yLnByb3RvdHlwZS5uZXh0KCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgX25leHQodGhpcywgKGVyciwgcmVzKSA9PiB7XG4gICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShyZXMpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZSBgZm5gIGZvciBldmVyeSBkb2N1bWVudCBpbiB0aGUgY3Vyc29yLiBJZiBgZm5gIHJldHVybnMgYSBwcm9taXNlLFxuICogd2lsbCB3YWl0IGZvciB0aGUgcHJvbWlzZSB0byByZXNvbHZlIGJlZm9yZSBpdGVyYXRpbmcgb24gdG8gdGhlIG5leHQgb25lLlxuICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIGRvbmUuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wYXJhbGxlbF0gdGhlIG51bWJlciBvZiBwcm9taXNlcyB0byBleGVjdXRlIGluIHBhcmFsbGVsLiBEZWZhdWx0cyB0byAxLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJhdGNoU2l6ZT1udWxsXSBpZiBzZXQsIE1vbmdvb3NlIHdpbGwgY2FsbCBgZm5gIHdpdGggYW4gYXJyYXkgb2YgYXQgbW9zdCBgYmF0Y2hTaXplYCBkb2N1bWVudHMsIGluc3RlYWQgb2YgYSBzaW5nbGUgZG9jdW1lbnRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY29udGludWVPbkVycm9yPWZhbHNlXSBpZiB0cnVlLCBgZWFjaEFzeW5jKClgIGl0ZXJhdGVzIHRocm91Z2ggYWxsIGRvY3MgZXZlbiBpZiBgZm5gIHRocm93cyBhbiBlcnJvci4gSWYgZmFsc2UsIGBlYWNoQXN5bmMoKWAgdGhyb3dzIGFuIGVycm9yIGltbWVkaWF0ZWx5IGlmIHRoZSBnaXZlbiBmdW5jdGlvbiBgZm4oKWAgdGhyb3dzIGFuIGVycm9yLlxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kIGVhY2hBc3luY1xuICovXG5cbkFnZ3JlZ2F0aW9uQ3Vyc29yLnByb3RvdHlwZS5lYWNoQXN5bmMgPSBmdW5jdGlvbihmbiwgb3B0cykge1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdBZ2dyZWdhdGlvbkN1cnNvci5wcm90b3R5cGUuZWFjaEFzeW5jKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG4gIGNvbnN0IF90aGlzID0gdGhpcztcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHJldHVybiBlYWNoQXN5bmMoZnVuY3Rpb24oY2IpIHsgcmV0dXJuIF9uZXh0KF90aGlzLCBjYik7IH0sIGZuLCBvcHRzKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBhc3luY0l0ZXJhdG9yIGZvciB1c2Ugd2l0aCBbYGZvci9hd2FpdC9vZmAgbG9vcHNdKGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vZ2V0dGluZy1zdGFydGVkLXdpdGgtYXN5bmMtaXRlcmF0b3JzLWluLW5vZGUtanMpXG4gKiBZb3UgZG8gbm90IG5lZWQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIGV4cGxpY2l0bHksIHRoZSBKYXZhU2NyaXB0IHJ1bnRpbWVcbiAqIHdpbGwgY2FsbCBpdCBmb3IgeW91LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gQXN5bmMgaXRlcmF0b3Igd2l0aG91dCBleHBsaWNpdGx5IGNhbGxpbmcgYGN1cnNvcigpYC4gTW9uZ29vc2Ugc3RpbGxcbiAqICAgICAvLyBjcmVhdGVzIGFuIEFnZ3JlZ2F0aW9uQ3Vyc29yIGluc3RhbmNlIGludGVybmFsbHkuXG4gKiAgICAgY29uc3QgYWdnID0gTW9kZWwuYWdncmVnYXRlKFt7ICRtYXRjaDogeyBhZ2U6IHsgJGd0ZTogMjUgfSB9IH1dKTtcbiAqICAgICBmb3IgYXdhaXQgKGNvbnN0IGRvYyBvZiBhZ2cpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKGRvYy5uYW1lKTtcbiAqICAgICB9XG4gKlxuICogICAgIC8vIFlvdSBjYW4gYWxzbyB1c2UgYW4gQWdncmVnYXRpb25DdXJzb3IgaW5zdGFuY2UgZm9yIGFzeW5jIGl0ZXJhdGlvblxuICogICAgIGNvbnN0IGN1cnNvciA9IE1vZGVsLmFnZ3JlZ2F0ZShbeyAkbWF0Y2g6IHsgYWdlOiB7ICRndGU6IDI1IH0gfSB9XSkuY3Vyc29yKCk7XG4gKiAgICAgZm9yIGF3YWl0IChjb25zdCBkb2Mgb2YgY3Vyc29yKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyhkb2MubmFtZSk7XG4gKiAgICAgfVxuICpcbiAqIE5vZGUuanMgMTAueCBzdXBwb3J0cyBhc3luYyBpdGVyYXRvcnMgbmF0aXZlbHkgd2l0aG91dCBhbnkgZmxhZ3MuIFlvdSBjYW5cbiAqIGVuYWJsZSBhc3luYyBpdGVyYXRvcnMgaW4gTm9kZS5qcyA4LnggdXNpbmcgdGhlIFtgLS1oYXJtb255X2FzeW5jX2l0ZXJhdGlvbmAgZmxhZ10oaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtYXN5bmMtaXRlcmF0aW9uL2lzc3Vlcy8xMTcjaXNzdWVjb21tZW50LTM0NjY5NTE4NykuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgbm90IHNldCBpZiBgU3ltYm9sLmFzeW5jSXRlcmF0b3JgIGlzIHVuZGVmaW5lZC4gSWZcbiAqIGBTeW1ib2wuYXN5bmNJdGVyYXRvcmAgaXMgdW5kZWZpbmVkLCB0aGF0IG1lYW5zIHlvdXIgTm9kZS5qcyB2ZXJzaW9uIGRvZXMgbm90XG4gKiBzdXBwb3J0IGFzeW5jIGl0ZXJhdG9ycy5cbiAqXG4gKiBAbWV0aG9kIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl1cbiAqIEBtZW1iZXJPZiBBZ2dyZWdhdGlvbkN1cnNvclxuICogQGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmlmIChTeW1ib2wuYXN5bmNJdGVyYXRvciAhPSBudWxsKSB7XG4gIEFnZ3JlZ2F0aW9uQ3Vyc29yLnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1OdWxsKCkuX3RyYW5zZm9ybUZvckFzeW5jSXRlcmF0b3IoKTtcbiAgfTtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5BZ2dyZWdhdGlvbkN1cnNvci5wcm90b3R5cGUuX3RyYW5zZm9ybUZvckFzeW5jSXRlcmF0b3IgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX3RyYW5zZm9ybXMuaW5kZXhPZihfdHJhbnNmb3JtRm9yQXN5bmNJdGVyYXRvcikgPT09IC0xKSB7XG4gICAgdGhpcy5tYXAoX3RyYW5zZm9ybUZvckFzeW5jSXRlcmF0b3IpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5BZ2dyZWdhdGlvbkN1cnNvci5wcm90b3R5cGUudHJhbnNmb3JtTnVsbCA9IGZ1bmN0aW9uKHZhbCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHZhbCA9IHRydWU7XG4gIH1cbiAgdGhpcy5fbW9uZ29vc2VPcHRpb25zLnRyYW5zZm9ybU51bGwgPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfdHJhbnNmb3JtRm9yQXN5bmNJdGVyYXRvcihkb2MpIHtcbiAgcmV0dXJuIGRvYyA9PSBudWxsID8geyBkb25lOiB0cnVlIH0gOiB7IHZhbHVlOiBkb2MsIGRvbmU6IGZhbHNlIH07XG59XG5cbi8qKlxuICogQWRkcyBhIFtjdXJzb3IgZmxhZ10oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0FnZ3JlZ2F0aW9uQ3Vyc29yLmh0bWwjYWRkQ3Vyc29yRmxhZykuXG4gKiBVc2VmdWwgZm9yIHNldHRpbmcgdGhlIGBub0N1cnNvclRpbWVvdXRgIGFuZCBgdGFpbGFibGVgIGZsYWdzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmbGFnXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlXG4gKiBAcmV0dXJuIHtBZ2dyZWdhdGlvbkN1cnNvcn0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgYWRkQ3Vyc29yRmxhZ1xuICovXG5cbkFnZ3JlZ2F0aW9uQ3Vyc29yLnByb3RvdHlwZS5hZGRDdXJzb3JGbGFnID0gZnVuY3Rpb24oZmxhZywgdmFsdWUpIHtcbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICBfd2FpdEZvckN1cnNvcih0aGlzLCBmdW5jdGlvbigpIHtcbiAgICBfdGhpcy5jdXJzb3IuYWRkQ3Vyc29yRmxhZyhmbGFnLCB2YWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX3dhaXRGb3JDdXJzb3IoY3R4LCBjYikge1xuICBpZiAoY3R4LmN1cnNvcikge1xuICAgIHJldHVybiBjYigpO1xuICB9XG4gIGN0eC5vbmNlKCdjdXJzb3InLCBmdW5jdGlvbigpIHtcbiAgICBjYigpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG5leHQgZG9jIGZyb20gdGhlIHVuZGVybHlpbmcgY3Vyc29yIGFuZCBtb25nb29zZWlmeSBpdFxuICogKHBvcHVsYXRlLCBldGMuKVxuICogQHBhcmFtIHtBbnl9IGN0eFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIF9uZXh0KGN0eCwgY2IpIHtcbiAgbGV0IGNhbGxiYWNrID0gY2I7XG4gIGlmIChjdHguX3RyYW5zZm9ybXMubGVuZ3RoKSB7XG4gICAgY2FsbGJhY2sgPSBmdW5jdGlvbihlcnIsIGRvYykge1xuICAgICAgaWYgKGVyciB8fCAoZG9jID09PSBudWxsICYmICFjdHguX21vbmdvb3NlT3B0aW9ucy50cmFuc2Zvcm1OdWxsKSkge1xuICAgICAgICByZXR1cm4gY2IoZXJyLCBkb2MpO1xuICAgICAgfVxuICAgICAgY2IoZXJyLCBjdHguX3RyYW5zZm9ybXMucmVkdWNlKGZ1bmN0aW9uKGRvYywgZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuKGRvYyk7XG4gICAgICB9LCBkb2MpKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKGN0eC5fZXJyb3IpIHtcbiAgICByZXR1cm4gaW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgY2FsbGJhY2soY3R4Ll9lcnJvcik7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoY3R4LmN1cnNvcikge1xuICAgIHJldHVybiBjdHguY3Vyc29yLm5leHQoKS50aGVuKFxuICAgICAgZG9jID0+IHtcbiAgICAgICAgaWYgKCFkb2MpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgbnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjayhudWxsLCBkb2MpO1xuICAgICAgfSxcbiAgICAgIGVyciA9PiBjYWxsYmFjayhlcnIpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBjdHgub25jZSgnY3Vyc29yJywgZnVuY3Rpb24oKSB7XG4gICAgICBfbmV4dChjdHgsIGNiKTtcbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFnZ3JlZ2F0aW9uQ3Vyc29yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/cursor/aggregationCursor.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/cursor/changeStream.js":
/*!*******************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/cursor/changeStream.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\n\n/*!\n * ignore\n */\n\nconst driverChangeStreamEvents = ['close', 'change', 'end', 'error', 'resumeTokenChanged'];\n\n/*!\n * ignore\n */\n\nclass ChangeStream extends EventEmitter {\n  constructor(changeStreamThunk, pipeline, options) {\n    super();\n\n    this.driverChangeStream = null;\n    this.closed = false;\n    this.bindedEvents = false;\n    this.pipeline = pipeline;\n    this.options = options;\n\n    if (options && options.hydrate && !options.model) {\n      throw new Error(\n        'Cannot create change stream with `hydrate: true` ' +\n        'unless calling `Model.watch()`'\n      );\n    }\n\n    // This wrapper is necessary because of buffering.\n    changeStreamThunk((err, driverChangeStream) => {\n      if (err != null) {\n        this.emit('error', err);\n        return;\n      }\n\n      this.driverChangeStream = driverChangeStream;\n      this.emit('ready');\n    });\n  }\n\n  _bindEvents() {\n    if (this.bindedEvents) {\n      return;\n    }\n\n    this.bindedEvents = true;\n\n    if (this.driverChangeStream == null) {\n      this.once('ready', () => {\n        this.driverChangeStream.on('close', () => {\n          this.closed = true;\n        });\n\n        driverChangeStreamEvents.forEach(ev => {\n          this.driverChangeStream.on(ev, data => {\n            if (data != null && data.fullDocument != null && this.options && this.options.hydrate) {\n              data.fullDocument = this.options.model.hydrate(data.fullDocument);\n            }\n            this.emit(ev, data);\n          });\n        });\n      });\n\n      return;\n    }\n\n    this.driverChangeStream.on('close', () => {\n      this.closed = true;\n    });\n\n    driverChangeStreamEvents.forEach(ev => {\n      this.driverChangeStream.on(ev, data => {\n        if (data != null && data.fullDocument != null && this.options && this.options.hydrate) {\n          data.fullDocument = this.options.model.hydrate(data.fullDocument);\n        }\n        this.emit(ev, data);\n      });\n    });\n  }\n\n  hasNext(cb) {\n    return this.driverChangeStream.hasNext(cb);\n  }\n\n  next(cb) {\n    if (this.options && this.options.hydrate) {\n      if (cb != null) {\n        const originalCb = cb;\n        cb = (err, data) => {\n          if (err != null) {\n            return originalCb(err);\n          }\n          if (data.fullDocument != null) {\n            data.fullDocument = this.options.model.hydrate(data.fullDocument);\n          }\n          return originalCb(null, data);\n        };\n      }\n\n      let maybePromise = this.driverChangeStream.next(cb);\n      if (maybePromise && typeof maybePromise.then === 'function') {\n        maybePromise = maybePromise.then(data => {\n          if (data.fullDocument != null) {\n            data.fullDocument = this.options.model.hydrate(data.fullDocument);\n          }\n          return data;\n        });\n      }\n      return maybePromise;\n    }\n\n    return this.driverChangeStream.next(cb);\n  }\n\n  addListener(event, handler) {\n    this._bindEvents();\n    return super.addListener(event, handler);\n  }\n\n  on(event, handler) {\n    this._bindEvents();\n    return super.on(event, handler);\n  }\n\n  once(event, handler) {\n    this._bindEvents();\n    return super.once(event, handler);\n  }\n\n  _queue(cb) {\n    this.once('ready', () => cb());\n  }\n\n  close() {\n    this.closed = true;\n    if (this.driverChangeStream) {\n      this.driverChangeStream.close();\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nmodule.exports = ChangeStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2N1cnNvci9jaGFuZ2VTdHJlYW0uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLHFCQUFxQiwwREFBOEI7O0FBRW5EO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY3Vyc29yL2NoYW5nZVN0cmVhbS5qcz8yZWYyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5jb25zdCBkcml2ZXJDaGFuZ2VTdHJlYW1FdmVudHMgPSBbJ2Nsb3NlJywgJ2NoYW5nZScsICdlbmQnLCAnZXJyb3InLCAncmVzdW1lVG9rZW5DaGFuZ2VkJ107XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuY2xhc3MgQ2hhbmdlU3RyZWFtIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoY2hhbmdlU3RyZWFtVGh1bmssIHBpcGVsaW5lLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuZHJpdmVyQ2hhbmdlU3RyZWFtID0gbnVsbDtcbiAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgIHRoaXMuYmluZGVkRXZlbnRzID0gZmFsc2U7XG4gICAgdGhpcy5waXBlbGluZSA9IHBpcGVsaW5lO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmh5ZHJhdGUgJiYgIW9wdGlvbnMubW9kZWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCBjcmVhdGUgY2hhbmdlIHN0cmVhbSB3aXRoIGBoeWRyYXRlOiB0cnVlYCAnICtcbiAgICAgICAgJ3VubGVzcyBjYWxsaW5nIGBNb2RlbC53YXRjaCgpYCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyB3cmFwcGVyIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIG9mIGJ1ZmZlcmluZy5cbiAgICBjaGFuZ2VTdHJlYW1UaHVuaygoZXJyLCBkcml2ZXJDaGFuZ2VTdHJlYW0pID0+IHtcbiAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRyaXZlckNoYW5nZVN0cmVhbSA9IGRyaXZlckNoYW5nZVN0cmVhbTtcbiAgICAgIHRoaXMuZW1pdCgncmVhZHknKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9iaW5kRXZlbnRzKCkge1xuICAgIGlmICh0aGlzLmJpbmRlZEV2ZW50cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYmluZGVkRXZlbnRzID0gdHJ1ZTtcblxuICAgIGlmICh0aGlzLmRyaXZlckNoYW5nZVN0cmVhbSA9PSBudWxsKSB7XG4gICAgICB0aGlzLm9uY2UoJ3JlYWR5JywgKCkgPT4ge1xuICAgICAgICB0aGlzLmRyaXZlckNoYW5nZVN0cmVhbS5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICBkcml2ZXJDaGFuZ2VTdHJlYW1FdmVudHMuZm9yRWFjaChldiA9PiB7XG4gICAgICAgICAgdGhpcy5kcml2ZXJDaGFuZ2VTdHJlYW0ub24oZXYsIGRhdGEgPT4ge1xuICAgICAgICAgICAgaWYgKGRhdGEgIT0gbnVsbCAmJiBkYXRhLmZ1bGxEb2N1bWVudCAhPSBudWxsICYmIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuaHlkcmF0ZSkge1xuICAgICAgICAgICAgICBkYXRhLmZ1bGxEb2N1bWVudCA9IHRoaXMub3B0aW9ucy5tb2RlbC5oeWRyYXRlKGRhdGEuZnVsbERvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW1pdChldiwgZGF0YSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmRyaXZlckNoYW5nZVN0cmVhbS5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgfSk7XG5cbiAgICBkcml2ZXJDaGFuZ2VTdHJlYW1FdmVudHMuZm9yRWFjaChldiA9PiB7XG4gICAgICB0aGlzLmRyaXZlckNoYW5nZVN0cmVhbS5vbihldiwgZGF0YSA9PiB7XG4gICAgICAgIGlmIChkYXRhICE9IG51bGwgJiYgZGF0YS5mdWxsRG9jdW1lbnQgIT0gbnVsbCAmJiB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLmh5ZHJhdGUpIHtcbiAgICAgICAgICBkYXRhLmZ1bGxEb2N1bWVudCA9IHRoaXMub3B0aW9ucy5tb2RlbC5oeWRyYXRlKGRhdGEuZnVsbERvY3VtZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoZXYsIGRhdGEpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBoYXNOZXh0KGNiKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJpdmVyQ2hhbmdlU3RyZWFtLmhhc05leHQoY2IpO1xuICB9XG5cbiAgbmV4dChjYikge1xuICAgIGlmICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLmh5ZHJhdGUpIHtcbiAgICAgIGlmIChjYiAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsQ2IgPSBjYjtcbiAgICAgICAgY2IgPSAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxDYihlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGF0YS5mdWxsRG9jdW1lbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgZGF0YS5mdWxsRG9jdW1lbnQgPSB0aGlzLm9wdGlvbnMubW9kZWwuaHlkcmF0ZShkYXRhLmZ1bGxEb2N1bWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvcmlnaW5hbENiKG51bGwsIGRhdGEpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBsZXQgbWF5YmVQcm9taXNlID0gdGhpcy5kcml2ZXJDaGFuZ2VTdHJlYW0ubmV4dChjYik7XG4gICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBtYXliZVByb21pc2UgPSBtYXliZVByb21pc2UudGhlbihkYXRhID0+IHtcbiAgICAgICAgICBpZiAoZGF0YS5mdWxsRG9jdW1lbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgZGF0YS5mdWxsRG9jdW1lbnQgPSB0aGlzLm9wdGlvbnMubW9kZWwuaHlkcmF0ZShkYXRhLmZ1bGxEb2N1bWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXliZVByb21pc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZHJpdmVyQ2hhbmdlU3RyZWFtLm5leHQoY2IpO1xuICB9XG5cbiAgYWRkTGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XG4gICAgcmV0dXJuIHN1cGVyLmFkZExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyKTtcbiAgfVxuXG4gIG9uKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgdGhpcy5fYmluZEV2ZW50cygpO1xuICAgIHJldHVybiBzdXBlci5vbihldmVudCwgaGFuZGxlcik7XG4gIH1cblxuICBvbmNlKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgdGhpcy5fYmluZEV2ZW50cygpO1xuICAgIHJldHVybiBzdXBlci5vbmNlKGV2ZW50LCBoYW5kbGVyKTtcbiAgfVxuXG4gIF9xdWV1ZShjYikge1xuICAgIHRoaXMub25jZSgncmVhZHknLCAoKSA9PiBjYigpKTtcbiAgfVxuXG4gIGNsb3NlKCkge1xuICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5kcml2ZXJDaGFuZ2VTdHJlYW0pIHtcbiAgICAgIHRoaXMuZHJpdmVyQ2hhbmdlU3RyZWFtLmNsb3NlKCk7XG4gICAgfVxuICB9XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBDaGFuZ2VTdHJlYW07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/cursor/changeStream.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/cursor/queryCursor.js":
/*!******************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/cursor/queryCursor.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ../error/mongooseError */ \"../backend/node_modules/mongoose/lib/error/mongooseError.js\");\nconst Readable = (__webpack_require__(/*! stream */ \"stream\").Readable);\nconst eachAsync = __webpack_require__(/*! ../helpers/cursor/eachAsync */ \"../backend/node_modules/mongoose/lib/helpers/cursor/eachAsync.js\");\nconst helpers = __webpack_require__(/*! ../queryHelpers */ \"../backend/node_modules/mongoose/lib/queryHelpers.js\");\nconst kareem = __webpack_require__(/*! kareem */ \"../backend/node_modules/kareem/index.js\");\nconst immediate = __webpack_require__(/*! ../helpers/immediate */ \"../backend/node_modules/mongoose/lib/helpers/immediate.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\n/**\n * A QueryCursor is a concurrency primitive for processing query results\n * one document at a time. A QueryCursor fulfills the Node.js streams3 API,\n * in addition to several other mechanisms for loading documents from MongoDB\n * one at a time.\n *\n * QueryCursors execute the model's pre `find` hooks before loading any documents\n * from MongoDB, and the model's post `find` hooks after loading each document.\n *\n * Unless you're an advanced user, do **not** instantiate this class directly.\n * Use [`Query#cursor()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.cursor()) instead.\n *\n * @param {Query} query\n * @param {Object} options query options passed to `.find()`\n * @inherits Readable https://nodejs.org/api/stream.html#class-streamreadable\n * @event `cursor`: Emitted when the cursor is created\n * @event `error`: Emitted when an error occurred\n * @event `data`: Emitted when the stream is flowing and the next doc is ready\n * @event `end`: Emitted when the stream is exhausted\n * @api public\n */\n\nfunction QueryCursor(query) {\n  // set autoDestroy=true because on node 12 it's by default false\n  // gh-10902 need autoDestroy to destroy correctly and emit 'close' event\n  Readable.call(this, { autoDestroy: true, objectMode: true });\n\n  this.cursor = null;\n  this.skipped = false;\n  this.query = query;\n  const model = query.model;\n  this._mongooseOptions = {};\n  this._transforms = [];\n  this.model = model;\n  this.options = {};\n  model.hooks.execPre('find', query, (err) => {\n    if (err != null) {\n      if (err instanceof kareem.skipWrappedFunction) {\n        const resultValue = err.args[0];\n        if (resultValue != null && (!Array.isArray(resultValue) || resultValue.length)) {\n          const err = new MongooseError(\n            'Cannot `skipMiddlewareFunction()` with a value when using ' +\n            '`.find().cursor()`, value must be nullish or empty array, got \"' +\n            util.inspect(resultValue) +\n            '\".'\n          );\n          this._markError(err);\n          this.listeners('error').length > 0 && this.emit('error', err);\n          return;\n        }\n        this.skipped = true;\n        this.emit('cursor', null);\n        return;\n      }\n      this._markError(err);\n      this.listeners('error').length > 0 && this.emit('error', err);\n      return;\n    }\n    Object.assign(this.options, query._optionsForExec());\n    this._transforms = this._transforms.concat(query._transforms.slice());\n    if (this.options.transform) {\n      this._transforms.push(this.options.transform);\n    }\n    // Re: gh-8039, you need to set the `cursor.batchSize` option, top-level\n    // `batchSize` option doesn't work.\n    if (this.options.batchSize) {\n      // Max out the number of documents we'll populate in parallel at 5000.\n      this.options._populateBatchSize = Math.min(this.options.batchSize, 5000);\n    }\n\n    if (model.collection._shouldBufferCommands() && model.collection.buffer) {\n      model.collection.queue.push([\n        () => _getRawCursor(query, this)\n      ]);\n    } else {\n      _getRawCursor(query, this);\n    }\n  });\n}\n\nutil.inherits(QueryCursor, Readable);\n\n/*!\n * ignore\n */\n\nfunction _getRawCursor(query, queryCursor) {\n  try {\n    const cursor = query.model.collection.find(query._conditions, queryCursor.options);\n    queryCursor.cursor = cursor;\n    queryCursor.emit('cursor', cursor);\n  } catch (err) {\n    queryCursor._markError(err);\n    queryCursor.listeners('error').length > 0 && queryCursor.emit('error', queryCursor._error);\n  }\n}\n\n/**\n * Necessary to satisfy the Readable API\n * @method _read\n * @memberOf QueryCursor\n * @instance\n * @api private\n */\n\nQueryCursor.prototype._read = function() {\n  _next(this, (error, doc) => {\n    if (error) {\n      return this.emit('error', error);\n    }\n    if (!doc) {\n      this.push(null);\n      this.cursor.close(function(error) {\n        if (error) {\n          return this.emit('error', error);\n        }\n      });\n      return;\n    }\n    this.push(doc);\n  });\n};\n\n/**\n * Registers a transform function which subsequently maps documents retrieved\n * via the streams interface or `.next()`\n *\n * #### Example:\n *\n *     // Map documents returned by `data` events\n *     Thing.\n *       find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *        doc.foo = \"bar\";\n *        return doc;\n *       })\n *       on('data', function(doc) { console.log(doc.foo); });\n *\n *     // Or map documents returned by `.next()`\n *     const cursor = Thing.find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *         doc.foo = \"bar\";\n *         return doc;\n *       });\n *     cursor.next(function(error, doc) {\n *       console.log(doc.foo);\n *     });\n *\n * @param {Function} fn\n * @return {QueryCursor}\n * @memberOf QueryCursor\n * @api public\n * @method map\n */\n\nObject.defineProperty(QueryCursor.prototype, 'map', {\n  value: function(fn) {\n    this._transforms.push(fn);\n    return this;\n  },\n  enumerable: true,\n  configurable: true,\n  writable: true\n});\n\n/**\n * Marks this cursor as errored\n * @method _markError\n * @memberOf QueryCursor\n * @instance\n * @api private\n */\n\nQueryCursor.prototype._markError = function(error) {\n  this._error = error;\n  return this;\n};\n\n/**\n * Marks this cursor as closed. Will stop streaming and subsequent calls to\n * `next()` will error.\n *\n * @return {Promise}\n * @api public\n * @method close\n * @emits close\n * @see AggregationCursor.close https://mongodb.github.io/node-mongodb-native/4.9/classes/AggregationCursor.html#close\n */\n\nQueryCursor.prototype.close = async function close() {\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('QueryCursor.prototype.close() no longer accepts a callback');\n  }\n  try {\n    await this.cursor.close();\n    this.emit('close');\n  } catch (error) {\n    this.listeners('error').length > 0 && this.emit('error', error);\n    throw error;\n  }\n};\n\n/**\n * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\n * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\n * if the resultant data has already been retrieved by this cursor.\n *\n * @return {AggregationCursor} this\n * @api public\n * @method rewind\n */\n\nQueryCursor.prototype.rewind = function() {\n  _waitForCursor(this, () => {\n    this.cursor.rewind();\n  });\n  return this;\n};\n\n/**\n * Get the next document from this cursor. Will return `null` when there are\n * no documents left.\n *\n * @return {Promise}\n * @api public\n * @method next\n */\n\nQueryCursor.prototype.next = async function next() {\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('QueryCursor.prototype.next() no longer accepts a callback');\n  }\n  return new Promise((resolve, reject) => {\n    _next(this, function(error, doc) {\n      if (error) {\n        return reject(error);\n      }\n      resolve(doc);\n    });\n  });\n};\n\n/**\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\n * will wait for the promise to resolve before iterating on to the next one.\n * Returns a promise that resolves when done.\n *\n * #### Example:\n *\n *     // Iterate over documents asynchronously\n *     Thing.\n *       find({ name: /^hello/ }).\n *       cursor().\n *       eachAsync(async function (doc, i) {\n *         doc.foo = doc.bar + i;\n *         await doc.save();\n *       })\n *\n * @param {Function} fn\n * @param {Object} [options]\n * @param {Number} [options.parallel] the number of promises to execute in parallel. Defaults to 1.\n * @param {Number} [options.batchSize] if set, will call `fn()` with arrays of documents with length at most `batchSize`\n * @param {Boolean} [options.continueOnError=false] if true, `eachAsync()` iterates through all docs even if `fn` throws an error. If false, `eachAsync()` throws an error immediately if the given function `fn()` throws an error.\n * @return {Promise}\n * @api public\n * @method eachAsync\n */\n\nQueryCursor.prototype.eachAsync = function(fn, opts) {\n  if (typeof arguments[2] === 'function') {\n    throw new MongooseError('QueryCursor.prototype.eachAsync() no longer accepts a callback');\n  }\n  if (typeof opts === 'function') {\n    opts = {};\n  }\n  opts = opts || {};\n\n  return eachAsync((cb) => _next(this, cb), fn, opts);\n};\n\n/**\n * The `options` passed in to the `QueryCursor` constructor.\n *\n * @api public\n * @property options\n */\n\nQueryCursor.prototype.options;\n\n/**\n * Adds a [cursor flag](https://mongodb.github.io/node-mongodb-native/4.9/classes/FindCursor.html#addCursorFlag).\n * Useful for setting the `noCursorTimeout` and `tailable` flags.\n *\n * @param {String} flag\n * @param {Boolean} value\n * @return {AggregationCursor} this\n * @api public\n * @method addCursorFlag\n */\n\nQueryCursor.prototype.addCursorFlag = function(flag, value) {\n  _waitForCursor(this, () => {\n    this.cursor.addCursorFlag(flag, value);\n  });\n  return this;\n};\n\n/*!\n * ignore\n */\n\nQueryCursor.prototype.transformNull = function(val) {\n  if (arguments.length === 0) {\n    val = true;\n  }\n  this._mongooseOptions.transformNull = val;\n  return this;\n};\n\n/*!\n * ignore\n */\n\nQueryCursor.prototype._transformForAsyncIterator = function() {\n  if (this._transforms.indexOf(_transformForAsyncIterator) === -1) {\n    this.map(_transformForAsyncIterator);\n  }\n  return this;\n};\n\n/**\n * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js).\n * You do not need to call this function explicitly, the JavaScript runtime\n * will call it for you.\n *\n * #### Example:\n *\n *     // Works without using `cursor()`\n *     for await (const doc of Model.find([{ $sort: { name: 1 } }])) {\n *       console.log(doc.name);\n *     }\n *\n *     // Can also use `cursor()`\n *     for await (const doc of Model.find([{ $sort: { name: 1 } }]).cursor()) {\n *       console.log(doc.name);\n *     }\n *\n * Node.js 10.x supports async iterators natively without any flags. You can\n * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\n *\n * **Note:** This function is not if `Symbol.asyncIterator` is undefined. If\n * `Symbol.asyncIterator` is undefined, that means your Node.js version does not\n * support async iterators.\n *\n * @method [Symbol.asyncIterator]\n * @memberOf QueryCursor\n * @instance\n * @api public\n */\n\nif (Symbol.asyncIterator != null) {\n  QueryCursor.prototype[Symbol.asyncIterator] = function() {\n    return this.transformNull()._transformForAsyncIterator();\n  };\n}\n\n/*!\n * ignore\n */\n\nfunction _transformForAsyncIterator(doc) {\n  return doc == null ? { done: true } : { value: doc, done: false };\n}\n\n/**\n * Get the next doc from the underlying cursor and mongooseify it\n * (populate, etc.)\n * @param {Any} ctx\n * @param {Function} cb\n * @api private\n */\n\nfunction _next(ctx, cb) {\n  let callback = cb;\n  if (ctx._transforms.length) {\n    callback = function(err, doc) {\n      if (err || (doc === null && !ctx._mongooseOptions.transformNull)) {\n        return cb(err, doc);\n      }\n      cb(err, ctx._transforms.reduce(function(doc, fn) {\n        return fn.call(ctx, doc);\n      }, doc));\n    };\n  }\n\n  if (ctx._error) {\n    return immediate(function() {\n      callback(ctx._error);\n    });\n  }\n  if (ctx.skipped) {\n    return immediate(() => callback(null, null));\n  }\n\n  if (ctx.cursor) {\n    if (ctx.query._mongooseOptions.populate && !ctx._pop) {\n      ctx._pop = helpers.preparePopulationOptionsMQ(ctx.query,\n        ctx.query._mongooseOptions);\n      ctx._pop.__noPromise = true;\n    }\n    if (ctx.query._mongooseOptions.populate && ctx.options._populateBatchSize > 1) {\n      if (ctx._batchDocs && ctx._batchDocs.length) {\n        // Return a cached populated doc\n        return _nextDoc(ctx, ctx._batchDocs.shift(), ctx._pop, callback);\n      } else if (ctx._batchExhausted) {\n        // Internal cursor reported no more docs. Act the same here\n        return callback(null, null);\n      } else {\n        // Request as many docs as batchSize, to populate them also in batch\n        ctx._batchDocs = [];\n        ctx.cursor.next().then(\n          res => { _onNext.call({ ctx, callback }, null, res); },\n          err => { _onNext.call({ ctx, callback }, err); }\n        );\n        return;\n      }\n    } else {\n      return ctx.cursor.next().then(\n        doc => {\n          if (!doc) {\n            callback(null, null);\n            return;\n          }\n\n          if (!ctx.query._mongooseOptions.populate) {\n            return _nextDoc(ctx, doc, null, callback);\n          }\n\n          ctx.query.model.populate(doc, ctx._pop).then(\n            doc => {\n              _nextDoc(ctx, doc, ctx._pop, callback);\n            },\n            err => {\n              callback(err);\n            }\n          );\n        },\n        error => {\n          callback(error);\n        }\n      );\n    }\n  } else {\n    ctx.once('error', cb);\n\n    ctx.once('cursor', function(cursor) {\n      ctx.removeListener('error', cb);\n      if (cursor == null) {\n        if (ctx.skipped) {\n          return cb(null, null);\n        }\n        return;\n      }\n      _next(ctx, cb);\n    });\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _onNext(error, doc) {\n  if (error) {\n    return this.callback(error);\n  }\n  if (!doc) {\n    this.ctx._batchExhausted = true;\n    return _populateBatch.call(this);\n  }\n\n  this.ctx._batchDocs.push(doc);\n\n  if (this.ctx._batchDocs.length < this.ctx.options._populateBatchSize) {\n    // If both `batchSize` and `_populateBatchSize` are huge, calling `next()` repeatedly may\n    // cause a stack overflow. So make sure we clear the stack regularly.\n    if (this.ctx._batchDocs.length > 0 && this.ctx._batchDocs.length % 1000 === 0) {\n      return immediate(() => this.ctx.cursor.next().then(\n        res => { _onNext.call(this, null, res); },\n        err => { _onNext.call(this, err); }\n      ));\n    }\n    this.ctx.cursor.next().then(\n      res => { _onNext.call(this, null, res); },\n      err => { _onNext.call(this, err); }\n    );\n  } else {\n    _populateBatch.call(this);\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _populateBatch() {\n  if (!this.ctx._batchDocs.length) {\n    return this.callback(null, null);\n  }\n  this.ctx.query.model.populate(this.ctx._batchDocs, this.ctx._pop).then(\n    () => {\n      _nextDoc(this.ctx, this.ctx._batchDocs.shift(), this.ctx._pop, this.callback);\n    },\n    err => {\n      this.callback(err);\n    }\n  );\n}\n\n/*!\n * ignore\n */\n\nfunction _nextDoc(ctx, doc, pop, callback) {\n  if (ctx.query._mongooseOptions.lean) {\n    return ctx.model.hooks.execPost('find', ctx.query, [[doc]], err => {\n      if (err != null) {\n        return callback(err);\n      }\n      callback(null, doc);\n    });\n  }\n\n  const { model, _fields, _userProvidedFields, options } = ctx.query;\n  helpers.createModelAndInit(model, doc, _fields, _userProvidedFields, options, pop, (err, doc) => {\n    if (err != null) {\n      return callback(err);\n    }\n    ctx.model.hooks.execPost('find', ctx.query, [[doc]], err => {\n      if (err != null) {\n        return callback(err);\n      }\n      callback(null, doc);\n    });\n  });\n}\n\n/*!\n * ignore\n */\n\nfunction _waitForCursor(ctx, cb) {\n  if (ctx.cursor) {\n    return cb();\n  }\n  ctx.once('cursor', function(cursor) {\n    if (cursor == null) {\n      return;\n    }\n    cb();\n  });\n}\n\nmodule.exports = QueryCursor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2N1cnNvci9xdWVyeUN1cnNvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsMkZBQXdCO0FBQ3RELGlCQUFpQixzREFBMEI7QUFDM0Msa0JBQWtCLG1CQUFPLENBQUMscUdBQTZCO0FBQ3ZELGdCQUFnQixtQkFBTyxDQUFDLDZFQUFpQjtBQUN6QyxlQUFlLG1CQUFPLENBQUMsdURBQVE7QUFDL0Isa0JBQWtCLG1CQUFPLENBQUMsdUZBQXNCO0FBQ2hELGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUNBQXFDOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QixlQUFlLGVBQWUsZUFBZTtBQUNoRSxtQkFBbUIsZUFBZSxlQUFlO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0NBQWdDO0FBQ2pELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdDQUFnQztBQUMvQyxlQUFlO0FBQ2Y7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxVQUFVLCtDQUErQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvY3Vyc29yL3F1ZXJ5Q3Vyc29yLmpzPzhmYTQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL21vbmdvb3NlRXJyb3InKTtcbmNvbnN0IFJlYWRhYmxlID0gcmVxdWlyZSgnc3RyZWFtJykuUmVhZGFibGU7XG5jb25zdCBlYWNoQXN5bmMgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2N1cnNvci9lYWNoQXN5bmMnKTtcbmNvbnN0IGhlbHBlcnMgPSByZXF1aXJlKCcuLi9xdWVyeUhlbHBlcnMnKTtcbmNvbnN0IGthcmVlbSA9IHJlcXVpcmUoJ2thcmVlbScpO1xuY29uc3QgaW1tZWRpYXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9pbW1lZGlhdGUnKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbi8qKlxuICogQSBRdWVyeUN1cnNvciBpcyBhIGNvbmN1cnJlbmN5IHByaW1pdGl2ZSBmb3IgcHJvY2Vzc2luZyBxdWVyeSByZXN1bHRzXG4gKiBvbmUgZG9jdW1lbnQgYXQgYSB0aW1lLiBBIFF1ZXJ5Q3Vyc29yIGZ1bGZpbGxzIHRoZSBOb2RlLmpzIHN0cmVhbXMzIEFQSSxcbiAqIGluIGFkZGl0aW9uIHRvIHNldmVyYWwgb3RoZXIgbWVjaGFuaXNtcyBmb3IgbG9hZGluZyBkb2N1bWVudHMgZnJvbSBNb25nb0RCXG4gKiBvbmUgYXQgYSB0aW1lLlxuICpcbiAqIFF1ZXJ5Q3Vyc29ycyBleGVjdXRlIHRoZSBtb2RlbCdzIHByZSBgZmluZGAgaG9va3MgYmVmb3JlIGxvYWRpbmcgYW55IGRvY3VtZW50c1xuICogZnJvbSBNb25nb0RCLCBhbmQgdGhlIG1vZGVsJ3MgcG9zdCBgZmluZGAgaG9va3MgYWZ0ZXIgbG9hZGluZyBlYWNoIGRvY3VtZW50LlxuICpcbiAqIFVubGVzcyB5b3UncmUgYW4gYWR2YW5jZWQgdXNlciwgZG8gKipub3QqKiBpbnN0YW50aWF0ZSB0aGlzIGNsYXNzIGRpcmVjdGx5LlxuICogVXNlIFtgUXVlcnkjY3Vyc29yKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLmN1cnNvcigpKSBpbnN0ZWFkLlxuICpcbiAqIEBwYXJhbSB7UXVlcnl9IHF1ZXJ5XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBxdWVyeSBvcHRpb25zIHBhc3NlZCB0byBgLmZpbmQoKWBcbiAqIEBpbmhlcml0cyBSZWFkYWJsZSBodHRwczovL25vZGVqcy5vcmcvYXBpL3N0cmVhbS5odG1sI2NsYXNzLXN0cmVhbXJlYWRhYmxlXG4gKiBAZXZlbnQgYGN1cnNvcmA6IEVtaXR0ZWQgd2hlbiB0aGUgY3Vyc29yIGlzIGNyZWF0ZWRcbiAqIEBldmVudCBgZXJyb3JgOiBFbWl0dGVkIHdoZW4gYW4gZXJyb3Igb2NjdXJyZWRcbiAqIEBldmVudCBgZGF0YWA6IEVtaXR0ZWQgd2hlbiB0aGUgc3RyZWFtIGlzIGZsb3dpbmcgYW5kIHRoZSBuZXh0IGRvYyBpcyByZWFkeVxuICogQGV2ZW50IGBlbmRgOiBFbWl0dGVkIHdoZW4gdGhlIHN0cmVhbSBpcyBleGhhdXN0ZWRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUXVlcnlDdXJzb3IocXVlcnkpIHtcbiAgLy8gc2V0IGF1dG9EZXN0cm95PXRydWUgYmVjYXVzZSBvbiBub2RlIDEyIGl0J3MgYnkgZGVmYXVsdCBmYWxzZVxuICAvLyBnaC0xMDkwMiBuZWVkIGF1dG9EZXN0cm95IHRvIGRlc3Ryb3kgY29ycmVjdGx5IGFuZCBlbWl0ICdjbG9zZScgZXZlbnRcbiAgUmVhZGFibGUuY2FsbCh0aGlzLCB7IGF1dG9EZXN0cm95OiB0cnVlLCBvYmplY3RNb2RlOiB0cnVlIH0pO1xuXG4gIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgdGhpcy5za2lwcGVkID0gZmFsc2U7XG4gIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgY29uc3QgbW9kZWwgPSBxdWVyeS5tb2RlbDtcbiAgdGhpcy5fbW9uZ29vc2VPcHRpb25zID0ge307XG4gIHRoaXMuX3RyYW5zZm9ybXMgPSBbXTtcbiAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgbW9kZWwuaG9va3MuZXhlY1ByZSgnZmluZCcsIHF1ZXJ5LCAoZXJyKSA9PiB7XG4gICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2Yga2FyZWVtLnNraXBXcmFwcGVkRnVuY3Rpb24pIHtcbiAgICAgICAgY29uc3QgcmVzdWx0VmFsdWUgPSBlcnIuYXJnc1swXTtcbiAgICAgICAgaWYgKHJlc3VsdFZhbHVlICE9IG51bGwgJiYgKCFBcnJheS5pc0FycmF5KHJlc3VsdFZhbHVlKSB8fCByZXN1bHRWYWx1ZS5sZW5ndGgpKSB7XG4gICAgICAgICAgY29uc3QgZXJyID0gbmV3IE1vbmdvb3NlRXJyb3IoXG4gICAgICAgICAgICAnQ2Fubm90IGBza2lwTWlkZGxld2FyZUZ1bmN0aW9uKClgIHdpdGggYSB2YWx1ZSB3aGVuIHVzaW5nICcgK1xuICAgICAgICAgICAgJ2AuZmluZCgpLmN1cnNvcigpYCwgdmFsdWUgbXVzdCBiZSBudWxsaXNoIG9yIGVtcHR5IGFycmF5LCBnb3QgXCInICtcbiAgICAgICAgICAgIHV0aWwuaW5zcGVjdChyZXN1bHRWYWx1ZSkgK1xuICAgICAgICAgICAgJ1wiLidcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuX21hcmtFcnJvcihlcnIpO1xuICAgICAgICAgIHRoaXMubGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aCA+IDAgJiYgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2tpcHBlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdCgnY3Vyc29yJywgbnVsbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21hcmtFcnJvcihlcnIpO1xuICAgICAgdGhpcy5saXN0ZW5lcnMoJ2Vycm9yJykubGVuZ3RoID4gMCAmJiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLm9wdGlvbnMsIHF1ZXJ5Ll9vcHRpb25zRm9yRXhlYygpKTtcbiAgICB0aGlzLl90cmFuc2Zvcm1zID0gdGhpcy5fdHJhbnNmb3Jtcy5jb25jYXQocXVlcnkuX3RyYW5zZm9ybXMuc2xpY2UoKSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50cmFuc2Zvcm0pIHtcbiAgICAgIHRoaXMuX3RyYW5zZm9ybXMucHVzaCh0aGlzLm9wdGlvbnMudHJhbnNmb3JtKTtcbiAgICB9XG4gICAgLy8gUmU6IGdoLTgwMzksIHlvdSBuZWVkIHRvIHNldCB0aGUgYGN1cnNvci5iYXRjaFNpemVgIG9wdGlvbiwgdG9wLWxldmVsXG4gICAgLy8gYGJhdGNoU2l6ZWAgb3B0aW9uIGRvZXNuJ3Qgd29yay5cbiAgICBpZiAodGhpcy5vcHRpb25zLmJhdGNoU2l6ZSkge1xuICAgICAgLy8gTWF4IG91dCB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyB3ZSdsbCBwb3B1bGF0ZSBpbiBwYXJhbGxlbCBhdCA1MDAwLlxuICAgICAgdGhpcy5vcHRpb25zLl9wb3B1bGF0ZUJhdGNoU2l6ZSA9IE1hdGgubWluKHRoaXMub3B0aW9ucy5iYXRjaFNpemUsIDUwMDApO1xuICAgIH1cblxuICAgIGlmIChtb2RlbC5jb2xsZWN0aW9uLl9zaG91bGRCdWZmZXJDb21tYW5kcygpICYmIG1vZGVsLmNvbGxlY3Rpb24uYnVmZmVyKSB7XG4gICAgICBtb2RlbC5jb2xsZWN0aW9uLnF1ZXVlLnB1c2goW1xuICAgICAgICAoKSA9PiBfZ2V0UmF3Q3Vyc29yKHF1ZXJ5LCB0aGlzKVxuICAgICAgXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9nZXRSYXdDdXJzb3IocXVlcnksIHRoaXMpO1xuICAgIH1cbiAgfSk7XG59XG5cbnV0aWwuaW5oZXJpdHMoUXVlcnlDdXJzb3IsIFJlYWRhYmxlKTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfZ2V0UmF3Q3Vyc29yKHF1ZXJ5LCBxdWVyeUN1cnNvcikge1xuICB0cnkge1xuICAgIGNvbnN0IGN1cnNvciA9IHF1ZXJ5Lm1vZGVsLmNvbGxlY3Rpb24uZmluZChxdWVyeS5fY29uZGl0aW9ucywgcXVlcnlDdXJzb3Iub3B0aW9ucyk7XG4gICAgcXVlcnlDdXJzb3IuY3Vyc29yID0gY3Vyc29yO1xuICAgIHF1ZXJ5Q3Vyc29yLmVtaXQoJ2N1cnNvcicsIGN1cnNvcik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHF1ZXJ5Q3Vyc29yLl9tYXJrRXJyb3IoZXJyKTtcbiAgICBxdWVyeUN1cnNvci5saXN0ZW5lcnMoJ2Vycm9yJykubGVuZ3RoID4gMCAmJiBxdWVyeUN1cnNvci5lbWl0KCdlcnJvcicsIHF1ZXJ5Q3Vyc29yLl9lcnJvcik7XG4gIH1cbn1cblxuLyoqXG4gKiBOZWNlc3NhcnkgdG8gc2F0aXNmeSB0aGUgUmVhZGFibGUgQVBJXG4gKiBAbWV0aG9kIF9yZWFkXG4gKiBAbWVtYmVyT2YgUXVlcnlDdXJzb3JcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUXVlcnlDdXJzb3IucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24oKSB7XG4gIF9uZXh0KHRoaXMsIChlcnJvciwgZG9jKSA9PiB7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICB9XG4gICAgaWYgKCFkb2MpIHtcbiAgICAgIHRoaXMucHVzaChudWxsKTtcbiAgICAgIHRoaXMuY3Vyc29yLmNsb3NlKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wdXNoKGRvYyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlcnMgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2hpY2ggc3Vic2VxdWVudGx5IG1hcHMgZG9jdW1lbnRzIHJldHJpZXZlZFxuICogdmlhIHRoZSBzdHJlYW1zIGludGVyZmFjZSBvciBgLm5leHQoKWBcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1hcCBkb2N1bWVudHMgcmV0dXJuZWQgYnkgYGRhdGFgIGV2ZW50c1xuICogICAgIFRoaW5nLlxuICogICAgICAgZmluZCh7IG5hbWU6IC9eaGVsbG8vIH0pLlxuICogICAgICAgY3Vyc29yKCkuXG4gKiAgICAgICBtYXAoZnVuY3Rpb24gKGRvYykge1xuICogICAgICAgIGRvYy5mb28gPSBcImJhclwiO1xuICogICAgICAgIHJldHVybiBkb2M7XG4gKiAgICAgICB9KVxuICogICAgICAgb24oJ2RhdGEnLCBmdW5jdGlvbihkb2MpIHsgY29uc29sZS5sb2coZG9jLmZvbyk7IH0pO1xuICpcbiAqICAgICAvLyBPciBtYXAgZG9jdW1lbnRzIHJldHVybmVkIGJ5IGAubmV4dCgpYFxuICogICAgIGNvbnN0IGN1cnNvciA9IFRoaW5nLmZpbmQoeyBuYW1lOiAvXmhlbGxvLyB9KS5cbiAqICAgICAgIGN1cnNvcigpLlxuICogICAgICAgbWFwKGZ1bmN0aW9uIChkb2MpIHtcbiAqICAgICAgICAgZG9jLmZvbyA9IFwiYmFyXCI7XG4gKiAgICAgICAgIHJldHVybiBkb2M7XG4gKiAgICAgICB9KTtcbiAqICAgICBjdXJzb3IubmV4dChmdW5jdGlvbihlcnJvciwgZG9jKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyhkb2MuZm9vKTtcbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7UXVlcnlDdXJzb3J9XG4gKiBAbWVtYmVyT2YgUXVlcnlDdXJzb3JcbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kIG1hcFxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWVyeUN1cnNvci5wcm90b3R5cGUsICdtYXAnLCB7XG4gIHZhbHVlOiBmdW5jdGlvbihmbikge1xuICAgIHRoaXMuX3RyYW5zZm9ybXMucHVzaChmbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWVcbn0pO1xuXG4vKipcbiAqIE1hcmtzIHRoaXMgY3Vyc29yIGFzIGVycm9yZWRcbiAqIEBtZXRob2QgX21hcmtFcnJvclxuICogQG1lbWJlck9mIFF1ZXJ5Q3Vyc29yXG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblF1ZXJ5Q3Vyc29yLnByb3RvdHlwZS5fbWFya0Vycm9yID0gZnVuY3Rpb24oZXJyb3IpIHtcbiAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE1hcmtzIHRoaXMgY3Vyc29yIGFzIGNsb3NlZC4gV2lsbCBzdG9wIHN0cmVhbWluZyBhbmQgc3Vic2VxdWVudCBjYWxscyB0b1xuICogYG5leHQoKWAgd2lsbCBlcnJvci5cbiAqXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgY2xvc2VcbiAqIEBlbWl0cyBjbG9zZVxuICogQHNlZSBBZ2dyZWdhdGlvbkN1cnNvci5jbG9zZSBodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvQWdncmVnYXRpb25DdXJzb3IuaHRtbCNjbG9zZVxuICovXG5cblF1ZXJ5Q3Vyc29yLnByb3RvdHlwZS5jbG9zZSA9IGFzeW5jIGZ1bmN0aW9uIGNsb3NlKCkge1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdRdWVyeUN1cnNvci5wcm90b3R5cGUuY2xvc2UoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cbiAgdHJ5IHtcbiAgICBhd2FpdCB0aGlzLmN1cnNvci5jbG9zZSgpO1xuICAgIHRoaXMuZW1pdCgnY2xvc2UnKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aGlzLmxpc3RlbmVycygnZXJyb3InKS5sZW5ndGggPiAwICYmIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8qKlxuICogUmV3aW5kIHRoaXMgY3Vyc29yIHRvIGl0cyB1bmluaXRpYWxpemVkIHN0YXRlLiBBbnkgb3B0aW9ucyB0aGF0IGFyZSBwcmVzZW50IG9uIHRoZSBjdXJzb3Igd2lsbFxuICogcmVtYWluIGluIGVmZmVjdC4gSXRlcmF0aW5nIHRoaXMgY3Vyc29yIHdpbGwgY2F1c2UgbmV3IHF1ZXJpZXMgdG8gYmUgc2VudCB0byB0aGUgc2VydmVyLCBldmVuXG4gKiBpZiB0aGUgcmVzdWx0YW50IGRhdGEgaGFzIGFscmVhZHkgYmVlbiByZXRyaWV2ZWQgYnkgdGhpcyBjdXJzb3IuXG4gKlxuICogQHJldHVybiB7QWdncmVnYXRpb25DdXJzb3J9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kIHJld2luZFxuICovXG5cblF1ZXJ5Q3Vyc29yLnByb3RvdHlwZS5yZXdpbmQgPSBmdW5jdGlvbigpIHtcbiAgX3dhaXRGb3JDdXJzb3IodGhpcywgKCkgPT4ge1xuICAgIHRoaXMuY3Vyc29yLnJld2luZCgpO1xuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbmV4dCBkb2N1bWVudCBmcm9tIHRoaXMgY3Vyc29yLiBXaWxsIHJldHVybiBgbnVsbGAgd2hlbiB0aGVyZSBhcmVcbiAqIG5vIGRvY3VtZW50cyBsZWZ0LlxuICpcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCBuZXh0XG4gKi9cblxuUXVlcnlDdXJzb3IucHJvdG90eXBlLm5leHQgPSBhc3luYyBmdW5jdGlvbiBuZXh0KCkge1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdRdWVyeUN1cnNvci5wcm90b3R5cGUubmV4dCgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIF9uZXh0KHRoaXMsIGZ1bmN0aW9uKGVycm9yLCBkb2MpIHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoZG9jKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgYGZuYCBmb3IgZXZlcnkgZG9jdW1lbnQgaW4gdGhlIGN1cnNvci4gSWYgYGZuYCByZXR1cm5zIGEgcHJvbWlzZSxcbiAqIHdpbGwgd2FpdCBmb3IgdGhlIHByb21pc2UgdG8gcmVzb2x2ZSBiZWZvcmUgaXRlcmF0aW5nIG9uIHRvIHRoZSBuZXh0IG9uZS5cbiAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBkb25lLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gSXRlcmF0ZSBvdmVyIGRvY3VtZW50cyBhc3luY2hyb25vdXNseVxuICogICAgIFRoaW5nLlxuICogICAgICAgZmluZCh7IG5hbWU6IC9eaGVsbG8vIH0pLlxuICogICAgICAgY3Vyc29yKCkuXG4gKiAgICAgICBlYWNoQXN5bmMoYXN5bmMgZnVuY3Rpb24gKGRvYywgaSkge1xuICogICAgICAgICBkb2MuZm9vID0gZG9jLmJhciArIGk7XG4gKiAgICAgICAgIGF3YWl0IGRvYy5zYXZlKCk7XG4gKiAgICAgICB9KVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGFyYWxsZWxdIHRoZSBudW1iZXIgb2YgcHJvbWlzZXMgdG8gZXhlY3V0ZSBpbiBwYXJhbGxlbC4gRGVmYXVsdHMgdG8gMS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5iYXRjaFNpemVdIGlmIHNldCwgd2lsbCBjYWxsIGBmbigpYCB3aXRoIGFycmF5cyBvZiBkb2N1bWVudHMgd2l0aCBsZW5ndGggYXQgbW9zdCBgYmF0Y2hTaXplYFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jb250aW51ZU9uRXJyb3I9ZmFsc2VdIGlmIHRydWUsIGBlYWNoQXN5bmMoKWAgaXRlcmF0ZXMgdGhyb3VnaCBhbGwgZG9jcyBldmVuIGlmIGBmbmAgdGhyb3dzIGFuIGVycm9yLiBJZiBmYWxzZSwgYGVhY2hBc3luYygpYCB0aHJvd3MgYW4gZXJyb3IgaW1tZWRpYXRlbHkgaWYgdGhlIGdpdmVuIGZ1bmN0aW9uIGBmbigpYCB0aHJvd3MgYW4gZXJyb3IuXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgZWFjaEFzeW5jXG4gKi9cblxuUXVlcnlDdXJzb3IucHJvdG90eXBlLmVhY2hBc3luYyA9IGZ1bmN0aW9uKGZuLCBvcHRzKSB7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ1F1ZXJ5Q3Vyc29yLnByb3RvdHlwZS5lYWNoQXN5bmMoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHJldHVybiBlYWNoQXN5bmMoKGNiKSA9PiBfbmV4dCh0aGlzLCBjYiksIGZuLCBvcHRzKTtcbn07XG5cbi8qKlxuICogVGhlIGBvcHRpb25zYCBwYXNzZWQgaW4gdG8gdGhlIGBRdWVyeUN1cnNvcmAgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBvcHRpb25zXG4gKi9cblxuUXVlcnlDdXJzb3IucHJvdG90eXBlLm9wdGlvbnM7XG5cbi8qKlxuICogQWRkcyBhIFtjdXJzb3IgZmxhZ10oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0ZpbmRDdXJzb3IuaHRtbCNhZGRDdXJzb3JGbGFnKS5cbiAqIFVzZWZ1bCBmb3Igc2V0dGluZyB0aGUgYG5vQ3Vyc29yVGltZW91dGAgYW5kIGB0YWlsYWJsZWAgZmxhZ3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZsYWdcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWVcbiAqIEByZXR1cm4ge0FnZ3JlZ2F0aW9uQ3Vyc29yfSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCBhZGRDdXJzb3JGbGFnXG4gKi9cblxuUXVlcnlDdXJzb3IucHJvdG90eXBlLmFkZEN1cnNvckZsYWcgPSBmdW5jdGlvbihmbGFnLCB2YWx1ZSkge1xuICBfd2FpdEZvckN1cnNvcih0aGlzLCAoKSA9PiB7XG4gICAgdGhpcy5jdXJzb3IuYWRkQ3Vyc29yRmxhZyhmbGFnLCB2YWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuUXVlcnlDdXJzb3IucHJvdG90eXBlLnRyYW5zZm9ybU51bGwgPSBmdW5jdGlvbih2YWwpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB2YWwgPSB0cnVlO1xuICB9XG4gIHRoaXMuX21vbmdvb3NlT3B0aW9ucy50cmFuc2Zvcm1OdWxsID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuUXVlcnlDdXJzb3IucHJvdG90eXBlLl90cmFuc2Zvcm1Gb3JBc3luY0l0ZXJhdG9yID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl90cmFuc2Zvcm1zLmluZGV4T2YoX3RyYW5zZm9ybUZvckFzeW5jSXRlcmF0b3IpID09PSAtMSkge1xuICAgIHRoaXMubWFwKF90cmFuc2Zvcm1Gb3JBc3luY0l0ZXJhdG9yKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBhc3luY0l0ZXJhdG9yIGZvciB1c2Ugd2l0aCBbYGZvci9hd2FpdC9vZmAgbG9vcHNdKGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vZ2V0dGluZy1zdGFydGVkLXdpdGgtYXN5bmMtaXRlcmF0b3JzLWluLW5vZGUtanMpLlxuICogWW91IGRvIG5vdCBuZWVkIHRvIGNhbGwgdGhpcyBmdW5jdGlvbiBleHBsaWNpdGx5LCB0aGUgSmF2YVNjcmlwdCBydW50aW1lXG4gKiB3aWxsIGNhbGwgaXQgZm9yIHlvdS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIFdvcmtzIHdpdGhvdXQgdXNpbmcgYGN1cnNvcigpYFxuICogICAgIGZvciBhd2FpdCAoY29uc3QgZG9jIG9mIE1vZGVsLmZpbmQoW3sgJHNvcnQ6IHsgbmFtZTogMSB9IH1dKSkge1xuICogICAgICAgY29uc29sZS5sb2coZG9jLm5hbWUpO1xuICogICAgIH1cbiAqXG4gKiAgICAgLy8gQ2FuIGFsc28gdXNlIGBjdXJzb3IoKWBcbiAqICAgICBmb3IgYXdhaXQgKGNvbnN0IGRvYyBvZiBNb2RlbC5maW5kKFt7ICRzb3J0OiB7IG5hbWU6IDEgfSB9XSkuY3Vyc29yKCkpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKGRvYy5uYW1lKTtcbiAqICAgICB9XG4gKlxuICogTm9kZS5qcyAxMC54IHN1cHBvcnRzIGFzeW5jIGl0ZXJhdG9ycyBuYXRpdmVseSB3aXRob3V0IGFueSBmbGFncy4gWW91IGNhblxuICogZW5hYmxlIGFzeW5jIGl0ZXJhdG9ycyBpbiBOb2RlLmpzIDgueCB1c2luZyB0aGUgW2AtLWhhcm1vbnlfYXN5bmNfaXRlcmF0aW9uYCBmbGFnXShodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1hc3luYy1pdGVyYXRpb24vaXNzdWVzLzExNyNpc3N1ZWNvbW1lbnQtMzQ2Njk1MTg3KS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyBub3QgaWYgYFN5bWJvbC5hc3luY0l0ZXJhdG9yYCBpcyB1bmRlZmluZWQuIElmXG4gKiBgU3ltYm9sLmFzeW5jSXRlcmF0b3JgIGlzIHVuZGVmaW5lZCwgdGhhdCBtZWFucyB5b3VyIE5vZGUuanMgdmVyc2lvbiBkb2VzIG5vdFxuICogc3VwcG9ydCBhc3luYyBpdGVyYXRvcnMuXG4gKlxuICogQG1ldGhvZCBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdXG4gKiBAbWVtYmVyT2YgUXVlcnlDdXJzb3JcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5pZiAoU3ltYm9sLmFzeW5jSXRlcmF0b3IgIT0gbnVsbCkge1xuICBRdWVyeUN1cnNvci5wcm90b3R5cGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtTnVsbCgpLl90cmFuc2Zvcm1Gb3JBc3luY0l0ZXJhdG9yKCk7XG4gIH07XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX3RyYW5zZm9ybUZvckFzeW5jSXRlcmF0b3IoZG9jKSB7XG4gIHJldHVybiBkb2MgPT0gbnVsbCA/IHsgZG9uZTogdHJ1ZSB9IDogeyB2YWx1ZTogZG9jLCBkb25lOiBmYWxzZSB9O1xufVxuXG4vKipcbiAqIEdldCB0aGUgbmV4dCBkb2MgZnJvbSB0aGUgdW5kZXJseWluZyBjdXJzb3IgYW5kIG1vbmdvb3NlaWZ5IGl0XG4gKiAocG9wdWxhdGUsIGV0Yy4pXG4gKiBAcGFyYW0ge0FueX0gY3R4XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gX25leHQoY3R4LCBjYikge1xuICBsZXQgY2FsbGJhY2sgPSBjYjtcbiAgaWYgKGN0eC5fdHJhbnNmb3Jtcy5sZW5ndGgpIHtcbiAgICBjYWxsYmFjayA9IGZ1bmN0aW9uKGVyciwgZG9jKSB7XG4gICAgICBpZiAoZXJyIHx8IChkb2MgPT09IG51bGwgJiYgIWN0eC5fbW9uZ29vc2VPcHRpb25zLnRyYW5zZm9ybU51bGwpKSB7XG4gICAgICAgIHJldHVybiBjYihlcnIsIGRvYyk7XG4gICAgICB9XG4gICAgICBjYihlcnIsIGN0eC5fdHJhbnNmb3Jtcy5yZWR1Y2UoZnVuY3Rpb24oZG9jLCBmbikge1xuICAgICAgICByZXR1cm4gZm4uY2FsbChjdHgsIGRvYyk7XG4gICAgICB9LCBkb2MpKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKGN0eC5fZXJyb3IpIHtcbiAgICByZXR1cm4gaW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgY2FsbGJhY2soY3R4Ll9lcnJvcik7XG4gICAgfSk7XG4gIH1cbiAgaWYgKGN0eC5za2lwcGVkKSB7XG4gICAgcmV0dXJuIGltbWVkaWF0ZSgoKSA9PiBjYWxsYmFjayhudWxsLCBudWxsKSk7XG4gIH1cblxuICBpZiAoY3R4LmN1cnNvcikge1xuICAgIGlmIChjdHgucXVlcnkuX21vbmdvb3NlT3B0aW9ucy5wb3B1bGF0ZSAmJiAhY3R4Ll9wb3ApIHtcbiAgICAgIGN0eC5fcG9wID0gaGVscGVycy5wcmVwYXJlUG9wdWxhdGlvbk9wdGlvbnNNUShjdHgucXVlcnksXG4gICAgICAgIGN0eC5xdWVyeS5fbW9uZ29vc2VPcHRpb25zKTtcbiAgICAgIGN0eC5fcG9wLl9fbm9Qcm9taXNlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGN0eC5xdWVyeS5fbW9uZ29vc2VPcHRpb25zLnBvcHVsYXRlICYmIGN0eC5vcHRpb25zLl9wb3B1bGF0ZUJhdGNoU2l6ZSA+IDEpIHtcbiAgICAgIGlmIChjdHguX2JhdGNoRG9jcyAmJiBjdHguX2JhdGNoRG9jcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gUmV0dXJuIGEgY2FjaGVkIHBvcHVsYXRlZCBkb2NcbiAgICAgICAgcmV0dXJuIF9uZXh0RG9jKGN0eCwgY3R4Ll9iYXRjaERvY3Muc2hpZnQoKSwgY3R4Ll9wb3AsIGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSBpZiAoY3R4Ll9iYXRjaEV4aGF1c3RlZCkge1xuICAgICAgICAvLyBJbnRlcm5hbCBjdXJzb3IgcmVwb3J0ZWQgbm8gbW9yZSBkb2NzLiBBY3QgdGhlIHNhbWUgaGVyZVxuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXF1ZXN0IGFzIG1hbnkgZG9jcyBhcyBiYXRjaFNpemUsIHRvIHBvcHVsYXRlIHRoZW0gYWxzbyBpbiBiYXRjaFxuICAgICAgICBjdHguX2JhdGNoRG9jcyA9IFtdO1xuICAgICAgICBjdHguY3Vyc29yLm5leHQoKS50aGVuKFxuICAgICAgICAgIHJlcyA9PiB7IF9vbk5leHQuY2FsbCh7IGN0eCwgY2FsbGJhY2sgfSwgbnVsbCwgcmVzKTsgfSxcbiAgICAgICAgICBlcnIgPT4geyBfb25OZXh0LmNhbGwoeyBjdHgsIGNhbGxiYWNrIH0sIGVycik7IH1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LmN1cnNvci5uZXh0KCkudGhlbihcbiAgICAgICAgZG9jID0+IHtcbiAgICAgICAgICBpZiAoIWRvYykge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFjdHgucXVlcnkuX21vbmdvb3NlT3B0aW9ucy5wb3B1bGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9uZXh0RG9jKGN0eCwgZG9jLCBudWxsLCBjYWxsYmFjayk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3R4LnF1ZXJ5Lm1vZGVsLnBvcHVsYXRlKGRvYywgY3R4Ll9wb3ApLnRoZW4oXG4gICAgICAgICAgICBkb2MgPT4ge1xuICAgICAgICAgICAgICBfbmV4dERvYyhjdHgsIGRvYywgY3R4Ll9wb3AsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnIgPT4ge1xuICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yID0+IHtcbiAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGN0eC5vbmNlKCdlcnJvcicsIGNiKTtcblxuICAgIGN0eC5vbmNlKCdjdXJzb3InLCBmdW5jdGlvbihjdXJzb3IpIHtcbiAgICAgIGN0eC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBjYik7XG4gICAgICBpZiAoY3Vyc29yID09IG51bGwpIHtcbiAgICAgICAgaWYgKGN0eC5za2lwcGVkKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKG51bGwsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIF9uZXh0KGN0eCwgY2IpO1xuICAgIH0pO1xuICB9XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX29uTmV4dChlcnJvciwgZG9jKSB7XG4gIGlmIChlcnJvcikge1xuICAgIHJldHVybiB0aGlzLmNhbGxiYWNrKGVycm9yKTtcbiAgfVxuICBpZiAoIWRvYykge1xuICAgIHRoaXMuY3R4Ll9iYXRjaEV4aGF1c3RlZCA9IHRydWU7XG4gICAgcmV0dXJuIF9wb3B1bGF0ZUJhdGNoLmNhbGwodGhpcyk7XG4gIH1cblxuICB0aGlzLmN0eC5fYmF0Y2hEb2NzLnB1c2goZG9jKTtcblxuICBpZiAodGhpcy5jdHguX2JhdGNoRG9jcy5sZW5ndGggPCB0aGlzLmN0eC5vcHRpb25zLl9wb3B1bGF0ZUJhdGNoU2l6ZSkge1xuICAgIC8vIElmIGJvdGggYGJhdGNoU2l6ZWAgYW5kIGBfcG9wdWxhdGVCYXRjaFNpemVgIGFyZSBodWdlLCBjYWxsaW5nIGBuZXh0KClgIHJlcGVhdGVkbHkgbWF5XG4gICAgLy8gY2F1c2UgYSBzdGFjayBvdmVyZmxvdy4gU28gbWFrZSBzdXJlIHdlIGNsZWFyIHRoZSBzdGFjayByZWd1bGFybHkuXG4gICAgaWYgKHRoaXMuY3R4Ll9iYXRjaERvY3MubGVuZ3RoID4gMCAmJiB0aGlzLmN0eC5fYmF0Y2hEb2NzLmxlbmd0aCAlIDEwMDAgPT09IDApIHtcbiAgICAgIHJldHVybiBpbW1lZGlhdGUoKCkgPT4gdGhpcy5jdHguY3Vyc29yLm5leHQoKS50aGVuKFxuICAgICAgICByZXMgPT4geyBfb25OZXh0LmNhbGwodGhpcywgbnVsbCwgcmVzKTsgfSxcbiAgICAgICAgZXJyID0+IHsgX29uTmV4dC5jYWxsKHRoaXMsIGVycik7IH1cbiAgICAgICkpO1xuICAgIH1cbiAgICB0aGlzLmN0eC5jdXJzb3IubmV4dCgpLnRoZW4oXG4gICAgICByZXMgPT4geyBfb25OZXh0LmNhbGwodGhpcywgbnVsbCwgcmVzKTsgfSxcbiAgICAgIGVyciA9PiB7IF9vbk5leHQuY2FsbCh0aGlzLCBlcnIpOyB9XG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBfcG9wdWxhdGVCYXRjaC5jYWxsKHRoaXMpO1xuICB9XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX3BvcHVsYXRlQmF0Y2goKSB7XG4gIGlmICghdGhpcy5jdHguX2JhdGNoRG9jcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5jYWxsYmFjayhudWxsLCBudWxsKTtcbiAgfVxuICB0aGlzLmN0eC5xdWVyeS5tb2RlbC5wb3B1bGF0ZSh0aGlzLmN0eC5fYmF0Y2hEb2NzLCB0aGlzLmN0eC5fcG9wKS50aGVuKFxuICAgICgpID0+IHtcbiAgICAgIF9uZXh0RG9jKHRoaXMuY3R4LCB0aGlzLmN0eC5fYmF0Y2hEb2NzLnNoaWZ0KCksIHRoaXMuY3R4Ll9wb3AsIHRoaXMuY2FsbGJhY2spO1xuICAgIH0sXG4gICAgZXJyID0+IHtcbiAgICAgIHRoaXMuY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gICk7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX25leHREb2MoY3R4LCBkb2MsIHBvcCwgY2FsbGJhY2spIHtcbiAgaWYgKGN0eC5xdWVyeS5fbW9uZ29vc2VPcHRpb25zLmxlYW4pIHtcbiAgICByZXR1cm4gY3R4Lm1vZGVsLmhvb2tzLmV4ZWNQb3N0KCdmaW5kJywgY3R4LnF1ZXJ5LCBbW2RvY11dLCBlcnIgPT4ge1xuICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2sobnVsbCwgZG9jKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IHsgbW9kZWwsIF9maWVsZHMsIF91c2VyUHJvdmlkZWRGaWVsZHMsIG9wdGlvbnMgfSA9IGN0eC5xdWVyeTtcbiAgaGVscGVycy5jcmVhdGVNb2RlbEFuZEluaXQobW9kZWwsIGRvYywgX2ZpZWxkcywgX3VzZXJQcm92aWRlZEZpZWxkcywgb3B0aW9ucywgcG9wLCAoZXJyLCBkb2MpID0+IHtcbiAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgIH1cbiAgICBjdHgubW9kZWwuaG9va3MuZXhlY1Bvc3QoJ2ZpbmQnLCBjdHgucXVlcnksIFtbZG9jXV0sIGVyciA9PiB7XG4gICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhudWxsLCBkb2MpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfd2FpdEZvckN1cnNvcihjdHgsIGNiKSB7XG4gIGlmIChjdHguY3Vyc29yKSB7XG4gICAgcmV0dXJuIGNiKCk7XG4gIH1cbiAgY3R4Lm9uY2UoJ2N1cnNvcicsIGZ1bmN0aW9uKGN1cnNvcikge1xuICAgIGlmIChjdXJzb3IgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYigpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBRdWVyeUN1cnNvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/cursor/queryCursor.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/document.js":
/*!********************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/document.js ***!
  \********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst InternalCache = __webpack_require__(/*! ./internal */ \"../backend/node_modules/mongoose/lib/internal.js\");\nconst MongooseError = __webpack_require__(/*! ./error/index */ \"../backend/node_modules/mongoose/lib/error/index.js\");\nconst MixedSchema = __webpack_require__(/*! ./schema/mixed */ \"../backend/node_modules/mongoose/lib/schema/mixed.js\");\nconst ObjectExpectedError = __webpack_require__(/*! ./error/objectExpected */ \"../backend/node_modules/mongoose/lib/error/objectExpected.js\");\nconst ObjectParameterError = __webpack_require__(/*! ./error/objectParameter */ \"../backend/node_modules/mongoose/lib/error/objectParameter.js\");\nconst ParallelValidateError = __webpack_require__(/*! ./error/parallelValidate */ \"../backend/node_modules/mongoose/lib/error/parallelValidate.js\");\nconst Schema = __webpack_require__(/*! ./schema */ \"../backend/node_modules/mongoose/lib/schema.js\");\nconst StrictModeError = __webpack_require__(/*! ./error/strict */ \"../backend/node_modules/mongoose/lib/error/strict.js\");\nconst ValidationError = __webpack_require__(/*! ./error/validation */ \"../backend/node_modules/mongoose/lib/error/validation.js\");\nconst ValidatorError = __webpack_require__(/*! ./error/validator */ \"../backend/node_modules/mongoose/lib/error/validator.js\");\nconst $__hasIncludedChildren = __webpack_require__(/*! ./helpers/projection/hasIncludedChildren */ \"../backend/node_modules/mongoose/lib/helpers/projection/hasIncludedChildren.js\");\nconst applyDefaults = __webpack_require__(/*! ./helpers/document/applyDefaults */ \"../backend/node_modules/mongoose/lib/helpers/document/applyDefaults.js\");\nconst cleanModifiedSubpaths = __webpack_require__(/*! ./helpers/document/cleanModifiedSubpaths */ \"../backend/node_modules/mongoose/lib/helpers/document/cleanModifiedSubpaths.js\");\nconst clone = __webpack_require__(/*! ./helpers/clone */ \"../backend/node_modules/mongoose/lib/helpers/clone.js\");\nconst compile = (__webpack_require__(/*! ./helpers/document/compile */ \"../backend/node_modules/mongoose/lib/helpers/document/compile.js\").compile);\nconst defineKey = (__webpack_require__(/*! ./helpers/document/compile */ \"../backend/node_modules/mongoose/lib/helpers/document/compile.js\").defineKey);\nconst flatten = (__webpack_require__(/*! ./helpers/common */ \"../backend/node_modules/mongoose/lib/helpers/common.js\").flatten);\nconst get = __webpack_require__(/*! ./helpers/get */ \"../backend/node_modules/mongoose/lib/helpers/get.js\");\nconst getEmbeddedDiscriminatorPath = __webpack_require__(/*! ./helpers/document/getEmbeddedDiscriminatorPath */ \"../backend/node_modules/mongoose/lib/helpers/document/getEmbeddedDiscriminatorPath.js\");\nconst getKeysInSchemaOrder = __webpack_require__(/*! ./helpers/schema/getKeysInSchemaOrder */ \"../backend/node_modules/mongoose/lib/helpers/schema/getKeysInSchemaOrder.js\");\nconst getSubdocumentStrictValue = __webpack_require__(/*! ./helpers/schema/getSubdocumentStrictValue */ \"../backend/node_modules/mongoose/lib/helpers/schema/getSubdocumentStrictValue.js\");\nconst handleSpreadDoc = __webpack_require__(/*! ./helpers/document/handleSpreadDoc */ \"../backend/node_modules/mongoose/lib/helpers/document/handleSpreadDoc.js\");\nconst immediate = __webpack_require__(/*! ./helpers/immediate */ \"../backend/node_modules/mongoose/lib/helpers/immediate.js\");\nconst isDefiningProjection = __webpack_require__(/*! ./helpers/projection/isDefiningProjection */ \"../backend/node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js\");\nconst isExclusive = __webpack_require__(/*! ./helpers/projection/isExclusive */ \"../backend/node_modules/mongoose/lib/helpers/projection/isExclusive.js\");\nconst inspect = (__webpack_require__(/*! util */ \"util\").inspect);\nconst internalToObjectOptions = (__webpack_require__(/*! ./options */ \"../backend/node_modules/mongoose/lib/options.js\").internalToObjectOptions);\nconst markArraySubdocsPopulated = __webpack_require__(/*! ./helpers/populate/markArraySubdocsPopulated */ \"../backend/node_modules/mongoose/lib/helpers/populate/markArraySubdocsPopulated.js\");\nconst minimize = __webpack_require__(/*! ./helpers/minimize */ \"../backend/node_modules/mongoose/lib/helpers/minimize.js\");\nconst mpath = __webpack_require__(/*! mpath */ \"../backend/node_modules/mpath/index.js\");\nconst queryhelpers = __webpack_require__(/*! ./queryHelpers */ \"../backend/node_modules/mongoose/lib/queryHelpers.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\nconst isPromise = __webpack_require__(/*! ./helpers/isPromise */ \"../backend/node_modules/mongoose/lib/helpers/isPromise.js\");\n\nconst deepEqual = utils.deepEqual;\nconst isMongooseObject = utils.isMongooseObject;\n\nconst arrayAtomicsBackupSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsBackupSymbol);\nconst arrayAtomicsSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsSymbol);\nconst documentArrayParent = (__webpack_require__(/*! ./helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").documentArrayParent);\nconst documentIsModified = (__webpack_require__(/*! ./helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").documentIsModified);\nconst documentModifiedPaths = (__webpack_require__(/*! ./helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").documentModifiedPaths);\nconst documentSchemaSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").documentSchemaSymbol);\nconst getSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").getSymbol);\nconst populateModelSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").populateModelSymbol);\nconst scopeSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").scopeSymbol);\nconst schemaMixedSymbol = (__webpack_require__(/*! ./schema/symbols */ \"../backend/node_modules/mongoose/lib/schema/symbols.js\").schemaMixedSymbol);\nconst parentPaths = __webpack_require__(/*! ./helpers/path/parentPaths */ \"../backend/node_modules/mongoose/lib/helpers/path/parentPaths.js\");\nconst getDeepestSubdocumentForPath = __webpack_require__(/*! ./helpers/document/getDeepestSubdocumentForPath */ \"../backend/node_modules/mongoose/lib/helpers/document/getDeepestSubdocumentForPath.js\");\nconst sessionNewDocuments = (__webpack_require__(/*! ./helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").sessionNewDocuments);\n\nlet DocumentArray;\nlet MongooseArray;\nlet Embedded;\n\nconst specialProperties = utils.specialProperties;\n\n/**\n * The core Mongoose document constructor. You should not call this directly,\n * the Mongoose [Model constructor](./api/model.html#Model) calls this for you.\n *\n * @param {Object} obj the values to set\n * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data\n * @param {Object} [options] various configuration options for the document\n * @param {Boolean} [options.defaults=true] if `false`, skip applying default values to this document.\n * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#class-eventemitter\n * @event `init`: Emitted on a document after it has been retrieved from the db and fully hydrated by Mongoose.\n * @event `save`: Emitted when the document is successfully saved\n * @api private\n */\n\nfunction Document(obj, fields, skipId, options) {\n  if (typeof skipId === 'object' && skipId != null) {\n    options = skipId;\n    skipId = options.skipId;\n  }\n  options = Object.assign({}, options);\n\n  // Support `browserDocument.js` syntax\n  if (this.$__schema == null) {\n    const _schema = utils.isObject(fields) && !fields.instanceOfSchema ?\n      new Schema(fields) :\n      fields;\n    this.$__setSchema(_schema);\n    fields = skipId;\n    skipId = options;\n    options = arguments[4] || {};\n  }\n\n  this.$__ = new InternalCache();\n\n  // Avoid setting `isNew` to `true`, because it is `true` by default\n  if (options.isNew != null && options.isNew !== true) {\n    this.$isNew = options.isNew;\n  }\n\n  if (options.priorDoc != null) {\n    this.$__.priorDoc = options.priorDoc;\n  }\n\n  if (skipId) {\n    this.$__.skipId = skipId;\n  }\n\n  if (obj != null && typeof obj !== 'object') {\n    throw new ObjectParameterError(obj, 'obj', 'Document');\n  }\n\n  let defaults = true;\n  if (options.defaults !== undefined) {\n    this.$__.defaults = options.defaults;\n    defaults = options.defaults;\n  }\n\n  const schema = this.$__schema;\n\n  if (typeof fields === 'boolean' || fields === 'throw') {\n    if (fields !== true) {\n      this.$__.strictMode = fields;\n    }\n    fields = undefined;\n  } else if (schema.options.strict !== true) {\n    this.$__.strictMode = schema.options.strict;\n  }\n\n  const requiredPaths = schema.requiredPaths(true);\n  for (const path of requiredPaths) {\n    this.$__.activePaths.require(path);\n  }\n\n  let exclude = null;\n\n  // determine if this doc is a result of a query with\n  // excluded fields\n  if (utils.isPOJO(fields) && Object.keys(fields).length > 0) {\n    exclude = isExclusive(fields);\n    this.$__.selected = fields;\n    this.$__.exclude = exclude;\n  }\n\n  const hasIncludedChildren = exclude === false && fields ?\n    $__hasIncludedChildren(fields) :\n    null;\n\n  if (this._doc == null) {\n    this.$__buildDoc(obj, fields, skipId, exclude, hasIncludedChildren, false);\n\n    // By default, defaults get applied **before** setting initial values\n    // Re: gh-6155\n    if (defaults) {\n      applyDefaults(this, fields, exclude, hasIncludedChildren, true, null);\n    }\n  }\n  if (obj) {\n    // Skip set hooks\n    if (this.$__original_set) {\n      this.$__original_set(obj, undefined, true, options);\n    } else {\n      this.$set(obj, undefined, true, options);\n    }\n\n    if (obj instanceof Document) {\n      this.$isNew = obj.$isNew;\n    }\n  }\n\n  // Function defaults get applied **after** setting initial values so they\n  // see the full doc rather than an empty one, unless they opt out.\n  // Re: gh-3781, gh-6155\n  if (options.willInit && defaults) {\n    if (options.skipDefaults) {\n      this.$__.skipDefaults = options.skipDefaults;\n    }\n  } else if (defaults) {\n    applyDefaults(this, fields, exclude, hasIncludedChildren, false, options.skipDefaults);\n  }\n\n  if (!this.$__.strictMode && obj) {\n    const _this = this;\n    const keys = Object.keys(this._doc);\n\n    keys.forEach(function(key) {\n      // Avoid methods, virtuals, existing fields, and `$` keys. The latter is to avoid overwriting\n      // Mongoose internals.\n      if (!(key in schema.tree) && !(key in schema.methods) && !(key in schema.virtuals) && !key.startsWith('$')) {\n        defineKey({ prop: key, subprops: null, prototype: _this });\n      }\n    });\n  }\n\n  applyQueue(this);\n}\n\nDocument.prototype.$isMongooseDocumentPrototype = true;\n\n/**\n * Boolean flag specifying if the document is new. If you create a document\n * using `new`, this document will be considered \"new\". `$isNew` is how\n * Mongoose determines whether `save()` should use `insertOne()` to create\n * a new document or `updateOne()` to update an existing document.\n *\n * #### Example:\n *\n *     const user = new User({ name: 'John Smith' });\n *     user.$isNew; // true\n *\n *     await user.save(); // Sends an `insertOne` to MongoDB\n *\n * On the other hand, if you load an existing document from the database\n * using `findOne()` or another [query operation](https://mongoosejs.com/docs/queries.html),\n * `$isNew` will be false.\n *\n * #### Example:\n *\n *     const user = await User.findOne({ name: 'John Smith' });\n *     user.$isNew; // false\n *\n * Mongoose sets `$isNew` to `false` immediately after `save()` succeeds.\n * That means Mongoose sets `$isNew` to false **before** `post('save')` hooks run.\n * In `post('save')` hooks, `$isNew` will be `false` if `save()` succeeded.\n *\n * #### Example:\n *\n *     userSchema.post('save', function() {\n *       this.$isNew; // false\n *     });\n *     await User.create({ name: 'John Smith' });\n *\n * For subdocuments, `$isNew` is true if either the parent has `$isNew` set,\n * or if you create a new subdocument.\n *\n * #### Example:\n *\n *     // Assume `Group` has a document array `users`\n *     const group = await Group.findOne();\n *     group.users[0].$isNew; // false\n *\n *     group.users.push({ name: 'John Smith' });\n *     group.users[1].$isNew; // true\n *\n * @api public\n * @property $isNew\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, 'isNew', {\n  get: function() {\n    return this.$isNew;\n  },\n  set: function(value) {\n    this.$isNew = value;\n  }\n});\n\n/**\n * Hash containing current validation errors.\n *\n * @api public\n * @property errors\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, 'errors', {\n  get: function() {\n    return this.$errors;\n  },\n  set: function(value) {\n    this.$errors = value;\n  }\n});\n\n/*!\n * ignore\n */\n\nDocument.prototype.$isNew = true;\n\n/*!\n * Document exposes the NodeJS event emitter API, so you can use\n * `on`, `once`, etc.\n */\nutils.each(\n  ['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners',\n    'removeAllListeners', 'addListener'],\n  function(emitterFn) {\n    Document.prototype[emitterFn] = function() {\n      // Delay creating emitter until necessary because emitters take up a lot of memory,\n      // especially for subdocuments.\n      if (!this.$__.emitter) {\n        if (emitterFn === 'emit') {\n          return;\n        }\n        this.$__.emitter = new EventEmitter();\n        this.$__.emitter.setMaxListeners(0);\n      }\n      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n    };\n    Document.prototype[`$${emitterFn}`] = Document.prototype[emitterFn];\n  });\n\nDocument.prototype.constructor = Document;\n\nfor (const i in EventEmitter.prototype) {\n  Document[i] = EventEmitter.prototype[i];\n}\n\n/**\n * The document's internal schema.\n *\n * @api private\n * @property schema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__schema;\n\n/**\n * The document's schema.\n *\n * @api public\n * @property schema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.schema;\n\n/**\n * Empty object that you can use for storing properties on the document. This\n * is handy for passing data to middleware without conflicting with Mongoose\n * internals.\n *\n * #### Example:\n *\n *     schema.pre('save', function() {\n *       // Mongoose will set `isNew` to `false` if `save()` succeeds\n *       this.$locals.wasNew = this.isNew;\n *     });\n *\n *     schema.post('save', function() {\n *       // Prints true if `isNew` was set before `save()`\n *       console.log(this.$locals.wasNew);\n *     });\n *\n * @api public\n * @property $locals\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$locals', {\n  configurable: false,\n  enumerable: false,\n  get: function() {\n    if (this.$__.locals == null) {\n      this.$__.locals = {};\n    }\n    return this.$__.locals;\n  },\n  set: function(v) {\n    this.$__.locals = v;\n  }\n});\n\n/**\n * Legacy alias for `$isNew`.\n *\n * @api public\n * @property isNew\n * @memberOf Document\n * @see $isNew https://mongoosejs.com/docs/api/document.html#Document.prototype.$isNew\n * @instance\n */\n\nDocument.prototype.isNew;\n\n/**\n * Set this property to add additional query filters when Mongoose saves this document and `isNew` is false.\n *\n * #### Example:\n *\n *     // Make sure `save()` never updates a soft deleted document.\n *     schema.pre('save', function() {\n *       this.$where = { isDeleted: false };\n *     });\n *\n * @api public\n * @property $where\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$where', {\n  configurable: false,\n  enumerable: false,\n  writable: true\n});\n\n/**\n * The string version of this documents _id.\n *\n * #### Note:\n *\n * This getter exists on all documents by default. The getter can be disabled by setting the `id` [option](https://mongoosejs.com/docs/guide.html#id) of its `Schema` to false at construction time.\n *\n *     new Schema({ name: String }, { id: false });\n *\n * @api public\n * @see Schema options https://mongoosejs.com/docs/guide.html#options\n * @property id\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.id;\n\n/**\n * Hash containing current validation $errors.\n *\n * @api public\n * @property $errors\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$errors;\n\n/**\n * A string containing the current operation that Mongoose is executing\n * on this document. May be `null`, `'save'`, `'validate'`, or `'remove'`.\n *\n * #### Example:\n *\n *     const doc = new Model({ name: 'test' });\n *     doc.$op; // null\n *\n *     const promise = doc.save();\n *     doc.$op; // 'save'\n *\n *     await promise;\n *     doc.$op; // null\n *\n * @api public\n * @property $op\n * @memberOf Document\n * @instance\n */\n\nObject.defineProperty(Document.prototype, '$op', {\n  get: function() {\n    return this.$__.op || null;\n  },\n  set: function(value) {\n    this.$__.op = value;\n  }\n});\n\n/*!\n * ignore\n */\n\nfunction $applyDefaultsToNested(val, path, doc) {\n  if (val == null) {\n    return;\n  }\n\n  const paths = Object.keys(doc.$__schema.paths);\n  const plen = paths.length;\n\n  const pathPieces = path.indexOf('.') === -1 ? [path] : path.split('.');\n\n  for (let i = 0; i < plen; ++i) {\n    let curPath = '';\n    const p = paths[i];\n\n    if (!p.startsWith(path + '.')) {\n      continue;\n    }\n\n    const type = doc.$__schema.paths[p];\n    const pieces = type.splitPath().slice(pathPieces.length);\n    const len = pieces.length;\n\n    if (type.defaultValue === void 0) {\n      continue;\n    }\n\n    let cur = val;\n\n    for (let j = 0; j < len; ++j) {\n      if (cur == null) {\n        break;\n      }\n\n      const piece = pieces[j];\n\n      if (j === len - 1) {\n        if (cur[piece] !== void 0) {\n          break;\n        }\n\n        try {\n          const def = type.getDefault(doc, false);\n          if (def !== void 0) {\n            cur[piece] = def;\n          }\n        } catch (err) {\n          doc.invalidate(path + '.' + curPath, err);\n          break;\n        }\n\n        break;\n      }\n\n      curPath += (!curPath.length ? '' : '.') + piece;\n\n      cur[piece] = cur[piece] || {};\n      cur = cur[piece];\n    }\n  }\n}\n\n/**\n * Builds the default doc structure\n *\n * @param {Object} obj\n * @param {Object} [fields]\n * @param {Boolean} [skipId]\n * @param {Boolean} [exclude]\n * @param {Object} [hasIncludedChildren]\n * @api private\n * @method $__buildDoc\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__buildDoc = function(obj, fields, skipId, exclude, hasIncludedChildren) {\n  const doc = {};\n\n  const paths = Object.keys(this.$__schema.paths).\n    // Don't build up any paths that are underneath a map, we don't know\n    // what the keys will be\n    filter(p => !p.includes('$*'));\n  const plen = paths.length;\n  let ii = 0;\n\n  for (; ii < plen; ++ii) {\n    const p = paths[ii];\n\n    if (p === '_id') {\n      if (skipId) {\n        continue;\n      }\n      if (obj && '_id' in obj) {\n        continue;\n      }\n    }\n\n    const path = this.$__schema.paths[p].splitPath();\n    const len = path.length;\n    const last = len - 1;\n    let curPath = '';\n    let doc_ = doc;\n    let included = false;\n\n    for (let i = 0; i < len; ++i) {\n      const piece = path[i];\n\n      if (!curPath.length) {\n        curPath = piece;\n      } else {\n        curPath += '.' + piece;\n      }\n\n      // support excluding intermediary levels\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i < last) {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  this._doc = doc;\n};\n\n/*!\n * Converts to POJO when you use the document for querying\n */\n\nDocument.prototype.toBSON = function() {\n  return this.toObject(internalToObjectOptions);\n};\n\n/**\n * Initializes the document without setters or marking anything modified.\n *\n * Called internally after a document is returned from mongodb. Normally,\n * you do **not** need to call this function on your own.\n *\n * This function triggers `init` [middleware](https://mongoosejs.com/docs/middleware.html).\n * Note that `init` hooks are [synchronous](https://mongoosejs.com/docs/middleware.html#synchronous).\n *\n * @param {Object} doc document returned by mongo\n * @param {Object} [opts]\n * @param {Function} [fn]\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.init = function(doc, opts, fn) {\n  if (typeof opts === 'function') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.$__init(doc, opts);\n\n  if (fn) {\n    fn(null, this);\n  }\n\n  return this;\n};\n\n/**\n * Alias for [`.init`](https://mongoosejs.com/docs/api/document.html#Document.prototype.init())\n *\n * @api public\n */\n\nDocument.prototype.$init = function() {\n  return this.constructor.prototype.init.apply(this, arguments);\n};\n\n/**\n * Internal \"init\" function\n *\n * @param {Document} doc\n * @param {Object} [opts]\n * @returns {Document} this\n * @api private\n */\n\nDocument.prototype.$__init = function(doc, opts) {\n  this.$isNew = false;\n  opts = opts || {};\n\n  // handle docs with populated paths\n  // If doc._id is not null or undefined\n  if (doc._id != null && opts.populated && opts.populated.length) {\n    const id = String(doc._id);\n    for (const item of opts.populated) {\n      if (item.isVirtual) {\n        this.$populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.$populated(item.path, item._docs[id], item);\n      }\n\n      if (item._childDocs == null) {\n        continue;\n      }\n      for (const child of item._childDocs) {\n        if (child == null || child.$__ == null) {\n          continue;\n        }\n        child.$__.parent = this;\n      }\n      item._childDocs = [];\n    }\n  }\n\n  init(this, doc, this._doc, opts);\n\n  markArraySubdocsPopulated(this, opts.populated);\n  this.$emit('init', this);\n  this.constructor.emit('init', this);\n\n  const hasIncludedChildren = this.$__.exclude === false && this.$__.selected ?\n    $__hasIncludedChildren(this.$__.selected) :\n    null;\n\n  applyDefaults(this, this.$__.selected, this.$__.exclude, hasIncludedChildren, false, this.$__.skipDefaults);\n  return this;\n};\n\n/**\n * Init helper.\n *\n * @param {Object} self document instance\n * @param {Object} obj raw mongodb doc\n * @param {Object} doc object we are initializing\n * @param {Object} [opts] Optional Options\n * @param {Boolean} [opts.setters] Call `applySetters` instead of `cast`\n * @param {String} [prefix] Prefix to add to each path\n * @api private\n */\n\nfunction init(self, obj, doc, opts, prefix) {\n  prefix = prefix || '';\n\n  if (obj.$__ != null) {\n    obj = obj._doc;\n  }\n  const keys = Object.keys(obj);\n  const len = keys.length;\n  let schemaType;\n  let path;\n  let i;\n  let index = 0;\n  const strict = self.$__.strictMode;\n  const docSchema = self.$__schema;\n\n  while (index < len) {\n    _init(index++);\n  }\n\n  function _init(index) {\n    i = keys[index];\n    // avoid prototype pollution\n    if (i === '__proto__' || i === 'constructor') {\n      return;\n    }\n    path = prefix ? prefix + i : i;\n    schemaType = docSchema.path(path);\n    // Should still work if not a model-level discriminator, but should not be\n    // necessary. This is *only* to catch the case where we queried using the\n    // base model and the discriminated model has a projection\n    if (docSchema.$isRootDiscriminator && !self.$__isSelected(path)) {\n      return;\n    }\n\n    const value = obj[i];\n    if (!schemaType && utils.isPOJO(value)) {\n      // assume nested object\n      if (!doc[i]) {\n        doc[i] = {};\n        if (!strict && !(i in docSchema.tree) && !(i in docSchema.methods) && !(i in docSchema.virtuals)) {\n          self[i] = doc[i];\n        }\n      }\n      init(self, value, doc[i], opts, path + '.');\n    } else if (!schemaType) {\n      doc[i] = value;\n      if (!strict && !prefix) {\n        self[i] = value;\n      }\n    } else {\n      // Retain order when overwriting defaults\n      if (doc.hasOwnProperty(i) && value !== void 0 && !opts.hydratedPopulatedDocs) {\n        delete doc[i];\n      }\n      if (value === null) {\n        doc[i] = schemaType._castNullish(null);\n      } else if (value !== undefined) {\n        const wasPopulated = value.$__ == null ? null : value.$__.wasPopulated;\n\n        if (schemaType && !wasPopulated && !opts.hydratedPopulatedDocs) {\n          try {\n            if (opts && opts.setters) {\n              // Call applySetters with `init = false` because otherwise setters are a noop\n              const overrideInit = false;\n              doc[i] = schemaType.applySetters(value, self, overrideInit);\n            } else {\n              doc[i] = schemaType.cast(value, self, true);\n            }\n          } catch (e) {\n            self.invalidate(e.path, new ValidatorError({\n              path: e.path,\n              message: e.message,\n              type: 'cast',\n              value: e.value,\n              reason: e\n            }));\n          }\n        } else {\n          doc[i] = value;\n        }\n      }\n      // mark as hydrated\n      if (!self.$isModified(path)) {\n        self.$__.activePaths.init(path);\n      }\n    }\n  }\n}\n\n/**\n * Sends an updateOne command with this document `_id` as the query selector.\n *\n * #### Example:\n *\n *     weirdCar.updateOne({$inc: {wheels:1}}, { w: 1 }, callback);\n *\n * #### Valid options:\n *\n *  - same as in [Model.updateOne](https://mongoosejs.com/docs/api/model.html#Model.updateOne)\n *\n * @see Model.updateOne https://mongoosejs.com/docs/api/model.html#Model.updateOne\n * @param {Object} doc\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and the [Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.updateOne = function updateOne(doc, options, callback) {\n  const query = this.constructor.updateOne({ _id: this._id }, doc, options);\n  const self = this;\n  query.pre(function queryPreUpdateOne(cb) {\n    self.constructor._middleware.execPre('updateOne', self, [self], cb);\n  });\n  query.post(function queryPostUpdateOne(cb) {\n    self.constructor._middleware.execPost('updateOne', self, [self], {}, cb);\n  });\n\n  if (this.$session() != null) {\n    if (!('session' in query.options)) {\n      query.options.session = this.$session();\n    }\n  }\n\n  if (callback != null) {\n    return query.exec(callback);\n  }\n\n  return query;\n};\n\n/**\n * Sends a replaceOne command with this document `_id` as the query selector.\n *\n * #### Valid options:\n *\n *  - same as in [Model.replaceOne](https://mongoosejs.com/docs/api/model.html#Model.replaceOne())\n *\n * @see Model.replaceOne https://mongoosejs.com/docs/api/model.html#Model.replaceOne()\n * @param {Object} doc\n * @param {Object} [options]\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.replaceOne = function replaceOne() {\n  const args = [...arguments];\n  args.unshift({ _id: this._id });\n  return this.constructor.replaceOne.apply(this.constructor, args);\n};\n\n/**\n * Getter/setter around the session associated with this document. Used to\n * automatically set `session` if you `save()` a doc that you got from a\n * query with an associated session.\n *\n * #### Example:\n *\n *     const session = MyModel.startSession();\n *     const doc = await MyModel.findOne().session(session);\n *     doc.$session() === session; // true\n *     doc.$session(null);\n *     doc.$session() === null; // true\n *\n * If this is a top-level document, setting the session propagates to all child\n * docs.\n *\n * @param {ClientSession} [session] overwrite the current session\n * @return {ClientSession}\n * @method $session\n * @api public\n * @memberOf Document\n */\n\nDocument.prototype.$session = function $session(session) {\n  if (arguments.length === 0) {\n    if (this.$__.session != null && this.$__.session.hasEnded) {\n      this.$__.session = null;\n      return null;\n    }\n    return this.$__.session;\n  }\n\n  if (session != null && session.hasEnded) {\n    throw new MongooseError('Cannot set a document\\'s session to a session that has ended. Make sure you haven\\'t ' +\n      'called `endSession()` on the session you are passing to `$session()`.');\n  }\n\n  if (session == null && this.$__.session == null) {\n    return;\n  }\n\n  this.$__.session = session;\n\n  if (!this.$isSubdocument) {\n    const subdocs = this.$getAllSubdocs();\n    for (const child of subdocs) {\n      child.$session(session);\n    }\n  }\n\n  return session;\n};\n\n/**\n * Getter/setter around whether this document will apply timestamps by\n * default when using `save()` and `bulkSave()`.\n *\n * #### Example:\n *\n *     const TestModel = mongoose.model('Test', new Schema({ name: String }, { timestamps: true }));\n *     const doc = new TestModel({ name: 'John Smith' });\n *\n *     doc.$timestamps(); // true\n *\n *     doc.$timestamps(false);\n *     await doc.save(); // Does **not** apply timestamps\n *\n * @param {Boolean} [value] overwrite the current session\n * @return {Document|boolean|undefined} When used as a getter (no argument), a boolean will be returned indicating the timestamps option state or if unset \"undefined\" will be used, otherwise will return \"this\"\n * @method $timestamps\n * @api public\n * @memberOf Document\n */\n\nDocument.prototype.$timestamps = function $timestamps(value) {\n  if (arguments.length === 0) {\n    if (this.$__.timestamps != null) {\n      return this.$__.timestamps;\n    }\n\n    if (this.$__schema) {\n      return this.$__schema.options.timestamps;\n    }\n\n    return undefined;\n  }\n\n  const currentValue = this.$timestamps();\n  if (value !== currentValue) {\n    this.$__.timestamps = value;\n  }\n\n  return this;\n};\n\n/**\n * Overwrite all values in this document with the values of `obj`, except\n * for immutable properties. Behaves similarly to `set()`, except for it\n * unsets all properties that aren't in `obj`.\n *\n * @param {Object} obj the object to overwrite this document with\n * @method overwrite\n * @memberOf Document\n * @instance\n * @api public\n * @return {Document} this\n */\n\nDocument.prototype.overwrite = function overwrite(obj) {\n  const keys = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(obj))));\n\n  for (const key of keys) {\n    if (key === '_id') {\n      continue;\n    }\n    // Explicitly skip version key\n    if (this.$__schema.options.versionKey && key === this.$__schema.options.versionKey) {\n      continue;\n    }\n    if (this.$__schema.options.discriminatorKey && key === this.$__schema.options.discriminatorKey) {\n      continue;\n    }\n    this.$set(key, obj[key]);\n  }\n\n  return this;\n};\n\n/**\n * Alias for `set()`, used internally to avoid conflicts\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @param {Boolean} [options.merge=false] if true, setting a [nested path](https://mongoosejs.com/docs/subdocs.html#subdocuments-versus-nested-paths) will merge existing values rather than overwrite the whole object. So `doc.set('nested', { a: 1, b: 2 })` becomes `doc.set('nested.a', 1); doc.set('nested.b', 2);`\n * @return {Document} this\n * @method $set\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.$set = function $set(path, val, type, options) {\n  if (utils.isPOJO(type)) {\n    options = type;\n    type = undefined;\n  }\n\n  const merge = options && options.merge;\n  const adhoc = type && type !== true;\n  const constructing = type === true;\n  let adhocs;\n  let keys;\n  let i = 0;\n  let pathtype;\n  let key;\n  let prefix;\n\n  const userSpecifiedStrict = options && 'strict' in options;\n  let strict = userSpecifiedStrict\n    ? options.strict\n    : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = this.$__schema.interpretAsType(path, type, this.$__schema.options);\n  }\n\n  if (path == null) {\n    [path, val] = [val, path];\n  } else if (typeof path !== 'string') {\n    // new Document({ key: val })\n    if (path instanceof Document) {\n      if (path.$__isNested) {\n        path = path.toObject();\n      } else {\n        // This ternary is to support gh-7898 (copying virtuals if same schema)\n        // while not breaking gh-10819, which for some reason breaks if we use toObject()\n        path = path.$__schema === this.$__schema\n          ? applyVirtuals(path, { ...path._doc })\n          : path._doc;\n      }\n    }\n    if (path == null) {\n      [path, val] = [val, path];\n    }\n\n    prefix = val ? val + '.' : '';\n    keys = getKeysInSchemaOrder(this.$__schema, path);\n\n    const len = keys.length;\n\n    // `_skipMinimizeTopLevel` is because we may have deleted the top-level\n    // nested key to ensure key order.\n    const _skipMinimizeTopLevel = options && options._skipMinimizeTopLevel || false;\n    if (len === 0 && _skipMinimizeTopLevel) {\n      delete options._skipMinimizeTopLevel;\n      if (val) {\n        this.$set(val, {});\n      }\n      return this;\n    }\n\n    options = Object.assign({}, options, { _skipMinimizeTopLevel: false });\n\n    for (let i = 0; i < len; ++i) {\n      key = keys[i];\n      const pathName = prefix ? prefix + key : key;\n      pathtype = this.$__schema.pathType(pathName);\n      const valForKey = path[key];\n\n      // On initial set, delete any nested keys if we're going to overwrite\n      // them to ensure we keep the user's key order.\n      if (type === true &&\n          !prefix &&\n          valForKey != null &&\n          pathtype === 'nested' &&\n          this._doc[key] != null) {\n        delete this._doc[key];\n      }\n\n      if (utils.isNonBuiltinObject(valForKey) && pathtype === 'nested') {\n        this.$set(pathName, valForKey, constructing, Object.assign({}, options, { _skipMarkModified: true }));\n        $applyDefaultsToNested(this.$get(pathName), pathName, this);\n        continue;\n      } else if (strict) {\n        // Don't overwrite defaults with undefined keys (gh-3981) (gh-9039)\n        if (constructing && valForKey === void 0 &&\n            this.$get(pathName) !== void 0) {\n          continue;\n        }\n\n        if (pathtype === 'adhocOrUndefined') {\n          pathtype = getEmbeddedDiscriminatorPath(this, pathName, { typeOnly: true });\n        }\n\n        if (pathtype === 'real' || pathtype === 'virtual') {\n          this.$set(pathName, valForKey, constructing, options);\n        } else if (pathtype === 'nested' && valForKey instanceof Document) {\n          this.$set(pathName,\n            valForKey.toObject({ transform: false }), constructing, options);\n        } else if (strict === 'throw') {\n          if (pathtype === 'nested') {\n            throw new ObjectExpectedError(key, valForKey);\n          } else {\n            throw new StrictModeError(key);\n          }\n        } else if (pathtype === 'nested' && valForKey == null) {\n          this.$set(pathName, valForKey, constructing, options);\n        }\n      } else if (valForKey !== void 0) {\n        this.$set(pathName, valForKey, constructing, options);\n      }\n    }\n\n    // Ensure all properties are in correct order\n    const orderedDoc = {};\n    const orderedKeys = Object.keys(this.$__schema.tree);\n    for (let i = 0, len = orderedKeys.length; i < len; ++i) {\n      (key = orderedKeys[i]) &&\n      (this._doc.hasOwnProperty(key)) &&\n      (orderedDoc[key] = undefined);\n    }\n    this._doc = Object.assign(orderedDoc, this._doc);\n\n    return this;\n  }\n\n  let pathType = this.$__schema.pathType(path);\n  let parts = null;\n  if (pathType === 'adhocOrUndefined') {\n    parts = path.indexOf('.') === -1 ? [path] : path.split('.');\n    pathType = getEmbeddedDiscriminatorPath(this, parts, { typeOnly: true });\n  }\n  if (pathType === 'adhocOrUndefined' && !userSpecifiedStrict) {\n    // May be path underneath non-strict schema\n    if (parts == null) {\n      parts = path.indexOf('.') === -1 ? [path] : path.split('.');\n    }\n    const subdocStrict = getSubdocumentStrictValue(this.$__schema, parts);\n    if (subdocStrict !== undefined) {\n      strict = subdocStrict;\n    }\n  }\n\n  // Assume this is a Mongoose document that was copied into a POJO using\n  // `Object.assign()` or `{...doc}`\n  val = handleSpreadDoc(val, true);\n\n  // if this doc is being constructed we should not trigger getters\n  const priorVal = (() => {\n    if (this.$__.priorDoc != null) {\n      return this.$__.priorDoc.$__getValue(path);\n    }\n    if (constructing) {\n      return void 0;\n    }\n    return this.$__getValue(path);\n  })();\n\n  if (pathType === 'nested' && val) {\n    if (typeof val === 'object' && val != null) {\n      if (val.$__ != null) {\n        val = val.toObject(internalToObjectOptions);\n      }\n      if (val == null) {\n        this.invalidate(path, new MongooseError.CastError('Object', val, path));\n        return this;\n      }\n      const wasModified = this.$isModified(path);\n      const hasInitialVal = this.$__.savedState != null && this.$__.savedState.hasOwnProperty(path);\n      if (this.$__.savedState != null && !this.$isNew && !this.$__.savedState.hasOwnProperty(path)) {\n        const initialVal = this.$__getValue(path);\n        this.$__.savedState[path] = initialVal;\n\n        const keys = Object.keys(initialVal || {});\n        for (const key of keys) {\n          this.$__.savedState[path + '.' + key] = initialVal[key];\n        }\n      }\n\n      if (!merge) {\n        this.$__setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        return this.$set(val, path, constructing);\n      }\n\n      const keys = getKeysInSchemaOrder(this.$__schema, val, path);\n\n      this.$__setValue(path, {});\n      for (const key of keys) {\n        this.$set(path + '.' + key, val[key], constructing, { ...options, _skipMarkModified: true });\n      }\n      if (priorVal != null &&\n          (!wasModified || hasInitialVal) &&\n          utils.deepEqual(hasInitialVal ? this.$__.savedState[path] : priorVal, val)) {\n        this.unmarkModified(path);\n      } else {\n        this.markModified(path);\n      }\n      return this;\n    }\n    this.invalidate(path, new MongooseError.CastError('Object', val, path));\n    return this;\n  }\n\n  let schema;\n  if (parts == null) {\n    parts = path.indexOf('.') === -1 ? [path] : path.split('.');\n  }\n\n  // Might need to change path for top-level alias\n  if (typeof this.$__schema.aliases[parts[0]] === 'string') {\n    parts[0] = this.$__schema.aliases[parts[0]];\n  }\n\n  if (pathType === 'adhocOrUndefined' && strict) {\n    // check for roots that are Mixed types\n    let mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      const subpath = parts.slice(0, i + 1).join('.');\n\n      // If path is underneath a virtual, bypass everything and just set it.\n      if (i + 1 < parts.length && this.$__schema.pathType(subpath) === 'virtual') {\n        mpath.set(path, val, this);\n        return this;\n      }\n\n      schema = this.$__schema.path(subpath);\n      if (schema == null) {\n        continue;\n      }\n\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      } else if (schema.$isSchemaMap && schema.$__schemaType instanceof MixedSchema && i < parts.length - 1) {\n        // Map of mixed and not the last element in the path resolves to mixed\n        mixed = true;\n        schema = schema.$__schemaType;\n        break;\n      }\n    }\n\n    if (schema == null) {\n      // Check for embedded discriminators\n      schema = getEmbeddedDiscriminatorPath(this, path);\n    }\n\n    if (!mixed && !schema) {\n      if (strict === 'throw') {\n        throw new StrictModeError(path);\n      }\n      return this;\n    }\n  } else if (pathType === 'virtual') {\n    schema = this.$__schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  // gh-4578, if setting a deeply nested path that doesn't exist yet, create it\n  let cur = this._doc;\n  let curPath = '';\n  for (i = 0; i < parts.length - 1; ++i) {\n    cur = cur[parts[i]];\n    curPath += (curPath.length !== 0 ? '.' : '') + parts[i];\n    if (!cur) {\n      this.$set(curPath, {});\n      // Hack re: gh-5800. If nested field is not selected, it probably exists\n      // so `MongoServerError: cannot use the part (nested of nested.num) to\n      // traverse the element ({nested: null})` is not likely. If user gets\n      // that error, its their fault for now. We should reconsider disallowing\n      // modifying not selected paths for 6.x\n      if (!this.$__isSelected(curPath)) {\n        this.unmarkModified(curPath);\n      }\n      cur = this.$__getValue(curPath);\n    }\n  }\n\n  let pathToMark;\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: \"LEFT_SUBFIELD only supports Object\"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    const len = parts.length;\n    for (i = 0; i < len; ++i) {\n      const subpath = parts.slice(0, i + 1).join('.');\n      if (this.$get(subpath, null, { getters: false }) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  }\n\n  if (!schema) {\n    this.$__set(pathToMark, path, options, constructing, parts, schema, val, priorVal);\n\n    if (pathType === 'nested' && val == null) {\n      cleanModifiedSubpaths(this, path);\n    }\n    return this;\n  }\n\n  // If overwriting a subdocument path, make sure to clear out\n  // any errors _before_ setting, so new errors that happen\n  // get persisted. Re: #9080\n  if (schema.$isSingleNested || schema.$isMongooseArray) {\n    _markValidSubpaths(this, path);\n  }\n\n  if (val != null && merge && schema.$isSingleNested) {\n    if (val instanceof Document) {\n      val = val.toObject({ virtuals: false, transform: false });\n    }\n    const keys = Object.keys(val);\n    for (const key of keys) {\n      this.$set(path + '.' + key, val[key], constructing, options);\n    }\n\n    return this;\n  }\n\n  let shouldSet = true;\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    const refMatches = (() => {\n      if (schema.options == null) {\n        return false;\n      }\n      if (!(val instanceof Document)) {\n        return false;\n      }\n      const model = val.constructor;\n\n      // Check ref\n      const ref = schema.options.ref;\n      if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {\n        return true;\n      }\n\n      // Check refPath\n      const refPath = schema.options.refPath;\n      if (refPath == null) {\n        return false;\n      }\n      const modelName = val.get(refPath);\n      return modelName === model.modelName || modelName === model.baseModelName;\n    })();\n\n    let didPopulate = false;\n    if (refMatches && val instanceof Document && (!val.$__.wasPopulated || utils.deepEqual(val.$__.wasPopulated.value, val._id))) {\n      const unpopulatedValue = (schema && schema.$isSingleNested) ? schema.cast(val, this) : val._id;\n      this.$populated(path, unpopulatedValue, { [populateModelSymbol]: val.constructor });\n      val.$__.wasPopulated = { value: unpopulatedValue };\n      didPopulate = true;\n    }\n\n    let popOpts;\n    const typeKey = this.$__schema.options.typeKey;\n    if (schema.options &&\n        Array.isArray(schema.options[typeKey]) &&\n        schema.options[typeKey].length &&\n        schema.options[typeKey][0] &&\n        schema.options[typeKey][0].ref &&\n        _isManuallyPopulatedArray(val, schema.options[typeKey][0].ref)) {\n      popOpts = { [populateModelSymbol]: val[0].constructor };\n      this.$populated(path, val.map(function(v) { return v._id; }), popOpts);\n\n      for (const doc of val) {\n        doc.$__.wasPopulated = { value: doc._id };\n      }\n      didPopulate = true;\n    }\n\n    if (!refMatches || !schema.$isSingleNested || !val.$__) {\n      // If this path is underneath a single nested schema, we'll call the setter\n      // later in `$__set()` because we don't take `_doc` when we iterate through\n      // a single nested doc. That's to make sure we get the correct context.\n      // Otherwise we would double-call the setter, see gh-7196.\n      let setterContext = this;\n      if (this.$__schema.singleNestedPaths[path] != null && parts.length > 1) {\n        setterContext = getDeepestSubdocumentForPath(this, parts, this.schema);\n      }\n      if (options != null && options.overwriteImmutable) {\n        val = schema.applySetters(val, setterContext, false, priorVal, { overwriteImmutable: true });\n      } else {\n        val = schema.applySetters(val, setterContext, false, priorVal);\n      }\n    }\n\n    if (Array.isArray(val) &&\n        !Array.isArray(schema) &&\n        schema.$isMongooseDocumentArray &&\n        val.length !== 0 &&\n        val[0] != null &&\n        val[0].$__ != null &&\n        val[0].$__.populated != null) {\n      const populatedPaths = Object.keys(val[0].$__.populated);\n      for (const populatedPath of populatedPaths) {\n        this.$populated(path + '.' + populatedPath,\n          val.map(v => v.$populated(populatedPath)),\n          val[0].$__.populated[populatedPath].options);\n      }\n      didPopulate = true;\n    }\n\n    if (!didPopulate && this.$__.populated) {\n      // If this array partially contains populated documents, convert them\n      // all to ObjectIds re: #8443\n      if (Array.isArray(val) && this.$__.populated[path]) {\n        for (let i = 0; i < val.length; ++i) {\n          if (val[i] instanceof Document) {\n            val.set(i, val[i]._id, true);\n          }\n        }\n      }\n      delete this.$__.populated[path];\n    }\n\n    if (val != null && schema.$isSingleNested) {\n      _checkImmutableSubpaths(val, schema, priorVal);\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    if (e instanceof MongooseError.StrictModeError && e.isImmutableError) {\n      this.invalidate(path, e);\n    } else if (e instanceof MongooseError.CastError) {\n      this.invalidate(e.path, e);\n      if (e.$originalErrorPath) {\n        this.invalidate(path,\n          new MongooseError.CastError(schema.instance, val, path, e.$originalErrorPath));\n      }\n    } else {\n      this.invalidate(path,\n        new MongooseError.CastError(schema.instance, val, path, e));\n    }\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    let savedState = null;\n    let savedStatePath = null;\n    if (!constructing) {\n      const doc = this.$isSubdocument ? this.ownerDocument() : this;\n      savedState = doc.$__.savedState;\n      savedStatePath = this.$isSubdocument ? this.$__.fullPath + '.' + path : path;\n      doc.$__saveInitialState(savedStatePath);\n    }\n\n    this.$__set(pathToMark, path, options, constructing, parts, schema, val, priorVal);\n\n    const isInTransaction = !!this.$__.session?.transaction;\n    const isModifiedWithinTransaction = this.$__.session &&\n      this.$__.session[sessionNewDocuments] &&\n      this.$__.session[sessionNewDocuments].has(this) &&\n      this.$__.session[sessionNewDocuments].get(this).modifiedPaths &&\n      !this.$__.session[sessionNewDocuments].get(this).modifiedPaths.has(savedStatePath);\n    if (savedState != null &&\n        savedState.hasOwnProperty(savedStatePath) &&\n        (!isInTransaction || isModifiedWithinTransaction) &&\n        utils.deepEqual(val, savedState[savedStatePath])) {\n      this.unmarkModified(path);\n    }\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _isManuallyPopulatedArray(val, ref) {\n  if (!Array.isArray(val)) {\n    return false;\n  }\n  if (val.length === 0) {\n    return false;\n  }\n\n  for (const el of val) {\n    if (!(el instanceof Document)) {\n      return false;\n    }\n    const modelName = el.constructor.modelName;\n    if (modelName == null) {\n      return false;\n    }\n    if (el.constructor.modelName != ref && el.constructor.baseModelName != ref) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Sets the value of a path, or many paths.\n * Alias for [`.$set`](https://mongoosejs.com/docs/api/document.html#Document.prototype.$set()).\n *\n * #### Example:\n *\n *     // path, value\n *     doc.set(path, value)\n *\n *     // object\n *     doc.set({\n *         path  : value\n *       , path2 : {\n *            path  : value\n *         }\n *     })\n *\n *     // on-the-fly cast to number\n *     doc.set(path, value, Number)\n *\n *     // on-the-fly cast to string\n *     doc.set(path, value, String)\n *\n *     // changing strict mode behavior\n *     doc.set(path, value, { strict: false });\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @return {Document} this\n * @api public\n * @method set\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.set = Document.prototype.$set;\n\n/**\n * Determine if we should mark this change as modified.\n *\n * @param {never} pathToMark UNUSED\n * @param {String|Symbol} path\n * @param {Object} options\n * @param {Any} constructing\n * @param {never} parts UNUSED\n * @param {Schema} schema\n * @param {Any} val\n * @param {Any} priorVal\n * @return {Boolean}\n * @api private\n * @method $__shouldModify\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__shouldModify = function(pathToMark, path, options, constructing, parts, schema, val, priorVal) {\n  if (options && options._skipMarkModified) {\n    return false;\n  }\n  if (this.$isNew) {\n    return true;\n  }\n  // Is path already modified? If so, always modify. We may unmark modified later.\n  if (path in this.$__.activePaths.getStatePaths('modify')) {\n    return true;\n  }\n\n  if (val === void 0 && !this.$__isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (val === void 0 && path in this.$__.activePaths.getStatePaths('default')) {\n    // we're just unsetting the default value which was never saved\n    return false;\n  }\n\n  // gh-3992: if setting a populated field to a doc, don't mark modified\n  // if they have the same _id\n  if (this.$populated(path) &&\n      val instanceof Document &&\n      deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal !== undefined ? priorVal : utils.getValue(path, this))) {\n    return true;\n  }\n\n  if (!constructing &&\n      val !== null &&\n      val !== undefined &&\n      path in this.$__.activePaths.getStatePaths('default') &&\n      deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n  return false;\n};\n\n/**\n * Handles the actual setting of the value and marking the path modified if appropriate.\n *\n * @param {String} pathToMark\n * @param {String|Symbol} path\n * @param {Object} options\n * @param {Any} constructing\n * @param {Array} parts\n * @param {Schema} schema\n * @param {Any} val\n * @param {Any} priorVal\n * @api private\n * @method $__set\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__set = function(pathToMark, path, options, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || __webpack_require__(/*! ./types/arraySubdocument */ \"../backend/node_modules/mongoose/lib/types/arraySubdocument.js\");\n\n  const shouldModify = this.$__shouldModify(pathToMark, path, options, constructing, parts,\n    schema, val, priorVal);\n\n  if (shouldModify) {\n    if (this.$__.primitiveAtomics && this.$__.primitiveAtomics[path]) {\n      delete this.$__.primitiveAtomics[path];\n      if (Object.keys(this.$__.primitiveAtomics).length === 0) {\n        delete this.$__.primitiveAtomics;\n      }\n    }\n    this.markModified(pathToMark);\n\n    // handle directly setting arrays (gh-1126)\n    MongooseArray || (MongooseArray = __webpack_require__(/*! ./types/array */ \"../backend/node_modules/mongoose/lib/types/array/index.js\"));\n    if (val && utils.isMongooseArray(val)) {\n      val._registerAtomic('$set', val);\n\n      // Update embedded document parent references (gh-5189)\n      if (utils.isMongooseDocumentArray(val)) {\n        val.forEach(function(item) {\n          item && item.__parentArray && (item.__parentArray = val);\n        });\n      }\n    }\n  } else if (Array.isArray(val) && Array.isArray(priorVal) && utils.isMongooseArray(val) && utils.isMongooseArray(priorVal)) {\n    val[arrayAtomicsSymbol] = priorVal[arrayAtomicsSymbol];\n    val[arrayAtomicsBackupSymbol] = priorVal[arrayAtomicsBackupSymbol];\n    if (utils.isMongooseDocumentArray(val)) {\n      val.forEach(doc => {\n        if (doc != null) {\n          doc.$isNew = false;\n        }\n      });\n    }\n  }\n\n  let obj = this._doc;\n  let i = 0;\n  const l = parts.length;\n  let cur = '';\n\n  for (; i < l; i++) {\n    const next = i + 1;\n    const last = next === l;\n    cur += (cur ? '.' + parts[i] : parts[i]);\n    if (specialProperties.has(parts[i])) {\n      return;\n    }\n\n    if (last) {\n      if (obj instanceof Map) {\n        obj.set(parts[i], val);\n      } else if (obj.$isSingleNested) {\n        if (!(parts[i] in obj)) {\n          obj[parts[i]] = val;\n          obj._doc[parts[i]] = val;\n        } else {\n          obj._doc[parts[i]] = val;\n        }\n      } else {\n        obj[parts[i]] = val;\n      }\n    } else {\n      const isMap = obj instanceof Map;\n      let value = isMap ? obj.get(parts[i]) : obj[parts[i]];\n      if (utils.isPOJO(value)) {\n        obj = value;\n      } else if (value && value instanceof Embedded) {\n        obj = value;\n      } else if (value && !Array.isArray(value) && value.$isSingleNested) {\n        obj = value;\n      } else if (value && Array.isArray(value)) {\n        obj = value;\n      } else if (value == null) {\n        value = {};\n        if (isMap) {\n          obj.set(parts[i], value);\n        } else {\n          obj[parts[i]] = value;\n        }\n        obj = value;\n      } else {\n        obj = value;\n      }\n    }\n  }\n};\n\n/**\n * Gets a raw value from a path (no getters)\n *\n * @param {String} path\n * @return {Any} Returns the value from the given `path`.\n * @api private\n */\n\nDocument.prototype.$__getValue = function(path) {\n  return utils.getValue(path, this._doc);\n};\n\n/**\n * Increments the numeric value at `path` by the given `val`.\n * When you call `save()` on this document, Mongoose will send a\n * [`$inc`](https://www.mongodb.com/docs/manual/reference/operator/update/inc/)\n * as opposed to a `$set`.\n *\n * #### Example:\n *\n *     const schema = new Schema({ counter: Number });\n *     const Test = db.model('Test', schema);\n *\n *     const doc = await Test.create({ counter: 0 });\n *     doc.$inc('counter', 2);\n *     await doc.save(); // Sends a `{ $inc: { counter: 2 } }` to MongoDB\n *     doc.counter; // 2\n *\n *     doc.counter += 2;\n *     await doc.save(); // Sends a `{ $set: { counter: 2 } }` to MongoDB\n *\n * @param {String|Array} path path or paths to update\n * @param {Number} val increment `path` by this value\n * @return {Document} this\n */\n\nDocument.prototype.$inc = function $inc(path, val) {\n  if (val == null) {\n    val = 1;\n  }\n\n  if (Array.isArray(path)) {\n    path.forEach((p) => this.$inc(p, val));\n    return this;\n  }\n\n  const schemaType = this.$__path(path);\n  if (schemaType == null) {\n    if (this.$__.strictMode === 'throw') {\n      throw new StrictModeError(path);\n    } else if (this.$__.strictMode === true) {\n      return this;\n    }\n  } else if (schemaType.instance !== 'Number') {\n    this.invalidate(path, new MongooseError.CastError(schemaType.instance, val, path));\n    return this;\n  }\n\n  const currentValue = this.$__getValue(path) || 0;\n  let shouldSet = false;\n  let valToSet = null;\n  let valToInc = val;\n\n  try {\n    val = schemaType.cast(val);\n    valToSet = schemaType.applySetters(currentValue + val, this);\n    valToInc = valToSet - currentValue;\n    shouldSet = true;\n  } catch (err) {\n    this.invalidate(path, new MongooseError.CastError('number', val, path, err));\n  }\n\n  if (shouldSet) {\n    this.$__.primitiveAtomics = this.$__.primitiveAtomics || {};\n    if (this.$__.primitiveAtomics[path] == null) {\n      this.$__.primitiveAtomics[path] = { $inc: valToInc };\n    } else {\n      this.$__.primitiveAtomics[path].$inc += valToInc;\n    }\n    this.markModified(path);\n    this.$__setValue(path, valToSet);\n  }\n\n  return this;\n};\n\n/**\n * Sets a raw value for a path (no casting, setters, transformations)\n *\n * @param {String} path\n * @param {Object} value\n * @return {Document} this\n * @api private\n */\n\nDocument.prototype.$__setValue = function(path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n};\n\n/**\n * Returns the value of a path.\n *\n * #### Example:\n *\n *     // path\n *     doc.get('age') // 47\n *\n *     // dynamic casting to a string\n *     doc.get('age', String) // \"47\"\n *\n * @param {String} path\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for on-the-fly attributes\n * @param {Object} [options]\n * @param {Boolean} [options.virtuals=false] Apply virtuals before getting this path\n * @param {Boolean} [options.getters=true] If false, skip applying getters and just get the raw value\n * @return {Any}\n * @api public\n */\n\nDocument.prototype.get = function(path, type, options) {\n  let adhoc;\n  if (options == null) {\n    options = {};\n  }\n  if (type) {\n    adhoc = this.$__schema.interpretAsType(path, type, this.$__schema.options);\n  }\n  const noDottedPath = options.noDottedPath;\n\n  // Fast path if we know we're just accessing top-level path on the document:\n  // just get the schema path, avoid `$__path()` because that does string manipulation\n  let schema = noDottedPath ? this.$__schema.paths[path] : this.$__path(path);\n  if (schema == null) {\n    schema = this.$__schema.virtualpath(path);\n\n    if (schema != null) {\n      return schema.applyGetters(void 0, this);\n    }\n  }\n\n  if (noDottedPath) {\n    let obj = this._doc[path];\n    if (adhoc) {\n      obj = adhoc.cast(obj);\n    }\n    if (schema != null && options.getters !== false) {\n      return schema.applyGetters(obj, this);\n    }\n    return obj;\n  }\n\n  if (schema != null && schema.instance === 'Mixed') {\n    const virtual = this.$__schema.virtualpath(path);\n    if (virtual != null) {\n      schema = virtual;\n    }\n  }\n\n  const hasDot = path.indexOf('.') !== -1;\n  let obj = this._doc;\n\n  const pieces = hasDot ? path.split('.') : [path];\n  // Might need to change path for top-level alias\n  if (typeof this.$__schema.aliases[pieces[0]] === 'string') {\n    pieces[0] = this.$__schema.aliases[pieces[0]];\n  }\n\n  for (let i = 0, l = pieces.length; i < l; i++) {\n    if (obj && obj._doc) {\n      obj = obj._doc;\n    }\n\n    if (obj == null) {\n      obj = void 0;\n    } else if (obj instanceof Map) {\n      obj = obj.get(pieces[i], { getters: false });\n    } else if (i === l - 1) {\n      obj = utils.getValue(pieces[i], obj);\n    } else {\n      obj = obj[pieces[i]];\n    }\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n\n  if (schema != null && options.getters !== false) {\n    obj = schema.applyGetters(obj, this);\n  } else if (this.$__schema.nested[path] && options.virtuals) {\n    // Might need to apply virtuals if this is a nested path\n    return applyVirtuals(this, clone(obj) || {}, { path: path });\n  }\n\n  return obj;\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype[getSymbol] = Document.prototype.get;\nDocument.prototype.$get = Document.prototype.get;\n\n/**\n * Returns the schematype for the given `path`.\n *\n * @param {String} path\n * @return {SchemaPath}\n * @api private\n * @method $__path\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__path = function(path) {\n  const adhocs = this.$__.adhocPaths;\n  const adhocType = adhocs && adhocs.hasOwnProperty(path) ? adhocs[path] : null;\n\n  if (adhocType) {\n    return adhocType;\n  }\n  return this.$__schema.path(path);\n};\n\n/**\n * Marks the path as having pending changes to write to the db.\n *\n * _Very helpful when using [Mixed](https://mongoosejs.com/docs/schematypes.html#mixed) types._\n *\n * #### Example:\n *\n *     doc.mixed.type = 'changed';\n *     doc.markModified('mixed.type');\n *     doc.save() // changes to mixed.type are now persisted\n *\n * @param {String} path the path to mark modified\n * @param {Document} [scope] the scope to run validators with\n * @api public\n */\n\nDocument.prototype.markModified = function(path, scope) {\n  this.$__saveInitialState(path);\n\n  this.$__.activePaths.modify(path);\n  if (scope != null && !this.$isSubdocument) {\n    this.$__.pathsToScopes = this.$__pathsToScopes || {};\n    this.$__.pathsToScopes[path] = scope;\n  }\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__saveInitialState = function $__saveInitialState(path) {\n  const savedState = this.$__.savedState;\n  const savedStatePath = path;\n  if (savedState != null) {\n    const firstDot = savedStatePath.indexOf('.');\n    const topLevelPath = firstDot === -1 ? savedStatePath : savedStatePath.slice(0, firstDot);\n    if (!savedState.hasOwnProperty(topLevelPath)) {\n      savedState[topLevelPath] = clone(this.$__getValue(topLevelPath));\n    }\n  }\n};\n\n/**\n * Clears the modified state on the specified path.\n *\n * #### Example:\n *\n *     doc.foo = 'bar';\n *     doc.unmarkModified('foo');\n *     doc.save(); // changes to foo will not be persisted\n *\n * @param {String} path the path to unmark modified\n * @api public\n */\n\nDocument.prototype.unmarkModified = function(path) {\n  this.$__.activePaths.init(path);\n  if (this.$__.pathsToScopes != null) {\n    delete this.$__.pathsToScopes[path];\n  }\n};\n\n/**\n * Don't run validation on this path or persist changes to this path.\n *\n * #### Example:\n *\n *     doc.foo = null;\n *     doc.$ignore('foo');\n *     doc.save(); // changes to foo will not be persisted and validators won't be run\n *\n * @memberOf Document\n * @instance\n * @method $ignore\n * @param {String} path the path to ignore\n * @api public\n */\n\nDocument.prototype.$ignore = function(path) {\n  this.$__.activePaths.ignore(path);\n};\n\n/**\n * Returns the list of paths that have been directly modified. A direct\n * modified path is a path that you explicitly set, whether via `doc.foo = 'bar'`,\n * `Object.assign(doc, { foo: 'bar' })`, or `doc.set('foo', 'bar')`.\n *\n * A path `a` may be in `modifiedPaths()` but not in `directModifiedPaths()`\n * because a child of `a` was directly modified.\n *\n * #### Example:\n *\n *     const schema = new Schema({ foo: String, nested: { bar: String } });\n *     const Model = mongoose.model('Test', schema);\n *     await Model.create({ foo: 'original', nested: { bar: 'original' } });\n *\n *     const doc = await Model.findOne();\n *     doc.nested.bar = 'modified';\n *     doc.directModifiedPaths(); // ['nested.bar']\n *     doc.modifiedPaths(); // ['nested', 'nested.bar']\n *\n * @return {String[]}\n * @api public\n */\n\nDocument.prototype.directModifiedPaths = function() {\n  return Object.keys(this.$__.activePaths.getStatePaths('modify'));\n};\n\n/**\n * Returns true if the given path is nullish or only contains empty objects.\n * Useful for determining whether this subdoc will get stripped out by the\n * [minimize option](https://mongoosejs.com/docs/guide.html#minimize).\n *\n * #### Example:\n *\n *     const schema = new Schema({ nested: { foo: String } });\n *     const Model = mongoose.model('Test', schema);\n *     const doc = new Model({});\n *     doc.$isEmpty('nested'); // true\n *     doc.nested.$isEmpty(); // true\n *\n *     doc.nested.foo = 'bar';\n *     doc.$isEmpty('nested'); // false\n *     doc.nested.$isEmpty(); // false\n *\n * @param {String} [path]\n * @memberOf Document\n * @instance\n * @api public\n * @method $isEmpty\n * @return {Boolean}\n */\n\nDocument.prototype.$isEmpty = function(path) {\n  const isEmptyOptions = {\n    minimize: true,\n    virtuals: false,\n    getters: false,\n    transform: false\n  };\n\n  if (arguments.length !== 0) {\n    const v = this.$get(path);\n    if (v == null) {\n      return true;\n    }\n    if (typeof v !== 'object') {\n      return false;\n    }\n    if (utils.isPOJO(v)) {\n      return _isEmpty(v);\n    }\n    return Object.keys(v.toObject(isEmptyOptions)).length === 0;\n  }\n\n  return Object.keys(this.toObject(isEmptyOptions)).length === 0;\n};\n\n/*!\n * ignore\n */\n\nfunction _isEmpty(v) {\n  if (v == null) {\n    return true;\n  }\n  if (typeof v !== 'object' || Array.isArray(v)) {\n    return false;\n  }\n  for (const key of Object.keys(v)) {\n    if (!_isEmpty(v[key])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Returns the list of paths that have been modified.\n *\n * @param {Object} [options]\n * @param {Boolean} [options.includeChildren=false] if true, returns children of modified paths as well. For example, if false, the list of modified paths for `doc.colors = { primary: 'blue' };` will **not** contain `colors.primary`. If true, `modifiedPaths()` will return an array that contains `colors.primary`.\n * @return {String[]}\n * @api public\n */\n\nDocument.prototype.modifiedPaths = function(options) {\n  options = options || {};\n\n  const directModifiedPaths = Object.keys(this.$__.activePaths.getStatePaths('modify'));\n  const result = new Set();\n\n  let i = 0;\n  let j = 0;\n  const len = directModifiedPaths.length;\n\n  for (i = 0; i < len; ++i) {\n    const path = directModifiedPaths[i];\n    const parts = parentPaths(path);\n    const pLen = parts.length;\n\n    for (j = 0; j < pLen; ++j) {\n      result.add(parts[j]);\n    }\n\n    if (!options.includeChildren) {\n      continue;\n    }\n\n    let ii = 0;\n    let cur = this.$get(path);\n    if (typeof cur === 'object' && cur !== null) {\n      if (cur._doc) {\n        cur = cur._doc;\n      }\n      const len = cur.length;\n      if (Array.isArray(cur)) {\n        for (ii = 0; ii < len; ++ii) {\n          const subPath = path + '.' + ii;\n          if (!result.has(subPath)) {\n            result.add(subPath);\n            if (cur[ii] != null && cur[ii].$__) {\n              const modified = cur[ii].modifiedPaths();\n              let iii = 0;\n              const iiiLen = modified.length;\n              for (iii = 0; iii < iiiLen; ++iii) {\n                result.add(subPath + '.' + modified[iii]);\n              }\n            }\n          }\n        }\n      } else {\n        const keys = Object.keys(cur);\n        let ii = 0;\n        const len = keys.length;\n        for (ii = 0; ii < len; ++ii) {\n          result.add(path + '.' + keys[ii]);\n        }\n      }\n    }\n  }\n  return Array.from(result);\n};\n\nDocument.prototype[documentModifiedPaths] = Document.prototype.modifiedPaths;\n\n/**\n * Returns true if any of the given paths is modified, else false. If no arguments, returns `true` if any path\n * in this document is modified.\n *\n * If `path` is given, checks if a path or any full path containing `path` as part of its path chain has been modified.\n *\n * #### Example:\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isModified()                      // true\n *     doc.isModified('documents')           // true\n *     doc.isModified('documents.0.title')   // true\n *     doc.isModified('documents otherProp') // true\n *     doc.isDirectModified('documents')     // false\n *\n * @param {String} [path] optional\n * @param {Object} [options]\n * @param {Boolean} [options.ignoreAtomics=false] If true, doesn't return true if path is underneath an array that was modified with atomic operations like `push()`\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isModified = function(paths, options, modifiedPaths) {\n  if (paths) {\n    const ignoreAtomics = options && options.ignoreAtomics;\n    const directModifiedPathsObj = this.$__.activePaths.states.modify;\n    if (directModifiedPathsObj == null) {\n      return false;\n    }\n\n    if (typeof paths === 'string') {\n      paths = paths.indexOf(' ') === -1 ? [paths] : paths.split(' ');\n    }\n\n    for (const path of paths) {\n      if (directModifiedPathsObj[path] != null) {\n        return true;\n      }\n    }\n\n    const modified = modifiedPaths || this[documentModifiedPaths]();\n    const isModifiedChild = paths.some(function(path) {\n      return !!~modified.indexOf(path);\n    });\n\n    let directModifiedPaths = Object.keys(directModifiedPathsObj);\n    if (ignoreAtomics) {\n      directModifiedPaths = directModifiedPaths.filter(path => {\n        const value = this.$__getValue(path);\n        if (value != null && value[arrayAtomicsSymbol] != null && value[arrayAtomicsSymbol].$set === undefined) {\n          return false;\n        }\n        return true;\n      });\n    }\n    return isModifiedChild || paths.some(function(path) {\n      return directModifiedPaths.some(function(mod) {\n        return mod === path || path.startsWith(mod + '.');\n      });\n    });\n  }\n\n  return this.$__.activePaths.some('modify');\n};\n\n/**\n * Alias of [`.isModified`](https://mongoosejs.com/docs/api/document.html#Document.prototype.isModified())\n *\n * @method $isModified\n * @memberOf Document\n * @api public\n */\n\nDocument.prototype.$isModified = Document.prototype.isModified;\n\nDocument.prototype[documentIsModified] = Document.prototype.isModified;\n\n/**\n * Checks if a path is set to its default.\n *\n * #### Example:\n *\n *     MyModel = mongoose.model('test', { name: { type: String, default: 'Val '} });\n *     const m = new MyModel();\n *     m.$isDefault('name'); // true\n *\n * @memberOf Document\n * @instance\n * @method $isDefault\n * @param {String} [path]\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.$isDefault = function(path) {\n  if (path == null) {\n    return this.$__.activePaths.some('default');\n  }\n\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.getStatePaths('default').hasOwnProperty(path);\n  }\n\n  let paths = path;\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n\n  return paths.some(path => this.$__.activePaths.getStatePaths('default').hasOwnProperty(path));\n};\n\n/**\n * Getter/setter, determines whether the document was removed or not.\n *\n * #### Example:\n *\n *     const product = await product.remove();\n *     product.$isDeleted(); // true\n *     product.remove(); // no-op, doesn't send anything to the db\n *\n *     product.$isDeleted(false);\n *     product.$isDeleted(); // false\n *     product.remove(); // will execute a remove against the db\n *\n *\n * @param {Boolean} [val] optional, overrides whether mongoose thinks the doc is deleted\n * @return {Boolean|Document} whether mongoose thinks this doc is deleted.\n * @method $isDeleted\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.$isDeleted = function(val) {\n  if (arguments.length === 0) {\n    return !!this.$__.isDeleted;\n  }\n\n  this.$__.isDeleted = !!val;\n  return this;\n};\n\n/**\n * Returns true if `path` was directly set and modified, else false.\n *\n * #### Example:\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isDirectModified('documents.0.title') // true\n *     doc.isDirectModified('documents') // false\n *\n * @param {String|String[]} [path]\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isDirectModified = function(path) {\n  if (path == null) {\n    return this.$__.activePaths.some('modify');\n  }\n\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.getStatePaths('modify').hasOwnProperty(path);\n  }\n\n  let paths = path;\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n\n  return paths.some(path => this.$__.activePaths.getStatePaths('modify').hasOwnProperty(path));\n};\n\n/**\n * Checks if `path` is in the `init` state, that is, it was set by `Document#init()` and not modified since.\n *\n * @param {String} [path]\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isInit = function(path) {\n  if (path == null) {\n    return this.$__.activePaths.some('init');\n  }\n\n  if (typeof path === 'string' && path.indexOf(' ') === -1) {\n    return this.$__.activePaths.getStatePaths('init').hasOwnProperty(path);\n  }\n\n  let paths = path;\n  if (!Array.isArray(paths)) {\n    paths = paths.split(' ');\n  }\n\n  return paths.some(path => this.$__.activePaths.getStatePaths('init').hasOwnProperty(path));\n};\n\n/**\n * Checks if `path` was selected in the source query which initialized this document.\n *\n * #### Example:\n *\n *     const doc = await Thing.findOne().select('name');\n *     doc.isSelected('name') // true\n *     doc.isSelected('age')  // false\n *\n * @param {String|String[]} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isSelected = function isSelected(path) {\n  if (this.$__.selected == null) {\n    return true;\n  }\n  if (!path) {\n    return false;\n  }\n  if (path === '_id') {\n    return this.$__.selected._id !== 0;\n  }\n\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n  if (Array.isArray(path)) {\n    return path.some(p => this.$__isSelected(p));\n  }\n\n  const paths = Object.keys(this.$__.selected);\n  let inclusive = null;\n\n  if (paths.length === 1 && paths[0] === '_id') {\n    // only _id was selected.\n    return this.$__.selected._id === 0;\n  }\n\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n    if (!isDefiningProjection(this.$__.selected[cur])) {\n      continue;\n    }\n    inclusive = !!this.$__.selected[cur];\n    break;\n  }\n\n  if (inclusive === null) {\n    return true;\n  }\n\n  if (path in this.$__.selected) {\n    return inclusive;\n  }\n\n  const pathDot = path + '.';\n\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n\n    if (cur.startsWith(pathDot)) {\n      return inclusive || cur !== pathDot;\n    }\n\n    if (pathDot.startsWith(cur + '.')) {\n      return inclusive;\n    }\n  }\n  return !inclusive;\n};\n\nDocument.prototype.$__isSelected = Document.prototype.isSelected;\n\n/**\n * Checks if `path` was explicitly selected. If no projection, always returns\n * true.\n *\n * #### Example:\n *\n *     Thing.findOne().select('nested.name').exec(function (err, doc) {\n *        doc.isDirectSelected('nested.name') // true\n *        doc.isDirectSelected('nested.otherName') // false\n *        doc.isDirectSelected('nested')  // false\n *     })\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isDirectSelected = function isDirectSelected(path) {\n  if (this.$__.selected == null) {\n    return true;\n  }\n\n  if (path === '_id') {\n    return this.$__.selected._id !== 0;\n  }\n\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n  if (Array.isArray(path)) {\n    return path.some(p => this.isDirectSelected(p));\n  }\n\n  const paths = Object.keys(this.$__.selected);\n  let inclusive = null;\n\n  if (paths.length === 1 && paths[0] === '_id') {\n    // only _id was selected.\n    return this.$__.selected._id === 0;\n  }\n\n  for (const cur of paths) {\n    if (cur === '_id') {\n      continue;\n    }\n    if (!isDefiningProjection(this.$__.selected[cur])) {\n      continue;\n    }\n    inclusive = !!this.$__.selected[cur];\n    break;\n  }\n\n  if (inclusive === null) {\n    return true;\n  }\n\n  if (this.$__.selected.hasOwnProperty(path)) {\n    return inclusive;\n  }\n\n  return !inclusive;\n};\n\n/**\n * Executes registered validation rules for this document.\n *\n * #### Note:\n *\n * This method is called `pre` save and if a validation rule is violated, [save](https://mongoosejs.com/docs/api/model.html#Model.prototype.save()) is aborted and the error is thrown.\n *\n * #### Example:\n *\n *     await doc.validate({ validateModifiedOnly: false, pathsToSkip: ['name', 'email']});\n *\n * @param {Array|String} [pathsToValidate] list of paths to validate. If set, Mongoose will validate only the modified paths that are in the given list.\n * @param {Object} [options] internal options\n * @param {Boolean} [options.validateModifiedOnly=false] if `true` mongoose validates only modified paths.\n * @param {Array|string} [options.pathsToSkip] list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.\n * @return {Promise} Returns a Promise.\n * @api public\n */\n\nDocument.prototype.validate = async function validate(pathsToValidate, options) {\n  if (typeof pathsToValidate === 'function' || typeof options === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Document.prototype.validate() no longer accepts a callback');\n  }\n  let parallelValidate;\n  this.$op = 'validate';\n\n  if (this.$isSubdocument != null) {\n    // Skip parallel validate check for subdocuments\n  } else if (this.$__.validating) {\n    parallelValidate = new ParallelValidateError(this, {\n      parentStack: options && options.parentStack,\n      conflictStack: this.$__.validating.stack\n    });\n  } else {\n    this.$__.validating = new ParallelValidateError(this, { parentStack: options && options.parentStack });\n  }\n\n  if (arguments.length === 1) {\n    if (typeof arguments[0] === 'object' && !Array.isArray(arguments[0])) {\n      options = arguments[0];\n      pathsToValidate = null;\n    }\n  }\n  if (options && typeof options.pathsToSkip === 'string') {\n    const isOnePathOnly = options.pathsToSkip.indexOf(' ') === -1;\n    options.pathsToSkip = isOnePathOnly ? [options.pathsToSkip] : options.pathsToSkip.split(' ');\n  }\n\n  if (parallelValidate != null) {\n    throw parallelValidate;\n  }\n\n  return new Promise((resolve, reject) => {\n    this.$__validate(pathsToValidate, options, (error) => {\n      this.$op = null;\n      this.$__.validating = null;\n      if (error != null) {\n        return reject(error);\n      }\n      resolve();\n    });\n  });\n};\n\n/**\n * Alias of [`.validate`](https://mongoosejs.com/docs/api/document.html#Document.prototype.validate())\n *\n * @method $validate\n * @memberOf Document\n * @api public\n */\n\nDocument.prototype.$validate = Document.prototype.validate;\n\n/*!\n * ignore\n */\n\nfunction _evaluateRequiredFunctions(doc) {\n  const requiredFields = Object.keys(doc.$__.activePaths.getStatePaths('require'));\n  let i = 0;\n  const len = requiredFields.length;\n  for (i = 0; i < len; ++i) {\n    const path = requiredFields[i];\n\n    const p = doc.$__schema.path(path);\n\n    if (p != null && typeof p.originalRequiredValue === 'function') {\n      doc.$__.cachedRequired = doc.$__.cachedRequired || {};\n      try {\n        doc.$__.cachedRequired[path] = p.originalRequiredValue.call(doc, doc);\n      } catch (err) {\n        doc.invalidate(path, err);\n      }\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _getPathsToValidate(doc, pathsToValidate, pathsToSkip) {\n  const doValidateOptions = {};\n\n  _evaluateRequiredFunctions(doc);\n  // only validate required fields when necessary\n  let paths = new Set(Object.keys(doc.$__.activePaths.getStatePaths('require')).filter(function(path) {\n    if (!doc.$__isSelected(path) && !doc.$isModified(path)) {\n      return false;\n    }\n    if (doc.$__.cachedRequired != null && path in doc.$__.cachedRequired) {\n      return doc.$__.cachedRequired[path];\n    }\n    return true;\n  }));\n\n  Object.keys(doc.$__.activePaths.getStatePaths('init')).forEach(addToPaths);\n  Object.keys(doc.$__.activePaths.getStatePaths('modify')).forEach(addToPaths);\n  Object.keys(doc.$__.activePaths.getStatePaths('default')).forEach(addToPaths);\n  function addToPaths(p) { paths.add(p); }\n\n  const subdocs = doc.$getAllSubdocs();\n  const modifiedPaths = doc.modifiedPaths();\n  for (const subdoc of subdocs) {\n    if (subdoc.$basePath) {\n      const fullPathToSubdoc = subdoc.$isSingleNested ? subdoc.$__pathRelativeToParent() : subdoc.$__fullPathWithIndexes();\n\n      // Remove child paths for now, because we'll be validating the whole\n      // subdoc.\n      // The following is a faster take on looping through every path in `paths`\n      // and checking if the path starts with `fullPathToSubdoc` re: gh-13191\n      for (const modifiedPath of subdoc.modifiedPaths()) {\n        paths.delete(fullPathToSubdoc + '.' + modifiedPath);\n      }\n\n      if (doc.$isModified(fullPathToSubdoc, null, modifiedPaths) &&\n            !doc.isDirectModified(fullPathToSubdoc) &&\n            !doc.$isDefault(fullPathToSubdoc)) {\n        paths.add(fullPathToSubdoc);\n        if (doc.$__.pathsToScopes == null) {\n          doc.$__.pathsToScopes = {};\n        }\n        doc.$__.pathsToScopes[fullPathToSubdoc] = subdoc.$isDocumentArrayElement ?\n          subdoc.__parentArray :\n          subdoc.$parent();\n\n        doValidateOptions[fullPathToSubdoc] = { skipSchemaValidators: true };\n        if (subdoc.$isDocumentArrayElement && subdoc.__index != null) {\n          doValidateOptions[fullPathToSubdoc].index = subdoc.__index;\n        }\n      }\n    }\n  }\n\n  for (const path of paths) {\n    const _pathType = doc.$__schema.path(path);\n    if (!_pathType) {\n      continue;\n    }\n\n    if (_pathType.$isMongooseDocumentArray) {\n      for (const p of paths) {\n        if (p == null || p.startsWith(_pathType.path + '.')) {\n          paths.delete(p);\n        }\n      }\n    }\n\n    // Optimization: if primitive path with no validators, or array of primitives\n    // with no validators, skip validating this path entirely.\n    if (!_pathType.caster && _pathType.validators.length === 0 && !_pathType.$parentSchemaDocArray) {\n      paths.delete(path);\n    } else if (_pathType.$isMongooseArray &&\n      !_pathType.$isMongooseDocumentArray && // Skip document arrays...\n      !_pathType.$embeddedSchemaType.$isMongooseArray && // and arrays of arrays\n      _pathType.validators.length === 0 && // and arrays with top-level validators\n      _pathType.$embeddedSchemaType.validators.length === 0) {\n      paths.delete(path);\n    }\n  }\n\n  for (const path of paths) {\n    // Single nested paths (paths embedded under single nested subdocs) will\n    // be validated on their own when we call `validate()` on the subdoc itself.\n    // Re: gh-8468\n    if (doc.$__schema.singleNestedPaths.hasOwnProperty(path)) {\n      paths.delete(path);\n      continue;\n    }\n  }\n\n  if (Array.isArray(pathsToValidate)) {\n    paths = _handlePathsToValidate(paths, pathsToValidate);\n  } else if (Array.isArray(pathsToSkip)) {\n    paths = _handlePathsToSkip(paths, pathsToSkip);\n  }\n\n  // from here on we're not removing items from paths\n\n  // gh-661: if a whole array is modified, make sure to run validation on all\n  // the children as well\n  _addArrayPathsToValidate(doc, paths);\n\n  const flattenOptions = { skipArrays: true };\n  for (const pathToCheck of paths) {\n    if (doc.$__schema.nested[pathToCheck]) {\n      let _v = doc.$__getValue(pathToCheck);\n      if (isMongooseObject(_v)) {\n        _v = _v.toObject({ transform: false });\n      }\n      const flat = flatten(_v, pathToCheck, flattenOptions, doc.$__schema);\n      Object.keys(flat).forEach(addToPaths);\n    }\n  }\n\n  for (const path of paths) {\n    const _pathType = doc.$__schema.path(path);\n\n    if (!_pathType) {\n      continue;\n    }\n\n    // If underneath a document array, may need to re-validate the parent\n    // array re: gh-6818. Do this _after_ adding subpaths, because\n    // we don't want to add every array subpath.\n    if (_pathType.$parentSchemaDocArray && typeof _pathType.$parentSchemaDocArray.path === 'string') {\n      paths.add(_pathType.$parentSchemaDocArray.path);\n    }\n\n    if (!_pathType.$isSchemaMap) {\n      continue;\n    }\n\n    const val = doc.$__getValue(path);\n    if (val == null) {\n      continue;\n    }\n    for (const key of val.keys()) {\n      paths.add(path + '.' + key);\n    }\n  }\n\n  paths = Array.from(paths);\n  return [paths, doValidateOptions];\n}\n\nfunction _addArrayPathsToValidate(doc, paths) {\n  for (const path of paths) {\n    const _pathType = doc.$__schema.path(path);\n    if (!_pathType) {\n      continue;\n    }\n\n    if (!_pathType.$isMongooseArray ||\n        // To avoid potential performance issues, skip doc arrays whose children\n        // are not required. `getPositionalPathType()` may be slow, so avoid\n        // it unless we have a case of #6364\n        (!Array.isArray(_pathType) &&\n          _pathType.$isMongooseDocumentArray &&\n          !(_pathType && _pathType.schemaOptions && _pathType.schemaOptions.required))) {\n      continue;\n    }\n\n    // gh-11380: optimization. If the array isn't a document array and there's no validators\n    // on the array type, there's no need to run validation on the individual array elements.\n    if (_pathType.$isMongooseArray &&\n        !_pathType.$isMongooseDocumentArray && // Skip document arrays...\n        !_pathType.$embeddedSchemaType.$isMongooseArray && // and arrays of arrays\n        _pathType.$embeddedSchemaType.validators.length === 0) {\n      continue;\n    }\n\n    const val = doc.$__getValue(path);\n    _pushNestedArrayPaths(val, paths, path);\n  }\n}\n\nfunction _pushNestedArrayPaths(val, paths, path) {\n  if (val != null) {\n    const numElements = val.length;\n    for (let j = 0; j < numElements; ++j) {\n      if (Array.isArray(val[j])) {\n        _pushNestedArrayPaths(val[j], paths, path + '.' + j);\n      } else {\n        paths.add(path + '.' + j);\n      }\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__validate = function(pathsToValidate, options, callback) {\n  if (this.$__.saveOptions && this.$__.saveOptions.pathsToSave && !pathsToValidate) {\n    pathsToValidate = [...this.$__.saveOptions.pathsToSave];\n  } else if (typeof pathsToValidate === 'function') {\n    callback = pathsToValidate;\n    options = null;\n    pathsToValidate = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  const hasValidateModifiedOnlyOption = options &&\n      (typeof options === 'object') &&\n      ('validateModifiedOnly' in options);\n\n  const pathsToSkip = (options && options.pathsToSkip) || null;\n\n  let shouldValidateModifiedOnly;\n  if (hasValidateModifiedOnlyOption) {\n    shouldValidateModifiedOnly = !!options.validateModifiedOnly;\n  } else {\n    shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;\n  }\n\n  const validateAllPaths = options && options.validateAllPaths;\n  if (validateAllPaths) {\n    if (pathsToSkip) {\n      throw new TypeError('Cannot set both `validateAllPaths` and `pathsToSkip`');\n    }\n    if (pathsToValidate) {\n      throw new TypeError('Cannot set both `validateAllPaths` and `pathsToValidate`');\n    }\n    if (hasValidateModifiedOnlyOption && shouldValidateModifiedOnly) {\n      throw new TypeError('Cannot set both `validateAllPaths` and `validateModifiedOnly`');\n    }\n  }\n\n  const _this = this;\n  const _complete = () => {\n    let validationError = this.$__.validationError;\n    this.$__.validationError = null;\n    this.$__.validating = null;\n\n    if (shouldValidateModifiedOnly && validationError != null) {\n      // Remove any validation errors that aren't from modified paths\n      const errors = Object.keys(validationError.errors);\n      for (const errPath of errors) {\n        if (!this.$isModified(errPath)) {\n          delete validationError.errors[errPath];\n        }\n      }\n      if (Object.keys(validationError.errors).length === 0) {\n        validationError = void 0;\n      }\n    }\n\n    this.$__.cachedRequired = {};\n    this.$emit('validate', _this);\n    this.constructor.emit('validate', _this);\n\n    if (validationError) {\n      for (const key in validationError.errors) {\n        // Make sure cast errors persist\n        if (!this[documentArrayParent] &&\n            validationError.errors[key] instanceof MongooseError.CastError) {\n          this.invalidate(key, validationError.errors[key]);\n        }\n      }\n\n      return validationError;\n    }\n  };\n\n  // only validate required fields when necessary\n  let paths;\n  let doValidateOptionsByPath;\n  if (validateAllPaths) {\n    paths = new Set(Object.keys(this.$__schema.paths));\n    // gh-661: if a whole array is modified, make sure to run validation on all\n    // the children as well\n    for (const path of paths) {\n      const schemaType = this.$__schema.path(path);\n      if (!schemaType || !schemaType.$isMongooseArray) {\n        continue;\n      }\n      const val = this.$__getValue(path);\n      if (!val) {\n        continue;\n      }\n      _pushNestedArrayPaths(val, paths, path);\n    }\n    paths = [...paths];\n    doValidateOptionsByPath = {};\n  } else {\n    const pathDetails = _getPathsToValidate(this, pathsToValidate, pathsToSkip);\n    paths = shouldValidateModifiedOnly ?\n      pathDetails[0].filter((path) => this.$isModified(path)) :\n      pathDetails[0];\n    doValidateOptionsByPath = pathDetails[1];\n  }\n\n  if (typeof pathsToValidate === 'string') {\n    pathsToValidate = pathsToValidate.split(' ');\n  }\n\n  if (paths.length === 0) {\n    return immediate(function() {\n      const error = _complete();\n      if (error) {\n        return _this.$__schema.s.hooks.execPost('validate:error', _this, [_this], { error: error }, function(error) {\n          callback(error);\n        });\n      }\n      callback(null, _this);\n    });\n  }\n\n  const validated = {};\n  let total = 0;\n\n  let pathsToSave = this.$__.saveOptions?.pathsToSave;\n  if (Array.isArray(pathsToSave)) {\n    pathsToSave = new Set(pathsToSave);\n    for (const path of paths) {\n      if (!pathsToSave.has(path)) {\n        continue;\n      }\n      validatePath(path);\n    }\n  } else {\n    for (const path of paths) {\n      validatePath(path);\n    }\n  }\n\n  function validatePath(path) {\n    if (path == null || validated[path]) {\n      return;\n    }\n\n    validated[path] = true;\n    total++;\n\n    immediate(function() {\n      const schemaType = _this.$__schema.path(path);\n\n      if (!schemaType) {\n        return --total || complete();\n      }\n\n      // If user marked as invalid or there was a cast error, don't validate\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      // If setting a path under a mixed path, avoid using the mixed path validator (gh-10141)\n      if (schemaType[schemaMixedSymbol] != null && path !== schemaType.path) {\n        return --total || complete();\n      }\n\n      let val = _this.$__getValue(path);\n\n      // If you `populate()` and get back a null value, required validators\n      // shouldn't fail (gh-8018). We should always fall back to the populated\n      // value.\n      let pop;\n      if ((pop = _this.$populated(path))) {\n        val = pop;\n      } else if (val != null && val.$__ != null && val.$__.wasPopulated) {\n        // Array paths, like `somearray.1`, do not show up as populated with `$populated()`,\n        // so in that case pull out the document's id\n        val = val._id;\n      }\n      const scope = _this.$__.pathsToScopes != null && path in _this.$__.pathsToScopes ?\n        _this.$__.pathsToScopes[path] :\n        _this;\n\n      const doValidateOptions = {\n        ...doValidateOptionsByPath[path],\n        path: path,\n        validateModifiedOnly: shouldValidateModifiedOnly,\n        validateAllPaths\n      };\n\n      schemaType.doValidate(val, function(err) {\n        if (err) {\n          const isSubdoc = schemaType.$isSingleNested ||\n              schemaType.$isArraySubdocument ||\n              schemaType.$isMongooseDocumentArray;\n          if (isSubdoc && err instanceof ValidationError) {\n            return --total || complete();\n          }\n          _this.invalidate(path, err, undefined, true);\n        }\n        --total || complete();\n      }, scope, doValidateOptions);\n    });\n  }\n\n  function complete() {\n    const error = _complete();\n    if (error) {\n      return _this.$__schema.s.hooks.execPost('validate:error', _this, [_this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n    callback(null, _this);\n  }\n\n};\n\n/*!\n * ignore\n */\n\nfunction _handlePathsToValidate(paths, pathsToValidate) {\n  const _pathsToValidate = new Set(pathsToValidate);\n  const parentPaths = new Map([]);\n  for (const path of pathsToValidate) {\n    if (path.indexOf('.') === -1) {\n      continue;\n    }\n    const pieces = path.split('.');\n    let cur = pieces[0];\n    for (let i = 1; i < pieces.length; ++i) {\n      // Since we skip subpaths under single nested subdocs to\n      // avoid double validation, we need to add back the\n      // single nested subpath if the user asked for it (gh-8626)\n      parentPaths.set(cur, path);\n      cur = cur + '.' + pieces[i];\n    }\n  }\n\n  const ret = new Set();\n  for (const path of paths) {\n    if (_pathsToValidate.has(path)) {\n      ret.add(path);\n    } else if (parentPaths.has(path)) {\n      ret.add(parentPaths.get(path));\n    }\n  }\n  return ret;\n}\n\n/*!\n * ignore\n */\n\nfunction _handlePathsToSkip(paths, pathsToSkip) {\n  pathsToSkip = new Set(pathsToSkip);\n  paths = Array.from(paths).filter(p => !pathsToSkip.has(p));\n  return new Set(paths);\n}\n\n/**\n * Executes registered validation rules (skipping asynchronous validators) for this document.\n *\n * #### Note:\n *\n * This method is useful if you need synchronous validation.\n *\n * #### Example:\n *\n *     const err = doc.validateSync();\n *     if (err) {\n *       handleError(err);\n *     } else {\n *       // validation passed\n *     }\n *\n * @param {Array|string} [pathsToValidate] only validate the given paths\n * @param {Object} [options] options for validation\n * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @param {Array|string} [options.pathsToSkip] list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.\n * @return {ValidationError|undefined} ValidationError if there are errors during validation, or undefined if there is no error.\n * @api public\n */\n\nDocument.prototype.validateSync = function(pathsToValidate, options) {\n  const _this = this;\n\n  if (arguments.length === 1 && typeof arguments[0] === 'object' && !Array.isArray(arguments[0])) {\n    options = arguments[0];\n    pathsToValidate = null;\n  }\n\n  const hasValidateModifiedOnlyOption = options &&\n      (typeof options === 'object') &&\n      ('validateModifiedOnly' in options);\n\n  let shouldValidateModifiedOnly;\n  if (hasValidateModifiedOnlyOption) {\n    shouldValidateModifiedOnly = !!options.validateModifiedOnly;\n  } else {\n    shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;\n  }\n\n  let pathsToSkip = options && options.pathsToSkip;\n\n  const validateAllPaths = options && options.validateAllPaths;\n  if (validateAllPaths) {\n    if (pathsToSkip) {\n      throw new TypeError('Cannot set both `validateAllPaths` and `pathsToSkip`');\n    }\n    if (pathsToValidate) {\n      throw new TypeError('Cannot set both `validateAllPaths` and `pathsToValidate`');\n    }\n  }\n\n  if (typeof pathsToValidate === 'string') {\n    const isOnePathOnly = pathsToValidate.indexOf(' ') === -1;\n    pathsToValidate = isOnePathOnly ? [pathsToValidate] : pathsToValidate.split(' ');\n  } else if (typeof pathsToSkip === 'string' && pathsToSkip.indexOf(' ') !== -1) {\n    pathsToSkip = pathsToSkip.split(' ');\n  }\n\n  // only validate required fields when necessary\n  let paths;\n  let skipSchemaValidators;\n  if (validateAllPaths) {\n    paths = new Set(Object.keys(this.$__schema.paths));\n    // gh-661: if a whole array is modified, make sure to run validation on all\n    // the children as well\n    for (const path of paths) {\n      const schemaType = this.$__schema.path(path);\n      if (!schemaType || !schemaType.$isMongooseArray) {\n        continue;\n      }\n      const val = this.$__getValue(path);\n      if (!val) {\n        continue;\n      }\n      _pushNestedArrayPaths(val, paths, path);\n    }\n    paths = [...paths];\n    skipSchemaValidators = {};\n  } else {\n    const pathDetails = _getPathsToValidate(this, pathsToValidate, pathsToSkip);\n    paths = shouldValidateModifiedOnly ?\n      pathDetails[0].filter((path) => this.$isModified(path)) :\n      pathDetails[0];\n    skipSchemaValidators = pathDetails[1];\n  }\n\n  const validating = {};\n\n  for (let i = 0, len = paths.length; i < len; ++i) {\n    const path = paths[i];\n\n    if (validating[path]) {\n      continue;\n    }\n\n    validating[path] = true;\n\n    const p = _this.$__schema.path(path);\n    if (!p) {\n      continue;\n    }\n    if (!_this.$isValid(path)) {\n      continue;\n    }\n\n    const val = _this.$__getValue(path);\n    const err = p.doValidateSync(val, _this, {\n      skipSchemaValidators: skipSchemaValidators[path],\n      path: path,\n      validateModifiedOnly: shouldValidateModifiedOnly,\n      validateAllPaths\n    });\n    if (err) {\n      const isSubdoc = p.$isSingleNested ||\n        p.$isArraySubdocument ||\n        p.$isMongooseDocumentArray;\n      if (isSubdoc && err instanceof ValidationError) {\n        continue;\n      }\n      _this.invalidate(path, err, undefined, true);\n    }\n  }\n\n  const err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n  _this.$emit('validate', _this);\n  _this.constructor.emit('validate', _this);\n\n  if (err) {\n    for (const key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n};\n\n/**\n * Marks a path as invalid, causing validation to fail.\n *\n * The `errorMsg` argument will become the message of the `ValidationError`.\n *\n * The `value` argument (if passed) will be available through the `ValidationError.value` property.\n *\n *     doc.invalidate('size', 'must be less than 20', 14);\n *\n *     doc.validate(function (err) {\n *       console.log(err)\n *       // prints\n *       { message: 'Validation failed',\n *         name: 'ValidationError',\n *         errors:\n *          { size:\n *             { message: 'must be less than 20',\n *               name: 'ValidatorError',\n *               path: 'size',\n *               type: 'user defined',\n *               value: 14 } } }\n *     })\n *\n * @param {String} path the field to invalidate. For array elements, use the `array.i.field` syntax, where `i` is the 0-based index in the array.\n * @param {String|Error} err the error which states the reason `path` was invalid\n * @param {Object|String|Number|any} val optional invalid value\n * @param {String} [kind] optional `kind` property for the error\n * @return {ValidationError} the current ValidationError, with all currently invalidated paths\n * @api public\n */\n\nDocument.prototype.invalidate = function(path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === 'string') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || 'user defined',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.addError(path, err);\n  return this.$__.validationError;\n};\n\n/**\n * Marks a path as valid, removing existing validation errors.\n *\n * @param {String} path the field to mark as valid\n * @api public\n * @memberOf Document\n * @instance\n * @method $markValid\n */\n\nDocument.prototype.$markValid = function(path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction _markValidSubpaths(doc, path) {\n  if (!doc.$__.validationError) {\n    return;\n  }\n\n  const keys = Object.keys(doc.$__.validationError.errors);\n  for (const key of keys) {\n    if (key.startsWith(path + '.')) {\n      delete doc.$__.validationError.errors[key];\n    }\n  }\n  if (Object.keys(doc.$__.validationError.errors).length === 0) {\n    doc.$__.validationError = null;\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _checkImmutableSubpaths(subdoc, schematype, priorVal) {\n  const schema = schematype.schema;\n  if (schema == null) {\n    return;\n  }\n\n  for (const key of Object.keys(schema.paths)) {\n    const path = schema.paths[key];\n    if (path.$immutableSetter == null) {\n      continue;\n    }\n    const oldVal = priorVal == null ? void 0 : priorVal.$__getValue(key);\n    // Calling immutableSetter with `oldVal` even though it expects `newVal`\n    // is intentional. That's because `$immutableSetter` compares its param\n    // to the current value.\n    path.$immutableSetter.call(subdoc, oldVal);\n  }\n}\n\n/**\n * Saves this document by inserting a new document into the database if [document.isNew](https://mongoosejs.com/docs/api/document.html#Document.prototype.isNew()) is `true`,\n * or sends an [updateOne](https://mongoosejs.com/docs/api/document.html#Document.prototype.updateOne()) operation **only** with the modifications to the database, it does not replace the whole document in the latter case.\n *\n * #### Example:\n *\n *     product.sold = Date.now();\n *     product = await product.save();\n *\n * If save is successful, the returned promise will fulfill with the document\n * saved.\n *\n * #### Example:\n *\n *     const newProduct = await product.save();\n *     newProduct === product; // true\n *\n * @param {Object} [options] options optional options\n * @param {Session} [options.session=null] the [session](https://www.mongodb.com/docs/manual/reference/server-sessions/) associated with this save operation. If not specified, defaults to the [document's associated session](https://mongoosejs.com/docs/api/document.html#Document.prototype.$session()).\n * @param {Object} [options.safe] (DEPRECATED) overrides [schema's safe option](https://mongoosejs.com/docs/guide.html#safe). Use the `w` option instead.\n * @param {Boolean} [options.validateBeforeSave] set to false to save without validating.\n * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @param {Number|String} [options.w] set the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#w-option). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.j] set to true for MongoDB to wait until this `save()` has been [journaled before resolving the returned promise](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Number} [options.wtimeout] sets a [timeout for the write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern).\n * @param {Boolean} [options.checkKeys=true] the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to `false` to skip that check. See [restrictions on field names](https://www.mongodb.com/docs/manual/reference/limits/#Restrictions-on-Field-Names)\n * @param {Boolean} [options.timestamps=true] if `false` and [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this `save()`.\n * @param {Function} [fn] optional callback\n * @method save\n * @memberOf Document\n * @instance\n * @throws {DocumentNotFoundError} if this [save updates an existing document](https://mongoosejs.com/docs/api/document.html#Document.prototype.isNew()) but the document doesn't exist in the database. For example, you will get this error if the document is [deleted between when you retrieved the document and when you saved it](documents.html#updating).\n * @return {Promise|undefined} Returns undefined if used with callback or a Promise otherwise.\n * @api public\n * @see middleware https://mongoosejs.com/docs/middleware.html\n */\n\n/**\n * Checks if a path is invalid\n *\n * @param {String|String[]} [path] the field to check. If unset will always return \"false\"\n * @method $isValid\n * @memberOf Document\n * @instance\n * @api private\n */\n\nDocument.prototype.$isValid = function(path) {\n  if (this.$__.validationError == null || Object.keys(this.$__.validationError.errors).length === 0) {\n    return true;\n  }\n  if (path == null) {\n    return false;\n  }\n\n  if (path.indexOf(' ') !== -1) {\n    path = path.split(' ');\n  }\n  if (Array.isArray(path)) {\n    return path.some(p => this.$__.validationError.errors[p] == null);\n  }\n\n  return this.$__.validationError.errors[path] == null;\n};\n\n/**\n * Resets the internal modified state of this document.\n *\n * @api private\n * @return {Document} this\n * @method $__reset\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__reset = function reset() {\n  let _this = this;\n\n  // Skip for subdocuments\n  const subdocs = this.$parent() === this ? this.$getAllSubdocs() : [];\n  const resetArrays = new Set();\n  for (const subdoc of subdocs) {\n    const fullPathWithIndexes = subdoc.$__fullPathWithIndexes();\n    subdoc.$__reset();\n    if (this.isModified(fullPathWithIndexes) || isParentInit(fullPathWithIndexes)) {\n      if (subdoc.$isDocumentArrayElement) {\n        resetArrays.add(subdoc.parentArray());\n      } else {\n        const parent = subdoc.$parent();\n        if (parent === this) {\n          this.$__.activePaths.clearPath(subdoc.$basePath);\n        } else if (parent != null && parent.$isSubdocument) {\n          // If map path underneath subdocument, may end up with a case where\n          // map path is modified but parent still needs to be reset. See gh-10295\n          parent.$__reset();\n        }\n      }\n    }\n  }\n\n  for (const array of resetArrays) {\n    this.$__.activePaths.clearPath(array.$path());\n    array[arrayAtomicsBackupSymbol] = array[arrayAtomicsSymbol];\n    array[arrayAtomicsSymbol] = {};\n  }\n\n  function isParentInit(path) {\n    path = path.indexOf('.') === -1 ? [path] : path.split('.');\n    let cur = '';\n    for (let i = 0; i < path.length; ++i) {\n      cur += (cur.length ? '.' : '') + path[i];\n      if (_this.$__.activePaths[cur] === 'init') {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // clear atomics\n  this.$__dirty().forEach(function(dirt) {\n    const type = dirt.value;\n\n    if (type && type[arrayAtomicsSymbol]) {\n      type[arrayAtomicsBackupSymbol] = type[arrayAtomicsSymbol];\n      type[arrayAtomicsSymbol] = {};\n    }\n  });\n\n  this.$__.backup = {};\n  this.$__.backup.activePaths = {\n    modify: Object.assign({}, this.$__.activePaths.getStatePaths('modify')),\n    default: Object.assign({}, this.$__.activePaths.getStatePaths('default'))\n  };\n  this.$__.backup.validationError = this.$__.validationError;\n  this.$__.backup.errors = this.$errors;\n\n  // Clear 'dirty' cache\n  this.$__.activePaths.clear('modify');\n  this.$__.activePaths.clear('default');\n  this.$__.validationError = undefined;\n  this.$errors = undefined;\n  _this = this;\n  this.$__schema.requiredPaths().forEach(function(path) {\n    _this.$__.activePaths.require(path);\n  });\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__undoReset = function $__undoReset() {\n  if (this.$__.backup == null || this.$__.backup.activePaths == null) {\n    return;\n  }\n\n  this.$__.activePaths.states.modify = this.$__.backup.activePaths.modify;\n  this.$__.activePaths.states.default = this.$__.backup.activePaths.default;\n\n  this.$__.validationError = this.$__.backup.validationError;\n  this.$errors = this.$__.backup.errors;\n\n  for (const dirt of this.$__dirty()) {\n    const type = dirt.value;\n\n    if (type && type[arrayAtomicsSymbol] && type[arrayAtomicsBackupSymbol]) {\n      type[arrayAtomicsSymbol] = type[arrayAtomicsBackupSymbol];\n    }\n  }\n\n  for (const subdoc of this.$getAllSubdocs()) {\n    subdoc.$__undoReset();\n  }\n};\n\n/**\n * Returns this documents dirty paths / vals.\n *\n * @return {Array}\n * @api private\n * @method $__dirty\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__dirty = function() {\n  const _this = this;\n  let all = this.$__.activePaths.map('modify', function(path) {\n    return {\n      path: path,\n      value: _this.$__getValue(path),\n      schema: _this.$__path(path)\n    };\n  });\n\n  // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n  all = all.concat(this.$__.activePaths.map('default', function(path) {\n    if (path === '_id' || _this.$__getValue(path) == null) {\n      return;\n    }\n    return {\n      path: path,\n      value: _this.$__getValue(path),\n      schema: _this.$__path(path)\n    };\n  }));\n\n  const allPaths = new Map(all.filter((el) => el != null).map((el) => [el.path, el.value]));\n  // Ignore \"foo.a\" if \"foo\" is dirty already.\n  const minimal = [];\n\n  all.forEach(function(item) {\n    if (!item) {\n      return;\n    }\n\n    let top = null;\n\n    const array = parentPaths(item.path);\n    for (let i = 0; i < array.length - 1; i++) {\n      if (allPaths.has(array[i])) {\n        top = allPaths.get(array[i]);\n        break;\n      }\n    }\n    if (top == null) {\n      minimal.push(item);\n    } else if (top != null &&\n        top[arrayAtomicsSymbol] != null &&\n        top.hasAtomics()) {\n      // special case for top level MongooseArrays\n      // the `top` array itself and a sub path of `top` are being set.\n      // the only way to honor all of both modifications is through a $set\n      // of entire array.\n      top[arrayAtomicsSymbol] = {};\n      top[arrayAtomicsSymbol].$set = top;\n    }\n  });\n  return minimal;\n};\n\n/**\n * Assigns/compiles `schema` into this documents prototype.\n *\n * @param {Schema} schema\n * @api private\n * @method $__setSchema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__setSchema = function(schema) {\n  compile(schema.tree, this, undefined, schema.options);\n\n  // Apply default getters if virtual doesn't have any (gh-6262)\n  for (const key of Object.keys(schema.virtuals)) {\n    schema.virtuals[key]._applyDefaultGetters();\n  }\n  if (schema.path('schema') == null) {\n    this.schema = schema;\n  }\n  this.$__schema = schema;\n  this[documentSchemaSymbol] = schema;\n};\n\n\n/**\n * Get active path that were changed and are arrays\n *\n * @return {Array}\n * @api private\n * @method $__getArrayPathsToValidate\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__getArrayPathsToValidate = function() {\n  DocumentArray || (DocumentArray = __webpack_require__(/*! ./types/documentArray */ \"../backend/node_modules/mongoose/lib/types/documentArray/index.js\"));\n\n  // validate all document arrays.\n  return this.$__.activePaths\n    .map('init', 'modify', function(i) {\n      return this.$__getValue(i);\n    }.bind(this))\n    .filter(function(val) {\n      return val && Array.isArray(val) && utils.isMongooseDocumentArray(val) && val.length;\n    }).reduce(function(seed, array) {\n      return seed.concat(array);\n    }, [])\n    .filter(function(doc) {\n      return doc;\n    });\n};\n\n\n/**\n * Get all subdocs (by bfs)\n *\n * @return {Array}\n * @api public\n * @method $getAllSubdocs\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$getAllSubdocs = function() {\n  DocumentArray || (DocumentArray = __webpack_require__(/*! ./types/documentArray */ \"../backend/node_modules/mongoose/lib/types/documentArray/index.js\"));\n  Embedded = Embedded || __webpack_require__(/*! ./types/arraySubdocument */ \"../backend/node_modules/mongoose/lib/types/arraySubdocument.js\");\n\n  function docReducer(doc, seed, path) {\n    let val = doc;\n    let isNested = false;\n    if (path) {\n      if (doc instanceof Document && doc[documentSchemaSymbol].paths[path]) {\n        val = doc._doc[path];\n      } else if (doc instanceof Document && doc[documentSchemaSymbol].nested[path]) {\n        val = doc._doc[path];\n        isNested = true;\n      } else {\n        val = doc[path];\n      }\n    }\n    if (val instanceof Embedded) {\n      seed.push(val);\n    } else if (val instanceof Map) {\n      seed = Array.from(val.keys()).reduce(function(seed, path) {\n        return docReducer(val.get(path), seed, null);\n      }, seed);\n    } else if (val && !Array.isArray(val) && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(function(seed, path) {\n        return docReducer(val, seed, path);\n      }, seed);\n      seed.push(val);\n    } else if (val && utils.isMongooseDocumentArray(val)) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n        seed = Object.keys(doc._doc).reduce(function(seed, path) {\n          return docReducer(doc._doc, seed, path);\n        }, seed);\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n      });\n    } else if (isNested && val != null) {\n      for (const path of Object.keys(val)) {\n        docReducer(val, seed, path);\n      }\n    }\n    return seed;\n  }\n\n  const subDocs = [];\n  for (const path of Object.keys(this._doc)) {\n    docReducer(this, subDocs, path);\n  }\n\n  return subDocs;\n};\n\n/*!\n * Runs queued functions\n */\n\nfunction applyQueue(doc) {\n  const q = doc.$__schema && doc.$__schema.callQueue;\n  if (!q.length) {\n    return;\n  }\n\n  for (const pair of q) {\n    if (pair[0] !== 'pre' && pair[0] !== 'post' && pair[0] !== 'on') {\n      doc[pair[0]].apply(doc, pair[1]);\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__handleReject = function handleReject(err) {\n  // emit on the Model if listening\n  if (this.$listeners('error').length) {\n    this.$emit('error', err);\n  } else if (this.constructor.listeners && this.constructor.listeners('error').length) {\n    this.constructor.emit('error', err);\n  }\n};\n\n/**\n * Internal helper for toObject() and toJSON() that doesn't manipulate options\n *\n * @return {Object}\n * @api private\n * @method $toObject\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$toObject = function(options, json) {\n  let defaultOptions = {\n    transform: true,\n    flattenDecimals: true\n  };\n\n  const path = json ? 'toJSON' : 'toObject';\n  const baseOptions = this.constructor &&\n    this.constructor.base &&\n    this.constructor.base.options &&\n    get(this.constructor.base.options, path) || {};\n  const schemaOptions = this.$__schema && this.$__schema.options || {};\n  // merge base default options with Schema's set default options if available.\n  // `clone` is necessary here because `utils.options` directly modifies the second input.\n  defaultOptions = { ...defaultOptions, ...baseOptions, ...schemaOptions[path] };\n\n  // If options do not exist or is not an object, set it to empty object\n  options = utils.isPOJO(options) ? { ...options } : {};\n  options._calledWithOptions = options._calledWithOptions || { ...options };\n\n  let _minimize;\n  if (options._calledWithOptions.minimize != null) {\n    _minimize = options.minimize;\n  } else if (defaultOptions.minimize != null) {\n    _minimize = defaultOptions.minimize;\n  } else {\n    _minimize = schemaOptions.minimize;\n  }\n\n  let flattenMaps;\n  if (options._calledWithOptions.flattenMaps != null) {\n    flattenMaps = options.flattenMaps;\n  } else if (defaultOptions.flattenMaps != null) {\n    flattenMaps = defaultOptions.flattenMaps;\n  } else {\n    flattenMaps = schemaOptions.flattenMaps;\n  }\n\n  let flattenObjectIds;\n  if (options._calledWithOptions.flattenObjectIds != null) {\n    flattenObjectIds = options.flattenObjectIds;\n  } else if (defaultOptions.flattenObjectIds != null) {\n    flattenObjectIds = defaultOptions.flattenObjectIds;\n  } else {\n    flattenObjectIds = schemaOptions.flattenObjectIds;\n  }\n\n  // The original options that will be passed to `clone()`. Important because\n  // `clone()` will recursively call `$toObject()` on embedded docs, so we\n  // need the original options the user passed in, plus `_isNested` and\n  // `_parentOptions` for checking whether we need to depopulate.\n  const cloneOptions = Object.assign({}, options, {\n    _isNested: true,\n    json: json,\n    minimize: _minimize,\n    flattenMaps: flattenMaps,\n    flattenObjectIds: flattenObjectIds,\n    _seen: (options && options._seen) || new Map()\n  });\n\n  if (utils.hasUserDefinedProperty(options, 'getters')) {\n    cloneOptions.getters = options.getters;\n  }\n  if (utils.hasUserDefinedProperty(options, 'virtuals')) {\n    cloneOptions.virtuals = options.virtuals;\n  }\n\n  const depopulate = options.depopulate ||\n    (options._parentOptions && options._parentOptions.depopulate || false);\n  // _isNested will only be true if this is not the top level document, we\n  // should never depopulate the top-level document\n  if (depopulate && options._isNested && this.$__.wasPopulated) {\n    return clone(this.$__.wasPopulated.value || this._id, cloneOptions);\n  }\n\n  // merge default options with input options.\n  options = { ...defaultOptions, ...options };\n  options._isNested = true;\n  options.json = json;\n  options.minimize = _minimize;\n\n  cloneOptions._parentOptions = options;\n  cloneOptions._skipSingleNestedGetters = false;\n\n  const gettersOptions = Object.assign({}, cloneOptions);\n  gettersOptions._skipSingleNestedGetters = true;\n\n  // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n  const originalTransform = options.transform;\n\n  let ret = clone(this._doc, cloneOptions) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, gettersOptions);\n\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || (options.getters && options.virtuals !== false)) {\n    applyVirtuals(this, ret, gettersOptions, options);\n  }\n\n  if (options.versionKey === false && this.$__schema.options.versionKey) {\n    delete ret[this.$__schema.options.versionKey];\n  }\n\n  let transform = options.transform;\n\n  // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema's transform and\n  // not the parent schema's\n  if (transform) {\n    applySchemaTypeTransforms(this, ret);\n  }\n\n  if (options.useProjection) {\n    omitDeselectedFields(this, ret);\n  }\n\n  if (transform === true || (schemaOptions.toObject && transform)) {\n    const opts = options.json ? schemaOptions.toJSON : schemaOptions.toObject;\n\n    if (opts) {\n      transform = (typeof options.transform === 'function' ? options.transform : opts.transform);\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === 'function') {\n    const xformed = transform(this, ret, options);\n    if (typeof xformed !== 'undefined') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Converts this document into a plain-old JavaScript object ([POJO](https://masteringjs.io/tutorials/fundamentals/pojo)).\n *\n * Buffers are converted to instances of [mongodb.Binary](https://mongodb.github.io/node-mongodb-native/4.9/classes/Binary.html) for proper storage.\n *\n * #### Getters/Virtuals\n *\n * Example of only applying path getters\n *\n *     doc.toObject({ getters: true, virtuals: false })\n *\n * Example of only applying virtual getters\n *\n *     doc.toObject({ virtuals: true })\n *\n * Example of applying both path and virtual getters\n *\n *     doc.toObject({ getters: true })\n *\n * To apply these options to every document of your schema by default, set your [schemas](https://mongoosejs.com/docs/api/schema.html#Schema()) `toObject` option to the same argument.\n *\n *     schema.set('toObject', { virtuals: true })\n *\n * #### Transform:\n *\n * We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional `transform` function.\n *\n * Transform functions receive three arguments\n *\n *     function (doc, ret, options) {}\n *\n * - `doc` The mongoose document which is being converted\n * - `ret` The plain object representation which has been converted\n * - `options` The options in use (either schema options or the options passed inline)\n *\n * #### Example:\n *\n *     // specify the transform schema option\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       // remove the _id of every document before returning the result\n *       delete ret._id;\n *       return ret;\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { name: 'Wreck-it Ralph' }\n *\n * With transformations we can do a lot more than remove properties. We can even return completely new customized objects:\n *\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       return { movie: ret.name }\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { movie: 'Wreck-it Ralph' }\n *\n * _Note: if a transform function returns `undefined`, the return value will be ignored._\n *\n * Transformations may also be applied inline, overridding any transform set in the schema options.\n * Any transform function specified in `toObject` options also propagates to any subdocuments.\n *\n *     function deleteId(doc, ret, options) {\n *       delete ret._id;\n *       return ret;\n *     }\n *\n *     const schema = mongoose.Schema({ name: String, docArr: [{ name: String }] });\n *     const TestModel = mongoose.model('Test', schema);\n *\n *     const doc = new TestModel({ name: 'test', docArr: [{ name: 'test' }] });\n *\n *     // pass the transform as an inline option. Deletes `_id` property\n *     // from both the top-level document and the subdocument.\n *     const obj = doc.toObject({ transform: deleteId });\n *     obj._id; // undefined\n *     obj.docArr[0]._id; // undefined\n *\n * If you want to skip transformations, use `transform: false`:\n *\n *     schema.options.toObject.hide = '_id';\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       if (options.hide) {\n *         options.hide.split(' ').forEach(function (prop) {\n *           delete ret[prop];\n *         });\n *       }\n *       return ret;\n *     }\n *\n *     const doc = new Doc({ _id: 'anId', secret: 47, name: 'Wreck-it Ralph' });\n *     doc.toObject();                                        // { secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: false });// { _id: 'anId', secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: true }); // { name: 'Wreck-it Ralph' }\n *\n * If you pass a transform in `toObject()` options, Mongoose will apply the transform\n * to [subdocuments](https://mongoosejs.com/docs/subdocs.html) in addition to the top-level document.\n * Similarly, `transform: false` skips transforms for all subdocuments.\n * Note that this behavior is different for transforms defined in the schema:\n * if you define a transform in `schema.options.toObject.transform`, that transform\n * will **not** apply to subdocuments.\n *\n *     const memberSchema = new Schema({ name: String, email: String });\n *     const groupSchema = new Schema({ members: [memberSchema], name: String, email });\n *     const Group = mongoose.model('Group', groupSchema);\n *\n *     const doc = new Group({\n *       name: 'Engineering',\n *       email: 'dev@mongoosejs.io',\n *       members: [{ name: 'Val', email: 'val@mongoosejs.io' }]\n *     });\n *\n *     // Removes `email` from both top-level document **and** array elements\n *     // { name: 'Engineering', members: [{ name: 'Val' }] }\n *     doc.toObject({ transform: (doc, ret) => { delete ret.email; return ret; } });\n *\n * Transforms, like all of these options, are also available for `toJSON`. See [this guide to `JSON.stringify()`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html) to learn why `toJSON()` and `toObject()` are separate functions.\n *\n * See [schema options](https://mongoosejs.com/docs/guide.html#toObject) for some more details.\n *\n * _During save, no custom options are applied to the document before being sent to the database._\n *\n * @param {Object} [options]\n * @param {Boolean} [options.getters=false] if true, apply all getters, including virtuals\n * @param {Boolean|Object} [options.virtuals=false] if true, apply virtuals, including aliases. Use `{ getters: true, virtuals: false }` to just apply getters, not virtuals. An object of the form `{ pathsToSkip: ['someVirtual'] }` may also be used to omit specific virtuals.\n * @param {Boolean} [options.aliases=true] if `options.virtuals = true`, you can set `options.aliases = false` to skip applying aliases. This option is a no-op if `options.virtuals = false`.\n * @param {Boolean} [options.minimize=true] if true, omit any empty objects from the output\n * @param {Function|null} [options.transform=null] if set, mongoose will call this function to allow you to transform the returned object\n * @param {Boolean} [options.depopulate=false] if true, replace any conventionally populated paths with the original id in the output. Has no affect on virtual populated paths.\n * @param {Boolean} [options.versionKey=true] if false, exclude the version key (`__v` by default) from the output\n * @param {Boolean} [options.flattenMaps=false] if true, convert Maps to POJOs. Useful if you want to `JSON.stringify()` the result of `toObject()`.\n * @param {Boolean} [options.flattenObjectIds=false] if true, convert any ObjectIds in the result to 24 character hex strings.\n * @param {Boolean} [options.useProjection=false] - If true, omits fields that are excluded in this document's projection. Unless you specified a projection, this will omit any field that has `select: false` in the schema.\n * @return {Object} js object (not a POJO)\n * @see mongodb.Binary https://mongodb.github.io/node-mongodb-native/4.9/classes/Binary.html\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toObject = function(options) {\n  return this.$toObject(options);\n};\n\n/*!\n * Applies virtuals properties to `json`.\n */\n\nfunction applyVirtuals(self, json, options, toObjectOptions) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.virtuals);\n  let i = paths.length;\n  const numPaths = i;\n  let path;\n  let assignPath;\n  let cur = self._doc;\n  let v;\n  const aliases = typeof (toObjectOptions && toObjectOptions.aliases) === 'boolean'\n    ? toObjectOptions.aliases\n    : true;\n\n  options = options || {};\n  let virtualsToApply = null;\n  if (Array.isArray(options.virtuals)) {\n    virtualsToApply = new Set(options.virtuals);\n  } else if (options.virtuals && options.virtuals.pathsToSkip) {\n    virtualsToApply = new Set(paths);\n    for (let i = 0; i < options.virtuals.pathsToSkip.length; i++) {\n      if (virtualsToApply.has(options.virtuals.pathsToSkip[i])) {\n        virtualsToApply.delete(options.virtuals.pathsToSkip[i]);\n      }\n    }\n  }\n\n  if (!cur) {\n    return json;\n  }\n\n  for (i = 0; i < numPaths; ++i) {\n    path = paths[i];\n\n    if (virtualsToApply != null && !virtualsToApply.has(path)) {\n      continue;\n    }\n\n    // Allow skipping aliases with `toObject({ virtuals: true, aliases: false })`\n    if (!aliases && schema.aliases.hasOwnProperty(path)) {\n      continue;\n    }\n\n    // We may be applying virtuals to a nested object, for example if calling\n    // `doc.nestedProp.toJSON()`. If so, the path we assign to, `assignPath`,\n    // will be a trailing substring of the `path`.\n    assignPath = path;\n    if (options.path != null) {\n      if (!path.startsWith(options.path + '.')) {\n        continue;\n      }\n      assignPath = path.substring(options.path.length + 1);\n    }\n    const parts = assignPath.split('.');\n    v = clone(self.get(path), options);\n    if (v === void 0) {\n      continue;\n    }\n    const plen = parts.length;\n    cur = json;\n    for (let j = 0; j < plen - 1; ++j) {\n      cur[parts[j]] = cur[parts[j]] || {};\n      cur = cur[parts[j]];\n    }\n    cur[parts[plen - 1]] = v;\n  }\n\n  return json;\n}\n\n\n/**\n * Applies virtuals properties to `json`.\n *\n * @param {Document} self\n * @param {Object} json\n * @param {Object} [options]\n * @return {Object} `json`\n * @api private\n */\n\nfunction applyGetters(self, json, options) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths);\n  let i = paths.length;\n  let path;\n  let cur = self._doc;\n  let v;\n\n  if (!cur) {\n    return json;\n  }\n\n  while (i--) {\n    path = paths[i];\n\n    const parts = path.split('.');\n\n    const plen = parts.length;\n    const last = plen - 1;\n    let branch = json;\n    let part;\n    cur = self._doc;\n\n    if (!self.$__isSelected(path)) {\n      continue;\n    }\n\n    for (let ii = 0; ii < plen; ++ii) {\n      part = parts[ii];\n      v = cur[part];\n      // If we've reached a non-object part of the branch, continuing would\n      // cause \"Cannot create property 'foo' on string 'bar'\" error.\n      // Necessary for mongoose-intl plugin re: gh-14446\n      if (branch != null && typeof branch !== 'object') {\n        break;\n      } else if (ii === last) {\n        const val = self.$get(path);\n        branch[part] = clone(val, options);\n        if (Array.isArray(branch[part]) && schema.paths[path].$embeddedSchemaType) {\n          for (let i = 0; i < branch[part].length; ++i) {\n            branch[part][i] = schema.paths[path].$embeddedSchemaType.applyGetters(\n              branch[part][i],\n              self\n            );\n          }\n        }\n      } else if (v == null) {\n        if (part in cur) {\n          branch[part] = v;\n        }\n        break;\n      } else {\n        branch = branch[part] || (branch[part] = {});\n      }\n      cur = v;\n    }\n  }\n\n  return json;\n}\n\n/**\n * Applies schema type transforms to `json`.\n *\n * @param {Document} self\n * @param {Object} json\n * @return {Object} `json`\n * @api private\n */\n\nfunction applySchemaTypeTransforms(self, json) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths || {});\n  const cur = self._doc;\n\n  if (!cur) {\n    return json;\n  }\n\n  for (const path of paths) {\n    const schematype = schema.paths[path];\n    if (typeof schematype.options.transform === 'function') {\n      const val = self.$get(path);\n      if (val === undefined) {\n        continue;\n      }\n      const transformedValue = schematype.options.transform.call(self, val);\n      throwErrorIfPromise(path, transformedValue);\n      utils.setValue(path, transformedValue, json);\n    } else if (schematype.$embeddedSchemaType != null &&\n        typeof schematype.$embeddedSchemaType.options.transform === 'function') {\n      const val = self.$get(path);\n      if (val === undefined) {\n        continue;\n      }\n      const vals = [].concat(val);\n      const transform = schematype.$embeddedSchemaType.options.transform;\n      for (let i = 0; i < vals.length; ++i) {\n        const transformedValue = transform.call(self, vals[i]);\n        vals[i] = transformedValue;\n        throwErrorIfPromise(path, transformedValue);\n      }\n\n      json[path] = vals;\n    }\n  }\n\n  return json;\n}\n\nfunction throwErrorIfPromise(path, transformedValue) {\n  if (isPromise(transformedValue)) {\n    throw new Error('`transform` function must be synchronous, but the transform on path `' + path + '` returned a promise.');\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction omitDeselectedFields(self, json) {\n  const schema = self.$__schema;\n  const paths = Object.keys(schema.paths || {});\n  const cur = self._doc;\n\n  if (!cur) {\n    return json;\n  }\n\n  let selected = self.$__.selected;\n  if (selected === void 0) {\n    selected = {};\n    queryhelpers.applyPaths(selected, schema);\n  }\n  if (selected == null || Object.keys(selected).length === 0) {\n    return json;\n  }\n\n  for (const path of paths) {\n    if (selected[path] != null && !selected[path]) {\n      delete json[path];\n    }\n  }\n\n  return json;\n}\n\n/**\n * The return value of this method is used in calls to [`JSON.stringify(doc)`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript#the-tojson-function).\n *\n * This method accepts the same options as [Document#toObject](https://mongoosejs.com/docs/api/document.html#Document.prototype.toObject()). To apply the options to every document of your schema by default, set your [schemas](https://mongoosejs.com/docs/api/schema.html#Schema()) `toJSON` option to the same argument.\n *\n *     schema.set('toJSON', { virtuals: true });\n *\n * There is one difference between `toJSON()` and `toObject()` options.\n * When you call `toJSON()`, the [`flattenMaps` option](https://mongoosejs.com/docs/api/document.html#Document.prototype.toObject()) defaults to `true`, because `JSON.stringify()` doesn't convert maps to objects by default.\n * When you call `toObject()`, the `flattenMaps` option is `false` by default.\n *\n * See [schema options](https://mongoosejs.com/docs/guide.html#toJSON) for more information on setting `toJSON` option defaults.\n *\n * @param {Object} options\n * @param {Boolean} [options.flattenMaps=true] if true, convert Maps to [POJOs](https://masteringjs.io/tutorials/fundamentals/pojo). Useful if you want to `JSON.stringify()` the result.\n * @param {Boolean} [options.flattenObjectIds=false] if true, convert any ObjectIds in the result to 24 character hex strings.\n * @return {Object}\n * @see Document#toObject https://mongoosejs.com/docs/api/document.html#Document.prototype.toObject()\n * @see JSON.stringify() in JavaScript https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toJSON = function(options) {\n  return this.$toObject(options, true);\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype.ownerDocument = function() {\n  return this;\n};\n\n\n/**\n * If this document is a subdocument or populated document, returns the document's\n * parent. Returns the original document if there is no parent.\n *\n * @return {Document}\n * @api public\n * @method parent\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.parent = function() {\n  if (this.$isSubdocument || this.$__.wasPopulated) {\n    return this.$__.parent;\n  }\n  return this;\n};\n\n/**\n * Alias for [`parent()`](https://mongoosejs.com/docs/api/document.html#Document.prototype.parent()). If this document is a subdocument or populated\n * document, returns the document's parent. Returns `undefined` otherwise.\n *\n * @return {Document}\n * @api public\n * @method $parent\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$parent = Document.prototype.parent;\n\n/**\n * Helper for console.log\n *\n * @return {String}\n * @api public\n * @method inspect\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.inspect = function(options) {\n  const isPOJO = utils.isPOJO(options);\n  let opts;\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n  }\n\n  const ret = arguments.length > 0 ? this.toObject(opts) : this.toObject();\n\n  if (ret == null) {\n    // If `toObject()` returns null, `this` is still an object, so if `inspect()`\n    // prints out null this can cause some serious confusion. See gh-7942.\n    return 'MongooseDocument { ' + ret + ' }';\n  }\n\n  return ret;\n};\n\nif (inspect.custom) {\n  // Avoid Node deprecation warning DEP0079\n  Document.prototype[inspect.custom] = Document.prototype.inspect;\n}\n\n/**\n * Helper for console.log\n *\n * @return {String}\n * @api public\n * @method toString\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toString = function() {\n  const ret = this.inspect();\n  if (typeof ret === 'string') {\n    return ret;\n  }\n  return inspect(ret);\n};\n\n/**\n * Returns true if this document is equal to another document.\n *\n * Documents are considered equal when they have matching `_id`s, unless neither\n * document has an `_id`, in which case this function falls back to using\n * `deepEqual()`.\n *\n * @param {Document} [doc] a document to compare. If falsy, will always return \"false\".\n * @return {Boolean}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.equals = function(doc) {\n  if (!doc) {\n    return false;\n  }\n\n  const tid = this.$__getValue('_id');\n  const docid = doc.$__ != null ? doc.$__getValue('_id') : doc;\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n  return tid && tid.equals\n    ? tid.equals(docid)\n    : tid === docid;\n};\n\n/**\n * Populates paths on an existing document.\n *\n * #### Example:\n *\n *     // Given a document, `populate()` lets you pull in referenced docs\n *     await doc.populate([\n *       'stories',\n *       { path: 'fans', sort: { name: -1 } }\n *     ]);\n *     doc.populated('stories'); // Array of ObjectIds\n *     doc.stories[0].title; // 'Casino Royale'\n *     doc.populated('fans'); // Array of ObjectIds\n *\n *     // If the referenced doc has been deleted, `populate()` will\n *     // remove that entry from the array.\n *     await Story.delete({ title: 'Casino Royale' });\n *     await doc.populate('stories'); // Empty array\n *\n *     // You can also pass additional query options to `populate()`,\n *     // like projections:\n *     await doc.populate('fans', '-email');\n *     doc.fans[0].email // undefined because of 2nd param `select`\n *\n * @param {String|Object|Array} path either the path to populate or an object specifying all parameters, or either an array of those\n * @param {Object|String} [select] Field selection for the population query\n * @param {Model} [model] The model you wish to use for population. If not specified, populate will look up the model by the name in the Schema's `ref` field.\n * @param {Object} [match] Conditions for the population query\n * @param {Object} [options] Options for the population query (sort, etc)\n * @param {String} [options.path=null] The path to populate.\n * @param {string|PopulateOptions} [options.populate=null] Recursively populate paths in the populated documents. See [deep populate docs](https://mongoosejs.com/docs/populate.html#deep-populate).\n * @param {boolean} [options.retainNullValues=false] by default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.\n * @param {boolean} [options.getters=false] if true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](https://mongoosejs.com/docs/schematypes.html#schematype-options).\n * @param {boolean} [options.clone=false] When you do `BlogPost.find().populate('author')`, blog posts with the same author will share 1 copy of an `author` doc. Enable this option to make Mongoose clone populated docs before assigning them.\n * @param {Object|Function} [options.match=null] Add an additional filter to the populate query. Can be a filter object containing [MongoDB query syntax](https://www.mongodb.com/docs/manual/tutorial/query-documents/), or a function that returns a filter object.\n * @param {Function} [options.transform=null] Function that Mongoose will call on every populated document that allows you to transform the populated document.\n * @param {Object} [options.options=null] Additional options like `limit` and `lean`.\n * @param {Function} [callback] Callback\n * @see population https://mongoosejs.com/docs/populate.html\n * @see Query#select https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @see Model.populate https://mongoosejs.com/docs/api/model.html#Model.populate()\n * @memberOf Document\n * @instance\n * @return {Promise|null} Returns a Promise if no `callback` is given.\n * @api public\n */\n\nDocument.prototype.populate = async function populate() {\n  const pop = {};\n  const args = [...arguments];\n  if (typeof args[args.length - 1] === 'function') {\n    throw new MongooseError('Document.prototype.populate() no longer accepts a callback');\n  }\n\n  if (args.length !== 0) {\n    // use hash to remove duplicate paths\n    const res = utils.populate.apply(null, args);\n    for (const populateOptions of res) {\n      pop[populateOptions.path] = populateOptions;\n    }\n  }\n\n  const paths = utils.object.vals(pop);\n  let topLevelModel = this.constructor;\n  if (this.$__isNested) {\n    topLevelModel = this.$__[scopeSymbol].constructor;\n    const nestedPath = this.$__.nestedPath;\n    paths.forEach(function(populateOptions) {\n      populateOptions.path = nestedPath + '.' + populateOptions.path;\n    });\n  }\n\n  // Use `$session()` by default if the document has an associated session\n  // See gh-6754\n  if (this.$session() != null) {\n    const session = this.$session();\n    paths.forEach(path => {\n      if (path.options == null) {\n        path.options = { session: session };\n        return;\n      }\n      if (!('session' in path.options)) {\n        path.options.session = session;\n      }\n    });\n  }\n\n  paths.forEach(p => {\n    p._localModel = topLevelModel;\n  });\n\n  return topLevelModel.populate(this, paths);\n};\n\n/**\n * Gets all populated documents associated with this document.\n *\n * @api public\n * @return {Document[]} array of populated documents. Empty array if there are no populated documents associated with this document.\n * @memberOf Document\n * @method $getPopulatedDocs\n * @instance\n */\n\nDocument.prototype.$getPopulatedDocs = function $getPopulatedDocs() {\n  let keys = [];\n  if (this.$__.populated != null) {\n    keys = keys.concat(Object.keys(this.$__.populated));\n  }\n  let result = [];\n  for (const key of keys) {\n    const value = this.$get(key);\n    if (Array.isArray(value)) {\n      result = result.concat(value);\n    } else if (value instanceof Document) {\n      result.push(value);\n    }\n  }\n  return result;\n};\n\n/**\n * Gets _id(s) used during population of the given `path`.\n *\n * #### Example:\n *\n *     const doc = await Model.findOne().populate('author');\n *\n *     console.log(doc.author.name); // Dr.Seuss\n *     console.log(doc.populated('author')); // '5144cf8050f071d979c118a7'\n *\n * If the path was not populated, returns `undefined`.\n *\n * @param {String} path\n * @param {Any} [val]\n * @param {Object} [options]\n * @return {Array|ObjectId|Number|Buffer|String|undefined}\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.populated = function(path, val, options) {\n  // val and options are internal\n  if (val == null || val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    if (typeof path !== 'string') {\n      return undefined;\n    }\n\n    // Map paths can be populated with either `path.$*` or just `path`\n    const _path = path.endsWith('.$*') ? path.replace(/\\.\\$\\*$/, '') : path;\n\n    const v = this.$__.populated[_path];\n    if (v) {\n      return val === true ? v : v.value;\n    }\n    return undefined;\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = { value: val, options: options };\n\n  // If this was a nested populate, make sure each populated doc knows\n  // about its populated children (gh-7685)\n  const pieces = path.split('.');\n  for (let i = 0; i < pieces.length - 1; ++i) {\n    const subpath = pieces.slice(0, i + 1).join('.');\n    const subdoc = this.$get(subpath);\n    if (subdoc != null && subdoc.$__ != null && this.$populated(subpath)) {\n      const rest = pieces.slice(i + 1).join('.');\n      subdoc.$populated(rest, val, options);\n      // No need to continue because the above recursion should take care of\n      // marking the rest of the docs as populated\n      break;\n    }\n  }\n\n  return val;\n};\n\n/**\n * Alias of [`.populated`](https://mongoosejs.com/docs/api/document.html#Document.prototype.populated()).\n *\n * @method $populated\n * @memberOf Document\n * @api public\n */\n\nDocument.prototype.$populated = Document.prototype.populated;\n\n/**\n * Throws an error if a given path is not populated\n *\n * #### Example:\n *\n *     const doc = await Model.findOne().populate('author');\n *\n *     doc.$assertPopulated('author'); // does not throw\n *     doc.$assertPopulated('other path'); // throws an error\n *\n *     // Manually populate and assert in one call. The following does\n *     // `doc.$set({ likes })` before asserting.\n *     doc.$assertPopulated('likes', { likes });\n *\n *\n * @param {String|String[]} path path or array of paths to check. `$assertPopulated` throws if any of the given paths is not populated.\n * @param {Object} [values] optional values to `$set()`. Convenient if you want to manually populate a path and assert that the path was populated in 1 call.\n * @return {Document} this\n * @memberOf Document\n * @method $assertPopulated\n * @instance\n * @api public\n */\n\nDocument.prototype.$assertPopulated = function $assertPopulated(path, values) {\n  if (Array.isArray(path)) {\n    path.forEach(p => this.$assertPopulated(p, values));\n    return this;\n  }\n\n  if (arguments.length > 1) {\n    this.$set(values);\n  }\n\n  if (!this.$populated(path)) {\n    throw new MongooseError(`Expected path \"${path}\" to be populated`);\n  }\n\n  return this;\n};\n\n/**\n * Takes a populated field and returns it to its unpopulated state.\n *\n * #### Example:\n *\n *     Model.findOne().populate('author').exec(function (err, doc) {\n *       console.log(doc.author.name); // Dr.Seuss\n *       console.log(doc.depopulate('author'));\n *       console.log(doc.author); // '5144cf8050f071d979c118a7'\n *     })\n *\n * If the path was not provided, then all populated fields are returned to their unpopulated state.\n *\n * @param {String|String[]} [path] Specific Path to depopulate. If unset, will depopulate all paths on the Document. Or multiple space-delimited paths.\n * @return {Document} this\n * @see Document.populate https://mongoosejs.com/docs/api/document.html#Document.prototype.populate()\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.depopulate = function(path) {\n  if (typeof path === 'string') {\n    path = path.indexOf(' ') === -1 ? [path] : path.split(' ');\n  }\n\n  let populatedIds;\n  const virtualKeys = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [];\n  const populated = this.$__ && this.$__.populated || {};\n\n  if (arguments.length === 0) {\n    // Depopulate all\n    for (const virtualKey of virtualKeys) {\n      delete this.$$populatedVirtuals[virtualKey];\n      delete this._doc[virtualKey];\n      delete populated[virtualKey];\n    }\n\n    const keys = Object.keys(populated);\n\n    for (const key of keys) {\n      populatedIds = this.$populated(key);\n      if (!populatedIds) {\n        continue;\n      }\n      delete populated[key];\n      utils.setValue(key, populatedIds, this._doc);\n    }\n    return this;\n  }\n\n  for (const singlePath of path) {\n    populatedIds = this.$populated(singlePath);\n    delete populated[singlePath];\n\n    if (virtualKeys.indexOf(singlePath) !== -1) {\n      delete this.$$populatedVirtuals[singlePath];\n      delete this._doc[singlePath];\n    } else if (populatedIds) {\n      utils.setValue(singlePath, populatedIds, this._doc);\n    }\n  }\n  return this;\n};\n\n\n/**\n * Returns the full path to this document.\n *\n * @param {String} [path]\n * @return {String}\n * @api private\n * @method $__fullPath\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__fullPath = function(path) {\n  // overridden in SubDocuments\n  return path || '';\n};\n\n/**\n * Returns the changes that happened to the document\n * in the format that will be sent to MongoDB.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({\n *       name: String,\n *       age: Number,\n *       country: String\n *     });\n *     const User = mongoose.model('User', userSchema);\n *     const user = await User.create({\n *       name: 'Hafez',\n *       age: 25,\n *       country: 'Egypt'\n *     });\n *\n *     // returns an empty object, no changes happened yet\n *     user.getChanges(); // { }\n *\n *     user.country = undefined;\n *     user.age = 26;\n *\n *     user.getChanges(); // { $set: { age: 26 }, { $unset: { country: 1 } } }\n *\n *     await user.save();\n *\n *     user.getChanges(); // { }\n *\n * Modifying the object that `getChanges()` returns does not affect the document's\n * change tracking state. Even if you `delete user.getChanges().$set`, Mongoose\n * will still send a `$set` to the server.\n *\n * @return {Object}\n * @api public\n * @method getChanges\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.getChanges = function() {\n  const delta = this.$__delta();\n  const changes = delta ? delta[1] : {};\n  return changes;\n};\n\n/**\n * Returns a copy of this document with a deep clone of `_doc` and `$__`.\n *\n * @return {Document} a copy of this document\n * @api public\n * @method $clone\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$clone = function() {\n  const Model = this.constructor;\n  const clonedDoc = new Model();\n  clonedDoc.$isNew = this.$isNew;\n  if (this._doc) {\n    clonedDoc._doc = clone(this._doc, { retainDocuments: true });\n  }\n  if (this.$__) {\n    const Cache = this.$__.constructor;\n    const clonedCache = new Cache();\n    for (const key of Object.getOwnPropertyNames(this.$__)) {\n      if (key === 'activePaths') {\n        continue;\n      }\n      clonedCache[key] = clone(this.$__[key]);\n    }\n    Object.assign(clonedCache.activePaths, clone({ ...this.$__.activePaths }));\n    clonedDoc.$__ = clonedCache;\n  }\n  return clonedDoc;\n};\n\n/*!\n * Module exports.\n */\n\nDocument.ValidationError = ValidationError;\nmodule.exports = exports = Document;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2RvY3VtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsMERBQThCO0FBQ25ELHNCQUFzQixtQkFBTyxDQUFDLG9FQUFZO0FBQzFDLHNCQUFzQixtQkFBTyxDQUFDLDBFQUFlO0FBQzdDLG9CQUFvQixtQkFBTyxDQUFDLDRFQUFnQjtBQUM1Qyw0QkFBNEIsbUJBQU8sQ0FBQyw0RkFBd0I7QUFDNUQsNkJBQTZCLG1CQUFPLENBQUMsOEZBQXlCO0FBQzlELDhCQUE4QixtQkFBTyxDQUFDLGdHQUEwQjtBQUNoRSxlQUFlLG1CQUFPLENBQUMsZ0VBQVU7QUFDakMsd0JBQXdCLG1CQUFPLENBQUMsNEVBQWdCO0FBQ2hELHdCQUF3QixtQkFBTyxDQUFDLG9GQUFvQjtBQUNwRCx1QkFBdUIsbUJBQU8sQ0FBQyxrRkFBbUI7QUFDbEQsK0JBQStCLG1CQUFPLENBQUMsZ0lBQTBDO0FBQ2pGLHNCQUFzQixtQkFBTyxDQUFDLGdIQUFrQztBQUNoRSw4QkFBOEIsbUJBQU8sQ0FBQyxnSUFBMEM7QUFDaEYsY0FBYyxtQkFBTyxDQUFDLDhFQUFpQjtBQUN2QyxnQkFBZ0IsbUlBQTZDO0FBQzdELGtCQUFrQixxSUFBK0M7QUFDakUsZ0JBQWdCLCtHQUFtQztBQUNuRCxZQUFZLG1CQUFPLENBQUMsMEVBQWU7QUFDbkMscUNBQXFDLG1CQUFPLENBQUMsOElBQWlEO0FBQzlGLDZCQUE2QixtQkFBTyxDQUFDLDBIQUF1QztBQUM1RSxrQ0FBa0MsbUJBQU8sQ0FBQyxvSUFBNEM7QUFDdEYsd0JBQXdCLG1CQUFPLENBQUMsb0hBQW9DO0FBQ3BFLGtCQUFrQixtQkFBTyxDQUFDLHNGQUFxQjtBQUMvQyw2QkFBNkIsbUJBQU8sQ0FBQyxrSUFBMkM7QUFDaEYsb0JBQW9CLG1CQUFPLENBQUMsZ0hBQWtDO0FBQzlELGdCQUFnQixpREFBdUI7QUFDdkMsZ0NBQWdDLGlIQUE0QztBQUM1RSxrQ0FBa0MsbUJBQU8sQ0FBQyx3SUFBOEM7QUFDeEYsaUJBQWlCLG1CQUFPLENBQUMsb0ZBQW9CO0FBQzdDLGNBQWMsbUJBQU8sQ0FBQyxxREFBTztBQUM3QixxQkFBcUIsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDN0MsY0FBYyxtQkFBTyxDQUFDLDhEQUFTO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLHNGQUFxQjs7QUFFL0M7QUFDQTs7QUFFQSxpQ0FBaUMsa0lBQXFEO0FBQ3RGLDJCQUEyQiw0SEFBK0M7QUFDMUUsNEJBQTRCLDZIQUFnRDtBQUM1RSwyQkFBMkIsNEhBQStDO0FBQzFFLDhCQUE4QiwrSEFBa0Q7QUFDaEYsNkJBQTZCLDhIQUFpRDtBQUM5RSxrQkFBa0IsbUhBQXNDO0FBQ3hELDRCQUE0Qiw2SEFBZ0Q7QUFDNUUsb0JBQW9CLHFIQUF3QztBQUM1RCwwQkFBMEIseUhBQTZDO0FBQ3ZFLG9CQUFvQixtQkFBTyxDQUFDLG9HQUE0QjtBQUN4RCxxQ0FBcUMsbUJBQU8sQ0FBQyw4SUFBaUQ7QUFDOUYsNEJBQTRCLDZIQUFnRDs7QUFFNUU7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2Q0FBNkM7QUFDakU7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG9CQUFvQjtBQUNuRCxvQkFBb0I7QUFDcEI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsb0JBQW9CO0FBQzdELG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLFFBQVE7QUFDUiwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSwwQkFBMEIsb0JBQW9CO0FBQzlDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixVQUFVO0FBQ3JDLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjLElBQUksV0FBVztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixjQUFjO0FBQzdDLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxXQUFXO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsVUFBVTtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTyxVQUFVLElBQUksTUFBTTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGdCQUFnQjtBQUMzQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QyxlQUFlO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHVFQUF1RTtBQUN2RSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjLElBQUksa0JBQWtCO0FBQ2pHLG1DQUFtQyxvQkFBb0I7QUFDdkQ7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZLDRCQUE0QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsS0FBSztBQUNoQixXQUFXLCtCQUErQjtBQUMxQyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTLDZOQUE2TixZQUFZLG9DQUFvQyx1QkFBdUI7QUFDeFQsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsY0FBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBLDhCQUE4QixhQUFhLDhCQUE4Qjs7QUFFekUsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUVBQXFFLGFBQWEseUJBQXlCO0FBQzNHO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9FQUFvRSxnQkFBZ0I7QUFDcEY7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLGlDQUFpQyxrQkFBa0I7QUFDbkQsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsZ0JBQWdCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsT0FBTztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBLDhEQUE4RCxxQ0FBcUM7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLGtCQUFrQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0EscUNBQXFDLGdCQUFnQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsbUNBQW1DO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHdDQUF3QztBQUN4RiwrQkFBK0I7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGtEQUFrRCxlQUFlOztBQUVqRTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsMEJBQTBCO0FBQ25HLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixlQUFlO0FBQzdDO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsS0FBSztBQUNoQixXQUFXLCtCQUErQjtBQUMxQyxXQUFXLFFBQVE7QUFDbkIsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLG1CQUFPLENBQUMsZ0dBQTBCOztBQUUzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsbUJBQU8sQ0FBQyxnRkFBZTtBQUM3RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLE9BQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxLQUFLO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUJBQWlCO0FBQ3BEO0FBQ0E7QUFDQSx1Q0FBdUMsWUFBWTtBQUNuRDtBQUNBLHlCQUF5QixjQUFjLFFBQVEsY0FBYztBQUM3RCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLHlCQUF5QixjQUFjLFFBQVEsY0FBYztBQUM3RDtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLFFBQVE7QUFDbkIsWUFBWSxVQUFVO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksVUFBVTtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVywrQkFBK0I7QUFDMUMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTixpQ0FBaUMsZ0JBQWdCO0FBQ2pELE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSwrQ0FBK0MsSUFBSSxZQUFZO0FBQy9EOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFlBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHVCQUF1QixlQUFlO0FBQ3pFO0FBQ0EsNEJBQTRCLDJCQUEyQixtQkFBbUI7QUFDMUU7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLDRCQUE0QjtBQUM1QjtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxVQUFVLGVBQWU7QUFDNUQ7QUFDQSwrQkFBK0I7QUFDL0IsK0JBQStCO0FBQy9CLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLDhCQUE4QjtBQUM5QjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVMsMkpBQTJKLGtCQUFrQjtBQUNqTSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsVUFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRLGdDQUFnQztBQUNsRjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0REFBNEQ7QUFDeEY7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLGNBQWM7QUFDekIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSiw0REFBNEQsNkNBQTZDO0FBQ3pHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRixjQUFjO0FBQ2xHO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLGNBQWM7QUFDaEc7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsS0FBSyxRQUFRLFNBQVMsSUFBSSxVQUFVO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHVCQUF1QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCx5QkFBeUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZG9jdW1lbnQuanM/MWNhNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5jb25zdCBJbnRlcm5hbENhY2hlID0gcmVxdWlyZSgnLi9pbnRlcm5hbCcpO1xuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3IvaW5kZXgnKTtcbmNvbnN0IE1peGVkU2NoZW1hID0gcmVxdWlyZSgnLi9zY2hlbWEvbWl4ZWQnKTtcbmNvbnN0IE9iamVjdEV4cGVjdGVkRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL29iamVjdEV4cGVjdGVkJyk7XG5jb25zdCBPYmplY3RQYXJhbWV0ZXJFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3Ivb2JqZWN0UGFyYW1ldGVyJyk7XG5jb25zdCBQYXJhbGxlbFZhbGlkYXRlRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL3BhcmFsbGVsVmFsaWRhdGUnKTtcbmNvbnN0IFNjaGVtYSA9IHJlcXVpcmUoJy4vc2NoZW1hJyk7XG5jb25zdCBTdHJpY3RNb2RlRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL3N0cmljdCcpO1xuY29uc3QgVmFsaWRhdGlvbkVycm9yID0gcmVxdWlyZSgnLi9lcnJvci92YWxpZGF0aW9uJyk7XG5jb25zdCBWYWxpZGF0b3JFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3IvdmFsaWRhdG9yJyk7XG5jb25zdCAkX19oYXNJbmNsdWRlZENoaWxkcmVuID0gcmVxdWlyZSgnLi9oZWxwZXJzL3Byb2plY3Rpb24vaGFzSW5jbHVkZWRDaGlsZHJlbicpO1xuY29uc3QgYXBwbHlEZWZhdWx0cyA9IHJlcXVpcmUoJy4vaGVscGVycy9kb2N1bWVudC9hcHBseURlZmF1bHRzJyk7XG5jb25zdCBjbGVhbk1vZGlmaWVkU3VicGF0aHMgPSByZXF1aXJlKCcuL2hlbHBlcnMvZG9jdW1lbnQvY2xlYW5Nb2RpZmllZFN1YnBhdGhzJyk7XG5jb25zdCBjbG9uZSA9IHJlcXVpcmUoJy4vaGVscGVycy9jbG9uZScpO1xuY29uc3QgY29tcGlsZSA9IHJlcXVpcmUoJy4vaGVscGVycy9kb2N1bWVudC9jb21waWxlJykuY29tcGlsZTtcbmNvbnN0IGRlZmluZUtleSA9IHJlcXVpcmUoJy4vaGVscGVycy9kb2N1bWVudC9jb21waWxlJykuZGVmaW5lS2V5O1xuY29uc3QgZmxhdHRlbiA9IHJlcXVpcmUoJy4vaGVscGVycy9jb21tb24nKS5mbGF0dGVuO1xuY29uc3QgZ2V0ID0gcmVxdWlyZSgnLi9oZWxwZXJzL2dldCcpO1xuY29uc3QgZ2V0RW1iZWRkZWREaXNjcmltaW5hdG9yUGF0aCA9IHJlcXVpcmUoJy4vaGVscGVycy9kb2N1bWVudC9nZXRFbWJlZGRlZERpc2NyaW1pbmF0b3JQYXRoJyk7XG5jb25zdCBnZXRLZXlzSW5TY2hlbWFPcmRlciA9IHJlcXVpcmUoJy4vaGVscGVycy9zY2hlbWEvZ2V0S2V5c0luU2NoZW1hT3JkZXInKTtcbmNvbnN0IGdldFN1YmRvY3VtZW50U3RyaWN0VmFsdWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvc2NoZW1hL2dldFN1YmRvY3VtZW50U3RyaWN0VmFsdWUnKTtcbmNvbnN0IGhhbmRsZVNwcmVhZERvYyA9IHJlcXVpcmUoJy4vaGVscGVycy9kb2N1bWVudC9oYW5kbGVTcHJlYWREb2MnKTtcbmNvbnN0IGltbWVkaWF0ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9pbW1lZGlhdGUnKTtcbmNvbnN0IGlzRGVmaW5pbmdQcm9qZWN0aW9uID0gcmVxdWlyZSgnLi9oZWxwZXJzL3Byb2plY3Rpb24vaXNEZWZpbmluZ1Byb2plY3Rpb24nKTtcbmNvbnN0IGlzRXhjbHVzaXZlID0gcmVxdWlyZSgnLi9oZWxwZXJzL3Byb2plY3Rpb24vaXNFeGNsdXNpdmUnKTtcbmNvbnN0IGluc3BlY3QgPSByZXF1aXJlKCd1dGlsJykuaW5zcGVjdDtcbmNvbnN0IGludGVybmFsVG9PYmplY3RPcHRpb25zID0gcmVxdWlyZSgnLi9vcHRpb25zJykuaW50ZXJuYWxUb09iamVjdE9wdGlvbnM7XG5jb25zdCBtYXJrQXJyYXlTdWJkb2NzUG9wdWxhdGVkID0gcmVxdWlyZSgnLi9oZWxwZXJzL3BvcHVsYXRlL21hcmtBcnJheVN1YmRvY3NQb3B1bGF0ZWQnKTtcbmNvbnN0IG1pbmltaXplID0gcmVxdWlyZSgnLi9oZWxwZXJzL21pbmltaXplJyk7XG5jb25zdCBtcGF0aCA9IHJlcXVpcmUoJ21wYXRoJyk7XG5jb25zdCBxdWVyeWhlbHBlcnMgPSByZXF1aXJlKCcuL3F1ZXJ5SGVscGVycycpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCBpc1Byb21pc2UgPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNQcm9taXNlJyk7XG5cbmNvbnN0IGRlZXBFcXVhbCA9IHV0aWxzLmRlZXBFcXVhbDtcbmNvbnN0IGlzTW9uZ29vc2VPYmplY3QgPSB1dGlscy5pc01vbmdvb3NlT2JqZWN0O1xuXG5jb25zdCBhcnJheUF0b21pY3NCYWNrdXBTeW1ib2wgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ltYm9scycpLmFycmF5QXRvbWljc0JhY2t1cFN5bWJvbDtcbmNvbnN0IGFycmF5QXRvbWljc1N5bWJvbCA9IHJlcXVpcmUoJy4vaGVscGVycy9zeW1ib2xzJykuYXJyYXlBdG9taWNzU3ltYm9sO1xuY29uc3QgZG9jdW1lbnRBcnJheVBhcmVudCA9IHJlcXVpcmUoJy4vaGVscGVycy9zeW1ib2xzJykuZG9jdW1lbnRBcnJheVBhcmVudDtcbmNvbnN0IGRvY3VtZW50SXNNb2RpZmllZCA9IHJlcXVpcmUoJy4vaGVscGVycy9zeW1ib2xzJykuZG9jdW1lbnRJc01vZGlmaWVkO1xuY29uc3QgZG9jdW1lbnRNb2RpZmllZFBhdGhzID0gcmVxdWlyZSgnLi9oZWxwZXJzL3N5bWJvbHMnKS5kb2N1bWVudE1vZGlmaWVkUGF0aHM7XG5jb25zdCBkb2N1bWVudFNjaGVtYVN5bWJvbCA9IHJlcXVpcmUoJy4vaGVscGVycy9zeW1ib2xzJykuZG9jdW1lbnRTY2hlbWFTeW1ib2w7XG5jb25zdCBnZXRTeW1ib2wgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ltYm9scycpLmdldFN5bWJvbDtcbmNvbnN0IHBvcHVsYXRlTW9kZWxTeW1ib2wgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ltYm9scycpLnBvcHVsYXRlTW9kZWxTeW1ib2w7XG5jb25zdCBzY29wZVN5bWJvbCA9IHJlcXVpcmUoJy4vaGVscGVycy9zeW1ib2xzJykuc2NvcGVTeW1ib2w7XG5jb25zdCBzY2hlbWFNaXhlZFN5bWJvbCA9IHJlcXVpcmUoJy4vc2NoZW1hL3N5bWJvbHMnKS5zY2hlbWFNaXhlZFN5bWJvbDtcbmNvbnN0IHBhcmVudFBhdGhzID0gcmVxdWlyZSgnLi9oZWxwZXJzL3BhdGgvcGFyZW50UGF0aHMnKTtcbmNvbnN0IGdldERlZXBlc3RTdWJkb2N1bWVudEZvclBhdGggPSByZXF1aXJlKCcuL2hlbHBlcnMvZG9jdW1lbnQvZ2V0RGVlcGVzdFN1YmRvY3VtZW50Rm9yUGF0aCcpO1xuY29uc3Qgc2Vzc2lvbk5ld0RvY3VtZW50cyA9IHJlcXVpcmUoJy4vaGVscGVycy9zeW1ib2xzJykuc2Vzc2lvbk5ld0RvY3VtZW50cztcblxubGV0IERvY3VtZW50QXJyYXk7XG5sZXQgTW9uZ29vc2VBcnJheTtcbmxldCBFbWJlZGRlZDtcblxuY29uc3Qgc3BlY2lhbFByb3BlcnRpZXMgPSB1dGlscy5zcGVjaWFsUHJvcGVydGllcztcblxuLyoqXG4gKiBUaGUgY29yZSBNb25nb29zZSBkb2N1bWVudCBjb25zdHJ1Y3Rvci4gWW91IHNob3VsZCBub3QgY2FsbCB0aGlzIGRpcmVjdGx5LFxuICogdGhlIE1vbmdvb3NlIFtNb2RlbCBjb25zdHJ1Y3Rvcl0oLi9hcGkvbW9kZWwuaHRtbCNNb2RlbCkgY2FsbHMgdGhpcyBmb3IgeW91LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdGhlIHZhbHVlcyB0byBzZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZmllbGRzXSBvcHRpb25hbCBvYmplY3QgY29udGFpbmluZyB0aGUgZmllbGRzIHdoaWNoIHdlcmUgc2VsZWN0ZWQgaW4gdGhlIHF1ZXJ5IHJldHVybmluZyB0aGlzIGRvY3VtZW50IGFuZCBhbnkgcG9wdWxhdGVkIHBhdGhzIGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gdmFyaW91cyBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBkb2N1bWVudFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5kZWZhdWx0cz10cnVlXSBpZiBgZmFsc2VgLCBza2lwIGFwcGx5aW5nIGRlZmF1bHQgdmFsdWVzIHRvIHRoaXMgZG9jdW1lbnQuXG4gKiBAaW5oZXJpdHMgTm9kZUpTIEV2ZW50RW1pdHRlciBodHRwczovL25vZGVqcy5vcmcvYXBpL2V2ZW50cy5odG1sI2NsYXNzLWV2ZW50ZW1pdHRlclxuICogQGV2ZW50IGBpbml0YDogRW1pdHRlZCBvbiBhIGRvY3VtZW50IGFmdGVyIGl0IGhhcyBiZWVuIHJldHJpZXZlZCBmcm9tIHRoZSBkYiBhbmQgZnVsbHkgaHlkcmF0ZWQgYnkgTW9uZ29vc2UuXG4gKiBAZXZlbnQgYHNhdmVgOiBFbWl0dGVkIHdoZW4gdGhlIGRvY3VtZW50IGlzIHN1Y2Nlc3NmdWxseSBzYXZlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gRG9jdW1lbnQob2JqLCBmaWVsZHMsIHNraXBJZCwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHNraXBJZCA9PT0gJ29iamVjdCcgJiYgc2tpcElkICE9IG51bGwpIHtcbiAgICBvcHRpb25zID0gc2tpcElkO1xuICAgIHNraXBJZCA9IG9wdGlvbnMuc2tpcElkO1xuICB9XG4gIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcblxuICAvLyBTdXBwb3J0IGBicm93c2VyRG9jdW1lbnQuanNgIHN5bnRheFxuICBpZiAodGhpcy4kX19zY2hlbWEgPT0gbnVsbCkge1xuICAgIGNvbnN0IF9zY2hlbWEgPSB1dGlscy5pc09iamVjdChmaWVsZHMpICYmICFmaWVsZHMuaW5zdGFuY2VPZlNjaGVtYSA/XG4gICAgICBuZXcgU2NoZW1hKGZpZWxkcykgOlxuICAgICAgZmllbGRzO1xuICAgIHRoaXMuJF9fc2V0U2NoZW1hKF9zY2hlbWEpO1xuICAgIGZpZWxkcyA9IHNraXBJZDtcbiAgICBza2lwSWQgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbNF0gfHwge307XG4gIH1cblxuICB0aGlzLiRfXyA9IG5ldyBJbnRlcm5hbENhY2hlKCk7XG5cbiAgLy8gQXZvaWQgc2V0dGluZyBgaXNOZXdgIHRvIGB0cnVlYCwgYmVjYXVzZSBpdCBpcyBgdHJ1ZWAgYnkgZGVmYXVsdFxuICBpZiAob3B0aW9ucy5pc05ldyAhPSBudWxsICYmIG9wdGlvbnMuaXNOZXcgIT09IHRydWUpIHtcbiAgICB0aGlzLiRpc05ldyA9IG9wdGlvbnMuaXNOZXc7XG4gIH1cblxuICBpZiAob3B0aW9ucy5wcmlvckRvYyAhPSBudWxsKSB7XG4gICAgdGhpcy4kX18ucHJpb3JEb2MgPSBvcHRpb25zLnByaW9yRG9jO1xuICB9XG5cbiAgaWYgKHNraXBJZCkge1xuICAgIHRoaXMuJF9fLnNraXBJZCA9IHNraXBJZDtcbiAgfVxuXG4gIGlmIChvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBPYmplY3RQYXJhbWV0ZXJFcnJvcihvYmosICdvYmonLCAnRG9jdW1lbnQnKTtcbiAgfVxuXG4gIGxldCBkZWZhdWx0cyA9IHRydWU7XG4gIGlmIChvcHRpb25zLmRlZmF1bHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLiRfXy5kZWZhdWx0cyA9IG9wdGlvbnMuZGVmYXVsdHM7XG4gICAgZGVmYXVsdHMgPSBvcHRpb25zLmRlZmF1bHRzO1xuICB9XG5cbiAgY29uc3Qgc2NoZW1hID0gdGhpcy4kX19zY2hlbWE7XG5cbiAgaWYgKHR5cGVvZiBmaWVsZHMgPT09ICdib29sZWFuJyB8fCBmaWVsZHMgPT09ICd0aHJvdycpIHtcbiAgICBpZiAoZmllbGRzICE9PSB0cnVlKSB7XG4gICAgICB0aGlzLiRfXy5zdHJpY3RNb2RlID0gZmllbGRzO1xuICAgIH1cbiAgICBmaWVsZHMgPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAoc2NoZW1hLm9wdGlvbnMuc3RyaWN0ICE9PSB0cnVlKSB7XG4gICAgdGhpcy4kX18uc3RyaWN0TW9kZSA9IHNjaGVtYS5vcHRpb25zLnN0cmljdDtcbiAgfVxuXG4gIGNvbnN0IHJlcXVpcmVkUGF0aHMgPSBzY2hlbWEucmVxdWlyZWRQYXRocyh0cnVlKTtcbiAgZm9yIChjb25zdCBwYXRoIG9mIHJlcXVpcmVkUGF0aHMpIHtcbiAgICB0aGlzLiRfXy5hY3RpdmVQYXRocy5yZXF1aXJlKHBhdGgpO1xuICB9XG5cbiAgbGV0IGV4Y2x1ZGUgPSBudWxsO1xuXG4gIC8vIGRldGVybWluZSBpZiB0aGlzIGRvYyBpcyBhIHJlc3VsdCBvZiBhIHF1ZXJ5IHdpdGhcbiAgLy8gZXhjbHVkZWQgZmllbGRzXG4gIGlmICh1dGlscy5pc1BPSk8oZmllbGRzKSAmJiBPYmplY3Qua2V5cyhmaWVsZHMpLmxlbmd0aCA+IDApIHtcbiAgICBleGNsdWRlID0gaXNFeGNsdXNpdmUoZmllbGRzKTtcbiAgICB0aGlzLiRfXy5zZWxlY3RlZCA9IGZpZWxkcztcbiAgICB0aGlzLiRfXy5leGNsdWRlID0gZXhjbHVkZTtcbiAgfVxuXG4gIGNvbnN0IGhhc0luY2x1ZGVkQ2hpbGRyZW4gPSBleGNsdWRlID09PSBmYWxzZSAmJiBmaWVsZHMgP1xuICAgICRfX2hhc0luY2x1ZGVkQ2hpbGRyZW4oZmllbGRzKSA6XG4gICAgbnVsbDtcblxuICBpZiAodGhpcy5fZG9jID09IG51bGwpIHtcbiAgICB0aGlzLiRfX2J1aWxkRG9jKG9iaiwgZmllbGRzLCBza2lwSWQsIGV4Y2x1ZGUsIGhhc0luY2x1ZGVkQ2hpbGRyZW4sIGZhbHNlKTtcblxuICAgIC8vIEJ5IGRlZmF1bHQsIGRlZmF1bHRzIGdldCBhcHBsaWVkICoqYmVmb3JlKiogc2V0dGluZyBpbml0aWFsIHZhbHVlc1xuICAgIC8vIFJlOiBnaC02MTU1XG4gICAgaWYgKGRlZmF1bHRzKSB7XG4gICAgICBhcHBseURlZmF1bHRzKHRoaXMsIGZpZWxkcywgZXhjbHVkZSwgaGFzSW5jbHVkZWRDaGlsZHJlbiwgdHJ1ZSwgbnVsbCk7XG4gICAgfVxuICB9XG4gIGlmIChvYmopIHtcbiAgICAvLyBTa2lwIHNldCBob29rc1xuICAgIGlmICh0aGlzLiRfX29yaWdpbmFsX3NldCkge1xuICAgICAgdGhpcy4kX19vcmlnaW5hbF9zZXQob2JqLCB1bmRlZmluZWQsIHRydWUsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiRzZXQob2JqLCB1bmRlZmluZWQsIHRydWUsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChvYmogaW5zdGFuY2VvZiBEb2N1bWVudCkge1xuICAgICAgdGhpcy4kaXNOZXcgPSBvYmouJGlzTmV3O1xuICAgIH1cbiAgfVxuXG4gIC8vIEZ1bmN0aW9uIGRlZmF1bHRzIGdldCBhcHBsaWVkICoqYWZ0ZXIqKiBzZXR0aW5nIGluaXRpYWwgdmFsdWVzIHNvIHRoZXlcbiAgLy8gc2VlIHRoZSBmdWxsIGRvYyByYXRoZXIgdGhhbiBhbiBlbXB0eSBvbmUsIHVubGVzcyB0aGV5IG9wdCBvdXQuXG4gIC8vIFJlOiBnaC0zNzgxLCBnaC02MTU1XG4gIGlmIChvcHRpb25zLndpbGxJbml0ICYmIGRlZmF1bHRzKSB7XG4gICAgaWYgKG9wdGlvbnMuc2tpcERlZmF1bHRzKSB7XG4gICAgICB0aGlzLiRfXy5za2lwRGVmYXVsdHMgPSBvcHRpb25zLnNraXBEZWZhdWx0cztcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGVmYXVsdHMpIHtcbiAgICBhcHBseURlZmF1bHRzKHRoaXMsIGZpZWxkcywgZXhjbHVkZSwgaGFzSW5jbHVkZWRDaGlsZHJlbiwgZmFsc2UsIG9wdGlvbnMuc2tpcERlZmF1bHRzKTtcbiAgfVxuXG4gIGlmICghdGhpcy4kX18uc3RyaWN0TW9kZSAmJiBvYmopIHtcbiAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuX2RvYyk7XG5cbiAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAvLyBBdm9pZCBtZXRob2RzLCB2aXJ0dWFscywgZXhpc3RpbmcgZmllbGRzLCBhbmQgYCRgIGtleXMuIFRoZSBsYXR0ZXIgaXMgdG8gYXZvaWQgb3ZlcndyaXRpbmdcbiAgICAgIC8vIE1vbmdvb3NlIGludGVybmFscy5cbiAgICAgIGlmICghKGtleSBpbiBzY2hlbWEudHJlZSkgJiYgIShrZXkgaW4gc2NoZW1hLm1ldGhvZHMpICYmICEoa2V5IGluIHNjaGVtYS52aXJ0dWFscykgJiYgIWtleS5zdGFydHNXaXRoKCckJykpIHtcbiAgICAgICAgZGVmaW5lS2V5KHsgcHJvcDoga2V5LCBzdWJwcm9wczogbnVsbCwgcHJvdG90eXBlOiBfdGhpcyB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGFwcGx5UXVldWUodGhpcyk7XG59XG5cbkRvY3VtZW50LnByb3RvdHlwZS4kaXNNb25nb29zZURvY3VtZW50UHJvdG90eXBlID0gdHJ1ZTtcblxuLyoqXG4gKiBCb29sZWFuIGZsYWcgc3BlY2lmeWluZyBpZiB0aGUgZG9jdW1lbnQgaXMgbmV3LiBJZiB5b3UgY3JlYXRlIGEgZG9jdW1lbnRcbiAqIHVzaW5nIGBuZXdgLCB0aGlzIGRvY3VtZW50IHdpbGwgYmUgY29uc2lkZXJlZCBcIm5ld1wiLiBgJGlzTmV3YCBpcyBob3dcbiAqIE1vbmdvb3NlIGRldGVybWluZXMgd2hldGhlciBgc2F2ZSgpYCBzaG91bGQgdXNlIGBpbnNlcnRPbmUoKWAgdG8gY3JlYXRlXG4gKiBhIG5ldyBkb2N1bWVudCBvciBgdXBkYXRlT25lKClgIHRvIHVwZGF0ZSBhbiBleGlzdGluZyBkb2N1bWVudC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHVzZXIgPSBuZXcgVXNlcih7IG5hbWU6ICdKb2huIFNtaXRoJyB9KTtcbiAqICAgICB1c2VyLiRpc05ldzsgLy8gdHJ1ZVxuICpcbiAqICAgICBhd2FpdCB1c2VyLnNhdmUoKTsgLy8gU2VuZHMgYW4gYGluc2VydE9uZWAgdG8gTW9uZ29EQlxuICpcbiAqIE9uIHRoZSBvdGhlciBoYW5kLCBpZiB5b3UgbG9hZCBhbiBleGlzdGluZyBkb2N1bWVudCBmcm9tIHRoZSBkYXRhYmFzZVxuICogdXNpbmcgYGZpbmRPbmUoKWAgb3IgYW5vdGhlciBbcXVlcnkgb3BlcmF0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvcXVlcmllcy5odG1sKSxcbiAqIGAkaXNOZXdgIHdpbGwgYmUgZmFsc2UuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCB1c2VyID0gYXdhaXQgVXNlci5maW5kT25lKHsgbmFtZTogJ0pvaG4gU21pdGgnIH0pO1xuICogICAgIHVzZXIuJGlzTmV3OyAvLyBmYWxzZVxuICpcbiAqIE1vbmdvb3NlIHNldHMgYCRpc05ld2AgdG8gYGZhbHNlYCBpbW1lZGlhdGVseSBhZnRlciBgc2F2ZSgpYCBzdWNjZWVkcy5cbiAqIFRoYXQgbWVhbnMgTW9uZ29vc2Ugc2V0cyBgJGlzTmV3YCB0byBmYWxzZSAqKmJlZm9yZSoqIGBwb3N0KCdzYXZlJylgIGhvb2tzIHJ1bi5cbiAqIEluIGBwb3N0KCdzYXZlJylgIGhvb2tzLCBgJGlzTmV3YCB3aWxsIGJlIGBmYWxzZWAgaWYgYHNhdmUoKWAgc3VjY2VlZGVkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgdXNlclNjaGVtYS5wb3N0KCdzYXZlJywgZnVuY3Rpb24oKSB7XG4gKiAgICAgICB0aGlzLiRpc05ldzsgLy8gZmFsc2VcbiAqICAgICB9KTtcbiAqICAgICBhd2FpdCBVc2VyLmNyZWF0ZSh7IG5hbWU6ICdKb2huIFNtaXRoJyB9KTtcbiAqXG4gKiBGb3Igc3ViZG9jdW1lbnRzLCBgJGlzTmV3YCBpcyB0cnVlIGlmIGVpdGhlciB0aGUgcGFyZW50IGhhcyBgJGlzTmV3YCBzZXQsXG4gKiBvciBpZiB5b3UgY3JlYXRlIGEgbmV3IHN1YmRvY3VtZW50LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gQXNzdW1lIGBHcm91cGAgaGFzIGEgZG9jdW1lbnQgYXJyYXkgYHVzZXJzYFxuICogICAgIGNvbnN0IGdyb3VwID0gYXdhaXQgR3JvdXAuZmluZE9uZSgpO1xuICogICAgIGdyb3VwLnVzZXJzWzBdLiRpc05ldzsgLy8gZmFsc2VcbiAqXG4gKiAgICAgZ3JvdXAudXNlcnMucHVzaCh7IG5hbWU6ICdKb2huIFNtaXRoJyB9KTtcbiAqICAgICBncm91cC51c2Vyc1sxXS4kaXNOZXc7IC8vIHRydWVcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5ICRpc05ld1xuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRG9jdW1lbnQucHJvdG90eXBlLCAnaXNOZXcnLCB7XG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuJGlzTmV3O1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy4kaXNOZXcgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbi8qKlxuICogSGFzaCBjb250YWluaW5nIGN1cnJlbnQgdmFsaWRhdGlvbiBlcnJvcnMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBlcnJvcnNcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KERvY3VtZW50LnByb3RvdHlwZSwgJ2Vycm9ycycsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4kZXJyb3JzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy4kZXJyb3JzID0gdmFsdWU7XG4gIH1cbn0pO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kaXNOZXcgPSB0cnVlO1xuXG4vKiFcbiAqIERvY3VtZW50IGV4cG9zZXMgdGhlIE5vZGVKUyBldmVudCBlbWl0dGVyIEFQSSwgc28geW91IGNhbiB1c2VcbiAqIGBvbmAsIGBvbmNlYCwgZXRjLlxuICovXG51dGlscy5lYWNoKFxuICBbJ29uJywgJ29uY2UnLCAnZW1pdCcsICdsaXN0ZW5lcnMnLCAncmVtb3ZlTGlzdGVuZXInLCAnc2V0TWF4TGlzdGVuZXJzJyxcbiAgICAncmVtb3ZlQWxsTGlzdGVuZXJzJywgJ2FkZExpc3RlbmVyJ10sXG4gIGZ1bmN0aW9uKGVtaXR0ZXJGbikge1xuICAgIERvY3VtZW50LnByb3RvdHlwZVtlbWl0dGVyRm5dID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBEZWxheSBjcmVhdGluZyBlbWl0dGVyIHVudGlsIG5lY2Vzc2FyeSBiZWNhdXNlIGVtaXR0ZXJzIHRha2UgdXAgYSBsb3Qgb2YgbWVtb3J5LFxuICAgICAgLy8gZXNwZWNpYWxseSBmb3Igc3ViZG9jdW1lbnRzLlxuICAgICAgaWYgKCF0aGlzLiRfXy5lbWl0dGVyKSB7XG4gICAgICAgIGlmIChlbWl0dGVyRm4gPT09ICdlbWl0Jykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRfXy5lbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLiRfXy5lbWl0dGVyLnNldE1heExpc3RlbmVycygwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLiRfXy5lbWl0dGVyW2VtaXR0ZXJGbl0uYXBwbHkodGhpcy4kX18uZW1pdHRlciwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIERvY3VtZW50LnByb3RvdHlwZVtgJCR7ZW1pdHRlckZufWBdID0gRG9jdW1lbnQucHJvdG90eXBlW2VtaXR0ZXJGbl07XG4gIH0pO1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEb2N1bWVudDtcblxuZm9yIChjb25zdCBpIGluIEV2ZW50RW1pdHRlci5wcm90b3R5cGUpIHtcbiAgRG9jdW1lbnRbaV0gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlW2ldO1xufVxuXG4vKipcbiAqIFRoZSBkb2N1bWVudCdzIGludGVybmFsIHNjaGVtYS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqIEBwcm9wZXJ0eSBzY2hlbWFcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRfX3NjaGVtYTtcblxuLyoqXG4gKiBUaGUgZG9jdW1lbnQncyBzY2hlbWEuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBzY2hlbWFcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLnNjaGVtYTtcblxuLyoqXG4gKiBFbXB0eSBvYmplY3QgdGhhdCB5b3UgY2FuIHVzZSBmb3Igc3RvcmluZyBwcm9wZXJ0aWVzIG9uIHRoZSBkb2N1bWVudC4gVGhpc1xuICogaXMgaGFuZHkgZm9yIHBhc3NpbmcgZGF0YSB0byBtaWRkbGV3YXJlIHdpdGhvdXQgY29uZmxpY3Rpbmcgd2l0aCBNb25nb29zZVxuICogaW50ZXJuYWxzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgc2NoZW1hLnByZSgnc2F2ZScsIGZ1bmN0aW9uKCkge1xuICogICAgICAgLy8gTW9uZ29vc2Ugd2lsbCBzZXQgYGlzTmV3YCB0byBgZmFsc2VgIGlmIGBzYXZlKClgIHN1Y2NlZWRzXG4gKiAgICAgICB0aGlzLiRsb2NhbHMud2FzTmV3ID0gdGhpcy5pc05ldztcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgc2NoZW1hLnBvc3QoJ3NhdmUnLCBmdW5jdGlvbigpIHtcbiAqICAgICAgIC8vIFByaW50cyB0cnVlIGlmIGBpc05ld2Agd2FzIHNldCBiZWZvcmUgYHNhdmUoKWBcbiAqICAgICAgIGNvbnNvbGUubG9nKHRoaXMuJGxvY2Fscy53YXNOZXcpO1xuICogICAgIH0pO1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgJGxvY2Fsc1xuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRG9jdW1lbnQucHJvdG90eXBlLCAnJGxvY2FscycsIHtcbiAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuJF9fLmxvY2FscyA9PSBudWxsKSB7XG4gICAgICB0aGlzLiRfXy5sb2NhbHMgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuJF9fLmxvY2FscztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgdGhpcy4kX18ubG9jYWxzID0gdjtcbiAgfVxufSk7XG5cbi8qKlxuICogTGVnYWN5IGFsaWFzIGZvciBgJGlzTmV3YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IGlzTmV3XG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBzZWUgJGlzTmV3IGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudC5wcm90b3R5cGUuJGlzTmV3XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuaXNOZXc7XG5cbi8qKlxuICogU2V0IHRoaXMgcHJvcGVydHkgdG8gYWRkIGFkZGl0aW9uYWwgcXVlcnkgZmlsdGVycyB3aGVuIE1vbmdvb3NlIHNhdmVzIHRoaXMgZG9jdW1lbnQgYW5kIGBpc05ld2AgaXMgZmFsc2UuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYWtlIHN1cmUgYHNhdmUoKWAgbmV2ZXIgdXBkYXRlcyBhIHNvZnQgZGVsZXRlZCBkb2N1bWVudC5cbiAqICAgICBzY2hlbWEucHJlKCdzYXZlJywgZnVuY3Rpb24oKSB7XG4gKiAgICAgICB0aGlzLiR3aGVyZSA9IHsgaXNEZWxldGVkOiBmYWxzZSB9O1xuICogICAgIH0pO1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgJHdoZXJlXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEb2N1bWVudC5wcm90b3R5cGUsICckd2hlcmUnLCB7XG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICB3cml0YWJsZTogdHJ1ZVxufSk7XG5cbi8qKlxuICogVGhlIHN0cmluZyB2ZXJzaW9uIG9mIHRoaXMgZG9jdW1lbnRzIF9pZC5cbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogVGhpcyBnZXR0ZXIgZXhpc3RzIG9uIGFsbCBkb2N1bWVudHMgYnkgZGVmYXVsdC4gVGhlIGdldHRlciBjYW4gYmUgZGlzYWJsZWQgYnkgc2V0dGluZyB0aGUgYGlkYCBbb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNpZCkgb2YgaXRzIGBTY2hlbWFgIHRvIGZhbHNlIGF0IGNvbnN0cnVjdGlvbiB0aW1lLlxuICpcbiAqICAgICBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0sIHsgaWQ6IGZhbHNlIH0pO1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAc2VlIFNjaGVtYSBvcHRpb25zIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI29wdGlvbnNcbiAqIEBwcm9wZXJ0eSBpZFxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuaWQ7XG5cbi8qKlxuICogSGFzaCBjb250YWluaW5nIGN1cnJlbnQgdmFsaWRhdGlvbiAkZXJyb3JzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgJGVycm9yc1xuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJGVycm9ycztcblxuLyoqXG4gKiBBIHN0cmluZyBjb250YWluaW5nIHRoZSBjdXJyZW50IG9wZXJhdGlvbiB0aGF0IE1vbmdvb3NlIGlzIGV4ZWN1dGluZ1xuICogb24gdGhpcyBkb2N1bWVudC4gTWF5IGJlIGBudWxsYCwgYCdzYXZlJ2AsIGAndmFsaWRhdGUnYCwgb3IgYCdyZW1vdmUnYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGRvYyA9IG5ldyBNb2RlbCh7IG5hbWU6ICd0ZXN0JyB9KTtcbiAqICAgICBkb2MuJG9wOyAvLyBudWxsXG4gKlxuICogICAgIGNvbnN0IHByb21pc2UgPSBkb2Muc2F2ZSgpO1xuICogICAgIGRvYy4kb3A7IC8vICdzYXZlJ1xuICpcbiAqICAgICBhd2FpdCBwcm9taXNlO1xuICogICAgIGRvYy4kb3A7IC8vIG51bGxcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5ICRvcFxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRG9jdW1lbnQucHJvdG90eXBlLCAnJG9wJywge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiRfXy5vcCB8fCBudWxsO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdGhpcy4kX18ub3AgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gJGFwcGx5RGVmYXVsdHNUb05lc3RlZCh2YWwsIHBhdGgsIGRvYykge1xuICBpZiAodmFsID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBwYXRocyA9IE9iamVjdC5rZXlzKGRvYy4kX19zY2hlbWEucGF0aHMpO1xuICBjb25zdCBwbGVuID0gcGF0aHMubGVuZ3RoO1xuXG4gIGNvbnN0IHBhdGhQaWVjZXMgPSBwYXRoLmluZGV4T2YoJy4nKSA9PT0gLTEgPyBbcGF0aF0gOiBwYXRoLnNwbGl0KCcuJyk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbGVuOyArK2kpIHtcbiAgICBsZXQgY3VyUGF0aCA9ICcnO1xuICAgIGNvbnN0IHAgPSBwYXRoc1tpXTtcblxuICAgIGlmICghcC5zdGFydHNXaXRoKHBhdGggKyAnLicpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCB0eXBlID0gZG9jLiRfX3NjaGVtYS5wYXRoc1twXTtcbiAgICBjb25zdCBwaWVjZXMgPSB0eXBlLnNwbGl0UGF0aCgpLnNsaWNlKHBhdGhQaWVjZXMubGVuZ3RoKTtcbiAgICBjb25zdCBsZW4gPSBwaWVjZXMubGVuZ3RoO1xuXG4gICAgaWYgKHR5cGUuZGVmYXVsdFZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGxldCBjdXIgPSB2YWw7XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxlbjsgKytqKSB7XG4gICAgICBpZiAoY3VyID09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBpZWNlID0gcGllY2VzW2pdO1xuXG4gICAgICBpZiAoaiA9PT0gbGVuIC0gMSkge1xuICAgICAgICBpZiAoY3VyW3BpZWNlXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGRlZiA9IHR5cGUuZ2V0RGVmYXVsdChkb2MsIGZhbHNlKTtcbiAgICAgICAgICBpZiAoZGVmICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGN1cltwaWVjZV0gPSBkZWY7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBkb2MuaW52YWxpZGF0ZShwYXRoICsgJy4nICsgY3VyUGF0aCwgZXJyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjdXJQYXRoICs9ICghY3VyUGF0aC5sZW5ndGggPyAnJyA6ICcuJykgKyBwaWVjZTtcblxuICAgICAgY3VyW3BpZWNlXSA9IGN1cltwaWVjZV0gfHwge307XG4gICAgICBjdXIgPSBjdXJbcGllY2VdO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEJ1aWxkcyB0aGUgZGVmYXVsdCBkb2Mgc3RydWN0dXJlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtPYmplY3R9IFtmaWVsZHNdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtza2lwSWRdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtleGNsdWRlXVxuICogQHBhcmFtIHtPYmplY3R9IFtoYXNJbmNsdWRlZENoaWxkcmVuXVxuICogQGFwaSBwcml2YXRlXG4gKiBAbWV0aG9kICRfX2J1aWxkRG9jXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kX19idWlsZERvYyA9IGZ1bmN0aW9uKG9iaiwgZmllbGRzLCBza2lwSWQsIGV4Y2x1ZGUsIGhhc0luY2x1ZGVkQ2hpbGRyZW4pIHtcbiAgY29uc3QgZG9jID0ge307XG5cbiAgY29uc3QgcGF0aHMgPSBPYmplY3Qua2V5cyh0aGlzLiRfX3NjaGVtYS5wYXRocykuXG4gICAgLy8gRG9uJ3QgYnVpbGQgdXAgYW55IHBhdGhzIHRoYXQgYXJlIHVuZGVybmVhdGggYSBtYXAsIHdlIGRvbid0IGtub3dcbiAgICAvLyB3aGF0IHRoZSBrZXlzIHdpbGwgYmVcbiAgICBmaWx0ZXIocCA9PiAhcC5pbmNsdWRlcygnJConKSk7XG4gIGNvbnN0IHBsZW4gPSBwYXRocy5sZW5ndGg7XG4gIGxldCBpaSA9IDA7XG5cbiAgZm9yICg7IGlpIDwgcGxlbjsgKytpaSkge1xuICAgIGNvbnN0IHAgPSBwYXRoc1tpaV07XG5cbiAgICBpZiAocCA9PT0gJ19pZCcpIHtcbiAgICAgIGlmIChza2lwSWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAob2JqICYmICdfaWQnIGluIG9iaikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwYXRoID0gdGhpcy4kX19zY2hlbWEucGF0aHNbcF0uc3BsaXRQYXRoKCk7XG4gICAgY29uc3QgbGVuID0gcGF0aC5sZW5ndGg7XG4gICAgY29uc3QgbGFzdCA9IGxlbiAtIDE7XG4gICAgbGV0IGN1clBhdGggPSAnJztcbiAgICBsZXQgZG9jXyA9IGRvYztcbiAgICBsZXQgaW5jbHVkZWQgPSBmYWxzZTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IHBpZWNlID0gcGF0aFtpXTtcblxuICAgICAgaWYgKCFjdXJQYXRoLmxlbmd0aCkge1xuICAgICAgICBjdXJQYXRoID0gcGllY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJQYXRoICs9ICcuJyArIHBpZWNlO1xuICAgICAgfVxuXG4gICAgICAvLyBzdXBwb3J0IGV4Y2x1ZGluZyBpbnRlcm1lZGlhcnkgbGV2ZWxzXG4gICAgICBpZiAoZXhjbHVkZSA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAoY3VyUGF0aCBpbiBmaWVsZHMpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChleGNsdWRlID09PSBmYWxzZSAmJiBmaWVsZHMgJiYgIWluY2x1ZGVkKSB7XG4gICAgICAgIGlmIChjdXJQYXRoIGluIGZpZWxkcykge1xuICAgICAgICAgIGluY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICghaGFzSW5jbHVkZWRDaGlsZHJlbltjdXJQYXRoXSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpIDwgbGFzdCkge1xuICAgICAgICBkb2NfID0gZG9jX1twaWVjZV0gfHwgKGRvY19bcGllY2VdID0ge30pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2RvYyA9IGRvYztcbn07XG5cbi8qIVxuICogQ29udmVydHMgdG8gUE9KTyB3aGVuIHlvdSB1c2UgdGhlIGRvY3VtZW50IGZvciBxdWVyeWluZ1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS50b0JTT04gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9PYmplY3QoaW50ZXJuYWxUb09iamVjdE9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgZG9jdW1lbnQgd2l0aG91dCBzZXR0ZXJzIG9yIG1hcmtpbmcgYW55dGhpbmcgbW9kaWZpZWQuXG4gKlxuICogQ2FsbGVkIGludGVybmFsbHkgYWZ0ZXIgYSBkb2N1bWVudCBpcyByZXR1cm5lZCBmcm9tIG1vbmdvZGIuIE5vcm1hbGx5LFxuICogeW91IGRvICoqbm90KiogbmVlZCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gb24geW91ciBvd24uXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0cmlnZ2VycyBgaW5pdGAgW21pZGRsZXdhcmVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9taWRkbGV3YXJlLmh0bWwpLlxuICogTm90ZSB0aGF0IGBpbml0YCBob29rcyBhcmUgW3N5bmNocm9ub3VzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvbWlkZGxld2FyZS5odG1sI3N5bmNocm9ub3VzKS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZG9jIGRvY3VtZW50IHJldHVybmVkIGJ5IG1vbmdvXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGRvYywgb3B0cywgZm4pIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm4gPSBvcHRzO1xuICAgIG9wdHMgPSBudWxsO1xuICB9XG5cbiAgdGhpcy4kX19pbml0KGRvYywgb3B0cyk7XG5cbiAgaWYgKGZuKSB7XG4gICAgZm4obnVsbCwgdGhpcyk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIFtgLmluaXRgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLmluaXQoKSlcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kaW5pdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBcImluaXRcIiBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvY1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICogQHJldHVybnMge0RvY3VtZW50fSB0aGlzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJF9faW5pdCA9IGZ1bmN0aW9uKGRvYywgb3B0cykge1xuICB0aGlzLiRpc05ldyA9IGZhbHNlO1xuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAvLyBoYW5kbGUgZG9jcyB3aXRoIHBvcHVsYXRlZCBwYXRoc1xuICAvLyBJZiBkb2MuX2lkIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICBpZiAoZG9jLl9pZCAhPSBudWxsICYmIG9wdHMucG9wdWxhdGVkICYmIG9wdHMucG9wdWxhdGVkLmxlbmd0aCkge1xuICAgIGNvbnN0IGlkID0gU3RyaW5nKGRvYy5faWQpO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBvcHRzLnBvcHVsYXRlZCkge1xuICAgICAgaWYgKGl0ZW0uaXNWaXJ0dWFsKSB7XG4gICAgICAgIHRoaXMuJHBvcHVsYXRlZChpdGVtLnBhdGgsIHV0aWxzLmdldFZhbHVlKGl0ZW0ucGF0aCwgZG9jKSwgaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiRwb3B1bGF0ZWQoaXRlbS5wYXRoLCBpdGVtLl9kb2NzW2lkXSwgaXRlbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtLl9jaGlsZERvY3MgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgaXRlbS5fY2hpbGREb2NzKSB7XG4gICAgICAgIGlmIChjaGlsZCA9PSBudWxsIHx8IGNoaWxkLiRfXyA9PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGQuJF9fLnBhcmVudCA9IHRoaXM7XG4gICAgICB9XG4gICAgICBpdGVtLl9jaGlsZERvY3MgPSBbXTtcbiAgICB9XG4gIH1cblxuICBpbml0KHRoaXMsIGRvYywgdGhpcy5fZG9jLCBvcHRzKTtcblxuICBtYXJrQXJyYXlTdWJkb2NzUG9wdWxhdGVkKHRoaXMsIG9wdHMucG9wdWxhdGVkKTtcbiAgdGhpcy4kZW1pdCgnaW5pdCcsIHRoaXMpO1xuICB0aGlzLmNvbnN0cnVjdG9yLmVtaXQoJ2luaXQnLCB0aGlzKTtcblxuICBjb25zdCBoYXNJbmNsdWRlZENoaWxkcmVuID0gdGhpcy4kX18uZXhjbHVkZSA9PT0gZmFsc2UgJiYgdGhpcy4kX18uc2VsZWN0ZWQgP1xuICAgICRfX2hhc0luY2x1ZGVkQ2hpbGRyZW4odGhpcy4kX18uc2VsZWN0ZWQpIDpcbiAgICBudWxsO1xuXG4gIGFwcGx5RGVmYXVsdHModGhpcywgdGhpcy4kX18uc2VsZWN0ZWQsIHRoaXMuJF9fLmV4Y2x1ZGUsIGhhc0luY2x1ZGVkQ2hpbGRyZW4sIGZhbHNlLCB0aGlzLiRfXy5za2lwRGVmYXVsdHMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSW5pdCBoZWxwZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHNlbGYgZG9jdW1lbnQgaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogcmF3IG1vbmdvZGIgZG9jXG4gKiBAcGFyYW0ge09iamVjdH0gZG9jIG9iamVjdCB3ZSBhcmUgaW5pdGlhbGl6aW5nXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIE9wdGlvbmFsIE9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdHMuc2V0dGVyc10gQ2FsbCBgYXBwbHlTZXR0ZXJzYCBpbnN0ZWFkIG9mIGBjYXN0YFxuICogQHBhcmFtIHtTdHJpbmd9IFtwcmVmaXhdIFByZWZpeCB0byBhZGQgdG8gZWFjaCBwYXRoXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpbml0KHNlbGYsIG9iaiwgZG9jLCBvcHRzLCBwcmVmaXgpIHtcbiAgcHJlZml4ID0gcHJlZml4IHx8ICcnO1xuXG4gIGlmIChvYmouJF9fICE9IG51bGwpIHtcbiAgICBvYmogPSBvYmouX2RvYztcbiAgfVxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgY29uc3QgbGVuID0ga2V5cy5sZW5ndGg7XG4gIGxldCBzY2hlbWFUeXBlO1xuICBsZXQgcGF0aDtcbiAgbGV0IGk7XG4gIGxldCBpbmRleCA9IDA7XG4gIGNvbnN0IHN0cmljdCA9IHNlbGYuJF9fLnN0cmljdE1vZGU7XG4gIGNvbnN0IGRvY1NjaGVtYSA9IHNlbGYuJF9fc2NoZW1hO1xuXG4gIHdoaWxlIChpbmRleCA8IGxlbikge1xuICAgIF9pbml0KGluZGV4KyspO1xuICB9XG5cbiAgZnVuY3Rpb24gX2luaXQoaW5kZXgpIHtcbiAgICBpID0ga2V5c1tpbmRleF07XG4gICAgLy8gYXZvaWQgcHJvdG90eXBlIHBvbGx1dGlvblxuICAgIGlmIChpID09PSAnX19wcm90b19fJyB8fCBpID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHBhdGggPSBwcmVmaXggPyBwcmVmaXggKyBpIDogaTtcbiAgICBzY2hlbWFUeXBlID0gZG9jU2NoZW1hLnBhdGgocGF0aCk7XG4gICAgLy8gU2hvdWxkIHN0aWxsIHdvcmsgaWYgbm90IGEgbW9kZWwtbGV2ZWwgZGlzY3JpbWluYXRvciwgYnV0IHNob3VsZCBub3QgYmVcbiAgICAvLyBuZWNlc3NhcnkuIFRoaXMgaXMgKm9ubHkqIHRvIGNhdGNoIHRoZSBjYXNlIHdoZXJlIHdlIHF1ZXJpZWQgdXNpbmcgdGhlXG4gICAgLy8gYmFzZSBtb2RlbCBhbmQgdGhlIGRpc2NyaW1pbmF0ZWQgbW9kZWwgaGFzIGEgcHJvamVjdGlvblxuICAgIGlmIChkb2NTY2hlbWEuJGlzUm9vdERpc2NyaW1pbmF0b3IgJiYgIXNlbGYuJF9faXNTZWxlY3RlZChwYXRoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbHVlID0gb2JqW2ldO1xuICAgIGlmICghc2NoZW1hVHlwZSAmJiB1dGlscy5pc1BPSk8odmFsdWUpKSB7XG4gICAgICAvLyBhc3N1bWUgbmVzdGVkIG9iamVjdFxuICAgICAgaWYgKCFkb2NbaV0pIHtcbiAgICAgICAgZG9jW2ldID0ge307XG4gICAgICAgIGlmICghc3RyaWN0ICYmICEoaSBpbiBkb2NTY2hlbWEudHJlZSkgJiYgIShpIGluIGRvY1NjaGVtYS5tZXRob2RzKSAmJiAhKGkgaW4gZG9jU2NoZW1hLnZpcnR1YWxzKSkge1xuICAgICAgICAgIHNlbGZbaV0gPSBkb2NbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluaXQoc2VsZiwgdmFsdWUsIGRvY1tpXSwgb3B0cywgcGF0aCArICcuJyk7XG4gICAgfSBlbHNlIGlmICghc2NoZW1hVHlwZSkge1xuICAgICAgZG9jW2ldID0gdmFsdWU7XG4gICAgICBpZiAoIXN0cmljdCAmJiAhcHJlZml4KSB7XG4gICAgICAgIHNlbGZbaV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmV0YWluIG9yZGVyIHdoZW4gb3ZlcndyaXRpbmcgZGVmYXVsdHNcbiAgICAgIGlmIChkb2MuaGFzT3duUHJvcGVydHkoaSkgJiYgdmFsdWUgIT09IHZvaWQgMCAmJiAhb3B0cy5oeWRyYXRlZFBvcHVsYXRlZERvY3MpIHtcbiAgICAgICAgZGVsZXRlIGRvY1tpXTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBkb2NbaV0gPSBzY2hlbWFUeXBlLl9jYXN0TnVsbGlzaChudWxsKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB3YXNQb3B1bGF0ZWQgPSB2YWx1ZS4kX18gPT0gbnVsbCA/IG51bGwgOiB2YWx1ZS4kX18ud2FzUG9wdWxhdGVkO1xuXG4gICAgICAgIGlmIChzY2hlbWFUeXBlICYmICF3YXNQb3B1bGF0ZWQgJiYgIW9wdHMuaHlkcmF0ZWRQb3B1bGF0ZWREb2NzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChvcHRzICYmIG9wdHMuc2V0dGVycykge1xuICAgICAgICAgICAgICAvLyBDYWxsIGFwcGx5U2V0dGVycyB3aXRoIGBpbml0ID0gZmFsc2VgIGJlY2F1c2Ugb3RoZXJ3aXNlIHNldHRlcnMgYXJlIGEgbm9vcFxuICAgICAgICAgICAgICBjb25zdCBvdmVycmlkZUluaXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgZG9jW2ldID0gc2NoZW1hVHlwZS5hcHBseVNldHRlcnModmFsdWUsIHNlbGYsIG92ZXJyaWRlSW5pdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkb2NbaV0gPSBzY2hlbWFUeXBlLmNhc3QodmFsdWUsIHNlbGYsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHNlbGYuaW52YWxpZGF0ZShlLnBhdGgsIG5ldyBWYWxpZGF0b3JFcnJvcih7XG4gICAgICAgICAgICAgIHBhdGg6IGUucGF0aCxcbiAgICAgICAgICAgICAgbWVzc2FnZTogZS5tZXNzYWdlLFxuICAgICAgICAgICAgICB0eXBlOiAnY2FzdCcsXG4gICAgICAgICAgICAgIHZhbHVlOiBlLnZhbHVlLFxuICAgICAgICAgICAgICByZWFzb246IGVcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9jW2ldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIG1hcmsgYXMgaHlkcmF0ZWRcbiAgICAgIGlmICghc2VsZi4kaXNNb2RpZmllZChwYXRoKSkge1xuICAgICAgICBzZWxmLiRfXy5hY3RpdmVQYXRocy5pbml0KHBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNlbmRzIGFuIHVwZGF0ZU9uZSBjb21tYW5kIHdpdGggdGhpcyBkb2N1bWVudCBgX2lkYCBhcyB0aGUgcXVlcnkgc2VsZWN0b3IuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICB3ZWlyZENhci51cGRhdGVPbmUoeyRpbmM6IHt3aGVlbHM6MX19LCB7IHc6IDEgfSwgY2FsbGJhY2spO1xuICpcbiAqICMjIyMgVmFsaWQgb3B0aW9uczpcbiAqXG4gKiAgLSBzYW1lIGFzIGluIFtNb2RlbC51cGRhdGVPbmVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbC51cGRhdGVPbmUpXG4gKlxuICogQHNlZSBNb2RlbC51cGRhdGVPbmUgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsLnVwZGF0ZU9uZVxuICogQHBhcmFtIHtPYmplY3R9IGRvY1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25hbCBzZWUgW2BRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKCkpXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubGVhbl0gaWYgdHJ1dGh5LCBtb25nb29zZSB3aWxsIHJldHVybiB0aGUgZG9jdW1lbnQgYXMgYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdCByYXRoZXIgdGhhbiBhIG1vbmdvb3NlIGRvY3VtZW50LiBTZWUgW2BRdWVyeS5sZWFuKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLmxlYW4oKSkgYW5kIHRoZSBbTW9uZ29vc2UgbGVhbiB0dXRvcmlhbF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3R1dG9yaWFscy9sZWFuLmh0bWwpLlxuICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gW29wdGlvbnMuc3RyaWN0XSBvdmVyd3JpdGVzIHRoZSBzY2hlbWEncyBbc3RyaWN0IG1vZGUgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdHJpY3QpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRpbWVzdGFtcHM9bnVsbF0gSWYgc2V0IHRvIGBmYWxzZWAgYW5kIFtzY2hlbWEtbGV2ZWwgdGltZXN0YW1wc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdGltZXN0YW1wcykgYXJlIGVuYWJsZWQsIHNraXAgdGltZXN0YW1wcyBmb3IgdGhpcyB1cGRhdGUuIE5vdGUgdGhhdCB0aGlzIGFsbG93cyB5b3UgdG8gb3ZlcndyaXRlIHRpbWVzdGFtcHMuIERvZXMgbm90aGluZyBpZiBzY2hlbWEtbGV2ZWwgdGltZXN0YW1wcyBhcmUgbm90IHNldC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja11cbiAqIEByZXR1cm4ge1F1ZXJ5fVxuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLnVwZGF0ZU9uZSA9IGZ1bmN0aW9uIHVwZGF0ZU9uZShkb2MsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHF1ZXJ5ID0gdGhpcy5jb25zdHJ1Y3Rvci51cGRhdGVPbmUoeyBfaWQ6IHRoaXMuX2lkIH0sIGRvYywgb3B0aW9ucyk7XG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuICBxdWVyeS5wcmUoZnVuY3Rpb24gcXVlcnlQcmVVcGRhdGVPbmUoY2IpIHtcbiAgICBzZWxmLmNvbnN0cnVjdG9yLl9taWRkbGV3YXJlLmV4ZWNQcmUoJ3VwZGF0ZU9uZScsIHNlbGYsIFtzZWxmXSwgY2IpO1xuICB9KTtcbiAgcXVlcnkucG9zdChmdW5jdGlvbiBxdWVyeVBvc3RVcGRhdGVPbmUoY2IpIHtcbiAgICBzZWxmLmNvbnN0cnVjdG9yLl9taWRkbGV3YXJlLmV4ZWNQb3N0KCd1cGRhdGVPbmUnLCBzZWxmLCBbc2VsZl0sIHt9LCBjYik7XG4gIH0pO1xuXG4gIGlmICh0aGlzLiRzZXNzaW9uKCkgIT0gbnVsbCkge1xuICAgIGlmICghKCdzZXNzaW9uJyBpbiBxdWVyeS5vcHRpb25zKSkge1xuICAgICAgcXVlcnkub3B0aW9ucy5zZXNzaW9uID0gdGhpcy4kc2Vzc2lvbigpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjYWxsYmFjayAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHF1ZXJ5LmV4ZWMoY2FsbGJhY2spO1xuICB9XG5cbiAgcmV0dXJuIHF1ZXJ5O1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIHJlcGxhY2VPbmUgY29tbWFuZCB3aXRoIHRoaXMgZG9jdW1lbnQgYF9pZGAgYXMgdGhlIHF1ZXJ5IHNlbGVjdG9yLlxuICpcbiAqICMjIyMgVmFsaWQgb3B0aW9uczpcbiAqXG4gKiAgLSBzYW1lIGFzIGluIFtNb2RlbC5yZXBsYWNlT25lXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vZGVsLmh0bWwjTW9kZWwucmVwbGFjZU9uZSgpKVxuICpcbiAqIEBzZWUgTW9kZWwucmVwbGFjZU9uZSBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vZGVsLmh0bWwjTW9kZWwucmVwbGFjZU9uZSgpXG4gKiBAcGFyYW0ge09iamVjdH0gZG9jXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdXG4gKiBAcmV0dXJuIHtRdWVyeX1cbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS5yZXBsYWNlT25lID0gZnVuY3Rpb24gcmVwbGFjZU9uZSgpIHtcbiAgY29uc3QgYXJncyA9IFsuLi5hcmd1bWVudHNdO1xuICBhcmdzLnVuc2hpZnQoeyBfaWQ6IHRoaXMuX2lkIH0pO1xuICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5yZXBsYWNlT25lLmFwcGx5KHRoaXMuY29uc3RydWN0b3IsIGFyZ3MpO1xufTtcblxuLyoqXG4gKiBHZXR0ZXIvc2V0dGVyIGFyb3VuZCB0aGUgc2Vzc2lvbiBhc3NvY2lhdGVkIHdpdGggdGhpcyBkb2N1bWVudC4gVXNlZCB0b1xuICogYXV0b21hdGljYWxseSBzZXQgYHNlc3Npb25gIGlmIHlvdSBgc2F2ZSgpYCBhIGRvYyB0aGF0IHlvdSBnb3QgZnJvbSBhXG4gKiBxdWVyeSB3aXRoIGFuIGFzc29jaWF0ZWQgc2Vzc2lvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNlc3Npb24gPSBNeU1vZGVsLnN0YXJ0U2Vzc2lvbigpO1xuICogICAgIGNvbnN0IGRvYyA9IGF3YWl0IE15TW9kZWwuZmluZE9uZSgpLnNlc3Npb24oc2Vzc2lvbik7XG4gKiAgICAgZG9jLiRzZXNzaW9uKCkgPT09IHNlc3Npb247IC8vIHRydWVcbiAqICAgICBkb2MuJHNlc3Npb24obnVsbCk7XG4gKiAgICAgZG9jLiRzZXNzaW9uKCkgPT09IG51bGw7IC8vIHRydWVcbiAqXG4gKiBJZiB0aGlzIGlzIGEgdG9wLWxldmVsIGRvY3VtZW50LCBzZXR0aW5nIHRoZSBzZXNzaW9uIHByb3BhZ2F0ZXMgdG8gYWxsIGNoaWxkXG4gKiBkb2NzLlxuICpcbiAqIEBwYXJhbSB7Q2xpZW50U2Vzc2lvbn0gW3Nlc3Npb25dIG92ZXJ3cml0ZSB0aGUgY3VycmVudCBzZXNzaW9uXG4gKiBAcmV0dXJuIHtDbGllbnRTZXNzaW9ufVxuICogQG1ldGhvZCAkc2Vzc2lvblxuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kc2Vzc2lvbiA9IGZ1bmN0aW9uICRzZXNzaW9uKHNlc3Npb24pIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAodGhpcy4kX18uc2Vzc2lvbiAhPSBudWxsICYmIHRoaXMuJF9fLnNlc3Npb24uaGFzRW5kZWQpIHtcbiAgICAgIHRoaXMuJF9fLnNlc3Npb24gPSBudWxsO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiRfXy5zZXNzaW9uO1xuICB9XG5cbiAgaWYgKHNlc3Npb24gIT0gbnVsbCAmJiBzZXNzaW9uLmhhc0VuZGVkKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0Nhbm5vdCBzZXQgYSBkb2N1bWVudFxcJ3Mgc2Vzc2lvbiB0byBhIHNlc3Npb24gdGhhdCBoYXMgZW5kZWQuIE1ha2Ugc3VyZSB5b3UgaGF2ZW5cXCd0ICcgK1xuICAgICAgJ2NhbGxlZCBgZW5kU2Vzc2lvbigpYCBvbiB0aGUgc2Vzc2lvbiB5b3UgYXJlIHBhc3NpbmcgdG8gYCRzZXNzaW9uKClgLicpO1xuICB9XG5cbiAgaWYgKHNlc3Npb24gPT0gbnVsbCAmJiB0aGlzLiRfXy5zZXNzaW9uID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLiRfXy5zZXNzaW9uID0gc2Vzc2lvbjtcblxuICBpZiAoIXRoaXMuJGlzU3ViZG9jdW1lbnQpIHtcbiAgICBjb25zdCBzdWJkb2NzID0gdGhpcy4kZ2V0QWxsU3ViZG9jcygpO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygc3ViZG9jcykge1xuICAgICAgY2hpbGQuJHNlc3Npb24oc2Vzc2lvbik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNlc3Npb247XG59O1xuXG4vKipcbiAqIEdldHRlci9zZXR0ZXIgYXJvdW5kIHdoZXRoZXIgdGhpcyBkb2N1bWVudCB3aWxsIGFwcGx5IHRpbWVzdGFtcHMgYnlcbiAqIGRlZmF1bHQgd2hlbiB1c2luZyBgc2F2ZSgpYCBhbmQgYGJ1bGtTYXZlKClgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgVGVzdE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0sIHsgdGltZXN0YW1wczogdHJ1ZSB9KSk7XG4gKiAgICAgY29uc3QgZG9jID0gbmV3IFRlc3RNb2RlbCh7IG5hbWU6ICdKb2huIFNtaXRoJyB9KTtcbiAqXG4gKiAgICAgZG9jLiR0aW1lc3RhbXBzKCk7IC8vIHRydWVcbiAqXG4gKiAgICAgZG9jLiR0aW1lc3RhbXBzKGZhbHNlKTtcbiAqICAgICBhd2FpdCBkb2Muc2F2ZSgpOyAvLyBEb2VzICoqbm90KiogYXBwbHkgdGltZXN0YW1wc1xuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3ZhbHVlXSBvdmVyd3JpdGUgdGhlIGN1cnJlbnQgc2Vzc2lvblxuICogQHJldHVybiB7RG9jdW1lbnR8Ym9vbGVhbnx1bmRlZmluZWR9IFdoZW4gdXNlZCBhcyBhIGdldHRlciAobm8gYXJndW1lbnQpLCBhIGJvb2xlYW4gd2lsbCBiZSByZXR1cm5lZCBpbmRpY2F0aW5nIHRoZSB0aW1lc3RhbXBzIG9wdGlvbiBzdGF0ZSBvciBpZiB1bnNldCBcInVuZGVmaW5lZFwiIHdpbGwgYmUgdXNlZCwgb3RoZXJ3aXNlIHdpbGwgcmV0dXJuIFwidGhpc1wiXG4gKiBAbWV0aG9kICR0aW1lc3RhbXBzXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIERvY3VtZW50XG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiR0aW1lc3RhbXBzID0gZnVuY3Rpb24gJHRpbWVzdGFtcHModmFsdWUpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAodGhpcy4kX18udGltZXN0YW1wcyAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy4kX18udGltZXN0YW1wcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy4kX19zY2hlbWEpIHtcbiAgICAgIHJldHVybiB0aGlzLiRfX3NjaGVtYS5vcHRpb25zLnRpbWVzdGFtcHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRoaXMuJHRpbWVzdGFtcHMoKTtcbiAgaWYgKHZhbHVlICE9PSBjdXJyZW50VmFsdWUpIHtcbiAgICB0aGlzLiRfXy50aW1lc3RhbXBzID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcndyaXRlIGFsbCB2YWx1ZXMgaW4gdGhpcyBkb2N1bWVudCB3aXRoIHRoZSB2YWx1ZXMgb2YgYG9iamAsIGV4Y2VwdFxuICogZm9yIGltbXV0YWJsZSBwcm9wZXJ0aWVzLiBCZWhhdmVzIHNpbWlsYXJseSB0byBgc2V0KClgLCBleGNlcHQgZm9yIGl0XG4gKiB1bnNldHMgYWxsIHByb3BlcnRpZXMgdGhhdCBhcmVuJ3QgaW4gYG9iamAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiB0aGUgb2JqZWN0IHRvIG92ZXJ3cml0ZSB0aGlzIGRvY3VtZW50IHdpdGhcbiAqIEBtZXRob2Qgb3ZlcndyaXRlXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqIEByZXR1cm4ge0RvY3VtZW50fSB0aGlzXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLm92ZXJ3cml0ZSA9IGZ1bmN0aW9uIG92ZXJ3cml0ZShvYmopIHtcbiAgY29uc3Qga2V5cyA9IEFycmF5LmZyb20obmV3IFNldChPYmplY3Qua2V5cyh0aGlzLl9kb2MpLmNvbmNhdChPYmplY3Qua2V5cyhvYmopKSkpO1xuXG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBpZiAoa2V5ID09PSAnX2lkJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIEV4cGxpY2l0bHkgc2tpcCB2ZXJzaW9uIGtleVxuICAgIGlmICh0aGlzLiRfX3NjaGVtYS5vcHRpb25zLnZlcnNpb25LZXkgJiYga2V5ID09PSB0aGlzLiRfX3NjaGVtYS5vcHRpb25zLnZlcnNpb25LZXkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy4kX19zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5ICYmIGtleSA9PT0gdGhpcy4kX19zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdGhpcy4kc2V0KGtleSwgb2JqW2tleV0pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciBgc2V0KClgLCB1c2VkIGludGVybmFsbHkgdG8gYXZvaWQgY29uZmxpY3RzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBwYXRoIHBhdGggb3Igb2JqZWN0IG9mIGtleS92YWxzIHRvIHNldFxuICogQHBhcmFtIHtBbnl9IHZhbCB0aGUgdmFsdWUgdG8gc2V0XG4gKiBAcGFyYW0ge1NjaGVtYXxTdHJpbmd8TnVtYmVyfEJ1ZmZlcnwqfSBbdHlwZV0gb3B0aW9uYWxseSBzcGVjaWZ5IGEgdHlwZSBmb3IgXCJvbi10aGUtZmx5XCIgYXR0cmlidXRlc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25hbGx5IHNwZWNpZnkgb3B0aW9ucyB0aGF0IG1vZGlmeSB0aGUgYmVoYXZpb3Igb2YgdGhlIHNldFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tZXJnZT1mYWxzZV0gaWYgdHJ1ZSwgc2V0dGluZyBhIFtuZXN0ZWQgcGF0aF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3N1YmRvY3MuaHRtbCNzdWJkb2N1bWVudHMtdmVyc3VzLW5lc3RlZC1wYXRocykgd2lsbCBtZXJnZSBleGlzdGluZyB2YWx1ZXMgcmF0aGVyIHRoYW4gb3ZlcndyaXRlIHRoZSB3aG9sZSBvYmplY3QuIFNvIGBkb2Muc2V0KCduZXN0ZWQnLCB7IGE6IDEsIGI6IDIgfSlgIGJlY29tZXMgYGRvYy5zZXQoJ25lc3RlZC5hJywgMSk7IGRvYy5zZXQoJ25lc3RlZC5iJywgMik7YFxuICogQHJldHVybiB7RG9jdW1lbnR9IHRoaXNcbiAqIEBtZXRob2QgJHNldFxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRzZXQgPSBmdW5jdGlvbiAkc2V0KHBhdGgsIHZhbCwgdHlwZSwgb3B0aW9ucykge1xuICBpZiAodXRpbHMuaXNQT0pPKHR5cGUpKSB7XG4gICAgb3B0aW9ucyA9IHR5cGU7XG4gICAgdHlwZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IG1lcmdlID0gb3B0aW9ucyAmJiBvcHRpb25zLm1lcmdlO1xuICBjb25zdCBhZGhvYyA9IHR5cGUgJiYgdHlwZSAhPT0gdHJ1ZTtcbiAgY29uc3QgY29uc3RydWN0aW5nID0gdHlwZSA9PT0gdHJ1ZTtcbiAgbGV0IGFkaG9jcztcbiAgbGV0IGtleXM7XG4gIGxldCBpID0gMDtcbiAgbGV0IHBhdGh0eXBlO1xuICBsZXQga2V5O1xuICBsZXQgcHJlZml4O1xuXG4gIGNvbnN0IHVzZXJTcGVjaWZpZWRTdHJpY3QgPSBvcHRpb25zICYmICdzdHJpY3QnIGluIG9wdGlvbnM7XG4gIGxldCBzdHJpY3QgPSB1c2VyU3BlY2lmaWVkU3RyaWN0XG4gICAgPyBvcHRpb25zLnN0cmljdFxuICAgIDogdGhpcy4kX18uc3RyaWN0TW9kZTtcblxuICBpZiAoYWRob2MpIHtcbiAgICBhZGhvY3MgPSB0aGlzLiRfXy5hZGhvY1BhdGhzIHx8ICh0aGlzLiRfXy5hZGhvY1BhdGhzID0ge30pO1xuICAgIGFkaG9jc1twYXRoXSA9IHRoaXMuJF9fc2NoZW1hLmludGVycHJldEFzVHlwZShwYXRoLCB0eXBlLCB0aGlzLiRfX3NjaGVtYS5vcHRpb25zKTtcbiAgfVxuXG4gIGlmIChwYXRoID09IG51bGwpIHtcbiAgICBbcGF0aCwgdmFsXSA9IFt2YWwsIHBhdGhdO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgIC8vIG5ldyBEb2N1bWVudCh7IGtleTogdmFsIH0pXG4gICAgaWYgKHBhdGggaW5zdGFuY2VvZiBEb2N1bWVudCkge1xuICAgICAgaWYgKHBhdGguJF9faXNOZXN0ZWQpIHtcbiAgICAgICAgcGF0aCA9IHBhdGgudG9PYmplY3QoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgdGVybmFyeSBpcyB0byBzdXBwb3J0IGdoLTc4OTggKGNvcHlpbmcgdmlydHVhbHMgaWYgc2FtZSBzY2hlbWEpXG4gICAgICAgIC8vIHdoaWxlIG5vdCBicmVha2luZyBnaC0xMDgxOSwgd2hpY2ggZm9yIHNvbWUgcmVhc29uIGJyZWFrcyBpZiB3ZSB1c2UgdG9PYmplY3QoKVxuICAgICAgICBwYXRoID0gcGF0aC4kX19zY2hlbWEgPT09IHRoaXMuJF9fc2NoZW1hXG4gICAgICAgICAgPyBhcHBseVZpcnR1YWxzKHBhdGgsIHsgLi4ucGF0aC5fZG9jIH0pXG4gICAgICAgICAgOiBwYXRoLl9kb2M7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXRoID09IG51bGwpIHtcbiAgICAgIFtwYXRoLCB2YWxdID0gW3ZhbCwgcGF0aF07XG4gICAgfVxuXG4gICAgcHJlZml4ID0gdmFsID8gdmFsICsgJy4nIDogJyc7XG4gICAga2V5cyA9IGdldEtleXNJblNjaGVtYU9yZGVyKHRoaXMuJF9fc2NoZW1hLCBwYXRoKTtcblxuICAgIGNvbnN0IGxlbiA9IGtleXMubGVuZ3RoO1xuXG4gICAgLy8gYF9za2lwTWluaW1pemVUb3BMZXZlbGAgaXMgYmVjYXVzZSB3ZSBtYXkgaGF2ZSBkZWxldGVkIHRoZSB0b3AtbGV2ZWxcbiAgICAvLyBuZXN0ZWQga2V5IHRvIGVuc3VyZSBrZXkgb3JkZXIuXG4gICAgY29uc3QgX3NraXBNaW5pbWl6ZVRvcExldmVsID0gb3B0aW9ucyAmJiBvcHRpb25zLl9za2lwTWluaW1pemVUb3BMZXZlbCB8fCBmYWxzZTtcbiAgICBpZiAobGVuID09PSAwICYmIF9za2lwTWluaW1pemVUb3BMZXZlbCkge1xuICAgICAgZGVsZXRlIG9wdGlvbnMuX3NraXBNaW5pbWl6ZVRvcExldmVsO1xuICAgICAgaWYgKHZhbCkge1xuICAgICAgICB0aGlzLiRzZXQodmFsLCB7fSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyBfc2tpcE1pbmltaXplVG9wTGV2ZWw6IGZhbHNlIH0pO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIGNvbnN0IHBhdGhOYW1lID0gcHJlZml4ID8gcHJlZml4ICsga2V5IDoga2V5O1xuICAgICAgcGF0aHR5cGUgPSB0aGlzLiRfX3NjaGVtYS5wYXRoVHlwZShwYXRoTmFtZSk7XG4gICAgICBjb25zdCB2YWxGb3JLZXkgPSBwYXRoW2tleV07XG5cbiAgICAgIC8vIE9uIGluaXRpYWwgc2V0LCBkZWxldGUgYW55IG5lc3RlZCBrZXlzIGlmIHdlJ3JlIGdvaW5nIHRvIG92ZXJ3cml0ZVxuICAgICAgLy8gdGhlbSB0byBlbnN1cmUgd2Uga2VlcCB0aGUgdXNlcidzIGtleSBvcmRlci5cbiAgICAgIGlmICh0eXBlID09PSB0cnVlICYmXG4gICAgICAgICAgIXByZWZpeCAmJlxuICAgICAgICAgIHZhbEZvcktleSAhPSBudWxsICYmXG4gICAgICAgICAgcGF0aHR5cGUgPT09ICduZXN0ZWQnICYmXG4gICAgICAgICAgdGhpcy5fZG9jW2tleV0gIT0gbnVsbCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fZG9jW2tleV07XG4gICAgICB9XG5cbiAgICAgIGlmICh1dGlscy5pc05vbkJ1aWx0aW5PYmplY3QodmFsRm9yS2V5KSAmJiBwYXRodHlwZSA9PT0gJ25lc3RlZCcpIHtcbiAgICAgICAgdGhpcy4kc2V0KHBhdGhOYW1lLCB2YWxGb3JLZXksIGNvbnN0cnVjdGluZywgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyBfc2tpcE1hcmtNb2RpZmllZDogdHJ1ZSB9KSk7XG4gICAgICAgICRhcHBseURlZmF1bHRzVG9OZXN0ZWQodGhpcy4kZ2V0KHBhdGhOYW1lKSwgcGF0aE5hbWUsIHRoaXMpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoc3RyaWN0KSB7XG4gICAgICAgIC8vIERvbid0IG92ZXJ3cml0ZSBkZWZhdWx0cyB3aXRoIHVuZGVmaW5lZCBrZXlzIChnaC0zOTgxKSAoZ2gtOTAzOSlcbiAgICAgICAgaWYgKGNvbnN0cnVjdGluZyAmJiB2YWxGb3JLZXkgPT09IHZvaWQgMCAmJlxuICAgICAgICAgICAgdGhpcy4kZ2V0KHBhdGhOYW1lKSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGF0aHR5cGUgPT09ICdhZGhvY09yVW5kZWZpbmVkJykge1xuICAgICAgICAgIHBhdGh0eXBlID0gZ2V0RW1iZWRkZWREaXNjcmltaW5hdG9yUGF0aCh0aGlzLCBwYXRoTmFtZSwgeyB0eXBlT25seTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXRodHlwZSA9PT0gJ3JlYWwnIHx8IHBhdGh0eXBlID09PSAndmlydHVhbCcpIHtcbiAgICAgICAgICB0aGlzLiRzZXQocGF0aE5hbWUsIHZhbEZvcktleSwgY29uc3RydWN0aW5nLCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXRodHlwZSA9PT0gJ25lc3RlZCcgJiYgdmFsRm9yS2V5IGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICAgICAgICB0aGlzLiRzZXQocGF0aE5hbWUsXG4gICAgICAgICAgICB2YWxGb3JLZXkudG9PYmplY3QoeyB0cmFuc2Zvcm06IGZhbHNlIH0pLCBjb25zdHJ1Y3RpbmcsIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCA9PT0gJ3Rocm93Jykge1xuICAgICAgICAgIGlmIChwYXRodHlwZSA9PT0gJ25lc3RlZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPYmplY3RFeHBlY3RlZEVycm9yKGtleSwgdmFsRm9yS2V5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN0cmljdE1vZGVFcnJvcihrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwYXRodHlwZSA9PT0gJ25lc3RlZCcgJiYgdmFsRm9yS2V5ID09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLiRzZXQocGF0aE5hbWUsIHZhbEZvcktleSwgY29uc3RydWN0aW5nLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh2YWxGb3JLZXkgIT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLiRzZXQocGF0aE5hbWUsIHZhbEZvcktleSwgY29uc3RydWN0aW5nLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgYWxsIHByb3BlcnRpZXMgYXJlIGluIGNvcnJlY3Qgb3JkZXJcbiAgICBjb25zdCBvcmRlcmVkRG9jID0ge307XG4gICAgY29uc3Qgb3JkZXJlZEtleXMgPSBPYmplY3Qua2V5cyh0aGlzLiRfX3NjaGVtYS50cmVlKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gb3JkZXJlZEtleXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIChrZXkgPSBvcmRlcmVkS2V5c1tpXSkgJiZcbiAgICAgICh0aGlzLl9kb2MuaGFzT3duUHJvcGVydHkoa2V5KSkgJiZcbiAgICAgIChvcmRlcmVkRG9jW2tleV0gPSB1bmRlZmluZWQpO1xuICAgIH1cbiAgICB0aGlzLl9kb2MgPSBPYmplY3QuYXNzaWduKG9yZGVyZWREb2MsIHRoaXMuX2RvYyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxldCBwYXRoVHlwZSA9IHRoaXMuJF9fc2NoZW1hLnBhdGhUeXBlKHBhdGgpO1xuICBsZXQgcGFydHMgPSBudWxsO1xuICBpZiAocGF0aFR5cGUgPT09ICdhZGhvY09yVW5kZWZpbmVkJykge1xuICAgIHBhcnRzID0gcGF0aC5pbmRleE9mKCcuJykgPT09IC0xID8gW3BhdGhdIDogcGF0aC5zcGxpdCgnLicpO1xuICAgIHBhdGhUeXBlID0gZ2V0RW1iZWRkZWREaXNjcmltaW5hdG9yUGF0aCh0aGlzLCBwYXJ0cywgeyB0eXBlT25seTogdHJ1ZSB9KTtcbiAgfVxuICBpZiAocGF0aFR5cGUgPT09ICdhZGhvY09yVW5kZWZpbmVkJyAmJiAhdXNlclNwZWNpZmllZFN0cmljdCkge1xuICAgIC8vIE1heSBiZSBwYXRoIHVuZGVybmVhdGggbm9uLXN0cmljdCBzY2hlbWFcbiAgICBpZiAocGFydHMgPT0gbnVsbCkge1xuICAgICAgcGFydHMgPSBwYXRoLmluZGV4T2YoJy4nKSA9PT0gLTEgPyBbcGF0aF0gOiBwYXRoLnNwbGl0KCcuJyk7XG4gICAgfVxuICAgIGNvbnN0IHN1YmRvY1N0cmljdCA9IGdldFN1YmRvY3VtZW50U3RyaWN0VmFsdWUodGhpcy4kX19zY2hlbWEsIHBhcnRzKTtcbiAgICBpZiAoc3ViZG9jU3RyaWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0cmljdCA9IHN1YmRvY1N0cmljdDtcbiAgICB9XG4gIH1cblxuICAvLyBBc3N1bWUgdGhpcyBpcyBhIE1vbmdvb3NlIGRvY3VtZW50IHRoYXQgd2FzIGNvcGllZCBpbnRvIGEgUE9KTyB1c2luZ1xuICAvLyBgT2JqZWN0LmFzc2lnbigpYCBvciBgey4uLmRvY31gXG4gIHZhbCA9IGhhbmRsZVNwcmVhZERvYyh2YWwsIHRydWUpO1xuXG4gIC8vIGlmIHRoaXMgZG9jIGlzIGJlaW5nIGNvbnN0cnVjdGVkIHdlIHNob3VsZCBub3QgdHJpZ2dlciBnZXR0ZXJzXG4gIGNvbnN0IHByaW9yVmFsID0gKCgpID0+IHtcbiAgICBpZiAodGhpcy4kX18ucHJpb3JEb2MgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuJF9fLnByaW9yRG9jLiRfX2dldFZhbHVlKHBhdGgpO1xuICAgIH1cbiAgICBpZiAoY29uc3RydWN0aW5nKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4kX19nZXRWYWx1ZShwYXRoKTtcbiAgfSkoKTtcblxuICBpZiAocGF0aFR5cGUgPT09ICduZXN0ZWQnICYmIHZhbCkge1xuICAgIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiB2YWwgIT0gbnVsbCkge1xuICAgICAgaWYgKHZhbC4kX18gIT0gbnVsbCkge1xuICAgICAgICB2YWwgPSB2YWwudG9PYmplY3QoaW50ZXJuYWxUb09iamVjdE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZShwYXRoLCBuZXcgTW9uZ29vc2VFcnJvci5DYXN0RXJyb3IoJ09iamVjdCcsIHZhbCwgcGF0aCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdhc01vZGlmaWVkID0gdGhpcy4kaXNNb2RpZmllZChwYXRoKTtcbiAgICAgIGNvbnN0IGhhc0luaXRpYWxWYWwgPSB0aGlzLiRfXy5zYXZlZFN0YXRlICE9IG51bGwgJiYgdGhpcy4kX18uc2F2ZWRTdGF0ZS5oYXNPd25Qcm9wZXJ0eShwYXRoKTtcbiAgICAgIGlmICh0aGlzLiRfXy5zYXZlZFN0YXRlICE9IG51bGwgJiYgIXRoaXMuJGlzTmV3ICYmICF0aGlzLiRfXy5zYXZlZFN0YXRlLmhhc093blByb3BlcnR5KHBhdGgpKSB7XG4gICAgICAgIGNvbnN0IGluaXRpYWxWYWwgPSB0aGlzLiRfX2dldFZhbHVlKHBhdGgpO1xuICAgICAgICB0aGlzLiRfXy5zYXZlZFN0YXRlW3BhdGhdID0gaW5pdGlhbFZhbDtcblxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaW5pdGlhbFZhbCB8fCB7fSk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICB0aGlzLiRfXy5zYXZlZFN0YXRlW3BhdGggKyAnLicgKyBrZXldID0gaW5pdGlhbFZhbFtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghbWVyZ2UpIHtcbiAgICAgICAgdGhpcy4kX19zZXRWYWx1ZShwYXRoLCBudWxsKTtcbiAgICAgICAgY2xlYW5Nb2RpZmllZFN1YnBhdGhzKHRoaXMsIHBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHNldCh2YWwsIHBhdGgsIGNvbnN0cnVjdGluZyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGtleXMgPSBnZXRLZXlzSW5TY2hlbWFPcmRlcih0aGlzLiRfX3NjaGVtYSwgdmFsLCBwYXRoKTtcblxuICAgICAgdGhpcy4kX19zZXRWYWx1ZShwYXRoLCB7fSk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIHRoaXMuJHNldChwYXRoICsgJy4nICsga2V5LCB2YWxba2V5XSwgY29uc3RydWN0aW5nLCB7IC4uLm9wdGlvbnMsIF9za2lwTWFya01vZGlmaWVkOiB0cnVlIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHByaW9yVmFsICE9IG51bGwgJiZcbiAgICAgICAgICAoIXdhc01vZGlmaWVkIHx8IGhhc0luaXRpYWxWYWwpICYmXG4gICAgICAgICAgdXRpbHMuZGVlcEVxdWFsKGhhc0luaXRpYWxWYWwgPyB0aGlzLiRfXy5zYXZlZFN0YXRlW3BhdGhdIDogcHJpb3JWYWwsIHZhbCkpIHtcbiAgICAgICAgdGhpcy51bm1hcmtNb2RpZmllZChwYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubWFya01vZGlmaWVkKHBhdGgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoaXMuaW52YWxpZGF0ZShwYXRoLCBuZXcgTW9uZ29vc2VFcnJvci5DYXN0RXJyb3IoJ09iamVjdCcsIHZhbCwgcGF0aCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGV0IHNjaGVtYTtcbiAgaWYgKHBhcnRzID09IG51bGwpIHtcbiAgICBwYXJ0cyA9IHBhdGguaW5kZXhPZignLicpID09PSAtMSA/IFtwYXRoXSA6IHBhdGguc3BsaXQoJy4nKTtcbiAgfVxuXG4gIC8vIE1pZ2h0IG5lZWQgdG8gY2hhbmdlIHBhdGggZm9yIHRvcC1sZXZlbCBhbGlhc1xuICBpZiAodHlwZW9mIHRoaXMuJF9fc2NoZW1hLmFsaWFzZXNbcGFydHNbMF1dID09PSAnc3RyaW5nJykge1xuICAgIHBhcnRzWzBdID0gdGhpcy4kX19zY2hlbWEuYWxpYXNlc1twYXJ0c1swXV07XG4gIH1cblxuICBpZiAocGF0aFR5cGUgPT09ICdhZGhvY09yVW5kZWZpbmVkJyAmJiBzdHJpY3QpIHtcbiAgICAvLyBjaGVjayBmb3Igcm9vdHMgdGhhdCBhcmUgTWl4ZWQgdHlwZXNcbiAgICBsZXQgbWl4ZWQ7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHN1YnBhdGggPSBwYXJ0cy5zbGljZSgwLCBpICsgMSkuam9pbignLicpO1xuXG4gICAgICAvLyBJZiBwYXRoIGlzIHVuZGVybmVhdGggYSB2aXJ0dWFsLCBieXBhc3MgZXZlcnl0aGluZyBhbmQganVzdCBzZXQgaXQuXG4gICAgICBpZiAoaSArIDEgPCBwYXJ0cy5sZW5ndGggJiYgdGhpcy4kX19zY2hlbWEucGF0aFR5cGUoc3VicGF0aCkgPT09ICd2aXJ0dWFsJykge1xuICAgICAgICBtcGF0aC5zZXQocGF0aCwgdmFsLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHNjaGVtYSA9IHRoaXMuJF9fc2NoZW1hLnBhdGgoc3VicGF0aCk7XG4gICAgICBpZiAoc2NoZW1hID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBNaXhlZFNjaGVtYSkge1xuICAgICAgICAvLyBhbGxvdyBjaGFuZ2VzIHRvIHN1YiBwYXRocyBvZiBtaXhlZCB0eXBlc1xuICAgICAgICBtaXhlZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChzY2hlbWEuJGlzU2NoZW1hTWFwICYmIHNjaGVtYS4kX19zY2hlbWFUeXBlIGluc3RhbmNlb2YgTWl4ZWRTY2hlbWEgJiYgaSA8IHBhcnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgLy8gTWFwIG9mIG1peGVkIGFuZCBub3QgdGhlIGxhc3QgZWxlbWVudCBpbiB0aGUgcGF0aCByZXNvbHZlcyB0byBtaXhlZFxuICAgICAgICBtaXhlZCA9IHRydWU7XG4gICAgICAgIHNjaGVtYSA9IHNjaGVtYS4kX19zY2hlbWFUeXBlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2NoZW1hID09IG51bGwpIHtcbiAgICAgIC8vIENoZWNrIGZvciBlbWJlZGRlZCBkaXNjcmltaW5hdG9yc1xuICAgICAgc2NoZW1hID0gZ2V0RW1iZWRkZWREaXNjcmltaW5hdG9yUGF0aCh0aGlzLCBwYXRoKTtcbiAgICB9XG5cbiAgICBpZiAoIW1peGVkICYmICFzY2hlbWEpIHtcbiAgICAgIGlmIChzdHJpY3QgPT09ICd0aHJvdycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN0cmljdE1vZGVFcnJvcihwYXRoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSBlbHNlIGlmIChwYXRoVHlwZSA9PT0gJ3ZpcnR1YWwnKSB7XG4gICAgc2NoZW1hID0gdGhpcy4kX19zY2hlbWEudmlydHVhbHBhdGgocGF0aCk7XG4gICAgc2NoZW1hLmFwcGx5U2V0dGVycyh2YWwsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9IGVsc2Uge1xuICAgIHNjaGVtYSA9IHRoaXMuJF9fcGF0aChwYXRoKTtcbiAgfVxuXG4gIC8vIGdoLTQ1NzgsIGlmIHNldHRpbmcgYSBkZWVwbHkgbmVzdGVkIHBhdGggdGhhdCBkb2Vzbid0IGV4aXN0IHlldCwgY3JlYXRlIGl0XG4gIGxldCBjdXIgPSB0aGlzLl9kb2M7XG4gIGxldCBjdXJQYXRoID0gJyc7XG4gIGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICBjdXIgPSBjdXJbcGFydHNbaV1dO1xuICAgIGN1clBhdGggKz0gKGN1clBhdGgubGVuZ3RoICE9PSAwID8gJy4nIDogJycpICsgcGFydHNbaV07XG4gICAgaWYgKCFjdXIpIHtcbiAgICAgIHRoaXMuJHNldChjdXJQYXRoLCB7fSk7XG4gICAgICAvLyBIYWNrIHJlOiBnaC01ODAwLiBJZiBuZXN0ZWQgZmllbGQgaXMgbm90IHNlbGVjdGVkLCBpdCBwcm9iYWJseSBleGlzdHNcbiAgICAgIC8vIHNvIGBNb25nb1NlcnZlckVycm9yOiBjYW5ub3QgdXNlIHRoZSBwYXJ0IChuZXN0ZWQgb2YgbmVzdGVkLm51bSkgdG9cbiAgICAgIC8vIHRyYXZlcnNlIHRoZSBlbGVtZW50ICh7bmVzdGVkOiBudWxsfSlgIGlzIG5vdCBsaWtlbHkuIElmIHVzZXIgZ2V0c1xuICAgICAgLy8gdGhhdCBlcnJvciwgaXRzIHRoZWlyIGZhdWx0IGZvciBub3cuIFdlIHNob3VsZCByZWNvbnNpZGVyIGRpc2FsbG93aW5nXG4gICAgICAvLyBtb2RpZnlpbmcgbm90IHNlbGVjdGVkIHBhdGhzIGZvciA2LnhcbiAgICAgIGlmICghdGhpcy4kX19pc1NlbGVjdGVkKGN1clBhdGgpKSB7XG4gICAgICAgIHRoaXMudW5tYXJrTW9kaWZpZWQoY3VyUGF0aCk7XG4gICAgICB9XG4gICAgICBjdXIgPSB0aGlzLiRfX2dldFZhbHVlKGN1clBhdGgpO1xuICAgIH1cbiAgfVxuXG4gIGxldCBwYXRoVG9NYXJrO1xuXG4gIC8vIFdoZW4gdXNpbmcgdGhlICRzZXQgb3BlcmF0b3IgdGhlIHBhdGggdG8gdGhlIGZpZWxkIG11c3QgYWxyZWFkeSBleGlzdC5cbiAgLy8gRWxzZSBtb25nb2RiIHRocm93czogXCJMRUZUX1NVQkZJRUxEIG9ubHkgc3VwcG9ydHMgT2JqZWN0XCJcblxuICBpZiAocGFydHMubGVuZ3RoIDw9IDEpIHtcbiAgICBwYXRoVG9NYXJrID0gcGF0aDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBsZW4gPSBwYXJ0cy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb25zdCBzdWJwYXRoID0gcGFydHMuc2xpY2UoMCwgaSArIDEpLmpvaW4oJy4nKTtcbiAgICAgIGlmICh0aGlzLiRnZXQoc3VicGF0aCwgbnVsbCwgeyBnZXR0ZXJzOiBmYWxzZSB9KSA9PT0gbnVsbCkge1xuICAgICAgICBwYXRoVG9NYXJrID0gc3VicGF0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFwYXRoVG9NYXJrKSB7XG4gICAgICBwYXRoVG9NYXJrID0gcGF0aDtcbiAgICB9XG4gIH1cblxuICBpZiAoIXNjaGVtYSkge1xuICAgIHRoaXMuJF9fc2V0KHBhdGhUb01hcmssIHBhdGgsIG9wdGlvbnMsIGNvbnN0cnVjdGluZywgcGFydHMsIHNjaGVtYSwgdmFsLCBwcmlvclZhbCk7XG5cbiAgICBpZiAocGF0aFR5cGUgPT09ICduZXN0ZWQnICYmIHZhbCA9PSBudWxsKSB7XG4gICAgICBjbGVhbk1vZGlmaWVkU3VicGF0aHModGhpcywgcGF0aCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gSWYgb3ZlcndyaXRpbmcgYSBzdWJkb2N1bWVudCBwYXRoLCBtYWtlIHN1cmUgdG8gY2xlYXIgb3V0XG4gIC8vIGFueSBlcnJvcnMgX2JlZm9yZV8gc2V0dGluZywgc28gbmV3IGVycm9ycyB0aGF0IGhhcHBlblxuICAvLyBnZXQgcGVyc2lzdGVkLiBSZTogIzkwODBcbiAgaWYgKHNjaGVtYS4kaXNTaW5nbGVOZXN0ZWQgfHwgc2NoZW1hLiRpc01vbmdvb3NlQXJyYXkpIHtcbiAgICBfbWFya1ZhbGlkU3VicGF0aHModGhpcywgcGF0aCk7XG4gIH1cblxuICBpZiAodmFsICE9IG51bGwgJiYgbWVyZ2UgJiYgc2NoZW1hLiRpc1NpbmdsZU5lc3RlZCkge1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBEb2N1bWVudCkge1xuICAgICAgdmFsID0gdmFsLnRvT2JqZWN0KHsgdmlydHVhbHM6IGZhbHNlLCB0cmFuc2Zvcm06IGZhbHNlIH0pO1xuICAgIH1cbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICB0aGlzLiRzZXQocGF0aCArICcuJyArIGtleSwgdmFsW2tleV0sIGNvbnN0cnVjdGluZywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsZXQgc2hvdWxkU2V0ID0gdHJ1ZTtcbiAgdHJ5IHtcbiAgICAvLyBJZiB0aGUgdXNlciBpcyB0cnlpbmcgdG8gc2V0IGEgcmVmIHBhdGggdG8gYSBkb2N1bWVudCB3aXRoXG4gICAgLy8gdGhlIGNvcnJlY3QgbW9kZWwgbmFtZSwgdHJlYXQgaXQgYXMgcG9wdWxhdGVkXG4gICAgY29uc3QgcmVmTWF0Y2hlcyA9ICgoKSA9PiB7XG4gICAgICBpZiAoc2NoZW1hLm9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoISh2YWwgaW5zdGFuY2VvZiBEb2N1bWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgbW9kZWwgPSB2YWwuY29uc3RydWN0b3I7XG5cbiAgICAgIC8vIENoZWNrIHJlZlxuICAgICAgY29uc3QgcmVmID0gc2NoZW1hLm9wdGlvbnMucmVmO1xuICAgICAgaWYgKHJlZiAhPSBudWxsICYmIChyZWYgPT09IG1vZGVsLm1vZGVsTmFtZSB8fCByZWYgPT09IG1vZGVsLmJhc2VNb2RlbE5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayByZWZQYXRoXG4gICAgICBjb25zdCByZWZQYXRoID0gc2NoZW1hLm9wdGlvbnMucmVmUGF0aDtcbiAgICAgIGlmIChyZWZQYXRoID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgbW9kZWxOYW1lID0gdmFsLmdldChyZWZQYXRoKTtcbiAgICAgIHJldHVybiBtb2RlbE5hbWUgPT09IG1vZGVsLm1vZGVsTmFtZSB8fCBtb2RlbE5hbWUgPT09IG1vZGVsLmJhc2VNb2RlbE5hbWU7XG4gICAgfSkoKTtcblxuICAgIGxldCBkaWRQb3B1bGF0ZSA9IGZhbHNlO1xuICAgIGlmIChyZWZNYXRjaGVzICYmIHZhbCBpbnN0YW5jZW9mIERvY3VtZW50ICYmICghdmFsLiRfXy53YXNQb3B1bGF0ZWQgfHwgdXRpbHMuZGVlcEVxdWFsKHZhbC4kX18ud2FzUG9wdWxhdGVkLnZhbHVlLCB2YWwuX2lkKSkpIHtcbiAgICAgIGNvbnN0IHVucG9wdWxhdGVkVmFsdWUgPSAoc2NoZW1hICYmIHNjaGVtYS4kaXNTaW5nbGVOZXN0ZWQpID8gc2NoZW1hLmNhc3QodmFsLCB0aGlzKSA6IHZhbC5faWQ7XG4gICAgICB0aGlzLiRwb3B1bGF0ZWQocGF0aCwgdW5wb3B1bGF0ZWRWYWx1ZSwgeyBbcG9wdWxhdGVNb2RlbFN5bWJvbF06IHZhbC5jb25zdHJ1Y3RvciB9KTtcbiAgICAgIHZhbC4kX18ud2FzUG9wdWxhdGVkID0geyB2YWx1ZTogdW5wb3B1bGF0ZWRWYWx1ZSB9O1xuICAgICAgZGlkUG9wdWxhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIGxldCBwb3BPcHRzO1xuICAgIGNvbnN0IHR5cGVLZXkgPSB0aGlzLiRfX3NjaGVtYS5vcHRpb25zLnR5cGVLZXk7XG4gICAgaWYgKHNjaGVtYS5vcHRpb25zICYmXG4gICAgICAgIEFycmF5LmlzQXJyYXkoc2NoZW1hLm9wdGlvbnNbdHlwZUtleV0pICYmXG4gICAgICAgIHNjaGVtYS5vcHRpb25zW3R5cGVLZXldLmxlbmd0aCAmJlxuICAgICAgICBzY2hlbWEub3B0aW9uc1t0eXBlS2V5XVswXSAmJlxuICAgICAgICBzY2hlbWEub3B0aW9uc1t0eXBlS2V5XVswXS5yZWYgJiZcbiAgICAgICAgX2lzTWFudWFsbHlQb3B1bGF0ZWRBcnJheSh2YWwsIHNjaGVtYS5vcHRpb25zW3R5cGVLZXldWzBdLnJlZikpIHtcbiAgICAgIHBvcE9wdHMgPSB7IFtwb3B1bGF0ZU1vZGVsU3ltYm9sXTogdmFsWzBdLmNvbnN0cnVjdG9yIH07XG4gICAgICB0aGlzLiRwb3B1bGF0ZWQocGF0aCwgdmFsLm1hcChmdW5jdGlvbih2KSB7IHJldHVybiB2Ll9pZDsgfSksIHBvcE9wdHMpO1xuXG4gICAgICBmb3IgKGNvbnN0IGRvYyBvZiB2YWwpIHtcbiAgICAgICAgZG9jLiRfXy53YXNQb3B1bGF0ZWQgPSB7IHZhbHVlOiBkb2MuX2lkIH07XG4gICAgICB9XG4gICAgICBkaWRQb3B1bGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCFyZWZNYXRjaGVzIHx8ICFzY2hlbWEuJGlzU2luZ2xlTmVzdGVkIHx8ICF2YWwuJF9fKSB7XG4gICAgICAvLyBJZiB0aGlzIHBhdGggaXMgdW5kZXJuZWF0aCBhIHNpbmdsZSBuZXN0ZWQgc2NoZW1hLCB3ZSdsbCBjYWxsIHRoZSBzZXR0ZXJcbiAgICAgIC8vIGxhdGVyIGluIGAkX19zZXQoKWAgYmVjYXVzZSB3ZSBkb24ndCB0YWtlIGBfZG9jYCB3aGVuIHdlIGl0ZXJhdGUgdGhyb3VnaFxuICAgICAgLy8gYSBzaW5nbGUgbmVzdGVkIGRvYy4gVGhhdCdzIHRvIG1ha2Ugc3VyZSB3ZSBnZXQgdGhlIGNvcnJlY3QgY29udGV4dC5cbiAgICAgIC8vIE90aGVyd2lzZSB3ZSB3b3VsZCBkb3VibGUtY2FsbCB0aGUgc2V0dGVyLCBzZWUgZ2gtNzE5Ni5cbiAgICAgIGxldCBzZXR0ZXJDb250ZXh0ID0gdGhpcztcbiAgICAgIGlmICh0aGlzLiRfX3NjaGVtYS5zaW5nbGVOZXN0ZWRQYXRoc1twYXRoXSAhPSBudWxsICYmIHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgc2V0dGVyQ29udGV4dCA9IGdldERlZXBlc3RTdWJkb2N1bWVudEZvclBhdGgodGhpcywgcGFydHMsIHRoaXMuc2NoZW1hKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5vdmVyd3JpdGVJbW11dGFibGUpIHtcbiAgICAgICAgdmFsID0gc2NoZW1hLmFwcGx5U2V0dGVycyh2YWwsIHNldHRlckNvbnRleHQsIGZhbHNlLCBwcmlvclZhbCwgeyBvdmVyd3JpdGVJbW11dGFibGU6IHRydWUgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBzY2hlbWEuYXBwbHlTZXR0ZXJzKHZhbCwgc2V0dGVyQ29udGV4dCwgZmFsc2UsIHByaW9yVmFsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpICYmXG4gICAgICAgICFBcnJheS5pc0FycmF5KHNjaGVtYSkgJiZcbiAgICAgICAgc2NoZW1hLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSAmJlxuICAgICAgICB2YWwubGVuZ3RoICE9PSAwICYmXG4gICAgICAgIHZhbFswXSAhPSBudWxsICYmXG4gICAgICAgIHZhbFswXS4kX18gIT0gbnVsbCAmJlxuICAgICAgICB2YWxbMF0uJF9fLnBvcHVsYXRlZCAhPSBudWxsKSB7XG4gICAgICBjb25zdCBwb3B1bGF0ZWRQYXRocyA9IE9iamVjdC5rZXlzKHZhbFswXS4kX18ucG9wdWxhdGVkKTtcbiAgICAgIGZvciAoY29uc3QgcG9wdWxhdGVkUGF0aCBvZiBwb3B1bGF0ZWRQYXRocykge1xuICAgICAgICB0aGlzLiRwb3B1bGF0ZWQocGF0aCArICcuJyArIHBvcHVsYXRlZFBhdGgsXG4gICAgICAgICAgdmFsLm1hcCh2ID0+IHYuJHBvcHVsYXRlZChwb3B1bGF0ZWRQYXRoKSksXG4gICAgICAgICAgdmFsWzBdLiRfXy5wb3B1bGF0ZWRbcG9wdWxhdGVkUGF0aF0ub3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBkaWRQb3B1bGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCFkaWRQb3B1bGF0ZSAmJiB0aGlzLiRfXy5wb3B1bGF0ZWQpIHtcbiAgICAgIC8vIElmIHRoaXMgYXJyYXkgcGFydGlhbGx5IGNvbnRhaW5zIHBvcHVsYXRlZCBkb2N1bWVudHMsIGNvbnZlcnQgdGhlbVxuICAgICAgLy8gYWxsIHRvIE9iamVjdElkcyByZTogIzg0NDNcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkgJiYgdGhpcy4kX18ucG9wdWxhdGVkW3BhdGhdKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKHZhbFtpXSBpbnN0YW5jZW9mIERvY3VtZW50KSB7XG4gICAgICAgICAgICB2YWwuc2V0KGksIHZhbFtpXS5faWQsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVsZXRlIHRoaXMuJF9fLnBvcHVsYXRlZFtwYXRoXTtcbiAgICB9XG5cbiAgICBpZiAodmFsICE9IG51bGwgJiYgc2NoZW1hLiRpc1NpbmdsZU5lc3RlZCkge1xuICAgICAgX2NoZWNrSW1tdXRhYmxlU3VicGF0aHModmFsLCBzY2hlbWEsIHByaW9yVmFsKTtcbiAgICB9XG5cbiAgICB0aGlzLiRtYXJrVmFsaWQocGF0aCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIE1vbmdvb3NlRXJyb3IuU3RyaWN0TW9kZUVycm9yICYmIGUuaXNJbW11dGFibGVFcnJvcikge1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKHBhdGgsIGUpO1xuICAgIH0gZWxzZSBpZiAoZSBpbnN0YW5jZW9mIE1vbmdvb3NlRXJyb3IuQ2FzdEVycm9yKSB7XG4gICAgICB0aGlzLmludmFsaWRhdGUoZS5wYXRoLCBlKTtcbiAgICAgIGlmIChlLiRvcmlnaW5hbEVycm9yUGF0aCkge1xuICAgICAgICB0aGlzLmludmFsaWRhdGUocGF0aCxcbiAgICAgICAgICBuZXcgTW9uZ29vc2VFcnJvci5DYXN0RXJyb3Ioc2NoZW1hLmluc3RhbmNlLCB2YWwsIHBhdGgsIGUuJG9yaWdpbmFsRXJyb3JQYXRoKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZShwYXRoLFxuICAgICAgICBuZXcgTW9uZ29vc2VFcnJvci5DYXN0RXJyb3Ioc2NoZW1hLmluc3RhbmNlLCB2YWwsIHBhdGgsIGUpKTtcbiAgICB9XG4gICAgc2hvdWxkU2V0ID0gZmFsc2U7XG4gIH1cblxuICBpZiAoc2hvdWxkU2V0KSB7XG4gICAgbGV0IHNhdmVkU3RhdGUgPSBudWxsO1xuICAgIGxldCBzYXZlZFN0YXRlUGF0aCA9IG51bGw7XG4gICAgaWYgKCFjb25zdHJ1Y3RpbmcpIHtcbiAgICAgIGNvbnN0IGRvYyA9IHRoaXMuJGlzU3ViZG9jdW1lbnQgPyB0aGlzLm93bmVyRG9jdW1lbnQoKSA6IHRoaXM7XG4gICAgICBzYXZlZFN0YXRlID0gZG9jLiRfXy5zYXZlZFN0YXRlO1xuICAgICAgc2F2ZWRTdGF0ZVBhdGggPSB0aGlzLiRpc1N1YmRvY3VtZW50ID8gdGhpcy4kX18uZnVsbFBhdGggKyAnLicgKyBwYXRoIDogcGF0aDtcbiAgICAgIGRvYy4kX19zYXZlSW5pdGlhbFN0YXRlKHNhdmVkU3RhdGVQYXRoKTtcbiAgICB9XG5cbiAgICB0aGlzLiRfX3NldChwYXRoVG9NYXJrLCBwYXRoLCBvcHRpb25zLCBjb25zdHJ1Y3RpbmcsIHBhcnRzLCBzY2hlbWEsIHZhbCwgcHJpb3JWYWwpO1xuXG4gICAgY29uc3QgaXNJblRyYW5zYWN0aW9uID0gISF0aGlzLiRfXy5zZXNzaW9uPy50cmFuc2FjdGlvbjtcbiAgICBjb25zdCBpc01vZGlmaWVkV2l0aGluVHJhbnNhY3Rpb24gPSB0aGlzLiRfXy5zZXNzaW9uICYmXG4gICAgICB0aGlzLiRfXy5zZXNzaW9uW3Nlc3Npb25OZXdEb2N1bWVudHNdICYmXG4gICAgICB0aGlzLiRfXy5zZXNzaW9uW3Nlc3Npb25OZXdEb2N1bWVudHNdLmhhcyh0aGlzKSAmJlxuICAgICAgdGhpcy4kX18uc2Vzc2lvbltzZXNzaW9uTmV3RG9jdW1lbnRzXS5nZXQodGhpcykubW9kaWZpZWRQYXRocyAmJlxuICAgICAgIXRoaXMuJF9fLnNlc3Npb25bc2Vzc2lvbk5ld0RvY3VtZW50c10uZ2V0KHRoaXMpLm1vZGlmaWVkUGF0aHMuaGFzKHNhdmVkU3RhdGVQYXRoKTtcbiAgICBpZiAoc2F2ZWRTdGF0ZSAhPSBudWxsICYmXG4gICAgICAgIHNhdmVkU3RhdGUuaGFzT3duUHJvcGVydHkoc2F2ZWRTdGF0ZVBhdGgpICYmXG4gICAgICAgICghaXNJblRyYW5zYWN0aW9uIHx8IGlzTW9kaWZpZWRXaXRoaW5UcmFuc2FjdGlvbikgJiZcbiAgICAgICAgdXRpbHMuZGVlcEVxdWFsKHZhbCwgc2F2ZWRTdGF0ZVtzYXZlZFN0YXRlUGF0aF0pKSB7XG4gICAgICB0aGlzLnVubWFya01vZGlmaWVkKHBhdGgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzY2hlbWEuJGlzU2luZ2xlTmVzdGVkICYmICh0aGlzLmlzRGlyZWN0TW9kaWZpZWQocGF0aCkgfHwgdmFsID09IG51bGwpKSB7XG4gICAgY2xlYW5Nb2RpZmllZFN1YnBhdGhzKHRoaXMsIHBhdGgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9pc01hbnVhbGx5UG9wdWxhdGVkQXJyYXkodmFsLCByZWYpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGNvbnN0IGVsIG9mIHZhbCkge1xuICAgIGlmICghKGVsIGluc3RhbmNlb2YgRG9jdW1lbnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG1vZGVsTmFtZSA9IGVsLmNvbnN0cnVjdG9yLm1vZGVsTmFtZTtcbiAgICBpZiAobW9kZWxOYW1lID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGVsLmNvbnN0cnVjdG9yLm1vZGVsTmFtZSAhPSByZWYgJiYgZWwuY29uc3RydWN0b3IuYmFzZU1vZGVsTmFtZSAhPSByZWYpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBvZiBhIHBhdGgsIG9yIG1hbnkgcGF0aHMuXG4gKiBBbGlhcyBmb3IgW2AuJHNldGBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudC5wcm90b3R5cGUuJHNldCgpKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIHBhdGgsIHZhbHVlXG4gKiAgICAgZG9jLnNldChwYXRoLCB2YWx1ZSlcbiAqXG4gKiAgICAgLy8gb2JqZWN0XG4gKiAgICAgZG9jLnNldCh7XG4gKiAgICAgICAgIHBhdGggIDogdmFsdWVcbiAqICAgICAgICwgcGF0aDIgOiB7XG4gKiAgICAgICAgICAgIHBhdGggIDogdmFsdWVcbiAqICAgICAgICAgfVxuICogICAgIH0pXG4gKlxuICogICAgIC8vIG9uLXRoZS1mbHkgY2FzdCB0byBudW1iZXJcbiAqICAgICBkb2Muc2V0KHBhdGgsIHZhbHVlLCBOdW1iZXIpXG4gKlxuICogICAgIC8vIG9uLXRoZS1mbHkgY2FzdCB0byBzdHJpbmdcbiAqICAgICBkb2Muc2V0KHBhdGgsIHZhbHVlLCBTdHJpbmcpXG4gKlxuICogICAgIC8vIGNoYW5naW5nIHN0cmljdCBtb2RlIGJlaGF2aW9yXG4gKiAgICAgZG9jLnNldChwYXRoLCB2YWx1ZSwgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gcGF0aCBwYXRoIG9yIG9iamVjdCBvZiBrZXkvdmFscyB0byBzZXRcbiAqIEBwYXJhbSB7QW55fSB2YWwgdGhlIHZhbHVlIHRvIHNldFxuICogQHBhcmFtIHtTY2hlbWF8U3RyaW5nfE51bWJlcnxCdWZmZXJ8Kn0gW3R5cGVdIG9wdGlvbmFsbHkgc3BlY2lmeSBhIHR5cGUgZm9yIFwib24tdGhlLWZseVwiIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWxseSBzcGVjaWZ5IG9wdGlvbnMgdGhhdCBtb2RpZnkgdGhlIGJlaGF2aW9yIG9mIHRoZSBzZXRcbiAqIEByZXR1cm4ge0RvY3VtZW50fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCBzZXRcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLnNldCA9IERvY3VtZW50LnByb3RvdHlwZS4kc2V0O1xuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSBzaG91bGQgbWFyayB0aGlzIGNoYW5nZSBhcyBtb2RpZmllZC5cbiAqXG4gKiBAcGFyYW0ge25ldmVyfSBwYXRoVG9NYXJrIFVOVVNFRFxuICogQHBhcmFtIHtTdHJpbmd8U3ltYm9sfSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtBbnl9IGNvbnN0cnVjdGluZ1xuICogQHBhcmFtIHtuZXZlcn0gcGFydHMgVU5VU0VEXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAcGFyYW0ge0FueX0gdmFsXG4gKiBAcGFyYW0ge0FueX0gcHJpb3JWYWxcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqIEBtZXRob2QgJF9fc2hvdWxkTW9kaWZ5XG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kX19zaG91bGRNb2RpZnkgPSBmdW5jdGlvbihwYXRoVG9NYXJrLCBwYXRoLCBvcHRpb25zLCBjb25zdHJ1Y3RpbmcsIHBhcnRzLCBzY2hlbWEsIHZhbCwgcHJpb3JWYWwpIHtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5fc2tpcE1hcmtNb2RpZmllZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodGhpcy4kaXNOZXcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyBJcyBwYXRoIGFscmVhZHkgbW9kaWZpZWQ/IElmIHNvLCBhbHdheXMgbW9kaWZ5LiBXZSBtYXkgdW5tYXJrIG1vZGlmaWVkIGxhdGVyLlxuICBpZiAocGF0aCBpbiB0aGlzLiRfXy5hY3RpdmVQYXRocy5nZXRTdGF0ZVBhdGhzKCdtb2RpZnknKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHZhbCA9PT0gdm9pZCAwICYmICF0aGlzLiRfX2lzU2VsZWN0ZWQocGF0aCkpIHtcbiAgICAvLyB3aGVuIGEgcGF0aCBpcyBub3Qgc2VsZWN0ZWQgaW4gYSBxdWVyeSwgaXRzIGluaXRpYWxcbiAgICAvLyB2YWx1ZSB3aWxsIGJlIHVuZGVmaW5lZC5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh2YWwgPT09IHZvaWQgMCAmJiBwYXRoIGluIHRoaXMuJF9fLmFjdGl2ZVBhdGhzLmdldFN0YXRlUGF0aHMoJ2RlZmF1bHQnKSkge1xuICAgIC8vIHdlJ3JlIGp1c3QgdW5zZXR0aW5nIHRoZSBkZWZhdWx0IHZhbHVlIHdoaWNoIHdhcyBuZXZlciBzYXZlZFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGdoLTM5OTI6IGlmIHNldHRpbmcgYSBwb3B1bGF0ZWQgZmllbGQgdG8gYSBkb2MsIGRvbid0IG1hcmsgbW9kaWZpZWRcbiAgLy8gaWYgdGhleSBoYXZlIHRoZSBzYW1lIF9pZFxuICBpZiAodGhpcy4kcG9wdWxhdGVkKHBhdGgpICYmXG4gICAgICB2YWwgaW5zdGFuY2VvZiBEb2N1bWVudCAmJlxuICAgICAgZGVlcEVxdWFsKHZhbC5faWQsIHByaW9yVmFsKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghZGVlcEVxdWFsKHZhbCwgcHJpb3JWYWwgIT09IHVuZGVmaW5lZCA/IHByaW9yVmFsIDogdXRpbHMuZ2V0VmFsdWUocGF0aCwgdGhpcykpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoIWNvbnN0cnVjdGluZyAmJlxuICAgICAgdmFsICE9PSBudWxsICYmXG4gICAgICB2YWwgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgcGF0aCBpbiB0aGlzLiRfXy5hY3RpdmVQYXRocy5nZXRTdGF0ZVBhdGhzKCdkZWZhdWx0JykgJiZcbiAgICAgIGRlZXBFcXVhbCh2YWwsIHNjaGVtYS5nZXREZWZhdWx0KHRoaXMsIGNvbnN0cnVjdGluZykpKSB7XG4gICAgLy8gYSBwYXRoIHdpdGggYSBkZWZhdWx0IHdhcyAkdW5zZXQgb24gdGhlIHNlcnZlclxuICAgIC8vIGFuZCB0aGUgdXNlciBpcyBzZXR0aW5nIGl0IHRvIHRoZSBzYW1lIHZhbHVlIGFnYWluXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBIYW5kbGVzIHRoZSBhY3R1YWwgc2V0dGluZyBvZiB0aGUgdmFsdWUgYW5kIG1hcmtpbmcgdGhlIHBhdGggbW9kaWZpZWQgaWYgYXBwcm9wcmlhdGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhUb01hcmtcbiAqIEBwYXJhbSB7U3RyaW5nfFN5bWJvbH0gcGF0aFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7QW55fSBjb25zdHJ1Y3RpbmdcbiAqIEBwYXJhbSB7QXJyYXl9IHBhcnRzXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAcGFyYW0ge0FueX0gdmFsXG4gKiBAcGFyYW0ge0FueX0gcHJpb3JWYWxcbiAqIEBhcGkgcHJpdmF0ZVxuICogQG1ldGhvZCAkX19zZXRcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRfX3NldCA9IGZ1bmN0aW9uKHBhdGhUb01hcmssIHBhdGgsIG9wdGlvbnMsIGNvbnN0cnVjdGluZywgcGFydHMsIHNjaGVtYSwgdmFsLCBwcmlvclZhbCkge1xuICBFbWJlZGRlZCA9IEVtYmVkZGVkIHx8IHJlcXVpcmUoJy4vdHlwZXMvYXJyYXlTdWJkb2N1bWVudCcpO1xuXG4gIGNvbnN0IHNob3VsZE1vZGlmeSA9IHRoaXMuJF9fc2hvdWxkTW9kaWZ5KHBhdGhUb01hcmssIHBhdGgsIG9wdGlvbnMsIGNvbnN0cnVjdGluZywgcGFydHMsXG4gICAgc2NoZW1hLCB2YWwsIHByaW9yVmFsKTtcblxuICBpZiAoc2hvdWxkTW9kaWZ5KSB7XG4gICAgaWYgKHRoaXMuJF9fLnByaW1pdGl2ZUF0b21pY3MgJiYgdGhpcy4kX18ucHJpbWl0aXZlQXRvbWljc1twYXRoXSkge1xuICAgICAgZGVsZXRlIHRoaXMuJF9fLnByaW1pdGl2ZUF0b21pY3NbcGF0aF07XG4gICAgICBpZiAoT2JqZWN0LmtleXModGhpcy4kX18ucHJpbWl0aXZlQXRvbWljcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLiRfXy5wcmltaXRpdmVBdG9taWNzO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm1hcmtNb2RpZmllZChwYXRoVG9NYXJrKTtcblxuICAgIC8vIGhhbmRsZSBkaXJlY3RseSBzZXR0aW5nIGFycmF5cyAoZ2gtMTEyNilcbiAgICBNb25nb29zZUFycmF5IHx8IChNb25nb29zZUFycmF5ID0gcmVxdWlyZSgnLi90eXBlcy9hcnJheScpKTtcbiAgICBpZiAodmFsICYmIHV0aWxzLmlzTW9uZ29vc2VBcnJheSh2YWwpKSB7XG4gICAgICB2YWwuX3JlZ2lzdGVyQXRvbWljKCckc2V0JywgdmFsKTtcblxuICAgICAgLy8gVXBkYXRlIGVtYmVkZGVkIGRvY3VtZW50IHBhcmVudCByZWZlcmVuY2VzIChnaC01MTg5KVxuICAgICAgaWYgKHV0aWxzLmlzTW9uZ29vc2VEb2N1bWVudEFycmF5KHZhbCkpIHtcbiAgICAgICAgdmFsLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgIGl0ZW0gJiYgaXRlbS5fX3BhcmVudEFycmF5ICYmIChpdGVtLl9fcGFyZW50QXJyYXkgPSB2YWwpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwpICYmIEFycmF5LmlzQXJyYXkocHJpb3JWYWwpICYmIHV0aWxzLmlzTW9uZ29vc2VBcnJheSh2YWwpICYmIHV0aWxzLmlzTW9uZ29vc2VBcnJheShwcmlvclZhbCkpIHtcbiAgICB2YWxbYXJyYXlBdG9taWNzU3ltYm9sXSA9IHByaW9yVmFsW2FycmF5QXRvbWljc1N5bWJvbF07XG4gICAgdmFsW2FycmF5QXRvbWljc0JhY2t1cFN5bWJvbF0gPSBwcmlvclZhbFthcnJheUF0b21pY3NCYWNrdXBTeW1ib2xdO1xuICAgIGlmICh1dGlscy5pc01vbmdvb3NlRG9jdW1lbnRBcnJheSh2YWwpKSB7XG4gICAgICB2YWwuZm9yRWFjaChkb2MgPT4ge1xuICAgICAgICBpZiAoZG9jICE9IG51bGwpIHtcbiAgICAgICAgICBkb2MuJGlzTmV3ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGxldCBvYmogPSB0aGlzLl9kb2M7XG4gIGxldCBpID0gMDtcbiAgY29uc3QgbCA9IHBhcnRzLmxlbmd0aDtcbiAgbGV0IGN1ciA9ICcnO1xuXG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3QgbmV4dCA9IGkgKyAxO1xuICAgIGNvbnN0IGxhc3QgPSBuZXh0ID09PSBsO1xuICAgIGN1ciArPSAoY3VyID8gJy4nICsgcGFydHNbaV0gOiBwYXJ0c1tpXSk7XG4gICAgaWYgKHNwZWNpYWxQcm9wZXJ0aWVzLmhhcyhwYXJ0c1tpXSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobGFzdCkge1xuICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBvYmouc2V0KHBhcnRzW2ldLCB2YWwpO1xuICAgICAgfSBlbHNlIGlmIChvYmouJGlzU2luZ2xlTmVzdGVkKSB7XG4gICAgICAgIGlmICghKHBhcnRzW2ldIGluIG9iaikpIHtcbiAgICAgICAgICBvYmpbcGFydHNbaV1dID0gdmFsO1xuICAgICAgICAgIG9iai5fZG9jW3BhcnRzW2ldXSA9IHZhbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmouX2RvY1twYXJ0c1tpXV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtwYXJ0c1tpXV0gPSB2YWw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGlzTWFwID0gb2JqIGluc3RhbmNlb2YgTWFwO1xuICAgICAgbGV0IHZhbHVlID0gaXNNYXAgPyBvYmouZ2V0KHBhcnRzW2ldKSA6IG9ialtwYXJ0c1tpXV07XG4gICAgICBpZiAodXRpbHMuaXNQT0pPKHZhbHVlKSkge1xuICAgICAgICBvYmogPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgJiYgdmFsdWUgaW5zdGFuY2VvZiBFbWJlZGRlZCkge1xuICAgICAgICBvYmogPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLiRpc1NpbmdsZU5lc3RlZCkge1xuICAgICAgICBvYmogPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgb2JqID0gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgdmFsdWUgPSB7fTtcbiAgICAgICAgaWYgKGlzTWFwKSB7XG4gICAgICAgICAgb2JqLnNldChwYXJ0c1tpXSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9ialtwYXJ0c1tpXV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBvYmogPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iaiA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBHZXRzIGEgcmF3IHZhbHVlIGZyb20gYSBwYXRoIChubyBnZXR0ZXJzKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtBbnl9IFJldHVybnMgdGhlIHZhbHVlIGZyb20gdGhlIGdpdmVuIGBwYXRoYC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kX19nZXRWYWx1ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHV0aWxzLmdldFZhbHVlKHBhdGgsIHRoaXMuX2RvYyk7XG59O1xuXG4vKipcbiAqIEluY3JlbWVudHMgdGhlIG51bWVyaWMgdmFsdWUgYXQgYHBhdGhgIGJ5IHRoZSBnaXZlbiBgdmFsYC5cbiAqIFdoZW4geW91IGNhbGwgYHNhdmUoKWAgb24gdGhpcyBkb2N1bWVudCwgTW9uZ29vc2Ugd2lsbCBzZW5kIGFcbiAqIFtgJGluY2BdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci91cGRhdGUvaW5jLylcbiAqIGFzIG9wcG9zZWQgdG8gYSBgJHNldGAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgY291bnRlcjogTnVtYmVyIH0pO1xuICogICAgIGNvbnN0IFRlc3QgPSBkYi5tb2RlbCgnVGVzdCcsIHNjaGVtYSk7XG4gKlxuICogICAgIGNvbnN0IGRvYyA9IGF3YWl0IFRlc3QuY3JlYXRlKHsgY291bnRlcjogMCB9KTtcbiAqICAgICBkb2MuJGluYygnY291bnRlcicsIDIpO1xuICogICAgIGF3YWl0IGRvYy5zYXZlKCk7IC8vIFNlbmRzIGEgYHsgJGluYzogeyBjb3VudGVyOiAyIH0gfWAgdG8gTW9uZ29EQlxuICogICAgIGRvYy5jb3VudGVyOyAvLyAyXG4gKlxuICogICAgIGRvYy5jb3VudGVyICs9IDI7XG4gKiAgICAgYXdhaXQgZG9jLnNhdmUoKTsgLy8gU2VuZHMgYSBgeyAkc2V0OiB7IGNvdW50ZXI6IDIgfSB9YCB0byBNb25nb0RCXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHBhdGggcGF0aCBvciBwYXRocyB0byB1cGRhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWwgaW5jcmVtZW50IGBwYXRoYCBieSB0aGlzIHZhbHVlXG4gKiBAcmV0dXJuIHtEb2N1bWVudH0gdGhpc1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kaW5jID0gZnVuY3Rpb24gJGluYyhwYXRoLCB2YWwpIHtcbiAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgdmFsID0gMTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgcGF0aC5mb3JFYWNoKChwKSA9PiB0aGlzLiRpbmMocCwgdmFsKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjb25zdCBzY2hlbWFUeXBlID0gdGhpcy4kX19wYXRoKHBhdGgpO1xuICBpZiAoc2NoZW1hVHlwZSA9PSBudWxsKSB7XG4gICAgaWYgKHRoaXMuJF9fLnN0cmljdE1vZGUgPT09ICd0aHJvdycpIHtcbiAgICAgIHRocm93IG5ldyBTdHJpY3RNb2RlRXJyb3IocGF0aCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLiRfXy5zdHJpY3RNb2RlID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0gZWxzZSBpZiAoc2NoZW1hVHlwZS5pbnN0YW5jZSAhPT0gJ051bWJlcicpIHtcbiAgICB0aGlzLmludmFsaWRhdGUocGF0aCwgbmV3IE1vbmdvb3NlRXJyb3IuQ2FzdEVycm9yKHNjaGVtYVR5cGUuaW5zdGFuY2UsIHZhbCwgcGF0aCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY29uc3QgY3VycmVudFZhbHVlID0gdGhpcy4kX19nZXRWYWx1ZShwYXRoKSB8fCAwO1xuICBsZXQgc2hvdWxkU2V0ID0gZmFsc2U7XG4gIGxldCB2YWxUb1NldCA9IG51bGw7XG4gIGxldCB2YWxUb0luYyA9IHZhbDtcblxuICB0cnkge1xuICAgIHZhbCA9IHNjaGVtYVR5cGUuY2FzdCh2YWwpO1xuICAgIHZhbFRvU2V0ID0gc2NoZW1hVHlwZS5hcHBseVNldHRlcnMoY3VycmVudFZhbHVlICsgdmFsLCB0aGlzKTtcbiAgICB2YWxUb0luYyA9IHZhbFRvU2V0IC0gY3VycmVudFZhbHVlO1xuICAgIHNob3VsZFNldCA9IHRydWU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMuaW52YWxpZGF0ZShwYXRoLCBuZXcgTW9uZ29vc2VFcnJvci5DYXN0RXJyb3IoJ251bWJlcicsIHZhbCwgcGF0aCwgZXJyKSk7XG4gIH1cblxuICBpZiAoc2hvdWxkU2V0KSB7XG4gICAgdGhpcy4kX18ucHJpbWl0aXZlQXRvbWljcyA9IHRoaXMuJF9fLnByaW1pdGl2ZUF0b21pY3MgfHwge307XG4gICAgaWYgKHRoaXMuJF9fLnByaW1pdGl2ZUF0b21pY3NbcGF0aF0gPT0gbnVsbCkge1xuICAgICAgdGhpcy4kX18ucHJpbWl0aXZlQXRvbWljc1twYXRoXSA9IHsgJGluYzogdmFsVG9JbmMgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4kX18ucHJpbWl0aXZlQXRvbWljc1twYXRoXS4kaW5jICs9IHZhbFRvSW5jO1xuICAgIH1cbiAgICB0aGlzLm1hcmtNb2RpZmllZChwYXRoKTtcbiAgICB0aGlzLiRfX3NldFZhbHVlKHBhdGgsIHZhbFRvU2V0KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIGEgcmF3IHZhbHVlIGZvciBhIHBhdGggKG5vIGNhc3RpbmcsIHNldHRlcnMsIHRyYW5zZm9ybWF0aW9ucylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAcmV0dXJuIHtEb2N1bWVudH0gdGhpc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRfX3NldFZhbHVlID0gZnVuY3Rpb24ocGF0aCwgdmFsKSB7XG4gIHV0aWxzLnNldFZhbHVlKHBhdGgsIHZhbCwgdGhpcy5fZG9jKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIG9mIGEgcGF0aC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIHBhdGhcbiAqICAgICBkb2MuZ2V0KCdhZ2UnKSAvLyA0N1xuICpcbiAqICAgICAvLyBkeW5hbWljIGNhc3RpbmcgdG8gYSBzdHJpbmdcbiAqICAgICBkb2MuZ2V0KCdhZ2UnLCBTdHJpbmcpIC8vIFwiNDdcIlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge1NjaGVtYXxTdHJpbmd8TnVtYmVyfEJ1ZmZlcnwqfSBbdHlwZV0gb3B0aW9uYWxseSBzcGVjaWZ5IGEgdHlwZSBmb3Igb24tdGhlLWZseSBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnZpcnR1YWxzPWZhbHNlXSBBcHBseSB2aXJ0dWFscyBiZWZvcmUgZ2V0dGluZyB0aGlzIHBhdGhcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZ2V0dGVycz10cnVlXSBJZiBmYWxzZSwgc2tpcCBhcHBseWluZyBnZXR0ZXJzIGFuZCBqdXN0IGdldCB0aGUgcmF3IHZhbHVlXG4gKiBAcmV0dXJuIHtBbnl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihwYXRoLCB0eXBlLCBvcHRpb25zKSB7XG4gIGxldCBhZGhvYztcbiAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBpZiAodHlwZSkge1xuICAgIGFkaG9jID0gdGhpcy4kX19zY2hlbWEuaW50ZXJwcmV0QXNUeXBlKHBhdGgsIHR5cGUsIHRoaXMuJF9fc2NoZW1hLm9wdGlvbnMpO1xuICB9XG4gIGNvbnN0IG5vRG90dGVkUGF0aCA9IG9wdGlvbnMubm9Eb3R0ZWRQYXRoO1xuXG4gIC8vIEZhc3QgcGF0aCBpZiB3ZSBrbm93IHdlJ3JlIGp1c3QgYWNjZXNzaW5nIHRvcC1sZXZlbCBwYXRoIG9uIHRoZSBkb2N1bWVudDpcbiAgLy8ganVzdCBnZXQgdGhlIHNjaGVtYSBwYXRoLCBhdm9pZCBgJF9fcGF0aCgpYCBiZWNhdXNlIHRoYXQgZG9lcyBzdHJpbmcgbWFuaXB1bGF0aW9uXG4gIGxldCBzY2hlbWEgPSBub0RvdHRlZFBhdGggPyB0aGlzLiRfX3NjaGVtYS5wYXRoc1twYXRoXSA6IHRoaXMuJF9fcGF0aChwYXRoKTtcbiAgaWYgKHNjaGVtYSA9PSBudWxsKSB7XG4gICAgc2NoZW1hID0gdGhpcy4kX19zY2hlbWEudmlydHVhbHBhdGgocGF0aCk7XG5cbiAgICBpZiAoc2NoZW1hICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBzY2hlbWEuYXBwbHlHZXR0ZXJzKHZvaWQgMCwgdGhpcyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG5vRG90dGVkUGF0aCkge1xuICAgIGxldCBvYmogPSB0aGlzLl9kb2NbcGF0aF07XG4gICAgaWYgKGFkaG9jKSB7XG4gICAgICBvYmogPSBhZGhvYy5jYXN0KG9iaik7XG4gICAgfVxuICAgIGlmIChzY2hlbWEgIT0gbnVsbCAmJiBvcHRpb25zLmdldHRlcnMgIT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gc2NoZW1hLmFwcGx5R2V0dGVycyhvYmosIHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgaWYgKHNjaGVtYSAhPSBudWxsICYmIHNjaGVtYS5pbnN0YW5jZSA9PT0gJ01peGVkJykge1xuICAgIGNvbnN0IHZpcnR1YWwgPSB0aGlzLiRfX3NjaGVtYS52aXJ0dWFscGF0aChwYXRoKTtcbiAgICBpZiAodmlydHVhbCAhPSBudWxsKSB7XG4gICAgICBzY2hlbWEgPSB2aXJ0dWFsO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGhhc0RvdCA9IHBhdGguaW5kZXhPZignLicpICE9PSAtMTtcbiAgbGV0IG9iaiA9IHRoaXMuX2RvYztcblxuICBjb25zdCBwaWVjZXMgPSBoYXNEb3QgPyBwYXRoLnNwbGl0KCcuJykgOiBbcGF0aF07XG4gIC8vIE1pZ2h0IG5lZWQgdG8gY2hhbmdlIHBhdGggZm9yIHRvcC1sZXZlbCBhbGlhc1xuICBpZiAodHlwZW9mIHRoaXMuJF9fc2NoZW1hLmFsaWFzZXNbcGllY2VzWzBdXSA9PT0gJ3N0cmluZycpIHtcbiAgICBwaWVjZXNbMF0gPSB0aGlzLiRfX3NjaGVtYS5hbGlhc2VzW3BpZWNlc1swXV07XG4gIH1cblxuICBmb3IgKGxldCBpID0gMCwgbCA9IHBpZWNlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAob2JqICYmIG9iai5fZG9jKSB7XG4gICAgICBvYmogPSBvYmouX2RvYztcbiAgICB9XG5cbiAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgIG9iaiA9IHZvaWQgMDtcbiAgICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgb2JqID0gb2JqLmdldChwaWVjZXNbaV0sIHsgZ2V0dGVyczogZmFsc2UgfSk7XG4gICAgfSBlbHNlIGlmIChpID09PSBsIC0gMSkge1xuICAgICAgb2JqID0gdXRpbHMuZ2V0VmFsdWUocGllY2VzW2ldLCBvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmogPSBvYmpbcGllY2VzW2ldXTtcbiAgICB9XG4gIH1cblxuICBpZiAoYWRob2MpIHtcbiAgICBvYmogPSBhZGhvYy5jYXN0KG9iaik7XG4gIH1cblxuICBpZiAoc2NoZW1hICE9IG51bGwgJiYgb3B0aW9ucy5nZXR0ZXJzICE9PSBmYWxzZSkge1xuICAgIG9iaiA9IHNjaGVtYS5hcHBseUdldHRlcnMob2JqLCB0aGlzKTtcbiAgfSBlbHNlIGlmICh0aGlzLiRfX3NjaGVtYS5uZXN0ZWRbcGF0aF0gJiYgb3B0aW9ucy52aXJ0dWFscykge1xuICAgIC8vIE1pZ2h0IG5lZWQgdG8gYXBwbHkgdmlydHVhbHMgaWYgdGhpcyBpcyBhIG5lc3RlZCBwYXRoXG4gICAgcmV0dXJuIGFwcGx5VmlydHVhbHModGhpcywgY2xvbmUob2JqKSB8fCB7fSwgeyBwYXRoOiBwYXRoIH0pO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlW2dldFN5bWJvbF0gPSBEb2N1bWVudC5wcm90b3R5cGUuZ2V0O1xuRG9jdW1lbnQucHJvdG90eXBlLiRnZXQgPSBEb2N1bWVudC5wcm90b3R5cGUuZ2V0O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHNjaGVtYXR5cGUgZm9yIHRoZSBnaXZlbiBgcGF0aGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm4ge1NjaGVtYVBhdGh9XG4gKiBAYXBpIHByaXZhdGVcbiAqIEBtZXRob2QgJF9fcGF0aFxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJF9fcGF0aCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgY29uc3QgYWRob2NzID0gdGhpcy4kX18uYWRob2NQYXRocztcbiAgY29uc3QgYWRob2NUeXBlID0gYWRob2NzICYmIGFkaG9jcy5oYXNPd25Qcm9wZXJ0eShwYXRoKSA/IGFkaG9jc1twYXRoXSA6IG51bGw7XG5cbiAgaWYgKGFkaG9jVHlwZSkge1xuICAgIHJldHVybiBhZGhvY1R5cGU7XG4gIH1cbiAgcmV0dXJuIHRoaXMuJF9fc2NoZW1hLnBhdGgocGF0aCk7XG59O1xuXG4vKipcbiAqIE1hcmtzIHRoZSBwYXRoIGFzIGhhdmluZyBwZW5kaW5nIGNoYW5nZXMgdG8gd3JpdGUgdG8gdGhlIGRiLlxuICpcbiAqIF9WZXJ5IGhlbHBmdWwgd2hlbiB1c2luZyBbTWl4ZWRdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zY2hlbWF0eXBlcy5odG1sI21peGVkKSB0eXBlcy5fXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBkb2MubWl4ZWQudHlwZSA9ICdjaGFuZ2VkJztcbiAqICAgICBkb2MubWFya01vZGlmaWVkKCdtaXhlZC50eXBlJyk7XG4gKiAgICAgZG9jLnNhdmUoKSAvLyBjaGFuZ2VzIHRvIG1peGVkLnR5cGUgYXJlIG5vdyBwZXJzaXN0ZWRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0aGUgcGF0aCB0byBtYXJrIG1vZGlmaWVkXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBbc2NvcGVdIHRoZSBzY29wZSB0byBydW4gdmFsaWRhdG9ycyB3aXRoXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS5tYXJrTW9kaWZpZWQgPSBmdW5jdGlvbihwYXRoLCBzY29wZSkge1xuICB0aGlzLiRfX3NhdmVJbml0aWFsU3RhdGUocGF0aCk7XG5cbiAgdGhpcy4kX18uYWN0aXZlUGF0aHMubW9kaWZ5KHBhdGgpO1xuICBpZiAoc2NvcGUgIT0gbnVsbCAmJiAhdGhpcy4kaXNTdWJkb2N1bWVudCkge1xuICAgIHRoaXMuJF9fLnBhdGhzVG9TY29wZXMgPSB0aGlzLiRfX3BhdGhzVG9TY29wZXMgfHwge307XG4gICAgdGhpcy4kX18ucGF0aHNUb1Njb3Blc1twYXRoXSA9IHNjb3BlO1xuICB9XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kX19zYXZlSW5pdGlhbFN0YXRlID0gZnVuY3Rpb24gJF9fc2F2ZUluaXRpYWxTdGF0ZShwYXRoKSB7XG4gIGNvbnN0IHNhdmVkU3RhdGUgPSB0aGlzLiRfXy5zYXZlZFN0YXRlO1xuICBjb25zdCBzYXZlZFN0YXRlUGF0aCA9IHBhdGg7XG4gIGlmIChzYXZlZFN0YXRlICE9IG51bGwpIHtcbiAgICBjb25zdCBmaXJzdERvdCA9IHNhdmVkU3RhdGVQYXRoLmluZGV4T2YoJy4nKTtcbiAgICBjb25zdCB0b3BMZXZlbFBhdGggPSBmaXJzdERvdCA9PT0gLTEgPyBzYXZlZFN0YXRlUGF0aCA6IHNhdmVkU3RhdGVQYXRoLnNsaWNlKDAsIGZpcnN0RG90KTtcbiAgICBpZiAoIXNhdmVkU3RhdGUuaGFzT3duUHJvcGVydHkodG9wTGV2ZWxQYXRoKSkge1xuICAgICAgc2F2ZWRTdGF0ZVt0b3BMZXZlbFBhdGhdID0gY2xvbmUodGhpcy4kX19nZXRWYWx1ZSh0b3BMZXZlbFBhdGgpKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYXJzIHRoZSBtb2RpZmllZCBzdGF0ZSBvbiB0aGUgc3BlY2lmaWVkIHBhdGguXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBkb2MuZm9vID0gJ2Jhcic7XG4gKiAgICAgZG9jLnVubWFya01vZGlmaWVkKCdmb28nKTtcbiAqICAgICBkb2Muc2F2ZSgpOyAvLyBjaGFuZ2VzIHRvIGZvbyB3aWxsIG5vdCBiZSBwZXJzaXN0ZWRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0aGUgcGF0aCB0byB1bm1hcmsgbW9kaWZpZWRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLnVubWFya01vZGlmaWVkID0gZnVuY3Rpb24ocGF0aCkge1xuICB0aGlzLiRfXy5hY3RpdmVQYXRocy5pbml0KHBhdGgpO1xuICBpZiAodGhpcy4kX18ucGF0aHNUb1Njb3BlcyAhPSBudWxsKSB7XG4gICAgZGVsZXRlIHRoaXMuJF9fLnBhdGhzVG9TY29wZXNbcGF0aF07XG4gIH1cbn07XG5cbi8qKlxuICogRG9uJ3QgcnVuIHZhbGlkYXRpb24gb24gdGhpcyBwYXRoIG9yIHBlcnNpc3QgY2hhbmdlcyB0byB0aGlzIHBhdGguXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBkb2MuZm9vID0gbnVsbDtcbiAqICAgICBkb2MuJGlnbm9yZSgnZm9vJyk7XG4gKiAgICAgZG9jLnNhdmUoKTsgLy8gY2hhbmdlcyB0byBmb28gd2lsbCBub3QgYmUgcGVyc2lzdGVkIGFuZCB2YWxpZGF0b3JzIHdvbid0IGJlIHJ1blxuICpcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKiBAbWV0aG9kICRpZ25vcmVcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRoZSBwYXRoIHRvIGlnbm9yZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJGlnbm9yZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdGhpcy4kX18uYWN0aXZlUGF0aHMuaWdub3JlKHBhdGgpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsaXN0IG9mIHBhdGhzIHRoYXQgaGF2ZSBiZWVuIGRpcmVjdGx5IG1vZGlmaWVkLiBBIGRpcmVjdFxuICogbW9kaWZpZWQgcGF0aCBpcyBhIHBhdGggdGhhdCB5b3UgZXhwbGljaXRseSBzZXQsIHdoZXRoZXIgdmlhIGBkb2MuZm9vID0gJ2JhcidgLFxuICogYE9iamVjdC5hc3NpZ24oZG9jLCB7IGZvbzogJ2JhcicgfSlgLCBvciBgZG9jLnNldCgnZm9vJywgJ2JhcicpYC5cbiAqXG4gKiBBIHBhdGggYGFgIG1heSBiZSBpbiBgbW9kaWZpZWRQYXRocygpYCBidXQgbm90IGluIGBkaXJlY3RNb2RpZmllZFBhdGhzKClgXG4gKiBiZWNhdXNlIGEgY2hpbGQgb2YgYGFgIHdhcyBkaXJlY3RseSBtb2RpZmllZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBmb286IFN0cmluZywgbmVzdGVkOiB7IGJhcjogU3RyaW5nIH0gfSk7XG4gKiAgICAgY29uc3QgTW9kZWwgPSBtb25nb29zZS5tb2RlbCgnVGVzdCcsIHNjaGVtYSk7XG4gKiAgICAgYXdhaXQgTW9kZWwuY3JlYXRlKHsgZm9vOiAnb3JpZ2luYWwnLCBuZXN0ZWQ6IHsgYmFyOiAnb3JpZ2luYWwnIH0gfSk7XG4gKlxuICogICAgIGNvbnN0IGRvYyA9IGF3YWl0IE1vZGVsLmZpbmRPbmUoKTtcbiAqICAgICBkb2MubmVzdGVkLmJhciA9ICdtb2RpZmllZCc7XG4gKiAgICAgZG9jLmRpcmVjdE1vZGlmaWVkUGF0aHMoKTsgLy8gWyduZXN0ZWQuYmFyJ11cbiAqICAgICBkb2MubW9kaWZpZWRQYXRocygpOyAvLyBbJ25lc3RlZCcsICduZXN0ZWQuYmFyJ11cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmdbXX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLmRpcmVjdE1vZGlmaWVkUGF0aHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuJF9fLmFjdGl2ZVBhdGhzLmdldFN0YXRlUGF0aHMoJ21vZGlmeScpKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBwYXRoIGlzIG51bGxpc2ggb3Igb25seSBjb250YWlucyBlbXB0eSBvYmplY3RzLlxuICogVXNlZnVsIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRoaXMgc3ViZG9jIHdpbGwgZ2V0IHN0cmlwcGVkIG91dCBieSB0aGVcbiAqIFttaW5pbWl6ZSBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI21pbmltaXplKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuZXN0ZWQ6IHsgZm9vOiBTdHJpbmcgfSB9KTtcbiAqICAgICBjb25zdCBNb2RlbCA9IG1vbmdvb3NlLm1vZGVsKCdUZXN0Jywgc2NoZW1hKTtcbiAqICAgICBjb25zdCBkb2MgPSBuZXcgTW9kZWwoe30pO1xuICogICAgIGRvYy4kaXNFbXB0eSgnbmVzdGVkJyk7IC8vIHRydWVcbiAqICAgICBkb2MubmVzdGVkLiRpc0VtcHR5KCk7IC8vIHRydWVcbiAqXG4gKiAgICAgZG9jLm5lc3RlZC5mb28gPSAnYmFyJztcbiAqICAgICBkb2MuJGlzRW1wdHkoJ25lc3RlZCcpOyAvLyBmYWxzZVxuICogICAgIGRvYy5uZXN0ZWQuJGlzRW1wdHkoKTsgLy8gZmFsc2VcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgJGlzRW1wdHlcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRpc0VtcHR5ID0gZnVuY3Rpb24ocGF0aCkge1xuICBjb25zdCBpc0VtcHR5T3B0aW9ucyA9IHtcbiAgICBtaW5pbWl6ZTogdHJ1ZSxcbiAgICB2aXJ0dWFsczogZmFsc2UsXG4gICAgZ2V0dGVyczogZmFsc2UsXG4gICAgdHJhbnNmb3JtOiBmYWxzZVxuICB9O1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAwKSB7XG4gICAgY29uc3QgdiA9IHRoaXMuJGdldChwYXRoKTtcbiAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2ICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNQT0pPKHYpKSB7XG4gICAgICByZXR1cm4gX2lzRW1wdHkodik7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyh2LnRvT2JqZWN0KGlzRW1wdHlPcHRpb25zKSkubGVuZ3RoID09PSAwO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMudG9PYmplY3QoaXNFbXB0eU9wdGlvbnMpKS5sZW5ndGggPT09IDA7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9pc0VtcHR5KHYpIHtcbiAgaWYgKHYgPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh0eXBlb2YgdiAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheSh2KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh2KSkge1xuICAgIGlmICghX2lzRW1wdHkodltrZXldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsaXN0IG9mIHBhdGhzIHRoYXQgaGF2ZSBiZWVuIG1vZGlmaWVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaW5jbHVkZUNoaWxkcmVuPWZhbHNlXSBpZiB0cnVlLCByZXR1cm5zIGNoaWxkcmVuIG9mIG1vZGlmaWVkIHBhdGhzIGFzIHdlbGwuIEZvciBleGFtcGxlLCBpZiBmYWxzZSwgdGhlIGxpc3Qgb2YgbW9kaWZpZWQgcGF0aHMgZm9yIGBkb2MuY29sb3JzID0geyBwcmltYXJ5OiAnYmx1ZScgfTtgIHdpbGwgKipub3QqKiBjb250YWluIGBjb2xvcnMucHJpbWFyeWAuIElmIHRydWUsIGBtb2RpZmllZFBhdGhzKClgIHdpbGwgcmV0dXJuIGFuIGFycmF5IHRoYXQgY29udGFpbnMgYGNvbG9ycy5wcmltYXJ5YC5cbiAqIEByZXR1cm4ge1N0cmluZ1tdfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUubW9kaWZpZWRQYXRocyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgY29uc3QgZGlyZWN0TW9kaWZpZWRQYXRocyA9IE9iamVjdC5rZXlzKHRoaXMuJF9fLmFjdGl2ZVBhdGhzLmdldFN0YXRlUGF0aHMoJ21vZGlmeScpKTtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IFNldCgpO1xuXG4gIGxldCBpID0gMDtcbiAgbGV0IGogPSAwO1xuICBjb25zdCBsZW4gPSBkaXJlY3RNb2RpZmllZFBhdGhzLmxlbmd0aDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBjb25zdCBwYXRoID0gZGlyZWN0TW9kaWZpZWRQYXRoc1tpXTtcbiAgICBjb25zdCBwYXJ0cyA9IHBhcmVudFBhdGhzKHBhdGgpO1xuICAgIGNvbnN0IHBMZW4gPSBwYXJ0cy5sZW5ndGg7XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgcExlbjsgKytqKSB7XG4gICAgICByZXN1bHQuYWRkKHBhcnRzW2pdKTtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMuaW5jbHVkZUNoaWxkcmVuKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBsZXQgaWkgPSAwO1xuICAgIGxldCBjdXIgPSB0aGlzLiRnZXQocGF0aCk7XG4gICAgaWYgKHR5cGVvZiBjdXIgPT09ICdvYmplY3QnICYmIGN1ciAhPT0gbnVsbCkge1xuICAgICAgaWYgKGN1ci5fZG9jKSB7XG4gICAgICAgIGN1ciA9IGN1ci5fZG9jO1xuICAgICAgfVxuICAgICAgY29uc3QgbGVuID0gY3VyLmxlbmd0aDtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1cikpIHtcbiAgICAgICAgZm9yIChpaSA9IDA7IGlpIDwgbGVuOyArK2lpKSB7XG4gICAgICAgICAgY29uc3Qgc3ViUGF0aCA9IHBhdGggKyAnLicgKyBpaTtcbiAgICAgICAgICBpZiAoIXJlc3VsdC5oYXMoc3ViUGF0aCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hZGQoc3ViUGF0aCk7XG4gICAgICAgICAgICBpZiAoY3VyW2lpXSAhPSBudWxsICYmIGN1cltpaV0uJF9fKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkID0gY3VyW2lpXS5tb2RpZmllZFBhdGhzKCk7XG4gICAgICAgICAgICAgIGxldCBpaWkgPSAwO1xuICAgICAgICAgICAgICBjb25zdCBpaWlMZW4gPSBtb2RpZmllZC5sZW5ndGg7XG4gICAgICAgICAgICAgIGZvciAoaWlpID0gMDsgaWlpIDwgaWlpTGVuOyArK2lpaSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQoc3ViUGF0aCArICcuJyArIG1vZGlmaWVkW2lpaV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoY3VyKTtcbiAgICAgICAgbGV0IGlpID0gMDtcbiAgICAgICAgY29uc3QgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGZvciAoaWkgPSAwOyBpaSA8IGxlbjsgKytpaSkge1xuICAgICAgICAgIHJlc3VsdC5hZGQocGF0aCArICcuJyArIGtleXNbaWldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbShyZXN1bHQpO1xufTtcblxuRG9jdW1lbnQucHJvdG90eXBlW2RvY3VtZW50TW9kaWZpZWRQYXRoc10gPSBEb2N1bWVudC5wcm90b3R5cGUubW9kaWZpZWRQYXRocztcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYW55IG9mIHRoZSBnaXZlbiBwYXRocyBpcyBtb2RpZmllZCwgZWxzZSBmYWxzZS4gSWYgbm8gYXJndW1lbnRzLCByZXR1cm5zIGB0cnVlYCBpZiBhbnkgcGF0aFxuICogaW4gdGhpcyBkb2N1bWVudCBpcyBtb2RpZmllZC5cbiAqXG4gKiBJZiBgcGF0aGAgaXMgZ2l2ZW4sIGNoZWNrcyBpZiBhIHBhdGggb3IgYW55IGZ1bGwgcGF0aCBjb250YWluaW5nIGBwYXRoYCBhcyBwYXJ0IG9mIGl0cyBwYXRoIGNoYWluIGhhcyBiZWVuIG1vZGlmaWVkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgZG9jLnNldCgnZG9jdW1lbnRzLjAudGl0bGUnLCAnY2hhbmdlZCcpO1xuICogICAgIGRvYy5pc01vZGlmaWVkKCkgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZVxuICogICAgIGRvYy5pc01vZGlmaWVkKCdkb2N1bWVudHMnKSAgICAgICAgICAgLy8gdHJ1ZVxuICogICAgIGRvYy5pc01vZGlmaWVkKCdkb2N1bWVudHMuMC50aXRsZScpICAgLy8gdHJ1ZVxuICogICAgIGRvYy5pc01vZGlmaWVkKCdkb2N1bWVudHMgb3RoZXJQcm9wJykgLy8gdHJ1ZVxuICogICAgIGRvYy5pc0RpcmVjdE1vZGlmaWVkKCdkb2N1bWVudHMnKSAgICAgLy8gZmFsc2VcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdIG9wdGlvbmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmlnbm9yZUF0b21pY3M9ZmFsc2VdIElmIHRydWUsIGRvZXNuJ3QgcmV0dXJuIHRydWUgaWYgcGF0aCBpcyB1bmRlcm5lYXRoIGFuIGFycmF5IHRoYXQgd2FzIG1vZGlmaWVkIHdpdGggYXRvbWljIG9wZXJhdGlvbnMgbGlrZSBgcHVzaCgpYFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLmlzTW9kaWZpZWQgPSBmdW5jdGlvbihwYXRocywgb3B0aW9ucywgbW9kaWZpZWRQYXRocykge1xuICBpZiAocGF0aHMpIHtcbiAgICBjb25zdCBpZ25vcmVBdG9taWNzID0gb3B0aW9ucyAmJiBvcHRpb25zLmlnbm9yZUF0b21pY3M7XG4gICAgY29uc3QgZGlyZWN0TW9kaWZpZWRQYXRoc09iaiA9IHRoaXMuJF9fLmFjdGl2ZVBhdGhzLnN0YXRlcy5tb2RpZnk7XG4gICAgaWYgKGRpcmVjdE1vZGlmaWVkUGF0aHNPYmogPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcGF0aHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBwYXRocyA9IHBhdGhzLmluZGV4T2YoJyAnKSA9PT0gLTEgPyBbcGF0aHNdIDogcGF0aHMuc3BsaXQoJyAnKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICAgIGlmIChkaXJlY3RNb2RpZmllZFBhdGhzT2JqW3BhdGhdICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbW9kaWZpZWQgPSBtb2RpZmllZFBhdGhzIHx8IHRoaXNbZG9jdW1lbnRNb2RpZmllZFBhdGhzXSgpO1xuICAgIGNvbnN0IGlzTW9kaWZpZWRDaGlsZCA9IHBhdGhzLnNvbWUoZnVuY3Rpb24ocGF0aCkge1xuICAgICAgcmV0dXJuICEhfm1vZGlmaWVkLmluZGV4T2YocGF0aCk7XG4gICAgfSk7XG5cbiAgICBsZXQgZGlyZWN0TW9kaWZpZWRQYXRocyA9IE9iamVjdC5rZXlzKGRpcmVjdE1vZGlmaWVkUGF0aHNPYmopO1xuICAgIGlmIChpZ25vcmVBdG9taWNzKSB7XG4gICAgICBkaXJlY3RNb2RpZmllZFBhdGhzID0gZGlyZWN0TW9kaWZpZWRQYXRocy5maWx0ZXIocGF0aCA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4kX19nZXRWYWx1ZShwYXRoKTtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdmFsdWVbYXJyYXlBdG9taWNzU3ltYm9sXSAhPSBudWxsICYmIHZhbHVlW2FycmF5QXRvbWljc1N5bWJvbF0uJHNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBpc01vZGlmaWVkQ2hpbGQgfHwgcGF0aHMuc29tZShmdW5jdGlvbihwYXRoKSB7XG4gICAgICByZXR1cm4gZGlyZWN0TW9kaWZpZWRQYXRocy5zb21lKGZ1bmN0aW9uKG1vZCkge1xuICAgICAgICByZXR1cm4gbW9kID09PSBwYXRoIHx8IHBhdGguc3RhcnRzV2l0aChtb2QgKyAnLicpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGhpcy4kX18uYWN0aXZlUGF0aHMuc29tZSgnbW9kaWZ5Jyk7XG59O1xuXG4vKipcbiAqIEFsaWFzIG9mIFtgLmlzTW9kaWZpZWRgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLmlzTW9kaWZpZWQoKSlcbiAqXG4gKiBAbWV0aG9kICRpc01vZGlmaWVkXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRpc01vZGlmaWVkID0gRG9jdW1lbnQucHJvdG90eXBlLmlzTW9kaWZpZWQ7XG5cbkRvY3VtZW50LnByb3RvdHlwZVtkb2N1bWVudElzTW9kaWZpZWRdID0gRG9jdW1lbnQucHJvdG90eXBlLmlzTW9kaWZpZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgcGF0aCBpcyBzZXQgdG8gaXRzIGRlZmF1bHQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBNeU1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ3Rlc3QnLCB7IG5hbWU6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0OiAnVmFsICd9IH0pO1xuICogICAgIGNvbnN0IG0gPSBuZXcgTXlNb2RlbCgpO1xuICogICAgIG0uJGlzRGVmYXVsdCgnbmFtZScpOyAvLyB0cnVlXG4gKlxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqIEBtZXRob2QgJGlzRGVmYXVsdFxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRpc0RlZmF1bHQgPSBmdW5jdGlvbihwYXRoKSB7XG4gIGlmIChwYXRoID09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy4kX18uYWN0aXZlUGF0aHMuc29tZSgnZGVmYXVsdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJyAmJiBwYXRoLmluZGV4T2YoJyAnKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gdGhpcy4kX18uYWN0aXZlUGF0aHMuZ2V0U3RhdGVQYXRocygnZGVmYXVsdCcpLmhhc093blByb3BlcnR5KHBhdGgpO1xuICB9XG5cbiAgbGV0IHBhdGhzID0gcGF0aDtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGhzKSkge1xuICAgIHBhdGhzID0gcGF0aHMuc3BsaXQoJyAnKTtcbiAgfVxuXG4gIHJldHVybiBwYXRocy5zb21lKHBhdGggPT4gdGhpcy4kX18uYWN0aXZlUGF0aHMuZ2V0U3RhdGVQYXRocygnZGVmYXVsdCcpLmhhc093blByb3BlcnR5KHBhdGgpKTtcbn07XG5cbi8qKlxuICogR2V0dGVyL3NldHRlciwgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBkb2N1bWVudCB3YXMgcmVtb3ZlZCBvciBub3QuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBwcm9kdWN0ID0gYXdhaXQgcHJvZHVjdC5yZW1vdmUoKTtcbiAqICAgICBwcm9kdWN0LiRpc0RlbGV0ZWQoKTsgLy8gdHJ1ZVxuICogICAgIHByb2R1Y3QucmVtb3ZlKCk7IC8vIG5vLW9wLCBkb2Vzbid0IHNlbmQgYW55dGhpbmcgdG8gdGhlIGRiXG4gKlxuICogICAgIHByb2R1Y3QuJGlzRGVsZXRlZChmYWxzZSk7XG4gKiAgICAgcHJvZHVjdC4kaXNEZWxldGVkKCk7IC8vIGZhbHNlXG4gKiAgICAgcHJvZHVjdC5yZW1vdmUoKTsgLy8gd2lsbCBleGVjdXRlIGEgcmVtb3ZlIGFnYWluc3QgdGhlIGRiXG4gKlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3ZhbF0gb3B0aW9uYWwsIG92ZXJyaWRlcyB3aGV0aGVyIG1vbmdvb3NlIHRoaW5rcyB0aGUgZG9jIGlzIGRlbGV0ZWRcbiAqIEByZXR1cm4ge0Jvb2xlYW58RG9jdW1lbnR9IHdoZXRoZXIgbW9uZ29vc2UgdGhpbmtzIHRoaXMgZG9jIGlzIGRlbGV0ZWQuXG4gKiBAbWV0aG9kICRpc0RlbGV0ZWRcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kaXNEZWxldGVkID0gZnVuY3Rpb24odmFsKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICEhdGhpcy4kX18uaXNEZWxldGVkO1xuICB9XG5cbiAgdGhpcy4kX18uaXNEZWxldGVkID0gISF2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYHBhdGhgIHdhcyBkaXJlY3RseSBzZXQgYW5kIG1vZGlmaWVkLCBlbHNlIGZhbHNlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgZG9jLnNldCgnZG9jdW1lbnRzLjAudGl0bGUnLCAnY2hhbmdlZCcpO1xuICogICAgIGRvYy5pc0RpcmVjdE1vZGlmaWVkKCdkb2N1bWVudHMuMC50aXRsZScpIC8vIHRydWVcbiAqICAgICBkb2MuaXNEaXJlY3RNb2RpZmllZCgnZG9jdW1lbnRzJykgLy8gZmFsc2VcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xTdHJpbmdbXX0gW3BhdGhdXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuaXNEaXJlY3RNb2RpZmllZCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLiRfXy5hY3RpdmVQYXRocy5zb21lKCdtb2RpZnknKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycgJiYgcGF0aC5pbmRleE9mKCcgJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIHRoaXMuJF9fLmFjdGl2ZVBhdGhzLmdldFN0YXRlUGF0aHMoJ21vZGlmeScpLmhhc093blByb3BlcnR5KHBhdGgpO1xuICB9XG5cbiAgbGV0IHBhdGhzID0gcGF0aDtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGhzKSkge1xuICAgIHBhdGhzID0gcGF0aHMuc3BsaXQoJyAnKTtcbiAgfVxuXG4gIHJldHVybiBwYXRocy5zb21lKHBhdGggPT4gdGhpcy4kX18uYWN0aXZlUGF0aHMuZ2V0U3RhdGVQYXRocygnbW9kaWZ5JykuaGFzT3duUHJvcGVydHkocGF0aCkpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGluIHRoZSBgaW5pdGAgc3RhdGUsIHRoYXQgaXMsIGl0IHdhcyBzZXQgYnkgYERvY3VtZW50I2luaXQoKWAgYW5kIG5vdCBtb2RpZmllZCBzaW5jZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuaXNJbml0ID0gZnVuY3Rpb24ocGF0aCkge1xuICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuJF9fLmFjdGl2ZVBhdGhzLnNvbWUoJ2luaXQnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycgJiYgcGF0aC5pbmRleE9mKCcgJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIHRoaXMuJF9fLmFjdGl2ZVBhdGhzLmdldFN0YXRlUGF0aHMoJ2luaXQnKS5oYXNPd25Qcm9wZXJ0eShwYXRoKTtcbiAgfVxuXG4gIGxldCBwYXRocyA9IHBhdGg7XG4gIGlmICghQXJyYXkuaXNBcnJheShwYXRocykpIHtcbiAgICBwYXRocyA9IHBhdGhzLnNwbGl0KCcgJyk7XG4gIH1cblxuICByZXR1cm4gcGF0aHMuc29tZShwYXRoID0+IHRoaXMuJF9fLmFjdGl2ZVBhdGhzLmdldFN0YXRlUGF0aHMoJ2luaXQnKS5oYXNPd25Qcm9wZXJ0eShwYXRoKSk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgd2FzIHNlbGVjdGVkIGluIHRoZSBzb3VyY2UgcXVlcnkgd2hpY2ggaW5pdGlhbGl6ZWQgdGhpcyBkb2N1bWVudC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGRvYyA9IGF3YWl0IFRoaW5nLmZpbmRPbmUoKS5zZWxlY3QoJ25hbWUnKTtcbiAqICAgICBkb2MuaXNTZWxlY3RlZCgnbmFtZScpIC8vIHRydWVcbiAqICAgICBkb2MuaXNTZWxlY3RlZCgnYWdlJykgIC8vIGZhbHNlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW119IHBhdGhcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS5pc1NlbGVjdGVkID0gZnVuY3Rpb24gaXNTZWxlY3RlZChwYXRoKSB7XG4gIGlmICh0aGlzLiRfXy5zZWxlY3RlZCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCFwYXRoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChwYXRoID09PSAnX2lkJykge1xuICAgIHJldHVybiB0aGlzLiRfXy5zZWxlY3RlZC5faWQgIT09IDA7XG4gIH1cblxuICBpZiAocGF0aC5pbmRleE9mKCcgJykgIT09IC0xKSB7XG4gICAgcGF0aCA9IHBhdGguc3BsaXQoJyAnKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgIHJldHVybiBwYXRoLnNvbWUocCA9PiB0aGlzLiRfX2lzU2VsZWN0ZWQocCkpO1xuICB9XG5cbiAgY29uc3QgcGF0aHMgPSBPYmplY3Qua2V5cyh0aGlzLiRfXy5zZWxlY3RlZCk7XG4gIGxldCBpbmNsdXNpdmUgPSBudWxsO1xuXG4gIGlmIChwYXRocy5sZW5ndGggPT09IDEgJiYgcGF0aHNbMF0gPT09ICdfaWQnKSB7XG4gICAgLy8gb25seSBfaWQgd2FzIHNlbGVjdGVkLlxuICAgIHJldHVybiB0aGlzLiRfXy5zZWxlY3RlZC5faWQgPT09IDA7XG4gIH1cblxuICBmb3IgKGNvbnN0IGN1ciBvZiBwYXRocykge1xuICAgIGlmIChjdXIgPT09ICdfaWQnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCFpc0RlZmluaW5nUHJvamVjdGlvbih0aGlzLiRfXy5zZWxlY3RlZFtjdXJdKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGluY2x1c2l2ZSA9ICEhdGhpcy4kX18uc2VsZWN0ZWRbY3VyXTtcbiAgICBicmVhaztcbiAgfVxuXG4gIGlmIChpbmNsdXNpdmUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChwYXRoIGluIHRoaXMuJF9fLnNlbGVjdGVkKSB7XG4gICAgcmV0dXJuIGluY2x1c2l2ZTtcbiAgfVxuXG4gIGNvbnN0IHBhdGhEb3QgPSBwYXRoICsgJy4nO1xuXG4gIGZvciAoY29uc3QgY3VyIG9mIHBhdGhzKSB7XG4gICAgaWYgKGN1ciA9PT0gJ19pZCcpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChjdXIuc3RhcnRzV2l0aChwYXRoRG90KSkge1xuICAgICAgcmV0dXJuIGluY2x1c2l2ZSB8fCBjdXIgIT09IHBhdGhEb3Q7XG4gICAgfVxuXG4gICAgaWYgKHBhdGhEb3Quc3RhcnRzV2l0aChjdXIgKyAnLicpKSB7XG4gICAgICByZXR1cm4gaW5jbHVzaXZlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gIWluY2x1c2l2ZTtcbn07XG5cbkRvY3VtZW50LnByb3RvdHlwZS4kX19pc1NlbGVjdGVkID0gRG9jdW1lbnQucHJvdG90eXBlLmlzU2VsZWN0ZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCB3YXMgZXhwbGljaXRseSBzZWxlY3RlZC4gSWYgbm8gcHJvamVjdGlvbiwgYWx3YXlzIHJldHVybnNcbiAqIHRydWUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBUaGluZy5maW5kT25lKCkuc2VsZWN0KCduZXN0ZWQubmFtZScpLmV4ZWMoZnVuY3Rpb24gKGVyciwgZG9jKSB7XG4gKiAgICAgICAgZG9jLmlzRGlyZWN0U2VsZWN0ZWQoJ25lc3RlZC5uYW1lJykgLy8gdHJ1ZVxuICogICAgICAgIGRvYy5pc0RpcmVjdFNlbGVjdGVkKCduZXN0ZWQub3RoZXJOYW1lJykgLy8gZmFsc2VcbiAqICAgICAgICBkb2MuaXNEaXJlY3RTZWxlY3RlZCgnbmVzdGVkJykgIC8vIGZhbHNlXG4gKiAgICAgfSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLmlzRGlyZWN0U2VsZWN0ZWQgPSBmdW5jdGlvbiBpc0RpcmVjdFNlbGVjdGVkKHBhdGgpIHtcbiAgaWYgKHRoaXMuJF9fLnNlbGVjdGVkID09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChwYXRoID09PSAnX2lkJykge1xuICAgIHJldHVybiB0aGlzLiRfXy5zZWxlY3RlZC5faWQgIT09IDA7XG4gIH1cblxuICBpZiAocGF0aC5pbmRleE9mKCcgJykgIT09IC0xKSB7XG4gICAgcGF0aCA9IHBhdGguc3BsaXQoJyAnKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgIHJldHVybiBwYXRoLnNvbWUocCA9PiB0aGlzLmlzRGlyZWN0U2VsZWN0ZWQocCkpO1xuICB9XG5cbiAgY29uc3QgcGF0aHMgPSBPYmplY3Qua2V5cyh0aGlzLiRfXy5zZWxlY3RlZCk7XG4gIGxldCBpbmNsdXNpdmUgPSBudWxsO1xuXG4gIGlmIChwYXRocy5sZW5ndGggPT09IDEgJiYgcGF0aHNbMF0gPT09ICdfaWQnKSB7XG4gICAgLy8gb25seSBfaWQgd2FzIHNlbGVjdGVkLlxuICAgIHJldHVybiB0aGlzLiRfXy5zZWxlY3RlZC5faWQgPT09IDA7XG4gIH1cblxuICBmb3IgKGNvbnN0IGN1ciBvZiBwYXRocykge1xuICAgIGlmIChjdXIgPT09ICdfaWQnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCFpc0RlZmluaW5nUHJvamVjdGlvbih0aGlzLiRfXy5zZWxlY3RlZFtjdXJdKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGluY2x1c2l2ZSA9ICEhdGhpcy4kX18uc2VsZWN0ZWRbY3VyXTtcbiAgICBicmVhaztcbiAgfVxuXG4gIGlmIChpbmNsdXNpdmUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0aGlzLiRfXy5zZWxlY3RlZC5oYXNPd25Qcm9wZXJ0eShwYXRoKSkge1xuICAgIHJldHVybiBpbmNsdXNpdmU7XG4gIH1cblxuICByZXR1cm4gIWluY2x1c2l2ZTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgcmVnaXN0ZXJlZCB2YWxpZGF0aW9uIHJ1bGVzIGZvciB0aGlzIGRvY3VtZW50LlxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYHByZWAgc2F2ZSBhbmQgaWYgYSB2YWxpZGF0aW9uIHJ1bGUgaXMgdmlvbGF0ZWQsIFtzYXZlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vZGVsLmh0bWwjTW9kZWwucHJvdG90eXBlLnNhdmUoKSkgaXMgYWJvcnRlZCBhbmQgdGhlIGVycm9yIGlzIHRocm93bi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGF3YWl0IGRvYy52YWxpZGF0ZSh7IHZhbGlkYXRlTW9kaWZpZWRPbmx5OiBmYWxzZSwgcGF0aHNUb1NraXA6IFsnbmFtZScsICdlbWFpbCddfSk7XG4gKlxuICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IFtwYXRoc1RvVmFsaWRhdGVdIGxpc3Qgb2YgcGF0aHMgdG8gdmFsaWRhdGUuIElmIHNldCwgTW9uZ29vc2Ugd2lsbCB2YWxpZGF0ZSBvbmx5IHRoZSBtb2RpZmllZCBwYXRocyB0aGF0IGFyZSBpbiB0aGUgZ2l2ZW4gbGlzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gaW50ZXJuYWwgb3B0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy52YWxpZGF0ZU1vZGlmaWVkT25seT1mYWxzZV0gaWYgYHRydWVgIG1vbmdvb3NlIHZhbGlkYXRlcyBvbmx5IG1vZGlmaWVkIHBhdGhzLlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IFtvcHRpb25zLnBhdGhzVG9Ta2lwXSBsaXN0IG9mIHBhdGhzIHRvIHNraXAuIElmIHNldCwgTW9uZ29vc2Ugd2lsbCB2YWxpZGF0ZSBldmVyeSBtb2RpZmllZCBwYXRoIHRoYXQgaXMgbm90IGluIHRoaXMgbGlzdC5cbiAqIEByZXR1cm4ge1Byb21pc2V9IFJldHVybnMgYSBQcm9taXNlLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUudmFsaWRhdGUgPSBhc3luYyBmdW5jdGlvbiB2YWxpZGF0ZShwYXRoc1RvVmFsaWRhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBwYXRoc1RvVmFsaWRhdGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdEb2N1bWVudC5wcm90b3R5cGUudmFsaWRhdGUoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cbiAgbGV0IHBhcmFsbGVsVmFsaWRhdGU7XG4gIHRoaXMuJG9wID0gJ3ZhbGlkYXRlJztcblxuICBpZiAodGhpcy4kaXNTdWJkb2N1bWVudCAhPSBudWxsKSB7XG4gICAgLy8gU2tpcCBwYXJhbGxlbCB2YWxpZGF0ZSBjaGVjayBmb3Igc3ViZG9jdW1lbnRzXG4gIH0gZWxzZSBpZiAodGhpcy4kX18udmFsaWRhdGluZykge1xuICAgIHBhcmFsbGVsVmFsaWRhdGUgPSBuZXcgUGFyYWxsZWxWYWxpZGF0ZUVycm9yKHRoaXMsIHtcbiAgICAgIHBhcmVudFN0YWNrOiBvcHRpb25zICYmIG9wdGlvbnMucGFyZW50U3RhY2ssXG4gICAgICBjb25mbGljdFN0YWNrOiB0aGlzLiRfXy52YWxpZGF0aW5nLnN0YWNrXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy4kX18udmFsaWRhdGluZyA9IG5ldyBQYXJhbGxlbFZhbGlkYXRlRXJyb3IodGhpcywgeyBwYXJlbnRTdGFjazogb3B0aW9ucyAmJiBvcHRpb25zLnBhcmVudFN0YWNrIH0pO1xuICB9XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHBhdGhzVG9WYWxpZGF0ZSA9IG51bGw7XG4gICAgfVxuICB9XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLnBhdGhzVG9Ta2lwID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IGlzT25lUGF0aE9ubHkgPSBvcHRpb25zLnBhdGhzVG9Ta2lwLmluZGV4T2YoJyAnKSA9PT0gLTE7XG4gICAgb3B0aW9ucy5wYXRoc1RvU2tpcCA9IGlzT25lUGF0aE9ubHkgPyBbb3B0aW9ucy5wYXRoc1RvU2tpcF0gOiBvcHRpb25zLnBhdGhzVG9Ta2lwLnNwbGl0KCcgJyk7XG4gIH1cblxuICBpZiAocGFyYWxsZWxWYWxpZGF0ZSAhPSBudWxsKSB7XG4gICAgdGhyb3cgcGFyYWxsZWxWYWxpZGF0ZTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdGhpcy4kX192YWxpZGF0ZShwYXRoc1RvVmFsaWRhdGUsIG9wdGlvbnMsIChlcnJvcikgPT4ge1xuICAgICAgdGhpcy4kb3AgPSBudWxsO1xuICAgICAgdGhpcy4kX18udmFsaWRhdGluZyA9IG51bGw7XG4gICAgICBpZiAoZXJyb3IgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEFsaWFzIG9mIFtgLnZhbGlkYXRlYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS52YWxpZGF0ZSgpKVxuICpcbiAqIEBtZXRob2QgJHZhbGlkYXRlXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiR2YWxpZGF0ZSA9IERvY3VtZW50LnByb3RvdHlwZS52YWxpZGF0ZTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfZXZhbHVhdGVSZXF1aXJlZEZ1bmN0aW9ucyhkb2MpIHtcbiAgY29uc3QgcmVxdWlyZWRGaWVsZHMgPSBPYmplY3Qua2V5cyhkb2MuJF9fLmFjdGl2ZVBhdGhzLmdldFN0YXRlUGF0aHMoJ3JlcXVpcmUnKSk7XG4gIGxldCBpID0gMDtcbiAgY29uc3QgbGVuID0gcmVxdWlyZWRGaWVsZHMubGVuZ3RoO1xuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBjb25zdCBwYXRoID0gcmVxdWlyZWRGaWVsZHNbaV07XG5cbiAgICBjb25zdCBwID0gZG9jLiRfX3NjaGVtYS5wYXRoKHBhdGgpO1xuXG4gICAgaWYgKHAgIT0gbnVsbCAmJiB0eXBlb2YgcC5vcmlnaW5hbFJlcXVpcmVkVmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGRvYy4kX18uY2FjaGVkUmVxdWlyZWQgPSBkb2MuJF9fLmNhY2hlZFJlcXVpcmVkIHx8IHt9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZG9jLiRfXy5jYWNoZWRSZXF1aXJlZFtwYXRoXSA9IHAub3JpZ2luYWxSZXF1aXJlZFZhbHVlLmNhbGwoZG9jLCBkb2MpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGRvYy5pbnZhbGlkYXRlKHBhdGgsIGVycik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2dldFBhdGhzVG9WYWxpZGF0ZShkb2MsIHBhdGhzVG9WYWxpZGF0ZSwgcGF0aHNUb1NraXApIHtcbiAgY29uc3QgZG9WYWxpZGF0ZU9wdGlvbnMgPSB7fTtcblxuICBfZXZhbHVhdGVSZXF1aXJlZEZ1bmN0aW9ucyhkb2MpO1xuICAvLyBvbmx5IHZhbGlkYXRlIHJlcXVpcmVkIGZpZWxkcyB3aGVuIG5lY2Vzc2FyeVxuICBsZXQgcGF0aHMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKGRvYy4kX18uYWN0aXZlUGF0aHMuZ2V0U3RhdGVQYXRocygncmVxdWlyZScpKS5maWx0ZXIoZnVuY3Rpb24ocGF0aCkge1xuICAgIGlmICghZG9jLiRfX2lzU2VsZWN0ZWQocGF0aCkgJiYgIWRvYy4kaXNNb2RpZmllZChwYXRoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZG9jLiRfXy5jYWNoZWRSZXF1aXJlZCAhPSBudWxsICYmIHBhdGggaW4gZG9jLiRfXy5jYWNoZWRSZXF1aXJlZCkge1xuICAgICAgcmV0dXJuIGRvYy4kX18uY2FjaGVkUmVxdWlyZWRbcGF0aF07XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9KSk7XG5cbiAgT2JqZWN0LmtleXMoZG9jLiRfXy5hY3RpdmVQYXRocy5nZXRTdGF0ZVBhdGhzKCdpbml0JykpLmZvckVhY2goYWRkVG9QYXRocyk7XG4gIE9iamVjdC5rZXlzKGRvYy4kX18uYWN0aXZlUGF0aHMuZ2V0U3RhdGVQYXRocygnbW9kaWZ5JykpLmZvckVhY2goYWRkVG9QYXRocyk7XG4gIE9iamVjdC5rZXlzKGRvYy4kX18uYWN0aXZlUGF0aHMuZ2V0U3RhdGVQYXRocygnZGVmYXVsdCcpKS5mb3JFYWNoKGFkZFRvUGF0aHMpO1xuICBmdW5jdGlvbiBhZGRUb1BhdGhzKHApIHsgcGF0aHMuYWRkKHApOyB9XG5cbiAgY29uc3Qgc3ViZG9jcyA9IGRvYy4kZ2V0QWxsU3ViZG9jcygpO1xuICBjb25zdCBtb2RpZmllZFBhdGhzID0gZG9jLm1vZGlmaWVkUGF0aHMoKTtcbiAgZm9yIChjb25zdCBzdWJkb2Mgb2Ygc3ViZG9jcykge1xuICAgIGlmIChzdWJkb2MuJGJhc2VQYXRoKSB7XG4gICAgICBjb25zdCBmdWxsUGF0aFRvU3ViZG9jID0gc3ViZG9jLiRpc1NpbmdsZU5lc3RlZCA/IHN1YmRvYy4kX19wYXRoUmVsYXRpdmVUb1BhcmVudCgpIDogc3ViZG9jLiRfX2Z1bGxQYXRoV2l0aEluZGV4ZXMoKTtcblxuICAgICAgLy8gUmVtb3ZlIGNoaWxkIHBhdGhzIGZvciBub3csIGJlY2F1c2Ugd2UnbGwgYmUgdmFsaWRhdGluZyB0aGUgd2hvbGVcbiAgICAgIC8vIHN1YmRvYy5cbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgaXMgYSBmYXN0ZXIgdGFrZSBvbiBsb29waW5nIHRocm91Z2ggZXZlcnkgcGF0aCBpbiBgcGF0aHNgXG4gICAgICAvLyBhbmQgY2hlY2tpbmcgaWYgdGhlIHBhdGggc3RhcnRzIHdpdGggYGZ1bGxQYXRoVG9TdWJkb2NgIHJlOiBnaC0xMzE5MVxuICAgICAgZm9yIChjb25zdCBtb2RpZmllZFBhdGggb2Ygc3ViZG9jLm1vZGlmaWVkUGF0aHMoKSkge1xuICAgICAgICBwYXRocy5kZWxldGUoZnVsbFBhdGhUb1N1YmRvYyArICcuJyArIG1vZGlmaWVkUGF0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkb2MuJGlzTW9kaWZpZWQoZnVsbFBhdGhUb1N1YmRvYywgbnVsbCwgbW9kaWZpZWRQYXRocykgJiZcbiAgICAgICAgICAgICFkb2MuaXNEaXJlY3RNb2RpZmllZChmdWxsUGF0aFRvU3ViZG9jKSAmJlxuICAgICAgICAgICAgIWRvYy4kaXNEZWZhdWx0KGZ1bGxQYXRoVG9TdWJkb2MpKSB7XG4gICAgICAgIHBhdGhzLmFkZChmdWxsUGF0aFRvU3ViZG9jKTtcbiAgICAgICAgaWYgKGRvYy4kX18ucGF0aHNUb1Njb3BlcyA9PSBudWxsKSB7XG4gICAgICAgICAgZG9jLiRfXy5wYXRoc1RvU2NvcGVzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZG9jLiRfXy5wYXRoc1RvU2NvcGVzW2Z1bGxQYXRoVG9TdWJkb2NdID0gc3ViZG9jLiRpc0RvY3VtZW50QXJyYXlFbGVtZW50ID9cbiAgICAgICAgICBzdWJkb2MuX19wYXJlbnRBcnJheSA6XG4gICAgICAgICAgc3ViZG9jLiRwYXJlbnQoKTtcblxuICAgICAgICBkb1ZhbGlkYXRlT3B0aW9uc1tmdWxsUGF0aFRvU3ViZG9jXSA9IHsgc2tpcFNjaGVtYVZhbGlkYXRvcnM6IHRydWUgfTtcbiAgICAgICAgaWYgKHN1YmRvYy4kaXNEb2N1bWVudEFycmF5RWxlbWVudCAmJiBzdWJkb2MuX19pbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgZG9WYWxpZGF0ZU9wdGlvbnNbZnVsbFBhdGhUb1N1YmRvY10uaW5kZXggPSBzdWJkb2MuX19pbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgIGNvbnN0IF9wYXRoVHlwZSA9IGRvYy4kX19zY2hlbWEucGF0aChwYXRoKTtcbiAgICBpZiAoIV9wYXRoVHlwZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKF9wYXRoVHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkpIHtcbiAgICAgIGZvciAoY29uc3QgcCBvZiBwYXRocykge1xuICAgICAgICBpZiAocCA9PSBudWxsIHx8IHAuc3RhcnRzV2l0aChfcGF0aFR5cGUucGF0aCArICcuJykpIHtcbiAgICAgICAgICBwYXRocy5kZWxldGUocCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPcHRpbWl6YXRpb246IGlmIHByaW1pdGl2ZSBwYXRoIHdpdGggbm8gdmFsaWRhdG9ycywgb3IgYXJyYXkgb2YgcHJpbWl0aXZlc1xuICAgIC8vIHdpdGggbm8gdmFsaWRhdG9ycywgc2tpcCB2YWxpZGF0aW5nIHRoaXMgcGF0aCBlbnRpcmVseS5cbiAgICBpZiAoIV9wYXRoVHlwZS5jYXN0ZXIgJiYgX3BhdGhUeXBlLnZhbGlkYXRvcnMubGVuZ3RoID09PSAwICYmICFfcGF0aFR5cGUuJHBhcmVudFNjaGVtYURvY0FycmF5KSB7XG4gICAgICBwYXRocy5kZWxldGUocGF0aCk7XG4gICAgfSBlbHNlIGlmIChfcGF0aFR5cGUuJGlzTW9uZ29vc2VBcnJheSAmJlxuICAgICAgIV9wYXRoVHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkgJiYgLy8gU2tpcCBkb2N1bWVudCBhcnJheXMuLi5cbiAgICAgICFfcGF0aFR5cGUuJGVtYmVkZGVkU2NoZW1hVHlwZS4kaXNNb25nb29zZUFycmF5ICYmIC8vIGFuZCBhcnJheXMgb2YgYXJyYXlzXG4gICAgICBfcGF0aFR5cGUudmFsaWRhdG9ycy5sZW5ndGggPT09IDAgJiYgLy8gYW5kIGFycmF5cyB3aXRoIHRvcC1sZXZlbCB2YWxpZGF0b3JzXG4gICAgICBfcGF0aFR5cGUuJGVtYmVkZGVkU2NoZW1hVHlwZS52YWxpZGF0b3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcGF0aHMuZGVsZXRlKHBhdGgpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgIC8vIFNpbmdsZSBuZXN0ZWQgcGF0aHMgKHBhdGhzIGVtYmVkZGVkIHVuZGVyIHNpbmdsZSBuZXN0ZWQgc3ViZG9jcykgd2lsbFxuICAgIC8vIGJlIHZhbGlkYXRlZCBvbiB0aGVpciBvd24gd2hlbiB3ZSBjYWxsIGB2YWxpZGF0ZSgpYCBvbiB0aGUgc3ViZG9jIGl0c2VsZi5cbiAgICAvLyBSZTogZ2gtODQ2OFxuICAgIGlmIChkb2MuJF9fc2NoZW1hLnNpbmdsZU5lc3RlZFBhdGhzLmhhc093blByb3BlcnR5KHBhdGgpKSB7XG4gICAgICBwYXRocy5kZWxldGUocGF0aCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShwYXRoc1RvVmFsaWRhdGUpKSB7XG4gICAgcGF0aHMgPSBfaGFuZGxlUGF0aHNUb1ZhbGlkYXRlKHBhdGhzLCBwYXRoc1RvVmFsaWRhdGUpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocGF0aHNUb1NraXApKSB7XG4gICAgcGF0aHMgPSBfaGFuZGxlUGF0aHNUb1NraXAocGF0aHMsIHBhdGhzVG9Ta2lwKTtcbiAgfVxuXG4gIC8vIGZyb20gaGVyZSBvbiB3ZSdyZSBub3QgcmVtb3ZpbmcgaXRlbXMgZnJvbSBwYXRoc1xuXG4gIC8vIGdoLTY2MTogaWYgYSB3aG9sZSBhcnJheSBpcyBtb2RpZmllZCwgbWFrZSBzdXJlIHRvIHJ1biB2YWxpZGF0aW9uIG9uIGFsbFxuICAvLyB0aGUgY2hpbGRyZW4gYXMgd2VsbFxuICBfYWRkQXJyYXlQYXRoc1RvVmFsaWRhdGUoZG9jLCBwYXRocyk7XG5cbiAgY29uc3QgZmxhdHRlbk9wdGlvbnMgPSB7IHNraXBBcnJheXM6IHRydWUgfTtcbiAgZm9yIChjb25zdCBwYXRoVG9DaGVjayBvZiBwYXRocykge1xuICAgIGlmIChkb2MuJF9fc2NoZW1hLm5lc3RlZFtwYXRoVG9DaGVja10pIHtcbiAgICAgIGxldCBfdiA9IGRvYy4kX19nZXRWYWx1ZShwYXRoVG9DaGVjayk7XG4gICAgICBpZiAoaXNNb25nb29zZU9iamVjdChfdikpIHtcbiAgICAgICAgX3YgPSBfdi50b09iamVjdCh7IHRyYW5zZm9ybTogZmFsc2UgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBmbGF0ID0gZmxhdHRlbihfdiwgcGF0aFRvQ2hlY2ssIGZsYXR0ZW5PcHRpb25zLCBkb2MuJF9fc2NoZW1hKTtcbiAgICAgIE9iamVjdC5rZXlzKGZsYXQpLmZvckVhY2goYWRkVG9QYXRocyk7XG4gICAgfVxuICB9XG5cbiAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgY29uc3QgX3BhdGhUeXBlID0gZG9jLiRfX3NjaGVtYS5wYXRoKHBhdGgpO1xuXG4gICAgaWYgKCFfcGF0aFR5cGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIElmIHVuZGVybmVhdGggYSBkb2N1bWVudCBhcnJheSwgbWF5IG5lZWQgdG8gcmUtdmFsaWRhdGUgdGhlIHBhcmVudFxuICAgIC8vIGFycmF5IHJlOiBnaC02ODE4LiBEbyB0aGlzIF9hZnRlcl8gYWRkaW5nIHN1YnBhdGhzLCBiZWNhdXNlXG4gICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBhZGQgZXZlcnkgYXJyYXkgc3VicGF0aC5cbiAgICBpZiAoX3BhdGhUeXBlLiRwYXJlbnRTY2hlbWFEb2NBcnJheSAmJiB0eXBlb2YgX3BhdGhUeXBlLiRwYXJlbnRTY2hlbWFEb2NBcnJheS5wYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgcGF0aHMuYWRkKF9wYXRoVHlwZS4kcGFyZW50U2NoZW1hRG9jQXJyYXkucGF0aCk7XG4gICAgfVxuXG4gICAgaWYgKCFfcGF0aFR5cGUuJGlzU2NoZW1hTWFwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWwgPSBkb2MuJF9fZ2V0VmFsdWUocGF0aCk7XG4gICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgb2YgdmFsLmtleXMoKSkge1xuICAgICAgcGF0aHMuYWRkKHBhdGggKyAnLicgKyBrZXkpO1xuICAgIH1cbiAgfVxuXG4gIHBhdGhzID0gQXJyYXkuZnJvbShwYXRocyk7XG4gIHJldHVybiBbcGF0aHMsIGRvVmFsaWRhdGVPcHRpb25zXTtcbn1cblxuZnVuY3Rpb24gX2FkZEFycmF5UGF0aHNUb1ZhbGlkYXRlKGRvYywgcGF0aHMpIHtcbiAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgY29uc3QgX3BhdGhUeXBlID0gZG9jLiRfX3NjaGVtYS5wYXRoKHBhdGgpO1xuICAgIGlmICghX3BhdGhUeXBlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoIV9wYXRoVHlwZS4kaXNNb25nb29zZUFycmF5IHx8XG4gICAgICAgIC8vIFRvIGF2b2lkIHBvdGVudGlhbCBwZXJmb3JtYW5jZSBpc3N1ZXMsIHNraXAgZG9jIGFycmF5cyB3aG9zZSBjaGlsZHJlblxuICAgICAgICAvLyBhcmUgbm90IHJlcXVpcmVkLiBgZ2V0UG9zaXRpb25hbFBhdGhUeXBlKClgIG1heSBiZSBzbG93LCBzbyBhdm9pZFxuICAgICAgICAvLyBpdCB1bmxlc3Mgd2UgaGF2ZSBhIGNhc2Ugb2YgIzYzNjRcbiAgICAgICAgKCFBcnJheS5pc0FycmF5KF9wYXRoVHlwZSkgJiZcbiAgICAgICAgICBfcGF0aFR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5ICYmXG4gICAgICAgICAgIShfcGF0aFR5cGUgJiYgX3BhdGhUeXBlLnNjaGVtYU9wdGlvbnMgJiYgX3BhdGhUeXBlLnNjaGVtYU9wdGlvbnMucmVxdWlyZWQpKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZ2gtMTEzODA6IG9wdGltaXphdGlvbi4gSWYgdGhlIGFycmF5IGlzbid0IGEgZG9jdW1lbnQgYXJyYXkgYW5kIHRoZXJlJ3Mgbm8gdmFsaWRhdG9yc1xuICAgIC8vIG9uIHRoZSBhcnJheSB0eXBlLCB0aGVyZSdzIG5vIG5lZWQgdG8gcnVuIHZhbGlkYXRpb24gb24gdGhlIGluZGl2aWR1YWwgYXJyYXkgZWxlbWVudHMuXG4gICAgaWYgKF9wYXRoVHlwZS4kaXNNb25nb29zZUFycmF5ICYmXG4gICAgICAgICFfcGF0aFR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5ICYmIC8vIFNraXAgZG9jdW1lbnQgYXJyYXlzLi4uXG4gICAgICAgICFfcGF0aFR5cGUuJGVtYmVkZGVkU2NoZW1hVHlwZS4kaXNNb25nb29zZUFycmF5ICYmIC8vIGFuZCBhcnJheXMgb2YgYXJyYXlzXG4gICAgICAgIF9wYXRoVHlwZS4kZW1iZWRkZWRTY2hlbWFUeXBlLnZhbGlkYXRvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWwgPSBkb2MuJF9fZ2V0VmFsdWUocGF0aCk7XG4gICAgX3B1c2hOZXN0ZWRBcnJheVBhdGhzKHZhbCwgcGF0aHMsIHBhdGgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9wdXNoTmVzdGVkQXJyYXlQYXRocyh2YWwsIHBhdGhzLCBwYXRoKSB7XG4gIGlmICh2YWwgIT0gbnVsbCkge1xuICAgIGNvbnN0IG51bUVsZW1lbnRzID0gdmFsLmxlbmd0aDtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bUVsZW1lbnRzOyArK2opIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbFtqXSkpIHtcbiAgICAgICAgX3B1c2hOZXN0ZWRBcnJheVBhdGhzKHZhbFtqXSwgcGF0aHMsIHBhdGggKyAnLicgKyBqKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGhzLmFkZChwYXRoICsgJy4nICsgaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRfX3ZhbGlkYXRlID0gZnVuY3Rpb24ocGF0aHNUb1ZhbGlkYXRlLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodGhpcy4kX18uc2F2ZU9wdGlvbnMgJiYgdGhpcy4kX18uc2F2ZU9wdGlvbnMucGF0aHNUb1NhdmUgJiYgIXBhdGhzVG9WYWxpZGF0ZSkge1xuICAgIHBhdGhzVG9WYWxpZGF0ZSA9IFsuLi50aGlzLiRfXy5zYXZlT3B0aW9ucy5wYXRoc1RvU2F2ZV07XG4gIH0gZWxzZSBpZiAodHlwZW9mIHBhdGhzVG9WYWxpZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gcGF0aHNUb1ZhbGlkYXRlO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICAgIHBhdGhzVG9WYWxpZGF0ZSA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cblxuICBjb25zdCBoYXNWYWxpZGF0ZU1vZGlmaWVkT25seU9wdGlvbiA9IG9wdGlvbnMgJiZcbiAgICAgICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpICYmXG4gICAgICAoJ3ZhbGlkYXRlTW9kaWZpZWRPbmx5JyBpbiBvcHRpb25zKTtcblxuICBjb25zdCBwYXRoc1RvU2tpcCA9IChvcHRpb25zICYmIG9wdGlvbnMucGF0aHNUb1NraXApIHx8IG51bGw7XG5cbiAgbGV0IHNob3VsZFZhbGlkYXRlTW9kaWZpZWRPbmx5O1xuICBpZiAoaGFzVmFsaWRhdGVNb2RpZmllZE9ubHlPcHRpb24pIHtcbiAgICBzaG91bGRWYWxpZGF0ZU1vZGlmaWVkT25seSA9ICEhb3B0aW9ucy52YWxpZGF0ZU1vZGlmaWVkT25seTtcbiAgfSBlbHNlIHtcbiAgICBzaG91bGRWYWxpZGF0ZU1vZGlmaWVkT25seSA9IHRoaXMuJF9fc2NoZW1hLm9wdGlvbnMudmFsaWRhdGVNb2RpZmllZE9ubHk7XG4gIH1cblxuICBjb25zdCB2YWxpZGF0ZUFsbFBhdGhzID0gb3B0aW9ucyAmJiBvcHRpb25zLnZhbGlkYXRlQWxsUGF0aHM7XG4gIGlmICh2YWxpZGF0ZUFsbFBhdGhzKSB7XG4gICAgaWYgKHBhdGhzVG9Ta2lwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3Qgc2V0IGJvdGggYHZhbGlkYXRlQWxsUGF0aHNgIGFuZCBgcGF0aHNUb1NraXBgJyk7XG4gICAgfVxuICAgIGlmIChwYXRoc1RvVmFsaWRhdGUpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBzZXQgYm90aCBgdmFsaWRhdGVBbGxQYXRoc2AgYW5kIGBwYXRoc1RvVmFsaWRhdGVgJyk7XG4gICAgfVxuICAgIGlmIChoYXNWYWxpZGF0ZU1vZGlmaWVkT25seU9wdGlvbiAmJiBzaG91bGRWYWxpZGF0ZU1vZGlmaWVkT25seSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IHNldCBib3RoIGB2YWxpZGF0ZUFsbFBhdGhzYCBhbmQgYHZhbGlkYXRlTW9kaWZpZWRPbmx5YCcpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IF90aGlzID0gdGhpcztcbiAgY29uc3QgX2NvbXBsZXRlID0gKCkgPT4ge1xuICAgIGxldCB2YWxpZGF0aW9uRXJyb3IgPSB0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3I7XG4gICAgdGhpcy4kX18udmFsaWRhdGlvbkVycm9yID0gbnVsbDtcbiAgICB0aGlzLiRfXy52YWxpZGF0aW5nID0gbnVsbDtcblxuICAgIGlmIChzaG91bGRWYWxpZGF0ZU1vZGlmaWVkT25seSAmJiB2YWxpZGF0aW9uRXJyb3IgIT0gbnVsbCkge1xuICAgICAgLy8gUmVtb3ZlIGFueSB2YWxpZGF0aW9uIGVycm9ycyB0aGF0IGFyZW4ndCBmcm9tIG1vZGlmaWVkIHBhdGhzXG4gICAgICBjb25zdCBlcnJvcnMgPSBPYmplY3Qua2V5cyh2YWxpZGF0aW9uRXJyb3IuZXJyb3JzKTtcbiAgICAgIGZvciAoY29uc3QgZXJyUGF0aCBvZiBlcnJvcnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLiRpc01vZGlmaWVkKGVyclBhdGgpKSB7XG4gICAgICAgICAgZGVsZXRlIHZhbGlkYXRpb25FcnJvci5lcnJvcnNbZXJyUGF0aF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChPYmplY3Qua2V5cyh2YWxpZGF0aW9uRXJyb3IuZXJyb3JzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFsaWRhdGlvbkVycm9yID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuJF9fLmNhY2hlZFJlcXVpcmVkID0ge307XG4gICAgdGhpcy4kZW1pdCgndmFsaWRhdGUnLCBfdGhpcyk7XG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5lbWl0KCd2YWxpZGF0ZScsIF90aGlzKTtcblxuICAgIGlmICh2YWxpZGF0aW9uRXJyb3IpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbGlkYXRpb25FcnJvci5lcnJvcnMpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIGNhc3QgZXJyb3JzIHBlcnNpc3RcbiAgICAgICAgaWYgKCF0aGlzW2RvY3VtZW50QXJyYXlQYXJlbnRdICYmXG4gICAgICAgICAgICB2YWxpZGF0aW9uRXJyb3IuZXJyb3JzW2tleV0gaW5zdGFuY2VvZiBNb25nb29zZUVycm9yLkNhc3RFcnJvcikge1xuICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZShrZXksIHZhbGlkYXRpb25FcnJvci5lcnJvcnNba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbGlkYXRpb25FcnJvcjtcbiAgICB9XG4gIH07XG5cbiAgLy8gb25seSB2YWxpZGF0ZSByZXF1aXJlZCBmaWVsZHMgd2hlbiBuZWNlc3NhcnlcbiAgbGV0IHBhdGhzO1xuICBsZXQgZG9WYWxpZGF0ZU9wdGlvbnNCeVBhdGg7XG4gIGlmICh2YWxpZGF0ZUFsbFBhdGhzKSB7XG4gICAgcGF0aHMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHRoaXMuJF9fc2NoZW1hLnBhdGhzKSk7XG4gICAgLy8gZ2gtNjYxOiBpZiBhIHdob2xlIGFycmF5IGlzIG1vZGlmaWVkLCBtYWtlIHN1cmUgdG8gcnVuIHZhbGlkYXRpb24gb24gYWxsXG4gICAgLy8gdGhlIGNoaWxkcmVuIGFzIHdlbGxcbiAgICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICAgIGNvbnN0IHNjaGVtYVR5cGUgPSB0aGlzLiRfX3NjaGVtYS5wYXRoKHBhdGgpO1xuICAgICAgaWYgKCFzY2hlbWFUeXBlIHx8ICFzY2hlbWFUeXBlLiRpc01vbmdvb3NlQXJyYXkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWwgPSB0aGlzLiRfX2dldFZhbHVlKHBhdGgpO1xuICAgICAgaWYgKCF2YWwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBfcHVzaE5lc3RlZEFycmF5UGF0aHModmFsLCBwYXRocywgcGF0aCk7XG4gICAgfVxuICAgIHBhdGhzID0gWy4uLnBhdGhzXTtcbiAgICBkb1ZhbGlkYXRlT3B0aW9uc0J5UGF0aCA9IHt9O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHBhdGhEZXRhaWxzID0gX2dldFBhdGhzVG9WYWxpZGF0ZSh0aGlzLCBwYXRoc1RvVmFsaWRhdGUsIHBhdGhzVG9Ta2lwKTtcbiAgICBwYXRocyA9IHNob3VsZFZhbGlkYXRlTW9kaWZpZWRPbmx5ID9cbiAgICAgIHBhdGhEZXRhaWxzWzBdLmZpbHRlcigocGF0aCkgPT4gdGhpcy4kaXNNb2RpZmllZChwYXRoKSkgOlxuICAgICAgcGF0aERldGFpbHNbMF07XG4gICAgZG9WYWxpZGF0ZU9wdGlvbnNCeVBhdGggPSBwYXRoRGV0YWlsc1sxXTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGF0aHNUb1ZhbGlkYXRlID09PSAnc3RyaW5nJykge1xuICAgIHBhdGhzVG9WYWxpZGF0ZSA9IHBhdGhzVG9WYWxpZGF0ZS5zcGxpdCgnICcpO1xuICB9XG5cbiAgaWYgKHBhdGhzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBpbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBlcnJvciA9IF9jb21wbGV0ZSgpO1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy4kX19zY2hlbWEucy5ob29rcy5leGVjUG9zdCgndmFsaWRhdGU6ZXJyb3InLCBfdGhpcywgW190aGlzXSwgeyBlcnJvcjogZXJyb3IgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2sobnVsbCwgX3RoaXMpO1xuICAgIH0pO1xuICB9XG5cbiAgY29uc3QgdmFsaWRhdGVkID0ge307XG4gIGxldCB0b3RhbCA9IDA7XG5cbiAgbGV0IHBhdGhzVG9TYXZlID0gdGhpcy4kX18uc2F2ZU9wdGlvbnM/LnBhdGhzVG9TYXZlO1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXRoc1RvU2F2ZSkpIHtcbiAgICBwYXRoc1RvU2F2ZSA9IG5ldyBTZXQocGF0aHNUb1NhdmUpO1xuICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgICAgaWYgKCFwYXRoc1RvU2F2ZS5oYXMocGF0aCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YWxpZGF0ZVBhdGgocGF0aCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgICAgdmFsaWRhdGVQYXRoKHBhdGgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlUGF0aChwYXRoKSB7XG4gICAgaWYgKHBhdGggPT0gbnVsbCB8fCB2YWxpZGF0ZWRbcGF0aF0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YWxpZGF0ZWRbcGF0aF0gPSB0cnVlO1xuICAgIHRvdGFsKys7XG5cbiAgICBpbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBzY2hlbWFUeXBlID0gX3RoaXMuJF9fc2NoZW1hLnBhdGgocGF0aCk7XG5cbiAgICAgIGlmICghc2NoZW1hVHlwZSkge1xuICAgICAgICByZXR1cm4gLS10b3RhbCB8fCBjb21wbGV0ZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB1c2VyIG1hcmtlZCBhcyBpbnZhbGlkIG9yIHRoZXJlIHdhcyBhIGNhc3QgZXJyb3IsIGRvbid0IHZhbGlkYXRlXG4gICAgICBpZiAoIV90aGlzLiRpc1ZhbGlkKHBhdGgpKSB7XG4gICAgICAgIC0tdG90YWwgfHwgY29tcGxldGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBzZXR0aW5nIGEgcGF0aCB1bmRlciBhIG1peGVkIHBhdGgsIGF2b2lkIHVzaW5nIHRoZSBtaXhlZCBwYXRoIHZhbGlkYXRvciAoZ2gtMTAxNDEpXG4gICAgICBpZiAoc2NoZW1hVHlwZVtzY2hlbWFNaXhlZFN5bWJvbF0gIT0gbnVsbCAmJiBwYXRoICE9PSBzY2hlbWFUeXBlLnBhdGgpIHtcbiAgICAgICAgcmV0dXJuIC0tdG90YWwgfHwgY29tcGxldGUoKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHZhbCA9IF90aGlzLiRfX2dldFZhbHVlKHBhdGgpO1xuXG4gICAgICAvLyBJZiB5b3UgYHBvcHVsYXRlKClgIGFuZCBnZXQgYmFjayBhIG51bGwgdmFsdWUsIHJlcXVpcmVkIHZhbGlkYXRvcnNcbiAgICAgIC8vIHNob3VsZG4ndCBmYWlsIChnaC04MDE4KS4gV2Ugc2hvdWxkIGFsd2F5cyBmYWxsIGJhY2sgdG8gdGhlIHBvcHVsYXRlZFxuICAgICAgLy8gdmFsdWUuXG4gICAgICBsZXQgcG9wO1xuICAgICAgaWYgKChwb3AgPSBfdGhpcy4kcG9wdWxhdGVkKHBhdGgpKSkge1xuICAgICAgICB2YWwgPSBwb3A7XG4gICAgICB9IGVsc2UgaWYgKHZhbCAhPSBudWxsICYmIHZhbC4kX18gIT0gbnVsbCAmJiB2YWwuJF9fLndhc1BvcHVsYXRlZCkge1xuICAgICAgICAvLyBBcnJheSBwYXRocywgbGlrZSBgc29tZWFycmF5LjFgLCBkbyBub3Qgc2hvdyB1cCBhcyBwb3B1bGF0ZWQgd2l0aCBgJHBvcHVsYXRlZCgpYCxcbiAgICAgICAgLy8gc28gaW4gdGhhdCBjYXNlIHB1bGwgb3V0IHRoZSBkb2N1bWVudCdzIGlkXG4gICAgICAgIHZhbCA9IHZhbC5faWQ7XG4gICAgICB9XG4gICAgICBjb25zdCBzY29wZSA9IF90aGlzLiRfXy5wYXRoc1RvU2NvcGVzICE9IG51bGwgJiYgcGF0aCBpbiBfdGhpcy4kX18ucGF0aHNUb1Njb3BlcyA/XG4gICAgICAgIF90aGlzLiRfXy5wYXRoc1RvU2NvcGVzW3BhdGhdIDpcbiAgICAgICAgX3RoaXM7XG5cbiAgICAgIGNvbnN0IGRvVmFsaWRhdGVPcHRpb25zID0ge1xuICAgICAgICAuLi5kb1ZhbGlkYXRlT3B0aW9uc0J5UGF0aFtwYXRoXSxcbiAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgdmFsaWRhdGVNb2RpZmllZE9ubHk6IHNob3VsZFZhbGlkYXRlTW9kaWZpZWRPbmx5LFxuICAgICAgICB2YWxpZGF0ZUFsbFBhdGhzXG4gICAgICB9O1xuXG4gICAgICBzY2hlbWFUeXBlLmRvVmFsaWRhdGUodmFsLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGNvbnN0IGlzU3ViZG9jID0gc2NoZW1hVHlwZS4kaXNTaW5nbGVOZXN0ZWQgfHxcbiAgICAgICAgICAgICAgc2NoZW1hVHlwZS4kaXNBcnJheVN1YmRvY3VtZW50IHx8XG4gICAgICAgICAgICAgIHNjaGVtYVR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5O1xuICAgICAgICAgIGlmIChpc1N1YmRvYyAmJiBlcnIgaW5zdGFuY2VvZiBWYWxpZGF0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiAtLXRvdGFsIHx8IGNvbXBsZXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF90aGlzLmludmFsaWRhdGUocGF0aCwgZXJyLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIC0tdG90YWwgfHwgY29tcGxldGUoKTtcbiAgICAgIH0sIHNjb3BlLCBkb1ZhbGlkYXRlT3B0aW9ucyk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICBjb25zdCBlcnJvciA9IF9jb21wbGV0ZSgpO1xuICAgIGlmIChlcnJvcikge1xuICAgICAgcmV0dXJuIF90aGlzLiRfX3NjaGVtYS5zLmhvb2tzLmV4ZWNQb3N0KCd2YWxpZGF0ZTplcnJvcicsIF90aGlzLCBbX3RoaXNdLCB7IGVycm9yOiBlcnJvciB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY2FsbGJhY2sobnVsbCwgX3RoaXMpO1xuICB9XG5cbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2hhbmRsZVBhdGhzVG9WYWxpZGF0ZShwYXRocywgcGF0aHNUb1ZhbGlkYXRlKSB7XG4gIGNvbnN0IF9wYXRoc1RvVmFsaWRhdGUgPSBuZXcgU2V0KHBhdGhzVG9WYWxpZGF0ZSk7XG4gIGNvbnN0IHBhcmVudFBhdGhzID0gbmV3IE1hcChbXSk7XG4gIGZvciAoY29uc3QgcGF0aCBvZiBwYXRoc1RvVmFsaWRhdGUpIHtcbiAgICBpZiAocGF0aC5pbmRleE9mKCcuJykgPT09IC0xKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgcGllY2VzID0gcGF0aC5zcGxpdCgnLicpO1xuICAgIGxldCBjdXIgPSBwaWVjZXNbMF07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwaWVjZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIC8vIFNpbmNlIHdlIHNraXAgc3VicGF0aHMgdW5kZXIgc2luZ2xlIG5lc3RlZCBzdWJkb2NzIHRvXG4gICAgICAvLyBhdm9pZCBkb3VibGUgdmFsaWRhdGlvbiwgd2UgbmVlZCB0byBhZGQgYmFjayB0aGVcbiAgICAgIC8vIHNpbmdsZSBuZXN0ZWQgc3VicGF0aCBpZiB0aGUgdXNlciBhc2tlZCBmb3IgaXQgKGdoLTg2MjYpXG4gICAgICBwYXJlbnRQYXRocy5zZXQoY3VyLCBwYXRoKTtcbiAgICAgIGN1ciA9IGN1ciArICcuJyArIHBpZWNlc1tpXTtcbiAgICB9XG4gIH1cblxuICBjb25zdCByZXQgPSBuZXcgU2V0KCk7XG4gIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgIGlmIChfcGF0aHNUb1ZhbGlkYXRlLmhhcyhwYXRoKSkge1xuICAgICAgcmV0LmFkZChwYXRoKTtcbiAgICB9IGVsc2UgaWYgKHBhcmVudFBhdGhzLmhhcyhwYXRoKSkge1xuICAgICAgcmV0LmFkZChwYXJlbnRQYXRocy5nZXQocGF0aCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9oYW5kbGVQYXRoc1RvU2tpcChwYXRocywgcGF0aHNUb1NraXApIHtcbiAgcGF0aHNUb1NraXAgPSBuZXcgU2V0KHBhdGhzVG9Ta2lwKTtcbiAgcGF0aHMgPSBBcnJheS5mcm9tKHBhdGhzKS5maWx0ZXIocCA9PiAhcGF0aHNUb1NraXAuaGFzKHApKTtcbiAgcmV0dXJuIG5ldyBTZXQocGF0aHMpO1xufVxuXG4vKipcbiAqIEV4ZWN1dGVzIHJlZ2lzdGVyZWQgdmFsaWRhdGlvbiBydWxlcyAoc2tpcHBpbmcgYXN5bmNocm9ub3VzIHZhbGlkYXRvcnMpIGZvciB0aGlzIGRvY3VtZW50LlxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyB1c2VmdWwgaWYgeW91IG5lZWQgc3luY2hyb25vdXMgdmFsaWRhdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGVyciA9IGRvYy52YWxpZGF0ZVN5bmMoKTtcbiAqICAgICBpZiAoZXJyKSB7XG4gKiAgICAgICBoYW5kbGVFcnJvcihlcnIpO1xuICogICAgIH0gZWxzZSB7XG4gKiAgICAgICAvLyB2YWxpZGF0aW9uIHBhc3NlZFxuICogICAgIH1cbiAqXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gW3BhdGhzVG9WYWxpZGF0ZV0gb25seSB2YWxpZGF0ZSB0aGUgZ2l2ZW4gcGF0aHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9ucyBmb3IgdmFsaWRhdGlvblxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy52YWxpZGF0ZU1vZGlmaWVkT25seT1mYWxzZV0gSWYgYHRydWVgLCBNb25nb29zZSB3aWxsIG9ubHkgdmFsaWRhdGUgbW9kaWZpZWQgcGF0aHMsIGFzIG9wcG9zZWQgdG8gbW9kaWZpZWQgcGF0aHMgYW5kIGByZXF1aXJlZGAgcGF0aHMuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gW29wdGlvbnMucGF0aHNUb1NraXBdIGxpc3Qgb2YgcGF0aHMgdG8gc2tpcC4gSWYgc2V0LCBNb25nb29zZSB3aWxsIHZhbGlkYXRlIGV2ZXJ5IG1vZGlmaWVkIHBhdGggdGhhdCBpcyBub3QgaW4gdGhpcyBsaXN0LlxuICogQHJldHVybiB7VmFsaWRhdGlvbkVycm9yfHVuZGVmaW5lZH0gVmFsaWRhdGlvbkVycm9yIGlmIHRoZXJlIGFyZSBlcnJvcnMgZHVyaW5nIHZhbGlkYXRpb24sIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSBpcyBubyBlcnJvci5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLnZhbGlkYXRlU3luYyA9IGZ1bmN0aW9uKHBhdGhzVG9WYWxpZGF0ZSwgb3B0aW9ucykge1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbMF07XG4gICAgcGF0aHNUb1ZhbGlkYXRlID0gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGhhc1ZhbGlkYXRlTW9kaWZpZWRPbmx5T3B0aW9uID0gb3B0aW9ucyAmJlxuICAgICAgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JykgJiZcbiAgICAgICgndmFsaWRhdGVNb2RpZmllZE9ubHknIGluIG9wdGlvbnMpO1xuXG4gIGxldCBzaG91bGRWYWxpZGF0ZU1vZGlmaWVkT25seTtcbiAgaWYgKGhhc1ZhbGlkYXRlTW9kaWZpZWRPbmx5T3B0aW9uKSB7XG4gICAgc2hvdWxkVmFsaWRhdGVNb2RpZmllZE9ubHkgPSAhIW9wdGlvbnMudmFsaWRhdGVNb2RpZmllZE9ubHk7XG4gIH0gZWxzZSB7XG4gICAgc2hvdWxkVmFsaWRhdGVNb2RpZmllZE9ubHkgPSB0aGlzLiRfX3NjaGVtYS5vcHRpb25zLnZhbGlkYXRlTW9kaWZpZWRPbmx5O1xuICB9XG5cbiAgbGV0IHBhdGhzVG9Ta2lwID0gb3B0aW9ucyAmJiBvcHRpb25zLnBhdGhzVG9Ta2lwO1xuXG4gIGNvbnN0IHZhbGlkYXRlQWxsUGF0aHMgPSBvcHRpb25zICYmIG9wdGlvbnMudmFsaWRhdGVBbGxQYXRocztcbiAgaWYgKHZhbGlkYXRlQWxsUGF0aHMpIHtcbiAgICBpZiAocGF0aHNUb1NraXApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBzZXQgYm90aCBgdmFsaWRhdGVBbGxQYXRoc2AgYW5kIGBwYXRoc1RvU2tpcGAnKTtcbiAgICB9XG4gICAgaWYgKHBhdGhzVG9WYWxpZGF0ZSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IHNldCBib3RoIGB2YWxpZGF0ZUFsbFBhdGhzYCBhbmQgYHBhdGhzVG9WYWxpZGF0ZWAnKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHBhdGhzVG9WYWxpZGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBpc09uZVBhdGhPbmx5ID0gcGF0aHNUb1ZhbGlkYXRlLmluZGV4T2YoJyAnKSA9PT0gLTE7XG4gICAgcGF0aHNUb1ZhbGlkYXRlID0gaXNPbmVQYXRoT25seSA/IFtwYXRoc1RvVmFsaWRhdGVdIDogcGF0aHNUb1ZhbGlkYXRlLnNwbGl0KCcgJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHBhdGhzVG9Ta2lwID09PSAnc3RyaW5nJyAmJiBwYXRoc1RvU2tpcC5pbmRleE9mKCcgJykgIT09IC0xKSB7XG4gICAgcGF0aHNUb1NraXAgPSBwYXRoc1RvU2tpcC5zcGxpdCgnICcpO1xuICB9XG5cbiAgLy8gb25seSB2YWxpZGF0ZSByZXF1aXJlZCBmaWVsZHMgd2hlbiBuZWNlc3NhcnlcbiAgbGV0IHBhdGhzO1xuICBsZXQgc2tpcFNjaGVtYVZhbGlkYXRvcnM7XG4gIGlmICh2YWxpZGF0ZUFsbFBhdGhzKSB7XG4gICAgcGF0aHMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHRoaXMuJF9fc2NoZW1hLnBhdGhzKSk7XG4gICAgLy8gZ2gtNjYxOiBpZiBhIHdob2xlIGFycmF5IGlzIG1vZGlmaWVkLCBtYWtlIHN1cmUgdG8gcnVuIHZhbGlkYXRpb24gb24gYWxsXG4gICAgLy8gdGhlIGNoaWxkcmVuIGFzIHdlbGxcbiAgICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICAgIGNvbnN0IHNjaGVtYVR5cGUgPSB0aGlzLiRfX3NjaGVtYS5wYXRoKHBhdGgpO1xuICAgICAgaWYgKCFzY2hlbWFUeXBlIHx8ICFzY2hlbWFUeXBlLiRpc01vbmdvb3NlQXJyYXkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWwgPSB0aGlzLiRfX2dldFZhbHVlKHBhdGgpO1xuICAgICAgaWYgKCF2YWwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBfcHVzaE5lc3RlZEFycmF5UGF0aHModmFsLCBwYXRocywgcGF0aCk7XG4gICAgfVxuICAgIHBhdGhzID0gWy4uLnBhdGhzXTtcbiAgICBza2lwU2NoZW1hVmFsaWRhdG9ycyA9IHt9O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHBhdGhEZXRhaWxzID0gX2dldFBhdGhzVG9WYWxpZGF0ZSh0aGlzLCBwYXRoc1RvVmFsaWRhdGUsIHBhdGhzVG9Ta2lwKTtcbiAgICBwYXRocyA9IHNob3VsZFZhbGlkYXRlTW9kaWZpZWRPbmx5ID9cbiAgICAgIHBhdGhEZXRhaWxzWzBdLmZpbHRlcigocGF0aCkgPT4gdGhpcy4kaXNNb2RpZmllZChwYXRoKSkgOlxuICAgICAgcGF0aERldGFpbHNbMF07XG4gICAgc2tpcFNjaGVtYVZhbGlkYXRvcnMgPSBwYXRoRGV0YWlsc1sxXTtcbiAgfVxuXG4gIGNvbnN0IHZhbGlkYXRpbmcgPSB7fTtcblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gcGF0aHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBjb25zdCBwYXRoID0gcGF0aHNbaV07XG5cbiAgICBpZiAodmFsaWRhdGluZ1twYXRoXSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFsaWRhdGluZ1twYXRoXSA9IHRydWU7XG5cbiAgICBjb25zdCBwID0gX3RoaXMuJF9fc2NoZW1hLnBhdGgocGF0aCk7XG4gICAgaWYgKCFwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCFfdGhpcy4kaXNWYWxpZChwYXRoKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsID0gX3RoaXMuJF9fZ2V0VmFsdWUocGF0aCk7XG4gICAgY29uc3QgZXJyID0gcC5kb1ZhbGlkYXRlU3luYyh2YWwsIF90aGlzLCB7XG4gICAgICBza2lwU2NoZW1hVmFsaWRhdG9yczogc2tpcFNjaGVtYVZhbGlkYXRvcnNbcGF0aF0sXG4gICAgICBwYXRoOiBwYXRoLFxuICAgICAgdmFsaWRhdGVNb2RpZmllZE9ubHk6IHNob3VsZFZhbGlkYXRlTW9kaWZpZWRPbmx5LFxuICAgICAgdmFsaWRhdGVBbGxQYXRoc1xuICAgIH0pO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGNvbnN0IGlzU3ViZG9jID0gcC4kaXNTaW5nbGVOZXN0ZWQgfHxcbiAgICAgICAgcC4kaXNBcnJheVN1YmRvY3VtZW50IHx8XG4gICAgICAgIHAuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5O1xuICAgICAgaWYgKGlzU3ViZG9jICYmIGVyciBpbnN0YW5jZW9mIFZhbGlkYXRpb25FcnJvcikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIF90aGlzLmludmFsaWRhdGUocGF0aCwgZXJyLCB1bmRlZmluZWQsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGVyciA9IF90aGlzLiRfXy52YWxpZGF0aW9uRXJyb3I7XG4gIF90aGlzLiRfXy52YWxpZGF0aW9uRXJyb3IgPSB1bmRlZmluZWQ7XG4gIF90aGlzLiRlbWl0KCd2YWxpZGF0ZScsIF90aGlzKTtcbiAgX3RoaXMuY29uc3RydWN0b3IuZW1pdCgndmFsaWRhdGUnLCBfdGhpcyk7XG5cbiAgaWYgKGVycikge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGVyci5lcnJvcnMpIHtcbiAgICAgIC8vIE1ha2Ugc3VyZSBjYXN0IGVycm9ycyBwZXJzaXN0XG4gICAgICBpZiAoZXJyLmVycm9yc1trZXldIGluc3RhbmNlb2YgTW9uZ29vc2VFcnJvci5DYXN0RXJyb3IpIHtcbiAgICAgICAgX3RoaXMuaW52YWxpZGF0ZShrZXksIGVyci5lcnJvcnNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVycjtcbn07XG5cbi8qKlxuICogTWFya3MgYSBwYXRoIGFzIGludmFsaWQsIGNhdXNpbmcgdmFsaWRhdGlvbiB0byBmYWlsLlxuICpcbiAqIFRoZSBgZXJyb3JNc2dgIGFyZ3VtZW50IHdpbGwgYmVjb21lIHRoZSBtZXNzYWdlIG9mIHRoZSBgVmFsaWRhdGlvbkVycm9yYC5cbiAqXG4gKiBUaGUgYHZhbHVlYCBhcmd1bWVudCAoaWYgcGFzc2VkKSB3aWxsIGJlIGF2YWlsYWJsZSB0aHJvdWdoIHRoZSBgVmFsaWRhdGlvbkVycm9yLnZhbHVlYCBwcm9wZXJ0eS5cbiAqXG4gKiAgICAgZG9jLmludmFsaWRhdGUoJ3NpemUnLCAnbXVzdCBiZSBsZXNzIHRoYW4gMjAnLCAxNCk7XG4gKlxuICogICAgIGRvYy52YWxpZGF0ZShmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyhlcnIpXG4gKiAgICAgICAvLyBwcmludHNcbiAqICAgICAgIHsgbWVzc2FnZTogJ1ZhbGlkYXRpb24gZmFpbGVkJyxcbiAqICAgICAgICAgbmFtZTogJ1ZhbGlkYXRpb25FcnJvcicsXG4gKiAgICAgICAgIGVycm9yczpcbiAqICAgICAgICAgIHsgc2l6ZTpcbiAqICAgICAgICAgICAgIHsgbWVzc2FnZTogJ211c3QgYmUgbGVzcyB0aGFuIDIwJyxcbiAqICAgICAgICAgICAgICAgbmFtZTogJ1ZhbGlkYXRvckVycm9yJyxcbiAqICAgICAgICAgICAgICAgcGF0aDogJ3NpemUnLFxuICogICAgICAgICAgICAgICB0eXBlOiAndXNlciBkZWZpbmVkJyxcbiAqICAgICAgICAgICAgICAgdmFsdWU6IDE0IH0gfSB9XG4gKiAgICAgfSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0aGUgZmllbGQgdG8gaW52YWxpZGF0ZS4gRm9yIGFycmF5IGVsZW1lbnRzLCB1c2UgdGhlIGBhcnJheS5pLmZpZWxkYCBzeW50YXgsIHdoZXJlIGBpYCBpcyB0aGUgMC1iYXNlZCBpbmRleCBpbiB0aGUgYXJyYXkuXG4gKiBAcGFyYW0ge1N0cmluZ3xFcnJvcn0gZXJyIHRoZSBlcnJvciB3aGljaCBzdGF0ZXMgdGhlIHJlYXNvbiBgcGF0aGAgd2FzIGludmFsaWRcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xOdW1iZXJ8YW55fSB2YWwgb3B0aW9uYWwgaW52YWxpZCB2YWx1ZVxuICogQHBhcmFtIHtTdHJpbmd9IFtraW5kXSBvcHRpb25hbCBga2luZGAgcHJvcGVydHkgZm9yIHRoZSBlcnJvclxuICogQHJldHVybiB7VmFsaWRhdGlvbkVycm9yfSB0aGUgY3VycmVudCBWYWxpZGF0aW9uRXJyb3IsIHdpdGggYWxsIGN1cnJlbnRseSBpbnZhbGlkYXRlZCBwYXRoc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uKHBhdGgsIGVyciwgdmFsLCBraW5kKSB7XG4gIGlmICghdGhpcy4kX18udmFsaWRhdGlvbkVycm9yKSB7XG4gICAgdGhpcy4kX18udmFsaWRhdGlvbkVycm9yID0gbmV3IFZhbGlkYXRpb25FcnJvcih0aGlzKTtcbiAgfVxuXG4gIGlmICh0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3IuZXJyb3JzW3BhdGhdKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFlcnIgfHwgdHlwZW9mIGVyciA9PT0gJ3N0cmluZycpIHtcbiAgICBlcnIgPSBuZXcgVmFsaWRhdG9yRXJyb3Ioe1xuICAgICAgcGF0aDogcGF0aCxcbiAgICAgIG1lc3NhZ2U6IGVycixcbiAgICAgIHR5cGU6IGtpbmQgfHwgJ3VzZXIgZGVmaW5lZCcsXG4gICAgICB2YWx1ZTogdmFsXG4gICAgfSk7XG4gIH1cblxuICBpZiAodGhpcy4kX18udmFsaWRhdGlvbkVycm9yID09PSBlcnIpIHtcbiAgICByZXR1cm4gdGhpcy4kX18udmFsaWRhdGlvbkVycm9yO1xuICB9XG5cbiAgdGhpcy4kX18udmFsaWRhdGlvbkVycm9yLmFkZEVycm9yKHBhdGgsIGVycik7XG4gIHJldHVybiB0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3I7XG59O1xuXG4vKipcbiAqIE1hcmtzIGEgcGF0aCBhcyB2YWxpZCwgcmVtb3ZpbmcgZXhpc3RpbmcgdmFsaWRhdGlvbiBlcnJvcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdGhlIGZpZWxkIHRvIG1hcmsgYXMgdmFsaWRcbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICogQG1ldGhvZCAkbWFya1ZhbGlkXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRtYXJrVmFsaWQgPSBmdW5jdGlvbihwYXRoKSB7XG4gIGlmICghdGhpcy4kX18udmFsaWRhdGlvbkVycm9yIHx8ICF0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3IuZXJyb3JzW3BhdGhdKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZGVsZXRlIHRoaXMuJF9fLnZhbGlkYXRpb25FcnJvci5lcnJvcnNbcGF0aF07XG4gIGlmIChPYmplY3Qua2V5cyh0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3IuZXJyb3JzKS5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3IgPSBudWxsO1xuICB9XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9tYXJrVmFsaWRTdWJwYXRocyhkb2MsIHBhdGgpIHtcbiAgaWYgKCFkb2MuJF9fLnZhbGlkYXRpb25FcnJvcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkb2MuJF9fLnZhbGlkYXRpb25FcnJvci5lcnJvcnMpO1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgaWYgKGtleS5zdGFydHNXaXRoKHBhdGggKyAnLicpKSB7XG4gICAgICBkZWxldGUgZG9jLiRfXy52YWxpZGF0aW9uRXJyb3IuZXJyb3JzW2tleV07XG4gICAgfVxuICB9XG4gIGlmIChPYmplY3Qua2V5cyhkb2MuJF9fLnZhbGlkYXRpb25FcnJvci5lcnJvcnMpLmxlbmd0aCA9PT0gMCkge1xuICAgIGRvYy4kX18udmFsaWRhdGlvbkVycm9yID0gbnVsbDtcbiAgfVxufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9jaGVja0ltbXV0YWJsZVN1YnBhdGhzKHN1YmRvYywgc2NoZW1hdHlwZSwgcHJpb3JWYWwpIHtcbiAgY29uc3Qgc2NoZW1hID0gc2NoZW1hdHlwZS5zY2hlbWE7XG4gIGlmIChzY2hlbWEgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjaGVtYS5wYXRocykpIHtcbiAgICBjb25zdCBwYXRoID0gc2NoZW1hLnBhdGhzW2tleV07XG4gICAgaWYgKHBhdGguJGltbXV0YWJsZVNldHRlciA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3Qgb2xkVmFsID0gcHJpb3JWYWwgPT0gbnVsbCA/IHZvaWQgMCA6IHByaW9yVmFsLiRfX2dldFZhbHVlKGtleSk7XG4gICAgLy8gQ2FsbGluZyBpbW11dGFibGVTZXR0ZXIgd2l0aCBgb2xkVmFsYCBldmVuIHRob3VnaCBpdCBleHBlY3RzIGBuZXdWYWxgXG4gICAgLy8gaXMgaW50ZW50aW9uYWwuIFRoYXQncyBiZWNhdXNlIGAkaW1tdXRhYmxlU2V0dGVyYCBjb21wYXJlcyBpdHMgcGFyYW1cbiAgICAvLyB0byB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICBwYXRoLiRpbW11dGFibGVTZXR0ZXIuY2FsbChzdWJkb2MsIG9sZFZhbCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTYXZlcyB0aGlzIGRvY3VtZW50IGJ5IGluc2VydGluZyBhIG5ldyBkb2N1bWVudCBpbnRvIHRoZSBkYXRhYmFzZSBpZiBbZG9jdW1lbnQuaXNOZXddKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudC5wcm90b3R5cGUuaXNOZXcoKSkgaXMgYHRydWVgLFxuICogb3Igc2VuZHMgYW4gW3VwZGF0ZU9uZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS51cGRhdGVPbmUoKSkgb3BlcmF0aW9uICoqb25seSoqIHdpdGggdGhlIG1vZGlmaWNhdGlvbnMgdG8gdGhlIGRhdGFiYXNlLCBpdCBkb2VzIG5vdCByZXBsYWNlIHRoZSB3aG9sZSBkb2N1bWVudCBpbiB0aGUgbGF0dGVyIGNhc2UuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBwcm9kdWN0LnNvbGQgPSBEYXRlLm5vdygpO1xuICogICAgIHByb2R1Y3QgPSBhd2FpdCBwcm9kdWN0LnNhdmUoKTtcbiAqXG4gKiBJZiBzYXZlIGlzIHN1Y2Nlc3NmdWwsIHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgZnVsZmlsbCB3aXRoIHRoZSBkb2N1bWVudFxuICogc2F2ZWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBuZXdQcm9kdWN0ID0gYXdhaXQgcHJvZHVjdC5zYXZlKCk7XG4gKiAgICAgbmV3UHJvZHVjdCA9PT0gcHJvZHVjdDsgLy8gdHJ1ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9ucyBvcHRpb25hbCBvcHRpb25zXG4gKiBAcGFyYW0ge1Nlc3Npb259IFtvcHRpb25zLnNlc3Npb249bnVsbF0gdGhlIFtzZXNzaW9uXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvc2VydmVyLXNlc3Npb25zLykgYXNzb2NpYXRlZCB3aXRoIHRoaXMgc2F2ZSBvcGVyYXRpb24uIElmIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvIHRoZSBbZG9jdW1lbnQncyBhc3NvY2lhdGVkIHNlc3Npb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudC5wcm90b3R5cGUuJHNlc3Npb24oKSkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuc2FmZV0gKERFUFJFQ0FURUQpIG92ZXJyaWRlcyBbc2NoZW1hJ3Mgc2FmZSBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3NhZmUpLiBVc2UgdGhlIGB3YCBvcHRpb24gaW5zdGVhZC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudmFsaWRhdGVCZWZvcmVTYXZlXSBzZXQgdG8gZmFsc2UgdG8gc2F2ZSB3aXRob3V0IHZhbGlkYXRpbmcuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnZhbGlkYXRlTW9kaWZpZWRPbmx5PWZhbHNlXSBJZiBgdHJ1ZWAsIE1vbmdvb3NlIHdpbGwgb25seSB2YWxpZGF0ZSBtb2RpZmllZCBwYXRocywgYXMgb3Bwb3NlZCB0byBtb2RpZmllZCBwYXRocyBhbmQgYHJlcXVpcmVkYCBwYXRocy5cbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW29wdGlvbnMud10gc2V0IHRoZSBbd3JpdGUgY29uY2Vybl0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vI3ctb3B0aW9uKS4gT3ZlcnJpZGVzIHRoZSBbc2NoZW1hLWxldmVsIGB3cml0ZUNvbmNlcm5gIG9wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjd3JpdGVDb25jZXJuKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5qXSBzZXQgdG8gdHJ1ZSBmb3IgTW9uZ29EQiB0byB3YWl0IHVudGlsIHRoaXMgYHNhdmUoKWAgaGFzIGJlZW4gW2pvdXJuYWxlZCBiZWZvcmUgcmVzb2x2aW5nIHRoZSByZXR1cm5lZCBwcm9taXNlXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvd3JpdGUtY29uY2Vybi8jai1vcHRpb24pLiBPdmVycmlkZXMgdGhlIFtzY2hlbWEtbGV2ZWwgYHdyaXRlQ29uY2VybmAgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN3cml0ZUNvbmNlcm4pXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud3RpbWVvdXRdIHNldHMgYSBbdGltZW91dCBmb3IgdGhlIHdyaXRlIGNvbmNlcm5dKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLyN3dGltZW91dCkuIE92ZXJyaWRlcyB0aGUgW3NjaGVtYS1sZXZlbCBgd3JpdGVDb25jZXJuYCBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3dyaXRlQ29uY2VybikuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNoZWNrS2V5cz10cnVlXSB0aGUgTW9uZ29EQiBkcml2ZXIgcHJldmVudHMgeW91IGZyb20gc2F2aW5nIGtleXMgdGhhdCBzdGFydCB3aXRoICckJyBvciBjb250YWluICcuJyBieSBkZWZhdWx0LiBTZXQgdGhpcyBvcHRpb24gdG8gYGZhbHNlYCB0byBza2lwIHRoYXQgY2hlY2suIFNlZSBbcmVzdHJpY3Rpb25zIG9uIGZpZWxkIG5hbWVzXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbGltaXRzLyNSZXN0cmljdGlvbnMtb24tRmllbGQtTmFtZXMpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRpbWVzdGFtcHM9dHJ1ZV0gaWYgYGZhbHNlYCBhbmQgW3RpbWVzdGFtcHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3RpbWVzdGFtcHMpIGFyZSBlbmFibGVkLCBza2lwIHRpbWVzdGFtcHMgZm9yIHRoaXMgYHNhdmUoKWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dIG9wdGlvbmFsIGNhbGxiYWNrXG4gKiBAbWV0aG9kIHNhdmVcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKiBAdGhyb3dzIHtEb2N1bWVudE5vdEZvdW5kRXJyb3J9IGlmIHRoaXMgW3NhdmUgdXBkYXRlcyBhbiBleGlzdGluZyBkb2N1bWVudF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS5pc05ldygpKSBidXQgdGhlIGRvY3VtZW50IGRvZXNuJ3QgZXhpc3QgaW4gdGhlIGRhdGFiYXNlLiBGb3IgZXhhbXBsZSwgeW91IHdpbGwgZ2V0IHRoaXMgZXJyb3IgaWYgdGhlIGRvY3VtZW50IGlzIFtkZWxldGVkIGJldHdlZW4gd2hlbiB5b3UgcmV0cmlldmVkIHRoZSBkb2N1bWVudCBhbmQgd2hlbiB5b3Ugc2F2ZWQgaXRdKGRvY3VtZW50cy5odG1sI3VwZGF0aW5nKS5cbiAqIEByZXR1cm4ge1Byb21pc2V8dW5kZWZpbmVkfSBSZXR1cm5zIHVuZGVmaW5lZCBpZiB1c2VkIHdpdGggY2FsbGJhY2sgb3IgYSBQcm9taXNlIG90aGVyd2lzZS5cbiAqIEBhcGkgcHVibGljXG4gKiBAc2VlIG1pZGRsZXdhcmUgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL21pZGRsZXdhcmUuaHRtbFxuICovXG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgcGF0aCBpcyBpbnZhbGlkXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW119IFtwYXRoXSB0aGUgZmllbGQgdG8gY2hlY2suIElmIHVuc2V0IHdpbGwgYWx3YXlzIHJldHVybiBcImZhbHNlXCJcbiAqIEBtZXRob2QgJGlzVmFsaWRcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJGlzVmFsaWQgPSBmdW5jdGlvbihwYXRoKSB7XG4gIGlmICh0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3IgPT0gbnVsbCB8fCBPYmplY3Qua2V5cyh0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3IuZXJyb3JzKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHBhdGguaW5kZXhPZignICcpICE9PSAtMSkge1xuICAgIHBhdGggPSBwYXRoLnNwbGl0KCcgJyk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0aCkpIHtcbiAgICByZXR1cm4gcGF0aC5zb21lKHAgPT4gdGhpcy4kX18udmFsaWRhdGlvbkVycm9yLmVycm9yc1twXSA9PSBudWxsKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3IuZXJyb3JzW3BhdGhdID09IG51bGw7XG59O1xuXG4vKipcbiAqIFJlc2V0cyB0aGUgaW50ZXJuYWwgbW9kaWZpZWQgc3RhdGUgb2YgdGhpcyBkb2N1bWVudC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqIEByZXR1cm4ge0RvY3VtZW50fSB0aGlzXG4gKiBAbWV0aG9kICRfX3Jlc2V0XG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kX19yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICBsZXQgX3RoaXMgPSB0aGlzO1xuXG4gIC8vIFNraXAgZm9yIHN1YmRvY3VtZW50c1xuICBjb25zdCBzdWJkb2NzID0gdGhpcy4kcGFyZW50KCkgPT09IHRoaXMgPyB0aGlzLiRnZXRBbGxTdWJkb2NzKCkgOiBbXTtcbiAgY29uc3QgcmVzZXRBcnJheXMgPSBuZXcgU2V0KCk7XG4gIGZvciAoY29uc3Qgc3ViZG9jIG9mIHN1YmRvY3MpIHtcbiAgICBjb25zdCBmdWxsUGF0aFdpdGhJbmRleGVzID0gc3ViZG9jLiRfX2Z1bGxQYXRoV2l0aEluZGV4ZXMoKTtcbiAgICBzdWJkb2MuJF9fcmVzZXQoKTtcbiAgICBpZiAodGhpcy5pc01vZGlmaWVkKGZ1bGxQYXRoV2l0aEluZGV4ZXMpIHx8IGlzUGFyZW50SW5pdChmdWxsUGF0aFdpdGhJbmRleGVzKSkge1xuICAgICAgaWYgKHN1YmRvYy4kaXNEb2N1bWVudEFycmF5RWxlbWVudCkge1xuICAgICAgICByZXNldEFycmF5cy5hZGQoc3ViZG9jLnBhcmVudEFycmF5KCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gc3ViZG9jLiRwYXJlbnQoKTtcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gdGhpcykge1xuICAgICAgICAgIHRoaXMuJF9fLmFjdGl2ZVBhdGhzLmNsZWFyUGF0aChzdWJkb2MuJGJhc2VQYXRoKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJlbnQgIT0gbnVsbCAmJiBwYXJlbnQuJGlzU3ViZG9jdW1lbnQpIHtcbiAgICAgICAgICAvLyBJZiBtYXAgcGF0aCB1bmRlcm5lYXRoIHN1YmRvY3VtZW50LCBtYXkgZW5kIHVwIHdpdGggYSBjYXNlIHdoZXJlXG4gICAgICAgICAgLy8gbWFwIHBhdGggaXMgbW9kaWZpZWQgYnV0IHBhcmVudCBzdGlsbCBuZWVkcyB0byBiZSByZXNldC4gU2VlIGdoLTEwMjk1XG4gICAgICAgICAgcGFyZW50LiRfX3Jlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKGNvbnN0IGFycmF5IG9mIHJlc2V0QXJyYXlzKSB7XG4gICAgdGhpcy4kX18uYWN0aXZlUGF0aHMuY2xlYXJQYXRoKGFycmF5LiRwYXRoKCkpO1xuICAgIGFycmF5W2FycmF5QXRvbWljc0JhY2t1cFN5bWJvbF0gPSBhcnJheVthcnJheUF0b21pY3NTeW1ib2xdO1xuICAgIGFycmF5W2FycmF5QXRvbWljc1N5bWJvbF0gPSB7fTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUGFyZW50SW5pdChwYXRoKSB7XG4gICAgcGF0aCA9IHBhdGguaW5kZXhPZignLicpID09PSAtMSA/IFtwYXRoXSA6IHBhdGguc3BsaXQoJy4nKTtcbiAgICBsZXQgY3VyID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgKytpKSB7XG4gICAgICBjdXIgKz0gKGN1ci5sZW5ndGggPyAnLicgOiAnJykgKyBwYXRoW2ldO1xuICAgICAgaWYgKF90aGlzLiRfXy5hY3RpdmVQYXRoc1tjdXJdID09PSAnaW5pdCcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gY2xlYXIgYXRvbWljc1xuICB0aGlzLiRfX2RpcnR5KCkuZm9yRWFjaChmdW5jdGlvbihkaXJ0KSB7XG4gICAgY29uc3QgdHlwZSA9IGRpcnQudmFsdWU7XG5cbiAgICBpZiAodHlwZSAmJiB0eXBlW2FycmF5QXRvbWljc1N5bWJvbF0pIHtcbiAgICAgIHR5cGVbYXJyYXlBdG9taWNzQmFja3VwU3ltYm9sXSA9IHR5cGVbYXJyYXlBdG9taWNzU3ltYm9sXTtcbiAgICAgIHR5cGVbYXJyYXlBdG9taWNzU3ltYm9sXSA9IHt9O1xuICAgIH1cbiAgfSk7XG5cbiAgdGhpcy4kX18uYmFja3VwID0ge307XG4gIHRoaXMuJF9fLmJhY2t1cC5hY3RpdmVQYXRocyA9IHtcbiAgICBtb2RpZnk6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuJF9fLmFjdGl2ZVBhdGhzLmdldFN0YXRlUGF0aHMoJ21vZGlmeScpKSxcbiAgICBkZWZhdWx0OiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiRfXy5hY3RpdmVQYXRocy5nZXRTdGF0ZVBhdGhzKCdkZWZhdWx0JykpXG4gIH07XG4gIHRoaXMuJF9fLmJhY2t1cC52YWxpZGF0aW9uRXJyb3IgPSB0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3I7XG4gIHRoaXMuJF9fLmJhY2t1cC5lcnJvcnMgPSB0aGlzLiRlcnJvcnM7XG5cbiAgLy8gQ2xlYXIgJ2RpcnR5JyBjYWNoZVxuICB0aGlzLiRfXy5hY3RpdmVQYXRocy5jbGVhcignbW9kaWZ5Jyk7XG4gIHRoaXMuJF9fLmFjdGl2ZVBhdGhzLmNsZWFyKCdkZWZhdWx0Jyk7XG4gIHRoaXMuJF9fLnZhbGlkYXRpb25FcnJvciA9IHVuZGVmaW5lZDtcbiAgdGhpcy4kZXJyb3JzID0gdW5kZWZpbmVkO1xuICBfdGhpcyA9IHRoaXM7XG4gIHRoaXMuJF9fc2NoZW1hLnJlcXVpcmVkUGF0aHMoKS5mb3JFYWNoKGZ1bmN0aW9uKHBhdGgpIHtcbiAgICBfdGhpcy4kX18uYWN0aXZlUGF0aHMucmVxdWlyZShwYXRoKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kX191bmRvUmVzZXQgPSBmdW5jdGlvbiAkX191bmRvUmVzZXQoKSB7XG4gIGlmICh0aGlzLiRfXy5iYWNrdXAgPT0gbnVsbCB8fCB0aGlzLiRfXy5iYWNrdXAuYWN0aXZlUGF0aHMgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuJF9fLmFjdGl2ZVBhdGhzLnN0YXRlcy5tb2RpZnkgPSB0aGlzLiRfXy5iYWNrdXAuYWN0aXZlUGF0aHMubW9kaWZ5O1xuICB0aGlzLiRfXy5hY3RpdmVQYXRocy5zdGF0ZXMuZGVmYXVsdCA9IHRoaXMuJF9fLmJhY2t1cC5hY3RpdmVQYXRocy5kZWZhdWx0O1xuXG4gIHRoaXMuJF9fLnZhbGlkYXRpb25FcnJvciA9IHRoaXMuJF9fLmJhY2t1cC52YWxpZGF0aW9uRXJyb3I7XG4gIHRoaXMuJGVycm9ycyA9IHRoaXMuJF9fLmJhY2t1cC5lcnJvcnM7XG5cbiAgZm9yIChjb25zdCBkaXJ0IG9mIHRoaXMuJF9fZGlydHkoKSkge1xuICAgIGNvbnN0IHR5cGUgPSBkaXJ0LnZhbHVlO1xuXG4gICAgaWYgKHR5cGUgJiYgdHlwZVthcnJheUF0b21pY3NTeW1ib2xdICYmIHR5cGVbYXJyYXlBdG9taWNzQmFja3VwU3ltYm9sXSkge1xuICAgICAgdHlwZVthcnJheUF0b21pY3NTeW1ib2xdID0gdHlwZVthcnJheUF0b21pY3NCYWNrdXBTeW1ib2xdO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoY29uc3Qgc3ViZG9jIG9mIHRoaXMuJGdldEFsbFN1YmRvY3MoKSkge1xuICAgIHN1YmRvYy4kX191bmRvUmVzZXQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgZG9jdW1lbnRzIGRpcnR5IHBhdGhzIC8gdmFscy5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHJpdmF0ZVxuICogQG1ldGhvZCAkX19kaXJ0eVxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJF9fZGlydHkgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICBsZXQgYWxsID0gdGhpcy4kX18uYWN0aXZlUGF0aHMubWFwKCdtb2RpZnknLCBmdW5jdGlvbihwYXRoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHBhdGgsXG4gICAgICB2YWx1ZTogX3RoaXMuJF9fZ2V0VmFsdWUocGF0aCksXG4gICAgICBzY2hlbWE6IF90aGlzLiRfX3BhdGgocGF0aClcbiAgICB9O1xuICB9KTtcblxuICAvLyBnaC0yNTU4OiBpZiB3ZSBoYWQgdG8gc2V0IGEgZGVmYXVsdCBhbmQgdGhlIHZhbHVlIGlzIG5vdCB1bmRlZmluZWQsXG4gIC8vIHdlIGhhdmUgdG8gc2F2ZSBhcyB3ZWxsXG4gIGFsbCA9IGFsbC5jb25jYXQodGhpcy4kX18uYWN0aXZlUGF0aHMubWFwKCdkZWZhdWx0JywgZnVuY3Rpb24ocGF0aCkge1xuICAgIGlmIChwYXRoID09PSAnX2lkJyB8fCBfdGhpcy4kX19nZXRWYWx1ZShwYXRoKSA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBwYXRoLFxuICAgICAgdmFsdWU6IF90aGlzLiRfX2dldFZhbHVlKHBhdGgpLFxuICAgICAgc2NoZW1hOiBfdGhpcy4kX19wYXRoKHBhdGgpXG4gICAgfTtcbiAgfSkpO1xuXG4gIGNvbnN0IGFsbFBhdGhzID0gbmV3IE1hcChhbGwuZmlsdGVyKChlbCkgPT4gZWwgIT0gbnVsbCkubWFwKChlbCkgPT4gW2VsLnBhdGgsIGVsLnZhbHVlXSkpO1xuICAvLyBJZ25vcmUgXCJmb28uYVwiIGlmIFwiZm9vXCIgaXMgZGlydHkgYWxyZWFkeS5cbiAgY29uc3QgbWluaW1hbCA9IFtdO1xuXG4gIGFsbC5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgdG9wID0gbnVsbDtcblxuICAgIGNvbnN0IGFycmF5ID0gcGFyZW50UGF0aHMoaXRlbS5wYXRoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgaWYgKGFsbFBhdGhzLmhhcyhhcnJheVtpXSkpIHtcbiAgICAgICAgdG9wID0gYWxsUGF0aHMuZ2V0KGFycmF5W2ldKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0b3AgPT0gbnVsbCkge1xuICAgICAgbWluaW1hbC5wdXNoKGl0ZW0pO1xuICAgIH0gZWxzZSBpZiAodG9wICE9IG51bGwgJiZcbiAgICAgICAgdG9wW2FycmF5QXRvbWljc1N5bWJvbF0gIT0gbnVsbCAmJlxuICAgICAgICB0b3AuaGFzQXRvbWljcygpKSB7XG4gICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIHRvcCBsZXZlbCBNb25nb29zZUFycmF5c1xuICAgICAgLy8gdGhlIGB0b3BgIGFycmF5IGl0c2VsZiBhbmQgYSBzdWIgcGF0aCBvZiBgdG9wYCBhcmUgYmVpbmcgc2V0LlxuICAgICAgLy8gdGhlIG9ubHkgd2F5IHRvIGhvbm9yIGFsbCBvZiBib3RoIG1vZGlmaWNhdGlvbnMgaXMgdGhyb3VnaCBhICRzZXRcbiAgICAgIC8vIG9mIGVudGlyZSBhcnJheS5cbiAgICAgIHRvcFthcnJheUF0b21pY3NTeW1ib2xdID0ge307XG4gICAgICB0b3BbYXJyYXlBdG9taWNzU3ltYm9sXS4kc2V0ID0gdG9wO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBtaW5pbWFsO1xufTtcblxuLyoqXG4gKiBBc3NpZ25zL2NvbXBpbGVzIGBzY2hlbWFgIGludG8gdGhpcyBkb2N1bWVudHMgcHJvdG90eXBlLlxuICpcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBhcGkgcHJpdmF0ZVxuICogQG1ldGhvZCAkX19zZXRTY2hlbWFcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRfX3NldFNjaGVtYSA9IGZ1bmN0aW9uKHNjaGVtYSkge1xuICBjb21waWxlKHNjaGVtYS50cmVlLCB0aGlzLCB1bmRlZmluZWQsIHNjaGVtYS5vcHRpb25zKTtcblxuICAvLyBBcHBseSBkZWZhdWx0IGdldHRlcnMgaWYgdmlydHVhbCBkb2Vzbid0IGhhdmUgYW55IChnaC02MjYyKVxuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzY2hlbWEudmlydHVhbHMpKSB7XG4gICAgc2NoZW1hLnZpcnR1YWxzW2tleV0uX2FwcGx5RGVmYXVsdEdldHRlcnMoKTtcbiAgfVxuICBpZiAoc2NoZW1hLnBhdGgoJ3NjaGVtYScpID09IG51bGwpIHtcbiAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgfVxuICB0aGlzLiRfX3NjaGVtYSA9IHNjaGVtYTtcbiAgdGhpc1tkb2N1bWVudFNjaGVtYVN5bWJvbF0gPSBzY2hlbWE7XG59O1xuXG5cbi8qKlxuICogR2V0IGFjdGl2ZSBwYXRoIHRoYXQgd2VyZSBjaGFuZ2VkIGFuZCBhcmUgYXJyYXlzXG4gKlxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHByaXZhdGVcbiAqIEBtZXRob2QgJF9fZ2V0QXJyYXlQYXRoc1RvVmFsaWRhdGVcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRfX2dldEFycmF5UGF0aHNUb1ZhbGlkYXRlID0gZnVuY3Rpb24oKSB7XG4gIERvY3VtZW50QXJyYXkgfHwgKERvY3VtZW50QXJyYXkgPSByZXF1aXJlKCcuL3R5cGVzL2RvY3VtZW50QXJyYXknKSk7XG5cbiAgLy8gdmFsaWRhdGUgYWxsIGRvY3VtZW50IGFycmF5cy5cbiAgcmV0dXJuIHRoaXMuJF9fLmFjdGl2ZVBhdGhzXG4gICAgLm1hcCgnaW5pdCcsICdtb2RpZnknLCBmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gdGhpcy4kX19nZXRWYWx1ZShpKTtcbiAgICB9LmJpbmQodGhpcykpXG4gICAgLmZpbHRlcihmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiB2YWwgJiYgQXJyYXkuaXNBcnJheSh2YWwpICYmIHV0aWxzLmlzTW9uZ29vc2VEb2N1bWVudEFycmF5KHZhbCkgJiYgdmFsLmxlbmd0aDtcbiAgICB9KS5yZWR1Y2UoZnVuY3Rpb24oc2VlZCwgYXJyYXkpIHtcbiAgICAgIHJldHVybiBzZWVkLmNvbmNhdChhcnJheSk7XG4gICAgfSwgW10pXG4gICAgLmZpbHRlcihmdW5jdGlvbihkb2MpIHtcbiAgICAgIHJldHVybiBkb2M7XG4gICAgfSk7XG59O1xuXG5cbi8qKlxuICogR2V0IGFsbCBzdWJkb2NzIChieSBiZnMpXG4gKlxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCAkZ2V0QWxsU3ViZG9jc1xuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJGdldEFsbFN1YmRvY3MgPSBmdW5jdGlvbigpIHtcbiAgRG9jdW1lbnRBcnJheSB8fCAoRG9jdW1lbnRBcnJheSA9IHJlcXVpcmUoJy4vdHlwZXMvZG9jdW1lbnRBcnJheScpKTtcbiAgRW1iZWRkZWQgPSBFbWJlZGRlZCB8fCByZXF1aXJlKCcuL3R5cGVzL2FycmF5U3ViZG9jdW1lbnQnKTtcblxuICBmdW5jdGlvbiBkb2NSZWR1Y2VyKGRvYywgc2VlZCwgcGF0aCkge1xuICAgIGxldCB2YWwgPSBkb2M7XG4gICAgbGV0IGlzTmVzdGVkID0gZmFsc2U7XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIGlmIChkb2MgaW5zdGFuY2VvZiBEb2N1bWVudCAmJiBkb2NbZG9jdW1lbnRTY2hlbWFTeW1ib2xdLnBhdGhzW3BhdGhdKSB7XG4gICAgICAgIHZhbCA9IGRvYy5fZG9jW3BhdGhdO1xuICAgICAgfSBlbHNlIGlmIChkb2MgaW5zdGFuY2VvZiBEb2N1bWVudCAmJiBkb2NbZG9jdW1lbnRTY2hlbWFTeW1ib2xdLm5lc3RlZFtwYXRoXSkge1xuICAgICAgICB2YWwgPSBkb2MuX2RvY1twYXRoXTtcbiAgICAgICAgaXNOZXN0ZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gZG9jW3BhdGhdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodmFsIGluc3RhbmNlb2YgRW1iZWRkZWQpIHtcbiAgICAgIHNlZWQucHVzaCh2YWwpO1xuICAgIH0gZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICBzZWVkID0gQXJyYXkuZnJvbSh2YWwua2V5cygpKS5yZWR1Y2UoZnVuY3Rpb24oc2VlZCwgcGF0aCkge1xuICAgICAgICByZXR1cm4gZG9jUmVkdWNlcih2YWwuZ2V0KHBhdGgpLCBzZWVkLCBudWxsKTtcbiAgICAgIH0sIHNlZWQpO1xuICAgIH0gZWxzZSBpZiAodmFsICYmICFBcnJheS5pc0FycmF5KHZhbCkgJiYgdmFsLiRpc1NpbmdsZU5lc3RlZCkge1xuICAgICAgc2VlZCA9IE9iamVjdC5rZXlzKHZhbC5fZG9jKS5yZWR1Y2UoZnVuY3Rpb24oc2VlZCwgcGF0aCkge1xuICAgICAgICByZXR1cm4gZG9jUmVkdWNlcih2YWwsIHNlZWQsIHBhdGgpO1xuICAgICAgfSwgc2VlZCk7XG4gICAgICBzZWVkLnB1c2godmFsKTtcbiAgICB9IGVsc2UgaWYgKHZhbCAmJiB1dGlscy5pc01vbmdvb3NlRG9jdW1lbnRBcnJheSh2YWwpKSB7XG4gICAgICB2YWwuZm9yRWFjaChmdW5jdGlvbiBfZG9jUmVkdWNlKGRvYykge1xuICAgICAgICBpZiAoIWRvYyB8fCAhZG9jLl9kb2MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2VlZCA9IE9iamVjdC5rZXlzKGRvYy5fZG9jKS5yZWR1Y2UoZnVuY3Rpb24oc2VlZCwgcGF0aCkge1xuICAgICAgICAgIHJldHVybiBkb2NSZWR1Y2VyKGRvYy5fZG9jLCBzZWVkLCBwYXRoKTtcbiAgICAgICAgfSwgc2VlZCk7XG4gICAgICAgIGlmIChkb2MgaW5zdGFuY2VvZiBFbWJlZGRlZCkge1xuICAgICAgICAgIHNlZWQucHVzaChkb2MpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGlzTmVzdGVkICYmIHZhbCAhPSBudWxsKSB7XG4gICAgICBmb3IgKGNvbnN0IHBhdGggb2YgT2JqZWN0LmtleXModmFsKSkge1xuICAgICAgICBkb2NSZWR1Y2VyKHZhbCwgc2VlZCwgcGF0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWVkO1xuICB9XG5cbiAgY29uc3Qgc3ViRG9jcyA9IFtdO1xuICBmb3IgKGNvbnN0IHBhdGggb2YgT2JqZWN0LmtleXModGhpcy5fZG9jKSkge1xuICAgIGRvY1JlZHVjZXIodGhpcywgc3ViRG9jcywgcGF0aCk7XG4gIH1cblxuICByZXR1cm4gc3ViRG9jcztcbn07XG5cbi8qIVxuICogUnVucyBxdWV1ZWQgZnVuY3Rpb25zXG4gKi9cblxuZnVuY3Rpb24gYXBwbHlRdWV1ZShkb2MpIHtcbiAgY29uc3QgcSA9IGRvYy4kX19zY2hlbWEgJiYgZG9jLiRfX3NjaGVtYS5jYWxsUXVldWU7XG4gIGlmICghcS5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKGNvbnN0IHBhaXIgb2YgcSkge1xuICAgIGlmIChwYWlyWzBdICE9PSAncHJlJyAmJiBwYWlyWzBdICE9PSAncG9zdCcgJiYgcGFpclswXSAhPT0gJ29uJykge1xuICAgICAgZG9jW3BhaXJbMF1dLmFwcGx5KGRvYywgcGFpclsxXSk7XG4gICAgfVxuICB9XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiRfX2hhbmRsZVJlamVjdCA9IGZ1bmN0aW9uIGhhbmRsZVJlamVjdChlcnIpIHtcbiAgLy8gZW1pdCBvbiB0aGUgTW9kZWwgaWYgbGlzdGVuaW5nXG4gIGlmICh0aGlzLiRsaXN0ZW5lcnMoJ2Vycm9yJykubGVuZ3RoKSB7XG4gICAgdGhpcy4kZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9IGVsc2UgaWYgKHRoaXMuY29uc3RydWN0b3IubGlzdGVuZXJzICYmIHRoaXMuY29uc3RydWN0b3IubGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aCkge1xuICAgIHRoaXMuY29uc3RydWN0b3IuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG59O1xuXG4vKipcbiAqIEludGVybmFsIGhlbHBlciBmb3IgdG9PYmplY3QoKSBhbmQgdG9KU09OKCkgdGhhdCBkb2Vzbid0IG1hbmlwdWxhdGUgb3B0aW9uc1xuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICogQG1ldGhvZCAkdG9PYmplY3RcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLiR0b09iamVjdCA9IGZ1bmN0aW9uKG9wdGlvbnMsIGpzb24pIHtcbiAgbGV0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIHRyYW5zZm9ybTogdHJ1ZSxcbiAgICBmbGF0dGVuRGVjaW1hbHM6IHRydWVcbiAgfTtcblxuICBjb25zdCBwYXRoID0ganNvbiA/ICd0b0pTT04nIDogJ3RvT2JqZWN0JztcbiAgY29uc3QgYmFzZU9wdGlvbnMgPSB0aGlzLmNvbnN0cnVjdG9yICYmXG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5iYXNlICYmXG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5iYXNlLm9wdGlvbnMgJiZcbiAgICBnZXQodGhpcy5jb25zdHJ1Y3Rvci5iYXNlLm9wdGlvbnMsIHBhdGgpIHx8IHt9O1xuICBjb25zdCBzY2hlbWFPcHRpb25zID0gdGhpcy4kX19zY2hlbWEgJiYgdGhpcy4kX19zY2hlbWEub3B0aW9ucyB8fCB7fTtcbiAgLy8gbWVyZ2UgYmFzZSBkZWZhdWx0IG9wdGlvbnMgd2l0aCBTY2hlbWEncyBzZXQgZGVmYXVsdCBvcHRpb25zIGlmIGF2YWlsYWJsZS5cbiAgLy8gYGNsb25lYCBpcyBuZWNlc3NhcnkgaGVyZSBiZWNhdXNlIGB1dGlscy5vcHRpb25zYCBkaXJlY3RseSBtb2RpZmllcyB0aGUgc2Vjb25kIGlucHV0LlxuICBkZWZhdWx0T3B0aW9ucyA9IHsgLi4uZGVmYXVsdE9wdGlvbnMsIC4uLmJhc2VPcHRpb25zLCAuLi5zY2hlbWFPcHRpb25zW3BhdGhdIH07XG5cbiAgLy8gSWYgb3B0aW9ucyBkbyBub3QgZXhpc3Qgb3IgaXMgbm90IGFuIG9iamVjdCwgc2V0IGl0IHRvIGVtcHR5IG9iamVjdFxuICBvcHRpb25zID0gdXRpbHMuaXNQT0pPKG9wdGlvbnMpID8geyAuLi5vcHRpb25zIH0gOiB7fTtcbiAgb3B0aW9ucy5fY2FsbGVkV2l0aE9wdGlvbnMgPSBvcHRpb25zLl9jYWxsZWRXaXRoT3B0aW9ucyB8fCB7IC4uLm9wdGlvbnMgfTtcblxuICBsZXQgX21pbmltaXplO1xuICBpZiAob3B0aW9ucy5fY2FsbGVkV2l0aE9wdGlvbnMubWluaW1pemUgIT0gbnVsbCkge1xuICAgIF9taW5pbWl6ZSA9IG9wdGlvbnMubWluaW1pemU7XG4gIH0gZWxzZSBpZiAoZGVmYXVsdE9wdGlvbnMubWluaW1pemUgIT0gbnVsbCkge1xuICAgIF9taW5pbWl6ZSA9IGRlZmF1bHRPcHRpb25zLm1pbmltaXplO1xuICB9IGVsc2Uge1xuICAgIF9taW5pbWl6ZSA9IHNjaGVtYU9wdGlvbnMubWluaW1pemU7XG4gIH1cblxuICBsZXQgZmxhdHRlbk1hcHM7XG4gIGlmIChvcHRpb25zLl9jYWxsZWRXaXRoT3B0aW9ucy5mbGF0dGVuTWFwcyAhPSBudWxsKSB7XG4gICAgZmxhdHRlbk1hcHMgPSBvcHRpb25zLmZsYXR0ZW5NYXBzO1xuICB9IGVsc2UgaWYgKGRlZmF1bHRPcHRpb25zLmZsYXR0ZW5NYXBzICE9IG51bGwpIHtcbiAgICBmbGF0dGVuTWFwcyA9IGRlZmF1bHRPcHRpb25zLmZsYXR0ZW5NYXBzO1xuICB9IGVsc2Uge1xuICAgIGZsYXR0ZW5NYXBzID0gc2NoZW1hT3B0aW9ucy5mbGF0dGVuTWFwcztcbiAgfVxuXG4gIGxldCBmbGF0dGVuT2JqZWN0SWRzO1xuICBpZiAob3B0aW9ucy5fY2FsbGVkV2l0aE9wdGlvbnMuZmxhdHRlbk9iamVjdElkcyAhPSBudWxsKSB7XG4gICAgZmxhdHRlbk9iamVjdElkcyA9IG9wdGlvbnMuZmxhdHRlbk9iamVjdElkcztcbiAgfSBlbHNlIGlmIChkZWZhdWx0T3B0aW9ucy5mbGF0dGVuT2JqZWN0SWRzICE9IG51bGwpIHtcbiAgICBmbGF0dGVuT2JqZWN0SWRzID0gZGVmYXVsdE9wdGlvbnMuZmxhdHRlbk9iamVjdElkcztcbiAgfSBlbHNlIHtcbiAgICBmbGF0dGVuT2JqZWN0SWRzID0gc2NoZW1hT3B0aW9ucy5mbGF0dGVuT2JqZWN0SWRzO1xuICB9XG5cbiAgLy8gVGhlIG9yaWdpbmFsIG9wdGlvbnMgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byBgY2xvbmUoKWAuIEltcG9ydGFudCBiZWNhdXNlXG4gIC8vIGBjbG9uZSgpYCB3aWxsIHJlY3Vyc2l2ZWx5IGNhbGwgYCR0b09iamVjdCgpYCBvbiBlbWJlZGRlZCBkb2NzLCBzbyB3ZVxuICAvLyBuZWVkIHRoZSBvcmlnaW5hbCBvcHRpb25zIHRoZSB1c2VyIHBhc3NlZCBpbiwgcGx1cyBgX2lzTmVzdGVkYCBhbmRcbiAgLy8gYF9wYXJlbnRPcHRpb25zYCBmb3IgY2hlY2tpbmcgd2hldGhlciB3ZSBuZWVkIHRvIGRlcG9wdWxhdGUuXG4gIGNvbnN0IGNsb25lT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICBfaXNOZXN0ZWQ6IHRydWUsXG4gICAganNvbjoganNvbixcbiAgICBtaW5pbWl6ZTogX21pbmltaXplLFxuICAgIGZsYXR0ZW5NYXBzOiBmbGF0dGVuTWFwcyxcbiAgICBmbGF0dGVuT2JqZWN0SWRzOiBmbGF0dGVuT2JqZWN0SWRzLFxuICAgIF9zZWVuOiAob3B0aW9ucyAmJiBvcHRpb25zLl9zZWVuKSB8fCBuZXcgTWFwKClcbiAgfSk7XG5cbiAgaWYgKHV0aWxzLmhhc1VzZXJEZWZpbmVkUHJvcGVydHkob3B0aW9ucywgJ2dldHRlcnMnKSkge1xuICAgIGNsb25lT3B0aW9ucy5nZXR0ZXJzID0gb3B0aW9ucy5nZXR0ZXJzO1xuICB9XG4gIGlmICh1dGlscy5oYXNVc2VyRGVmaW5lZFByb3BlcnR5KG9wdGlvbnMsICd2aXJ0dWFscycpKSB7XG4gICAgY2xvbmVPcHRpb25zLnZpcnR1YWxzID0gb3B0aW9ucy52aXJ0dWFscztcbiAgfVxuXG4gIGNvbnN0IGRlcG9wdWxhdGUgPSBvcHRpb25zLmRlcG9wdWxhdGUgfHxcbiAgICAob3B0aW9ucy5fcGFyZW50T3B0aW9ucyAmJiBvcHRpb25zLl9wYXJlbnRPcHRpb25zLmRlcG9wdWxhdGUgfHwgZmFsc2UpO1xuICAvLyBfaXNOZXN0ZWQgd2lsbCBvbmx5IGJlIHRydWUgaWYgdGhpcyBpcyBub3QgdGhlIHRvcCBsZXZlbCBkb2N1bWVudCwgd2VcbiAgLy8gc2hvdWxkIG5ldmVyIGRlcG9wdWxhdGUgdGhlIHRvcC1sZXZlbCBkb2N1bWVudFxuICBpZiAoZGVwb3B1bGF0ZSAmJiBvcHRpb25zLl9pc05lc3RlZCAmJiB0aGlzLiRfXy53YXNQb3B1bGF0ZWQpIHtcbiAgICByZXR1cm4gY2xvbmUodGhpcy4kX18ud2FzUG9wdWxhdGVkLnZhbHVlIHx8IHRoaXMuX2lkLCBjbG9uZU9wdGlvbnMpO1xuICB9XG5cbiAgLy8gbWVyZ2UgZGVmYXVsdCBvcHRpb25zIHdpdGggaW5wdXQgb3B0aW9ucy5cbiAgb3B0aW9ucyA9IHsgLi4uZGVmYXVsdE9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgb3B0aW9ucy5faXNOZXN0ZWQgPSB0cnVlO1xuICBvcHRpb25zLmpzb24gPSBqc29uO1xuICBvcHRpb25zLm1pbmltaXplID0gX21pbmltaXplO1xuXG4gIGNsb25lT3B0aW9ucy5fcGFyZW50T3B0aW9ucyA9IG9wdGlvbnM7XG4gIGNsb25lT3B0aW9ucy5fc2tpcFNpbmdsZU5lc3RlZEdldHRlcnMgPSBmYWxzZTtcblxuICBjb25zdCBnZXR0ZXJzT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGNsb25lT3B0aW9ucyk7XG4gIGdldHRlcnNPcHRpb25zLl9za2lwU2luZ2xlTmVzdGVkR2V0dGVycyA9IHRydWU7XG5cbiAgLy8gcmVtZW1iZXIgdGhlIHJvb3QgdHJhbnNmb3JtIGZ1bmN0aW9uXG4gIC8vIHRvIHNhdmUgaXQgZnJvbSBiZWluZyBvdmVyd3JpdHRlbiBieSBzdWItdHJhbnNmb3JtIGZ1bmN0aW9uc1xuICBjb25zdCBvcmlnaW5hbFRyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuXG4gIGxldCByZXQgPSBjbG9uZSh0aGlzLl9kb2MsIGNsb25lT3B0aW9ucykgfHwge307XG5cbiAgaWYgKG9wdGlvbnMuZ2V0dGVycykge1xuICAgIGFwcGx5R2V0dGVycyh0aGlzLCByZXQsIGdldHRlcnNPcHRpb25zKTtcblxuICAgIGlmIChvcHRpb25zLm1pbmltaXplKSB7XG4gICAgICByZXQgPSBtaW5pbWl6ZShyZXQpIHx8IHt9O1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRpb25zLnZpcnR1YWxzIHx8IChvcHRpb25zLmdldHRlcnMgJiYgb3B0aW9ucy52aXJ0dWFscyAhPT0gZmFsc2UpKSB7XG4gICAgYXBwbHlWaXJ0dWFscyh0aGlzLCByZXQsIGdldHRlcnNPcHRpb25zLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnZlcnNpb25LZXkgPT09IGZhbHNlICYmIHRoaXMuJF9fc2NoZW1hLm9wdGlvbnMudmVyc2lvbktleSkge1xuICAgIGRlbGV0ZSByZXRbdGhpcy4kX19zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5XTtcbiAgfVxuXG4gIGxldCB0cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAvLyBJbiB0aGUgY2FzZSB3aGVyZSBhIHN1YmRvY3VtZW50IGhhcyBpdHMgb3duIHRyYW5zZm9ybSBmdW5jdGlvbiwgd2UgbmVlZCB0b1xuICAvLyBjaGVjayBhbmQgc2VlIGlmIHRoZSBwYXJlbnQgaGFzIGEgdHJhbnNmb3JtIChvcHRpb25zLnRyYW5zZm9ybSkgYW5kIGlmIHRoZVxuICAvLyBjaGlsZCBzY2hlbWEgaGFzIGEgdHJhbnNmb3JtICh0aGlzLnNjaGVtYS5vcHRpb25zLnRvT2JqZWN0KSBJbiB0aGlzIGNhc2UsXG4gIC8vIHdlIG5lZWQgdG8gYWRqdXN0IG9wdGlvbnMudHJhbnNmb3JtIHRvIGJlIHRoZSBjaGlsZCBzY2hlbWEncyB0cmFuc2Zvcm0gYW5kXG4gIC8vIG5vdCB0aGUgcGFyZW50IHNjaGVtYSdzXG4gIGlmICh0cmFuc2Zvcm0pIHtcbiAgICBhcHBseVNjaGVtYVR5cGVUcmFuc2Zvcm1zKHRoaXMsIHJldCk7XG4gIH1cblxuICBpZiAob3B0aW9ucy51c2VQcm9qZWN0aW9uKSB7XG4gICAgb21pdERlc2VsZWN0ZWRGaWVsZHModGhpcywgcmV0KTtcbiAgfVxuXG4gIGlmICh0cmFuc2Zvcm0gPT09IHRydWUgfHwgKHNjaGVtYU9wdGlvbnMudG9PYmplY3QgJiYgdHJhbnNmb3JtKSkge1xuICAgIGNvbnN0IG9wdHMgPSBvcHRpb25zLmpzb24gPyBzY2hlbWFPcHRpb25zLnRvSlNPTiA6IHNjaGVtYU9wdGlvbnMudG9PYmplY3Q7XG5cbiAgICBpZiAob3B0cykge1xuICAgICAgdHJhbnNmb3JtID0gKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMudHJhbnNmb3JtIDogb3B0cy50cmFuc2Zvcm0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLnRyYW5zZm9ybSA9IG9yaWdpbmFsVHJhbnNmb3JtO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCB4Zm9ybWVkID0gdHJhbnNmb3JtKHRoaXMsIHJldCwgb3B0aW9ucyk7XG4gICAgaWYgKHR5cGVvZiB4Zm9ybWVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0ID0geGZvcm1lZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGRvY3VtZW50IGludG8gYSBwbGFpbi1vbGQgSmF2YVNjcmlwdCBvYmplY3QgKFtQT0pPXShodHRwczovL21hc3RlcmluZ2pzLmlvL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvcG9qbykpLlxuICpcbiAqIEJ1ZmZlcnMgYXJlIGNvbnZlcnRlZCB0byBpbnN0YW5jZXMgb2YgW21vbmdvZGIuQmluYXJ5XShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvQmluYXJ5Lmh0bWwpIGZvciBwcm9wZXIgc3RvcmFnZS5cbiAqXG4gKiAjIyMjIEdldHRlcnMvVmlydHVhbHNcbiAqXG4gKiBFeGFtcGxlIG9mIG9ubHkgYXBwbHlpbmcgcGF0aCBnZXR0ZXJzXG4gKlxuICogICAgIGRvYy50b09iamVjdCh7IGdldHRlcnM6IHRydWUsIHZpcnR1YWxzOiBmYWxzZSB9KVxuICpcbiAqIEV4YW1wbGUgb2Ygb25seSBhcHBseWluZyB2aXJ0dWFsIGdldHRlcnNcbiAqXG4gKiAgICAgZG9jLnRvT2JqZWN0KHsgdmlydHVhbHM6IHRydWUgfSlcbiAqXG4gKiBFeGFtcGxlIG9mIGFwcGx5aW5nIGJvdGggcGF0aCBhbmQgdmlydHVhbCBnZXR0ZXJzXG4gKlxuICogICAgIGRvYy50b09iamVjdCh7IGdldHRlcnM6IHRydWUgfSlcbiAqXG4gKiBUbyBhcHBseSB0aGVzZSBvcHRpb25zIHRvIGV2ZXJ5IGRvY3VtZW50IG9mIHlvdXIgc2NoZW1hIGJ5IGRlZmF1bHQsIHNldCB5b3VyIFtzY2hlbWFzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3NjaGVtYS5odG1sI1NjaGVtYSgpKSBgdG9PYmplY3RgIG9wdGlvbiB0byB0aGUgc2FtZSBhcmd1bWVudC5cbiAqXG4gKiAgICAgc2NoZW1hLnNldCgndG9PYmplY3QnLCB7IHZpcnR1YWxzOiB0cnVlIH0pXG4gKlxuICogIyMjIyBUcmFuc2Zvcm06XG4gKlxuICogV2UgbWF5IG5lZWQgdG8gcGVyZm9ybSBhIHRyYW5zZm9ybWF0aW9uIG9mIHRoZSByZXN1bHRpbmcgb2JqZWN0IGJhc2VkIG9uIHNvbWUgY3JpdGVyaWEsIHNheSB0byByZW1vdmUgc29tZSBzZW5zaXRpdmUgaW5mb3JtYXRpb24gb3IgcmV0dXJuIGEgY3VzdG9tIG9iamVjdC4gSW4gdGhpcyBjYXNlIHdlIHNldCB0aGUgb3B0aW9uYWwgYHRyYW5zZm9ybWAgZnVuY3Rpb24uXG4gKlxuICogVHJhbnNmb3JtIGZ1bmN0aW9ucyByZWNlaXZlIHRocmVlIGFyZ3VtZW50c1xuICpcbiAqICAgICBmdW5jdGlvbiAoZG9jLCByZXQsIG9wdGlvbnMpIHt9XG4gKlxuICogLSBgZG9jYCBUaGUgbW9uZ29vc2UgZG9jdW1lbnQgd2hpY2ggaXMgYmVpbmcgY29udmVydGVkXG4gKiAtIGByZXRgIFRoZSBwbGFpbiBvYmplY3QgcmVwcmVzZW50YXRpb24gd2hpY2ggaGFzIGJlZW4gY29udmVydGVkXG4gKiAtIGBvcHRpb25zYCBUaGUgb3B0aW9ucyBpbiB1c2UgKGVpdGhlciBzY2hlbWEgb3B0aW9ucyBvciB0aGUgb3B0aW9ucyBwYXNzZWQgaW5saW5lKVxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gc3BlY2lmeSB0aGUgdHJhbnNmb3JtIHNjaGVtYSBvcHRpb25cbiAqICAgICBpZiAoIXNjaGVtYS5vcHRpb25zLnRvT2JqZWN0KSBzY2hlbWEub3B0aW9ucy50b09iamVjdCA9IHt9O1xuICogICAgIHNjaGVtYS5vcHRpb25zLnRvT2JqZWN0LnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChkb2MsIHJldCwgb3B0aW9ucykge1xuICogICAgICAgLy8gcmVtb3ZlIHRoZSBfaWQgb2YgZXZlcnkgZG9jdW1lbnQgYmVmb3JlIHJldHVybmluZyB0aGUgcmVzdWx0XG4gKiAgICAgICBkZWxldGUgcmV0Ll9pZDtcbiAqICAgICAgIHJldHVybiByZXQ7XG4gKiAgICAgfVxuICpcbiAqICAgICAvLyB3aXRob3V0IHRoZSB0cmFuc2Zvcm1hdGlvbiBpbiB0aGUgc2NoZW1hXG4gKiAgICAgZG9jLnRvT2JqZWN0KCk7IC8vIHsgX2lkOiAnYW5JZCcsIG5hbWU6ICdXcmVjay1pdCBSYWxwaCcgfVxuICpcbiAqICAgICAvLyB3aXRoIHRoZSB0cmFuc2Zvcm1hdGlvblxuICogICAgIGRvYy50b09iamVjdCgpOyAvLyB7IG5hbWU6ICdXcmVjay1pdCBSYWxwaCcgfVxuICpcbiAqIFdpdGggdHJhbnNmb3JtYXRpb25zIHdlIGNhbiBkbyBhIGxvdCBtb3JlIHRoYW4gcmVtb3ZlIHByb3BlcnRpZXMuIFdlIGNhbiBldmVuIHJldHVybiBjb21wbGV0ZWx5IG5ldyBjdXN0b21pemVkIG9iamVjdHM6XG4gKlxuICogICAgIGlmICghc2NoZW1hLm9wdGlvbnMudG9PYmplY3QpIHNjaGVtYS5vcHRpb25zLnRvT2JqZWN0ID0ge307XG4gKiAgICAgc2NoZW1hLm9wdGlvbnMudG9PYmplY3QudHJhbnNmb3JtID0gZnVuY3Rpb24gKGRvYywgcmV0LCBvcHRpb25zKSB7XG4gKiAgICAgICByZXR1cm4geyBtb3ZpZTogcmV0Lm5hbWUgfVxuICogICAgIH1cbiAqXG4gKiAgICAgLy8gd2l0aG91dCB0aGUgdHJhbnNmb3JtYXRpb24gaW4gdGhlIHNjaGVtYVxuICogICAgIGRvYy50b09iamVjdCgpOyAvLyB7IF9pZDogJ2FuSWQnLCBuYW1lOiAnV3JlY2staXQgUmFscGgnIH1cbiAqXG4gKiAgICAgLy8gd2l0aCB0aGUgdHJhbnNmb3JtYXRpb25cbiAqICAgICBkb2MudG9PYmplY3QoKTsgLy8geyBtb3ZpZTogJ1dyZWNrLWl0IFJhbHBoJyB9XG4gKlxuICogX05vdGU6IGlmIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHJldHVybnMgYHVuZGVmaW5lZGAsIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSBpZ25vcmVkLl9cbiAqXG4gKiBUcmFuc2Zvcm1hdGlvbnMgbWF5IGFsc28gYmUgYXBwbGllZCBpbmxpbmUsIG92ZXJyaWRkaW5nIGFueSB0cmFuc2Zvcm0gc2V0IGluIHRoZSBzY2hlbWEgb3B0aW9ucy5cbiAqIEFueSB0cmFuc2Zvcm0gZnVuY3Rpb24gc3BlY2lmaWVkIGluIGB0b09iamVjdGAgb3B0aW9ucyBhbHNvIHByb3BhZ2F0ZXMgdG8gYW55IHN1YmRvY3VtZW50cy5cbiAqXG4gKiAgICAgZnVuY3Rpb24gZGVsZXRlSWQoZG9jLCByZXQsIG9wdGlvbnMpIHtcbiAqICAgICAgIGRlbGV0ZSByZXQuX2lkO1xuICogICAgICAgcmV0dXJuIHJldDtcbiAqICAgICB9XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG1vbmdvb3NlLlNjaGVtYSh7IG5hbWU6IFN0cmluZywgZG9jQXJyOiBbeyBuYW1lOiBTdHJpbmcgfV0gfSk7XG4gKiAgICAgY29uc3QgVGVzdE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBzY2hlbWEpO1xuICpcbiAqICAgICBjb25zdCBkb2MgPSBuZXcgVGVzdE1vZGVsKHsgbmFtZTogJ3Rlc3QnLCBkb2NBcnI6IFt7IG5hbWU6ICd0ZXN0JyB9XSB9KTtcbiAqXG4gKiAgICAgLy8gcGFzcyB0aGUgdHJhbnNmb3JtIGFzIGFuIGlubGluZSBvcHRpb24uIERlbGV0ZXMgYF9pZGAgcHJvcGVydHlcbiAqICAgICAvLyBmcm9tIGJvdGggdGhlIHRvcC1sZXZlbCBkb2N1bWVudCBhbmQgdGhlIHN1YmRvY3VtZW50LlxuICogICAgIGNvbnN0IG9iaiA9IGRvYy50b09iamVjdCh7IHRyYW5zZm9ybTogZGVsZXRlSWQgfSk7XG4gKiAgICAgb2JqLl9pZDsgLy8gdW5kZWZpbmVkXG4gKiAgICAgb2JqLmRvY0FyclswXS5faWQ7IC8vIHVuZGVmaW5lZFxuICpcbiAqIElmIHlvdSB3YW50IHRvIHNraXAgdHJhbnNmb3JtYXRpb25zLCB1c2UgYHRyYW5zZm9ybTogZmFsc2VgOlxuICpcbiAqICAgICBzY2hlbWEub3B0aW9ucy50b09iamVjdC5oaWRlID0gJ19pZCc7XG4gKiAgICAgc2NoZW1hLm9wdGlvbnMudG9PYmplY3QudHJhbnNmb3JtID0gZnVuY3Rpb24gKGRvYywgcmV0LCBvcHRpb25zKSB7XG4gKiAgICAgICBpZiAob3B0aW9ucy5oaWRlKSB7XG4gKiAgICAgICAgIG9wdGlvbnMuaGlkZS5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAqICAgICAgICAgICBkZWxldGUgcmV0W3Byb3BdO1xuICogICAgICAgICB9KTtcbiAqICAgICAgIH1cbiAqICAgICAgIHJldHVybiByZXQ7XG4gKiAgICAgfVxuICpcbiAqICAgICBjb25zdCBkb2MgPSBuZXcgRG9jKHsgX2lkOiAnYW5JZCcsIHNlY3JldDogNDcsIG5hbWU6ICdXcmVjay1pdCBSYWxwaCcgfSk7XG4gKiAgICAgZG9jLnRvT2JqZWN0KCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHsgc2VjcmV0OiA0NywgbmFtZTogJ1dyZWNrLWl0IFJhbHBoJyB9XG4gKiAgICAgZG9jLnRvT2JqZWN0KHsgaGlkZTogJ3NlY3JldCBfaWQnLCB0cmFuc2Zvcm06IGZhbHNlIH0pOy8vIHsgX2lkOiAnYW5JZCcsIHNlY3JldDogNDcsIG5hbWU6ICdXcmVjay1pdCBSYWxwaCcgfVxuICogICAgIGRvYy50b09iamVjdCh7IGhpZGU6ICdzZWNyZXQgX2lkJywgdHJhbnNmb3JtOiB0cnVlIH0pOyAvLyB7IG5hbWU6ICdXcmVjay1pdCBSYWxwaCcgfVxuICpcbiAqIElmIHlvdSBwYXNzIGEgdHJhbnNmb3JtIGluIGB0b09iamVjdCgpYCBvcHRpb25zLCBNb25nb29zZSB3aWxsIGFwcGx5IHRoZSB0cmFuc2Zvcm1cbiAqIHRvIFtzdWJkb2N1bWVudHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zdWJkb2NzLmh0bWwpIGluIGFkZGl0aW9uIHRvIHRoZSB0b3AtbGV2ZWwgZG9jdW1lbnQuXG4gKiBTaW1pbGFybHksIGB0cmFuc2Zvcm06IGZhbHNlYCBza2lwcyB0cmFuc2Zvcm1zIGZvciBhbGwgc3ViZG9jdW1lbnRzLlxuICogTm90ZSB0aGF0IHRoaXMgYmVoYXZpb3IgaXMgZGlmZmVyZW50IGZvciB0cmFuc2Zvcm1zIGRlZmluZWQgaW4gdGhlIHNjaGVtYTpcbiAqIGlmIHlvdSBkZWZpbmUgYSB0cmFuc2Zvcm0gaW4gYHNjaGVtYS5vcHRpb25zLnRvT2JqZWN0LnRyYW5zZm9ybWAsIHRoYXQgdHJhbnNmb3JtXG4gKiB3aWxsICoqbm90KiogYXBwbHkgdG8gc3ViZG9jdW1lbnRzLlxuICpcbiAqICAgICBjb25zdCBtZW1iZXJTY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nLCBlbWFpbDogU3RyaW5nIH0pO1xuICogICAgIGNvbnN0IGdyb3VwU2NoZW1hID0gbmV3IFNjaGVtYSh7IG1lbWJlcnM6IFttZW1iZXJTY2hlbWFdLCBuYW1lOiBTdHJpbmcsIGVtYWlsIH0pO1xuICogICAgIGNvbnN0IEdyb3VwID0gbW9uZ29vc2UubW9kZWwoJ0dyb3VwJywgZ3JvdXBTY2hlbWEpO1xuICpcbiAqICAgICBjb25zdCBkb2MgPSBuZXcgR3JvdXAoe1xuICogICAgICAgbmFtZTogJ0VuZ2luZWVyaW5nJyxcbiAqICAgICAgIGVtYWlsOiAnZGV2QG1vbmdvb3NlanMuaW8nLFxuICogICAgICAgbWVtYmVyczogW3sgbmFtZTogJ1ZhbCcsIGVtYWlsOiAndmFsQG1vbmdvb3NlanMuaW8nIH1dXG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vIFJlbW92ZXMgYGVtYWlsYCBmcm9tIGJvdGggdG9wLWxldmVsIGRvY3VtZW50ICoqYW5kKiogYXJyYXkgZWxlbWVudHNcbiAqICAgICAvLyB7IG5hbWU6ICdFbmdpbmVlcmluZycsIG1lbWJlcnM6IFt7IG5hbWU6ICdWYWwnIH1dIH1cbiAqICAgICBkb2MudG9PYmplY3QoeyB0cmFuc2Zvcm06IChkb2MsIHJldCkgPT4geyBkZWxldGUgcmV0LmVtYWlsOyByZXR1cm4gcmV0OyB9IH0pO1xuICpcbiAqIFRyYW5zZm9ybXMsIGxpa2UgYWxsIG9mIHRoZXNlIG9wdGlvbnMsIGFyZSBhbHNvIGF2YWlsYWJsZSBmb3IgYHRvSlNPTmAuIFNlZSBbdGhpcyBndWlkZSB0byBgSlNPTi5zdHJpbmdpZnkoKWBdKGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vdGhlLTgwLTIwLWd1aWRlLXRvLWpzb24tc3RyaW5naWZ5LWluLWphdmFzY3JpcHQuaHRtbCkgdG8gbGVhcm4gd2h5IGB0b0pTT04oKWAgYW5kIGB0b09iamVjdCgpYCBhcmUgc2VwYXJhdGUgZnVuY3Rpb25zLlxuICpcbiAqIFNlZSBbc2NoZW1hIG9wdGlvbnNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3RvT2JqZWN0KSBmb3Igc29tZSBtb3JlIGRldGFpbHMuXG4gKlxuICogX0R1cmluZyBzYXZlLCBubyBjdXN0b20gb3B0aW9ucyBhcmUgYXBwbGllZCB0byB0aGUgZG9jdW1lbnQgYmVmb3JlIGJlaW5nIHNlbnQgdG8gdGhlIGRhdGFiYXNlLl9cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmdldHRlcnM9ZmFsc2VdIGlmIHRydWUsIGFwcGx5IGFsbCBnZXR0ZXJzLCBpbmNsdWRpbmcgdmlydHVhbHNcbiAqIEBwYXJhbSB7Qm9vbGVhbnxPYmplY3R9IFtvcHRpb25zLnZpcnR1YWxzPWZhbHNlXSBpZiB0cnVlLCBhcHBseSB2aXJ0dWFscywgaW5jbHVkaW5nIGFsaWFzZXMuIFVzZSBgeyBnZXR0ZXJzOiB0cnVlLCB2aXJ0dWFsczogZmFsc2UgfWAgdG8ganVzdCBhcHBseSBnZXR0ZXJzLCBub3QgdmlydHVhbHMuIEFuIG9iamVjdCBvZiB0aGUgZm9ybSBgeyBwYXRoc1RvU2tpcDogWydzb21lVmlydHVhbCddIH1gIG1heSBhbHNvIGJlIHVzZWQgdG8gb21pdCBzcGVjaWZpYyB2aXJ0dWFscy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxpYXNlcz10cnVlXSBpZiBgb3B0aW9ucy52aXJ0dWFscyA9IHRydWVgLCB5b3UgY2FuIHNldCBgb3B0aW9ucy5hbGlhc2VzID0gZmFsc2VgIHRvIHNraXAgYXBwbHlpbmcgYWxpYXNlcy4gVGhpcyBvcHRpb24gaXMgYSBuby1vcCBpZiBgb3B0aW9ucy52aXJ0dWFscyA9IGZhbHNlYC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWluaW1pemU9dHJ1ZV0gaWYgdHJ1ZSwgb21pdCBhbnkgZW1wdHkgb2JqZWN0cyBmcm9tIHRoZSBvdXRwdXRcbiAqIEBwYXJhbSB7RnVuY3Rpb258bnVsbH0gW29wdGlvbnMudHJhbnNmb3JtPW51bGxdIGlmIHNldCwgbW9uZ29vc2Ugd2lsbCBjYWxsIHRoaXMgZnVuY3Rpb24gdG8gYWxsb3cgeW91IHRvIHRyYW5zZm9ybSB0aGUgcmV0dXJuZWQgb2JqZWN0XG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmRlcG9wdWxhdGU9ZmFsc2VdIGlmIHRydWUsIHJlcGxhY2UgYW55IGNvbnZlbnRpb25hbGx5IHBvcHVsYXRlZCBwYXRocyB3aXRoIHRoZSBvcmlnaW5hbCBpZCBpbiB0aGUgb3V0cHV0LiBIYXMgbm8gYWZmZWN0IG9uIHZpcnR1YWwgcG9wdWxhdGVkIHBhdGhzLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy52ZXJzaW9uS2V5PXRydWVdIGlmIGZhbHNlLCBleGNsdWRlIHRoZSB2ZXJzaW9uIGtleSAoYF9fdmAgYnkgZGVmYXVsdCkgZnJvbSB0aGUgb3V0cHV0XG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZsYXR0ZW5NYXBzPWZhbHNlXSBpZiB0cnVlLCBjb252ZXJ0IE1hcHMgdG8gUE9KT3MuIFVzZWZ1bCBpZiB5b3Ugd2FudCB0byBgSlNPTi5zdHJpbmdpZnkoKWAgdGhlIHJlc3VsdCBvZiBgdG9PYmplY3QoKWAuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZsYXR0ZW5PYmplY3RJZHM9ZmFsc2VdIGlmIHRydWUsIGNvbnZlcnQgYW55IE9iamVjdElkcyBpbiB0aGUgcmVzdWx0IHRvIDI0IGNoYXJhY3RlciBoZXggc3RyaW5ncy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXNlUHJvamVjdGlvbj1mYWxzZV0gLSBJZiB0cnVlLCBvbWl0cyBmaWVsZHMgdGhhdCBhcmUgZXhjbHVkZWQgaW4gdGhpcyBkb2N1bWVudCdzIHByb2plY3Rpb24uIFVubGVzcyB5b3Ugc3BlY2lmaWVkIGEgcHJvamVjdGlvbiwgdGhpcyB3aWxsIG9taXQgYW55IGZpZWxkIHRoYXQgaGFzIGBzZWxlY3Q6IGZhbHNlYCBpbiB0aGUgc2NoZW1hLlxuICogQHJldHVybiB7T2JqZWN0fSBqcyBvYmplY3QgKG5vdCBhIFBPSk8pXG4gKiBAc2VlIG1vbmdvZGIuQmluYXJ5IGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9CaW5hcnkuaHRtbFxuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLnRvT2JqZWN0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICByZXR1cm4gdGhpcy4kdG9PYmplY3Qob3B0aW9ucyk7XG59O1xuXG4vKiFcbiAqIEFwcGxpZXMgdmlydHVhbHMgcHJvcGVydGllcyB0byBganNvbmAuXG4gKi9cblxuZnVuY3Rpb24gYXBwbHlWaXJ0dWFscyhzZWxmLCBqc29uLCBvcHRpb25zLCB0b09iamVjdE9wdGlvbnMpIHtcbiAgY29uc3Qgc2NoZW1hID0gc2VsZi4kX19zY2hlbWE7XG4gIGNvbnN0IHBhdGhzID0gT2JqZWN0LmtleXMoc2NoZW1hLnZpcnR1YWxzKTtcbiAgbGV0IGkgPSBwYXRocy5sZW5ndGg7XG4gIGNvbnN0IG51bVBhdGhzID0gaTtcbiAgbGV0IHBhdGg7XG4gIGxldCBhc3NpZ25QYXRoO1xuICBsZXQgY3VyID0gc2VsZi5fZG9jO1xuICBsZXQgdjtcbiAgY29uc3QgYWxpYXNlcyA9IHR5cGVvZiAodG9PYmplY3RPcHRpb25zICYmIHRvT2JqZWN0T3B0aW9ucy5hbGlhc2VzKSA9PT0gJ2Jvb2xlYW4nXG4gICAgPyB0b09iamVjdE9wdGlvbnMuYWxpYXNlc1xuICAgIDogdHJ1ZTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgbGV0IHZpcnR1YWxzVG9BcHBseSA9IG51bGw7XG4gIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMudmlydHVhbHMpKSB7XG4gICAgdmlydHVhbHNUb0FwcGx5ID0gbmV3IFNldChvcHRpb25zLnZpcnR1YWxzKTtcbiAgfSBlbHNlIGlmIChvcHRpb25zLnZpcnR1YWxzICYmIG9wdGlvbnMudmlydHVhbHMucGF0aHNUb1NraXApIHtcbiAgICB2aXJ0dWFsc1RvQXBwbHkgPSBuZXcgU2V0KHBhdGhzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdGlvbnMudmlydHVhbHMucGF0aHNUb1NraXAubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh2aXJ0dWFsc1RvQXBwbHkuaGFzKG9wdGlvbnMudmlydHVhbHMucGF0aHNUb1NraXBbaV0pKSB7XG4gICAgICAgIHZpcnR1YWxzVG9BcHBseS5kZWxldGUob3B0aW9ucy52aXJ0dWFscy5wYXRoc1RvU2tpcFtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjdXIpIHtcbiAgICByZXR1cm4ganNvbjtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBudW1QYXRoczsgKytpKSB7XG4gICAgcGF0aCA9IHBhdGhzW2ldO1xuXG4gICAgaWYgKHZpcnR1YWxzVG9BcHBseSAhPSBudWxsICYmICF2aXJ0dWFsc1RvQXBwbHkuaGFzKHBhdGgpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBBbGxvdyBza2lwcGluZyBhbGlhc2VzIHdpdGggYHRvT2JqZWN0KHsgdmlydHVhbHM6IHRydWUsIGFsaWFzZXM6IGZhbHNlIH0pYFxuICAgIGlmICghYWxpYXNlcyAmJiBzY2hlbWEuYWxpYXNlcy5oYXNPd25Qcm9wZXJ0eShwYXRoKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gV2UgbWF5IGJlIGFwcGx5aW5nIHZpcnR1YWxzIHRvIGEgbmVzdGVkIG9iamVjdCwgZm9yIGV4YW1wbGUgaWYgY2FsbGluZ1xuICAgIC8vIGBkb2MubmVzdGVkUHJvcC50b0pTT04oKWAuIElmIHNvLCB0aGUgcGF0aCB3ZSBhc3NpZ24gdG8sIGBhc3NpZ25QYXRoYCxcbiAgICAvLyB3aWxsIGJlIGEgdHJhaWxpbmcgc3Vic3RyaW5nIG9mIHRoZSBgcGF0aGAuXG4gICAgYXNzaWduUGF0aCA9IHBhdGg7XG4gICAgaWYgKG9wdGlvbnMucGF0aCAhPSBudWxsKSB7XG4gICAgICBpZiAoIXBhdGguc3RhcnRzV2l0aChvcHRpb25zLnBhdGggKyAnLicpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYXNzaWduUGF0aCA9IHBhdGguc3Vic3RyaW5nKG9wdGlvbnMucGF0aC5sZW5ndGggKyAxKTtcbiAgICB9XG4gICAgY29uc3QgcGFydHMgPSBhc3NpZ25QYXRoLnNwbGl0KCcuJyk7XG4gICAgdiA9IGNsb25lKHNlbGYuZ2V0KHBhdGgpLCBvcHRpb25zKTtcbiAgICBpZiAodiA9PT0gdm9pZCAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgcGxlbiA9IHBhcnRzLmxlbmd0aDtcbiAgICBjdXIgPSBqc29uO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcGxlbiAtIDE7ICsraikge1xuICAgICAgY3VyW3BhcnRzW2pdXSA9IGN1cltwYXJ0c1tqXV0gfHwge307XG4gICAgICBjdXIgPSBjdXJbcGFydHNbal1dO1xuICAgIH1cbiAgICBjdXJbcGFydHNbcGxlbiAtIDFdXSA9IHY7XG4gIH1cblxuICByZXR1cm4ganNvbjtcbn1cblxuXG4vKipcbiAqIEFwcGxpZXMgdmlydHVhbHMgcHJvcGVydGllcyB0byBganNvbmAuXG4gKlxuICogQHBhcmFtIHtEb2N1bWVudH0gc2VsZlxuICogQHBhcmFtIHtPYmplY3R9IGpzb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEByZXR1cm4ge09iamVjdH0gYGpzb25gXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBhcHBseUdldHRlcnMoc2VsZiwganNvbiwgb3B0aW9ucykge1xuICBjb25zdCBzY2hlbWEgPSBzZWxmLiRfX3NjaGVtYTtcbiAgY29uc3QgcGF0aHMgPSBPYmplY3Qua2V5cyhzY2hlbWEucGF0aHMpO1xuICBsZXQgaSA9IHBhdGhzLmxlbmd0aDtcbiAgbGV0IHBhdGg7XG4gIGxldCBjdXIgPSBzZWxmLl9kb2M7XG4gIGxldCB2O1xuXG4gIGlmICghY3VyKSB7XG4gICAgcmV0dXJuIGpzb247XG4gIH1cblxuICB3aGlsZSAoaS0tKSB7XG4gICAgcGF0aCA9IHBhdGhzW2ldO1xuXG4gICAgY29uc3QgcGFydHMgPSBwYXRoLnNwbGl0KCcuJyk7XG5cbiAgICBjb25zdCBwbGVuID0gcGFydHMubGVuZ3RoO1xuICAgIGNvbnN0IGxhc3QgPSBwbGVuIC0gMTtcbiAgICBsZXQgYnJhbmNoID0ganNvbjtcbiAgICBsZXQgcGFydDtcbiAgICBjdXIgPSBzZWxmLl9kb2M7XG5cbiAgICBpZiAoIXNlbGYuJF9faXNTZWxlY3RlZChwYXRoKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IHBsZW47ICsraWkpIHtcbiAgICAgIHBhcnQgPSBwYXJ0c1tpaV07XG4gICAgICB2ID0gY3VyW3BhcnRdO1xuICAgICAgLy8gSWYgd2UndmUgcmVhY2hlZCBhIG5vbi1vYmplY3QgcGFydCBvZiB0aGUgYnJhbmNoLCBjb250aW51aW5nIHdvdWxkXG4gICAgICAvLyBjYXVzZSBcIkNhbm5vdCBjcmVhdGUgcHJvcGVydHkgJ2Zvbycgb24gc3RyaW5nICdiYXInXCIgZXJyb3IuXG4gICAgICAvLyBOZWNlc3NhcnkgZm9yIG1vbmdvb3NlLWludGwgcGx1Z2luIHJlOiBnaC0xNDQ0NlxuICAgICAgaWYgKGJyYW5jaCAhPSBudWxsICYmIHR5cGVvZiBicmFuY2ggIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChpaSA9PT0gbGFzdCkge1xuICAgICAgICBjb25zdCB2YWwgPSBzZWxmLiRnZXQocGF0aCk7XG4gICAgICAgIGJyYW5jaFtwYXJ0XSA9IGNsb25lKHZhbCwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGJyYW5jaFtwYXJ0XSkgJiYgc2NoZW1hLnBhdGhzW3BhdGhdLiRlbWJlZGRlZFNjaGVtYVR5cGUpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJyYW5jaFtwYXJ0XS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgYnJhbmNoW3BhcnRdW2ldID0gc2NoZW1hLnBhdGhzW3BhdGhdLiRlbWJlZGRlZFNjaGVtYVR5cGUuYXBwbHlHZXR0ZXJzKFxuICAgICAgICAgICAgICBicmFuY2hbcGFydF1baV0sXG4gICAgICAgICAgICAgIHNlbGZcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICBpZiAocGFydCBpbiBjdXIpIHtcbiAgICAgICAgICBicmFuY2hbcGFydF0gPSB2O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJhbmNoID0gYnJhbmNoW3BhcnRdIHx8IChicmFuY2hbcGFydF0gPSB7fSk7XG4gICAgICB9XG4gICAgICBjdXIgPSB2O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBqc29uO1xufVxuXG4vKipcbiAqIEFwcGxpZXMgc2NoZW1hIHR5cGUgdHJhbnNmb3JtcyB0byBganNvbmAuXG4gKlxuICogQHBhcmFtIHtEb2N1bWVudH0gc2VsZlxuICogQHBhcmFtIHtPYmplY3R9IGpzb25cbiAqIEByZXR1cm4ge09iamVjdH0gYGpzb25gXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBhcHBseVNjaGVtYVR5cGVUcmFuc2Zvcm1zKHNlbGYsIGpzb24pIHtcbiAgY29uc3Qgc2NoZW1hID0gc2VsZi4kX19zY2hlbWE7XG4gIGNvbnN0IHBhdGhzID0gT2JqZWN0LmtleXMoc2NoZW1hLnBhdGhzIHx8IHt9KTtcbiAgY29uc3QgY3VyID0gc2VsZi5fZG9jO1xuXG4gIGlmICghY3VyKSB7XG4gICAgcmV0dXJuIGpzb247XG4gIH1cblxuICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICBjb25zdCBzY2hlbWF0eXBlID0gc2NoZW1hLnBhdGhzW3BhdGhdO1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hdHlwZS5vcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3QgdmFsID0gc2VsZi4kZ2V0KHBhdGgpO1xuICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdHJhbnNmb3JtZWRWYWx1ZSA9IHNjaGVtYXR5cGUub3B0aW9ucy50cmFuc2Zvcm0uY2FsbChzZWxmLCB2YWwpO1xuICAgICAgdGhyb3dFcnJvcklmUHJvbWlzZShwYXRoLCB0cmFuc2Zvcm1lZFZhbHVlKTtcbiAgICAgIHV0aWxzLnNldFZhbHVlKHBhdGgsIHRyYW5zZm9ybWVkVmFsdWUsIGpzb24pO1xuICAgIH0gZWxzZSBpZiAoc2NoZW1hdHlwZS4kZW1iZWRkZWRTY2hlbWFUeXBlICE9IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIHNjaGVtYXR5cGUuJGVtYmVkZGVkU2NoZW1hVHlwZS5vcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3QgdmFsID0gc2VsZi4kZ2V0KHBhdGgpO1xuICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFscyA9IFtdLmNvbmNhdCh2YWwpO1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gc2NoZW1hdHlwZS4kZW1iZWRkZWRTY2hlbWFUeXBlLm9wdGlvbnMudHJhbnNmb3JtO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkVmFsdWUgPSB0cmFuc2Zvcm0uY2FsbChzZWxmLCB2YWxzW2ldKTtcbiAgICAgICAgdmFsc1tpXSA9IHRyYW5zZm9ybWVkVmFsdWU7XG4gICAgICAgIHRocm93RXJyb3JJZlByb21pc2UocGF0aCwgdHJhbnNmb3JtZWRWYWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGpzb25bcGF0aF0gPSB2YWxzO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBqc29uO1xufVxuXG5mdW5jdGlvbiB0aHJvd0Vycm9ySWZQcm9taXNlKHBhdGgsIHRyYW5zZm9ybWVkVmFsdWUpIHtcbiAgaWYgKGlzUHJvbWlzZSh0cmFuc2Zvcm1lZFZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignYHRyYW5zZm9ybWAgZnVuY3Rpb24gbXVzdCBiZSBzeW5jaHJvbm91cywgYnV0IHRoZSB0cmFuc2Zvcm0gb24gcGF0aCBgJyArIHBhdGggKyAnYCByZXR1cm5lZCBhIHByb21pc2UuJyk7XG4gIH1cbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBvbWl0RGVzZWxlY3RlZEZpZWxkcyhzZWxmLCBqc29uKSB7XG4gIGNvbnN0IHNjaGVtYSA9IHNlbGYuJF9fc2NoZW1hO1xuICBjb25zdCBwYXRocyA9IE9iamVjdC5rZXlzKHNjaGVtYS5wYXRocyB8fCB7fSk7XG4gIGNvbnN0IGN1ciA9IHNlbGYuX2RvYztcblxuICBpZiAoIWN1cikge1xuICAgIHJldHVybiBqc29uO1xuICB9XG5cbiAgbGV0IHNlbGVjdGVkID0gc2VsZi4kX18uc2VsZWN0ZWQ7XG4gIGlmIChzZWxlY3RlZCA9PT0gdm9pZCAwKSB7XG4gICAgc2VsZWN0ZWQgPSB7fTtcbiAgICBxdWVyeWhlbHBlcnMuYXBwbHlQYXRocyhzZWxlY3RlZCwgc2NoZW1hKTtcbiAgfVxuICBpZiAoc2VsZWN0ZWQgPT0gbnVsbCB8fCBPYmplY3Qua2V5cyhzZWxlY3RlZCkubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGpzb247XG4gIH1cblxuICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICBpZiAoc2VsZWN0ZWRbcGF0aF0gIT0gbnVsbCAmJiAhc2VsZWN0ZWRbcGF0aF0pIHtcbiAgICAgIGRlbGV0ZSBqc29uW3BhdGhdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBqc29uO1xufVxuXG4vKipcbiAqIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhpcyBtZXRob2QgaXMgdXNlZCBpbiBjYWxscyB0byBbYEpTT04uc3RyaW5naWZ5KGRvYylgXShodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tL3RoZS04MC0yMC1ndWlkZS10by1qc29uLXN0cmluZ2lmeS1pbi1qYXZhc2NyaXB0I3RoZS10b2pzb24tZnVuY3Rpb24pLlxuICpcbiAqIFRoaXMgbWV0aG9kIGFjY2VwdHMgdGhlIHNhbWUgb3B0aW9ucyBhcyBbRG9jdW1lbnQjdG9PYmplY3RdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudC5wcm90b3R5cGUudG9PYmplY3QoKSkuIFRvIGFwcGx5IHRoZSBvcHRpb25zIHRvIGV2ZXJ5IGRvY3VtZW50IG9mIHlvdXIgc2NoZW1hIGJ5IGRlZmF1bHQsIHNldCB5b3VyIFtzY2hlbWFzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3NjaGVtYS5odG1sI1NjaGVtYSgpKSBgdG9KU09OYCBvcHRpb24gdG8gdGhlIHNhbWUgYXJndW1lbnQuXG4gKlxuICogICAgIHNjaGVtYS5zZXQoJ3RvSlNPTicsIHsgdmlydHVhbHM6IHRydWUgfSk7XG4gKlxuICogVGhlcmUgaXMgb25lIGRpZmZlcmVuY2UgYmV0d2VlbiBgdG9KU09OKClgIGFuZCBgdG9PYmplY3QoKWAgb3B0aW9ucy5cbiAqIFdoZW4geW91IGNhbGwgYHRvSlNPTigpYCwgdGhlIFtgZmxhdHRlbk1hcHNgIG9wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS50b09iamVjdCgpKSBkZWZhdWx0cyB0byBgdHJ1ZWAsIGJlY2F1c2UgYEpTT04uc3RyaW5naWZ5KClgIGRvZXNuJ3QgY29udmVydCBtYXBzIHRvIG9iamVjdHMgYnkgZGVmYXVsdC5cbiAqIFdoZW4geW91IGNhbGwgYHRvT2JqZWN0KClgLCB0aGUgYGZsYXR0ZW5NYXBzYCBvcHRpb24gaXMgYGZhbHNlYCBieSBkZWZhdWx0LlxuICpcbiAqIFNlZSBbc2NoZW1hIG9wdGlvbnNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3RvSlNPTikgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gc2V0dGluZyBgdG9KU09OYCBvcHRpb24gZGVmYXVsdHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmxhdHRlbk1hcHM9dHJ1ZV0gaWYgdHJ1ZSwgY29udmVydCBNYXBzIHRvIFtQT0pPc10oaHR0cHM6Ly9tYXN0ZXJpbmdqcy5pby90dXRvcmlhbHMvZnVuZGFtZW50YWxzL3Bvam8pLiBVc2VmdWwgaWYgeW91IHdhbnQgdG8gYEpTT04uc3RyaW5naWZ5KClgIHRoZSByZXN1bHQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZsYXR0ZW5PYmplY3RJZHM9ZmFsc2VdIGlmIHRydWUsIGNvbnZlcnQgYW55IE9iamVjdElkcyBpbiB0aGUgcmVzdWx0IHRvIDI0IGNoYXJhY3RlciBoZXggc3RyaW5ncy5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBzZWUgRG9jdW1lbnQjdG9PYmplY3QgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS50b09iamVjdCgpXG4gKiBAc2VlIEpTT04uc3RyaW5naWZ5KCkgaW4gSmF2YVNjcmlwdCBodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tL3RoZS04MC0yMC1ndWlkZS10by1qc29uLXN0cmluZ2lmeS1pbi1qYXZhc2NyaXB0Lmh0bWxcbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHJldHVybiB0aGlzLiR0b09iamVjdChvcHRpb25zLCB0cnVlKTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLm93bmVyRG9jdW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogSWYgdGhpcyBkb2N1bWVudCBpcyBhIHN1YmRvY3VtZW50IG9yIHBvcHVsYXRlZCBkb2N1bWVudCwgcmV0dXJucyB0aGUgZG9jdW1lbnQnc1xuICogcGFyZW50LiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBkb2N1bWVudCBpZiB0aGVyZSBpcyBubyBwYXJlbnQuXG4gKlxuICogQHJldHVybiB7RG9jdW1lbnR9XG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCBwYXJlbnRcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLnBhcmVudCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy4kaXNTdWJkb2N1bWVudCB8fCB0aGlzLiRfXy53YXNQb3B1bGF0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy4kX18ucGFyZW50O1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3IgW2BwYXJlbnQoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudC5wcm90b3R5cGUucGFyZW50KCkpLiBJZiB0aGlzIGRvY3VtZW50IGlzIGEgc3ViZG9jdW1lbnQgb3IgcG9wdWxhdGVkXG4gKiBkb2N1bWVudCwgcmV0dXJucyB0aGUgZG9jdW1lbnQncyBwYXJlbnQuIFJldHVybnMgYHVuZGVmaW5lZGAgb3RoZXJ3aXNlLlxuICpcbiAqIEByZXR1cm4ge0RvY3VtZW50fVxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgJHBhcmVudFxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJHBhcmVudCA9IERvY3VtZW50LnByb3RvdHlwZS5wYXJlbnQ7XG5cbi8qKlxuICogSGVscGVyIGZvciBjb25zb2xlLmxvZ1xuICpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kIGluc3BlY3RcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGNvbnN0IGlzUE9KTyA9IHV0aWxzLmlzUE9KTyhvcHRpb25zKTtcbiAgbGV0IG9wdHM7XG4gIGlmIChpc1BPSk8pIHtcbiAgICBvcHRzID0gb3B0aW9ucztcbiAgICBvcHRzLm1pbmltaXplID0gZmFsc2U7XG4gIH1cblxuICBjb25zdCByZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCA/IHRoaXMudG9PYmplY3Qob3B0cykgOiB0aGlzLnRvT2JqZWN0KCk7XG5cbiAgaWYgKHJldCA9PSBudWxsKSB7XG4gICAgLy8gSWYgYHRvT2JqZWN0KClgIHJldHVybnMgbnVsbCwgYHRoaXNgIGlzIHN0aWxsIGFuIG9iamVjdCwgc28gaWYgYGluc3BlY3QoKWBcbiAgICAvLyBwcmludHMgb3V0IG51bGwgdGhpcyBjYW4gY2F1c2Ugc29tZSBzZXJpb3VzIGNvbmZ1c2lvbi4gU2VlIGdoLTc5NDIuXG4gICAgcmV0dXJuICdNb25nb29zZURvY3VtZW50IHsgJyArIHJldCArICcgfSc7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuaWYgKGluc3BlY3QuY3VzdG9tKSB7XG4gIC8vIEF2b2lkIE5vZGUgZGVwcmVjYXRpb24gd2FybmluZyBERVAwMDc5XG4gIERvY3VtZW50LnByb3RvdHlwZVtpbnNwZWN0LmN1c3RvbV0gPSBEb2N1bWVudC5wcm90b3R5cGUuaW5zcGVjdDtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZm9yIGNvbnNvbGUubG9nXG4gKlxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgdG9TdHJpbmdcbiAqIEBtZW1iZXJPZiBEb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IHJldCA9IHRoaXMuaW5zcGVjdCgpO1xuICBpZiAodHlwZW9mIHJldCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIHJldHVybiBpbnNwZWN0KHJldCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGRvY3VtZW50IGlzIGVxdWFsIHRvIGFub3RoZXIgZG9jdW1lbnQuXG4gKlxuICogRG9jdW1lbnRzIGFyZSBjb25zaWRlcmVkIGVxdWFsIHdoZW4gdGhleSBoYXZlIG1hdGNoaW5nIGBfaWRgcywgdW5sZXNzIG5laXRoZXJcbiAqIGRvY3VtZW50IGhhcyBhbiBgX2lkYCwgaW4gd2hpY2ggY2FzZSB0aGlzIGZ1bmN0aW9uIGZhbGxzIGJhY2sgdG8gdXNpbmdcbiAqIGBkZWVwRXF1YWwoKWAuXG4gKlxuICogQHBhcmFtIHtEb2N1bWVudH0gW2RvY10gYSBkb2N1bWVudCB0byBjb21wYXJlLiBJZiBmYWxzeSwgd2lsbCBhbHdheXMgcmV0dXJuIFwiZmFsc2VcIi5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24oZG9jKSB7XG4gIGlmICghZG9jKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgdGlkID0gdGhpcy4kX19nZXRWYWx1ZSgnX2lkJyk7XG4gIGNvbnN0IGRvY2lkID0gZG9jLiRfXyAhPSBudWxsID8gZG9jLiRfX2dldFZhbHVlKCdfaWQnKSA6IGRvYztcbiAgaWYgKCF0aWQgJiYgIWRvY2lkKSB7XG4gICAgcmV0dXJuIGRlZXBFcXVhbCh0aGlzLCBkb2MpO1xuICB9XG4gIHJldHVybiB0aWQgJiYgdGlkLmVxdWFsc1xuICAgID8gdGlkLmVxdWFscyhkb2NpZClcbiAgICA6IHRpZCA9PT0gZG9jaWQ7XG59O1xuXG4vKipcbiAqIFBvcHVsYXRlcyBwYXRocyBvbiBhbiBleGlzdGluZyBkb2N1bWVudC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIEdpdmVuIGEgZG9jdW1lbnQsIGBwb3B1bGF0ZSgpYCBsZXRzIHlvdSBwdWxsIGluIHJlZmVyZW5jZWQgZG9jc1xuICogICAgIGF3YWl0IGRvYy5wb3B1bGF0ZShbXG4gKiAgICAgICAnc3RvcmllcycsXG4gKiAgICAgICB7IHBhdGg6ICdmYW5zJywgc29ydDogeyBuYW1lOiAtMSB9IH1cbiAqICAgICBdKTtcbiAqICAgICBkb2MucG9wdWxhdGVkKCdzdG9yaWVzJyk7IC8vIEFycmF5IG9mIE9iamVjdElkc1xuICogICAgIGRvYy5zdG9yaWVzWzBdLnRpdGxlOyAvLyAnQ2FzaW5vIFJveWFsZSdcbiAqICAgICBkb2MucG9wdWxhdGVkKCdmYW5zJyk7IC8vIEFycmF5IG9mIE9iamVjdElkc1xuICpcbiAqICAgICAvLyBJZiB0aGUgcmVmZXJlbmNlZCBkb2MgaGFzIGJlZW4gZGVsZXRlZCwgYHBvcHVsYXRlKClgIHdpbGxcbiAqICAgICAvLyByZW1vdmUgdGhhdCBlbnRyeSBmcm9tIHRoZSBhcnJheS5cbiAqICAgICBhd2FpdCBTdG9yeS5kZWxldGUoeyB0aXRsZTogJ0Nhc2lubyBSb3lhbGUnIH0pO1xuICogICAgIGF3YWl0IGRvYy5wb3B1bGF0ZSgnc3RvcmllcycpOyAvLyBFbXB0eSBhcnJheVxuICpcbiAqICAgICAvLyBZb3UgY2FuIGFsc28gcGFzcyBhZGRpdGlvbmFsIHF1ZXJ5IG9wdGlvbnMgdG8gYHBvcHVsYXRlKClgLFxuICogICAgIC8vIGxpa2UgcHJvamVjdGlvbnM6XG4gKiAgICAgYXdhaXQgZG9jLnBvcHVsYXRlKCdmYW5zJywgJy1lbWFpbCcpO1xuICogICAgIGRvYy5mYW5zWzBdLmVtYWlsIC8vIHVuZGVmaW5lZCBiZWNhdXNlIG9mIDJuZCBwYXJhbSBgc2VsZWN0YFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxBcnJheX0gcGF0aCBlaXRoZXIgdGhlIHBhdGggdG8gcG9wdWxhdGUgb3IgYW4gb2JqZWN0IHNwZWNpZnlpbmcgYWxsIHBhcmFtZXRlcnMsIG9yIGVpdGhlciBhbiBhcnJheSBvZiB0aG9zZVxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbc2VsZWN0XSBGaWVsZCBzZWxlY3Rpb24gZm9yIHRoZSBwb3B1bGF0aW9uIHF1ZXJ5XG4gKiBAcGFyYW0ge01vZGVsfSBbbW9kZWxdIFRoZSBtb2RlbCB5b3Ugd2lzaCB0byB1c2UgZm9yIHBvcHVsYXRpb24uIElmIG5vdCBzcGVjaWZpZWQsIHBvcHVsYXRlIHdpbGwgbG9vayB1cCB0aGUgbW9kZWwgYnkgdGhlIG5hbWUgaW4gdGhlIFNjaGVtYSdzIGByZWZgIGZpZWxkLlxuICogQHBhcmFtIHtPYmplY3R9IFttYXRjaF0gQ29uZGl0aW9ucyBmb3IgdGhlIHBvcHVsYXRpb24gcXVlcnlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBmb3IgdGhlIHBvcHVsYXRpb24gcXVlcnkgKHNvcnQsIGV0YylcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYXRoPW51bGxdIFRoZSBwYXRoIHRvIHBvcHVsYXRlLlxuICogQHBhcmFtIHtzdHJpbmd8UG9wdWxhdGVPcHRpb25zfSBbb3B0aW9ucy5wb3B1bGF0ZT1udWxsXSBSZWN1cnNpdmVseSBwb3B1bGF0ZSBwYXRocyBpbiB0aGUgcG9wdWxhdGVkIGRvY3VtZW50cy4gU2VlIFtkZWVwIHBvcHVsYXRlIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9wb3B1bGF0ZS5odG1sI2RlZXAtcG9wdWxhdGUpLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZXRhaW5OdWxsVmFsdWVzPWZhbHNlXSBieSBkZWZhdWx0LCBNb25nb29zZSByZW1vdmVzIG51bGwgYW5kIHVuZGVmaW5lZCB2YWx1ZXMgZnJvbSBwb3B1bGF0ZWQgYXJyYXlzLiBVc2UgdGhpcyBvcHRpb24gdG8gbWFrZSBgcG9wdWxhdGUoKWAgcmV0YWluIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgYXJyYXkgZW50cmllcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZ2V0dGVycz1mYWxzZV0gaWYgdHJ1ZSwgTW9uZ29vc2Ugd2lsbCBjYWxsIGFueSBnZXR0ZXJzIGRlZmluZWQgb24gdGhlIGBsb2NhbEZpZWxkYC4gQnkgZGVmYXVsdCwgTW9uZ29vc2UgZ2V0cyB0aGUgcmF3IHZhbHVlIG9mIGBsb2NhbEZpZWxkYC4gRm9yIGV4YW1wbGUsIHlvdSB3b3VsZCBuZWVkIHRvIHNldCB0aGlzIG9wdGlvbiB0byBgdHJ1ZWAgaWYgeW91IHdhbnRlZCB0byBbYWRkIGEgYGxvd2VyY2FzZWAgZ2V0dGVyIHRvIHlvdXIgYGxvY2FsRmllbGRgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3Mvc2NoZW1hdHlwZXMuaHRtbCNzY2hlbWF0eXBlLW9wdGlvbnMpLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jbG9uZT1mYWxzZV0gV2hlbiB5b3UgZG8gYEJsb2dQb3N0LmZpbmQoKS5wb3B1bGF0ZSgnYXV0aG9yJylgLCBibG9nIHBvc3RzIHdpdGggdGhlIHNhbWUgYXV0aG9yIHdpbGwgc2hhcmUgMSBjb3B5IG9mIGFuIGBhdXRob3JgIGRvYy4gRW5hYmxlIHRoaXMgb3B0aW9uIHRvIG1ha2UgTW9uZ29vc2UgY2xvbmUgcG9wdWxhdGVkIGRvY3MgYmVmb3JlIGFzc2lnbmluZyB0aGVtLlxuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IFtvcHRpb25zLm1hdGNoPW51bGxdIEFkZCBhbiBhZGRpdGlvbmFsIGZpbHRlciB0byB0aGUgcG9wdWxhdGUgcXVlcnkuIENhbiBiZSBhIGZpbHRlciBvYmplY3QgY29udGFpbmluZyBbTW9uZ29EQiBxdWVyeSBzeW50YXhdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3R1dG9yaWFsL3F1ZXJ5LWRvY3VtZW50cy8pLCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZpbHRlciBvYmplY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy50cmFuc2Zvcm09bnVsbF0gRnVuY3Rpb24gdGhhdCBNb25nb29zZSB3aWxsIGNhbGwgb24gZXZlcnkgcG9wdWxhdGVkIGRvY3VtZW50IHRoYXQgYWxsb3dzIHlvdSB0byB0cmFuc2Zvcm0gdGhlIHBvcHVsYXRlZCBkb2N1bWVudC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5vcHRpb25zPW51bGxdIEFkZGl0aW9uYWwgb3B0aW9ucyBsaWtlIGBsaW1pdGAgYW5kIGBsZWFuYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQ2FsbGJhY2tcbiAqIEBzZWUgcG9wdWxhdGlvbiBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvcG9wdWxhdGUuaHRtbFxuICogQHNlZSBRdWVyeSNzZWxlY3QgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZWxlY3QoKVxuICogQHNlZSBNb2RlbC5wb3B1bGF0ZSBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vZGVsLmh0bWwjTW9kZWwucG9wdWxhdGUoKVxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqIEByZXR1cm4ge1Byb21pc2V8bnVsbH0gUmV0dXJucyBhIFByb21pc2UgaWYgbm8gYGNhbGxiYWNrYCBpcyBnaXZlbi5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLnBvcHVsYXRlID0gYXN5bmMgZnVuY3Rpb24gcG9wdWxhdGUoKSB7XG4gIGNvbnN0IHBvcCA9IHt9O1xuICBjb25zdCBhcmdzID0gWy4uLmFyZ3VtZW50c107XG4gIGlmICh0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0RvY3VtZW50LnByb3RvdHlwZS5wb3B1bGF0ZSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGlmIChhcmdzLmxlbmd0aCAhPT0gMCkge1xuICAgIC8vIHVzZSBoYXNoIHRvIHJlbW92ZSBkdXBsaWNhdGUgcGF0aHNcbiAgICBjb25zdCByZXMgPSB1dGlscy5wb3B1bGF0ZS5hcHBseShudWxsLCBhcmdzKTtcbiAgICBmb3IgKGNvbnN0IHBvcHVsYXRlT3B0aW9ucyBvZiByZXMpIHtcbiAgICAgIHBvcFtwb3B1bGF0ZU9wdGlvbnMucGF0aF0gPSBwb3B1bGF0ZU9wdGlvbnM7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcGF0aHMgPSB1dGlscy5vYmplY3QudmFscyhwb3ApO1xuICBsZXQgdG9wTGV2ZWxNb2RlbCA9IHRoaXMuY29uc3RydWN0b3I7XG4gIGlmICh0aGlzLiRfX2lzTmVzdGVkKSB7XG4gICAgdG9wTGV2ZWxNb2RlbCA9IHRoaXMuJF9fW3Njb3BlU3ltYm9sXS5jb25zdHJ1Y3RvcjtcbiAgICBjb25zdCBuZXN0ZWRQYXRoID0gdGhpcy4kX18ubmVzdGVkUGF0aDtcbiAgICBwYXRocy5mb3JFYWNoKGZ1bmN0aW9uKHBvcHVsYXRlT3B0aW9ucykge1xuICAgICAgcG9wdWxhdGVPcHRpb25zLnBhdGggPSBuZXN0ZWRQYXRoICsgJy4nICsgcG9wdWxhdGVPcHRpb25zLnBhdGg7XG4gICAgfSk7XG4gIH1cblxuICAvLyBVc2UgYCRzZXNzaW9uKClgIGJ5IGRlZmF1bHQgaWYgdGhlIGRvY3VtZW50IGhhcyBhbiBhc3NvY2lhdGVkIHNlc3Npb25cbiAgLy8gU2VlIGdoLTY3NTRcbiAgaWYgKHRoaXMuJHNlc3Npb24oKSAhPSBudWxsKSB7XG4gICAgY29uc3Qgc2Vzc2lvbiA9IHRoaXMuJHNlc3Npb24oKTtcbiAgICBwYXRocy5mb3JFYWNoKHBhdGggPT4ge1xuICAgICAgaWYgKHBhdGgub3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIHBhdGgub3B0aW9ucyA9IHsgc2Vzc2lvbjogc2Vzc2lvbiB9O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoISgnc2Vzc2lvbicgaW4gcGF0aC5vcHRpb25zKSkge1xuICAgICAgICBwYXRoLm9wdGlvbnMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwYXRocy5mb3JFYWNoKHAgPT4ge1xuICAgIHAuX2xvY2FsTW9kZWwgPSB0b3BMZXZlbE1vZGVsO1xuICB9KTtcblxuICByZXR1cm4gdG9wTGV2ZWxNb2RlbC5wb3B1bGF0ZSh0aGlzLCBwYXRocyk7XG59O1xuXG4vKipcbiAqIEdldHMgYWxsIHBvcHVsYXRlZCBkb2N1bWVudHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZG9jdW1lbnQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEByZXR1cm4ge0RvY3VtZW50W119IGFycmF5IG9mIHBvcHVsYXRlZCBkb2N1bWVudHMuIEVtcHR5IGFycmF5IGlmIHRoZXJlIGFyZSBubyBwb3B1bGF0ZWQgZG9jdW1lbnRzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGRvY3VtZW50LlxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAbWV0aG9kICRnZXRQb3B1bGF0ZWREb2NzXG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJGdldFBvcHVsYXRlZERvY3MgPSBmdW5jdGlvbiAkZ2V0UG9wdWxhdGVkRG9jcygpIHtcbiAgbGV0IGtleXMgPSBbXTtcbiAgaWYgKHRoaXMuJF9fLnBvcHVsYXRlZCAhPSBudWxsKSB7XG4gICAga2V5cyA9IGtleXMuY29uY2F0KE9iamVjdC5rZXlzKHRoaXMuJF9fLnBvcHVsYXRlZCkpO1xuICB9XG4gIGxldCByZXN1bHQgPSBbXTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy4kZ2V0KGtleSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogR2V0cyBfaWQocykgdXNlZCBkdXJpbmcgcG9wdWxhdGlvbiBvZiB0aGUgZ2l2ZW4gYHBhdGhgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgZG9jID0gYXdhaXQgTW9kZWwuZmluZE9uZSgpLnBvcHVsYXRlKCdhdXRob3InKTtcbiAqXG4gKiAgICAgY29uc29sZS5sb2coZG9jLmF1dGhvci5uYW1lKTsgLy8gRHIuU2V1c3NcbiAqICAgICBjb25zb2xlLmxvZyhkb2MucG9wdWxhdGVkKCdhdXRob3InKSk7IC8vICc1MTQ0Y2Y4MDUwZjA3MWQ5NzljMTE4YTcnXG4gKlxuICogSWYgdGhlIHBhdGggd2FzIG5vdCBwb3B1bGF0ZWQsIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7QW55fSBbdmFsXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHJldHVybiB7QXJyYXl8T2JqZWN0SWR8TnVtYmVyfEJ1ZmZlcnxTdHJpbmd8dW5kZWZpbmVkfVxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRG9jdW1lbnQucHJvdG90eXBlLnBvcHVsYXRlZCA9IGZ1bmN0aW9uKHBhdGgsIHZhbCwgb3B0aW9ucykge1xuICAvLyB2YWwgYW5kIG9wdGlvbnMgYXJlIGludGVybmFsXG4gIGlmICh2YWwgPT0gbnVsbCB8fCB2YWwgPT09IHRydWUpIHtcbiAgICBpZiAoIXRoaXMuJF9fLnBvcHVsYXRlZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBNYXAgcGF0aHMgY2FuIGJlIHBvcHVsYXRlZCB3aXRoIGVpdGhlciBgcGF0aC4kKmAgb3IganVzdCBgcGF0aGBcbiAgICBjb25zdCBfcGF0aCA9IHBhdGguZW5kc1dpdGgoJy4kKicpID8gcGF0aC5yZXBsYWNlKC9cXC5cXCRcXCokLywgJycpIDogcGF0aDtcblxuICAgIGNvbnN0IHYgPSB0aGlzLiRfXy5wb3B1bGF0ZWRbX3BhdGhdO1xuICAgIGlmICh2KSB7XG4gICAgICByZXR1cm4gdmFsID09PSB0cnVlID8gdiA6IHYudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICB0aGlzLiRfXy5wb3B1bGF0ZWQgfHwgKHRoaXMuJF9fLnBvcHVsYXRlZCA9IHt9KTtcbiAgdGhpcy4kX18ucG9wdWxhdGVkW3BhdGhdID0geyB2YWx1ZTogdmFsLCBvcHRpb25zOiBvcHRpb25zIH07XG5cbiAgLy8gSWYgdGhpcyB3YXMgYSBuZXN0ZWQgcG9wdWxhdGUsIG1ha2Ugc3VyZSBlYWNoIHBvcHVsYXRlZCBkb2Mga25vd3NcbiAgLy8gYWJvdXQgaXRzIHBvcHVsYXRlZCBjaGlsZHJlbiAoZ2gtNzY4NSlcbiAgY29uc3QgcGllY2VzID0gcGF0aC5zcGxpdCgnLicpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBpZWNlcy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICBjb25zdCBzdWJwYXRoID0gcGllY2VzLnNsaWNlKDAsIGkgKyAxKS5qb2luKCcuJyk7XG4gICAgY29uc3Qgc3ViZG9jID0gdGhpcy4kZ2V0KHN1YnBhdGgpO1xuICAgIGlmIChzdWJkb2MgIT0gbnVsbCAmJiBzdWJkb2MuJF9fICE9IG51bGwgJiYgdGhpcy4kcG9wdWxhdGVkKHN1YnBhdGgpKSB7XG4gICAgICBjb25zdCByZXN0ID0gcGllY2VzLnNsaWNlKGkgKyAxKS5qb2luKCcuJyk7XG4gICAgICBzdWJkb2MuJHBvcHVsYXRlZChyZXN0LCB2YWwsIG9wdGlvbnMpO1xuICAgICAgLy8gTm8gbmVlZCB0byBjb250aW51ZSBiZWNhdXNlIHRoZSBhYm92ZSByZWN1cnNpb24gc2hvdWxkIHRha2UgY2FyZSBvZlxuICAgICAgLy8gbWFya2luZyB0aGUgcmVzdCBvZiB0aGUgZG9jcyBhcyBwb3B1bGF0ZWRcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YWw7XG59O1xuXG4vKipcbiAqIEFsaWFzIG9mIFtgLnBvcHVsYXRlZGBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudC5wcm90b3R5cGUucG9wdWxhdGVkKCkpLlxuICpcbiAqIEBtZXRob2QgJHBvcHVsYXRlZFxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kcG9wdWxhdGVkID0gRG9jdW1lbnQucHJvdG90eXBlLnBvcHVsYXRlZDtcblxuLyoqXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgYSBnaXZlbiBwYXRoIGlzIG5vdCBwb3B1bGF0ZWRcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGRvYyA9IGF3YWl0IE1vZGVsLmZpbmRPbmUoKS5wb3B1bGF0ZSgnYXV0aG9yJyk7XG4gKlxuICogICAgIGRvYy4kYXNzZXJ0UG9wdWxhdGVkKCdhdXRob3InKTsgLy8gZG9lcyBub3QgdGhyb3dcbiAqICAgICBkb2MuJGFzc2VydFBvcHVsYXRlZCgnb3RoZXIgcGF0aCcpOyAvLyB0aHJvd3MgYW4gZXJyb3JcbiAqXG4gKiAgICAgLy8gTWFudWFsbHkgcG9wdWxhdGUgYW5kIGFzc2VydCBpbiBvbmUgY2FsbC4gVGhlIGZvbGxvd2luZyBkb2VzXG4gKiAgICAgLy8gYGRvYy4kc2V0KHsgbGlrZXMgfSlgIGJlZm9yZSBhc3NlcnRpbmcuXG4gKiAgICAgZG9jLiRhc3NlcnRQb3B1bGF0ZWQoJ2xpa2VzJywgeyBsaWtlcyB9KTtcbiAqXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW119IHBhdGggcGF0aCBvciBhcnJheSBvZiBwYXRocyB0byBjaGVjay4gYCRhc3NlcnRQb3B1bGF0ZWRgIHRocm93cyBpZiBhbnkgb2YgdGhlIGdpdmVuIHBhdGhzIGlzIG5vdCBwb3B1bGF0ZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gW3ZhbHVlc10gb3B0aW9uYWwgdmFsdWVzIHRvIGAkc2V0KClgLiBDb252ZW5pZW50IGlmIHlvdSB3YW50IHRvIG1hbnVhbGx5IHBvcHVsYXRlIGEgcGF0aCBhbmQgYXNzZXJ0IHRoYXQgdGhlIHBhdGggd2FzIHBvcHVsYXRlZCBpbiAxIGNhbGwuXG4gKiBAcmV0dXJuIHtEb2N1bWVudH0gdGhpc1xuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAbWV0aG9kICRhc3NlcnRQb3B1bGF0ZWRcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJGFzc2VydFBvcHVsYXRlZCA9IGZ1bmN0aW9uICRhc3NlcnRQb3B1bGF0ZWQocGF0aCwgdmFsdWVzKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgcGF0aC5mb3JFYWNoKHAgPT4gdGhpcy4kYXNzZXJ0UG9wdWxhdGVkKHAsIHZhbHVlcykpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgdGhpcy4kc2V0KHZhbHVlcyk7XG4gIH1cblxuICBpZiAoIXRoaXMuJHBvcHVsYXRlZChwYXRoKSkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKGBFeHBlY3RlZCBwYXRoIFwiJHtwYXRofVwiIHRvIGJlIHBvcHVsYXRlZGApO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFRha2VzIGEgcG9wdWxhdGVkIGZpZWxkIGFuZCByZXR1cm5zIGl0IHRvIGl0cyB1bnBvcHVsYXRlZCBzdGF0ZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIE1vZGVsLmZpbmRPbmUoKS5wb3B1bGF0ZSgnYXV0aG9yJykuZXhlYyhmdW5jdGlvbiAoZXJyLCBkb2MpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKGRvYy5hdXRob3IubmFtZSk7IC8vIERyLlNldXNzXG4gKiAgICAgICBjb25zb2xlLmxvZyhkb2MuZGVwb3B1bGF0ZSgnYXV0aG9yJykpO1xuICogICAgICAgY29uc29sZS5sb2coZG9jLmF1dGhvcik7IC8vICc1MTQ0Y2Y4MDUwZjA3MWQ5NzljMTE4YTcnXG4gKiAgICAgfSlcbiAqXG4gKiBJZiB0aGUgcGF0aCB3YXMgbm90IHByb3ZpZGVkLCB0aGVuIGFsbCBwb3B1bGF0ZWQgZmllbGRzIGFyZSByZXR1cm5lZCB0byB0aGVpciB1bnBvcHVsYXRlZCBzdGF0ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xTdHJpbmdbXX0gW3BhdGhdIFNwZWNpZmljIFBhdGggdG8gZGVwb3B1bGF0ZS4gSWYgdW5zZXQsIHdpbGwgZGVwb3B1bGF0ZSBhbGwgcGF0aHMgb24gdGhlIERvY3VtZW50LiBPciBtdWx0aXBsZSBzcGFjZS1kZWxpbWl0ZWQgcGF0aHMuXG4gKiBAcmV0dXJuIHtEb2N1bWVudH0gdGhpc1xuICogQHNlZSBEb2N1bWVudC5wb3B1bGF0ZSBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLnBvcHVsYXRlKClcbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS5kZXBvcHVsYXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgcGF0aCA9IHBhdGguaW5kZXhPZignICcpID09PSAtMSA/IFtwYXRoXSA6IHBhdGguc3BsaXQoJyAnKTtcbiAgfVxuXG4gIGxldCBwb3B1bGF0ZWRJZHM7XG4gIGNvbnN0IHZpcnR1YWxLZXlzID0gdGhpcy4kJHBvcHVsYXRlZFZpcnR1YWxzID8gT2JqZWN0LmtleXModGhpcy4kJHBvcHVsYXRlZFZpcnR1YWxzKSA6IFtdO1xuICBjb25zdCBwb3B1bGF0ZWQgPSB0aGlzLiRfXyAmJiB0aGlzLiRfXy5wb3B1bGF0ZWQgfHwge307XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAvLyBEZXBvcHVsYXRlIGFsbFxuICAgIGZvciAoY29uc3QgdmlydHVhbEtleSBvZiB2aXJ0dWFsS2V5cykge1xuICAgICAgZGVsZXRlIHRoaXMuJCRwb3B1bGF0ZWRWaXJ0dWFsc1t2aXJ0dWFsS2V5XTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9kb2NbdmlydHVhbEtleV07XG4gICAgICBkZWxldGUgcG9wdWxhdGVkW3ZpcnR1YWxLZXldO1xuICAgIH1cblxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwb3B1bGF0ZWQpO1xuXG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgcG9wdWxhdGVkSWRzID0gdGhpcy4kcG9wdWxhdGVkKGtleSk7XG4gICAgICBpZiAoIXBvcHVsYXRlZElkcykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBwb3B1bGF0ZWRba2V5XTtcbiAgICAgIHV0aWxzLnNldFZhbHVlKGtleSwgcG9wdWxhdGVkSWRzLCB0aGlzLl9kb2MpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGZvciAoY29uc3Qgc2luZ2xlUGF0aCBvZiBwYXRoKSB7XG4gICAgcG9wdWxhdGVkSWRzID0gdGhpcy4kcG9wdWxhdGVkKHNpbmdsZVBhdGgpO1xuICAgIGRlbGV0ZSBwb3B1bGF0ZWRbc2luZ2xlUGF0aF07XG5cbiAgICBpZiAodmlydHVhbEtleXMuaW5kZXhPZihzaW5nbGVQYXRoKSAhPT0gLTEpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLiQkcG9wdWxhdGVkVmlydHVhbHNbc2luZ2xlUGF0aF07XG4gICAgICBkZWxldGUgdGhpcy5fZG9jW3NpbmdsZVBhdGhdO1xuICAgIH0gZWxzZSBpZiAocG9wdWxhdGVkSWRzKSB7XG4gICAgICB1dGlscy5zZXRWYWx1ZShzaW5nbGVQYXRoLCBwb3B1bGF0ZWRJZHMsIHRoaXMuX2RvYyk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGZ1bGwgcGF0aCB0byB0aGlzIGRvY3VtZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICogQG1ldGhvZCAkX19mdWxsUGF0aFxuICogQG1lbWJlck9mIERvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Eb2N1bWVudC5wcm90b3R5cGUuJF9fZnVsbFBhdGggPSBmdW5jdGlvbihwYXRoKSB7XG4gIC8vIG92ZXJyaWRkZW4gaW4gU3ViRG9jdW1lbnRzXG4gIHJldHVybiBwYXRoIHx8ICcnO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjaGFuZ2VzIHRoYXQgaGFwcGVuZWQgdG8gdGhlIGRvY3VtZW50XG4gKiBpbiB0aGUgZm9ybWF0IHRoYXQgd2lsbCBiZSBzZW50IHRvIE1vbmdvREIuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCB1c2VyU2NoZW1hID0gbmV3IFNjaGVtYSh7XG4gKiAgICAgICBuYW1lOiBTdHJpbmcsXG4gKiAgICAgICBhZ2U6IE51bWJlcixcbiAqICAgICAgIGNvdW50cnk6IFN0cmluZ1xuICogICAgIH0pO1xuICogICAgIGNvbnN0IFVzZXIgPSBtb25nb29zZS5tb2RlbCgnVXNlcicsIHVzZXJTY2hlbWEpO1xuICogICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBVc2VyLmNyZWF0ZSh7XG4gKiAgICAgICBuYW1lOiAnSGFmZXonLFxuICogICAgICAgYWdlOiAyNSxcbiAqICAgICAgIGNvdW50cnk6ICdFZ3lwdCdcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gcmV0dXJucyBhbiBlbXB0eSBvYmplY3QsIG5vIGNoYW5nZXMgaGFwcGVuZWQgeWV0XG4gKiAgICAgdXNlci5nZXRDaGFuZ2VzKCk7IC8vIHsgfVxuICpcbiAqICAgICB1c2VyLmNvdW50cnkgPSB1bmRlZmluZWQ7XG4gKiAgICAgdXNlci5hZ2UgPSAyNjtcbiAqXG4gKiAgICAgdXNlci5nZXRDaGFuZ2VzKCk7IC8vIHsgJHNldDogeyBhZ2U6IDI2IH0sIHsgJHVuc2V0OiB7IGNvdW50cnk6IDEgfSB9IH1cbiAqXG4gKiAgICAgYXdhaXQgdXNlci5zYXZlKCk7XG4gKlxuICogICAgIHVzZXIuZ2V0Q2hhbmdlcygpOyAvLyB7IH1cbiAqXG4gKiBNb2RpZnlpbmcgdGhlIG9iamVjdCB0aGF0IGBnZXRDaGFuZ2VzKClgIHJldHVybnMgZG9lcyBub3QgYWZmZWN0IHRoZSBkb2N1bWVudCdzXG4gKiBjaGFuZ2UgdHJhY2tpbmcgc3RhdGUuIEV2ZW4gaWYgeW91IGBkZWxldGUgdXNlci5nZXRDaGFuZ2VzKCkuJHNldGAsIE1vbmdvb3NlXG4gKiB3aWxsIHN0aWxsIHNlbmQgYSBgJHNldGAgdG8gdGhlIHNlcnZlci5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCBnZXRDaGFuZ2VzXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS5nZXRDaGFuZ2VzID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IGRlbHRhID0gdGhpcy4kX19kZWx0YSgpO1xuICBjb25zdCBjaGFuZ2VzID0gZGVsdGEgPyBkZWx0YVsxXSA6IHt9O1xuICByZXR1cm4gY2hhbmdlcztcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyBkb2N1bWVudCB3aXRoIGEgZGVlcCBjbG9uZSBvZiBgX2RvY2AgYW5kIGAkX19gLlxuICpcbiAqIEByZXR1cm4ge0RvY3VtZW50fSBhIGNvcHkgb2YgdGhpcyBkb2N1bWVudFxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgJGNsb25lXG4gKiBAbWVtYmVyT2YgRG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICovXG5cbkRvY3VtZW50LnByb3RvdHlwZS4kY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgTW9kZWwgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICBjb25zdCBjbG9uZWREb2MgPSBuZXcgTW9kZWwoKTtcbiAgY2xvbmVkRG9jLiRpc05ldyA9IHRoaXMuJGlzTmV3O1xuICBpZiAodGhpcy5fZG9jKSB7XG4gICAgY2xvbmVkRG9jLl9kb2MgPSBjbG9uZSh0aGlzLl9kb2MsIHsgcmV0YWluRG9jdW1lbnRzOiB0cnVlIH0pO1xuICB9XG4gIGlmICh0aGlzLiRfXykge1xuICAgIGNvbnN0IENhY2hlID0gdGhpcy4kX18uY29uc3RydWN0b3I7XG4gICAgY29uc3QgY2xvbmVkQ2FjaGUgPSBuZXcgQ2FjaGUoKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLiRfXykpIHtcbiAgICAgIGlmIChrZXkgPT09ICdhY3RpdmVQYXRocycpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjbG9uZWRDYWNoZVtrZXldID0gY2xvbmUodGhpcy4kX19ba2V5XSk7XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24oY2xvbmVkQ2FjaGUuYWN0aXZlUGF0aHMsIGNsb25lKHsgLi4udGhpcy4kX18uYWN0aXZlUGF0aHMgfSkpO1xuICAgIGNsb25lZERvYy4kX18gPSBjbG9uZWRDYWNoZTtcbiAgfVxuICByZXR1cm4gY2xvbmVkRG9jO1xufTtcblxuLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5Eb2N1bWVudC5WYWxpZGF0aW9uRXJyb3IgPSBWYWxpZGF0aW9uRXJyb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBEb2N1bWVudDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/document.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/documentProvider.js":
/*!****************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/documentProvider.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* eslint-env browser */\n\n/*!\n * Module dependencies.\n */\nconst Document = __webpack_require__(/*! ./document.js */ \"../backend/node_modules/mongoose/lib/document.js\");\nconst BrowserDocument = __webpack_require__(/*! ./browserDocument.js */ \"../backend/node_modules/mongoose/lib/browserDocument.js\");\n\nlet isBrowser = false;\n\n/**\n * Returns the Document constructor for the current context\n *\n * @api private\n */\nmodule.exports = function documentProvider() {\n  if (isBrowser) {\n    return BrowserDocument;\n  }\n  return Document;\n};\n\n/*!\n * ignore\n */\nmodule.exports.setBrowser = function(flag) {\n  isBrowser = flag;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2RvY3VtZW50UHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsdUVBQWU7QUFDeEMsd0JBQXdCLG1CQUFPLENBQUMscUZBQXNCOztBQUV0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2RvY3VtZW50UHJvdmlkZXIuanM/YWE4NSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cbmNvbnN0IERvY3VtZW50ID0gcmVxdWlyZSgnLi9kb2N1bWVudC5qcycpO1xuY29uc3QgQnJvd3NlckRvY3VtZW50ID0gcmVxdWlyZSgnLi9icm93c2VyRG9jdW1lbnQuanMnKTtcblxubGV0IGlzQnJvd3NlciA9IGZhbHNlO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIERvY3VtZW50IGNvbnN0cnVjdG9yIGZvciB0aGUgY3VycmVudCBjb250ZXh0XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZG9jdW1lbnRQcm92aWRlcigpIHtcbiAgaWYgKGlzQnJvd3Nlcikge1xuICAgIHJldHVybiBCcm93c2VyRG9jdW1lbnQ7XG4gIH1cbiAgcmV0dXJuIERvY3VtZW50O1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xubW9kdWxlLmV4cG9ydHMuc2V0QnJvd3NlciA9IGZ1bmN0aW9uKGZsYWcpIHtcbiAgaXNCcm93c2VyID0gZmxhZztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/documentProvider.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/driver.js":
/*!******************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/driver.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nlet driver = null;\n\nmodule.exports.get = function() {\n  return driver;\n};\n\nmodule.exports.set = function(v) {\n  driver = v;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2RyaXZlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZHJpdmVyLmpzPzMzYzAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmxldCBkcml2ZXIgPSBudWxsO1xuXG5tb2R1bGUuZXhwb3J0cy5nZXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGRyaXZlcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzLnNldCA9IGZ1bmN0aW9uKHYpIHtcbiAgZHJpdmVyID0gdjtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/driver.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/drivers/node-mongodb-native/collection.js":
/*!**************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/drivers/node-mongodb-native/collection.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseCollection = __webpack_require__(/*! ../../collection */ \"../backend/node_modules/mongoose/lib/collection.js\");\nconst MongooseError = __webpack_require__(/*! ../../error/mongooseError */ \"../backend/node_modules/mongoose/lib/error/mongooseError.js\");\nconst Collection = (__webpack_require__(/*! mongodb */ \"../backend/node_modules/mongodb/lib/index.js\").Collection);\nconst ObjectId = __webpack_require__(/*! ../../types/objectid */ \"../backend/node_modules/mongoose/lib/types/objectid.js\");\nconst getConstructorName = __webpack_require__(/*! ../../helpers/getConstructorName */ \"../backend/node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst internalToObjectOptions = (__webpack_require__(/*! ../../options */ \"../backend/node_modules/mongoose/lib/options.js\").internalToObjectOptions);\nconst stream = __webpack_require__(/*! stream */ \"stream\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\n/**\n * A [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) collection implementation.\n *\n * All methods methods from the [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) driver are copied and wrapped in queue management.\n *\n * @inherits Collection https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html\n * @api private\n */\n\nfunction NativeCollection(name, conn, options) {\n  this.collection = null;\n  this.Promise = options.Promise || Promise;\n  this.modelName = options.modelName;\n  delete options.modelName;\n  this._closed = false;\n  MongooseCollection.apply(this, arguments);\n}\n\n/*!\n * Inherit from abstract Collection.\n */\n\nObject.setPrototypeOf(NativeCollection.prototype, MongooseCollection.prototype);\n\n/**\n * Called when the connection opens.\n *\n * @api private\n */\n\nNativeCollection.prototype.onOpen = function() {\n  this.collection = this.conn.db.collection(this.name);\n  MongooseCollection.prototype.onOpen.call(this);\n  return this.collection;\n};\n\n/**\n * Called when the connection closes\n *\n * @api private\n */\n\nNativeCollection.prototype.onClose = function(force) {\n  MongooseCollection.prototype.onClose.call(this, force);\n};\n\n/**\n * Helper to get the collection, in case `this.collection` isn't set yet.\n * May happen if `bufferCommands` is false and created the model when\n * Mongoose was disconnected.\n *\n * @api private\n */\n\nNativeCollection.prototype._getCollection = function _getCollection() {\n  if (this.collection) {\n    return this.collection;\n  }\n  if (this.conn.db != null) {\n    this.collection = this.conn.db.collection(this.name);\n    return this.collection;\n  }\n  return null;\n};\n\n/*!\n * ignore\n */\n\nconst syncCollectionMethods = { watch: true, find: true, aggregate: true };\n\n/**\n * Copy the collection methods and make them subject to queues\n * @param {Number|String} I\n * @api private\n */\n\nfunction iter(i) {\n  NativeCollection.prototype[i] = function() {\n    const collection = this._getCollection();\n    const args = Array.from(arguments);\n    const _this = this;\n    const globalDebug = _this &&\n      _this.conn &&\n      _this.conn.base &&\n      _this.conn.base.options &&\n      _this.conn.base.options.debug;\n    const connectionDebug = _this &&\n      _this.conn &&\n      _this.conn.options &&\n      _this.conn.options.debug;\n    const debug = connectionDebug == null ? globalDebug : connectionDebug;\n    const lastArg = arguments[arguments.length - 1];\n    const opId = new ObjectId();\n\n    // If user force closed, queueing will hang forever. See #5664\n    if (this.conn.$wasForceClosed) {\n      const error = new MongooseError('Connection was force closed');\n      if (args.length > 0 &&\n        typeof args[args.length - 1] === 'function') {\n        args[args.length - 1](error);\n        return;\n      } else {\n        throw error;\n      }\n    }\n\n    let _args = args;\n    let callback = null;\n    if (this._shouldBufferCommands() && this.buffer) {\n      this.conn.emit('buffer', {\n        _id: opId,\n        modelName: _this.modelName,\n        collectionName: _this.name,\n        method: i,\n        args: args\n      });\n\n      let callback;\n      let _args = args;\n      let promise = null;\n      let timeout = null;\n      if (syncCollectionMethods[i] && typeof lastArg === 'function') {\n        this.addQueue(i, _args);\n        callback = lastArg;\n      } else if (syncCollectionMethods[i]) {\n        promise = new this.Promise((resolve, reject) => {\n          callback = function collectionOperationCallback(err, res) {\n            if (timeout != null) {\n              clearTimeout(timeout);\n            }\n            if (err != null) {\n              return reject(err);\n            }\n            resolve(res);\n          };\n          _args = args.concat([callback]);\n          this.addQueue(i, _args);\n        });\n      } else if (typeof lastArg === 'function') {\n        callback = function collectionOperationCallback() {\n          if (timeout != null) {\n            clearTimeout(timeout);\n          }\n          return lastArg.apply(this, arguments);\n        };\n        _args = args.slice(0, args.length - 1).concat([callback]);\n      } else {\n        promise = new Promise((resolve, reject) => {\n          callback = function collectionOperationCallback(err, res) {\n            if (timeout != null) {\n              clearTimeout(timeout);\n            }\n            if (err != null) {\n              return reject(err);\n            }\n            resolve(res);\n          };\n          _args = args.concat([callback]);\n          this.addQueue(i, _args);\n        });\n      }\n\n      const bufferTimeoutMS = this._getBufferTimeoutMS();\n      timeout = setTimeout(() => {\n        const removed = this.removeQueue(i, _args);\n        if (removed) {\n          const message = 'Operation `' + this.name + '.' + i + '()` buffering timed out after ' +\n            bufferTimeoutMS + 'ms';\n          const err = new MongooseError(message);\n          this.conn.emit('buffer-end', { _id: opId, modelName: _this.modelName, collectionName: _this.name, method: i, error: err });\n          callback(err);\n        }\n      }, bufferTimeoutMS);\n\n      if (!syncCollectionMethods[i] && typeof lastArg === 'function') {\n        this.addQueue(i, _args);\n        return;\n      }\n\n      return promise;\n    } else if (!syncCollectionMethods[i] && typeof lastArg === 'function') {\n      callback = function collectionOperationCallback(err, res) {\n        if (err != null) {\n          _this.conn.emit('operation-end', { _id: opId, modelName: _this.modelName, collectionName: _this.name, method: i, error: err });\n        } else {\n          _this.conn.emit('operation-end', { _id: opId, modelName: _this.modelName, collectionName: _this.name, method: i, result: res });\n        }\n        return lastArg.apply(this, arguments);\n      };\n      _args = args.slice(0, args.length - 1).concat([callback]);\n    }\n\n    if (debug) {\n      if (typeof debug === 'function') {\n        let argsToAdd = null;\n        if (typeof args[args.length - 1] == 'function') {\n          argsToAdd = args.slice(0, args.length - 1);\n        } else {\n          argsToAdd = args;\n        }\n        debug.apply(_this,\n          [_this.name, i].concat(argsToAdd));\n      } else if (debug instanceof stream.Writable) {\n        this.$printToStream(_this.name, i, args, debug);\n      } else {\n        const color = debug.color == null ? true : debug.color;\n        const shell = debug.shell == null ? false : debug.shell;\n        this.$print(_this.name, i, args, color, shell);\n      }\n    }\n\n    this.conn.emit('operation-start', { _id: opId, modelName: _this.modelName, collectionName: this.name, method: i, params: _args });\n\n    try {\n      if (collection == null) {\n        const message = 'Cannot call `' + this.name + '.' + i + '()` before initial connection ' +\n          'is complete if `bufferCommands = false`. Make sure you `await mongoose.connect()` if ' +\n          'you have `bufferCommands = false`.';\n        throw new MongooseError(message);\n      }\n\n      if (syncCollectionMethods[i] && typeof lastArg === 'function') {\n        const ret = collection[i].apply(collection, _args.slice(0, _args.length - 1));\n        return lastArg.call(this, null, ret);\n      }\n\n      const ret = collection[i].apply(collection, _args);\n      if (ret != null && typeof ret.then === 'function') {\n        return ret.then(\n          res => {\n            typeof lastArg === 'function' && lastArg(null, res);\n            return res;\n          },\n          err => {\n            if (typeof lastArg === 'function') {\n              lastArg(err);\n              return;\n            }\n            throw err;\n          }\n        );\n      }\n      return ret;\n    } catch (error) {\n      // Collection operation may throw because of max bson size, catch it here\n      // See gh-3906\n      if (typeof lastArg === 'function') {\n        return lastArg(error);\n      } else {\n        this.conn.emit('operation-end', { _id: opId, modelName: _this.modelName, collectionName: this.name, method: i, error: error });\n\n        throw error;\n      }\n    }\n  };\n}\n\nfor (const key of Object.getOwnPropertyNames(Collection.prototype)) {\n  // Janky hack to work around gh-3005 until we can get rid of the mongoose\n  // collection abstraction\n  const descriptor = Object.getOwnPropertyDescriptor(Collection.prototype, key);\n  // Skip properties with getters because they may throw errors (gh-8528)\n  if (descriptor.get !== undefined) {\n    continue;\n  }\n  if (typeof Collection.prototype[key] !== 'function') {\n    continue;\n  }\n\n  iter(key);\n}\n\n/**\n * Debug print helper\n *\n * @api public\n * @method $print\n */\n\nNativeCollection.prototype.$print = function(name, i, args, color, shell) {\n  const moduleName = color ? '\\x1B[0;36mMongoose:\\x1B[0m ' : 'Mongoose: ';\n  const functionCall = [name, i].join('.');\n  const _args = [];\n  for (let j = args.length - 1; j >= 0; --j) {\n    if (this.$format(args[j]) || _args.length) {\n      _args.unshift(this.$format(args[j], color, shell));\n    }\n  }\n  const params = '(' + _args.join(', ') + ')';\n\n  console.info(moduleName + functionCall + params);\n};\n\n/**\n * Debug print helper\n *\n * @api public\n * @method $print\n */\n\nNativeCollection.prototype.$printToStream = function(name, i, args, stream) {\n  const functionCall = [name, i].join('.');\n  const _args = [];\n  for (let j = args.length - 1; j >= 0; --j) {\n    if (this.$format(args[j]) || _args.length) {\n      _args.unshift(this.$format(args[j]));\n    }\n  }\n  const params = '(' + _args.join(', ') + ')';\n\n  stream.write(functionCall + params, 'utf8');\n};\n\n/**\n * Formatter for debug print args\n *\n * @api public\n * @method $format\n */\n\nNativeCollection.prototype.$format = function(arg, color, shell) {\n  const type = typeof arg;\n  if (type === 'function' || type === 'undefined') return '';\n  return format(arg, false, color, shell);\n};\n\n/**\n * Debug print helper\n * @param {Any} representation\n * @api private\n */\n\nfunction inspectable(representation) {\n  const ret = {\n    inspect: function() { return representation; }\n  };\n  if (util.inspect.custom) {\n    ret[util.inspect.custom] = ret.inspect;\n  }\n  return ret;\n}\nfunction map(o) {\n  return format(o, true);\n}\nfunction formatObjectId(x, key) {\n  x[key] = inspectable('ObjectId(\"' + x[key].toHexString() + '\")');\n}\nfunction formatDate(x, key, shell) {\n  if (shell) {\n    x[key] = inspectable('ISODate(\"' + x[key].toUTCString() + '\")');\n  } else {\n    x[key] = inspectable('new Date(\"' + x[key].toUTCString() + '\")');\n  }\n}\nfunction format(obj, sub, color, shell) {\n  if (obj && typeof obj.toBSON === 'function') {\n    obj = obj.toBSON();\n  }\n  if (obj == null) {\n    return obj;\n  }\n\n  const clone = __webpack_require__(/*! ../../helpers/clone */ \"../backend/node_modules/mongoose/lib/helpers/clone.js\");\n  let x = clone(obj, internalToObjectOptions);\n  const constructorName = getConstructorName(x);\n\n  if (constructorName === 'Binary') {\n    x = 'BinData(' + x.sub_type + ', \"' + x.toString('base64') + '\")';\n  } else if (constructorName === 'ObjectId') {\n    x = inspectable('ObjectId(\"' + x.toHexString() + '\")');\n  } else if (constructorName === 'Date') {\n    x = inspectable('new Date(\"' + x.toUTCString() + '\")');\n  } else if (constructorName === 'Object') {\n    const keys = Object.keys(x);\n    const numKeys = keys.length;\n    let key;\n    for (let i = 0; i < numKeys; ++i) {\n      key = keys[i];\n      if (x[key]) {\n        let error;\n        if (typeof x[key].toBSON === 'function') {\n          try {\n            // `session.toBSON()` throws an error. This means we throw errors\n            // in debug mode when using transactions, see gh-6712. As a\n            // workaround, catch `toBSON()` errors, try to serialize without\n            // `toBSON()`, and rethrow if serialization still fails.\n            x[key] = x[key].toBSON();\n          } catch (_error) {\n            error = _error;\n          }\n        }\n        const _constructorName = getConstructorName(x[key]);\n        if (_constructorName === 'Binary') {\n          x[key] = 'BinData(' + x[key].sub_type + ', \"' +\n            x[key].buffer.toString('base64') + '\")';\n        } else if (_constructorName === 'Object') {\n          x[key] = format(x[key], true);\n        } else if (_constructorName === 'ObjectId') {\n          formatObjectId(x, key);\n        } else if (_constructorName === 'Date') {\n          formatDate(x, key, shell);\n        } else if (_constructorName === 'ClientSession') {\n          x[key] = inspectable('ClientSession(\"' +\n            (\n              x[key] &&\n              x[key].id &&\n              x[key].id.id &&\n              x[key].id.id.buffer || ''\n            ).toString('hex') + '\")');\n        } else if (Array.isArray(x[key])) {\n          x[key] = x[key].map(map);\n        } else if (error != null) {\n          // If there was an error with `toBSON()` and the object wasn't\n          // already converted to a string representation, rethrow it.\n          // Open to better ideas on how to handle this.\n          throw error;\n        }\n      }\n    }\n  }\n  if (sub) {\n    return x;\n  }\n\n  return util.\n    inspect(x, false, 10, color).\n    replace(/\\n/g, '').\n    replace(/\\s{2,}/g, ' ');\n}\n\n/**\n * Retrieves information about this collections indexes.\n *\n * @param {Function} callback\n * @method getIndexes\n * @api public\n */\n\nNativeCollection.prototype.getIndexes = NativeCollection.prototype.indexInformation;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = NativeCollection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2RyaXZlcnMvbm9kZS1tb25nb2RiLW5hdGl2ZS9jb2xsZWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsbUJBQU8sQ0FBQyw0RUFBa0I7QUFDckQsc0JBQXNCLG1CQUFPLENBQUMsOEZBQTJCO0FBQ3pELG1CQUFtQiwrRkFBNkI7QUFDaEQsaUJBQWlCLG1CQUFPLENBQUMsb0ZBQXNCO0FBQy9DLDJCQUEyQixtQkFBTyxDQUFDLDRHQUFrQztBQUNyRSxnQ0FBZ0MscUhBQWdEO0FBQ2hGLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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LFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2RyaXZlcnMvbm9kZS1tb25nb2RiLW5hdGl2ZS9jb2xsZWN0aW9uLmpzPzlhNmIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgTW9uZ29vc2VDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vY29sbGVjdGlvbicpO1xuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4uLy4uL2Vycm9yL21vbmdvb3NlRXJyb3InKTtcbmNvbnN0IENvbGxlY3Rpb24gPSByZXF1aXJlKCdtb25nb2RiJykuQ29sbGVjdGlvbjtcbmNvbnN0IE9iamVjdElkID0gcmVxdWlyZSgnLi4vLi4vdHlwZXMvb2JqZWN0aWQnKTtcbmNvbnN0IGdldENvbnN0cnVjdG9yTmFtZSA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvZ2V0Q29uc3RydWN0b3JOYW1lJyk7XG5jb25zdCBpbnRlcm5hbFRvT2JqZWN0T3B0aW9ucyA9IHJlcXVpcmUoJy4uLy4uL29wdGlvbnMnKS5pbnRlcm5hbFRvT2JqZWN0T3B0aW9ucztcbmNvbnN0IHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLyoqXG4gKiBBIFtub2RlLW1vbmdvZGItbmF0aXZlXShodHRwczovL2dpdGh1Yi5jb20vbW9uZ29kYi9ub2RlLW1vbmdvZGItbmF0aXZlKSBjb2xsZWN0aW9uIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEFsbCBtZXRob2RzIG1ldGhvZHMgZnJvbSB0aGUgW25vZGUtbW9uZ29kYi1uYXRpdmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tb25nb2RiL25vZGUtbW9uZ29kYi1uYXRpdmUpIGRyaXZlciBhcmUgY29waWVkIGFuZCB3cmFwcGVkIGluIHF1ZXVlIG1hbmFnZW1lbnQuXG4gKlxuICogQGluaGVyaXRzIENvbGxlY3Rpb24gaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0NvbGxlY3Rpb24uaHRtbFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gTmF0aXZlQ29sbGVjdGlvbihuYW1lLCBjb25uLCBvcHRpb25zKSB7XG4gIHRoaXMuY29sbGVjdGlvbiA9IG51bGw7XG4gIHRoaXMuUHJvbWlzZSA9IG9wdGlvbnMuUHJvbWlzZSB8fCBQcm9taXNlO1xuICB0aGlzLm1vZGVsTmFtZSA9IG9wdGlvbnMubW9kZWxOYW1lO1xuICBkZWxldGUgb3B0aW9ucy5tb2RlbE5hbWU7XG4gIHRoaXMuX2Nsb3NlZCA9IGZhbHNlO1xuICBNb25nb29zZUNvbGxlY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuLyohXG4gKiBJbmhlcml0IGZyb20gYWJzdHJhY3QgQ29sbGVjdGlvbi5cbiAqL1xuXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoTmF0aXZlQ29sbGVjdGlvbi5wcm90b3R5cGUsIE1vbmdvb3NlQ29sbGVjdGlvbi5wcm90b3R5cGUpO1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHRoZSBjb25uZWN0aW9uIG9wZW5zLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk5hdGl2ZUNvbGxlY3Rpb24ucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmNvbGxlY3Rpb24gPSB0aGlzLmNvbm4uZGIuY29sbGVjdGlvbih0aGlzLm5hbWUpO1xuICBNb25nb29zZUNvbGxlY3Rpb24ucHJvdG90eXBlLm9uT3Blbi5jYWxsKHRoaXMpO1xuICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiB0aGUgY29ubmVjdGlvbiBjbG9zZXNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5OYXRpdmVDb2xsZWN0aW9uLnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24oZm9yY2UpIHtcbiAgTW9uZ29vc2VDb2xsZWN0aW9uLnByb3RvdHlwZS5vbkNsb3NlLmNhbGwodGhpcywgZm9yY2UpO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IHRoZSBjb2xsZWN0aW9uLCBpbiBjYXNlIGB0aGlzLmNvbGxlY3Rpb25gIGlzbid0IHNldCB5ZXQuXG4gKiBNYXkgaGFwcGVuIGlmIGBidWZmZXJDb21tYW5kc2AgaXMgZmFsc2UgYW5kIGNyZWF0ZWQgdGhlIG1vZGVsIHdoZW5cbiAqIE1vbmdvb3NlIHdhcyBkaXNjb25uZWN0ZWQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTmF0aXZlQ29sbGVjdGlvbi5wcm90b3R5cGUuX2dldENvbGxlY3Rpb24gPSBmdW5jdGlvbiBfZ2V0Q29sbGVjdGlvbigpIHtcbiAgaWYgKHRoaXMuY29sbGVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLmNvbGxlY3Rpb247XG4gIH1cbiAgaWYgKHRoaXMuY29ubi5kYiAhPSBudWxsKSB7XG4gICAgdGhpcy5jb2xsZWN0aW9uID0gdGhpcy5jb25uLmRiLmNvbGxlY3Rpb24odGhpcy5uYW1lKTtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5jb25zdCBzeW5jQ29sbGVjdGlvbk1ldGhvZHMgPSB7IHdhdGNoOiB0cnVlLCBmaW5kOiB0cnVlLCBhZ2dyZWdhdGU6IHRydWUgfTtcblxuLyoqXG4gKiBDb3B5IHRoZSBjb2xsZWN0aW9uIG1ldGhvZHMgYW5kIG1ha2UgdGhlbSBzdWJqZWN0IHRvIHF1ZXVlc1xuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBJXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpdGVyKGkpIHtcbiAgTmF0aXZlQ29sbGVjdGlvbi5wcm90b3R5cGVbaV0gPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBjb2xsZWN0aW9uID0gdGhpcy5fZ2V0Q29sbGVjdGlvbigpO1xuICAgIGNvbnN0IGFyZ3MgPSBBcnJheS5mcm9tKGFyZ3VtZW50cyk7XG4gICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgIGNvbnN0IGdsb2JhbERlYnVnID0gX3RoaXMgJiZcbiAgICAgIF90aGlzLmNvbm4gJiZcbiAgICAgIF90aGlzLmNvbm4uYmFzZSAmJlxuICAgICAgX3RoaXMuY29ubi5iYXNlLm9wdGlvbnMgJiZcbiAgICAgIF90aGlzLmNvbm4uYmFzZS5vcHRpb25zLmRlYnVnO1xuICAgIGNvbnN0IGNvbm5lY3Rpb25EZWJ1ZyA9IF90aGlzICYmXG4gICAgICBfdGhpcy5jb25uICYmXG4gICAgICBfdGhpcy5jb25uLm9wdGlvbnMgJiZcbiAgICAgIF90aGlzLmNvbm4ub3B0aW9ucy5kZWJ1ZztcbiAgICBjb25zdCBkZWJ1ZyA9IGNvbm5lY3Rpb25EZWJ1ZyA9PSBudWxsID8gZ2xvYmFsRGVidWcgOiBjb25uZWN0aW9uRGVidWc7XG4gICAgY29uc3QgbGFzdEFyZyA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAgY29uc3Qgb3BJZCA9IG5ldyBPYmplY3RJZCgpO1xuXG4gICAgLy8gSWYgdXNlciBmb3JjZSBjbG9zZWQsIHF1ZXVlaW5nIHdpbGwgaGFuZyBmb3JldmVyLiBTZWUgIzU2NjRcbiAgICBpZiAodGhpcy5jb25uLiR3YXNGb3JjZUNsb3NlZCkge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgTW9uZ29vc2VFcnJvcignQ29ubmVjdGlvbiB3YXMgZm9yY2UgY2xvc2VkJyk7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPiAwICYmXG4gICAgICAgIHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgYXJnc1thcmdzLmxlbmd0aCAtIDFdKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IF9hcmdzID0gYXJncztcbiAgICBsZXQgY2FsbGJhY2sgPSBudWxsO1xuICAgIGlmICh0aGlzLl9zaG91bGRCdWZmZXJDb21tYW5kcygpICYmIHRoaXMuYnVmZmVyKSB7XG4gICAgICB0aGlzLmNvbm4uZW1pdCgnYnVmZmVyJywge1xuICAgICAgICBfaWQ6IG9wSWQsXG4gICAgICAgIG1vZGVsTmFtZTogX3RoaXMubW9kZWxOYW1lLFxuICAgICAgICBjb2xsZWN0aW9uTmFtZTogX3RoaXMubmFtZSxcbiAgICAgICAgbWV0aG9kOiBpLFxuICAgICAgICBhcmdzOiBhcmdzXG4gICAgICB9KTtcblxuICAgICAgbGV0IGNhbGxiYWNrO1xuICAgICAgbGV0IF9hcmdzID0gYXJncztcbiAgICAgIGxldCBwcm9taXNlID0gbnVsbDtcbiAgICAgIGxldCB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIGlmIChzeW5jQ29sbGVjdGlvbk1ldGhvZHNbaV0gJiYgdHlwZW9mIGxhc3RBcmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5hZGRRdWV1ZShpLCBfYXJncyk7XG4gICAgICAgIGNhbGxiYWNrID0gbGFzdEFyZztcbiAgICAgIH0gZWxzZSBpZiAoc3luY0NvbGxlY3Rpb25NZXRob2RzW2ldKSB7XG4gICAgICAgIHByb21pc2UgPSBuZXcgdGhpcy5Qcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uIGNvbGxlY3Rpb25PcGVyYXRpb25DYWxsYmFjayhlcnIsIHJlcykge1xuICAgICAgICAgICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXMpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgX2FyZ3MgPSBhcmdzLmNvbmNhdChbY2FsbGJhY2tdKTtcbiAgICAgICAgICB0aGlzLmFkZFF1ZXVlKGksIF9hcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsYXN0QXJnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gY29sbGVjdGlvbk9wZXJhdGlvbkNhbGxiYWNrKCkge1xuICAgICAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGxhc3RBcmcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgICAgX2FyZ3MgPSBhcmdzLnNsaWNlKDAsIGFyZ3MubGVuZ3RoIC0gMSkuY29uY2F0KFtjYWxsYmFja10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uIGNvbGxlY3Rpb25PcGVyYXRpb25DYWxsYmFjayhlcnIsIHJlcykge1xuICAgICAgICAgICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXMpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgX2FyZ3MgPSBhcmdzLmNvbmNhdChbY2FsbGJhY2tdKTtcbiAgICAgICAgICB0aGlzLmFkZFF1ZXVlKGksIF9hcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJ1ZmZlclRpbWVvdXRNUyA9IHRoaXMuX2dldEJ1ZmZlclRpbWVvdXRNUygpO1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCByZW1vdmVkID0gdGhpcy5yZW1vdmVRdWV1ZShpLCBfYXJncyk7XG4gICAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdPcGVyYXRpb24gYCcgKyB0aGlzLm5hbWUgKyAnLicgKyBpICsgJygpYCBidWZmZXJpbmcgdGltZWQgb3V0IGFmdGVyICcgK1xuICAgICAgICAgICAgYnVmZmVyVGltZW91dE1TICsgJ21zJztcbiAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgTW9uZ29vc2VFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICB0aGlzLmNvbm4uZW1pdCgnYnVmZmVyLWVuZCcsIHsgX2lkOiBvcElkLCBtb2RlbE5hbWU6IF90aGlzLm1vZGVsTmFtZSwgY29sbGVjdGlvbk5hbWU6IF90aGlzLm5hbWUsIG1ldGhvZDogaSwgZXJyb3I6IGVyciB9KTtcbiAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICB9LCBidWZmZXJUaW1lb3V0TVMpO1xuXG4gICAgICBpZiAoIXN5bmNDb2xsZWN0aW9uTWV0aG9kc1tpXSAmJiB0eXBlb2YgbGFzdEFyZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLmFkZFF1ZXVlKGksIF9hcmdzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9IGVsc2UgaWYgKCFzeW5jQ29sbGVjdGlvbk1ldGhvZHNbaV0gJiYgdHlwZW9mIGxhc3RBcmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gY29sbGVjdGlvbk9wZXJhdGlvbkNhbGxiYWNrKGVyciwgcmVzKSB7XG4gICAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICAgIF90aGlzLmNvbm4uZW1pdCgnb3BlcmF0aW9uLWVuZCcsIHsgX2lkOiBvcElkLCBtb2RlbE5hbWU6IF90aGlzLm1vZGVsTmFtZSwgY29sbGVjdGlvbk5hbWU6IF90aGlzLm5hbWUsIG1ldGhvZDogaSwgZXJyb3I6IGVyciB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpcy5jb25uLmVtaXQoJ29wZXJhdGlvbi1lbmQnLCB7IF9pZDogb3BJZCwgbW9kZWxOYW1lOiBfdGhpcy5tb2RlbE5hbWUsIGNvbGxlY3Rpb25OYW1lOiBfdGhpcy5uYW1lLCBtZXRob2Q6IGksIHJlc3VsdDogcmVzIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYXN0QXJnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgX2FyZ3MgPSBhcmdzLnNsaWNlKDAsIGFyZ3MubGVuZ3RoIC0gMSkuY29uY2F0KFtjYWxsYmFja10pO1xuICAgIH1cblxuICAgIGlmIChkZWJ1Zykge1xuICAgICAgaWYgKHR5cGVvZiBkZWJ1ZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBsZXQgYXJnc1RvQWRkID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGFyZ3NUb0FkZCA9IGFyZ3Muc2xpY2UoMCwgYXJncy5sZW5ndGggLSAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcmdzVG9BZGQgPSBhcmdzO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnLmFwcGx5KF90aGlzLFxuICAgICAgICAgIFtfdGhpcy5uYW1lLCBpXS5jb25jYXQoYXJnc1RvQWRkKSk7XG4gICAgICB9IGVsc2UgaWYgKGRlYnVnIGluc3RhbmNlb2Ygc3RyZWFtLldyaXRhYmxlKSB7XG4gICAgICAgIHRoaXMuJHByaW50VG9TdHJlYW0oX3RoaXMubmFtZSwgaSwgYXJncywgZGVidWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29sb3IgPSBkZWJ1Zy5jb2xvciA9PSBudWxsID8gdHJ1ZSA6IGRlYnVnLmNvbG9yO1xuICAgICAgICBjb25zdCBzaGVsbCA9IGRlYnVnLnNoZWxsID09IG51bGwgPyBmYWxzZSA6IGRlYnVnLnNoZWxsO1xuICAgICAgICB0aGlzLiRwcmludChfdGhpcy5uYW1lLCBpLCBhcmdzLCBjb2xvciwgc2hlbGwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY29ubi5lbWl0KCdvcGVyYXRpb24tc3RhcnQnLCB7IF9pZDogb3BJZCwgbW9kZWxOYW1lOiBfdGhpcy5tb2RlbE5hbWUsIGNvbGxlY3Rpb25OYW1lOiB0aGlzLm5hbWUsIG1ldGhvZDogaSwgcGFyYW1zOiBfYXJncyB9KTtcblxuICAgIHRyeSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnQ2Fubm90IGNhbGwgYCcgKyB0aGlzLm5hbWUgKyAnLicgKyBpICsgJygpYCBiZWZvcmUgaW5pdGlhbCBjb25uZWN0aW9uICcgK1xuICAgICAgICAgICdpcyBjb21wbGV0ZSBpZiBgYnVmZmVyQ29tbWFuZHMgPSBmYWxzZWAuIE1ha2Ugc3VyZSB5b3UgYGF3YWl0IG1vbmdvb3NlLmNvbm5lY3QoKWAgaWYgJyArXG4gICAgICAgICAgJ3lvdSBoYXZlIGBidWZmZXJDb21tYW5kcyA9IGZhbHNlYC4nO1xuICAgICAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN5bmNDb2xsZWN0aW9uTWV0aG9kc1tpXSAmJiB0eXBlb2YgbGFzdEFyZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCByZXQgPSBjb2xsZWN0aW9uW2ldLmFwcGx5KGNvbGxlY3Rpb24sIF9hcmdzLnNsaWNlKDAsIF9hcmdzLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgcmV0dXJuIGxhc3RBcmcuY2FsbCh0aGlzLCBudWxsLCByZXQpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXQgPSBjb2xsZWN0aW9uW2ldLmFwcGx5KGNvbGxlY3Rpb24sIF9hcmdzKTtcbiAgICAgIGlmIChyZXQgIT0gbnVsbCAmJiB0eXBlb2YgcmV0LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHJldC50aGVuKFxuICAgICAgICAgIHJlcyA9PiB7XG4gICAgICAgICAgICB0eXBlb2YgbGFzdEFyZyA9PT0gJ2Z1bmN0aW9uJyAmJiBsYXN0QXJnKG51bGwsIHJlcyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZXJyID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGFzdEFyZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBsYXN0QXJnKGVycik7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBDb2xsZWN0aW9uIG9wZXJhdGlvbiBtYXkgdGhyb3cgYmVjYXVzZSBvZiBtYXggYnNvbiBzaXplLCBjYXRjaCBpdCBoZXJlXG4gICAgICAvLyBTZWUgZ2gtMzkwNlxuICAgICAgaWYgKHR5cGVvZiBsYXN0QXJnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBsYXN0QXJnKGVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29ubi5lbWl0KCdvcGVyYXRpb24tZW5kJywgeyBfaWQ6IG9wSWQsIG1vZGVsTmFtZTogX3RoaXMubW9kZWxOYW1lLCBjb2xsZWN0aW9uTmFtZTogdGhpcy5uYW1lLCBtZXRob2Q6IGksIGVycm9yOiBlcnJvciB9KTtcblxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKENvbGxlY3Rpb24ucHJvdG90eXBlKSkge1xuICAvLyBKYW5reSBoYWNrIHRvIHdvcmsgYXJvdW5kIGdoLTMwMDUgdW50aWwgd2UgY2FuIGdldCByaWQgb2YgdGhlIG1vbmdvb3NlXG4gIC8vIGNvbGxlY3Rpb24gYWJzdHJhY3Rpb25cbiAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoQ29sbGVjdGlvbi5wcm90b3R5cGUsIGtleSk7XG4gIC8vIFNraXAgcHJvcGVydGllcyB3aXRoIGdldHRlcnMgYmVjYXVzZSB0aGV5IG1heSB0aHJvdyBlcnJvcnMgKGdoLTg1MjgpXG4gIGlmIChkZXNjcmlwdG9yLmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29udGludWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBDb2xsZWN0aW9uLnByb3RvdHlwZVtrZXldICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgY29udGludWU7XG4gIH1cblxuICBpdGVyKGtleSk7XG59XG5cbi8qKlxuICogRGVidWcgcHJpbnQgaGVscGVyXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgJHByaW50XG4gKi9cblxuTmF0aXZlQ29sbGVjdGlvbi5wcm90b3R5cGUuJHByaW50ID0gZnVuY3Rpb24obmFtZSwgaSwgYXJncywgY29sb3IsIHNoZWxsKSB7XG4gIGNvbnN0IG1vZHVsZU5hbWUgPSBjb2xvciA/ICdcXHgxQlswOzM2bU1vbmdvb3NlOlxceDFCWzBtICcgOiAnTW9uZ29vc2U6ICc7XG4gIGNvbnN0IGZ1bmN0aW9uQ2FsbCA9IFtuYW1lLCBpXS5qb2luKCcuJyk7XG4gIGNvbnN0IF9hcmdzID0gW107XG4gIGZvciAobGV0IGogPSBhcmdzLmxlbmd0aCAtIDE7IGogPj0gMDsgLS1qKSB7XG4gICAgaWYgKHRoaXMuJGZvcm1hdChhcmdzW2pdKSB8fCBfYXJncy5sZW5ndGgpIHtcbiAgICAgIF9hcmdzLnVuc2hpZnQodGhpcy4kZm9ybWF0KGFyZ3Nbal0sIGNvbG9yLCBzaGVsbCkpO1xuICAgIH1cbiAgfVxuICBjb25zdCBwYXJhbXMgPSAnKCcgKyBfYXJncy5qb2luKCcsICcpICsgJyknO1xuXG4gIGNvbnNvbGUuaW5mbyhtb2R1bGVOYW1lICsgZnVuY3Rpb25DYWxsICsgcGFyYW1zKTtcbn07XG5cbi8qKlxuICogRGVidWcgcHJpbnQgaGVscGVyXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgJHByaW50XG4gKi9cblxuTmF0aXZlQ29sbGVjdGlvbi5wcm90b3R5cGUuJHByaW50VG9TdHJlYW0gPSBmdW5jdGlvbihuYW1lLCBpLCBhcmdzLCBzdHJlYW0pIHtcbiAgY29uc3QgZnVuY3Rpb25DYWxsID0gW25hbWUsIGldLmpvaW4oJy4nKTtcbiAgY29uc3QgX2FyZ3MgPSBbXTtcbiAgZm9yIChsZXQgaiA9IGFyZ3MubGVuZ3RoIC0gMTsgaiA+PSAwOyAtLWopIHtcbiAgICBpZiAodGhpcy4kZm9ybWF0KGFyZ3Nbal0pIHx8IF9hcmdzLmxlbmd0aCkge1xuICAgICAgX2FyZ3MudW5zaGlmdCh0aGlzLiRmb3JtYXQoYXJnc1tqXSkpO1xuICAgIH1cbiAgfVxuICBjb25zdCBwYXJhbXMgPSAnKCcgKyBfYXJncy5qb2luKCcsICcpICsgJyknO1xuXG4gIHN0cmVhbS53cml0ZShmdW5jdGlvbkNhbGwgKyBwYXJhbXMsICd1dGY4Jyk7XG59O1xuXG4vKipcbiAqIEZvcm1hdHRlciBmb3IgZGVidWcgcHJpbnQgYXJnc1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kICRmb3JtYXRcbiAqL1xuXG5OYXRpdmVDb2xsZWN0aW9uLnByb3RvdHlwZS4kZm9ybWF0ID0gZnVuY3Rpb24oYXJnLCBjb2xvciwgc2hlbGwpIHtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiBhcmc7XG4gIGlmICh0eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGUgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gJyc7XG4gIHJldHVybiBmb3JtYXQoYXJnLCBmYWxzZSwgY29sb3IsIHNoZWxsKTtcbn07XG5cbi8qKlxuICogRGVidWcgcHJpbnQgaGVscGVyXG4gKiBAcGFyYW0ge0FueX0gcmVwcmVzZW50YXRpb25cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGluc3BlY3RhYmxlKHJlcHJlc2VudGF0aW9uKSB7XG4gIGNvbnN0IHJldCA9IHtcbiAgICBpbnNwZWN0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHJlcHJlc2VudGF0aW9uOyB9XG4gIH07XG4gIGlmICh1dGlsLmluc3BlY3QuY3VzdG9tKSB7XG4gICAgcmV0W3V0aWwuaW5zcGVjdC5jdXN0b21dID0gcmV0Lmluc3BlY3Q7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIG1hcChvKSB7XG4gIHJldHVybiBmb3JtYXQobywgdHJ1ZSk7XG59XG5mdW5jdGlvbiBmb3JtYXRPYmplY3RJZCh4LCBrZXkpIHtcbiAgeFtrZXldID0gaW5zcGVjdGFibGUoJ09iamVjdElkKFwiJyArIHhba2V5XS50b0hleFN0cmluZygpICsgJ1wiKScpO1xufVxuZnVuY3Rpb24gZm9ybWF0RGF0ZSh4LCBrZXksIHNoZWxsKSB7XG4gIGlmIChzaGVsbCkge1xuICAgIHhba2V5XSA9IGluc3BlY3RhYmxlKCdJU09EYXRlKFwiJyArIHhba2V5XS50b1VUQ1N0cmluZygpICsgJ1wiKScpO1xuICB9IGVsc2Uge1xuICAgIHhba2V5XSA9IGluc3BlY3RhYmxlKCduZXcgRGF0ZShcIicgKyB4W2tleV0udG9VVENTdHJpbmcoKSArICdcIiknKTtcbiAgfVxufVxuZnVuY3Rpb24gZm9ybWF0KG9iaiwgc3ViLCBjb2xvciwgc2hlbGwpIHtcbiAgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqLnRvQlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9iaiA9IG9iai50b0JTT04oKTtcbiAgfVxuICBpZiAob2JqID09IG51bGwpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXJzL2Nsb25lJyk7XG4gIGxldCB4ID0gY2xvbmUob2JqLCBpbnRlcm5hbFRvT2JqZWN0T3B0aW9ucyk7XG4gIGNvbnN0IGNvbnN0cnVjdG9yTmFtZSA9IGdldENvbnN0cnVjdG9yTmFtZSh4KTtcblxuICBpZiAoY29uc3RydWN0b3JOYW1lID09PSAnQmluYXJ5Jykge1xuICAgIHggPSAnQmluRGF0YSgnICsgeC5zdWJfdHlwZSArICcsIFwiJyArIHgudG9TdHJpbmcoJ2Jhc2U2NCcpICsgJ1wiKSc7XG4gIH0gZWxzZSBpZiAoY29uc3RydWN0b3JOYW1lID09PSAnT2JqZWN0SWQnKSB7XG4gICAgeCA9IGluc3BlY3RhYmxlKCdPYmplY3RJZChcIicgKyB4LnRvSGV4U3RyaW5nKCkgKyAnXCIpJyk7XG4gIH0gZWxzZSBpZiAoY29uc3RydWN0b3JOYW1lID09PSAnRGF0ZScpIHtcbiAgICB4ID0gaW5zcGVjdGFibGUoJ25ldyBEYXRlKFwiJyArIHgudG9VVENTdHJpbmcoKSArICdcIiknKTtcbiAgfSBlbHNlIGlmIChjb25zdHJ1Y3Rvck5hbWUgPT09ICdPYmplY3QnKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHgpO1xuICAgIGNvbnN0IG51bUtleXMgPSBrZXlzLmxlbmd0aDtcbiAgICBsZXQga2V5O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtS2V5czsgKytpKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKHhba2V5XSkge1xuICAgICAgICBsZXQgZXJyb3I7XG4gICAgICAgIGlmICh0eXBlb2YgeFtrZXldLnRvQlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBgc2Vzc2lvbi50b0JTT04oKWAgdGhyb3dzIGFuIGVycm9yLiBUaGlzIG1lYW5zIHdlIHRocm93IGVycm9yc1xuICAgICAgICAgICAgLy8gaW4gZGVidWcgbW9kZSB3aGVuIHVzaW5nIHRyYW5zYWN0aW9ucywgc2VlIGdoLTY3MTIuIEFzIGFcbiAgICAgICAgICAgIC8vIHdvcmthcm91bmQsIGNhdGNoIGB0b0JTT04oKWAgZXJyb3JzLCB0cnkgdG8gc2VyaWFsaXplIHdpdGhvdXRcbiAgICAgICAgICAgIC8vIGB0b0JTT04oKWAsIGFuZCByZXRocm93IGlmIHNlcmlhbGl6YXRpb24gc3RpbGwgZmFpbHMuXG4gICAgICAgICAgICB4W2tleV0gPSB4W2tleV0udG9CU09OKCk7XG4gICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICBlcnJvciA9IF9lcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgX2NvbnN0cnVjdG9yTmFtZSA9IGdldENvbnN0cnVjdG9yTmFtZSh4W2tleV0pO1xuICAgICAgICBpZiAoX2NvbnN0cnVjdG9yTmFtZSA9PT0gJ0JpbmFyeScpIHtcbiAgICAgICAgICB4W2tleV0gPSAnQmluRGF0YSgnICsgeFtrZXldLnN1Yl90eXBlICsgJywgXCInICtcbiAgICAgICAgICAgIHhba2V5XS5idWZmZXIudG9TdHJpbmcoJ2Jhc2U2NCcpICsgJ1wiKSc7XG4gICAgICAgIH0gZWxzZSBpZiAoX2NvbnN0cnVjdG9yTmFtZSA9PT0gJ09iamVjdCcpIHtcbiAgICAgICAgICB4W2tleV0gPSBmb3JtYXQoeFtrZXldLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChfY29uc3RydWN0b3JOYW1lID09PSAnT2JqZWN0SWQnKSB7XG4gICAgICAgICAgZm9ybWF0T2JqZWN0SWQoeCwga2V5KTtcbiAgICAgICAgfSBlbHNlIGlmIChfY29uc3RydWN0b3JOYW1lID09PSAnRGF0ZScpIHtcbiAgICAgICAgICBmb3JtYXREYXRlKHgsIGtleSwgc2hlbGwpO1xuICAgICAgICB9IGVsc2UgaWYgKF9jb25zdHJ1Y3Rvck5hbWUgPT09ICdDbGllbnRTZXNzaW9uJykge1xuICAgICAgICAgIHhba2V5XSA9IGluc3BlY3RhYmxlKCdDbGllbnRTZXNzaW9uKFwiJyArXG4gICAgICAgICAgICAoXG4gICAgICAgICAgICAgIHhba2V5XSAmJlxuICAgICAgICAgICAgICB4W2tleV0uaWQgJiZcbiAgICAgICAgICAgICAgeFtrZXldLmlkLmlkICYmXG4gICAgICAgICAgICAgIHhba2V5XS5pZC5pZC5idWZmZXIgfHwgJydcbiAgICAgICAgICAgICkudG9TdHJpbmcoJ2hleCcpICsgJ1wiKScpO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoeFtrZXldKSkge1xuICAgICAgICAgIHhba2V5XSA9IHhba2V5XS5tYXAobWFwKTtcbiAgICAgICAgfSBlbHNlIGlmIChlcnJvciAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGFuIGVycm9yIHdpdGggYHRvQlNPTigpYCBhbmQgdGhlIG9iamVjdCB3YXNuJ3RcbiAgICAgICAgICAvLyBhbHJlYWR5IGNvbnZlcnRlZCB0byBhIHN0cmluZyByZXByZXNlbnRhdGlvbiwgcmV0aHJvdyBpdC5cbiAgICAgICAgICAvLyBPcGVuIHRvIGJldHRlciBpZGVhcyBvbiBob3cgdG8gaGFuZGxlIHRoaXMuXG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHN1Yikge1xuICAgIHJldHVybiB4O1xuICB9XG5cbiAgcmV0dXJuIHV0aWwuXG4gICAgaW5zcGVjdCh4LCBmYWxzZSwgMTAsIGNvbG9yKS5cbiAgICByZXBsYWNlKC9cXG4vZywgJycpLlxuICAgIHJlcGxhY2UoL1xcc3syLH0vZywgJyAnKTtcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBjb2xsZWN0aW9ucyBpbmRleGVzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAbWV0aG9kIGdldEluZGV4ZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTmF0aXZlQ29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0SW5kZXhlcyA9IE5hdGl2ZUNvbGxlY3Rpb24ucHJvdG90eXBlLmluZGV4SW5mb3JtYXRpb247XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBOYXRpdmVDb2xsZWN0aW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/drivers/node-mongodb-native/collection.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/drivers/node-mongodb-native/connection.js":
/*!**************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/drivers/node-mongodb-native/connection.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseConnection = __webpack_require__(/*! ../../connection */ \"../backend/node_modules/mongoose/lib/connection.js\");\nconst MongooseError = __webpack_require__(/*! ../../error/index */ \"../backend/node_modules/mongoose/lib/error/index.js\");\nconst STATES = __webpack_require__(/*! ../../connectionState */ \"../backend/node_modules/mongoose/lib/connectionState.js\");\nconst mongodb = __webpack_require__(/*! mongodb */ \"../backend/node_modules/mongodb/lib/index.js\");\nconst pkg = __webpack_require__(/*! ../../../package.json */ \"../backend/node_modules/mongoose/package.json\");\nconst processConnectionOptions = __webpack_require__(/*! ../../helpers/processConnectionOptions */ \"../backend/node_modules/mongoose/lib/helpers/processConnectionOptions.js\");\nconst setTimeout = (__webpack_require__(/*! ../../helpers/timers */ \"../backend/node_modules/mongoose/lib/helpers/timers.js\").setTimeout);\nconst utils = __webpack_require__(/*! ../../utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\n\n/**\n * A [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) connection implementation.\n *\n * @inherits Connection\n * @api private\n */\n\nfunction NativeConnection() {\n  MongooseConnection.apply(this, arguments);\n  this._listening = false;\n}\n\n/**\n * Expose the possible connection states.\n * @api public\n */\n\nNativeConnection.STATES = STATES;\n\n/*!\n * Inherits from Connection.\n */\n\nObject.setPrototypeOf(NativeConnection.prototype, MongooseConnection.prototype);\n\n/**\n * Switches to a different database using the same connection pool.\n *\n * Returns a new connection object, with the new db. If you set the `useCache`\n * option, `useDb()` will cache connections by `name`.\n *\n * **Note:** Calling `close()` on a `useDb()` connection will close the base connection as well.\n *\n * @param {String} name The database name\n * @param {Object} [options]\n * @param {Boolean} [options.useCache=false] If true, cache results so calling `useDb()` multiple times with the same name only creates 1 connection object.\n * @param {Boolean} [options.noListener=false] If true, the new connection object won't listen to any events on the base connection. This is better for memory usage in cases where you're calling `useDb()` for every request.\n * @return {Connection} New Connection Object\n * @api public\n */\n\nNativeConnection.prototype.useDb = function(name, options) {\n  // Return immediately if cached\n  options = options || {};\n  if (options.useCache && this.relatedDbs[name]) {\n    return this.relatedDbs[name];\n  }\n\n  // we have to manually copy all of the attributes...\n  const newConn = new this.constructor();\n  newConn.name = name;\n  newConn.base = this.base;\n  newConn.collections = {};\n  newConn.models = {};\n  newConn.replica = this.replica;\n  newConn.config = Object.assign({}, this.config, newConn.config);\n  newConn.name = this.name;\n  newConn.options = this.options;\n  newConn._readyState = this._readyState;\n  newConn._closeCalled = this._closeCalled;\n  newConn._hasOpened = this._hasOpened;\n  newConn._listening = false;\n  newConn._parent = this;\n\n  newConn.host = this.host;\n  newConn.port = this.port;\n  newConn.user = this.user;\n  newConn.pass = this.pass;\n\n  // First, when we create another db object, we are not guaranteed to have a\n  // db object to work with. So, in the case where we have a db object and it\n  // is connected, we can just proceed with setting everything up. However, if\n  // we do not have a db or the state is not connected, then we need to wait on\n  // the 'open' event of the connection before doing the rest of the setup\n  // the 'connected' event is the first time we'll have access to the db object\n\n  const _this = this;\n\n  newConn.client = _this.client;\n\n  if (this.db && this._readyState === STATES.connected) {\n    wireup();\n  } else {\n    this.once('connected', wireup);\n  }\n\n  function wireup() {\n    newConn.client = _this.client;\n    const _opts = {};\n    if (options.hasOwnProperty('noListener')) {\n      _opts.noListener = options.noListener;\n    }\n    newConn.db = _this.client.db(name, _opts);\n    newConn.onOpen();\n  }\n\n  newConn.name = name;\n\n  // push onto the otherDbs stack, this is used when state changes\n  if (options.noListener !== true) {\n    this.otherDbs.push(newConn);\n  }\n  newConn.otherDbs.push(this);\n\n  // push onto the relatedDbs cache, this is used when state changes\n  if (options && options.useCache) {\n    this.relatedDbs[newConn.name] = newConn;\n    newConn.relatedDbs = this.relatedDbs;\n  }\n\n  return newConn;\n};\n\n/**\n * Removes the database connection with the given name created with `useDb()`.\n *\n * Throws an error if the database connection was not found.\n *\n * #### Example:\n *\n *     // Connect to `initialdb` first\n *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/initialdb').asPromise();\n *\n *     // Creates an un-cached connection to `mydb`\n *     const db = conn.useDb('mydb');\n *\n *     // Closes `db`, and removes `db` from `conn.relatedDbs` and `conn.otherDbs`\n *     await conn.removeDb('mydb');\n *\n * @method removeDb\n * @memberOf Connection\n * @param {String} name The database name\n * @return {Connection} this\n */\n\nNativeConnection.prototype.removeDb = function removeDb(name) {\n  const dbs = this.otherDbs.filter(db => db.name === name);\n  if (!dbs.length) {\n    throw new MongooseError(`No connections to database \"${name}\" found`);\n  }\n\n  for (const db of dbs) {\n    db._closeCalled = true;\n    db._destroyCalled = true;\n    db._readyState = STATES.disconnected;\n    db.$wasForceClosed = true;\n  }\n  delete this.relatedDbs[name];\n  this.otherDbs = this.otherDbs.filter(db => db.name !== name);\n};\n\n/**\n * Closes the connection\n *\n * @param {Boolean} [force]\n * @return {Connection} this\n * @api private\n */\n\nNativeConnection.prototype.doClose = async function doClose(force) {\n  if (this.client == null) {\n    return this;\n  }\n\n  let skipCloseClient = false;\n  if (force != null && typeof force === 'object') {\n    skipCloseClient = force.skipCloseClient;\n    force = force.force;\n  }\n\n  if (skipCloseClient) {\n    return this;\n  }\n\n  await this.client.close(force);\n  // Defer because the driver will wait at least 1ms before finishing closing\n  // the pool, see https://github.com/mongodb-js/mongodb-core/blob/a8f8e4ce41936babc3b9112bf42d609779f03b39/lib/connection/pool.js#L1026-L1030.\n  // If there's queued operations, you may still get some background work\n  // after the callback is called.\n  await new Promise(resolve => setTimeout(resolve, 1));\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nNativeConnection.prototype.createClient = async function createClient(uri, options) {\n  if (typeof uri !== 'string') {\n    throw new MongooseError('The `uri` parameter to `openUri()` must be a ' +\n      `string, got \"${typeof uri}\". Make sure the first parameter to ` +\n      '`mongoose.connect()` or `mongoose.createConnection()` is a string.');\n  }\n\n  if (this._destroyCalled) {\n    throw new MongooseError(\n      'Connection has been closed and destroyed, and cannot be used for re-opening the connection. ' +\n      'Please create a new connection with `mongoose.createConnection()` or `mongoose.connect()`.'\n    );\n  }\n\n  if (this.readyState === STATES.connecting || this.readyState === STATES.connected) {\n    if (this._connectionString !== uri) {\n      throw new MongooseError('Can\\'t call `openUri()` on an active connection with ' +\n        'different connection strings. Make sure you aren\\'t calling `mongoose.connect()` ' +\n        'multiple times. See: https://mongoosejs.com/docs/connections.html#multiple_connections');\n    }\n  }\n\n  options = processConnectionOptions(uri, options);\n\n  if (options) {\n\n    const autoIndex = options.config && options.config.autoIndex != null ?\n      options.config.autoIndex :\n      options.autoIndex;\n    if (autoIndex != null) {\n      this.config.autoIndex = autoIndex !== false;\n      delete options.config;\n      delete options.autoIndex;\n    }\n\n    if ('autoCreate' in options) {\n      this.config.autoCreate = !!options.autoCreate;\n      delete options.autoCreate;\n    }\n\n    if ('sanitizeFilter' in options) {\n      this.config.sanitizeFilter = options.sanitizeFilter;\n      delete options.sanitizeFilter;\n    }\n\n    if ('autoSearchIndex' in options) {\n      this.config.autoSearchIndex = options.autoSearchIndex;\n      delete options.autoSearchIndex;\n    }\n\n    // Backwards compat\n    if (options.user || options.pass) {\n      options.auth = options.auth || {};\n      options.auth.username = options.user;\n      options.auth.password = options.pass;\n\n      this.user = options.user;\n      this.pass = options.pass;\n    }\n    delete options.user;\n    delete options.pass;\n\n    if (options.bufferCommands != null) {\n      this.config.bufferCommands = options.bufferCommands;\n      delete options.bufferCommands;\n    }\n  } else {\n    options = {};\n  }\n\n  this._connectionOptions = options;\n  const dbName = options.dbName;\n  if (dbName != null) {\n    this.$dbName = dbName;\n  }\n  delete options.dbName;\n\n  if (!utils.hasUserDefinedProperty(options, 'driverInfo')) {\n    options.driverInfo = {\n      name: 'Mongoose',\n      version: pkg.version\n    };\n  }\n\n  this.readyState = STATES.connecting;\n  this._connectionString = uri;\n\n  let client;\n  try {\n    client = new mongodb.MongoClient(uri, options);\n  } catch (error) {\n    this.readyState = STATES.disconnected;\n    throw error;\n  }\n  this.client = client;\n\n  client.setMaxListeners(0);\n  await client.connect();\n\n  _setClient(this, client, options, dbName);\n\n  for (const db of this.otherDbs) {\n    _setClient(db, client, {}, db.name);\n  }\n  return this;\n};\n\n/*!\n * ignore\n */\n\nNativeConnection.prototype.setClient = function setClient(client) {\n  if (!(client instanceof mongodb.MongoClient)) {\n    throw new MongooseError('Must call `setClient()` with an instance of MongoClient');\n  }\n  if (this.readyState !== STATES.disconnected) {\n    throw new MongooseError('Cannot call `setClient()` on a connection that is already connected.');\n  }\n  if (client.topology == null) {\n    throw new MongooseError('Cannot call `setClient()` with a MongoClient that you have not called `connect()` on yet.');\n  }\n\n  this._connectionString = client.s.url;\n  _setClient(this, client, {}, client.s.options.dbName);\n\n  for (const model of Object.values(this.models)) {\n    // Errors handled internally, so safe to ignore error\n    model.init().catch(function $modelInitNoop() {});\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _setClient(conn, client, options, dbName) {\n  const db = dbName != null ? client.db(dbName) : client.db();\n  conn.db = db;\n  conn.client = client;\n  conn.host = client &&\n    client.s &&\n    client.s.options &&\n    client.s.options.hosts &&\n    client.s.options.hosts[0] &&\n    client.s.options.hosts[0].host || void 0;\n  conn.port = client &&\n    client.s &&\n    client.s.options &&\n    client.s.options.hosts &&\n    client.s.options.hosts[0] &&\n    client.s.options.hosts[0].port || void 0;\n  conn.name = dbName != null ? dbName : db.databaseName;\n  conn._closeCalled = client._closeCalled;\n\n  const _handleReconnect = () => {\n    // If we aren't disconnected, we assume this reconnect is due to a\n    // socket timeout. If there's no activity on a socket for\n    // `socketTimeoutMS`, the driver will attempt to reconnect and emit\n    // this event.\n    if (conn.readyState !== STATES.connected) {\n      conn.readyState = STATES.connected;\n      conn.emit('reconnect');\n      conn.emit('reconnected');\n      conn.onOpen();\n    }\n  };\n\n  const type = client &&\n  client.topology &&\n  client.topology.description &&\n  client.topology.description.type || '';\n\n  if (type === 'Single') {\n    client.on('serverDescriptionChanged', ev => {\n      const newDescription = ev.newDescription;\n      if (newDescription.type === 'Unknown') {\n        conn.readyState = STATES.disconnected;\n      } else {\n        _handleReconnect();\n      }\n    });\n  } else if (type.startsWith('ReplicaSet')) {\n    client.on('topologyDescriptionChanged', ev => {\n      // Emit disconnected if we've lost connectivity to the primary\n      const description = ev.newDescription;\n      if (conn.readyState === STATES.connected && description.type !== 'ReplicaSetWithPrimary') {\n        // Implicitly emits 'disconnected'\n        conn.readyState = STATES.disconnected;\n      } else if (conn.readyState === STATES.disconnected && description.type === 'ReplicaSetWithPrimary') {\n        _handleReconnect();\n      }\n    });\n  }\n\n  conn.onOpen();\n\n  for (const i in conn.collections) {\n    if (utils.object.hasOwnProperty(conn.collections, i)) {\n      conn.collections[i].onOpen();\n    }\n  }\n}\n\n\n/*!\n * Module exports.\n */\n\nmodule.exports = NativeConnection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2RyaXZlcnMvbm9kZS1tb25nb2RiLW5hdGl2ZS9jb25uZWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYiwyQkFBMkIsbUJBQU8sQ0FBQyw0RUFBa0I7QUFDckQsc0JBQXNCLG1CQUFPLENBQUMsOEVBQW1CO0FBQ2pELGVBQWUsbUJBQU8sQ0FBQyxzRkFBdUI7QUFDOUMsZ0JBQWdCLG1CQUFPLENBQUMsNkRBQVM7QUFDakMsWUFBWSxtQkFBTyxDQUFDLDRFQUF1QjtBQUMzQyxpQ0FBaUMsbUJBQU8sQ0FBQyx3SEFBd0M7QUFDakYsbUJBQW1CLHNIQUEwQztBQUM3RCxjQUFjLG1CQUFPLENBQUMsa0VBQWE7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixZQUFZLFlBQVk7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksWUFBWTtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsS0FBSztBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVksWUFBWTtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9kcml2ZXJzL25vZGUtbW9uZ29kYi1uYXRpdmUvY29ubmVjdGlvbi5qcz8zYmYwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1vbmdvb3NlQ29ubmVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL2Nvbm5lY3Rpb24nKTtcbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9lcnJvci9pbmRleCcpO1xuY29uc3QgU1RBVEVTID0gcmVxdWlyZSgnLi4vLi4vY29ubmVjdGlvblN0YXRlJyk7XG5jb25zdCBtb25nb2RiID0gcmVxdWlyZSgnbW9uZ29kYicpO1xuY29uc3QgcGtnID0gcmVxdWlyZSgnLi4vLi4vLi4vcGFja2FnZS5qc29uJyk7XG5jb25zdCBwcm9jZXNzQ29ubmVjdGlvbk9wdGlvbnMgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXJzL3Byb2Nlc3NDb25uZWN0aW9uT3B0aW9ucycpO1xuY29uc3Qgc2V0VGltZW91dCA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvdGltZXJzJykuc2V0VGltZW91dDtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBBIFtub2RlLW1vbmdvZGItbmF0aXZlXShodHRwczovL2dpdGh1Yi5jb20vbW9uZ29kYi9ub2RlLW1vbmdvZGItbmF0aXZlKSBjb25uZWN0aW9uIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBpbmhlcml0cyBDb25uZWN0aW9uXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBOYXRpdmVDb25uZWN0aW9uKCkge1xuICBNb25nb29zZUNvbm5lY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgdGhpcy5fbGlzdGVuaW5nID0gZmFsc2U7XG59XG5cbi8qKlxuICogRXhwb3NlIHRoZSBwb3NzaWJsZSBjb25uZWN0aW9uIHN0YXRlcy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTmF0aXZlQ29ubmVjdGlvbi5TVEFURVMgPSBTVEFURVM7XG5cbi8qIVxuICogSW5oZXJpdHMgZnJvbSBDb25uZWN0aW9uLlxuICovXG5cbk9iamVjdC5zZXRQcm90b3R5cGVPZihOYXRpdmVDb25uZWN0aW9uLnByb3RvdHlwZSwgTW9uZ29vc2VDb25uZWN0aW9uLnByb3RvdHlwZSk7XG5cbi8qKlxuICogU3dpdGNoZXMgdG8gYSBkaWZmZXJlbnQgZGF0YWJhc2UgdXNpbmcgdGhlIHNhbWUgY29ubmVjdGlvbiBwb29sLlxuICpcbiAqIFJldHVybnMgYSBuZXcgY29ubmVjdGlvbiBvYmplY3QsIHdpdGggdGhlIG5ldyBkYi4gSWYgeW91IHNldCB0aGUgYHVzZUNhY2hlYFxuICogb3B0aW9uLCBgdXNlRGIoKWAgd2lsbCBjYWNoZSBjb25uZWN0aW9ucyBieSBgbmFtZWAuXG4gKlxuICogKipOb3RlOioqIENhbGxpbmcgYGNsb3NlKClgIG9uIGEgYHVzZURiKClgIGNvbm5lY3Rpb24gd2lsbCBjbG9zZSB0aGUgYmFzZSBjb25uZWN0aW9uIGFzIHdlbGwuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGRhdGFiYXNlIG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXNlQ2FjaGU9ZmFsc2VdIElmIHRydWUsIGNhY2hlIHJlc3VsdHMgc28gY2FsbGluZyBgdXNlRGIoKWAgbXVsdGlwbGUgdGltZXMgd2l0aCB0aGUgc2FtZSBuYW1lIG9ubHkgY3JlYXRlcyAxIGNvbm5lY3Rpb24gb2JqZWN0LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ub0xpc3RlbmVyPWZhbHNlXSBJZiB0cnVlLCB0aGUgbmV3IGNvbm5lY3Rpb24gb2JqZWN0IHdvbid0IGxpc3RlbiB0byBhbnkgZXZlbnRzIG9uIHRoZSBiYXNlIGNvbm5lY3Rpb24uIFRoaXMgaXMgYmV0dGVyIGZvciBtZW1vcnkgdXNhZ2UgaW4gY2FzZXMgd2hlcmUgeW91J3JlIGNhbGxpbmcgYHVzZURiKClgIGZvciBldmVyeSByZXF1ZXN0LlxuICogQHJldHVybiB7Q29ubmVjdGlvbn0gTmV3IENvbm5lY3Rpb24gT2JqZWN0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk5hdGl2ZUNvbm5lY3Rpb24ucHJvdG90eXBlLnVzZURiID0gZnVuY3Rpb24obmFtZSwgb3B0aW9ucykge1xuICAvLyBSZXR1cm4gaW1tZWRpYXRlbHkgaWYgY2FjaGVkXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAob3B0aW9ucy51c2VDYWNoZSAmJiB0aGlzLnJlbGF0ZWREYnNbbmFtZV0pIHtcbiAgICByZXR1cm4gdGhpcy5yZWxhdGVkRGJzW25hbWVdO1xuICB9XG5cbiAgLy8gd2UgaGF2ZSB0byBtYW51YWxseSBjb3B5IGFsbCBvZiB0aGUgYXR0cmlidXRlcy4uLlxuICBjb25zdCBuZXdDb25uID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKTtcbiAgbmV3Q29ubi5uYW1lID0gbmFtZTtcbiAgbmV3Q29ubi5iYXNlID0gdGhpcy5iYXNlO1xuICBuZXdDb25uLmNvbGxlY3Rpb25zID0ge307XG4gIG5ld0Nvbm4ubW9kZWxzID0ge307XG4gIG5ld0Nvbm4ucmVwbGljYSA9IHRoaXMucmVwbGljYTtcbiAgbmV3Q29ubi5jb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbmZpZywgbmV3Q29ubi5jb25maWcpO1xuICBuZXdDb25uLm5hbWUgPSB0aGlzLm5hbWU7XG4gIG5ld0Nvbm4ub3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgbmV3Q29ubi5fcmVhZHlTdGF0ZSA9IHRoaXMuX3JlYWR5U3RhdGU7XG4gIG5ld0Nvbm4uX2Nsb3NlQ2FsbGVkID0gdGhpcy5fY2xvc2VDYWxsZWQ7XG4gIG5ld0Nvbm4uX2hhc09wZW5lZCA9IHRoaXMuX2hhc09wZW5lZDtcbiAgbmV3Q29ubi5fbGlzdGVuaW5nID0gZmFsc2U7XG4gIG5ld0Nvbm4uX3BhcmVudCA9IHRoaXM7XG5cbiAgbmV3Q29ubi5ob3N0ID0gdGhpcy5ob3N0O1xuICBuZXdDb25uLnBvcnQgPSB0aGlzLnBvcnQ7XG4gIG5ld0Nvbm4udXNlciA9IHRoaXMudXNlcjtcbiAgbmV3Q29ubi5wYXNzID0gdGhpcy5wYXNzO1xuXG4gIC8vIEZpcnN0LCB3aGVuIHdlIGNyZWF0ZSBhbm90aGVyIGRiIG9iamVjdCwgd2UgYXJlIG5vdCBndWFyYW50ZWVkIHRvIGhhdmUgYVxuICAvLyBkYiBvYmplY3QgdG8gd29yayB3aXRoLiBTbywgaW4gdGhlIGNhc2Ugd2hlcmUgd2UgaGF2ZSBhIGRiIG9iamVjdCBhbmQgaXRcbiAgLy8gaXMgY29ubmVjdGVkLCB3ZSBjYW4ganVzdCBwcm9jZWVkIHdpdGggc2V0dGluZyBldmVyeXRoaW5nIHVwLiBIb3dldmVyLCBpZlxuICAvLyB3ZSBkbyBub3QgaGF2ZSBhIGRiIG9yIHRoZSBzdGF0ZSBpcyBub3QgY29ubmVjdGVkLCB0aGVuIHdlIG5lZWQgdG8gd2FpdCBvblxuICAvLyB0aGUgJ29wZW4nIGV2ZW50IG9mIHRoZSBjb25uZWN0aW9uIGJlZm9yZSBkb2luZyB0aGUgcmVzdCBvZiB0aGUgc2V0dXBcbiAgLy8gdGhlICdjb25uZWN0ZWQnIGV2ZW50IGlzIHRoZSBmaXJzdCB0aW1lIHdlJ2xsIGhhdmUgYWNjZXNzIHRvIHRoZSBkYiBvYmplY3RcblxuICBjb25zdCBfdGhpcyA9IHRoaXM7XG5cbiAgbmV3Q29ubi5jbGllbnQgPSBfdGhpcy5jbGllbnQ7XG5cbiAgaWYgKHRoaXMuZGIgJiYgdGhpcy5fcmVhZHlTdGF0ZSA9PT0gU1RBVEVTLmNvbm5lY3RlZCkge1xuICAgIHdpcmV1cCgpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMub25jZSgnY29ubmVjdGVkJywgd2lyZXVwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdpcmV1cCgpIHtcbiAgICBuZXdDb25uLmNsaWVudCA9IF90aGlzLmNsaWVudDtcbiAgICBjb25zdCBfb3B0cyA9IHt9O1xuICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KCdub0xpc3RlbmVyJykpIHtcbiAgICAgIF9vcHRzLm5vTGlzdGVuZXIgPSBvcHRpb25zLm5vTGlzdGVuZXI7XG4gICAgfVxuICAgIG5ld0Nvbm4uZGIgPSBfdGhpcy5jbGllbnQuZGIobmFtZSwgX29wdHMpO1xuICAgIG5ld0Nvbm4ub25PcGVuKCk7XG4gIH1cblxuICBuZXdDb25uLm5hbWUgPSBuYW1lO1xuXG4gIC8vIHB1c2ggb250byB0aGUgb3RoZXJEYnMgc3RhY2ssIHRoaXMgaXMgdXNlZCB3aGVuIHN0YXRlIGNoYW5nZXNcbiAgaWYgKG9wdGlvbnMubm9MaXN0ZW5lciAhPT0gdHJ1ZSkge1xuICAgIHRoaXMub3RoZXJEYnMucHVzaChuZXdDb25uKTtcbiAgfVxuICBuZXdDb25uLm90aGVyRGJzLnB1c2godGhpcyk7XG5cbiAgLy8gcHVzaCBvbnRvIHRoZSByZWxhdGVkRGJzIGNhY2hlLCB0aGlzIGlzIHVzZWQgd2hlbiBzdGF0ZSBjaGFuZ2VzXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMudXNlQ2FjaGUpIHtcbiAgICB0aGlzLnJlbGF0ZWREYnNbbmV3Q29ubi5uYW1lXSA9IG5ld0Nvbm47XG4gICAgbmV3Q29ubi5yZWxhdGVkRGJzID0gdGhpcy5yZWxhdGVkRGJzO1xuICB9XG5cbiAgcmV0dXJuIG5ld0Nvbm47XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgdGhlIGRhdGFiYXNlIGNvbm5lY3Rpb24gd2l0aCB0aGUgZ2l2ZW4gbmFtZSBjcmVhdGVkIHdpdGggYHVzZURiKClgLlxuICpcbiAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgZGF0YWJhc2UgY29ubmVjdGlvbiB3YXMgbm90IGZvdW5kLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gQ29ubmVjdCB0byBgaW5pdGlhbGRiYCBmaXJzdFxuICogICAgIGNvbnN0IGNvbm4gPSBhd2FpdCBtb25nb29zZS5jcmVhdGVDb25uZWN0aW9uKCdtb25nb2RiOi8vMTI3LjAuMC4xOjI3MDE3L2luaXRpYWxkYicpLmFzUHJvbWlzZSgpO1xuICpcbiAqICAgICAvLyBDcmVhdGVzIGFuIHVuLWNhY2hlZCBjb25uZWN0aW9uIHRvIGBteWRiYFxuICogICAgIGNvbnN0IGRiID0gY29ubi51c2VEYignbXlkYicpO1xuICpcbiAqICAgICAvLyBDbG9zZXMgYGRiYCwgYW5kIHJlbW92ZXMgYGRiYCBmcm9tIGBjb25uLnJlbGF0ZWREYnNgIGFuZCBgY29ubi5vdGhlckRic2BcbiAqICAgICBhd2FpdCBjb25uLnJlbW92ZURiKCdteWRiJyk7XG4gKlxuICogQG1ldGhvZCByZW1vdmVEYlxuICogQG1lbWJlck9mIENvbm5lY3Rpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBkYXRhYmFzZSBuYW1lXG4gKiBAcmV0dXJuIHtDb25uZWN0aW9ufSB0aGlzXG4gKi9cblxuTmF0aXZlQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlRGIgPSBmdW5jdGlvbiByZW1vdmVEYihuYW1lKSB7XG4gIGNvbnN0IGRicyA9IHRoaXMub3RoZXJEYnMuZmlsdGVyKGRiID0+IGRiLm5hbWUgPT09IG5hbWUpO1xuICBpZiAoIWRicy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcihgTm8gY29ubmVjdGlvbnMgdG8gZGF0YWJhc2UgXCIke25hbWV9XCIgZm91bmRgKTtcbiAgfVxuXG4gIGZvciAoY29uc3QgZGIgb2YgZGJzKSB7XG4gICAgZGIuX2Nsb3NlQ2FsbGVkID0gdHJ1ZTtcbiAgICBkYi5fZGVzdHJveUNhbGxlZCA9IHRydWU7XG4gICAgZGIuX3JlYWR5U3RhdGUgPSBTVEFURVMuZGlzY29ubmVjdGVkO1xuICAgIGRiLiR3YXNGb3JjZUNsb3NlZCA9IHRydWU7XG4gIH1cbiAgZGVsZXRlIHRoaXMucmVsYXRlZERic1tuYW1lXTtcbiAgdGhpcy5vdGhlckRicyA9IHRoaXMub3RoZXJEYnMuZmlsdGVyKGRiID0+IGRiLm5hbWUgIT09IG5hbWUpO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIGNvbm5lY3Rpb25cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZV1cbiAqIEByZXR1cm4ge0Nvbm5lY3Rpb259IHRoaXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk5hdGl2ZUNvbm5lY3Rpb24ucHJvdG90eXBlLmRvQ2xvc2UgPSBhc3luYyBmdW5jdGlvbiBkb0Nsb3NlKGZvcmNlKSB7XG4gIGlmICh0aGlzLmNsaWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsZXQgc2tpcENsb3NlQ2xpZW50ID0gZmFsc2U7XG4gIGlmIChmb3JjZSAhPSBudWxsICYmIHR5cGVvZiBmb3JjZSA9PT0gJ29iamVjdCcpIHtcbiAgICBza2lwQ2xvc2VDbGllbnQgPSBmb3JjZS5za2lwQ2xvc2VDbGllbnQ7XG4gICAgZm9yY2UgPSBmb3JjZS5mb3JjZTtcbiAgfVxuXG4gIGlmIChza2lwQ2xvc2VDbGllbnQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGF3YWl0IHRoaXMuY2xpZW50LmNsb3NlKGZvcmNlKTtcbiAgLy8gRGVmZXIgYmVjYXVzZSB0aGUgZHJpdmVyIHdpbGwgd2FpdCBhdCBsZWFzdCAxbXMgYmVmb3JlIGZpbmlzaGluZyBjbG9zaW5nXG4gIC8vIHRoZSBwb29sLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21vbmdvZGItanMvbW9uZ29kYi1jb3JlL2Jsb2IvYThmOGU0Y2U0MTkzNmJhYmMzYjkxMTJiZjQyZDYwOTc3OWYwM2IzOS9saWIvY29ubmVjdGlvbi9wb29sLmpzI0wxMDI2LUwxMDMwLlxuICAvLyBJZiB0aGVyZSdzIHF1ZXVlZCBvcGVyYXRpb25zLCB5b3UgbWF5IHN0aWxsIGdldCBzb21lIGJhY2tncm91bmQgd29ya1xuICAvLyBhZnRlciB0aGUgY2FsbGJhY2sgaXMgY2FsbGVkLlxuICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMSkpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5OYXRpdmVDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVDbGllbnQgPSBhc3luYyBmdW5jdGlvbiBjcmVhdGVDbGllbnQodXJpLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgdXJpICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdUaGUgYHVyaWAgcGFyYW1ldGVyIHRvIGBvcGVuVXJpKClgIG11c3QgYmUgYSAnICtcbiAgICAgIGBzdHJpbmcsIGdvdCBcIiR7dHlwZW9mIHVyaX1cIi4gTWFrZSBzdXJlIHRoZSBmaXJzdCBwYXJhbWV0ZXIgdG8gYCArXG4gICAgICAnYG1vbmdvb3NlLmNvbm5lY3QoKWAgb3IgYG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oKWAgaXMgYSBzdHJpbmcuJyk7XG4gIH1cblxuICBpZiAodGhpcy5fZGVzdHJveUNhbGxlZCkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKFxuICAgICAgJ0Nvbm5lY3Rpb24gaGFzIGJlZW4gY2xvc2VkIGFuZCBkZXN0cm95ZWQsIGFuZCBjYW5ub3QgYmUgdXNlZCBmb3IgcmUtb3BlbmluZyB0aGUgY29ubmVjdGlvbi4gJyArXG4gICAgICAnUGxlYXNlIGNyZWF0ZSBhIG5ldyBjb25uZWN0aW9uIHdpdGggYG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oKWAgb3IgYG1vbmdvb3NlLmNvbm5lY3QoKWAuJ1xuICAgICk7XG4gIH1cblxuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTVEFURVMuY29ubmVjdGluZyB8fCB0aGlzLnJlYWR5U3RhdGUgPT09IFNUQVRFUy5jb25uZWN0ZWQpIHtcbiAgICBpZiAodGhpcy5fY29ubmVjdGlvblN0cmluZyAhPT0gdXJpKSB7XG4gICAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignQ2FuXFwndCBjYWxsIGBvcGVuVXJpKClgIG9uIGFuIGFjdGl2ZSBjb25uZWN0aW9uIHdpdGggJyArXG4gICAgICAgICdkaWZmZXJlbnQgY29ubmVjdGlvbiBzdHJpbmdzLiBNYWtlIHN1cmUgeW91IGFyZW5cXCd0IGNhbGxpbmcgYG1vbmdvb3NlLmNvbm5lY3QoKWAgJyArXG4gICAgICAgICdtdWx0aXBsZSB0aW1lcy4gU2VlOiBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvY29ubmVjdGlvbnMuaHRtbCNtdWx0aXBsZV9jb25uZWN0aW9ucycpO1xuICAgIH1cbiAgfVxuXG4gIG9wdGlvbnMgPSBwcm9jZXNzQ29ubmVjdGlvbk9wdGlvbnModXJpLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucykge1xuXG4gICAgY29uc3QgYXV0b0luZGV4ID0gb3B0aW9ucy5jb25maWcgJiYgb3B0aW9ucy5jb25maWcuYXV0b0luZGV4ICE9IG51bGwgP1xuICAgICAgb3B0aW9ucy5jb25maWcuYXV0b0luZGV4IDpcbiAgICAgIG9wdGlvbnMuYXV0b0luZGV4O1xuICAgIGlmIChhdXRvSW5kZXggIT0gbnVsbCkge1xuICAgICAgdGhpcy5jb25maWcuYXV0b0luZGV4ID0gYXV0b0luZGV4ICE9PSBmYWxzZTtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLmNvbmZpZztcbiAgICAgIGRlbGV0ZSBvcHRpb25zLmF1dG9JbmRleDtcbiAgICB9XG5cbiAgICBpZiAoJ2F1dG9DcmVhdGUnIGluIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuY29uZmlnLmF1dG9DcmVhdGUgPSAhIW9wdGlvbnMuYXV0b0NyZWF0ZTtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLmF1dG9DcmVhdGU7XG4gICAgfVxuXG4gICAgaWYgKCdzYW5pdGl6ZUZpbHRlcicgaW4gb3B0aW9ucykge1xuICAgICAgdGhpcy5jb25maWcuc2FuaXRpemVGaWx0ZXIgPSBvcHRpb25zLnNhbml0aXplRmlsdGVyO1xuICAgICAgZGVsZXRlIG9wdGlvbnMuc2FuaXRpemVGaWx0ZXI7XG4gICAgfVxuXG4gICAgaWYgKCdhdXRvU2VhcmNoSW5kZXgnIGluIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuY29uZmlnLmF1dG9TZWFyY2hJbmRleCA9IG9wdGlvbnMuYXV0b1NlYXJjaEluZGV4O1xuICAgICAgZGVsZXRlIG9wdGlvbnMuYXV0b1NlYXJjaEluZGV4O1xuICAgIH1cblxuICAgIC8vIEJhY2t3YXJkcyBjb21wYXRcbiAgICBpZiAob3B0aW9ucy51c2VyIHx8IG9wdGlvbnMucGFzcykge1xuICAgICAgb3B0aW9ucy5hdXRoID0gb3B0aW9ucy5hdXRoIHx8IHt9O1xuICAgICAgb3B0aW9ucy5hdXRoLnVzZXJuYW1lID0gb3B0aW9ucy51c2VyO1xuICAgICAgb3B0aW9ucy5hdXRoLnBhc3N3b3JkID0gb3B0aW9ucy5wYXNzO1xuXG4gICAgICB0aGlzLnVzZXIgPSBvcHRpb25zLnVzZXI7XG4gICAgICB0aGlzLnBhc3MgPSBvcHRpb25zLnBhc3M7XG4gICAgfVxuICAgIGRlbGV0ZSBvcHRpb25zLnVzZXI7XG4gICAgZGVsZXRlIG9wdGlvbnMucGFzcztcblxuICAgIGlmIChvcHRpb25zLmJ1ZmZlckNvbW1hbmRzICE9IG51bGwpIHtcbiAgICAgIHRoaXMuY29uZmlnLmJ1ZmZlckNvbW1hbmRzID0gb3B0aW9ucy5idWZmZXJDb21tYW5kcztcbiAgICAgIGRlbGV0ZSBvcHRpb25zLmJ1ZmZlckNvbW1hbmRzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB0aGlzLl9jb25uZWN0aW9uT3B0aW9ucyA9IG9wdGlvbnM7XG4gIGNvbnN0IGRiTmFtZSA9IG9wdGlvbnMuZGJOYW1lO1xuICBpZiAoZGJOYW1lICE9IG51bGwpIHtcbiAgICB0aGlzLiRkYk5hbWUgPSBkYk5hbWU7XG4gIH1cbiAgZGVsZXRlIG9wdGlvbnMuZGJOYW1lO1xuXG4gIGlmICghdXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eShvcHRpb25zLCAnZHJpdmVySW5mbycpKSB7XG4gICAgb3B0aW9ucy5kcml2ZXJJbmZvID0ge1xuICAgICAgbmFtZTogJ01vbmdvb3NlJyxcbiAgICAgIHZlcnNpb246IHBrZy52ZXJzaW9uXG4gICAgfTtcbiAgfVxuXG4gIHRoaXMucmVhZHlTdGF0ZSA9IFNUQVRFUy5jb25uZWN0aW5nO1xuICB0aGlzLl9jb25uZWN0aW9uU3RyaW5nID0gdXJpO1xuXG4gIGxldCBjbGllbnQ7XG4gIHRyeSB7XG4gICAgY2xpZW50ID0gbmV3IG1vbmdvZGIuTW9uZ29DbGllbnQodXJpLCBvcHRpb25zKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBTVEFURVMuZGlzY29ubmVjdGVkO1xuICAgIHRocm93IGVycm9yO1xuICB9XG4gIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuXG4gIGNsaWVudC5zZXRNYXhMaXN0ZW5lcnMoMCk7XG4gIGF3YWl0IGNsaWVudC5jb25uZWN0KCk7XG5cbiAgX3NldENsaWVudCh0aGlzLCBjbGllbnQsIG9wdGlvbnMsIGRiTmFtZSk7XG5cbiAgZm9yIChjb25zdCBkYiBvZiB0aGlzLm90aGVyRGJzKSB7XG4gICAgX3NldENsaWVudChkYiwgY2xpZW50LCB7fSwgZGIubmFtZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbk5hdGl2ZUNvbm5lY3Rpb24ucHJvdG90eXBlLnNldENsaWVudCA9IGZ1bmN0aW9uIHNldENsaWVudChjbGllbnQpIHtcbiAgaWYgKCEoY2xpZW50IGluc3RhbmNlb2YgbW9uZ29kYi5Nb25nb0NsaWVudCkpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTXVzdCBjYWxsIGBzZXRDbGllbnQoKWAgd2l0aCBhbiBpbnN0YW5jZSBvZiBNb25nb0NsaWVudCcpO1xuICB9XG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFNUQVRFUy5kaXNjb25uZWN0ZWQpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignQ2Fubm90IGNhbGwgYHNldENsaWVudCgpYCBvbiBhIGNvbm5lY3Rpb24gdGhhdCBpcyBhbHJlYWR5IGNvbm5lY3RlZC4nKTtcbiAgfVxuICBpZiAoY2xpZW50LnRvcG9sb2d5ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignQ2Fubm90IGNhbGwgYHNldENsaWVudCgpYCB3aXRoIGEgTW9uZ29DbGllbnQgdGhhdCB5b3UgaGF2ZSBub3QgY2FsbGVkIGBjb25uZWN0KClgIG9uIHlldC4nKTtcbiAgfVxuXG4gIHRoaXMuX2Nvbm5lY3Rpb25TdHJpbmcgPSBjbGllbnQucy51cmw7XG4gIF9zZXRDbGllbnQodGhpcywgY2xpZW50LCB7fSwgY2xpZW50LnMub3B0aW9ucy5kYk5hbWUpO1xuXG4gIGZvciAoY29uc3QgbW9kZWwgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLm1vZGVscykpIHtcbiAgICAvLyBFcnJvcnMgaGFuZGxlZCBpbnRlcm5hbGx5LCBzbyBzYWZlIHRvIGlnbm9yZSBlcnJvclxuICAgIG1vZGVsLmluaXQoKS5jYXRjaChmdW5jdGlvbiAkbW9kZWxJbml0Tm9vcCgpIHt9KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfc2V0Q2xpZW50KGNvbm4sIGNsaWVudCwgb3B0aW9ucywgZGJOYW1lKSB7XG4gIGNvbnN0IGRiID0gZGJOYW1lICE9IG51bGwgPyBjbGllbnQuZGIoZGJOYW1lKSA6IGNsaWVudC5kYigpO1xuICBjb25uLmRiID0gZGI7XG4gIGNvbm4uY2xpZW50ID0gY2xpZW50O1xuICBjb25uLmhvc3QgPSBjbGllbnQgJiZcbiAgICBjbGllbnQucyAmJlxuICAgIGNsaWVudC5zLm9wdGlvbnMgJiZcbiAgICBjbGllbnQucy5vcHRpb25zLmhvc3RzICYmXG4gICAgY2xpZW50LnMub3B0aW9ucy5ob3N0c1swXSAmJlxuICAgIGNsaWVudC5zLm9wdGlvbnMuaG9zdHNbMF0uaG9zdCB8fCB2b2lkIDA7XG4gIGNvbm4ucG9ydCA9IGNsaWVudCAmJlxuICAgIGNsaWVudC5zICYmXG4gICAgY2xpZW50LnMub3B0aW9ucyAmJlxuICAgIGNsaWVudC5zLm9wdGlvbnMuaG9zdHMgJiZcbiAgICBjbGllbnQucy5vcHRpb25zLmhvc3RzWzBdICYmXG4gICAgY2xpZW50LnMub3B0aW9ucy5ob3N0c1swXS5wb3J0IHx8IHZvaWQgMDtcbiAgY29ubi5uYW1lID0gZGJOYW1lICE9IG51bGwgPyBkYk5hbWUgOiBkYi5kYXRhYmFzZU5hbWU7XG4gIGNvbm4uX2Nsb3NlQ2FsbGVkID0gY2xpZW50Ll9jbG9zZUNhbGxlZDtcblxuICBjb25zdCBfaGFuZGxlUmVjb25uZWN0ID0gKCkgPT4ge1xuICAgIC8vIElmIHdlIGFyZW4ndCBkaXNjb25uZWN0ZWQsIHdlIGFzc3VtZSB0aGlzIHJlY29ubmVjdCBpcyBkdWUgdG8gYVxuICAgIC8vIHNvY2tldCB0aW1lb3V0LiBJZiB0aGVyZSdzIG5vIGFjdGl2aXR5IG9uIGEgc29ja2V0IGZvclxuICAgIC8vIGBzb2NrZXRUaW1lb3V0TVNgLCB0aGUgZHJpdmVyIHdpbGwgYXR0ZW1wdCB0byByZWNvbm5lY3QgYW5kIGVtaXRcbiAgICAvLyB0aGlzIGV2ZW50LlxuICAgIGlmIChjb25uLnJlYWR5U3RhdGUgIT09IFNUQVRFUy5jb25uZWN0ZWQpIHtcbiAgICAgIGNvbm4ucmVhZHlTdGF0ZSA9IFNUQVRFUy5jb25uZWN0ZWQ7XG4gICAgICBjb25uLmVtaXQoJ3JlY29ubmVjdCcpO1xuICAgICAgY29ubi5lbWl0KCdyZWNvbm5lY3RlZCcpO1xuICAgICAgY29ubi5vbk9wZW4oKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgdHlwZSA9IGNsaWVudCAmJlxuICBjbGllbnQudG9wb2xvZ3kgJiZcbiAgY2xpZW50LnRvcG9sb2d5LmRlc2NyaXB0aW9uICYmXG4gIGNsaWVudC50b3BvbG9neS5kZXNjcmlwdGlvbi50eXBlIHx8ICcnO1xuXG4gIGlmICh0eXBlID09PSAnU2luZ2xlJykge1xuICAgIGNsaWVudC5vbignc2VydmVyRGVzY3JpcHRpb25DaGFuZ2VkJywgZXYgPT4ge1xuICAgICAgY29uc3QgbmV3RGVzY3JpcHRpb24gPSBldi5uZXdEZXNjcmlwdGlvbjtcbiAgICAgIGlmIChuZXdEZXNjcmlwdGlvbi50eXBlID09PSAnVW5rbm93bicpIHtcbiAgICAgICAgY29ubi5yZWFkeVN0YXRlID0gU1RBVEVTLmRpc2Nvbm5lY3RlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9oYW5kbGVSZWNvbm5lY3QoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ1JlcGxpY2FTZXQnKSkge1xuICAgIGNsaWVudC5vbigndG9wb2xvZ3lEZXNjcmlwdGlvbkNoYW5nZWQnLCBldiA9PiB7XG4gICAgICAvLyBFbWl0IGRpc2Nvbm5lY3RlZCBpZiB3ZSd2ZSBsb3N0IGNvbm5lY3Rpdml0eSB0byB0aGUgcHJpbWFyeVxuICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBldi5uZXdEZXNjcmlwdGlvbjtcbiAgICAgIGlmIChjb25uLnJlYWR5U3RhdGUgPT09IFNUQVRFUy5jb25uZWN0ZWQgJiYgZGVzY3JpcHRpb24udHlwZSAhPT0gJ1JlcGxpY2FTZXRXaXRoUHJpbWFyeScpIHtcbiAgICAgICAgLy8gSW1wbGljaXRseSBlbWl0cyAnZGlzY29ubmVjdGVkJ1xuICAgICAgICBjb25uLnJlYWR5U3RhdGUgPSBTVEFURVMuZGlzY29ubmVjdGVkO1xuICAgICAgfSBlbHNlIGlmIChjb25uLnJlYWR5U3RhdGUgPT09IFNUQVRFUy5kaXNjb25uZWN0ZWQgJiYgZGVzY3JpcHRpb24udHlwZSA9PT0gJ1JlcGxpY2FTZXRXaXRoUHJpbWFyeScpIHtcbiAgICAgICAgX2hhbmRsZVJlY29ubmVjdCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY29ubi5vbk9wZW4oKTtcblxuICBmb3IgKGNvbnN0IGkgaW4gY29ubi5jb2xsZWN0aW9ucykge1xuICAgIGlmICh1dGlscy5vYmplY3QuaGFzT3duUHJvcGVydHkoY29ubi5jb2xsZWN0aW9ucywgaSkpIHtcbiAgICAgIGNvbm4uY29sbGVjdGlvbnNbaV0ub25PcGVuKCk7XG4gICAgfVxuICB9XG59XG5cblxuLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5hdGl2ZUNvbm5lY3Rpb247XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/drivers/node-mongodb-native/connection.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/drivers/node-mongodb-native/index.js":
/*!*********************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/drivers/node-mongodb-native/index.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module exports.\n */\n\n\n\nexports.Collection = __webpack_require__(/*! ./collection */ \"../backend/node_modules/mongoose/lib/drivers/node-mongodb-native/collection.js\");\nexports.Connection = __webpack_require__(/*! ./connection */ \"../backend/node_modules/mongoose/lib/drivers/node-mongodb-native/connection.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2RyaXZlcnMvbm9kZS1tb25nb2RiLW5hdGl2ZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsOElBQTRDO0FBQzVDLDhJQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9kcml2ZXJzL25vZGUtbW9uZ29kYi1uYXRpdmUvaW5kZXguanM/MjFiNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5Db2xsZWN0aW9uID0gcmVxdWlyZSgnLi9jb2xsZWN0aW9uJyk7XG5leHBvcnRzLkNvbm5lY3Rpb24gPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb24nKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/drivers/node-mongodb-native/index.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/error/bulkWriteError.js":
/*!********************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/error/bulkWriteError.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"../backend/node_modules/mongoose/lib/error/index.js\");\n\n\n/**\n * If `bulkWrite()` or `insertMany()` has validation errors, but\n * all valid operations succeed, and 'throwOnValidationError' is true,\n * Mongoose will throw this error.\n *\n * @api private\n */\n\nclass MongooseBulkWriteError extends MongooseError {\n  constructor(validationErrors, results, rawResult, operation) {\n    let preview = validationErrors.map(e => e.message).join(', ');\n    if (preview.length > 200) {\n      preview = preview.slice(0, 200) + '...';\n    }\n    super(`${operation} failed with ${validationErrors.length} Mongoose validation errors: ${preview}`);\n\n    this.validationErrors = validationErrors;\n    this.results = results;\n    this.rawResult = rawResult;\n    this.operation = operation;\n  }\n}\n\nObject.defineProperty(MongooseBulkWriteError.prototype, 'name', {\n  value: 'MongooseBulkWriteError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = MongooseBulkWriteError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL2J1bGtXcml0ZUVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQywrREFBSTs7O0FBR2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVyxjQUFjLHlCQUF5Qiw4QkFBOEIsUUFBUTs7QUFFckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9lcnJvci9idWxrV3JpdGVFcnJvci5qcz8xYjRjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLycpO1xuXG5cbi8qKlxuICogSWYgYGJ1bGtXcml0ZSgpYCBvciBgaW5zZXJ0TWFueSgpYCBoYXMgdmFsaWRhdGlvbiBlcnJvcnMsIGJ1dFxuICogYWxsIHZhbGlkIG9wZXJhdGlvbnMgc3VjY2VlZCwgYW5kICd0aHJvd09uVmFsaWRhdGlvbkVycm9yJyBpcyB0cnVlLFxuICogTW9uZ29vc2Ugd2lsbCB0aHJvdyB0aGlzIGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmNsYXNzIE1vbmdvb3NlQnVsa1dyaXRlRXJyb3IgZXh0ZW5kcyBNb25nb29zZUVycm9yIHtcbiAgY29uc3RydWN0b3IodmFsaWRhdGlvbkVycm9ycywgcmVzdWx0cywgcmF3UmVzdWx0LCBvcGVyYXRpb24pIHtcbiAgICBsZXQgcHJldmlldyA9IHZhbGlkYXRpb25FcnJvcnMubWFwKGUgPT4gZS5tZXNzYWdlKS5qb2luKCcsICcpO1xuICAgIGlmIChwcmV2aWV3Lmxlbmd0aCA+IDIwMCkge1xuICAgICAgcHJldmlldyA9IHByZXZpZXcuc2xpY2UoMCwgMjAwKSArICcuLi4nO1xuICAgIH1cbiAgICBzdXBlcihgJHtvcGVyYXRpb259IGZhaWxlZCB3aXRoICR7dmFsaWRhdGlvbkVycm9ycy5sZW5ndGh9IE1vbmdvb3NlIHZhbGlkYXRpb24gZXJyb3JzOiAke3ByZXZpZXd9YCk7XG5cbiAgICB0aGlzLnZhbGlkYXRpb25FcnJvcnMgPSB2YWxpZGF0aW9uRXJyb3JzO1xuICAgIHRoaXMucmVzdWx0cyA9IHJlc3VsdHM7XG4gICAgdGhpcy5yYXdSZXN1bHQgPSByYXdSZXN1bHQ7XG4gICAgdGhpcy5vcGVyYXRpb24gPSBvcGVyYXRpb247XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vbmdvb3NlQnVsa1dyaXRlRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdNb25nb29zZUJ1bGtXcml0ZUVycm9yJ1xufSk7XG5cbi8qIVxuICogZXhwb3J0c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTW9uZ29vc2VCdWxrV3JpdGVFcnJvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/error/bulkWriteError.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/error/cast.js":
/*!**********************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/error/cast.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseError = __webpack_require__(/*! ./mongooseError */ \"../backend/node_modules/mongoose/lib/error/mongooseError.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\n/**\n * Casting Error constructor.\n *\n * @param {String} type\n * @param {String} value\n * @inherits MongooseError\n * @api private\n */\n\nclass CastError extends MongooseError {\n  constructor(type, value, path, reason, schemaType) {\n    // If no args, assume we'll `init()` later.\n    if (arguments.length > 0) {\n      const valueType = getValueType(value);\n      const messageFormat = getMessageFormat(schemaType);\n      const msg = formatMessage(null, type, value, path, messageFormat, valueType, reason);\n      super(msg);\n      this.init(type, value, path, reason, schemaType);\n    } else {\n      super(formatMessage());\n    }\n  }\n\n  toJSON() {\n    return {\n      stringValue: this.stringValue,\n      valueType: this.valueType,\n      kind: this.kind,\n      value: this.value,\n      path: this.path,\n      reason: this.reason,\n      name: this.name,\n      message: this.message\n    };\n  }\n  /*!\n   * ignore\n   */\n  init(type, value, path, reason, schemaType) {\n    this.stringValue = getStringValue(value);\n    this.messageFormat = getMessageFormat(schemaType);\n    this.kind = type;\n    this.value = value;\n    this.path = path;\n    this.reason = reason;\n    this.valueType = getValueType(value);\n  }\n\n  /**\n   * ignore\n   * @param {Readonly<CastError>} other\n   * @api private\n   */\n  copy(other) {\n    this.messageFormat = other.messageFormat;\n    this.stringValue = other.stringValue;\n    this.kind = other.kind;\n    this.value = other.value;\n    this.path = other.path;\n    this.reason = other.reason;\n    this.message = other.message;\n    this.valueType = other.valueType;\n  }\n\n  /*!\n   * ignore\n   */\n  setModel(model) {\n    this.model = model;\n    this.message = formatMessage(model, this.kind, this.value, this.path,\n      this.messageFormat, this.valueType);\n  }\n}\n\nObject.defineProperty(CastError.prototype, 'name', {\n  value: 'CastError'\n});\n\nfunction getStringValue(value) {\n  let stringValue = util.inspect(value);\n  stringValue = stringValue.replace(/^'|'$/g, '\"');\n  if (!stringValue.startsWith('\"')) {\n    stringValue = '\"' + stringValue + '\"';\n  }\n  return stringValue;\n}\n\nfunction getValueType(value) {\n  if (value == null) {\n    return '' + value;\n  }\n\n  const t = typeof value;\n  if (t !== 'object') {\n    return t;\n  }\n  if (typeof value.constructor !== 'function') {\n    return t;\n  }\n  return value.constructor.name;\n}\n\nfunction getMessageFormat(schemaType) {\n  const messageFormat = schemaType && schemaType._castErrorMessage || null;\n  if (typeof messageFormat === 'string' || typeof messageFormat === 'function') {\n    return messageFormat;\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction formatMessage(model, kind, value, path, messageFormat, valueType, reason) {\n  if (typeof messageFormat === 'string') {\n    const stringValue = getStringValue(value);\n    let ret = messageFormat.\n      replace('{KIND}', kind).\n      replace('{VALUE}', stringValue).\n      replace('{PATH}', path);\n    if (model != null) {\n      ret = ret.replace('{MODEL}', model.modelName);\n    }\n\n    return ret;\n  } else if (typeof messageFormat === 'function') {\n    return messageFormat(value, path, model, kind);\n  } else {\n    const stringValue = getStringValue(value);\n    const valueTypeMsg = valueType ? ' (type ' + valueType + ')' : '';\n    let ret = 'Cast to ' + kind + ' failed for value ' +\n      stringValue + valueTypeMsg + ' at path \"' + path + '\"';\n    if (model != null) {\n      ret += ' for model \"' + model.modelName + '\"';\n    }\n    if (reason != null &&\n        typeof reason.constructor === 'function' &&\n        reason.constructor.name !== 'AssertionError' &&\n        reason.constructor.name !== 'Error') {\n      ret += ' because of \"' + reason.constructor.name + '\"';\n    }\n    return ret;\n  }\n}\n\n/*!\n * exports\n */\n\nmodule.exports = CastError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL2Nhc3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixtQkFBTyxDQUFDLG9GQUFpQjtBQUMvQyxhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBSztBQUNyQixnQkFBZ0IsTUFBTTtBQUN0QixnQkFBZ0IsS0FBSztBQUNyQjtBQUNBLDBCQUEwQixNQUFNO0FBQ2hDOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9lcnJvci9jYXN0LmpzPzI1NzYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vbW9uZ29vc2VFcnJvcicpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLyoqXG4gKiBDYXN0aW5nIEVycm9yIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEBpbmhlcml0cyBNb25nb29zZUVycm9yXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5jbGFzcyBDYXN0RXJyb3IgZXh0ZW5kcyBNb25nb29zZUVycm9yIHtcbiAgY29uc3RydWN0b3IodHlwZSwgdmFsdWUsIHBhdGgsIHJlYXNvbiwgc2NoZW1hVHlwZSkge1xuICAgIC8vIElmIG5vIGFyZ3MsIGFzc3VtZSB3ZSdsbCBgaW5pdCgpYCBsYXRlci5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IGdldFZhbHVlVHlwZSh2YWx1ZSk7XG4gICAgICBjb25zdCBtZXNzYWdlRm9ybWF0ID0gZ2V0TWVzc2FnZUZvcm1hdChzY2hlbWFUeXBlKTtcbiAgICAgIGNvbnN0IG1zZyA9IGZvcm1hdE1lc3NhZ2UobnVsbCwgdHlwZSwgdmFsdWUsIHBhdGgsIG1lc3NhZ2VGb3JtYXQsIHZhbHVlVHlwZSwgcmVhc29uKTtcbiAgICAgIHN1cGVyKG1zZyk7XG4gICAgICB0aGlzLmluaXQodHlwZSwgdmFsdWUsIHBhdGgsIHJlYXNvbiwgc2NoZW1hVHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyKGZvcm1hdE1lc3NhZ2UoKSk7XG4gICAgfVxuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdHJpbmdWYWx1ZTogdGhpcy5zdHJpbmdWYWx1ZSxcbiAgICAgIHZhbHVlVHlwZTogdGhpcy52YWx1ZVR5cGUsXG4gICAgICBraW5kOiB0aGlzLmtpbmQsXG4gICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcbiAgICAgIHBhdGg6IHRoaXMucGF0aCxcbiAgICAgIHJlYXNvbjogdGhpcy5yZWFzb24sXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2VcbiAgICB9O1xuICB9XG4gIC8qIVxuICAgKiBpZ25vcmVcbiAgICovXG4gIGluaXQodHlwZSwgdmFsdWUsIHBhdGgsIHJlYXNvbiwgc2NoZW1hVHlwZSkge1xuICAgIHRoaXMuc3RyaW5nVmFsdWUgPSBnZXRTdHJpbmdWYWx1ZSh2YWx1ZSk7XG4gICAgdGhpcy5tZXNzYWdlRm9ybWF0ID0gZ2V0TWVzc2FnZUZvcm1hdChzY2hlbWFUeXBlKTtcbiAgICB0aGlzLmtpbmQgPSB0eXBlO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICAgIHRoaXMudmFsdWVUeXBlID0gZ2V0VmFsdWVUeXBlKHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBpZ25vcmVcbiAgICogQHBhcmFtIHtSZWFkb25seTxDYXN0RXJyb3I+fSBvdGhlclxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNvcHkob3RoZXIpIHtcbiAgICB0aGlzLm1lc3NhZ2VGb3JtYXQgPSBvdGhlci5tZXNzYWdlRm9ybWF0O1xuICAgIHRoaXMuc3RyaW5nVmFsdWUgPSBvdGhlci5zdHJpbmdWYWx1ZTtcbiAgICB0aGlzLmtpbmQgPSBvdGhlci5raW5kO1xuICAgIHRoaXMudmFsdWUgPSBvdGhlci52YWx1ZTtcbiAgICB0aGlzLnBhdGggPSBvdGhlci5wYXRoO1xuICAgIHRoaXMucmVhc29uID0gb3RoZXIucmVhc29uO1xuICAgIHRoaXMubWVzc2FnZSA9IG90aGVyLm1lc3NhZ2U7XG4gICAgdGhpcy52YWx1ZVR5cGUgPSBvdGhlci52YWx1ZVR5cGU7XG4gIH1cblxuICAvKiFcbiAgICogaWdub3JlXG4gICAqL1xuICBzZXRNb2RlbChtb2RlbCkge1xuICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICB0aGlzLm1lc3NhZ2UgPSBmb3JtYXRNZXNzYWdlKG1vZGVsLCB0aGlzLmtpbmQsIHRoaXMudmFsdWUsIHRoaXMucGF0aCxcbiAgICAgIHRoaXMubWVzc2FnZUZvcm1hdCwgdGhpcy52YWx1ZVR5cGUpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXN0RXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdDYXN0RXJyb3InXG59KTtcblxuZnVuY3Rpb24gZ2V0U3RyaW5nVmFsdWUodmFsdWUpIHtcbiAgbGV0IHN0cmluZ1ZhbHVlID0gdXRpbC5pbnNwZWN0KHZhbHVlKTtcbiAgc3RyaW5nVmFsdWUgPSBzdHJpbmdWYWx1ZS5yZXBsYWNlKC9eJ3wnJC9nLCAnXCInKTtcbiAgaWYgKCFzdHJpbmdWYWx1ZS5zdGFydHNXaXRoKCdcIicpKSB7XG4gICAgc3RyaW5nVmFsdWUgPSAnXCInICsgc3RyaW5nVmFsdWUgKyAnXCInO1xuICB9XG4gIHJldHVybiBzdHJpbmdWYWx1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVUeXBlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnICsgdmFsdWU7XG4gIH1cblxuICBjb25zdCB0ID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodCAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gdDtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlLmNvbnN0cnVjdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgcmV0dXJuIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG59XG5cbmZ1bmN0aW9uIGdldE1lc3NhZ2VGb3JtYXQoc2NoZW1hVHlwZSkge1xuICBjb25zdCBtZXNzYWdlRm9ybWF0ID0gc2NoZW1hVHlwZSAmJiBzY2hlbWFUeXBlLl9jYXN0RXJyb3JNZXNzYWdlIHx8IG51bGw7XG4gIGlmICh0eXBlb2YgbWVzc2FnZUZvcm1hdCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG1lc3NhZ2VGb3JtYXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWVzc2FnZUZvcm1hdDtcbiAgfVxufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2UobW9kZWwsIGtpbmQsIHZhbHVlLCBwYXRoLCBtZXNzYWdlRm9ybWF0LCB2YWx1ZVR5cGUsIHJlYXNvbikge1xuICBpZiAodHlwZW9mIG1lc3NhZ2VGb3JtYXQgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3Qgc3RyaW5nVmFsdWUgPSBnZXRTdHJpbmdWYWx1ZSh2YWx1ZSk7XG4gICAgbGV0IHJldCA9IG1lc3NhZ2VGb3JtYXQuXG4gICAgICByZXBsYWNlKCd7S0lORH0nLCBraW5kKS5cbiAgICAgIHJlcGxhY2UoJ3tWQUxVRX0nLCBzdHJpbmdWYWx1ZSkuXG4gICAgICByZXBsYWNlKCd7UEFUSH0nLCBwYXRoKTtcbiAgICBpZiAobW9kZWwgIT0gbnVsbCkge1xuICAgICAgcmV0ID0gcmV0LnJlcGxhY2UoJ3tNT0RFTH0nLCBtb2RlbC5tb2RlbE5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1lc3NhZ2VGb3JtYXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWVzc2FnZUZvcm1hdCh2YWx1ZSwgcGF0aCwgbW9kZWwsIGtpbmQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHN0cmluZ1ZhbHVlID0gZ2V0U3RyaW5nVmFsdWUodmFsdWUpO1xuICAgIGNvbnN0IHZhbHVlVHlwZU1zZyA9IHZhbHVlVHlwZSA/ICcgKHR5cGUgJyArIHZhbHVlVHlwZSArICcpJyA6ICcnO1xuICAgIGxldCByZXQgPSAnQ2FzdCB0byAnICsga2luZCArICcgZmFpbGVkIGZvciB2YWx1ZSAnICtcbiAgICAgIHN0cmluZ1ZhbHVlICsgdmFsdWVUeXBlTXNnICsgJyBhdCBwYXRoIFwiJyArIHBhdGggKyAnXCInO1xuICAgIGlmIChtb2RlbCAhPSBudWxsKSB7XG4gICAgICByZXQgKz0gJyBmb3IgbW9kZWwgXCInICsgbW9kZWwubW9kZWxOYW1lICsgJ1wiJztcbiAgICB9XG4gICAgaWYgKHJlYXNvbiAhPSBudWxsICYmXG4gICAgICAgIHR5cGVvZiByZWFzb24uY29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgcmVhc29uLmNvbnN0cnVjdG9yLm5hbWUgIT09ICdBc3NlcnRpb25FcnJvcicgJiZcbiAgICAgICAgcmVhc29uLmNvbnN0cnVjdG9yLm5hbWUgIT09ICdFcnJvcicpIHtcbiAgICAgIHJldCArPSAnIGJlY2F1c2Ugb2YgXCInICsgcmVhc29uLmNvbnN0cnVjdG9yLm5hbWUgKyAnXCInO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG59XG5cbi8qIVxuICogZXhwb3J0c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gQ2FzdEVycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/error/cast.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/error/createCollectionsError.js":
/*!****************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/error/createCollectionsError.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst MongooseError = __webpack_require__(/*! ./mongooseError */ \"../backend/node_modules/mongoose/lib/error/mongooseError.js\");\n\n/**\n * createCollections Error constructor\n *\n * @param {String} message\n * @param {String} errorsMap\n * @inherits MongooseError\n * @api private\n */\n\nclass CreateCollectionsError extends MongooseError {\n  constructor(message, errorsMap) {\n    super(message);\n    this.errors = errorsMap;\n  }\n}\n\nObject.defineProperty(CreateCollectionsError.prototype, 'name', {\n  value: 'CreateCollectionsError'\n});\n\nmodule.exports = CreateCollectionsError;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL2NyZWF0ZUNvbGxlY3Rpb25zRXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsb0ZBQWlCOztBQUUvQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvY3JlYXRlQ29sbGVjdGlvbnNFcnJvci5qcz80ZjRmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vbW9uZ29vc2VFcnJvcicpO1xuXG4vKipcbiAqIGNyZWF0ZUNvbGxlY3Rpb25zIEVycm9yIGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBlcnJvcnNNYXBcbiAqIEBpbmhlcml0cyBNb25nb29zZUVycm9yXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5jbGFzcyBDcmVhdGVDb2xsZWN0aW9uc0Vycm9yIGV4dGVuZHMgTW9uZ29vc2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGVycm9yc01hcCkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzTWFwO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDcmVhdGVDb2xsZWN0aW9uc0Vycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnQ3JlYXRlQ29sbGVjdGlvbnNFcnJvcidcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENyZWF0ZUNvbGxlY3Rpb25zRXJyb3I7XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/error/createCollectionsError.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/error/divergentArray.js":
/*!********************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/error/divergentArray.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"../backend/node_modules/mongoose/lib/error/index.js\");\n\nclass DivergentArrayError extends MongooseError {\n  /**\n   * DivergentArrayError constructor.\n   * @param {Array<String>} paths\n   * @api private\n   */\n  constructor(paths) {\n    const msg = 'For your own good, using `document.save()` to update an array '\n            + 'which was selected using an $elemMatch projection OR '\n            + 'populated using skip, limit, query conditions, or exclusion of '\n            + 'the _id field when the operation results in a $pop or $set of '\n            + 'the entire array is not supported. The following '\n            + 'path(s) would have been modified unsafely:\\n'\n            + '  ' + paths.join('\\n  ') + '\\n'\n            + 'Use Model.updateOne() to update these arrays instead.';\n    // TODO write up a docs page (FAQ) and link to it\n    super(msg);\n  }\n}\n\nObject.defineProperty(DivergentArrayError.prototype, 'name', {\n  value: 'DivergentArrayError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = DivergentArrayError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL2RpdmVyZ2VudEFycmF5LmpzIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsK0RBQUk7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL2RpdmVyZ2VudEFycmF5LmpzPzI4MTciXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi8nKTtcblxuY2xhc3MgRGl2ZXJnZW50QXJyYXlFcnJvciBleHRlbmRzIE1vbmdvb3NlRXJyb3Ige1xuICAvKipcbiAgICogRGl2ZXJnZW50QXJyYXlFcnJvciBjb25zdHJ1Y3Rvci5cbiAgICogQHBhcmFtIHtBcnJheTxTdHJpbmc+fSBwYXRoc1xuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhdGhzKSB7XG4gICAgY29uc3QgbXNnID0gJ0ZvciB5b3VyIG93biBnb29kLCB1c2luZyBgZG9jdW1lbnQuc2F2ZSgpYCB0byB1cGRhdGUgYW4gYXJyYXkgJ1xuICAgICAgICAgICAgKyAnd2hpY2ggd2FzIHNlbGVjdGVkIHVzaW5nIGFuICRlbGVtTWF0Y2ggcHJvamVjdGlvbiBPUiAnXG4gICAgICAgICAgICArICdwb3B1bGF0ZWQgdXNpbmcgc2tpcCwgbGltaXQsIHF1ZXJ5IGNvbmRpdGlvbnMsIG9yIGV4Y2x1c2lvbiBvZiAnXG4gICAgICAgICAgICArICd0aGUgX2lkIGZpZWxkIHdoZW4gdGhlIG9wZXJhdGlvbiByZXN1bHRzIGluIGEgJHBvcCBvciAkc2V0IG9mICdcbiAgICAgICAgICAgICsgJ3RoZSBlbnRpcmUgYXJyYXkgaXMgbm90IHN1cHBvcnRlZC4gVGhlIGZvbGxvd2luZyAnXG4gICAgICAgICAgICArICdwYXRoKHMpIHdvdWxkIGhhdmUgYmVlbiBtb2RpZmllZCB1bnNhZmVseTpcXG4nXG4gICAgICAgICAgICArICcgICcgKyBwYXRocy5qb2luKCdcXG4gICcpICsgJ1xcbidcbiAgICAgICAgICAgICsgJ1VzZSBNb2RlbC51cGRhdGVPbmUoKSB0byB1cGRhdGUgdGhlc2UgYXJyYXlzIGluc3RlYWQuJztcbiAgICAvLyBUT0RPIHdyaXRlIHVwIGEgZG9jcyBwYWdlIChGQVEpIGFuZCBsaW5rIHRvIGl0XG4gICAgc3VwZXIobXNnKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRGl2ZXJnZW50QXJyYXlFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ0RpdmVyZ2VudEFycmF5RXJyb3InXG59KTtcblxuLyohXG4gKiBleHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBEaXZlcmdlbnRBcnJheUVycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/error/divergentArray.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/error/eachAsyncMultiError.js":
/*!*************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/error/eachAsyncMultiError.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"../backend/node_modules/mongoose/lib/error/index.js\");\n\n\n/**\n * If `eachAsync()` is called with `continueOnError: true`, there can be\n * multiple errors. This error class contains an `errors` property, which\n * contains an array of all errors that occurred in `eachAsync()`.\n *\n * @api private\n */\n\nclass EachAsyncMultiError extends MongooseError {\n  /**\n   * @param {String} connectionString\n   */\n  constructor(errors) {\n    let preview = errors.map(e => e.message).join(', ');\n    if (preview.length > 50) {\n      preview = preview.slice(0, 50) + '...';\n    }\n    super(`eachAsync() finished with ${errors.length} errors: ${preview}`);\n\n    this.errors = errors;\n  }\n}\n\nObject.defineProperty(EachAsyncMultiError.prototype, 'name', {\n  value: 'EachAsyncMultiError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = EachAsyncMultiError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL2VhY2hBc3luY011bHRpRXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVhOztBQUViLHNCQUFzQixtQkFBTyxDQUFDLCtEQUFJOzs7QUFHbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZUFBZSxVQUFVLFFBQVE7O0FBRXhFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvZWFjaEFzeW5jTXVsdGlFcnJvci5qcz8xODVkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLycpO1xuXG5cbi8qKlxuICogSWYgYGVhY2hBc3luYygpYCBpcyBjYWxsZWQgd2l0aCBgY29udGludWVPbkVycm9yOiB0cnVlYCwgdGhlcmUgY2FuIGJlXG4gKiBtdWx0aXBsZSBlcnJvcnMuIFRoaXMgZXJyb3IgY2xhc3MgY29udGFpbnMgYW4gYGVycm9yc2AgcHJvcGVydHksIHdoaWNoXG4gKiBjb250YWlucyBhbiBhcnJheSBvZiBhbGwgZXJyb3JzIHRoYXQgb2NjdXJyZWQgaW4gYGVhY2hBc3luYygpYC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5jbGFzcyBFYWNoQXN5bmNNdWx0aUVycm9yIGV4dGVuZHMgTW9uZ29vc2VFcnJvciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29ubmVjdGlvblN0cmluZ1xuICAgKi9cbiAgY29uc3RydWN0b3IoZXJyb3JzKSB7XG4gICAgbGV0IHByZXZpZXcgPSBlcnJvcnMubWFwKGUgPT4gZS5tZXNzYWdlKS5qb2luKCcsICcpO1xuICAgIGlmIChwcmV2aWV3Lmxlbmd0aCA+IDUwKSB7XG4gICAgICBwcmV2aWV3ID0gcHJldmlldy5zbGljZSgwLCA1MCkgKyAnLi4uJztcbiAgICB9XG4gICAgc3VwZXIoYGVhY2hBc3luYygpIGZpbmlzaGVkIHdpdGggJHtlcnJvcnMubGVuZ3RofSBlcnJvcnM6ICR7cHJldmlld31gKTtcblxuICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFYWNoQXN5bmNNdWx0aUVycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnRWFjaEFzeW5jTXVsdGlFcnJvcidcbn0pO1xuXG4vKiFcbiAqIGV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVhY2hBc3luY011bHRpRXJyb3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/error/eachAsyncMultiError.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/error/index.js":
/*!***********************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/error/index.js ***!
  \***********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/**\n * MongooseError constructor. MongooseError is the base class for all\n * Mongoose-specific errors.\n *\n * #### Example:\n *\n *     const Model = mongoose.model('Test', new mongoose.Schema({ answer: Number }));\n *     const doc = new Model({ answer: 'not a number' });\n *     const err = doc.validateSync();\n *\n *     err instanceof mongoose.Error.ValidationError; // true\n *\n * @constructor Error\n * @param {String} msg Error message\n * @inherits Error https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error\n */\n\nconst MongooseError = __webpack_require__(/*! ./mongooseError */ \"../backend/node_modules/mongoose/lib/error/mongooseError.js\");\n\n/**\n * The name of the error. The name uniquely identifies this Mongoose error. The\n * possible values are:\n *\n * - `MongooseError`: general Mongoose error\n * - `CastError`: Mongoose could not convert a value to the type defined in the schema path. May be in a `ValidationError` class' `errors` property.\n * - `DivergentArrayError`: You attempted to `save()` an array that was modified after you loaded it with a `$elemMatch` or similar projection\n * - `MissingSchemaError`: You tried to access a model with [`mongoose.model()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.model()) that was not defined\n * - `DocumentNotFoundError`: The document you tried to [`save()`](https://mongoosejs.com/docs/api/document.html#Document.prototype.save()) was not found\n * - `ValidatorError`: error from an individual schema path's validator\n * - `ValidationError`: error returned from [`validate()`](https://mongoosejs.com/docs/api/document.html#Document.prototype.validate()) or [`validateSync()`](https://mongoosejs.com/docs/api/document.html#Document.prototype.validateSync()). Contains zero or more `ValidatorError` instances in `.errors` property.\n * - `MissingSchemaError`: You called `mongoose.Document()` without a schema\n * - `ObjectExpectedError`: Thrown when you set a nested path to a non-object value with [strict mode set](https://mongoosejs.com/docs/guide.html#strict).\n * - `ObjectParameterError`: Thrown when you pass a non-object value to a function which expects an object as a paramter\n * - `OverwriteModelError`: Thrown when you call [`mongoose.model()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.model()) to re-define a model that was already defined.\n * - `ParallelSaveError`: Thrown when you call [`save()`](https://mongoosejs.com/docs/api/model.html#Model.prototype.save()) on a document when the same document instance is already saving.\n * - `StrictModeError`: Thrown when you set a path that isn't the schema and [strict mode](https://mongoosejs.com/docs/guide.html#strict) is set to `throw`.\n * - `VersionError`: Thrown when the [document is out of sync](https://mongoosejs.com/docs/guide.html#versionKey)\n *\n * @api public\n * @property {String} name\n * @memberOf Error\n * @instance\n */\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = MongooseError;\n\n/**\n * The default built-in validator error messages.\n *\n * @see Error.messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.messages = __webpack_require__(/*! ./messages */ \"../backend/node_modules/mongoose/lib/error/messages.js\");\n\n// backward compat\nMongooseError.Messages = MongooseError.messages;\n\n/**\n * An instance of this error class will be returned when `save()` fails\n * because the underlying\n * document was not found. The constructor takes one parameter, the\n * conditions that mongoose passed to `updateOne()` when trying to update\n * the document.\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.DocumentNotFoundError = __webpack_require__(/*! ./notFound */ \"../backend/node_modules/mongoose/lib/error/notFound.js\");\n\n/**\n * An instance of this error class will be returned when mongoose failed to\n * cast a value.\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.CastError = __webpack_require__(/*! ./cast */ \"../backend/node_modules/mongoose/lib/error/cast.js\");\n\n/**\n * An instance of this error class will be returned when [validation](https://mongoosejs.com/docs/validation.html) failed.\n * The `errors` property contains an object whose keys are the paths that failed and whose values are\n * instances of CastError or ValidationError.\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.ValidationError = __webpack_require__(/*! ./validation */ \"../backend/node_modules/mongoose/lib/error/validation.js\");\n\n/**\n * A `ValidationError` has a hash of `errors` that contain individual\n * `ValidatorError` instances.\n *\n * #### Example:\n *\n *     const schema = Schema({ name: { type: String, required: true } });\n *     const Model = mongoose.model('Test', schema);\n *     const doc = new Model({});\n *\n *     // Top-level error is a ValidationError, **not** a ValidatorError\n *     const err = doc.validateSync();\n *     err instanceof mongoose.Error.ValidationError; // true\n *\n *     // A ValidationError `err` has 0 or more ValidatorErrors keyed by the\n *     // path in the `err.errors` property.\n *     err.errors['name'] instanceof mongoose.Error.ValidatorError;\n *\n *     err.errors['name'].kind; // 'required'\n *     err.errors['name'].path; // 'name'\n *     err.errors['name'].value; // undefined\n *\n * Instances of `ValidatorError` have the following properties:\n *\n * - `kind`: The validator's `type`, like `'required'` or `'regexp'`\n * - `path`: The path that failed validation\n * - `value`: The value that failed validation\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.ValidatorError = __webpack_require__(/*! ./validator */ \"../backend/node_modules/mongoose/lib/error/validator.js\");\n\n/**\n * An instance of this error class will be returned when you call `save()` after\n * the document in the database was changed in a potentially unsafe way. See\n * the [`versionKey` option](https://mongoosejs.com/docs/guide.html#versionKey) for more information.\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.VersionError = __webpack_require__(/*! ./version */ \"../backend/node_modules/mongoose/lib/error/version.js\");\n\n/**\n * An instance of this error class will be returned when you call `save()` multiple\n * times on the same document in parallel. See the [FAQ](https://mongoosejs.com/docs/faq.html) for more\n * information.\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.ParallelSaveError = __webpack_require__(/*! ./parallelSave */ \"../backend/node_modules/mongoose/lib/error/parallelSave.js\");\n\n/**\n * Thrown when a model with the given name was already registered on the connection.\n * See [the FAQ about `OverwriteModelError`](https://mongoosejs.com/docs/faq.html#overwrite-model-error).\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.OverwriteModelError = __webpack_require__(/*! ./overwriteModel */ \"../backend/node_modules/mongoose/lib/error/overwriteModel.js\");\n\n/**\n * Thrown when you try to access a model that has not been registered yet\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.MissingSchemaError = __webpack_require__(/*! ./missingSchema */ \"../backend/node_modules/mongoose/lib/error/missingSchema.js\");\n\n/**\n * Thrown when the MongoDB Node driver can't connect to a valid server\n * to send an operation to.\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.MongooseServerSelectionError = __webpack_require__(/*! ./serverSelection */ \"../backend/node_modules/mongoose/lib/error/serverSelection.js\");\n\n/**\n * An instance of this error will be returned if you used an array projection\n * and then modified the array in an unsafe way.\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.DivergentArrayError = __webpack_require__(/*! ./divergentArray */ \"../backend/node_modules/mongoose/lib/error/divergentArray.js\");\n\n/**\n * Thrown when your try to pass values to model constructor that\n * were not specified in schema or change immutable properties when\n * `strict` mode is `\"throw\"`\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.StrictModeError = __webpack_require__(/*! ./strict */ \"../backend/node_modules/mongoose/lib/error/strict.js\");\n\n/**\n * An instance of this error class will be returned when mongoose failed to\n * populate with a path that is not existing.\n *\n * @api public\n * @memberOf Error\n * @static\n */\n\nMongooseError.StrictPopulateError = __webpack_require__(/*! ./strictPopulate */ \"../backend/node_modules/mongoose/lib/error/strictPopulate.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxnQkFBZ0I7QUFDbEYsK0JBQStCLHdCQUF3QjtBQUN2RDtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQSxzQkFBc0IsbUJBQU8sQ0FBQyxvRkFBaUI7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixtQkFBTyxDQUFDLDBFQUFZOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLG1CQUFPLENBQUMsMEVBQVk7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLG1CQUFPLENBQUMsa0VBQVE7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsbUJBQU8sQ0FBQyw4RUFBYzs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVEsZ0NBQWdDO0FBQ3ZFO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQyxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsbUJBQU8sQ0FBQyw0RUFBYTs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixtQkFBTyxDQUFDLHdFQUFXOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLG1CQUFPLENBQUMsa0ZBQWdCOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxtQkFBTyxDQUFDLHNGQUFrQjs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLG1CQUFPLENBQUMsb0ZBQWlCOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QyxtQkFBTyxDQUFDLHdGQUFtQjs7QUFFeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsbUJBQU8sQ0FBQyxzRkFBa0I7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsbUJBQU8sQ0FBQyxzRUFBVTs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsbUJBQU8sQ0FBQyxzRkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvaW5kZXguanM/NWNkMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9uZ29vc2VFcnJvciBjb25zdHJ1Y3Rvci4gTW9uZ29vc2VFcnJvciBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgYWxsXG4gKiBNb25nb29zZS1zcGVjaWZpYyBlcnJvcnMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBNb2RlbCA9IG1vbmdvb3NlLm1vZGVsKCdUZXN0JywgbmV3IG1vbmdvb3NlLlNjaGVtYSh7IGFuc3dlcjogTnVtYmVyIH0pKTtcbiAqICAgICBjb25zdCBkb2MgPSBuZXcgTW9kZWwoeyBhbnN3ZXI6ICdub3QgYSBudW1iZXInIH0pO1xuICogICAgIGNvbnN0IGVyciA9IGRvYy52YWxpZGF0ZVN5bmMoKTtcbiAqXG4gKiAgICAgZXJyIGluc3RhbmNlb2YgbW9uZ29vc2UuRXJyb3IuVmFsaWRhdGlvbkVycm9yOyAvLyB0cnVlXG4gKlxuICogQGNvbnN0cnVjdG9yIEVycm9yXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIEVycm9yIG1lc3NhZ2VcbiAqIEBpbmhlcml0cyBFcnJvciBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvclxuICovXG5cbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuL21vbmdvb3NlRXJyb3InKTtcblxuLyoqXG4gKiBUaGUgbmFtZSBvZiB0aGUgZXJyb3IuIFRoZSBuYW1lIHVuaXF1ZWx5IGlkZW50aWZpZXMgdGhpcyBNb25nb29zZSBlcnJvci4gVGhlXG4gKiBwb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICpcbiAqIC0gYE1vbmdvb3NlRXJyb3JgOiBnZW5lcmFsIE1vbmdvb3NlIGVycm9yXG4gKiAtIGBDYXN0RXJyb3JgOiBNb25nb29zZSBjb3VsZCBub3QgY29udmVydCBhIHZhbHVlIHRvIHRoZSB0eXBlIGRlZmluZWQgaW4gdGhlIHNjaGVtYSBwYXRoLiBNYXkgYmUgaW4gYSBgVmFsaWRhdGlvbkVycm9yYCBjbGFzcycgYGVycm9yc2AgcHJvcGVydHkuXG4gKiAtIGBEaXZlcmdlbnRBcnJheUVycm9yYDogWW91IGF0dGVtcHRlZCB0byBgc2F2ZSgpYCBhbiBhcnJheSB0aGF0IHdhcyBtb2RpZmllZCBhZnRlciB5b3UgbG9hZGVkIGl0IHdpdGggYSBgJGVsZW1NYXRjaGAgb3Igc2ltaWxhciBwcm9qZWN0aW9uXG4gKiAtIGBNaXNzaW5nU2NoZW1hRXJyb3JgOiBZb3UgdHJpZWQgdG8gYWNjZXNzIGEgbW9kZWwgd2l0aCBbYG1vbmdvb3NlLm1vZGVsKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vbmdvb3NlLmh0bWwjTW9uZ29vc2UubW9kZWwoKSkgdGhhdCB3YXMgbm90IGRlZmluZWRcbiAqIC0gYERvY3VtZW50Tm90Rm91bmRFcnJvcmA6IFRoZSBkb2N1bWVudCB5b3UgdHJpZWQgdG8gW2BzYXZlKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLnNhdmUoKSkgd2FzIG5vdCBmb3VuZFxuICogLSBgVmFsaWRhdG9yRXJyb3JgOiBlcnJvciBmcm9tIGFuIGluZGl2aWR1YWwgc2NoZW1hIHBhdGgncyB2YWxpZGF0b3JcbiAqIC0gYFZhbGlkYXRpb25FcnJvcmA6IGVycm9yIHJldHVybmVkIGZyb20gW2B2YWxpZGF0ZSgpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS52YWxpZGF0ZSgpKSBvciBbYHZhbGlkYXRlU3luYygpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS52YWxpZGF0ZVN5bmMoKSkuIENvbnRhaW5zIHplcm8gb3IgbW9yZSBgVmFsaWRhdG9yRXJyb3JgIGluc3RhbmNlcyBpbiBgLmVycm9yc2AgcHJvcGVydHkuXG4gKiAtIGBNaXNzaW5nU2NoZW1hRXJyb3JgOiBZb3UgY2FsbGVkIGBtb25nb29zZS5Eb2N1bWVudCgpYCB3aXRob3V0IGEgc2NoZW1hXG4gKiAtIGBPYmplY3RFeHBlY3RlZEVycm9yYDogVGhyb3duIHdoZW4geW91IHNldCBhIG5lc3RlZCBwYXRoIHRvIGEgbm9uLW9iamVjdCB2YWx1ZSB3aXRoIFtzdHJpY3QgbW9kZSBzZXRdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdCkuXG4gKiAtIGBPYmplY3RQYXJhbWV0ZXJFcnJvcmA6IFRocm93biB3aGVuIHlvdSBwYXNzIGEgbm9uLW9iamVjdCB2YWx1ZSB0byBhIGZ1bmN0aW9uIHdoaWNoIGV4cGVjdHMgYW4gb2JqZWN0IGFzIGEgcGFyYW10ZXJcbiAqIC0gYE92ZXJ3cml0ZU1vZGVsRXJyb3JgOiBUaHJvd24gd2hlbiB5b3UgY2FsbCBbYG1vbmdvb3NlLm1vZGVsKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vbmdvb3NlLmh0bWwjTW9uZ29vc2UubW9kZWwoKSkgdG8gcmUtZGVmaW5lIGEgbW9kZWwgdGhhdCB3YXMgYWxyZWFkeSBkZWZpbmVkLlxuICogLSBgUGFyYWxsZWxTYXZlRXJyb3JgOiBUaHJvd24gd2hlbiB5b3UgY2FsbCBbYHNhdmUoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbC5wcm90b3R5cGUuc2F2ZSgpKSBvbiBhIGRvY3VtZW50IHdoZW4gdGhlIHNhbWUgZG9jdW1lbnQgaW5zdGFuY2UgaXMgYWxyZWFkeSBzYXZpbmcuXG4gKiAtIGBTdHJpY3RNb2RlRXJyb3JgOiBUaHJvd24gd2hlbiB5b3Ugc2V0IGEgcGF0aCB0aGF0IGlzbid0IHRoZSBzY2hlbWEgYW5kIFtzdHJpY3QgbW9kZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc3RyaWN0KSBpcyBzZXQgdG8gYHRocm93YC5cbiAqIC0gYFZlcnNpb25FcnJvcmA6IFRocm93biB3aGVuIHRoZSBbZG9jdW1lbnQgaXMgb3V0IG9mIHN5bmNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3ZlcnNpb25LZXkpXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBuYW1lXG4gKiBAbWVtYmVyT2YgRXJyb3JcbiAqIEBpbnN0YW5jZVxuICovXG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gTW9uZ29vc2VFcnJvcjtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBidWlsdC1pbiB2YWxpZGF0b3IgZXJyb3IgbWVzc2FnZXMuXG4gKlxuICogQHNlZSBFcnJvci5tZXNzYWdlcyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2Vycm9yLmh0bWwjRXJyb3IubWVzc2FnZXNcbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgRXJyb3JcbiAqIEBzdGF0aWNcbiAqL1xuXG5Nb25nb29zZUVycm9yLm1lc3NhZ2VzID0gcmVxdWlyZSgnLi9tZXNzYWdlcycpO1xuXG4vLyBiYWNrd2FyZCBjb21wYXRcbk1vbmdvb3NlRXJyb3IuTWVzc2FnZXMgPSBNb25nb29zZUVycm9yLm1lc3NhZ2VzO1xuXG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIHRoaXMgZXJyb3IgY2xhc3Mgd2lsbCBiZSByZXR1cm5lZCB3aGVuIGBzYXZlKClgIGZhaWxzXG4gKiBiZWNhdXNlIHRoZSB1bmRlcmx5aW5nXG4gKiBkb2N1bWVudCB3YXMgbm90IGZvdW5kLiBUaGUgY29uc3RydWN0b3IgdGFrZXMgb25lIHBhcmFtZXRlciwgdGhlXG4gKiBjb25kaXRpb25zIHRoYXQgbW9uZ29vc2UgcGFzc2VkIHRvIGB1cGRhdGVPbmUoKWAgd2hlbiB0cnlpbmcgdG8gdXBkYXRlXG4gKiB0aGUgZG9jdW1lbnQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBFcnJvclxuICogQHN0YXRpY1xuICovXG5cbk1vbmdvb3NlRXJyb3IuRG9jdW1lbnROb3RGb3VuZEVycm9yID0gcmVxdWlyZSgnLi9ub3RGb3VuZCcpO1xuXG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIHRoaXMgZXJyb3IgY2xhc3Mgd2lsbCBiZSByZXR1cm5lZCB3aGVuIG1vbmdvb3NlIGZhaWxlZCB0b1xuICogY2FzdCBhIHZhbHVlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgRXJyb3JcbiAqIEBzdGF0aWNcbiAqL1xuXG5Nb25nb29zZUVycm9yLkNhc3RFcnJvciA9IHJlcXVpcmUoJy4vY2FzdCcpO1xuXG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIHRoaXMgZXJyb3IgY2xhc3Mgd2lsbCBiZSByZXR1cm5lZCB3aGVuIFt2YWxpZGF0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdmFsaWRhdGlvbi5odG1sKSBmYWlsZWQuXG4gKiBUaGUgYGVycm9yc2AgcHJvcGVydHkgY29udGFpbnMgYW4gb2JqZWN0IHdob3NlIGtleXMgYXJlIHRoZSBwYXRocyB0aGF0IGZhaWxlZCBhbmQgd2hvc2UgdmFsdWVzIGFyZVxuICogaW5zdGFuY2VzIG9mIENhc3RFcnJvciBvciBWYWxpZGF0aW9uRXJyb3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBFcnJvclxuICogQHN0YXRpY1xuICovXG5cbk1vbmdvb3NlRXJyb3IuVmFsaWRhdGlvbkVycm9yID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XG5cbi8qKlxuICogQSBgVmFsaWRhdGlvbkVycm9yYCBoYXMgYSBoYXNoIG9mIGBlcnJvcnNgIHRoYXQgY29udGFpbiBpbmRpdmlkdWFsXG4gKiBgVmFsaWRhdG9yRXJyb3JgIGluc3RhbmNlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IFNjaGVtYSh7IG5hbWU6IHsgdHlwZTogU3RyaW5nLCByZXF1aXJlZDogdHJ1ZSB9IH0pO1xuICogICAgIGNvbnN0IE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBzY2hlbWEpO1xuICogICAgIGNvbnN0IGRvYyA9IG5ldyBNb2RlbCh7fSk7XG4gKlxuICogICAgIC8vIFRvcC1sZXZlbCBlcnJvciBpcyBhIFZhbGlkYXRpb25FcnJvciwgKipub3QqKiBhIFZhbGlkYXRvckVycm9yXG4gKiAgICAgY29uc3QgZXJyID0gZG9jLnZhbGlkYXRlU3luYygpO1xuICogICAgIGVyciBpbnN0YW5jZW9mIG1vbmdvb3NlLkVycm9yLlZhbGlkYXRpb25FcnJvcjsgLy8gdHJ1ZVxuICpcbiAqICAgICAvLyBBIFZhbGlkYXRpb25FcnJvciBgZXJyYCBoYXMgMCBvciBtb3JlIFZhbGlkYXRvckVycm9ycyBrZXllZCBieSB0aGVcbiAqICAgICAvLyBwYXRoIGluIHRoZSBgZXJyLmVycm9yc2AgcHJvcGVydHkuXG4gKiAgICAgZXJyLmVycm9yc1snbmFtZSddIGluc3RhbmNlb2YgbW9uZ29vc2UuRXJyb3IuVmFsaWRhdG9yRXJyb3I7XG4gKlxuICogICAgIGVyci5lcnJvcnNbJ25hbWUnXS5raW5kOyAvLyAncmVxdWlyZWQnXG4gKiAgICAgZXJyLmVycm9yc1snbmFtZSddLnBhdGg7IC8vICduYW1lJ1xuICogICAgIGVyci5lcnJvcnNbJ25hbWUnXS52YWx1ZTsgLy8gdW5kZWZpbmVkXG4gKlxuICogSW5zdGFuY2VzIG9mIGBWYWxpZGF0b3JFcnJvcmAgaGF2ZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogLSBga2luZGA6IFRoZSB2YWxpZGF0b3IncyBgdHlwZWAsIGxpa2UgYCdyZXF1aXJlZCdgIG9yIGAncmVnZXhwJ2BcbiAqIC0gYHBhdGhgOiBUaGUgcGF0aCB0aGF0IGZhaWxlZCB2YWxpZGF0aW9uXG4gKiAtIGB2YWx1ZWA6IFRoZSB2YWx1ZSB0aGF0IGZhaWxlZCB2YWxpZGF0aW9uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBFcnJvclxuICogQHN0YXRpY1xuICovXG5cbk1vbmdvb3NlRXJyb3IuVmFsaWRhdG9yRXJyb3IgPSByZXF1aXJlKCcuL3ZhbGlkYXRvcicpO1xuXG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIHRoaXMgZXJyb3IgY2xhc3Mgd2lsbCBiZSByZXR1cm5lZCB3aGVuIHlvdSBjYWxsIGBzYXZlKClgIGFmdGVyXG4gKiB0aGUgZG9jdW1lbnQgaW4gdGhlIGRhdGFiYXNlIHdhcyBjaGFuZ2VkIGluIGEgcG90ZW50aWFsbHkgdW5zYWZlIHdheS4gU2VlXG4gKiB0aGUgW2B2ZXJzaW9uS2V5YCBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3ZlcnNpb25LZXkpIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgRXJyb3JcbiAqIEBzdGF0aWNcbiAqL1xuXG5Nb25nb29zZUVycm9yLlZlcnNpb25FcnJvciA9IHJlcXVpcmUoJy4vdmVyc2lvbicpO1xuXG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIHRoaXMgZXJyb3IgY2xhc3Mgd2lsbCBiZSByZXR1cm5lZCB3aGVuIHlvdSBjYWxsIGBzYXZlKClgIG11bHRpcGxlXG4gKiB0aW1lcyBvbiB0aGUgc2FtZSBkb2N1bWVudCBpbiBwYXJhbGxlbC4gU2VlIHRoZSBbRkFRXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZmFxLmh0bWwpIGZvciBtb3JlXG4gKiBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIEVycm9yXG4gKiBAc3RhdGljXG4gKi9cblxuTW9uZ29vc2VFcnJvci5QYXJhbGxlbFNhdmVFcnJvciA9IHJlcXVpcmUoJy4vcGFyYWxsZWxTYXZlJyk7XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYSBtb2RlbCB3aXRoIHRoZSBnaXZlbiBuYW1lIHdhcyBhbHJlYWR5IHJlZ2lzdGVyZWQgb24gdGhlIGNvbm5lY3Rpb24uXG4gKiBTZWUgW3RoZSBGQVEgYWJvdXQgYE92ZXJ3cml0ZU1vZGVsRXJyb3JgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZmFxLmh0bWwjb3ZlcndyaXRlLW1vZGVsLWVycm9yKS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIEVycm9yXG4gKiBAc3RhdGljXG4gKi9cblxuTW9uZ29vc2VFcnJvci5PdmVyd3JpdGVNb2RlbEVycm9yID0gcmVxdWlyZSgnLi9vdmVyd3JpdGVNb2RlbCcpO1xuXG4vKipcbiAqIFRocm93biB3aGVuIHlvdSB0cnkgdG8gYWNjZXNzIGEgbW9kZWwgdGhhdCBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZCB5ZXRcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIEVycm9yXG4gKiBAc3RhdGljXG4gKi9cblxuTW9uZ29vc2VFcnJvci5NaXNzaW5nU2NoZW1hRXJyb3IgPSByZXF1aXJlKCcuL21pc3NpbmdTY2hlbWEnKTtcblxuLyoqXG4gKiBUaHJvd24gd2hlbiB0aGUgTW9uZ29EQiBOb2RlIGRyaXZlciBjYW4ndCBjb25uZWN0IHRvIGEgdmFsaWQgc2VydmVyXG4gKiB0byBzZW5kIGFuIG9wZXJhdGlvbiB0by5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIEVycm9yXG4gKiBAc3RhdGljXG4gKi9cblxuTW9uZ29vc2VFcnJvci5Nb25nb29zZVNlcnZlclNlbGVjdGlvbkVycm9yID0gcmVxdWlyZSgnLi9zZXJ2ZXJTZWxlY3Rpb24nKTtcblxuLyoqXG4gKiBBbiBpbnN0YW5jZSBvZiB0aGlzIGVycm9yIHdpbGwgYmUgcmV0dXJuZWQgaWYgeW91IHVzZWQgYW4gYXJyYXkgcHJvamVjdGlvblxuICogYW5kIHRoZW4gbW9kaWZpZWQgdGhlIGFycmF5IGluIGFuIHVuc2FmZSB3YXkuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBFcnJvclxuICogQHN0YXRpY1xuICovXG5cbk1vbmdvb3NlRXJyb3IuRGl2ZXJnZW50QXJyYXlFcnJvciA9IHJlcXVpcmUoJy4vZGl2ZXJnZW50QXJyYXknKTtcblxuLyoqXG4gKiBUaHJvd24gd2hlbiB5b3VyIHRyeSB0byBwYXNzIHZhbHVlcyB0byBtb2RlbCBjb25zdHJ1Y3RvciB0aGF0XG4gKiB3ZXJlIG5vdCBzcGVjaWZpZWQgaW4gc2NoZW1hIG9yIGNoYW5nZSBpbW11dGFibGUgcHJvcGVydGllcyB3aGVuXG4gKiBgc3RyaWN0YCBtb2RlIGlzIGBcInRocm93XCJgXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBFcnJvclxuICogQHN0YXRpY1xuICovXG5cbk1vbmdvb3NlRXJyb3IuU3RyaWN0TW9kZUVycm9yID0gcmVxdWlyZSgnLi9zdHJpY3QnKTtcblxuLyoqXG4gKiBBbiBpbnN0YW5jZSBvZiB0aGlzIGVycm9yIGNsYXNzIHdpbGwgYmUgcmV0dXJuZWQgd2hlbiBtb25nb29zZSBmYWlsZWQgdG9cbiAqIHBvcHVsYXRlIHdpdGggYSBwYXRoIHRoYXQgaXMgbm90IGV4aXN0aW5nLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgRXJyb3JcbiAqIEBzdGF0aWNcbiAqL1xuXG5Nb25nb29zZUVycm9yLlN0cmljdFBvcHVsYXRlRXJyb3IgPSByZXF1aXJlKCcuL3N0cmljdFBvcHVsYXRlJyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/error/index.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/error/invalidSchemaOption.js":
/*!*************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/error/invalidSchemaOption.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"../backend/node_modules/mongoose/lib/error/index.js\");\n\nclass InvalidSchemaOptionError extends MongooseError {\n  /**\n   * InvalidSchemaOption Error constructor.\n   * @param {String} name\n   * @api private\n   */\n  constructor(name, option) {\n    const msg = `Cannot create use schema for property \"${name}\" because the schema has the ${option} option enabled.`;\n    super(msg);\n  }\n}\n\nObject.defineProperty(InvalidSchemaOptionError.prototype, 'name', {\n  value: 'InvalidSchemaOptionError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = InvalidSchemaOptionError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL2ludmFsaWRTY2hlbWFPcHRpb24uanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQywrREFBSTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxLQUFLLCtCQUErQixRQUFRO0FBQ3RHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvaW52YWxpZFNjaGVtYU9wdGlvbi5qcz9lNzAyIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vJyk7XG5cbmNsYXNzIEludmFsaWRTY2hlbWFPcHRpb25FcnJvciBleHRlbmRzIE1vbmdvb3NlRXJyb3Ige1xuICAvKipcbiAgICogSW52YWxpZFNjaGVtYU9wdGlvbiBFcnJvciBjb25zdHJ1Y3Rvci5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihuYW1lLCBvcHRpb24pIHtcbiAgICBjb25zdCBtc2cgPSBgQ2Fubm90IGNyZWF0ZSB1c2Ugc2NoZW1hIGZvciBwcm9wZXJ0eSBcIiR7bmFtZX1cIiBiZWNhdXNlIHRoZSBzY2hlbWEgaGFzIHRoZSAke29wdGlvbn0gb3B0aW9uIGVuYWJsZWQuYDtcbiAgICBzdXBlcihtc2cpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnZhbGlkU2NoZW1hT3B0aW9uRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdJbnZhbGlkU2NoZW1hT3B0aW9uRXJyb3InXG59KTtcblxuLyohXG4gKiBleHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBJbnZhbGlkU2NoZW1hT3B0aW9uRXJyb3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/error/invalidSchemaOption.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/error/messages.js":
/*!**************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/error/messages.js ***!
  \**************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\n/**\n * The default built-in validator error messages. These may be customized.\n *\n *     // customize within each schema or globally like so\n *     const mongoose = require('mongoose');\n *     mongoose.Error.messages.String.enum  = \"Your custom message for {PATH}.\";\n *\n * Error messages support basic templating. Mongoose will replace the following strings with the corresponding value.\n *\n * - `{PATH}` is replaced with the invalid document path\n * - `{VALUE}` is replaced with the invalid value\n * - `{TYPE}` is replaced with the validator type such as \"regexp\", \"min\", or \"user defined\"\n * - `{MIN}` is replaced with the declared min value for the Number.min validator\n * - `{MAX}` is replaced with the declared max value for the Number.max validator\n *\n * Click the \"show code\" link below to see all defaults.\n *\n * @static\n * @memberOf MongooseError\n * @api public\n */\n\n\n\nconst msg = module.exports = exports = {};\n\nmsg.DocumentNotFoundError = null;\n\nmsg.general = {};\nmsg.general.default = 'Validator failed for path `{PATH}` with value `{VALUE}`';\nmsg.general.required = 'Path `{PATH}` is required.';\n\nmsg.Number = {};\nmsg.Number.min = 'Path `{PATH}` ({VALUE}) is less than minimum allowed value ({MIN}).';\nmsg.Number.max = 'Path `{PATH}` ({VALUE}) is more than maximum allowed value ({MAX}).';\nmsg.Number.enum = '`{VALUE}` is not a valid enum value for path `{PATH}`.';\n\nmsg.Date = {};\nmsg.Date.min = 'Path `{PATH}` ({VALUE}) is before minimum allowed value ({MIN}).';\nmsg.Date.max = 'Path `{PATH}` ({VALUE}) is after maximum allowed value ({MAX}).';\n\nmsg.String = {};\nmsg.String.enum = '`{VALUE}` is not a valid enum value for path `{PATH}`.';\nmsg.String.match = 'Path `{PATH}` is invalid ({VALUE}).';\nmsg.String.minlength = 'Path `{PATH}` (`{VALUE}`) is shorter than the minimum allowed length ({MINLENGTH}).';\nmsg.String.maxlength = 'Path `{PATH}` (`{VALUE}`) is longer than the maximum allowed length ({MAXLENGTH}).';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL21lc3NhZ2VzLmpzIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLEtBQUs7QUFDN0U7QUFDQTtBQUNBO0FBQ0EsT0FBTyxLQUFLO0FBQ1osT0FBTyxNQUFNO0FBQ2IsT0FBTyxLQUFLO0FBQ1osT0FBTyxJQUFJO0FBQ1gsT0FBTyxJQUFJO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUE7O0FBRUE7QUFDQSxtREFBbUQsS0FBSyxlQUFlLE1BQU07QUFDN0UsK0JBQStCLEtBQUs7O0FBRXBDO0FBQ0EseUJBQXlCLEtBQUssSUFBSSxNQUFNLHVDQUF1QyxJQUFJO0FBQ25GLHlCQUF5QixLQUFLLElBQUksTUFBTSx1Q0FBdUMsSUFBSTtBQUNuRixxQkFBcUIsTUFBTSx1Q0FBdUMsS0FBSzs7QUFFdkU7QUFDQSx1QkFBdUIsS0FBSyxJQUFJLE1BQU0sb0NBQW9DLElBQUk7QUFDOUUsdUJBQXVCLEtBQUssSUFBSSxNQUFNLG1DQUFtQyxJQUFJOztBQUU3RTtBQUNBLHFCQUFxQixNQUFNLHVDQUF1QyxLQUFLO0FBQ3ZFLDJCQUEyQixLQUFLLGVBQWUsTUFBTTtBQUNyRCwrQkFBK0IsS0FBSyxLQUFLLE1BQU0sZ0RBQWdELFVBQVU7QUFDekcsK0JBQStCLEtBQUssS0FBSyxNQUFNLCtDQUErQyxVQUFVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL21lc3NhZ2VzLmpzPzU5YzEiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIFRoZSBkZWZhdWx0IGJ1aWx0LWluIHZhbGlkYXRvciBlcnJvciBtZXNzYWdlcy4gVGhlc2UgbWF5IGJlIGN1c3RvbWl6ZWQuXG4gKlxuICogICAgIC8vIGN1c3RvbWl6ZSB3aXRoaW4gZWFjaCBzY2hlbWEgb3IgZ2xvYmFsbHkgbGlrZSBzb1xuICogICAgIGNvbnN0IG1vbmdvb3NlID0gcmVxdWlyZSgnbW9uZ29vc2UnKTtcbiAqICAgICBtb25nb29zZS5FcnJvci5tZXNzYWdlcy5TdHJpbmcuZW51bSAgPSBcIllvdXIgY3VzdG9tIG1lc3NhZ2UgZm9yIHtQQVRIfS5cIjtcbiAqXG4gKiBFcnJvciBtZXNzYWdlcyBzdXBwb3J0IGJhc2ljIHRlbXBsYXRpbmcuIE1vbmdvb3NlIHdpbGwgcmVwbGFjZSB0aGUgZm9sbG93aW5nIHN0cmluZ3Mgd2l0aCB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZS5cbiAqXG4gKiAtIGB7UEFUSH1gIGlzIHJlcGxhY2VkIHdpdGggdGhlIGludmFsaWQgZG9jdW1lbnQgcGF0aFxuICogLSBge1ZBTFVFfWAgaXMgcmVwbGFjZWQgd2l0aCB0aGUgaW52YWxpZCB2YWx1ZVxuICogLSBge1RZUEV9YCBpcyByZXBsYWNlZCB3aXRoIHRoZSB2YWxpZGF0b3IgdHlwZSBzdWNoIGFzIFwicmVnZXhwXCIsIFwibWluXCIsIG9yIFwidXNlciBkZWZpbmVkXCJcbiAqIC0gYHtNSU59YCBpcyByZXBsYWNlZCB3aXRoIHRoZSBkZWNsYXJlZCBtaW4gdmFsdWUgZm9yIHRoZSBOdW1iZXIubWluIHZhbGlkYXRvclxuICogLSBge01BWH1gIGlzIHJlcGxhY2VkIHdpdGggdGhlIGRlY2xhcmVkIG1heCB2YWx1ZSBmb3IgdGhlIE51bWJlci5tYXggdmFsaWRhdG9yXG4gKlxuICogQ2xpY2sgdGhlIFwic2hvdyBjb2RlXCIgbGluayBiZWxvdyB0byBzZWUgYWxsIGRlZmF1bHRzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBNb25nb29zZUVycm9yXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgbXNnID0gbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0ge307XG5cbm1zZy5Eb2N1bWVudE5vdEZvdW5kRXJyb3IgPSBudWxsO1xuXG5tc2cuZ2VuZXJhbCA9IHt9O1xubXNnLmdlbmVyYWwuZGVmYXVsdCA9ICdWYWxpZGF0b3IgZmFpbGVkIGZvciBwYXRoIGB7UEFUSH1gIHdpdGggdmFsdWUgYHtWQUxVRX1gJztcbm1zZy5nZW5lcmFsLnJlcXVpcmVkID0gJ1BhdGggYHtQQVRIfWAgaXMgcmVxdWlyZWQuJztcblxubXNnLk51bWJlciA9IHt9O1xubXNnLk51bWJlci5taW4gPSAnUGF0aCBge1BBVEh9YCAoe1ZBTFVFfSkgaXMgbGVzcyB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZSAoe01JTn0pLic7XG5tc2cuTnVtYmVyLm1heCA9ICdQYXRoIGB7UEFUSH1gICh7VkFMVUV9KSBpcyBtb3JlIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlICh7TUFYfSkuJztcbm1zZy5OdW1iZXIuZW51bSA9ICdge1ZBTFVFfWAgaXMgbm90IGEgdmFsaWQgZW51bSB2YWx1ZSBmb3IgcGF0aCBge1BBVEh9YC4nO1xuXG5tc2cuRGF0ZSA9IHt9O1xubXNnLkRhdGUubWluID0gJ1BhdGggYHtQQVRIfWAgKHtWQUxVRX0pIGlzIGJlZm9yZSBtaW5pbXVtIGFsbG93ZWQgdmFsdWUgKHtNSU59KS4nO1xubXNnLkRhdGUubWF4ID0gJ1BhdGggYHtQQVRIfWAgKHtWQUxVRX0pIGlzIGFmdGVyIG1heGltdW0gYWxsb3dlZCB2YWx1ZSAoe01BWH0pLic7XG5cbm1zZy5TdHJpbmcgPSB7fTtcbm1zZy5TdHJpbmcuZW51bSA9ICdge1ZBTFVFfWAgaXMgbm90IGEgdmFsaWQgZW51bSB2YWx1ZSBmb3IgcGF0aCBge1BBVEh9YC4nO1xubXNnLlN0cmluZy5tYXRjaCA9ICdQYXRoIGB7UEFUSH1gIGlzIGludmFsaWQgKHtWQUxVRX0pLic7XG5tc2cuU3RyaW5nLm1pbmxlbmd0aCA9ICdQYXRoIGB7UEFUSH1gIChge1ZBTFVFfWApIGlzIHNob3J0ZXIgdGhhbiB0aGUgbWluaW11bSBhbGxvd2VkIGxlbmd0aCAoe01JTkxFTkdUSH0pLic7XG5tc2cuU3RyaW5nLm1heGxlbmd0aCA9ICdQYXRoIGB7UEFUSH1gIChge1ZBTFVFfWApIGlzIGxvbmdlciB0aGFuIHRoZSBtYXhpbXVtIGFsbG93ZWQgbGVuZ3RoICh7TUFYTEVOR1RIfSkuJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/error/messages.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/error/missingSchema.js":
/*!*******************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/error/missingSchema.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"../backend/node_modules/mongoose/lib/error/index.js\");\n\nclass MissingSchemaError extends MongooseError {\n  /**\n   * MissingSchema Error constructor.\n   * @param {String} name\n   * @api private\n   */\n  constructor(name) {\n    const msg = 'Schema hasn\\'t been registered for model \"' + name + '\".\\n'\n            + 'Use mongoose.model(name, schema)';\n    super(msg);\n  }\n}\n\nObject.defineProperty(MissingSchemaError.prototype, 'name', {\n  value: 'MissingSchemaError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = MissingSchemaError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL21pc3NpbmdTY2hlbWEuanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQywrREFBSTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL21pc3NpbmdTY2hlbWEuanM/MjI2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLycpO1xuXG5jbGFzcyBNaXNzaW5nU2NoZW1hRXJyb3IgZXh0ZW5kcyBNb25nb29zZUVycm9yIHtcbiAgLyoqXG4gICAqIE1pc3NpbmdTY2hlbWEgRXJyb3IgY29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IobmFtZSkge1xuICAgIGNvbnN0IG1zZyA9ICdTY2hlbWEgaGFzblxcJ3QgYmVlbiByZWdpc3RlcmVkIGZvciBtb2RlbCBcIicgKyBuYW1lICsgJ1wiLlxcbidcbiAgICAgICAgICAgICsgJ1VzZSBtb25nb29zZS5tb2RlbChuYW1lLCBzY2hlbWEpJztcbiAgICBzdXBlcihtc2cpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNaXNzaW5nU2NoZW1hRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdNaXNzaW5nU2NoZW1hRXJyb3InXG59KTtcblxuLyohXG4gKiBleHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBNaXNzaW5nU2NoZW1hRXJyb3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/error/missingSchema.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/error/mongooseError.js":
/*!*******************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/error/mongooseError.js ***!
  \*******************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nclass MongooseError extends Error { }\n\nObject.defineProperty(MongooseError.prototype, 'name', {\n  value: 'MongooseError'\n});\n\nmodule.exports = MongooseError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL21vbmdvb3NlRXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL21vbmdvb3NlRXJyb3IuanM/YjExMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuY2xhc3MgTW9uZ29vc2VFcnJvciBleHRlbmRzIEVycm9yIHsgfVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTW9uZ29vc2VFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ01vbmdvb3NlRXJyb3InXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBNb25nb29zZUVycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/error/mongooseError.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/error/notFound.js":
/*!**************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/error/notFound.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"../backend/node_modules/mongoose/lib/error/index.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\nclass DocumentNotFoundError extends MongooseError {\n  /**\n   * OverwriteModel Error constructor.\n   * @api private\n   */\n  constructor(filter, model, numAffected, result) {\n    let msg;\n    const messages = MongooseError.messages;\n    if (messages.DocumentNotFoundError != null) {\n      msg = typeof messages.DocumentNotFoundError === 'function' ?\n        messages.DocumentNotFoundError(filter, model) :\n        messages.DocumentNotFoundError;\n    } else {\n      msg = 'No document found for query \"' + util.inspect(filter) +\n        '\" on model \"' + model + '\"';\n    }\n\n    super(msg);\n\n    this.result = result;\n    this.numAffected = numAffected;\n    this.filter = filter;\n    // Backwards compat\n    this.query = filter;\n  }\n}\n\nObject.defineProperty(DocumentNotFoundError.prototype, 'name', {\n  value: 'DocumentNotFoundError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = DocumentNotFoundError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL25vdEZvdW5kLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsbUJBQU8sQ0FBQywrREFBSTtBQUNsQyxhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL25vdEZvdW5kLmpzP2Y5YTYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5jbGFzcyBEb2N1bWVudE5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBNb25nb29zZUVycm9yIHtcbiAgLyoqXG4gICAqIE92ZXJ3cml0ZU1vZGVsIEVycm9yIGNvbnN0cnVjdG9yLlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGZpbHRlciwgbW9kZWwsIG51bUFmZmVjdGVkLCByZXN1bHQpIHtcbiAgICBsZXQgbXNnO1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gTW9uZ29vc2VFcnJvci5tZXNzYWdlcztcbiAgICBpZiAobWVzc2FnZXMuRG9jdW1lbnROb3RGb3VuZEVycm9yICE9IG51bGwpIHtcbiAgICAgIG1zZyA9IHR5cGVvZiBtZXNzYWdlcy5Eb2N1bWVudE5vdEZvdW5kRXJyb3IgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICBtZXNzYWdlcy5Eb2N1bWVudE5vdEZvdW5kRXJyb3IoZmlsdGVyLCBtb2RlbCkgOlxuICAgICAgICBtZXNzYWdlcy5Eb2N1bWVudE5vdEZvdW5kRXJyb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1zZyA9ICdObyBkb2N1bWVudCBmb3VuZCBmb3IgcXVlcnkgXCInICsgdXRpbC5pbnNwZWN0KGZpbHRlcikgK1xuICAgICAgICAnXCIgb24gbW9kZWwgXCInICsgbW9kZWwgKyAnXCInO1xuICAgIH1cblxuICAgIHN1cGVyKG1zZyk7XG5cbiAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICB0aGlzLm51bUFmZmVjdGVkID0gbnVtQWZmZWN0ZWQ7XG4gICAgdGhpcy5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgLy8gQmFja3dhcmRzIGNvbXBhdFxuICAgIHRoaXMucXVlcnkgPSBmaWx0ZXI7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KERvY3VtZW50Tm90Rm91bmRFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ0RvY3VtZW50Tm90Rm91bmRFcnJvcidcbn0pO1xuXG4vKiFcbiAqIGV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IERvY3VtZW50Tm90Rm91bmRFcnJvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/error/notFound.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/error/objectExpected.js":
/*!********************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/error/objectExpected.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"../backend/node_modules/mongoose/lib/error/index.js\");\n\n\nclass ObjectExpectedError extends MongooseError {\n  /**\n   * Strict mode error constructor\n   *\n   * @param {string} type\n   * @param {string} value\n   * @api private\n   */\n  constructor(path, val) {\n    const typeDescription = Array.isArray(val) ? 'array' : 'primitive value';\n    super('Tried to set nested object field `' + path +\n      `\\` to ${typeDescription} \\`` + val + '`');\n    this.path = path;\n  }\n}\n\nObject.defineProperty(ObjectExpectedError.prototype, 'name', {\n  value: 'ObjectExpectedError'\n});\n\nmodule.exports = ObjectExpectedError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL29iamVjdEV4cGVjdGVkLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQywrREFBSTs7O0FBR2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL29iamVjdEV4cGVjdGVkLmpzPzliMjgiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vJyk7XG5cblxuY2xhc3MgT2JqZWN0RXhwZWN0ZWRFcnJvciBleHRlbmRzIE1vbmdvb3NlRXJyb3Ige1xuICAvKipcbiAgICogU3RyaWN0IG1vZGUgZXJyb3IgY29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IocGF0aCwgdmFsKSB7XG4gICAgY29uc3QgdHlwZURlc2NyaXB0aW9uID0gQXJyYXkuaXNBcnJheSh2YWwpID8gJ2FycmF5JyA6ICdwcmltaXRpdmUgdmFsdWUnO1xuICAgIHN1cGVyKCdUcmllZCB0byBzZXQgbmVzdGVkIG9iamVjdCBmaWVsZCBgJyArIHBhdGggK1xuICAgICAgYFxcYCB0byAke3R5cGVEZXNjcmlwdGlvbn0gXFxgYCArIHZhbCArICdgJyk7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0RXhwZWN0ZWRFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ09iamVjdEV4cGVjdGVkRXJyb3InXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3RFeHBlY3RlZEVycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/error/objectExpected.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/error/objectParameter.js":
/*!*********************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/error/objectParameter.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"../backend/node_modules/mongoose/lib/error/index.js\");\n\nclass ObjectParameterError extends MongooseError {\n  /**\n   * Constructor for errors that happen when a parameter that's expected to be\n   * an object isn't an object\n   *\n   * @param {Any} value\n   * @param {String} paramName\n   * @param {String} fnName\n   * @api private\n   */\n  constructor(value, paramName, fnName) {\n    super('Parameter \"' + paramName + '\" to ' + fnName +\n      '() must be an object, got \"' + value.toString() + '\" (type ' + typeof value + ')');\n  }\n}\n\n\nObject.defineProperty(ObjectParameterError.prototype, 'name', {\n  value: 'ObjectParameterError'\n});\n\nmodule.exports = ObjectParameterError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL29iamVjdFBhcmFtZXRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsK0RBQUk7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3Ivb2JqZWN0UGFyYW1ldGVyLmpzPzQyZGEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vJyk7XG5cbmNsYXNzIE9iamVjdFBhcmFtZXRlckVycm9yIGV4dGVuZHMgTW9uZ29vc2VFcnJvciB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvciBmb3IgZXJyb3JzIHRoYXQgaGFwcGVuIHdoZW4gYSBwYXJhbWV0ZXIgdGhhdCdzIGV4cGVjdGVkIHRvIGJlXG4gICAqIGFuIG9iamVjdCBpc24ndCBhbiBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtBbnl9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbU5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZuTmFtZVxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBwYXJhbU5hbWUsIGZuTmFtZSkge1xuICAgIHN1cGVyKCdQYXJhbWV0ZXIgXCInICsgcGFyYW1OYW1lICsgJ1wiIHRvICcgKyBmbk5hbWUgK1xuICAgICAgJygpIG11c3QgYmUgYW4gb2JqZWN0LCBnb3QgXCInICsgdmFsdWUudG9TdHJpbmcoKSArICdcIiAodHlwZSAnICsgdHlwZW9mIHZhbHVlICsgJyknKTtcbiAgfVxufVxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3RQYXJhbWV0ZXJFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ09iamVjdFBhcmFtZXRlckVycm9yJ1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0UGFyYW1ldGVyRXJyb3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/error/objectParameter.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/error/overwriteModel.js":
/*!********************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/error/overwriteModel.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"../backend/node_modules/mongoose/lib/error/index.js\");\n\n\nclass OverwriteModelError extends MongooseError {\n  /**\n   * OverwriteModel Error constructor.\n   * @param {String} name\n   * @api private\n   */\n  constructor(name) {\n    super('Cannot overwrite `' + name + '` model once compiled.');\n  }\n}\n\nObject.defineProperty(OverwriteModelError.prototype, 'name', {\n  value: 'OverwriteModelError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = OverwriteModelError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL292ZXJ3cml0ZU1vZGVsLmpzIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsK0RBQUk7OztBQUdsQztBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9lcnJvci9vdmVyd3JpdGVNb2RlbC5qcz9jYWVkIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vJyk7XG5cblxuY2xhc3MgT3ZlcndyaXRlTW9kZWxFcnJvciBleHRlbmRzIE1vbmdvb3NlRXJyb3Ige1xuICAvKipcbiAgICogT3ZlcndyaXRlTW9kZWwgRXJyb3IgY29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IobmFtZSkge1xuICAgIHN1cGVyKCdDYW5ub3Qgb3ZlcndyaXRlIGAnICsgbmFtZSArICdgIG1vZGVsIG9uY2UgY29tcGlsZWQuJyk7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE92ZXJ3cml0ZU1vZGVsRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdPdmVyd3JpdGVNb2RlbEVycm9yJ1xufSk7XG5cbi8qIVxuICogZXhwb3J0c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gT3ZlcndyaXRlTW9kZWxFcnJvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/error/overwriteModel.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/error/parallelSave.js":
/*!******************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/error/parallelSave.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"../backend/node_modules/mongoose/lib/error/index.js\");\n\nclass ParallelSaveError extends MongooseError {\n  /**\n   * ParallelSave Error constructor.\n   *\n   * @param {Document} doc\n   * @api private\n   */\n  constructor(doc) {\n    const msg = 'Can\\'t save() the same doc multiple times in parallel. Document: ';\n    super(msg + doc._id);\n  }\n}\n\nObject.defineProperty(ParallelSaveError.prototype, 'name', {\n  value: 'ParallelSaveError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = ParallelSaveError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL3BhcmFsbGVsU2F2ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLG1CQUFPLENBQUMsK0RBQUk7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9lcnJvci9wYXJhbGxlbFNhdmUuanM/NGViYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi8nKTtcblxuY2xhc3MgUGFyYWxsZWxTYXZlRXJyb3IgZXh0ZW5kcyBNb25nb29zZUVycm9yIHtcbiAgLyoqXG4gICAqIFBhcmFsbGVsU2F2ZSBFcnJvciBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHtEb2N1bWVudH0gZG9jXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IoZG9jKSB7XG4gICAgY29uc3QgbXNnID0gJ0NhblxcJ3Qgc2F2ZSgpIHRoZSBzYW1lIGRvYyBtdWx0aXBsZSB0aW1lcyBpbiBwYXJhbGxlbC4gRG9jdW1lbnQ6ICc7XG4gICAgc3VwZXIobXNnICsgZG9jLl9pZCk7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBhcmFsbGVsU2F2ZUVycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnUGFyYWxsZWxTYXZlRXJyb3InXG59KTtcblxuLyohXG4gKiBleHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBQYXJhbGxlbFNhdmVFcnJvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/error/parallelSave.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/error/parallelValidate.js":
/*!**********************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/error/parallelValidate.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseError = __webpack_require__(/*! ./mongooseError */ \"../backend/node_modules/mongoose/lib/error/mongooseError.js\");\n\n\nclass ParallelValidateError extends MongooseError {\n  /**\n   * ParallelValidate Error constructor.\n   *\n   * @param {Document} doc\n   * @api private\n   */\n  constructor(doc) {\n    const msg = 'Can\\'t validate() the same doc multiple times in parallel. Document: ';\n    super(msg + doc._id);\n  }\n}\n\nObject.defineProperty(ParallelValidateError.prototype, 'name', {\n  value: 'ParallelValidateError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = ParallelValidateError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL3BhcmFsbGVsVmFsaWRhdGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixtQkFBTyxDQUFDLG9GQUFpQjs7O0FBRy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9lcnJvci9wYXJhbGxlbFZhbGlkYXRlLmpzPzBmYmIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vbW9uZ29vc2VFcnJvcicpO1xuXG5cbmNsYXNzIFBhcmFsbGVsVmFsaWRhdGVFcnJvciBleHRlbmRzIE1vbmdvb3NlRXJyb3Ige1xuICAvKipcbiAgICogUGFyYWxsZWxWYWxpZGF0ZSBFcnJvciBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHtEb2N1bWVudH0gZG9jXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IoZG9jKSB7XG4gICAgY29uc3QgbXNnID0gJ0NhblxcJ3QgdmFsaWRhdGUoKSB0aGUgc2FtZSBkb2MgbXVsdGlwbGUgdGltZXMgaW4gcGFyYWxsZWwuIERvY3VtZW50OiAnO1xuICAgIHN1cGVyKG1zZyArIGRvYy5faWQpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYXJhbGxlbFZhbGlkYXRlRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdQYXJhbGxlbFZhbGlkYXRlRXJyb3InXG59KTtcblxuLyohXG4gKiBleHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBQYXJhbGxlbFZhbGlkYXRlRXJyb3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/error/parallelValidate.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/error/serverSelection.js":
/*!*********************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/error/serverSelection.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./mongooseError */ \"../backend/node_modules/mongoose/lib/error/mongooseError.js\");\nconst allServersUnknown = __webpack_require__(/*! ../helpers/topology/allServersUnknown */ \"../backend/node_modules/mongoose/lib/helpers/topology/allServersUnknown.js\");\nconst isAtlas = __webpack_require__(/*! ../helpers/topology/isAtlas */ \"../backend/node_modules/mongoose/lib/helpers/topology/isAtlas.js\");\nconst isSSLError = __webpack_require__(/*! ../helpers/topology/isSSLError */ \"../backend/node_modules/mongoose/lib/helpers/topology/isSSLError.js\");\n\n/*!\n * ignore\n */\n\nconst atlasMessage = 'Could not connect to any servers in your MongoDB Atlas cluster. ' +\n  'One common reason is that you\\'re trying to access the database from ' +\n  'an IP that isn\\'t whitelisted. Make sure your current IP address is on your Atlas ' +\n  'cluster\\'s IP whitelist: https://www.mongodb.com/docs/atlas/security-whitelist/';\n\nconst sslMessage = 'Mongoose is connecting with SSL enabled, but the server is ' +\n  'not accepting SSL connections. Please ensure that the MongoDB server you are ' +\n  'connecting to is configured to accept SSL connections. Learn more: ' +\n  'https://mongoosejs.com/docs/tutorials/ssl.html';\n\nclass MongooseServerSelectionError extends MongooseError {\n  /**\n   * MongooseServerSelectionError constructor\n   *\n   * @api private\n   */\n  assimilateError(err) {\n    const reason = err.reason;\n    // Special message for a case that is likely due to IP whitelisting issues.\n    const isAtlasWhitelistError = isAtlas(reason) &&\n      allServersUnknown(reason) &&\n      err.message.indexOf('bad auth') === -1 &&\n      err.message.indexOf('Authentication failed') === -1;\n\n    if (isAtlasWhitelistError) {\n      this.message = atlasMessage;\n    } else if (isSSLError(reason)) {\n      this.message = sslMessage;\n    } else {\n      this.message = err.message;\n    }\n    for (const key in err) {\n      if (key !== 'name') {\n        this[key] = err[key];\n      }\n    }\n\n    return this;\n  }\n}\n\nObject.defineProperty(MongooseServerSelectionError.prototype, 'name', {\n  value: 'MongooseServerSelectionError'\n});\n\nmodule.exports = MongooseServerSelectionError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL3NlcnZlclNlbGVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsb0ZBQWlCO0FBQy9DLDBCQUEwQixtQkFBTyxDQUFDLHlIQUF1QztBQUN6RSxnQkFBZ0IsbUJBQU8sQ0FBQyxxR0FBNkI7QUFDckQsbUJBQW1CLG1CQUFPLENBQUMsMkdBQWdDOztBQUUzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3Ivc2VydmVyU2VsZWN0aW9uLmpzP2M4NzAiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vbW9uZ29vc2VFcnJvcicpO1xuY29uc3QgYWxsU2VydmVyc1Vua25vd24gPSByZXF1aXJlKCcuLi9oZWxwZXJzL3RvcG9sb2d5L2FsbFNlcnZlcnNVbmtub3duJyk7XG5jb25zdCBpc0F0bGFzID0gcmVxdWlyZSgnLi4vaGVscGVycy90b3BvbG9neS9pc0F0bGFzJyk7XG5jb25zdCBpc1NTTEVycm9yID0gcmVxdWlyZSgnLi4vaGVscGVycy90b3BvbG9neS9pc1NTTEVycm9yJyk7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuY29uc3QgYXRsYXNNZXNzYWdlID0gJ0NvdWxkIG5vdCBjb25uZWN0IHRvIGFueSBzZXJ2ZXJzIGluIHlvdXIgTW9uZ29EQiBBdGxhcyBjbHVzdGVyLiAnICtcbiAgJ09uZSBjb21tb24gcmVhc29uIGlzIHRoYXQgeW91XFwncmUgdHJ5aW5nIHRvIGFjY2VzcyB0aGUgZGF0YWJhc2UgZnJvbSAnICtcbiAgJ2FuIElQIHRoYXQgaXNuXFwndCB3aGl0ZWxpc3RlZC4gTWFrZSBzdXJlIHlvdXIgY3VycmVudCBJUCBhZGRyZXNzIGlzIG9uIHlvdXIgQXRsYXMgJyArXG4gICdjbHVzdGVyXFwncyBJUCB3aGl0ZWxpc3Q6IGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvYXRsYXMvc2VjdXJpdHktd2hpdGVsaXN0Lyc7XG5cbmNvbnN0IHNzbE1lc3NhZ2UgPSAnTW9uZ29vc2UgaXMgY29ubmVjdGluZyB3aXRoIFNTTCBlbmFibGVkLCBidXQgdGhlIHNlcnZlciBpcyAnICtcbiAgJ25vdCBhY2NlcHRpbmcgU1NMIGNvbm5lY3Rpb25zLiBQbGVhc2UgZW5zdXJlIHRoYXQgdGhlIE1vbmdvREIgc2VydmVyIHlvdSBhcmUgJyArXG4gICdjb25uZWN0aW5nIHRvIGlzIGNvbmZpZ3VyZWQgdG8gYWNjZXB0IFNTTCBjb25uZWN0aW9ucy4gTGVhcm4gbW9yZTogJyArXG4gICdodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHV0b3JpYWxzL3NzbC5odG1sJztcblxuY2xhc3MgTW9uZ29vc2VTZXJ2ZXJTZWxlY3Rpb25FcnJvciBleHRlbmRzIE1vbmdvb3NlRXJyb3Ige1xuICAvKipcbiAgICogTW9uZ29vc2VTZXJ2ZXJTZWxlY3Rpb25FcnJvciBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGFzc2ltaWxhdGVFcnJvcihlcnIpIHtcbiAgICBjb25zdCByZWFzb24gPSBlcnIucmVhc29uO1xuICAgIC8vIFNwZWNpYWwgbWVzc2FnZSBmb3IgYSBjYXNlIHRoYXQgaXMgbGlrZWx5IGR1ZSB0byBJUCB3aGl0ZWxpc3RpbmcgaXNzdWVzLlxuICAgIGNvbnN0IGlzQXRsYXNXaGl0ZWxpc3RFcnJvciA9IGlzQXRsYXMocmVhc29uKSAmJlxuICAgICAgYWxsU2VydmVyc1Vua25vd24ocmVhc29uKSAmJlxuICAgICAgZXJyLm1lc3NhZ2UuaW5kZXhPZignYmFkIGF1dGgnKSA9PT0gLTEgJiZcbiAgICAgIGVyci5tZXNzYWdlLmluZGV4T2YoJ0F1dGhlbnRpY2F0aW9uIGZhaWxlZCcpID09PSAtMTtcblxuICAgIGlmIChpc0F0bGFzV2hpdGVsaXN0RXJyb3IpIHtcbiAgICAgIHRoaXMubWVzc2FnZSA9IGF0bGFzTWVzc2FnZTtcbiAgICB9IGVsc2UgaWYgKGlzU1NMRXJyb3IocmVhc29uKSkge1xuICAgICAgdGhpcy5tZXNzYWdlID0gc3NsTWVzc2FnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIGVycikge1xuICAgICAgaWYgKGtleSAhPT0gJ25hbWUnKSB7XG4gICAgICAgIHRoaXNba2V5XSA9IGVycltrZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb25nb29zZVNlcnZlclNlbGVjdGlvbkVycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnTW9uZ29vc2VTZXJ2ZXJTZWxlY3Rpb25FcnJvcidcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vbmdvb3NlU2VydmVyU2VsZWN0aW9uRXJyb3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/error/serverSelection.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/error/setOptionError.js":
/*!********************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/error/setOptionError.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module requirements\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./mongooseError */ \"../backend/node_modules/mongoose/lib/error/mongooseError.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst combinePathErrors = __webpack_require__(/*! ../helpers/error/combinePathErrors */ \"../backend/node_modules/mongoose/lib/helpers/error/combinePathErrors.js\");\n\nclass SetOptionError extends MongooseError {\n  /**\n   * Mongoose.set Error\n   *\n   * @api private\n   * @inherits MongooseError\n   */\n  constructor() {\n    super('');\n\n    this.errors = {};\n  }\n\n  /**\n   * Console.log helper\n   */\n  toString() {\n    return combinePathErrors(this);\n  }\n\n  /**\n   * inspect helper\n   * @api private\n   */\n  inspect() {\n    return Object.assign(new Error(this.message), this);\n  }\n\n  /**\n  * add message\n  * @param {String} key\n  * @param {String|Error} error\n  * @api private\n  */\n  addError(key, error) {\n    if (error instanceof SetOptionError) {\n      const { errors } = error;\n      for (const optionKey of Object.keys(errors)) {\n        this.addError(optionKey, errors[optionKey]);\n      }\n\n      return;\n    }\n\n    this.errors[key] = error;\n    this.message = combinePathErrors(this);\n  }\n}\n\n\nif (util.inspect.custom) {\n  // Avoid Node deprecation warning DEP0079\n  SetOptionError.prototype[util.inspect.custom] = SetOptionError.prototype.inspect;\n}\n\n/**\n * Helper for JSON.stringify\n * Ensure `name` and `message` show up in toJSON output re: gh-9847\n * @api private\n */\nObject.defineProperty(SetOptionError.prototype, 'toJSON', {\n  enumerable: false,\n  writable: false,\n  configurable: true,\n  value: function() {\n    return Object.assign({}, this, { name: this.name, message: this.message });\n  }\n});\n\n\nObject.defineProperty(SetOptionError.prototype, 'name', {\n  value: 'SetOptionError'\n});\n\nclass SetOptionInnerError extends MongooseError {\n  /**\n   * Error for the \"errors\" array in \"SetOptionError\" with consistent message\n   * @param {String} key\n   */\n  constructor(key) {\n    super(`\"${key}\" is not a valid option to set`);\n  }\n}\n\nSetOptionError.SetOptionInnerError = SetOptionInnerError;\n\n/*!\n * Module exports\n */\n\nmodule.exports = SetOptionError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL3NldE9wdGlvbkVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyxvRkFBaUI7QUFDL0MsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLDBCQUEwQixtQkFBTyxDQUFDLG1IQUFvQzs7QUFFdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixVQUFVLHdDQUF3QztBQUM3RTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsY0FBYyxJQUFJO0FBQ2xCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL3NldE9wdGlvbkVycm9yLmpzPzgxODQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi9tb25nb29zZUVycm9yJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgY29tYmluZVBhdGhFcnJvcnMgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2Vycm9yL2NvbWJpbmVQYXRoRXJyb3JzJyk7XG5cbmNsYXNzIFNldE9wdGlvbkVycm9yIGV4dGVuZHMgTW9uZ29vc2VFcnJvciB7XG4gIC8qKlxuICAgKiBNb25nb29zZS5zZXQgRXJyb3JcbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqIEBpbmhlcml0cyBNb25nb29zZUVycm9yXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcignJyk7XG5cbiAgICB0aGlzLmVycm9ycyA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnNvbGUubG9nIGhlbHBlclxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGNvbWJpbmVQYXRoRXJyb3JzKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIGluc3BlY3QgaGVscGVyXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaW5zcGVjdCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IodGhpcy5tZXNzYWdlKSwgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgKiBhZGQgbWVzc2FnZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgKiBAcGFyYW0ge1N0cmluZ3xFcnJvcn0gZXJyb3JcbiAgKiBAYXBpIHByaXZhdGVcbiAgKi9cbiAgYWRkRXJyb3Ioa2V5LCBlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFNldE9wdGlvbkVycm9yKSB7XG4gICAgICBjb25zdCB7IGVycm9ycyB9ID0gZXJyb3I7XG4gICAgICBmb3IgKGNvbnN0IG9wdGlvbktleSBvZiBPYmplY3Qua2V5cyhlcnJvcnMpKSB7XG4gICAgICAgIHRoaXMuYWRkRXJyb3Iob3B0aW9uS2V5LCBlcnJvcnNbb3B0aW9uS2V5XSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmVycm9yc1trZXldID0gZXJyb3I7XG4gICAgdGhpcy5tZXNzYWdlID0gY29tYmluZVBhdGhFcnJvcnModGhpcyk7XG4gIH1cbn1cblxuXG5pZiAodXRpbC5pbnNwZWN0LmN1c3RvbSkge1xuICAvLyBBdm9pZCBOb2RlIGRlcHJlY2F0aW9uIHdhcm5pbmcgREVQMDA3OVxuICBTZXRPcHRpb25FcnJvci5wcm90b3R5cGVbdXRpbC5pbnNwZWN0LmN1c3RvbV0gPSBTZXRPcHRpb25FcnJvci5wcm90b3R5cGUuaW5zcGVjdDtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZm9yIEpTT04uc3RyaW5naWZ5XG4gKiBFbnN1cmUgYG5hbWVgIGFuZCBgbWVzc2FnZWAgc2hvdyB1cCBpbiB0b0pTT04gb3V0cHV0IHJlOiBnaC05ODQ3XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNldE9wdGlvbkVycm9yLnByb3RvdHlwZSwgJ3RvSlNPTicsIHtcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIHdyaXRhYmxlOiBmYWxzZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRoaXMsIHsgbmFtZTogdGhpcy5uYW1lLCBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UgfSk7XG4gIH1cbn0pO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXRPcHRpb25FcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ1NldE9wdGlvbkVycm9yJ1xufSk7XG5cbmNsYXNzIFNldE9wdGlvbklubmVyRXJyb3IgZXh0ZW5kcyBNb25nb29zZUVycm9yIHtcbiAgLyoqXG4gICAqIEVycm9yIGZvciB0aGUgXCJlcnJvcnNcIiBhcnJheSBpbiBcIlNldE9wdGlvbkVycm9yXCIgd2l0aCBjb25zaXN0ZW50IG1lc3NhZ2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKi9cbiAgY29uc3RydWN0b3Ioa2V5KSB7XG4gICAgc3VwZXIoYFwiJHtrZXl9XCIgaXMgbm90IGEgdmFsaWQgb3B0aW9uIHRvIHNldGApO1xuICB9XG59XG5cblNldE9wdGlvbkVycm9yLlNldE9wdGlvbklubmVyRXJyb3IgPSBTZXRPcHRpb25Jbm5lckVycm9yO1xuXG4vKiFcbiAqIE1vZHVsZSBleHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTZXRPcHRpb25FcnJvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/error/setOptionError.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/error/strict.js":
/*!************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/error/strict.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"../backend/node_modules/mongoose/lib/error/index.js\");\n\n\nclass StrictModeError extends MongooseError {\n  /**\n   * Strict mode error constructor\n   *\n   * @param {String} path\n   * @param {String} [msg]\n   * @param {Boolean} [immutable]\n   * @inherits MongooseError\n   * @api private\n   */\n  constructor(path, msg, immutable) {\n    msg = msg || 'Field `' + path + '` is not in schema and strict ' +\n      'mode is set to throw.';\n    super(msg);\n    this.isImmutableError = !!immutable;\n    this.path = path;\n  }\n}\n\nObject.defineProperty(StrictModeError.prototype, 'name', {\n  value: 'StrictModeError'\n});\n\nmodule.exports = StrictModeError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL3N0cmljdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsK0RBQUk7OztBQUdsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3Ivc3RyaWN0LmpzPzFiYzQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vJyk7XG5cblxuY2xhc3MgU3RyaWN0TW9kZUVycm9yIGV4dGVuZHMgTW9uZ29vc2VFcnJvciB7XG4gIC8qKlxuICAgKiBTdHJpY3QgbW9kZSBlcnJvciBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW21zZ11cbiAgICogQHBhcmFtIHtCb29sZWFufSBbaW1tdXRhYmxlXVxuICAgKiBAaW5oZXJpdHMgTW9uZ29vc2VFcnJvclxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhdGgsIG1zZywgaW1tdXRhYmxlKSB7XG4gICAgbXNnID0gbXNnIHx8ICdGaWVsZCBgJyArIHBhdGggKyAnYCBpcyBub3QgaW4gc2NoZW1hIGFuZCBzdHJpY3QgJyArXG4gICAgICAnbW9kZSBpcyBzZXQgdG8gdGhyb3cuJztcbiAgICBzdXBlcihtc2cpO1xuICAgIHRoaXMuaXNJbW11dGFibGVFcnJvciA9ICEhaW1tdXRhYmxlO1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cmljdE1vZGVFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ1N0cmljdE1vZGVFcnJvcidcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmljdE1vZGVFcnJvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/error/strict.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/error/strictPopulate.js":
/*!********************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/error/strictPopulate.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"../backend/node_modules/mongoose/lib/error/index.js\");\n\nclass StrictPopulateError extends MongooseError {\n  /**\n   * Strict mode error constructor\n   *\n   * @param {String} path\n   * @param {String} [msg]\n   * @inherits MongooseError\n   * @api private\n   */\n  constructor(path, msg) {\n    msg = msg || 'Cannot populate path `' + path + '` because it is not in your schema. ' + 'Set the `strictPopulate` option to false to override.';\n    super(msg);\n    this.path = path;\n  }\n}\n\nObject.defineProperty(StrictPopulateError.prototype, 'name', {\n  value: 'StrictPopulateError'\n});\n\nmodule.exports = StrictPopulateError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL3N0cmljdFBvcHVsYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQywrREFBSTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9lcnJvci9zdHJpY3RQb3B1bGF0ZS5qcz9lMWU4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLycpO1xuXG5jbGFzcyBTdHJpY3RQb3B1bGF0ZUVycm9yIGV4dGVuZHMgTW9uZ29vc2VFcnJvciB7XG4gIC8qKlxuICAgKiBTdHJpY3QgbW9kZSBlcnJvciBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW21zZ11cbiAgICogQGluaGVyaXRzIE1vbmdvb3NlRXJyb3JcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXRoLCBtc2cpIHtcbiAgICBtc2cgPSBtc2cgfHwgJ0Nhbm5vdCBwb3B1bGF0ZSBwYXRoIGAnICsgcGF0aCArICdgIGJlY2F1c2UgaXQgaXMgbm90IGluIHlvdXIgc2NoZW1hLiAnICsgJ1NldCB0aGUgYHN0cmljdFBvcHVsYXRlYCBvcHRpb24gdG8gZmFsc2UgdG8gb3ZlcnJpZGUuJztcbiAgICBzdXBlcihtc2cpO1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cmljdFBvcHVsYXRlRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdTdHJpY3RQb3B1bGF0ZUVycm9yJ1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RyaWN0UG9wdWxhdGVFcnJvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/error/strictPopulate.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/error/syncIndexes.js":
/*!*****************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/error/syncIndexes.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseError = __webpack_require__(/*! ./mongooseError */ \"../backend/node_modules/mongoose/lib/error/mongooseError.js\");\n\n/**\n * SyncIndexes Error constructor.\n *\n * @param {String} message\n * @param {String} errorsMap\n * @inherits MongooseError\n * @api private\n */\n\nclass SyncIndexesError extends MongooseError {\n  constructor(message, errorsMap) {\n    super(message);\n    this.errors = errorsMap;\n  }\n}\n\nObject.defineProperty(SyncIndexesError.prototype, 'name', {\n  value: 'SyncIndexesError'\n});\n\n\nmodule.exports = SyncIndexesError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL3N5bmNJbmRleGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsbUJBQU8sQ0FBQyxvRkFBaUI7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3Ivc3luY0luZGV4ZXMuanM/M2Y2MiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi9tb25nb29zZUVycm9yJyk7XG5cbi8qKlxuICogU3luY0luZGV4ZXMgRXJyb3IgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBlcnJvcnNNYXBcbiAqIEBpbmhlcml0cyBNb25nb29zZUVycm9yXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5jbGFzcyBTeW5jSW5kZXhlc0Vycm9yIGV4dGVuZHMgTW9uZ29vc2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGVycm9yc01hcCkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzTWFwO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTeW5jSW5kZXhlc0Vycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnU3luY0luZGV4ZXNFcnJvcidcbn0pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU3luY0luZGV4ZXNFcnJvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/error/syncIndexes.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/error/validation.js":
/*!****************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/error/validation.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module requirements\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./mongooseError */ \"../backend/node_modules/mongoose/lib/error/mongooseError.js\");\nconst getConstructorName = __webpack_require__(/*! ../helpers/getConstructorName */ \"../backend/node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst combinePathErrors = __webpack_require__(/*! ../helpers/error/combinePathErrors */ \"../backend/node_modules/mongoose/lib/helpers/error/combinePathErrors.js\");\n\nclass ValidationError extends MongooseError {\n  /**\n   * Document Validation Error\n   *\n   * @api private\n   * @param {Document} [instance]\n   * @inherits MongooseError\n   */\n  constructor(instance) {\n    let _message;\n    if (getConstructorName(instance) === 'model') {\n      _message = instance.constructor.modelName + ' validation failed';\n    } else {\n      _message = 'Validation failed';\n    }\n\n    super(_message);\n\n    this.errors = {};\n    this._message = _message;\n\n    if (instance) {\n      instance.$errors = this.errors;\n    }\n  }\n\n  /**\n   * Console.log helper\n   */\n  toString() {\n    return this.name + ': ' + combinePathErrors(this);\n  }\n\n  /**\n   * inspect helper\n   * @api private\n   */\n  inspect() {\n    return Object.assign(new Error(this.message), this);\n  }\n\n  /**\n  * add message\n  * @param {String} path\n  * @param {String|Error} error\n  * @api private\n  */\n  addError(path, error) {\n    if (error instanceof ValidationError) {\n      const { errors } = error;\n      for (const errorPath of Object.keys(errors)) {\n        this.addError(`${path}.${errorPath}`, errors[errorPath]);\n      }\n\n      return;\n    }\n\n    this.errors[path] = error;\n    this.message = this._message + ': ' + combinePathErrors(this);\n  }\n}\n\n\nif (util.inspect.custom) {\n  // Avoid Node deprecation warning DEP0079\n  ValidationError.prototype[util.inspect.custom] = ValidationError.prototype.inspect;\n}\n\n/**\n * Helper for JSON.stringify\n * Ensure `name` and `message` show up in toJSON output re: gh-9847\n * @api private\n */\nObject.defineProperty(ValidationError.prototype, 'toJSON', {\n  enumerable: false,\n  writable: false,\n  configurable: true,\n  value: function() {\n    return Object.assign({}, this, { name: this.name, message: this.message });\n  }\n});\n\n\nObject.defineProperty(ValidationError.prototype, 'name', {\n  value: 'ValidationError'\n});\n\n/*!\n * Module exports\n */\n\nmodule.exports = ValidationError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL3ZhbGlkYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVhOztBQUViLHNCQUFzQixtQkFBTyxDQUFDLG9GQUFpQjtBQUMvQywyQkFBMkIsbUJBQU8sQ0FBQyx5R0FBK0I7QUFDbEUsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLDBCQUEwQixtQkFBTyxDQUFDLG1IQUFvQzs7QUFFdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBLHlCQUF5QixLQUFLLEdBQUcsVUFBVTtBQUMzQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixVQUFVLHdDQUF3QztBQUM3RTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9lcnJvci92YWxpZGF0aW9uLmpzPzg2ZWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi9tb25nb29zZUVycm9yJyk7XG5jb25zdCBnZXRDb25zdHJ1Y3Rvck5hbWUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2dldENvbnN0cnVjdG9yTmFtZScpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IGNvbWJpbmVQYXRoRXJyb3JzID0gcmVxdWlyZSgnLi4vaGVscGVycy9lcnJvci9jb21iaW5lUGF0aEVycm9ycycpO1xuXG5jbGFzcyBWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBNb25nb29zZUVycm9yIHtcbiAgLyoqXG4gICAqIERvY3VtZW50IFZhbGlkYXRpb24gRXJyb3JcbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqIEBwYXJhbSB7RG9jdW1lbnR9IFtpbnN0YW5jZV1cbiAgICogQGluaGVyaXRzIE1vbmdvb3NlRXJyb3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKGluc3RhbmNlKSB7XG4gICAgbGV0IF9tZXNzYWdlO1xuICAgIGlmIChnZXRDb25zdHJ1Y3Rvck5hbWUoaW5zdGFuY2UpID09PSAnbW9kZWwnKSB7XG4gICAgICBfbWVzc2FnZSA9IGluc3RhbmNlLmNvbnN0cnVjdG9yLm1vZGVsTmFtZSArICcgdmFsaWRhdGlvbiBmYWlsZWQnO1xuICAgIH0gZWxzZSB7XG4gICAgICBfbWVzc2FnZSA9ICdWYWxpZGF0aW9uIGZhaWxlZCc7XG4gICAgfVxuXG4gICAgc3VwZXIoX21lc3NhZ2UpO1xuXG4gICAgdGhpcy5lcnJvcnMgPSB7fTtcbiAgICB0aGlzLl9tZXNzYWdlID0gX21lc3NhZ2U7XG5cbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgIGluc3RhbmNlLiRlcnJvcnMgPSB0aGlzLmVycm9ycztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29uc29sZS5sb2cgaGVscGVyXG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lICsgJzogJyArIGNvbWJpbmVQYXRoRXJyb3JzKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIGluc3BlY3QgaGVscGVyXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgaW5zcGVjdCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IodGhpcy5tZXNzYWdlKSwgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgKiBhZGQgbWVzc2FnZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICogQHBhcmFtIHtTdHJpbmd8RXJyb3J9IGVycm9yXG4gICogQGFwaSBwcml2YXRlXG4gICovXG4gIGFkZEVycm9yKHBhdGgsIGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICBjb25zdCB7IGVycm9ycyB9ID0gZXJyb3I7XG4gICAgICBmb3IgKGNvbnN0IGVycm9yUGF0aCBvZiBPYmplY3Qua2V5cyhlcnJvcnMpKSB7XG4gICAgICAgIHRoaXMuYWRkRXJyb3IoYCR7cGF0aH0uJHtlcnJvclBhdGh9YCwgZXJyb3JzW2Vycm9yUGF0aF0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5lcnJvcnNbcGF0aF0gPSBlcnJvcjtcbiAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLl9tZXNzYWdlICsgJzogJyArIGNvbWJpbmVQYXRoRXJyb3JzKHRoaXMpO1xuICB9XG59XG5cblxuaWYgKHV0aWwuaW5zcGVjdC5jdXN0b20pIHtcbiAgLy8gQXZvaWQgTm9kZSBkZXByZWNhdGlvbiB3YXJuaW5nIERFUDAwNzlcbiAgVmFsaWRhdGlvbkVycm9yLnByb3RvdHlwZVt1dGlsLmluc3BlY3QuY3VzdG9tXSA9IFZhbGlkYXRpb25FcnJvci5wcm90b3R5cGUuaW5zcGVjdDtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZm9yIEpTT04uc3RyaW5naWZ5XG4gKiBFbnN1cmUgYG5hbWVgIGFuZCBgbWVzc2FnZWAgc2hvdyB1cCBpbiB0b0pTT04gb3V0cHV0IHJlOiBnaC05ODQ3XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZhbGlkYXRpb25FcnJvci5wcm90b3R5cGUsICd0b0pTT04nLCB7XG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICB3cml0YWJsZTogZmFsc2UsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLCB7IG5hbWU6IHRoaXMubmFtZSwgbWVzc2FnZTogdGhpcy5tZXNzYWdlIH0pO1xuICB9XG59KTtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVmFsaWRhdGlvbkVycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnVmFsaWRhdGlvbkVycm9yJ1xufSk7XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZhbGlkYXRpb25FcnJvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/error/validation.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/error/validator.js":
/*!***************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/error/validator.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"../backend/node_modules/mongoose/lib/error/index.js\");\n\n\nclass ValidatorError extends MongooseError {\n  /**\n   * Schema validator error\n   *\n   * @param {Object} properties\n   * @param {Document} doc\n   * @api private\n   */\n  constructor(properties, doc) {\n    let msg = properties.message;\n    if (!msg) {\n      msg = MongooseError.messages.general.default;\n    }\n\n    const message = formatMessage(msg, properties, doc);\n    super(message);\n\n    properties = Object.assign({}, properties, { message: message });\n    this.properties = properties;\n    this.kind = properties.type;\n    this.path = properties.path;\n    this.value = properties.value;\n    this.reason = properties.reason;\n  }\n\n  /**\n   * toString helper\n   * TODO remove? This defaults to `${this.name}: ${this.message}`\n   * @api private\n   */\n  toString() {\n    return this.message;\n  }\n\n  /**\n   * Ensure `name` and `message` show up in toJSON output re: gh-9296\n   * @api private\n   */\n\n  toJSON() {\n    return Object.assign({ name: this.name, message: this.message }, this);\n  }\n}\n\n\nObject.defineProperty(ValidatorError.prototype, 'name', {\n  value: 'ValidatorError'\n});\n\n/**\n * The object used to define this validator. Not enumerable to hide\n * it from `require('util').inspect()` output re: gh-3925\n * @api private\n */\n\nObject.defineProperty(ValidatorError.prototype, 'properties', {\n  enumerable: false,\n  writable: true,\n  value: null\n});\n\n// Exposed for testing\nValidatorError.prototype.formatMessage = formatMessage;\n\n/**\n * Formats error messages\n * @api private\n */\n\nfunction formatMessage(msg, properties, doc) {\n  if (typeof msg === 'function') {\n    return msg(properties, doc);\n  }\n\n  const propertyNames = Object.keys(properties);\n  for (const propertyName of propertyNames) {\n    if (propertyName === 'message') {\n      continue;\n    }\n    msg = msg.replace('{' + propertyName.toUpperCase() + '}', properties[propertyName]);\n  }\n\n  return msg;\n}\n\n/*!\n * exports\n */\n\nmodule.exports = ValidatorError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL3ZhbGlkYXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsK0RBQUk7OztBQUdsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUMsZ0JBQWdCLGtCQUFrQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxVQUFVLElBQUksYUFBYTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLHdDQUF3QztBQUNuRTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUNBQW1DO0FBQzNEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL3ZhbGlkYXRvci5qcz80N2I4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLycpO1xuXG5cbmNsYXNzIFZhbGlkYXRvckVycm9yIGV4dGVuZHMgTW9uZ29vc2VFcnJvciB7XG4gIC8qKlxuICAgKiBTY2hlbWEgdmFsaWRhdG9yIGVycm9yXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvY1xuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHByb3BlcnRpZXMsIGRvYykge1xuICAgIGxldCBtc2cgPSBwcm9wZXJ0aWVzLm1lc3NhZ2U7XG4gICAgaWYgKCFtc2cpIHtcbiAgICAgIG1zZyA9IE1vbmdvb3NlRXJyb3IubWVzc2FnZXMuZ2VuZXJhbC5kZWZhdWx0O1xuICAgIH1cblxuICAgIGNvbnN0IG1lc3NhZ2UgPSBmb3JtYXRNZXNzYWdlKG1zZywgcHJvcGVydGllcywgZG9jKTtcbiAgICBzdXBlcihtZXNzYWdlKTtcblxuICAgIHByb3BlcnRpZXMgPSBPYmplY3QuYXNzaWduKHt9LCBwcm9wZXJ0aWVzLCB7IG1lc3NhZ2U6IG1lc3NhZ2UgfSk7XG4gICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcbiAgICB0aGlzLmtpbmQgPSBwcm9wZXJ0aWVzLnR5cGU7XG4gICAgdGhpcy5wYXRoID0gcHJvcGVydGllcy5wYXRoO1xuICAgIHRoaXMudmFsdWUgPSBwcm9wZXJ0aWVzLnZhbHVlO1xuICAgIHRoaXMucmVhc29uID0gcHJvcGVydGllcy5yZWFzb247XG4gIH1cblxuICAvKipcbiAgICogdG9TdHJpbmcgaGVscGVyXG4gICAqIFRPRE8gcmVtb3ZlPyBUaGlzIGRlZmF1bHRzIHRvIGAke3RoaXMubmFtZX06ICR7dGhpcy5tZXNzYWdlfWBcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuc3VyZSBgbmFtZWAgYW5kIGBtZXNzYWdlYCBzaG93IHVwIGluIHRvSlNPTiBvdXRwdXQgcmU6IGdoLTkyOTZcbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IG5hbWU6IHRoaXMubmFtZSwgbWVzc2FnZTogdGhpcy5tZXNzYWdlIH0sIHRoaXMpO1xuICB9XG59XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZhbGlkYXRvckVycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnVmFsaWRhdG9yRXJyb3InXG59KTtcblxuLyoqXG4gKiBUaGUgb2JqZWN0IHVzZWQgdG8gZGVmaW5lIHRoaXMgdmFsaWRhdG9yLiBOb3QgZW51bWVyYWJsZSB0byBoaWRlXG4gKiBpdCBmcm9tIGByZXF1aXJlKCd1dGlsJykuaW5zcGVjdCgpYCBvdXRwdXQgcmU6IGdoLTM5MjVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWYWxpZGF0b3JFcnJvci5wcm90b3R5cGUsICdwcm9wZXJ0aWVzJywge1xuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIHZhbHVlOiBudWxsXG59KTtcblxuLy8gRXhwb3NlZCBmb3IgdGVzdGluZ1xuVmFsaWRhdG9yRXJyb3IucHJvdG90eXBlLmZvcm1hdE1lc3NhZ2UgPSBmb3JtYXRNZXNzYWdlO1xuXG4vKipcbiAqIEZvcm1hdHMgZXJyb3IgbWVzc2FnZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2UobXNnLCBwcm9wZXJ0aWVzLCBkb2MpIHtcbiAgaWYgKHR5cGVvZiBtc2cgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbXNnKHByb3BlcnRpZXMsIGRvYyk7XG4gIH1cblxuICBjb25zdCBwcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyk7XG4gIGZvciAoY29uc3QgcHJvcGVydHlOYW1lIG9mIHByb3BlcnR5TmFtZXMpIHtcbiAgICBpZiAocHJvcGVydHlOYW1lID09PSAnbWVzc2FnZScpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBtc2cgPSBtc2cucmVwbGFjZSgneycgKyBwcm9wZXJ0eU5hbWUudG9VcHBlckNhc2UoKSArICd9JywgcHJvcGVydGllc1twcm9wZXJ0eU5hbWVdKTtcbiAgfVxuXG4gIHJldHVybiBtc2c7XG59XG5cbi8qIVxuICogZXhwb3J0c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gVmFsaWRhdG9yRXJyb3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/error/validator.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/error/version.js":
/*!*************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/error/version.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseError = __webpack_require__(/*! ./ */ \"../backend/node_modules/mongoose/lib/error/index.js\");\n\nclass VersionError extends MongooseError {\n  /**\n   * Version Error constructor.\n   *\n   * @param {Document} doc\n   * @param {Number} currentVersion\n   * @param {Array<String>} modifiedPaths\n   * @api private\n   */\n  constructor(doc, currentVersion, modifiedPaths) {\n    const modifiedPathsStr = modifiedPaths.join(', ');\n    super('No matching document found for id \"' + doc._id +\n      '\" version ' + currentVersion + ' modifiedPaths \"' + modifiedPathsStr + '\"');\n    this.version = currentVersion;\n    this.modifiedPaths = modifiedPaths;\n  }\n}\n\n\nObject.defineProperty(VersionError.prototype, 'name', {\n  value: 'VersionError'\n});\n\n/*!\n * exports\n */\n\nmodule.exports = VersionError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2Vycm9yL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixtQkFBTyxDQUFDLCtEQUFJOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixhQUFhLFFBQVE7QUFDckIsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvZXJyb3IvdmVyc2lvbi5qcz9kNDE4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLycpO1xuXG5jbGFzcyBWZXJzaW9uRXJyb3IgZXh0ZW5kcyBNb25nb29zZUVycm9yIHtcbiAgLyoqXG4gICAqIFZlcnNpb24gRXJyb3IgY29uc3RydWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvY1xuICAgKiBAcGFyYW0ge051bWJlcn0gY3VycmVudFZlcnNpb25cbiAgICogQHBhcmFtIHtBcnJheTxTdHJpbmc+fSBtb2RpZmllZFBhdGhzXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IoZG9jLCBjdXJyZW50VmVyc2lvbiwgbW9kaWZpZWRQYXRocykge1xuICAgIGNvbnN0IG1vZGlmaWVkUGF0aHNTdHIgPSBtb2RpZmllZFBhdGhzLmpvaW4oJywgJyk7XG4gICAgc3VwZXIoJ05vIG1hdGNoaW5nIGRvY3VtZW50IGZvdW5kIGZvciBpZCBcIicgKyBkb2MuX2lkICtcbiAgICAgICdcIiB2ZXJzaW9uICcgKyBjdXJyZW50VmVyc2lvbiArICcgbW9kaWZpZWRQYXRocyBcIicgKyBtb2RpZmllZFBhdGhzU3RyICsgJ1wiJyk7XG4gICAgdGhpcy52ZXJzaW9uID0gY3VycmVudFZlcnNpb247XG4gICAgdGhpcy5tb2RpZmllZFBhdGhzID0gbW9kaWZpZWRQYXRocztcbiAgfVxufVxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWZXJzaW9uRXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdWZXJzaW9uRXJyb3InXG59KTtcblxuLyohXG4gKiBleHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBWZXJzaW9uRXJyb3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/error/version.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/aggregate/prepareDiscriminatorPipeline.js":
/*!**********************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/aggregate/prepareDiscriminatorPipeline.js ***!
  \**********************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function prepareDiscriminatorPipeline(pipeline, schema, prefix) {\n  const discriminatorMapping = schema && schema.discriminatorMapping;\n  prefix = prefix || '';\n\n  if (discriminatorMapping && !discriminatorMapping.isRoot) {\n    const originalPipeline = pipeline;\n    const filterKey = (prefix.length > 0 ? prefix + '.' : prefix) + discriminatorMapping.key;\n    const discriminatorValue = discriminatorMapping.value;\n\n    // If the first pipeline stage is a match and it doesn't specify a `__t`\n    // key, add the discriminator key to it. This allows for potential\n    // aggregation query optimizations not to be disturbed by this feature.\n    if (originalPipeline[0] != null &&\n        originalPipeline[0].$match &&\n        (originalPipeline[0].$match[filterKey] === undefined || originalPipeline[0].$match[filterKey] === discriminatorValue)) {\n      originalPipeline[0].$match[filterKey] = discriminatorValue;\n      // `originalPipeline` is a ref, so there's no need for\n      // aggregate._pipeline = originalPipeline\n    } else if (originalPipeline[0] != null && originalPipeline[0].$geoNear) {\n      originalPipeline[0].$geoNear.query =\n          originalPipeline[0].$geoNear.query || {};\n      originalPipeline[0].$geoNear.query[filterKey] = discriminatorValue;\n    } else if (originalPipeline[0] != null && originalPipeline[0].$search) {\n      if (originalPipeline[1] && originalPipeline[1].$match != null) {\n        originalPipeline[1].$match[filterKey] = originalPipeline[1].$match[filterKey] || discriminatorValue;\n      } else {\n        const match = {};\n        match[filterKey] = discriminatorValue;\n        originalPipeline.splice(1, 0, { $match: match });\n      }\n    } else {\n      const match = {};\n      match[filterKey] = discriminatorValue;\n      originalPipeline.unshift({ $match: match });\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvYWdncmVnYXRlL3ByZXBhcmVEaXNjcmltaW5hdG9yUGlwZWxpbmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0Esd0NBQXdDLGVBQWU7QUFDdkQ7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2FnZ3JlZ2F0ZS9wcmVwYXJlRGlzY3JpbWluYXRvclBpcGVsaW5lLmpzPzMwOTMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHByZXBhcmVEaXNjcmltaW5hdG9yUGlwZWxpbmUocGlwZWxpbmUsIHNjaGVtYSwgcHJlZml4KSB7XG4gIGNvbnN0IGRpc2NyaW1pbmF0b3JNYXBwaW5nID0gc2NoZW1hICYmIHNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZztcbiAgcHJlZml4ID0gcHJlZml4IHx8ICcnO1xuXG4gIGlmIChkaXNjcmltaW5hdG9yTWFwcGluZyAmJiAhZGlzY3JpbWluYXRvck1hcHBpbmcuaXNSb290KSB7XG4gICAgY29uc3Qgb3JpZ2luYWxQaXBlbGluZSA9IHBpcGVsaW5lO1xuICAgIGNvbnN0IGZpbHRlcktleSA9IChwcmVmaXgubGVuZ3RoID4gMCA/IHByZWZpeCArICcuJyA6IHByZWZpeCkgKyBkaXNjcmltaW5hdG9yTWFwcGluZy5rZXk7XG4gICAgY29uc3QgZGlzY3JpbWluYXRvclZhbHVlID0gZGlzY3JpbWluYXRvck1hcHBpbmcudmFsdWU7XG5cbiAgICAvLyBJZiB0aGUgZmlyc3QgcGlwZWxpbmUgc3RhZ2UgaXMgYSBtYXRjaCBhbmQgaXQgZG9lc24ndCBzcGVjaWZ5IGEgYF9fdGBcbiAgICAvLyBrZXksIGFkZCB0aGUgZGlzY3JpbWluYXRvciBrZXkgdG8gaXQuIFRoaXMgYWxsb3dzIGZvciBwb3RlbnRpYWxcbiAgICAvLyBhZ2dyZWdhdGlvbiBxdWVyeSBvcHRpbWl6YXRpb25zIG5vdCB0byBiZSBkaXN0dXJiZWQgYnkgdGhpcyBmZWF0dXJlLlxuICAgIGlmIChvcmlnaW5hbFBpcGVsaW5lWzBdICE9IG51bGwgJiZcbiAgICAgICAgb3JpZ2luYWxQaXBlbGluZVswXS4kbWF0Y2ggJiZcbiAgICAgICAgKG9yaWdpbmFsUGlwZWxpbmVbMF0uJG1hdGNoW2ZpbHRlcktleV0gPT09IHVuZGVmaW5lZCB8fCBvcmlnaW5hbFBpcGVsaW5lWzBdLiRtYXRjaFtmaWx0ZXJLZXldID09PSBkaXNjcmltaW5hdG9yVmFsdWUpKSB7XG4gICAgICBvcmlnaW5hbFBpcGVsaW5lWzBdLiRtYXRjaFtmaWx0ZXJLZXldID0gZGlzY3JpbWluYXRvclZhbHVlO1xuICAgICAgLy8gYG9yaWdpbmFsUGlwZWxpbmVgIGlzIGEgcmVmLCBzbyB0aGVyZSdzIG5vIG5lZWQgZm9yXG4gICAgICAvLyBhZ2dyZWdhdGUuX3BpcGVsaW5lID0gb3JpZ2luYWxQaXBlbGluZVxuICAgIH0gZWxzZSBpZiAob3JpZ2luYWxQaXBlbGluZVswXSAhPSBudWxsICYmIG9yaWdpbmFsUGlwZWxpbmVbMF0uJGdlb05lYXIpIHtcbiAgICAgIG9yaWdpbmFsUGlwZWxpbmVbMF0uJGdlb05lYXIucXVlcnkgPVxuICAgICAgICAgIG9yaWdpbmFsUGlwZWxpbmVbMF0uJGdlb05lYXIucXVlcnkgfHwge307XG4gICAgICBvcmlnaW5hbFBpcGVsaW5lWzBdLiRnZW9OZWFyLnF1ZXJ5W2ZpbHRlcktleV0gPSBkaXNjcmltaW5hdG9yVmFsdWU7XG4gICAgfSBlbHNlIGlmIChvcmlnaW5hbFBpcGVsaW5lWzBdICE9IG51bGwgJiYgb3JpZ2luYWxQaXBlbGluZVswXS4kc2VhcmNoKSB7XG4gICAgICBpZiAob3JpZ2luYWxQaXBlbGluZVsxXSAmJiBvcmlnaW5hbFBpcGVsaW5lWzFdLiRtYXRjaCAhPSBudWxsKSB7XG4gICAgICAgIG9yaWdpbmFsUGlwZWxpbmVbMV0uJG1hdGNoW2ZpbHRlcktleV0gPSBvcmlnaW5hbFBpcGVsaW5lWzFdLiRtYXRjaFtmaWx0ZXJLZXldIHx8IGRpc2NyaW1pbmF0b3JWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0ge307XG4gICAgICAgIG1hdGNoW2ZpbHRlcktleV0gPSBkaXNjcmltaW5hdG9yVmFsdWU7XG4gICAgICAgIG9yaWdpbmFsUGlwZWxpbmUuc3BsaWNlKDEsIDAsIHsgJG1hdGNoOiBtYXRjaCB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWF0Y2ggPSB7fTtcbiAgICAgIG1hdGNoW2ZpbHRlcktleV0gPSBkaXNjcmltaW5hdG9yVmFsdWU7XG4gICAgICBvcmlnaW5hbFBpcGVsaW5lLnVuc2hpZnQoeyAkbWF0Y2g6IG1hdGNoIH0pO1xuICAgIH1cbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/aggregate/prepareDiscriminatorPipeline.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/aggregate/stringifyFunctionOperators.js":
/*!********************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/aggregate/stringifyFunctionOperators.js ***!
  \********************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function stringifyFunctionOperators(pipeline) {\n  if (!Array.isArray(pipeline)) {\n    return;\n  }\n\n  for (const stage of pipeline) {\n    if (stage == null) {\n      continue;\n    }\n\n    const canHaveAccumulator = stage.$group || stage.$bucket || stage.$bucketAuto;\n    if (canHaveAccumulator != null) {\n      for (const key of Object.keys(canHaveAccumulator)) {\n        handleAccumulator(canHaveAccumulator[key]);\n      }\n    }\n\n    const stageType = Object.keys(stage)[0];\n    if (stageType && typeof stage[stageType] === 'object') {\n      const stageOptions = stage[stageType];\n      for (const key of Object.keys(stageOptions)) {\n        if (stageOptions[key] != null &&\n            stageOptions[key].$function != null &&\n            typeof stageOptions[key].$function.body === 'function') {\n          stageOptions[key].$function.body = stageOptions[key].$function.body.toString();\n        }\n      }\n    }\n\n    if (stage.$facet != null) {\n      for (const key of Object.keys(stage.$facet)) {\n        stringifyFunctionOperators(stage.$facet[key]);\n      }\n    }\n  }\n};\n\nfunction handleAccumulator(operator) {\n  if (operator == null || operator.$accumulator == null) {\n    return;\n  }\n\n  for (const key of ['init', 'accumulate', 'merge', 'finalize']) {\n    if (typeof operator.$accumulator[key] === 'function') {\n      operator.$accumulator[key] = String(operator.$accumulator[key]);\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvYWdncmVnYXRlL3N0cmluZ2lmeUZ1bmN0aW9uT3BlcmF0b3JzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2FnZ3JlZ2F0ZS9zdHJpbmdpZnlGdW5jdGlvbk9wZXJhdG9ycy5qcz80M2VmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzdHJpbmdpZnlGdW5jdGlvbk9wZXJhdG9ycyhwaXBlbGluZSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkocGlwZWxpbmUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yIChjb25zdCBzdGFnZSBvZiBwaXBlbGluZSkge1xuICAgIGlmIChzdGFnZSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBjYW5IYXZlQWNjdW11bGF0b3IgPSBzdGFnZS4kZ3JvdXAgfHwgc3RhZ2UuJGJ1Y2tldCB8fCBzdGFnZS4kYnVja2V0QXV0bztcbiAgICBpZiAoY2FuSGF2ZUFjY3VtdWxhdG9yICE9IG51bGwpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGNhbkhhdmVBY2N1bXVsYXRvcikpIHtcbiAgICAgICAgaGFuZGxlQWNjdW11bGF0b3IoY2FuSGF2ZUFjY3VtdWxhdG9yW2tleV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHN0YWdlVHlwZSA9IE9iamVjdC5rZXlzKHN0YWdlKVswXTtcbiAgICBpZiAoc3RhZ2VUeXBlICYmIHR5cGVvZiBzdGFnZVtzdGFnZVR5cGVdID09PSAnb2JqZWN0Jykge1xuICAgICAgY29uc3Qgc3RhZ2VPcHRpb25zID0gc3RhZ2Vbc3RhZ2VUeXBlXTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHN0YWdlT3B0aW9ucykpIHtcbiAgICAgICAgaWYgKHN0YWdlT3B0aW9uc1trZXldICE9IG51bGwgJiZcbiAgICAgICAgICAgIHN0YWdlT3B0aW9uc1trZXldLiRmdW5jdGlvbiAhPSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2Ygc3RhZ2VPcHRpb25zW2tleV0uJGZ1bmN0aW9uLmJvZHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBzdGFnZU9wdGlvbnNba2V5XS4kZnVuY3Rpb24uYm9keSA9IHN0YWdlT3B0aW9uc1trZXldLiRmdW5jdGlvbi5ib2R5LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RhZ2UuJGZhY2V0ICE9IG51bGwpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHN0YWdlLiRmYWNldCkpIHtcbiAgICAgICAgc3RyaW5naWZ5RnVuY3Rpb25PcGVyYXRvcnMoc3RhZ2UuJGZhY2V0W2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gaGFuZGxlQWNjdW11bGF0b3Iob3BlcmF0b3IpIHtcbiAgaWYgKG9wZXJhdG9yID09IG51bGwgfHwgb3BlcmF0b3IuJGFjY3VtdWxhdG9yID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKGNvbnN0IGtleSBvZiBbJ2luaXQnLCAnYWNjdW11bGF0ZScsICdtZXJnZScsICdmaW5hbGl6ZSddKSB7XG4gICAgaWYgKHR5cGVvZiBvcGVyYXRvci4kYWNjdW11bGF0b3Jba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb3BlcmF0b3IuJGFjY3VtdWxhdG9yW2tleV0gPSBTdHJpbmcob3BlcmF0b3IuJGFjY3VtdWxhdG9yW2tleV0pO1xuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/aggregate/stringifyFunctionOperators.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/arrayDepth.js":
/*!******************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/arrayDepth.js ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = arrayDepth;\n\nfunction arrayDepth(arr) {\n  if (!Array.isArray(arr)) {\n    return { min: 0, max: 0, containsNonArrayItem: true };\n  }\n  if (arr.length === 0) {\n    return { min: 1, max: 1, containsNonArrayItem: false };\n  }\n  if (arr.length === 1 && !Array.isArray(arr[0])) {\n    return { min: 1, max: 1, containsNonArrayItem: false };\n  }\n\n  const res = arrayDepth(arr[0]);\n\n  for (let i = 1; i < arr.length; ++i) {\n    const _res = arrayDepth(arr[i]);\n    if (_res.min < res.min) {\n      res.min = _res.min;\n    }\n    if (_res.max > res.max) {\n      res.max = _res.max;\n    }\n    res.containsNonArrayItem = res.containsNonArrayItem || _res.containsNonArrayItem;\n  }\n\n  res.min = res.min + 1;\n  res.max = res.max + 1;\n\n  return res;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvYXJyYXlEZXB0aC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTs7QUFFQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9hcnJheURlcHRoLmpzP2MxYjYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RGVwdGg7XG5cbmZ1bmN0aW9uIGFycmF5RGVwdGgoYXJyKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgcmV0dXJuIHsgbWluOiAwLCBtYXg6IDAsIGNvbnRhaW5zTm9uQXJyYXlJdGVtOiB0cnVlIH07XG4gIH1cbiAgaWYgKGFyci5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4geyBtaW46IDEsIG1heDogMSwgY29udGFpbnNOb25BcnJheUl0ZW06IGZhbHNlIH07XG4gIH1cbiAgaWYgKGFyci5sZW5ndGggPT09IDEgJiYgIUFycmF5LmlzQXJyYXkoYXJyWzBdKSkge1xuICAgIHJldHVybiB7IG1pbjogMSwgbWF4OiAxLCBjb250YWluc05vbkFycmF5SXRlbTogZmFsc2UgfTtcbiAgfVxuXG4gIGNvbnN0IHJlcyA9IGFycmF5RGVwdGgoYXJyWzBdKTtcblxuICBmb3IgKGxldCBpID0gMTsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IF9yZXMgPSBhcnJheURlcHRoKGFycltpXSk7XG4gICAgaWYgKF9yZXMubWluIDwgcmVzLm1pbikge1xuICAgICAgcmVzLm1pbiA9IF9yZXMubWluO1xuICAgIH1cbiAgICBpZiAoX3Jlcy5tYXggPiByZXMubWF4KSB7XG4gICAgICByZXMubWF4ID0gX3Jlcy5tYXg7XG4gICAgfVxuICAgIHJlcy5jb250YWluc05vbkFycmF5SXRlbSA9IHJlcy5jb250YWluc05vbkFycmF5SXRlbSB8fCBfcmVzLmNvbnRhaW5zTm9uQXJyYXlJdGVtO1xuICB9XG5cbiAgcmVzLm1pbiA9IHJlcy5taW4gKyAxO1xuICByZXMubWF4ID0gcmVzLm1heCArIDE7XG5cbiAgcmV0dXJuIHJlcztcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/arrayDepth.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/clone.js":
/*!*************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/clone.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Decimal = __webpack_require__(/*! ../types/decimal128 */ \"../backend/node_modules/mongoose/lib/types/decimal128.js\");\nconst ObjectId = __webpack_require__(/*! ../types/objectid */ \"../backend/node_modules/mongoose/lib/types/objectid.js\");\nconst specialProperties = __webpack_require__(/*! ./specialProperties */ \"../backend/node_modules/mongoose/lib/helpers/specialProperties.js\");\nconst isMongooseObject = __webpack_require__(/*! ./isMongooseObject */ \"../backend/node_modules/mongoose/lib/helpers/isMongooseObject.js\");\nconst getFunctionName = __webpack_require__(/*! ./getFunctionName */ \"../backend/node_modules/mongoose/lib/helpers/getFunctionName.js\");\nconst isBsonType = __webpack_require__(/*! ./isBsonType */ \"../backend/node_modules/mongoose/lib/helpers/isBsonType.js\");\nconst isMongooseArray = (__webpack_require__(/*! ../types/array/isMongooseArray */ \"../backend/node_modules/mongoose/lib/types/array/isMongooseArray.js\").isMongooseArray);\nconst isObject = __webpack_require__(/*! ./isObject */ \"../backend/node_modules/mongoose/lib/helpers/isObject.js\");\nconst isPOJO = __webpack_require__(/*! ./isPOJO */ \"../backend/node_modules/mongoose/lib/helpers/isPOJO.js\");\nconst symbols = __webpack_require__(/*! ./symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\");\nconst trustedSymbol = (__webpack_require__(/*! ./query/trusted */ \"../backend/node_modules/mongoose/lib/helpers/query/trusted.js\").trustedSymbol);\n\n/**\n * Object clone with Mongoose natives support.\n *\n * If options.minimize is true, creates a minimal data object. Empty objects and undefined values will not be cloned. This makes the data payload sent to MongoDB as small as possible.\n *\n * Functions are never cloned.\n *\n * @param {Object} obj the object to clone\n * @param {Object} options\n * @param {Boolean} isArrayChild true if cloning immediately underneath an array. Special case for minimize.\n * @return {Object} the cloned object\n * @api private\n */\n\nfunction clone(obj, options, isArrayChild) {\n  if (obj == null) {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return cloneArray(isMongooseArray(obj) ? obj.__array : obj, options);\n  }\n\n  if (isMongooseObject(obj)) {\n    if (options) {\n      // Single nested subdocs should apply getters later in `applyGetters()`\n      // when calling `toObject()`. See gh-7442, gh-8295\n      if (options._skipSingleNestedGetters && obj.$isSingleNested) {\n        options = Object.assign({}, options, { getters: false });\n      }\n      if (options.retainDocuments && obj.$__ != null) {\n        const clonedDoc = obj.$clone();\n        if (obj.__index != null) {\n          clonedDoc.__index = obj.__index;\n        }\n        if (obj.__parentArray != null) {\n          clonedDoc.__parentArray = obj.__parentArray;\n        }\n        clonedDoc.$__parent = obj.$__parent;\n        return clonedDoc;\n      }\n    }\n    const isSingleNested = obj.$isSingleNested;\n\n    if (isPOJO(obj) && obj.$__ != null && obj._doc != null) {\n      return obj._doc;\n    }\n\n    let ret;\n    if (options && options.json && typeof obj.toJSON === 'function') {\n      ret = obj.toJSON(options);\n    } else {\n      ret = obj.toObject(options);\n    }\n\n    if (options && options.minimize && !obj.constructor.$__required && isSingleNested && Object.keys(ret).length === 0) {\n      return undefined;\n    }\n\n    return ret;\n  }\n\n  const objConstructor = obj.constructor;\n\n  if (objConstructor) {\n    switch (getFunctionName(objConstructor)) {\n      case 'Object':\n        return cloneObject(obj, options, isArrayChild);\n      case 'Date':\n        return new objConstructor(+obj);\n      case 'RegExp':\n        return cloneRegExp(obj);\n      default:\n        // ignore\n        break;\n    }\n  }\n\n  if (isBsonType(obj, 'ObjectId')) {\n    if (options && options.flattenObjectIds) {\n      return obj.toJSON();\n    }\n    return new ObjectId(obj.id);\n  }\n\n  if (isBsonType(obj, 'Decimal128')) {\n    if (options && options.flattenDecimals) {\n      return obj.toJSON();\n    }\n    return Decimal.fromString(obj.toString());\n  }\n\n  // object created with Object.create(null)\n  if (!objConstructor && isObject(obj)) {\n    return cloneObject(obj, options, isArrayChild);\n  }\n\n  if (typeof obj === 'object' && obj[symbols.schemaTypeSymbol]) {\n    return obj.clone();\n  }\n\n  // If we're cloning this object to go into a MongoDB command,\n  // and there's a `toBSON()` function, assume this object will be\n  // stored as a primitive in MongoDB and doesn't need to be cloned.\n  if (options && options.bson && typeof obj.toBSON === 'function') {\n    return obj;\n  }\n\n  if (typeof obj.valueOf === 'function') {\n    return obj.valueOf();\n  }\n\n  return cloneObject(obj, options, isArrayChild);\n}\nmodule.exports = clone;\n\n/*!\n * ignore\n */\n\nfunction cloneObject(obj, options, isArrayChild) {\n  const minimize = options && options.minimize;\n  const omitUndefined = options && options.omitUndefined;\n  const seen = options && options._seen;\n  const ret = {};\n  let hasKeys;\n\n  if (seen && seen.has(obj)) {\n    return seen.get(obj);\n  } else if (seen) {\n    seen.set(obj, ret);\n  }\n  if (trustedSymbol in obj) {\n    ret[trustedSymbol] = obj[trustedSymbol];\n  }\n\n  let i = 0;\n  let key = '';\n  const keys = Object.keys(obj);\n  const len = keys.length;\n\n  for (i = 0; i < len; ++i) {\n    if (specialProperties.has(key = keys[i])) {\n      continue;\n    }\n\n    // Don't pass `isArrayChild` down\n    const val = clone(obj[key], options, false);\n\n    if ((minimize === false || omitUndefined) && typeof val === 'undefined') {\n      delete ret[key];\n    } else if (minimize !== true || (typeof val !== 'undefined')) {\n      hasKeys || (hasKeys = true);\n      ret[key] = val;\n    }\n  }\n\n  return minimize && !isArrayChild ? hasKeys && ret : ret;\n}\n\nfunction cloneArray(arr, options) {\n  let i = 0;\n  const len = arr.length;\n  const ret = new Array(len);\n  for (i = 0; i < len; ++i) {\n    ret[i] = clone(arr[i], options, true);\n  }\n\n  return ret;\n}\n\nfunction cloneRegExp(regexp) {\n  const ret = new RegExp(regexp.source, regexp.flags);\n\n  if (ret.lastIndex !== regexp.lastIndex) {\n    ret.lastIndex = regexp.lastIndex;\n  }\n  return ret;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvY2xvbmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZ0JBQWdCLG1CQUFPLENBQUMscUZBQXFCO0FBQzdDLGlCQUFpQixtQkFBTyxDQUFDLGlGQUFtQjtBQUM1QywwQkFBMEIsbUJBQU8sQ0FBQyw4RkFBcUI7QUFDdkQseUJBQXlCLG1CQUFPLENBQUMsNEZBQW9CO0FBQ3JELHdCQUF3QixtQkFBTyxDQUFDLDBGQUFtQjtBQUNuRCxtQkFBbUIsbUJBQU8sQ0FBQyxnRkFBYztBQUN6Qyx3QkFBd0Isa0pBQXlEO0FBQ2pGLGlCQUFpQixtQkFBTyxDQUFDLDRFQUFZO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyx3RUFBVTtBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBVztBQUNuQyxzQkFBc0IsMkhBQXdDOztBQUU5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGFBQWEsZ0JBQWdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2Nsb25lLmpzPzViNjgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBEZWNpbWFsID0gcmVxdWlyZSgnLi4vdHlwZXMvZGVjaW1hbDEyOCcpO1xuY29uc3QgT2JqZWN0SWQgPSByZXF1aXJlKCcuLi90eXBlcy9vYmplY3RpZCcpO1xuY29uc3Qgc3BlY2lhbFByb3BlcnRpZXMgPSByZXF1aXJlKCcuL3NwZWNpYWxQcm9wZXJ0aWVzJyk7XG5jb25zdCBpc01vbmdvb3NlT2JqZWN0ID0gcmVxdWlyZSgnLi9pc01vbmdvb3NlT2JqZWN0Jyk7XG5jb25zdCBnZXRGdW5jdGlvbk5hbWUgPSByZXF1aXJlKCcuL2dldEZ1bmN0aW9uTmFtZScpO1xuY29uc3QgaXNCc29uVHlwZSA9IHJlcXVpcmUoJy4vaXNCc29uVHlwZScpO1xuY29uc3QgaXNNb25nb29zZUFycmF5ID0gcmVxdWlyZSgnLi4vdHlwZXMvYXJyYXkvaXNNb25nb29zZUFycmF5JykuaXNNb25nb29zZUFycmF5O1xuY29uc3QgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5jb25zdCBpc1BPSk8gPSByZXF1aXJlKCcuL2lzUE9KTycpO1xuY29uc3Qgc3ltYm9scyA9IHJlcXVpcmUoJy4vc3ltYm9scycpO1xuY29uc3QgdHJ1c3RlZFN5bWJvbCA9IHJlcXVpcmUoJy4vcXVlcnkvdHJ1c3RlZCcpLnRydXN0ZWRTeW1ib2w7XG5cbi8qKlxuICogT2JqZWN0IGNsb25lIHdpdGggTW9uZ29vc2UgbmF0aXZlcyBzdXBwb3J0LlxuICpcbiAqIElmIG9wdGlvbnMubWluaW1pemUgaXMgdHJ1ZSwgY3JlYXRlcyBhIG1pbmltYWwgZGF0YSBvYmplY3QuIEVtcHR5IG9iamVjdHMgYW5kIHVuZGVmaW5lZCB2YWx1ZXMgd2lsbCBub3QgYmUgY2xvbmVkLiBUaGlzIG1ha2VzIHRoZSBkYXRhIHBheWxvYWQgc2VudCB0byBNb25nb0RCIGFzIHNtYWxsIGFzIHBvc3NpYmxlLlxuICpcbiAqIEZ1bmN0aW9ucyBhcmUgbmV2ZXIgY2xvbmVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdGhlIG9iamVjdCB0byBjbG9uZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNBcnJheUNoaWxkIHRydWUgaWYgY2xvbmluZyBpbW1lZGlhdGVseSB1bmRlcm5lYXRoIGFuIGFycmF5LiBTcGVjaWFsIGNhc2UgZm9yIG1pbmltaXplLlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgY2xvbmVkIG9iamVjdFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY2xvbmUob2JqLCBvcHRpb25zLCBpc0FycmF5Q2hpbGQpIHtcbiAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gY2xvbmVBcnJheShpc01vbmdvb3NlQXJyYXkob2JqKSA/IG9iai5fX2FycmF5IDogb2JqLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmIChpc01vbmdvb3NlT2JqZWN0KG9iaikpIHtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgLy8gU2luZ2xlIG5lc3RlZCBzdWJkb2NzIHNob3VsZCBhcHBseSBnZXR0ZXJzIGxhdGVyIGluIGBhcHBseUdldHRlcnMoKWBcbiAgICAgIC8vIHdoZW4gY2FsbGluZyBgdG9PYmplY3QoKWAuIFNlZSBnaC03NDQyLCBnaC04Mjk1XG4gICAgICBpZiAob3B0aW9ucy5fc2tpcFNpbmdsZU5lc3RlZEdldHRlcnMgJiYgb2JqLiRpc1NpbmdsZU5lc3RlZCkge1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyBnZXR0ZXJzOiBmYWxzZSB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnJldGFpbkRvY3VtZW50cyAmJiBvYmouJF9fICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgY2xvbmVkRG9jID0gb2JqLiRjbG9uZSgpO1xuICAgICAgICBpZiAob2JqLl9faW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgIGNsb25lZERvYy5fX2luZGV4ID0gb2JqLl9faW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iai5fX3BhcmVudEFycmF5ICE9IG51bGwpIHtcbiAgICAgICAgICBjbG9uZWREb2MuX19wYXJlbnRBcnJheSA9IG9iai5fX3BhcmVudEFycmF5O1xuICAgICAgICB9XG4gICAgICAgIGNsb25lZERvYy4kX19wYXJlbnQgPSBvYmouJF9fcGFyZW50O1xuICAgICAgICByZXR1cm4gY2xvbmVkRG9jO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpc1NpbmdsZU5lc3RlZCA9IG9iai4kaXNTaW5nbGVOZXN0ZWQ7XG5cbiAgICBpZiAoaXNQT0pPKG9iaikgJiYgb2JqLiRfXyAhPSBudWxsICYmIG9iai5fZG9jICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBvYmouX2RvYztcbiAgICB9XG5cbiAgICBsZXQgcmV0O1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuanNvbiAmJiB0eXBlb2Ygb2JqLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0ID0gb2JqLnRvSlNPTihvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0ID0gb2JqLnRvT2JqZWN0KG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMubWluaW1pemUgJiYgIW9iai5jb25zdHJ1Y3Rvci4kX19yZXF1aXJlZCAmJiBpc1NpbmdsZU5lc3RlZCAmJiBPYmplY3Qua2V5cyhyZXQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgY29uc3Qgb2JqQ29uc3RydWN0b3IgPSBvYmouY29uc3RydWN0b3I7XG5cbiAgaWYgKG9iakNvbnN0cnVjdG9yKSB7XG4gICAgc3dpdGNoIChnZXRGdW5jdGlvbk5hbWUob2JqQ29uc3RydWN0b3IpKSB7XG4gICAgICBjYXNlICdPYmplY3QnOlxuICAgICAgICByZXR1cm4gY2xvbmVPYmplY3Qob2JqLCBvcHRpb25zLCBpc0FycmF5Q2hpbGQpO1xuICAgICAgY2FzZSAnRGF0ZSc6XG4gICAgICAgIHJldHVybiBuZXcgb2JqQ29uc3RydWN0b3IoK29iaik7XG4gICAgICBjYXNlICdSZWdFeHAnOlxuICAgICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIGlnbm9yZVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoaXNCc29uVHlwZShvYmosICdPYmplY3RJZCcpKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5mbGF0dGVuT2JqZWN0SWRzKSB7XG4gICAgICByZXR1cm4gb2JqLnRvSlNPTigpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE9iamVjdElkKG9iai5pZCk7XG4gIH1cblxuICBpZiAoaXNCc29uVHlwZShvYmosICdEZWNpbWFsMTI4JykpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmZsYXR0ZW5EZWNpbWFscykge1xuICAgICAgcmV0dXJuIG9iai50b0pTT04oKTtcbiAgICB9XG4gICAgcmV0dXJuIERlY2ltYWwuZnJvbVN0cmluZyhvYmoudG9TdHJpbmcoKSk7XG4gIH1cblxuICAvLyBvYmplY3QgY3JlYXRlZCB3aXRoIE9iamVjdC5jcmVhdGUobnVsbClcbiAgaWYgKCFvYmpDb25zdHJ1Y3RvciAmJiBpc09iamVjdChvYmopKSB7XG4gICAgcmV0dXJuIGNsb25lT2JqZWN0KG9iaiwgb3B0aW9ucywgaXNBcnJheUNoaWxkKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmpbc3ltYm9scy5zY2hlbWFUeXBlU3ltYm9sXSkge1xuICAgIHJldHVybiBvYmouY2xvbmUoKTtcbiAgfVxuXG4gIC8vIElmIHdlJ3JlIGNsb25pbmcgdGhpcyBvYmplY3QgdG8gZ28gaW50byBhIE1vbmdvREIgY29tbWFuZCxcbiAgLy8gYW5kIHRoZXJlJ3MgYSBgdG9CU09OKClgIGZ1bmN0aW9uLCBhc3N1bWUgdGhpcyBvYmplY3Qgd2lsbCBiZVxuICAvLyBzdG9yZWQgYXMgYSBwcmltaXRpdmUgaW4gTW9uZ29EQiBhbmQgZG9lc24ndCBuZWVkIHRvIGJlIGNsb25lZC5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ic29uICYmIHR5cGVvZiBvYmoudG9CU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqLnZhbHVlT2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gb2JqLnZhbHVlT2YoKTtcbiAgfVxuXG4gIHJldHVybiBjbG9uZU9iamVjdChvYmosIG9wdGlvbnMsIGlzQXJyYXlDaGlsZCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGNsb25lT2JqZWN0KG9iaiwgb3B0aW9ucywgaXNBcnJheUNoaWxkKSB7XG4gIGNvbnN0IG1pbmltaXplID0gb3B0aW9ucyAmJiBvcHRpb25zLm1pbmltaXplO1xuICBjb25zdCBvbWl0VW5kZWZpbmVkID0gb3B0aW9ucyAmJiBvcHRpb25zLm9taXRVbmRlZmluZWQ7XG4gIGNvbnN0IHNlZW4gPSBvcHRpb25zICYmIG9wdGlvbnMuX3NlZW47XG4gIGNvbnN0IHJldCA9IHt9O1xuICBsZXQgaGFzS2V5cztcblxuICBpZiAoc2VlbiAmJiBzZWVuLmhhcyhvYmopKSB7XG4gICAgcmV0dXJuIHNlZW4uZ2V0KG9iaik7XG4gIH0gZWxzZSBpZiAoc2Vlbikge1xuICAgIHNlZW4uc2V0KG9iaiwgcmV0KTtcbiAgfVxuICBpZiAodHJ1c3RlZFN5bWJvbCBpbiBvYmopIHtcbiAgICByZXRbdHJ1c3RlZFN5bWJvbF0gPSBvYmpbdHJ1c3RlZFN5bWJvbF07XG4gIH1cblxuICBsZXQgaSA9IDA7XG4gIGxldCBrZXkgPSAnJztcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGNvbnN0IGxlbiA9IGtleXMubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChzcGVjaWFsUHJvcGVydGllcy5oYXMoa2V5ID0ga2V5c1tpXSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIERvbid0IHBhc3MgYGlzQXJyYXlDaGlsZGAgZG93blxuICAgIGNvbnN0IHZhbCA9IGNsb25lKG9ialtrZXldLCBvcHRpb25zLCBmYWxzZSk7XG5cbiAgICBpZiAoKG1pbmltaXplID09PSBmYWxzZSB8fCBvbWl0VW5kZWZpbmVkKSAmJiB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgZGVsZXRlIHJldFtrZXldO1xuICAgIH0gZWxzZSBpZiAobWluaW1pemUgIT09IHRydWUgfHwgKHR5cGVvZiB2YWwgIT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgaGFzS2V5cyB8fCAoaGFzS2V5cyA9IHRydWUpO1xuICAgICAgcmV0W2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1pbmltaXplICYmICFpc0FycmF5Q2hpbGQgPyBoYXNLZXlzICYmIHJldCA6IHJldDtcbn1cblxuZnVuY3Rpb24gY2xvbmVBcnJheShhcnIsIG9wdGlvbnMpIHtcbiAgbGV0IGkgPSAwO1xuICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xuICBjb25zdCByZXQgPSBuZXcgQXJyYXkobGVuKTtcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgcmV0W2ldID0gY2xvbmUoYXJyW2ldLCBvcHRpb25zLCB0cnVlKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGNsb25lUmVnRXhwKHJlZ2V4cCkge1xuICBjb25zdCByZXQgPSBuZXcgUmVnRXhwKHJlZ2V4cC5zb3VyY2UsIHJlZ2V4cC5mbGFncyk7XG5cbiAgaWYgKHJldC5sYXN0SW5kZXggIT09IHJlZ2V4cC5sYXN0SW5kZXgpIHtcbiAgICByZXQubGFzdEluZGV4ID0gcmVnZXhwLmxhc3RJbmRleDtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/clone.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/common.js":
/*!**************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/common.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst Binary = (__webpack_require__(/*! bson */ \"../backend/node_modules/bson/lib/bson.cjs\").Binary);\nconst isBsonType = __webpack_require__(/*! ./isBsonType */ \"../backend/node_modules/mongoose/lib/helpers/isBsonType.js\");\nconst isMongooseObject = __webpack_require__(/*! ./isMongooseObject */ \"../backend/node_modules/mongoose/lib/helpers/isMongooseObject.js\");\nconst MongooseError = __webpack_require__(/*! ../error */ \"../backend/node_modules/mongoose/lib/error/index.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\nexports.flatten = flatten;\nexports.modifiedPaths = modifiedPaths;\n\n/*!\n * ignore\n */\n\nfunction flatten(update, path, options, schema) {\n  let keys;\n  if (update && isMongooseObject(update) && !Buffer.isBuffer(update)) {\n    keys = Object.keys(update.toObject({ transform: false, virtuals: false }) || {});\n  } else {\n    keys = Object.keys(update || {});\n  }\n\n  const numKeys = keys.length;\n  const result = {};\n  path = path ? path + '.' : '';\n\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const val = update[key];\n    result[path + key] = val;\n\n    // Avoid going into mixed paths if schema is specified\n    const keySchema = schema && schema.path && schema.path(path + key);\n    const isNested = schema && schema.nested && schema.nested[path + key];\n    if (keySchema && keySchema.instance === 'Mixed') continue;\n\n    if (shouldFlatten(val)) {\n      if (options && options.skipArrays && Array.isArray(val)) {\n        continue;\n      }\n      const flat = flatten(val, path + key, options, schema);\n      for (const k in flat) {\n        result[k] = flat[k];\n      }\n      if (Array.isArray(val)) {\n        result[path + key] = val;\n      }\n    }\n\n    if (isNested) {\n      const paths = Object.keys(schema.paths);\n      for (const p of paths) {\n        if (p.startsWith(path + key + '.') && !result.hasOwnProperty(p)) {\n          result[p] = void 0;\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\n/*!\n * ignore\n */\n\nfunction modifiedPaths(update, path, result, recursion = null) {\n  if (update == null || typeof update !== 'object') {\n    return;\n  }\n\n  if (recursion == null) {\n    recursion = {\n      raw: { update, path },\n      trace: new WeakSet()\n    };\n  }\n\n  if (recursion.trace.has(update)) {\n    throw new MongooseError(`a circular reference in the update value, updateValue:\n${util.inspect(recursion.raw.update, { showHidden: false, depth: 1 })}\nupdatePath: '${recursion.raw.path}'`);\n  }\n  recursion.trace.add(update);\n\n  const keys = Object.keys(update || {});\n  const numKeys = keys.length;\n  result = result || {};\n  path = path ? path + '.' : '';\n\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    let val = update[key];\n\n    const _path = path + key;\n    result[_path] = true;\n    if (!Buffer.isBuffer(val) && isMongooseObject(val)) {\n      val = val.toObject({ transform: false, virtuals: false });\n    }\n    if (shouldFlatten(val)) {\n      modifiedPaths(val, path + key, result, recursion);\n    }\n  }\n  recursion.trace.delete(update);\n\n  return result;\n}\n\n/*!\n * ignore\n */\n\nfunction shouldFlatten(val) {\n  return val &&\n      typeof val === 'object' &&\n      !(val instanceof Date) &&\n      !isBsonType(val, 'ObjectId') &&\n      (!Array.isArray(val) || val.length !== 0) &&\n      !(val instanceof Buffer) &&\n      !isBsonType(val, 'Decimal128') &&\n      !(val instanceof Binary);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvY29tbW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLHFGQUFzQjtBQUNyQyxtQkFBbUIsbUJBQU8sQ0FBQyxnRkFBYztBQUN6Qyx5QkFBeUIsbUJBQU8sQ0FBQyw0RkFBb0I7QUFDckQsc0JBQXNCLG1CQUFPLENBQUMscUVBQVU7QUFDeEMsYUFBYSxtQkFBTyxDQUFDLGtCQUFNOztBQUUzQixlQUFlO0FBQ2YscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG1DQUFtQyxPQUFPO0FBQ25GLElBQUk7QUFDSixtQ0FBbUM7QUFDbkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFLHFDQUFxQyw2QkFBNkI7QUFDcEUsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTs7QUFFQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1DQUFtQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9jb21tb24uanM/ZWY2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBCaW5hcnkgPSByZXF1aXJlKCdic29uJykuQmluYXJ5O1xuY29uc3QgaXNCc29uVHlwZSA9IHJlcXVpcmUoJy4vaXNCc29uVHlwZScpO1xuY29uc3QgaXNNb25nb29zZU9iamVjdCA9IHJlcXVpcmUoJy4vaXNNb25nb29zZU9iamVjdCcpO1xuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5leHBvcnRzLmZsYXR0ZW4gPSBmbGF0dGVuO1xuZXhwb3J0cy5tb2RpZmllZFBhdGhzID0gbW9kaWZpZWRQYXRocztcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBmbGF0dGVuKHVwZGF0ZSwgcGF0aCwgb3B0aW9ucywgc2NoZW1hKSB7XG4gIGxldCBrZXlzO1xuICBpZiAodXBkYXRlICYmIGlzTW9uZ29vc2VPYmplY3QodXBkYXRlKSAmJiAhQnVmZmVyLmlzQnVmZmVyKHVwZGF0ZSkpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModXBkYXRlLnRvT2JqZWN0KHsgdHJhbnNmb3JtOiBmYWxzZSwgdmlydHVhbHM6IGZhbHNlIH0pIHx8IHt9KTtcbiAgfSBlbHNlIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModXBkYXRlIHx8IHt9KTtcbiAgfVxuXG4gIGNvbnN0IG51bUtleXMgPSBrZXlzLmxlbmd0aDtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIHBhdGggPSBwYXRoID8gcGF0aCArICcuJyA6ICcnO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtS2V5czsgKytpKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICBjb25zdCB2YWwgPSB1cGRhdGVba2V5XTtcbiAgICByZXN1bHRbcGF0aCArIGtleV0gPSB2YWw7XG5cbiAgICAvLyBBdm9pZCBnb2luZyBpbnRvIG1peGVkIHBhdGhzIGlmIHNjaGVtYSBpcyBzcGVjaWZpZWRcbiAgICBjb25zdCBrZXlTY2hlbWEgPSBzY2hlbWEgJiYgc2NoZW1hLnBhdGggJiYgc2NoZW1hLnBhdGgocGF0aCArIGtleSk7XG4gICAgY29uc3QgaXNOZXN0ZWQgPSBzY2hlbWEgJiYgc2NoZW1hLm5lc3RlZCAmJiBzY2hlbWEubmVzdGVkW3BhdGggKyBrZXldO1xuICAgIGlmIChrZXlTY2hlbWEgJiYga2V5U2NoZW1hLmluc3RhbmNlID09PSAnTWl4ZWQnKSBjb250aW51ZTtcblxuICAgIGlmIChzaG91bGRGbGF0dGVuKHZhbCkpIHtcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc2tpcEFycmF5cyAmJiBBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBmbGF0ID0gZmxhdHRlbih2YWwsIHBhdGggKyBrZXksIG9wdGlvbnMsIHNjaGVtYSk7XG4gICAgICBmb3IgKGNvbnN0IGsgaW4gZmxhdCkge1xuICAgICAgICByZXN1bHRba10gPSBmbGF0W2tdO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICByZXN1bHRbcGF0aCArIGtleV0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzTmVzdGVkKSB7XG4gICAgICBjb25zdCBwYXRocyA9IE9iamVjdC5rZXlzKHNjaGVtYS5wYXRocyk7XG4gICAgICBmb3IgKGNvbnN0IHAgb2YgcGF0aHMpIHtcbiAgICAgICAgaWYgKHAuc3RhcnRzV2l0aChwYXRoICsga2V5ICsgJy4nKSAmJiAhcmVzdWx0Lmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgICAgcmVzdWx0W3BdID0gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBtb2RpZmllZFBhdGhzKHVwZGF0ZSwgcGF0aCwgcmVzdWx0LCByZWN1cnNpb24gPSBudWxsKSB7XG4gIGlmICh1cGRhdGUgPT0gbnVsbCB8fCB0eXBlb2YgdXBkYXRlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChyZWN1cnNpb24gPT0gbnVsbCkge1xuICAgIHJlY3Vyc2lvbiA9IHtcbiAgICAgIHJhdzogeyB1cGRhdGUsIHBhdGggfSxcbiAgICAgIHRyYWNlOiBuZXcgV2Vha1NldCgpXG4gICAgfTtcbiAgfVxuXG4gIGlmIChyZWN1cnNpb24udHJhY2UuaGFzKHVwZGF0ZSkpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcihgYSBjaXJjdWxhciByZWZlcmVuY2UgaW4gdGhlIHVwZGF0ZSB2YWx1ZSwgdXBkYXRlVmFsdWU6XG4ke3V0aWwuaW5zcGVjdChyZWN1cnNpb24ucmF3LnVwZGF0ZSwgeyBzaG93SGlkZGVuOiBmYWxzZSwgZGVwdGg6IDEgfSl9XG51cGRhdGVQYXRoOiAnJHtyZWN1cnNpb24ucmF3LnBhdGh9J2ApO1xuICB9XG4gIHJlY3Vyc2lvbi50cmFjZS5hZGQodXBkYXRlKTtcblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModXBkYXRlIHx8IHt9KTtcbiAgY29uc3QgbnVtS2V5cyA9IGtleXMubGVuZ3RoO1xuICByZXN1bHQgPSByZXN1bHQgfHwge307XG4gIHBhdGggPSBwYXRoID8gcGF0aCArICcuJyA6ICcnO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtS2V5czsgKytpKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICBsZXQgdmFsID0gdXBkYXRlW2tleV07XG5cbiAgICBjb25zdCBfcGF0aCA9IHBhdGggKyBrZXk7XG4gICAgcmVzdWx0W19wYXRoXSA9IHRydWU7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodmFsKSAmJiBpc01vbmdvb3NlT2JqZWN0KHZhbCkpIHtcbiAgICAgIHZhbCA9IHZhbC50b09iamVjdCh7IHRyYW5zZm9ybTogZmFsc2UsIHZpcnR1YWxzOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgaWYgKHNob3VsZEZsYXR0ZW4odmFsKSkge1xuICAgICAgbW9kaWZpZWRQYXRocyh2YWwsIHBhdGggKyBrZXksIHJlc3VsdCwgcmVjdXJzaW9uKTtcbiAgICB9XG4gIH1cbiAgcmVjdXJzaW9uLnRyYWNlLmRlbGV0ZSh1cGRhdGUpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gc2hvdWxkRmxhdHRlbih2YWwpIHtcbiAgcmV0dXJuIHZhbCAmJlxuICAgICAgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICEodmFsIGluc3RhbmNlb2YgRGF0ZSkgJiZcbiAgICAgICFpc0Jzb25UeXBlKHZhbCwgJ09iamVjdElkJykgJiZcbiAgICAgICghQXJyYXkuaXNBcnJheSh2YWwpIHx8IHZhbC5sZW5ndGggIT09IDApICYmXG4gICAgICAhKHZhbCBpbnN0YW5jZW9mIEJ1ZmZlcikgJiZcbiAgICAgICFpc0Jzb25UeXBlKHZhbCwgJ0RlY2ltYWwxMjgnKSAmJlxuICAgICAgISh2YWwgaW5zdGFuY2VvZiBCaW5hcnkpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/common.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/cursor/eachAsync.js":
/*!************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/cursor/eachAsync.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst EachAsyncMultiError = __webpack_require__(/*! ../../error/eachAsyncMultiError */ \"../backend/node_modules/mongoose/lib/error/eachAsyncMultiError.js\");\nconst immediate = __webpack_require__(/*! ../immediate */ \"../backend/node_modules/mongoose/lib/helpers/immediate.js\");\n\n/**\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\n * will wait for the promise to resolve before iterating on to the next one.\n * Returns a promise that resolves when done.\n *\n * @param {Function} next the thunk to call to get the next document\n * @param {Function} fn\n * @param {Object} options\n * @param {Number} [options.batchSize=null] if set, Mongoose will call `fn` with an array of at most `batchSize` documents, instead of a single document\n * @param {Number} [options.parallel=1] maximum number of `fn` calls that Mongoose will run in parallel\n * @param {AbortSignal} [options.signal] allow cancelling this eachAsync(). Once the abort signal is fired, `eachAsync()` will immediately fulfill the returned promise (or call the callback) and not fetch any more documents.\n * @return {Promise}\n * @api public\n * @method eachAsync\n */\n\nmodule.exports = async function eachAsync(next, fn, options) {\n  const parallel = options.parallel || 1;\n  const batchSize = options.batchSize;\n  const signal = options.signal;\n  const continueOnError = options.continueOnError;\n  const aggregatedErrors = [];\n  const enqueue = asyncQueue();\n\n  let aborted = false;\n\n  return new Promise((resolve, reject) => {\n    if (signal != null) {\n      if (signal.aborted) {\n        return resolve(null);\n      }\n\n      signal.addEventListener('abort', () => {\n        aborted = true;\n        return resolve(null);\n      }, { once: true });\n    }\n\n    if (batchSize != null) {\n      if (typeof batchSize !== 'number') {\n        throw new TypeError('batchSize must be a number');\n      } else if (!Number.isInteger(batchSize)) {\n        throw new TypeError('batchSize must be an integer');\n      } else if (batchSize < 1) {\n        throw new TypeError('batchSize must be at least 1');\n      }\n    }\n\n    iterate((err, res) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n\n  function iterate(finalCallback) {\n    let handleResultsInProgress = 0;\n    let currentDocumentIndex = 0;\n\n    let error = null;\n    for (let i = 0; i < parallel; ++i) {\n      enqueue(createFetch());\n    }\n\n    function createFetch() {\n      let documentsBatch = [];\n      let drained = false;\n\n      return fetch;\n\n      function fetch(done) {\n        if (drained || aborted) {\n          return done();\n        } else if (error) {\n          return done();\n        }\n\n        next(function(err, doc) {\n          if (error != null) {\n            return done();\n          }\n          if (err != null) {\n            if (err.name === 'MongoCursorExhaustedError') {\n              // We may end up calling `next()` multiple times on an exhausted\n              // cursor, which leads to an error. In case cursor is exhausted,\n              // just treat it as if the cursor returned no document, which is\n              // how a cursor indicates it is exhausted.\n              doc = null;\n            } else if (continueOnError) {\n              aggregatedErrors.push(err);\n            } else {\n              error = err;\n              finalCallback(err);\n              return done();\n            }\n          }\n          if (doc == null) {\n            drained = true;\n            if (handleResultsInProgress <= 0) {\n              const finalErr = continueOnError ?\n                createEachAsyncMultiError(aggregatedErrors) :\n                error;\n\n              finalCallback(finalErr);\n            } else if (batchSize && documentsBatch.length) {\n              handleNextResult(documentsBatch, currentDocumentIndex++, handleNextResultCallBack);\n            }\n            return done();\n          }\n\n          ++handleResultsInProgress;\n\n          // Kick off the subsequent `next()` before handling the result, but\n          // make sure we know that we still have a result to handle re: #8422\n          immediate(() => done());\n\n          if (batchSize) {\n            documentsBatch.push(doc);\n          }\n\n          // If the current documents size is less than the provided batch size don't process the documents yet\n          if (batchSize && documentsBatch.length !== batchSize) {\n            immediate(() => enqueue(fetch));\n            return;\n          }\n\n          const docsToProcess = batchSize ? documentsBatch : doc;\n\n          function handleNextResultCallBack(err) {\n            if (batchSize) {\n              handleResultsInProgress -= documentsBatch.length;\n              documentsBatch = [];\n            } else {\n              --handleResultsInProgress;\n            }\n            if (err != null) {\n              if (continueOnError) {\n                aggregatedErrors.push(err);\n              } else {\n                error = err;\n                return finalCallback(err);\n              }\n            }\n            if ((drained || aborted) && handleResultsInProgress <= 0) {\n              const finalErr = continueOnError ?\n                createEachAsyncMultiError(aggregatedErrors) :\n                error;\n              return finalCallback(finalErr);\n            }\n\n            immediate(() => enqueue(fetch));\n          }\n\n          handleNextResult(docsToProcess, currentDocumentIndex++, handleNextResultCallBack);\n        });\n      }\n    }\n  }\n\n  function handleNextResult(doc, i, callback) {\n    let maybePromise;\n    try {\n      maybePromise = fn(doc, i);\n    } catch (err) {\n      return callback(err);\n    }\n    if (maybePromise && typeof maybePromise.then === 'function') {\n      maybePromise.then(\n        function() { callback(null); },\n        function(error) {\n          callback(error || new Error('`eachAsync()` promise rejected without error'));\n        });\n    } else {\n      callback(null);\n    }\n  }\n};\n\n// `next()` can only execute one at a time, so make sure we always execute\n// `next()` in series, while still allowing multiple `fn()` instances to run\n// in parallel.\nfunction asyncQueue() {\n  const _queue = [];\n  let inProgress = null;\n  let id = 0;\n\n  return function enqueue(fn) {\n    if (\n      inProgress === null &&\n      _queue.length === 0\n    ) {\n      inProgress = id++;\n      return fn(_step);\n    }\n    _queue.push(fn);\n  };\n\n  function _step() {\n    if (_queue.length !== 0) {\n      inProgress = id++;\n      const fn = _queue.shift();\n      fn(_step);\n    } else {\n      inProgress = null;\n    }\n  }\n}\n\nfunction createEachAsyncMultiError(aggregatedErrors) {\n  if (aggregatedErrors.length === 0) {\n    return null;\n  }\n\n  return new EachAsyncMultiError(aggregatedErrors);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvY3Vyc29yL2VhY2hBc3luYy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLG1CQUFPLENBQUMsMEdBQWlDO0FBQ3JFLGtCQUFrQixtQkFBTyxDQUFDLCtFQUFjOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGFBQWE7QUFDeEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sSUFBSSxZQUFZO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvY3Vyc29yL2VhY2hBc3luYy5qcz80Zjk0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IEVhY2hBc3luY011bHRpRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9lcnJvci9lYWNoQXN5bmNNdWx0aUVycm9yJyk7XG5jb25zdCBpbW1lZGlhdGUgPSByZXF1aXJlKCcuLi9pbW1lZGlhdGUnKTtcblxuLyoqXG4gKiBFeGVjdXRlIGBmbmAgZm9yIGV2ZXJ5IGRvY3VtZW50IGluIHRoZSBjdXJzb3IuIElmIGBmbmAgcmV0dXJucyBhIHByb21pc2UsXG4gKiB3aWxsIHdhaXQgZm9yIHRoZSBwcm9taXNlIHRvIHJlc29sdmUgYmVmb3JlIGl0ZXJhdGluZyBvbiB0byB0aGUgbmV4dCBvbmUuXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gZG9uZS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0IHRoZSB0aHVuayB0byBjYWxsIHRvIGdldCB0aGUgbmV4dCBkb2N1bWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYmF0Y2hTaXplPW51bGxdIGlmIHNldCwgTW9uZ29vc2Ugd2lsbCBjYWxsIGBmbmAgd2l0aCBhbiBhcnJheSBvZiBhdCBtb3N0IGBiYXRjaFNpemVgIGRvY3VtZW50cywgaW5zdGVhZCBvZiBhIHNpbmdsZSBkb2N1bWVudFxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBhcmFsbGVsPTFdIG1heGltdW0gbnVtYmVyIG9mIGBmbmAgY2FsbHMgdGhhdCBNb25nb29zZSB3aWxsIHJ1biBpbiBwYXJhbGxlbFxuICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gW29wdGlvbnMuc2lnbmFsXSBhbGxvdyBjYW5jZWxsaW5nIHRoaXMgZWFjaEFzeW5jKCkuIE9uY2UgdGhlIGFib3J0IHNpZ25hbCBpcyBmaXJlZCwgYGVhY2hBc3luYygpYCB3aWxsIGltbWVkaWF0ZWx5IGZ1bGZpbGwgdGhlIHJldHVybmVkIHByb21pc2UgKG9yIGNhbGwgdGhlIGNhbGxiYWNrKSBhbmQgbm90IGZldGNoIGFueSBtb3JlIGRvY3VtZW50cy5cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCBlYWNoQXN5bmNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFzeW5jIGZ1bmN0aW9uIGVhY2hBc3luYyhuZXh0LCBmbiwgb3B0aW9ucykge1xuICBjb25zdCBwYXJhbGxlbCA9IG9wdGlvbnMucGFyYWxsZWwgfHwgMTtcbiAgY29uc3QgYmF0Y2hTaXplID0gb3B0aW9ucy5iYXRjaFNpemU7XG4gIGNvbnN0IHNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsO1xuICBjb25zdCBjb250aW51ZU9uRXJyb3IgPSBvcHRpb25zLmNvbnRpbnVlT25FcnJvcjtcbiAgY29uc3QgYWdncmVnYXRlZEVycm9ycyA9IFtdO1xuICBjb25zdCBlbnF1ZXVlID0gYXN5bmNRdWV1ZSgpO1xuXG4gIGxldCBhYm9ydGVkID0gZmFsc2U7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBpZiAoc2lnbmFsICE9IG51bGwpIHtcbiAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShudWxsKTtcbiAgICAgIH1cblxuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4ge1xuICAgICAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUobnVsbCk7XG4gICAgICB9LCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgaWYgKGJhdGNoU2l6ZSAhPSBudWxsKSB7XG4gICAgICBpZiAodHlwZW9mIGJhdGNoU2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYmF0Y2hTaXplIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICAgIH0gZWxzZSBpZiAoIU51bWJlci5pc0ludGVnZXIoYmF0Y2hTaXplKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdiYXRjaFNpemUgbXVzdCBiZSBhbiBpbnRlZ2VyJyk7XG4gICAgICB9IGVsc2UgaWYgKGJhdGNoU2l6ZSA8IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYmF0Y2hTaXplIG11c3QgYmUgYXQgbGVhc3QgMScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGl0ZXJhdGUoKGVyciwgcmVzKSA9PiB7XG4gICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShyZXMpO1xuICAgIH0pO1xuICB9KTtcblxuICBmdW5jdGlvbiBpdGVyYXRlKGZpbmFsQ2FsbGJhY2spIHtcbiAgICBsZXQgaGFuZGxlUmVzdWx0c0luUHJvZ3Jlc3MgPSAwO1xuICAgIGxldCBjdXJyZW50RG9jdW1lbnRJbmRleCA9IDA7XG5cbiAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYWxsZWw7ICsraSkge1xuICAgICAgZW5xdWV1ZShjcmVhdGVGZXRjaCgpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVGZXRjaCgpIHtcbiAgICAgIGxldCBkb2N1bWVudHNCYXRjaCA9IFtdO1xuICAgICAgbGV0IGRyYWluZWQgPSBmYWxzZTtcblxuICAgICAgcmV0dXJuIGZldGNoO1xuXG4gICAgICBmdW5jdGlvbiBmZXRjaChkb25lKSB7XG4gICAgICAgIGlmIChkcmFpbmVkIHx8IGFib3J0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHQoZnVuY3Rpb24oZXJyLCBkb2MpIHtcbiAgICAgICAgICBpZiAoZXJyb3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoZXJyLm5hbWUgPT09ICdNb25nb0N1cnNvckV4aGF1c3RlZEVycm9yJykge1xuICAgICAgICAgICAgICAvLyBXZSBtYXkgZW5kIHVwIGNhbGxpbmcgYG5leHQoKWAgbXVsdGlwbGUgdGltZXMgb24gYW4gZXhoYXVzdGVkXG4gICAgICAgICAgICAgIC8vIGN1cnNvciwgd2hpY2ggbGVhZHMgdG8gYW4gZXJyb3IuIEluIGNhc2UgY3Vyc29yIGlzIGV4aGF1c3RlZCxcbiAgICAgICAgICAgICAgLy8ganVzdCB0cmVhdCBpdCBhcyBpZiB0aGUgY3Vyc29yIHJldHVybmVkIG5vIGRvY3VtZW50LCB3aGljaCBpc1xuICAgICAgICAgICAgICAvLyBob3cgYSBjdXJzb3IgaW5kaWNhdGVzIGl0IGlzIGV4aGF1c3RlZC5cbiAgICAgICAgICAgICAgZG9jID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29udGludWVPbkVycm9yKSB7XG4gICAgICAgICAgICAgIGFnZ3JlZ2F0ZWRFcnJvcnMucHVzaChlcnIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgIGZpbmFsQ2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRvYyA9PSBudWxsKSB7XG4gICAgICAgICAgICBkcmFpbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChoYW5kbGVSZXN1bHRzSW5Qcm9ncmVzcyA8PSAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGZpbmFsRXJyID0gY29udGludWVPbkVycm9yID9cbiAgICAgICAgICAgICAgICBjcmVhdGVFYWNoQXN5bmNNdWx0aUVycm9yKGFnZ3JlZ2F0ZWRFcnJvcnMpIDpcbiAgICAgICAgICAgICAgICBlcnJvcjtcblxuICAgICAgICAgICAgICBmaW5hbENhbGxiYWNrKGZpbmFsRXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYmF0Y2hTaXplICYmIGRvY3VtZW50c0JhdGNoLmxlbmd0aCkge1xuICAgICAgICAgICAgICBoYW5kbGVOZXh0UmVzdWx0KGRvY3VtZW50c0JhdGNoLCBjdXJyZW50RG9jdW1lbnRJbmRleCsrLCBoYW5kbGVOZXh0UmVzdWx0Q2FsbEJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICArK2hhbmRsZVJlc3VsdHNJblByb2dyZXNzO1xuXG4gICAgICAgICAgLy8gS2ljayBvZmYgdGhlIHN1YnNlcXVlbnQgYG5leHQoKWAgYmVmb3JlIGhhbmRsaW5nIHRoZSByZXN1bHQsIGJ1dFxuICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBrbm93IHRoYXQgd2Ugc3RpbGwgaGF2ZSBhIHJlc3VsdCB0byBoYW5kbGUgcmU6ICM4NDIyXG4gICAgICAgICAgaW1tZWRpYXRlKCgpID0+IGRvbmUoKSk7XG5cbiAgICAgICAgICBpZiAoYmF0Y2hTaXplKSB7XG4gICAgICAgICAgICBkb2N1bWVudHNCYXRjaC5wdXNoKGRvYyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgZG9jdW1lbnRzIHNpemUgaXMgbGVzcyB0aGFuIHRoZSBwcm92aWRlZCBiYXRjaCBzaXplIGRvbid0IHByb2Nlc3MgdGhlIGRvY3VtZW50cyB5ZXRcbiAgICAgICAgICBpZiAoYmF0Y2hTaXplICYmIGRvY3VtZW50c0JhdGNoLmxlbmd0aCAhPT0gYmF0Y2hTaXplKSB7XG4gICAgICAgICAgICBpbW1lZGlhdGUoKCkgPT4gZW5xdWV1ZShmZXRjaCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGRvY3NUb1Byb2Nlc3MgPSBiYXRjaFNpemUgPyBkb2N1bWVudHNCYXRjaCA6IGRvYztcblxuICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZU5leHRSZXN1bHRDYWxsQmFjayhlcnIpIHtcbiAgICAgICAgICAgIGlmIChiYXRjaFNpemUpIHtcbiAgICAgICAgICAgICAgaGFuZGxlUmVzdWx0c0luUHJvZ3Jlc3MgLT0gZG9jdW1lbnRzQmF0Y2gubGVuZ3RoO1xuICAgICAgICAgICAgICBkb2N1bWVudHNCYXRjaCA9IFtdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLS1oYW5kbGVSZXN1bHRzSW5Qcm9ncmVzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAoY29udGludWVPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgYWdncmVnYXRlZEVycm9ycy5wdXNoKGVycik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbmFsQ2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChkcmFpbmVkIHx8IGFib3J0ZWQpICYmIGhhbmRsZVJlc3VsdHNJblByb2dyZXNzIDw9IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgZmluYWxFcnIgPSBjb250aW51ZU9uRXJyb3IgP1xuICAgICAgICAgICAgICAgIGNyZWF0ZUVhY2hBc3luY011bHRpRXJyb3IoYWdncmVnYXRlZEVycm9ycykgOlxuICAgICAgICAgICAgICAgIGVycm9yO1xuICAgICAgICAgICAgICByZXR1cm4gZmluYWxDYWxsYmFjayhmaW5hbEVycik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGltbWVkaWF0ZSgoKSA9PiBlbnF1ZXVlKGZldGNoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaGFuZGxlTmV4dFJlc3VsdChkb2NzVG9Qcm9jZXNzLCBjdXJyZW50RG9jdW1lbnRJbmRleCsrLCBoYW5kbGVOZXh0UmVzdWx0Q2FsbEJhY2spO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVOZXh0UmVzdWx0KGRvYywgaSwgY2FsbGJhY2spIHtcbiAgICBsZXQgbWF5YmVQcm9taXNlO1xuICAgIHRyeSB7XG4gICAgICBtYXliZVByb21pc2UgPSBmbihkb2MsIGkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgfVxuICAgIGlmIChtYXliZVByb21pc2UgJiYgdHlwZW9mIG1heWJlUHJvbWlzZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBtYXliZVByb21pc2UudGhlbihcbiAgICAgICAgZnVuY3Rpb24oKSB7IGNhbGxiYWNrKG51bGwpOyB9LFxuICAgICAgICBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIGNhbGxiYWNrKGVycm9yIHx8IG5ldyBFcnJvcignYGVhY2hBc3luYygpYCBwcm9taXNlIHJlamVjdGVkIHdpdGhvdXQgZXJyb3InKSk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayhudWxsKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGBuZXh0KClgIGNhbiBvbmx5IGV4ZWN1dGUgb25lIGF0IGEgdGltZSwgc28gbWFrZSBzdXJlIHdlIGFsd2F5cyBleGVjdXRlXG4vLyBgbmV4dCgpYCBpbiBzZXJpZXMsIHdoaWxlIHN0aWxsIGFsbG93aW5nIG11bHRpcGxlIGBmbigpYCBpbnN0YW5jZXMgdG8gcnVuXG4vLyBpbiBwYXJhbGxlbC5cbmZ1bmN0aW9uIGFzeW5jUXVldWUoKSB7XG4gIGNvbnN0IF9xdWV1ZSA9IFtdO1xuICBsZXQgaW5Qcm9ncmVzcyA9IG51bGw7XG4gIGxldCBpZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGVucXVldWUoZm4pIHtcbiAgICBpZiAoXG4gICAgICBpblByb2dyZXNzID09PSBudWxsICYmXG4gICAgICBfcXVldWUubGVuZ3RoID09PSAwXG4gICAgKSB7XG4gICAgICBpblByb2dyZXNzID0gaWQrKztcbiAgICAgIHJldHVybiBmbihfc3RlcCk7XG4gICAgfVxuICAgIF9xdWV1ZS5wdXNoKGZuKTtcbiAgfTtcblxuICBmdW5jdGlvbiBfc3RlcCgpIHtcbiAgICBpZiAoX3F1ZXVlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgaW5Qcm9ncmVzcyA9IGlkKys7XG4gICAgICBjb25zdCBmbiA9IF9xdWV1ZS5zaGlmdCgpO1xuICAgICAgZm4oX3N0ZXApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpblByb2dyZXNzID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWFjaEFzeW5jTXVsdGlFcnJvcihhZ2dyZWdhdGVkRXJyb3JzKSB7XG4gIGlmIChhZ2dyZWdhdGVkRXJyb3JzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBFYWNoQXN5bmNNdWx0aUVycm9yKGFnZ3JlZ2F0ZWRFcnJvcnMpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/cursor/eachAsync.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/discriminator/applyEmbeddedDiscriminators.js":
/*!*************************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/discriminator/applyEmbeddedDiscriminators.js ***!
  \*************************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = applyEmbeddedDiscriminators;\n\nfunction applyEmbeddedDiscriminators(schema, seen = new WeakSet(), overwriteExisting = false) {\n  if (seen.has(schema)) {\n    return;\n  }\n  seen.add(schema);\n  for (const path of Object.keys(schema.paths)) {\n    const schemaType = schema.paths[path];\n    if (!schemaType.schema) {\n      continue;\n    }\n    applyEmbeddedDiscriminators(schemaType.schema, seen);\n    if (!schemaType.schema._applyDiscriminators) {\n      continue;\n    }\n    if (schemaType._appliedDiscriminators && !overwriteExisting) {\n      continue;\n    }\n    for (const discriminatorKey of schemaType.schema._applyDiscriminators.keys()) {\n      const {\n        schema: discriminatorSchema,\n        options\n      } = schemaType.schema._applyDiscriminators.get(discriminatorKey);\n      applyEmbeddedDiscriminators(discriminatorSchema, seen);\n      schemaType.discriminator(\n        discriminatorKey,\n        discriminatorSchema,\n        overwriteExisting ? { ...options, overwriteExisting: true } : options\n      );\n    }\n    schemaType._appliedDiscriminators = true;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZGlzY3JpbWluYXRvci9hcHBseUVtYmVkZGVkRGlzY3JpbWluYXRvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHNDQUFzQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZGlzY3JpbWluYXRvci9hcHBseUVtYmVkZGVkRGlzY3JpbWluYXRvcnMuanM/MGU0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gYXBwbHlFbWJlZGRlZERpc2NyaW1pbmF0b3JzO1xuXG5mdW5jdGlvbiBhcHBseUVtYmVkZGVkRGlzY3JpbWluYXRvcnMoc2NoZW1hLCBzZWVuID0gbmV3IFdlYWtTZXQoKSwgb3ZlcndyaXRlRXhpc3RpbmcgPSBmYWxzZSkge1xuICBpZiAoc2Vlbi5oYXMoc2NoZW1hKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBzZWVuLmFkZChzY2hlbWEpO1xuICBmb3IgKGNvbnN0IHBhdGggb2YgT2JqZWN0LmtleXMoc2NoZW1hLnBhdGhzKSkge1xuICAgIGNvbnN0IHNjaGVtYVR5cGUgPSBzY2hlbWEucGF0aHNbcGF0aF07XG4gICAgaWYgKCFzY2hlbWFUeXBlLnNjaGVtYSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGFwcGx5RW1iZWRkZWREaXNjcmltaW5hdG9ycyhzY2hlbWFUeXBlLnNjaGVtYSwgc2Vlbik7XG4gICAgaWYgKCFzY2hlbWFUeXBlLnNjaGVtYS5fYXBwbHlEaXNjcmltaW5hdG9ycykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChzY2hlbWFUeXBlLl9hcHBsaWVkRGlzY3JpbWluYXRvcnMgJiYgIW92ZXJ3cml0ZUV4aXN0aW5nKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBkaXNjcmltaW5hdG9yS2V5IG9mIHNjaGVtYVR5cGUuc2NoZW1hLl9hcHBseURpc2NyaW1pbmF0b3JzLmtleXMoKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzY2hlbWE6IGRpc2NyaW1pbmF0b3JTY2hlbWEsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH0gPSBzY2hlbWFUeXBlLnNjaGVtYS5fYXBwbHlEaXNjcmltaW5hdG9ycy5nZXQoZGlzY3JpbWluYXRvcktleSk7XG4gICAgICBhcHBseUVtYmVkZGVkRGlzY3JpbWluYXRvcnMoZGlzY3JpbWluYXRvclNjaGVtYSwgc2Vlbik7XG4gICAgICBzY2hlbWFUeXBlLmRpc2NyaW1pbmF0b3IoXG4gICAgICAgIGRpc2NyaW1pbmF0b3JLZXksXG4gICAgICAgIGRpc2NyaW1pbmF0b3JTY2hlbWEsXG4gICAgICAgIG92ZXJ3cml0ZUV4aXN0aW5nID8geyAuLi5vcHRpb25zLCBvdmVyd3JpdGVFeGlzdGluZzogdHJ1ZSB9IDogb3B0aW9uc1xuICAgICAgKTtcbiAgICB9XG4gICAgc2NoZW1hVHlwZS5fYXBwbGllZERpc2NyaW1pbmF0b3JzID0gdHJ1ZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/discriminator/applyEmbeddedDiscriminators.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/discriminator/areDiscriminatorValuesEqual.js":
/*!*************************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/discriminator/areDiscriminatorValuesEqual.js ***!
  \*************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst isBsonType = __webpack_require__(/*! ../isBsonType */ \"../backend/node_modules/mongoose/lib/helpers/isBsonType.js\");\n\nmodule.exports = function areDiscriminatorValuesEqual(a, b) {\n  if (typeof a === 'string' && typeof b === 'string') {\n    return a === b;\n  }\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a === b;\n  }\n  if (isBsonType(a, 'ObjectId') && isBsonType(b, 'ObjectId')) {\n    return a.toString() === b.toString();\n  }\n  return false;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZGlzY3JpbWluYXRvci9hcmVEaXNjcmltaW5hdG9yVmFsdWVzRXF1YWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsbUJBQW1CLG1CQUFPLENBQUMsaUZBQWU7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2Rpc2NyaW1pbmF0b3IvYXJlRGlzY3JpbWluYXRvclZhbHVlc0VxdWFsLmpzP2Y0M2QiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpc0Jzb25UeXBlID0gcmVxdWlyZSgnLi4vaXNCc29uVHlwZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFyZURpc2NyaW1pbmF0b3JWYWx1ZXNFcXVhbChhLCBiKSB7XG4gIGlmICh0eXBlb2YgYSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGIgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIH1cbiAgaWYgKHR5cGVvZiBhID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYiA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gYSA9PT0gYjtcbiAgfVxuICBpZiAoaXNCc29uVHlwZShhLCAnT2JqZWN0SWQnKSAmJiBpc0Jzb25UeXBlKGIsICdPYmplY3RJZCcpKSB7XG4gICAgcmV0dXJuIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/discriminator/areDiscriminatorValuesEqual.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection.js":
/*!*************************************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection.js ***!
  \*************************************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function checkEmbeddedDiscriminatorKeyProjection(userProjection, path, schema, selected, addedPaths) {\n  const userProjectedInPath = Object.keys(userProjection).\n    reduce((cur, key) => cur || key.startsWith(path + '.'), false);\n  const _discriminatorKey = path + '.' + schema.options.discriminatorKey;\n  if (!userProjectedInPath &&\n      addedPaths.length === 1 &&\n      addedPaths[0] === _discriminatorKey) {\n    selected.splice(selected.indexOf(_discriminatorKey), 1);\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZGlzY3JpbWluYXRvci9jaGVja0VtYmVkZGVkRGlzY3JpbWluYXRvcktleVByb2plY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kaXNjcmltaW5hdG9yL2NoZWNrRW1iZWRkZWREaXNjcmltaW5hdG9yS2V5UHJvamVjdGlvbi5qcz9kZjQ2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjaGVja0VtYmVkZGVkRGlzY3JpbWluYXRvcktleVByb2plY3Rpb24odXNlclByb2plY3Rpb24sIHBhdGgsIHNjaGVtYSwgc2VsZWN0ZWQsIGFkZGVkUGF0aHMpIHtcbiAgY29uc3QgdXNlclByb2plY3RlZEluUGF0aCA9IE9iamVjdC5rZXlzKHVzZXJQcm9qZWN0aW9uKS5cbiAgICByZWR1Y2UoKGN1ciwga2V5KSA9PiBjdXIgfHwga2V5LnN0YXJ0c1dpdGgocGF0aCArICcuJyksIGZhbHNlKTtcbiAgY29uc3QgX2Rpc2NyaW1pbmF0b3JLZXkgPSBwYXRoICsgJy4nICsgc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleTtcbiAgaWYgKCF1c2VyUHJvamVjdGVkSW5QYXRoICYmXG4gICAgICBhZGRlZFBhdGhzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgYWRkZWRQYXRoc1swXSA9PT0gX2Rpc2NyaW1pbmF0b3JLZXkpIHtcbiAgICBzZWxlY3RlZC5zcGxpY2Uoc2VsZWN0ZWQuaW5kZXhPZihfZGlzY3JpbWluYXRvcktleSksIDEpO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/discriminator/getConstructor.js":
/*!************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/discriminator/getConstructor.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst getDiscriminatorByValue = __webpack_require__(/*! ./getDiscriminatorByValue */ \"../backend/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\n\n/**\n * Find the correct constructor, taking into account discriminators\n * @api private\n */\n\nmodule.exports = function getConstructor(Constructor, value, defaultDiscriminatorValue) {\n  const discriminatorKey = Constructor.schema.options.discriminatorKey;\n  let discriminatorValue = (value != null && value[discriminatorKey]);\n  if (discriminatorValue == null) {\n    discriminatorValue = defaultDiscriminatorValue;\n  }\n  if (Constructor.discriminators &&\n      discriminatorValue != null) {\n    if (Constructor.discriminators[discriminatorValue]) {\n      Constructor = Constructor.discriminators[discriminatorValue];\n    } else {\n      const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, discriminatorValue);\n      if (constructorByValue) {\n        Constructor = constructorByValue;\n      }\n    }\n  }\n\n  return Constructor;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZGlzY3JpbWluYXRvci9nZXRDb25zdHJ1Y3Rvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixnQ0FBZ0MsbUJBQU8sQ0FBQyx3SEFBMkI7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZGlzY3JpbWluYXRvci9nZXRDb25zdHJ1Y3Rvci5qcz80MWVkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUgPSByZXF1aXJlKCcuL2dldERpc2NyaW1pbmF0b3JCeVZhbHVlJyk7XG5cbi8qKlxuICogRmluZCB0aGUgY29ycmVjdCBjb25zdHJ1Y3RvciwgdGFraW5nIGludG8gYWNjb3VudCBkaXNjcmltaW5hdG9yc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRDb25zdHJ1Y3RvcihDb25zdHJ1Y3RvciwgdmFsdWUsIGRlZmF1bHREaXNjcmltaW5hdG9yVmFsdWUpIHtcbiAgY29uc3QgZGlzY3JpbWluYXRvcktleSA9IENvbnN0cnVjdG9yLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXk7XG4gIGxldCBkaXNjcmltaW5hdG9yVmFsdWUgPSAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZVtkaXNjcmltaW5hdG9yS2V5XSk7XG4gIGlmIChkaXNjcmltaW5hdG9yVmFsdWUgPT0gbnVsbCkge1xuICAgIGRpc2NyaW1pbmF0b3JWYWx1ZSA9IGRlZmF1bHREaXNjcmltaW5hdG9yVmFsdWU7XG4gIH1cbiAgaWYgKENvbnN0cnVjdG9yLmRpc2NyaW1pbmF0b3JzICYmXG4gICAgICBkaXNjcmltaW5hdG9yVmFsdWUgIT0gbnVsbCkge1xuICAgIGlmIChDb25zdHJ1Y3Rvci5kaXNjcmltaW5hdG9yc1tkaXNjcmltaW5hdG9yVmFsdWVdKSB7XG4gICAgICBDb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yLmRpc2NyaW1pbmF0b3JzW2Rpc2NyaW1pbmF0b3JWYWx1ZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbnN0cnVjdG9yQnlWYWx1ZSA9IGdldERpc2NyaW1pbmF0b3JCeVZhbHVlKENvbnN0cnVjdG9yLmRpc2NyaW1pbmF0b3JzLCBkaXNjcmltaW5hdG9yVmFsdWUpO1xuICAgICAgaWYgKGNvbnN0cnVjdG9yQnlWYWx1ZSkge1xuICAgICAgICBDb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yQnlWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gQ29uc3RydWN0b3I7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/discriminator/getConstructor.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js":
/*!*********************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js ***!
  \*********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst areDiscriminatorValuesEqual = __webpack_require__(/*! ./areDiscriminatorValuesEqual */ \"../backend/node_modules/mongoose/lib/helpers/discriminator/areDiscriminatorValuesEqual.js\");\n\n/**\n * returns discriminator by discriminatorMapping.value\n *\n * @param {Object} discriminators\n * @param {string} value\n * @api private\n */\n\nmodule.exports = function getDiscriminatorByValue(discriminators, value) {\n  if (discriminators == null) {\n    return null;\n  }\n  for (const name of Object.keys(discriminators)) {\n    const it = discriminators[name];\n    if (\n      it.schema &&\n      it.schema.discriminatorMapping &&\n      areDiscriminatorValuesEqual(it.schema.discriminatorMapping.value, value)\n    ) {\n      return it;\n    }\n  }\n  return null;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZGlzY3JpbWluYXRvci9nZXREaXNjcmltaW5hdG9yQnlWYWx1ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixvQ0FBb0MsbUJBQU8sQ0FBQyxnSUFBK0I7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2Rpc2NyaW1pbmF0b3IvZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUuanM/ZGZjNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGFyZURpc2NyaW1pbmF0b3JWYWx1ZXNFcXVhbCA9IHJlcXVpcmUoJy4vYXJlRGlzY3JpbWluYXRvclZhbHVlc0VxdWFsJyk7XG5cbi8qKlxuICogcmV0dXJucyBkaXNjcmltaW5hdG9yIGJ5IGRpc2NyaW1pbmF0b3JNYXBwaW5nLnZhbHVlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRpc2NyaW1pbmF0b3JzXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUoZGlzY3JpbWluYXRvcnMsIHZhbHVlKSB7XG4gIGlmIChkaXNjcmltaW5hdG9ycyA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKGRpc2NyaW1pbmF0b3JzKSkge1xuICAgIGNvbnN0IGl0ID0gZGlzY3JpbWluYXRvcnNbbmFtZV07XG4gICAgaWYgKFxuICAgICAgaXQuc2NoZW1hICYmXG4gICAgICBpdC5zY2hlbWEuZGlzY3JpbWluYXRvck1hcHBpbmcgJiZcbiAgICAgIGFyZURpc2NyaW1pbmF0b3JWYWx1ZXNFcXVhbChpdC5zY2hlbWEuZGlzY3JpbWluYXRvck1hcHBpbmcudmFsdWUsIHZhbHVlKVxuICAgICkge1xuICAgICAgcmV0dXJuIGl0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js":
/*!***************************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js ***!
  \***************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst areDiscriminatorValuesEqual = __webpack_require__(/*! ./areDiscriminatorValuesEqual */ \"../backend/node_modules/mongoose/lib/helpers/discriminator/areDiscriminatorValuesEqual.js\");\n\n/**\n * returns discriminator by discriminatorMapping.value\n *\n * @param {Schema} schema\n * @param {string} value\n * @api private\n */\n\nmodule.exports = function getSchemaDiscriminatorByValue(schema, value) {\n  if (schema == null || schema.discriminators == null) {\n    return null;\n  }\n  for (const key of Object.keys(schema.discriminators)) {\n    const discriminatorSchema = schema.discriminators[key];\n    if (discriminatorSchema.discriminatorMapping == null) {\n      continue;\n    }\n    if (areDiscriminatorValuesEqual(discriminatorSchema.discriminatorMapping.value, value)) {\n      return discriminatorSchema;\n    }\n  }\n  return null;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZGlzY3JpbWluYXRvci9nZXRTY2hlbWFEaXNjcmltaW5hdG9yQnlWYWx1ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixvQ0FBb0MsbUJBQU8sQ0FBQyxnSUFBK0I7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kaXNjcmltaW5hdG9yL2dldFNjaGVtYURpc2NyaW1pbmF0b3JCeVZhbHVlLmpzP2Q5YzAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBhcmVEaXNjcmltaW5hdG9yVmFsdWVzRXF1YWwgPSByZXF1aXJlKCcuL2FyZURpc2NyaW1pbmF0b3JWYWx1ZXNFcXVhbCcpO1xuXG4vKipcbiAqIHJldHVybnMgZGlzY3JpbWluYXRvciBieSBkaXNjcmltaW5hdG9yTWFwcGluZy52YWx1ZVxuICpcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRTY2hlbWFEaXNjcmltaW5hdG9yQnlWYWx1ZShzY2hlbWEsIHZhbHVlKSB7XG4gIGlmIChzY2hlbWEgPT0gbnVsbCB8fCBzY2hlbWEuZGlzY3JpbWluYXRvcnMgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjaGVtYS5kaXNjcmltaW5hdG9ycykpIHtcbiAgICBjb25zdCBkaXNjcmltaW5hdG9yU2NoZW1hID0gc2NoZW1hLmRpc2NyaW1pbmF0b3JzW2tleV07XG4gICAgaWYgKGRpc2NyaW1pbmF0b3JTY2hlbWEuZGlzY3JpbWluYXRvck1hcHBpbmcgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChhcmVEaXNjcmltaW5hdG9yVmFsdWVzRXF1YWwoZGlzY3JpbWluYXRvclNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZy52YWx1ZSwgdmFsdWUpKSB7XG4gICAgICByZXR1cm4gZGlzY3JpbWluYXRvclNjaGVtYTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/discriminator/mergeDiscriminatorSchema.js":
/*!**********************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/discriminator/mergeDiscriminatorSchema.js ***!
  \**********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst schemaMerge = __webpack_require__(/*! ../schema/merge */ \"../backend/node_modules/mongoose/lib/helpers/schema/merge.js\");\nconst specialProperties = __webpack_require__(/*! ../../helpers/specialProperties */ \"../backend/node_modules/mongoose/lib/helpers/specialProperties.js\");\nconst isBsonType = __webpack_require__(/*! ../../helpers/isBsonType */ \"../backend/node_modules/mongoose/lib/helpers/isBsonType.js\");\nconst ObjectId = __webpack_require__(/*! ../../types/objectid */ \"../backend/node_modules/mongoose/lib/types/objectid.js\");\nconst isObject = __webpack_require__(/*! ../../helpers/isObject */ \"../backend/node_modules/mongoose/lib/helpers/isObject.js\");\n/**\n * Merges `from` into `to` without overwriting existing properties.\n *\n * @param {Object} to\n * @param {Object} from\n * @param {String} [path]\n * @api private\n */\n\nmodule.exports = function mergeDiscriminatorSchema(to, from, path, seen) {\n  const keys = Object.keys(from);\n  let i = 0;\n  const len = keys.length;\n  let key;\n\n  path = path || '';\n  seen = seen || new WeakSet();\n\n  if (seen.has(from)) {\n    return;\n  }\n  seen.add(from);\n\n  while (i < len) {\n    key = keys[i++];\n    if (!path) {\n      if (key === 'discriminators' ||\n        key === 'base' ||\n        key === '_applyDiscriminators' ||\n        key === '_userProvidedOptions' ||\n        key === 'options' ||\n        key === 'tree') {\n        continue;\n      }\n    }\n    if (path === 'tree' && from != null && from.instanceOfSchema) {\n      continue;\n    }\n    if (specialProperties.has(key)) {\n      continue;\n    }\n    if (to[key] == null) {\n      to[key] = from[key];\n    } else if (isObject(from[key])) {\n      if (!isObject(to[key])) {\n        to[key] = {};\n      }\n      if (from[key] != null) {\n        // Skip merging schemas if we're creating a discriminator schema and\n        // base schema has a given path as a single nested but discriminator schema\n        // has the path as a document array, or vice versa (gh-9534)\n        if ((from[key].$isSingleNested && to[key].$isMongooseDocumentArray) ||\n              (from[key].$isMongooseDocumentArray && to[key].$isSingleNested) ||\n              (from[key].$isMongooseDocumentArrayElement && to[key].$isMongooseDocumentArrayElement)) {\n          continue;\n        } else if (from[key].instanceOfSchema) {\n          if (to[key].instanceOfSchema) {\n            schemaMerge(to[key], from[key].clone(), true);\n          } else {\n            to[key] = from[key].clone();\n          }\n          continue;\n        } else if (isBsonType(from[key], 'ObjectId')) {\n          to[key] = new ObjectId(from[key]);\n          continue;\n        }\n      }\n      mergeDiscriminatorSchema(to[key], from[key], path ? path + '.' + key : key, seen);\n    }\n  }\n\n  if (from != null && from.instanceOfSchema) {\n    to.tree = Object.assign({}, from.tree, to.tree);\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZGlzY3JpbWluYXRvci9tZXJnZURpc2NyaW1pbmF0b3JTY2hlbWEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixvQkFBb0IsbUJBQU8sQ0FBQyxxRkFBaUI7QUFDN0MsMEJBQTBCLG1CQUFPLENBQUMsMEdBQWlDO0FBQ25FLG1CQUFtQixtQkFBTyxDQUFDLDRGQUEwQjtBQUNyRCxpQkFBaUIsbUJBQU8sQ0FBQyxvRkFBc0I7QUFDL0MsaUJBQWlCLG1CQUFPLENBQUMsd0ZBQXdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZGlzY3JpbWluYXRvci9tZXJnZURpc2NyaW1pbmF0b3JTY2hlbWEuanM/YmJlNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBzY2hlbWFNZXJnZSA9IHJlcXVpcmUoJy4uL3NjaGVtYS9tZXJnZScpO1xuY29uc3Qgc3BlY2lhbFByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXJzL3NwZWNpYWxQcm9wZXJ0aWVzJyk7XG5jb25zdCBpc0Jzb25UeXBlID0gcmVxdWlyZSgnLi4vLi4vaGVscGVycy9pc0Jzb25UeXBlJyk7XG5jb25zdCBPYmplY3RJZCA9IHJlcXVpcmUoJy4uLy4uL3R5cGVzL29iamVjdGlkJyk7XG5jb25zdCBpc09iamVjdCA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvaXNPYmplY3QnKTtcbi8qKlxuICogTWVyZ2VzIGBmcm9tYCBpbnRvIGB0b2Agd2l0aG91dCBvdmVyd3JpdGluZyBleGlzdGluZyBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b1xuICogQHBhcmFtIHtPYmplY3R9IGZyb21cbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWVyZ2VEaXNjcmltaW5hdG9yU2NoZW1hKHRvLCBmcm9tLCBwYXRoLCBzZWVuKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhmcm9tKTtcbiAgbGV0IGkgPSAwO1xuICBjb25zdCBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgbGV0IGtleTtcblxuICBwYXRoID0gcGF0aCB8fCAnJztcbiAgc2VlbiA9IHNlZW4gfHwgbmV3IFdlYWtTZXQoKTtcblxuICBpZiAoc2Vlbi5oYXMoZnJvbSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc2Vlbi5hZGQoZnJvbSk7XG5cbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICBrZXkgPSBrZXlzW2krK107XG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICBpZiAoa2V5ID09PSAnZGlzY3JpbWluYXRvcnMnIHx8XG4gICAgICAgIGtleSA9PT0gJ2Jhc2UnIHx8XG4gICAgICAgIGtleSA9PT0gJ19hcHBseURpc2NyaW1pbmF0b3JzJyB8fFxuICAgICAgICBrZXkgPT09ICdfdXNlclByb3ZpZGVkT3B0aW9ucycgfHxcbiAgICAgICAga2V5ID09PSAnb3B0aW9ucycgfHxcbiAgICAgICAga2V5ID09PSAndHJlZScpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXRoID09PSAndHJlZScgJiYgZnJvbSAhPSBudWxsICYmIGZyb20uaW5zdGFuY2VPZlNjaGVtYSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChzcGVjaWFsUHJvcGVydGllcy5oYXMoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICh0b1trZXldID09IG51bGwpIHtcbiAgICAgIHRvW2tleV0gPSBmcm9tW2tleV07XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChmcm9tW2tleV0pKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KHRvW2tleV0pKSB7XG4gICAgICAgIHRvW2tleV0gPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChmcm9tW2tleV0gIT0gbnVsbCkge1xuICAgICAgICAvLyBTa2lwIG1lcmdpbmcgc2NoZW1hcyBpZiB3ZSdyZSBjcmVhdGluZyBhIGRpc2NyaW1pbmF0b3Igc2NoZW1hIGFuZFxuICAgICAgICAvLyBiYXNlIHNjaGVtYSBoYXMgYSBnaXZlbiBwYXRoIGFzIGEgc2luZ2xlIG5lc3RlZCBidXQgZGlzY3JpbWluYXRvciBzY2hlbWFcbiAgICAgICAgLy8gaGFzIHRoZSBwYXRoIGFzIGEgZG9jdW1lbnQgYXJyYXksIG9yIHZpY2UgdmVyc2EgKGdoLTk1MzQpXG4gICAgICAgIGlmICgoZnJvbVtrZXldLiRpc1NpbmdsZU5lc3RlZCAmJiB0b1trZXldLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSkgfHxcbiAgICAgICAgICAgICAgKGZyb21ba2V5XS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkgJiYgdG9ba2V5XS4kaXNTaW5nbGVOZXN0ZWQpIHx8XG4gICAgICAgICAgICAgIChmcm9tW2tleV0uJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5RWxlbWVudCAmJiB0b1trZXldLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheUVsZW1lbnQpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZnJvbVtrZXldLmluc3RhbmNlT2ZTY2hlbWEpIHtcbiAgICAgICAgICBpZiAodG9ba2V5XS5pbnN0YW5jZU9mU2NoZW1hKSB7XG4gICAgICAgICAgICBzY2hlbWFNZXJnZSh0b1trZXldLCBmcm9tW2tleV0uY2xvbmUoKSwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvW2tleV0gPSBmcm9tW2tleV0uY2xvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNCc29uVHlwZShmcm9tW2tleV0sICdPYmplY3RJZCcpKSB7XG4gICAgICAgICAgdG9ba2V5XSA9IG5ldyBPYmplY3RJZChmcm9tW2tleV0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtZXJnZURpc2NyaW1pbmF0b3JTY2hlbWEodG9ba2V5XSwgZnJvbVtrZXldLCBwYXRoID8gcGF0aCArICcuJyArIGtleSA6IGtleSwgc2Vlbik7XG4gICAgfVxuICB9XG5cbiAgaWYgKGZyb20gIT0gbnVsbCAmJiBmcm9tLmluc3RhbmNlT2ZTY2hlbWEpIHtcbiAgICB0by50cmVlID0gT2JqZWN0LmFzc2lnbih7fSwgZnJvbS50cmVlLCB0by50cmVlKTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/discriminator/mergeDiscriminatorSchema.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/document/applyDefaults.js":
/*!******************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/document/applyDefaults.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst isNestedProjection = __webpack_require__(/*! ../projection/isNestedProjection */ \"../backend/node_modules/mongoose/lib/helpers/projection/isNestedProjection.js\");\n\nmodule.exports = function applyDefaults(doc, fields, exclude, hasIncludedChildren, isBeforeSetters, pathsToSkip) {\n  const paths = Object.keys(doc.$__schema.paths);\n  const plen = paths.length;\n\n  for (let i = 0; i < plen; ++i) {\n    let def;\n    let curPath = '';\n    const p = paths[i];\n\n    if (p === '_id' && doc.$__.skipId) {\n      continue;\n    }\n\n    const type = doc.$__schema.paths[p];\n    const path = type.splitPath();\n    const len = path.length;\n    let included = false;\n    let doc_ = doc._doc;\n    for (let j = 0; j < len; ++j) {\n      if (doc_ == null) {\n        break;\n      }\n\n      const piece = path[j];\n      curPath += (!curPath.length ? '' : '.') + piece;\n\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        const hasSubpaths = type.$isSingleNested || type.$isMongooseDocumentArray;\n        if ((curPath in fields && !isNestedProjection(fields[curPath])) || (j === len - 1 && hasSubpaths && hasIncludedChildren != null && hasIncludedChildren[curPath])) {\n          included = true;\n        } else if (hasIncludedChildren != null && !hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (j === len - 1) {\n        if (doc_[piece] !== void 0) {\n          break;\n        }\n\n        if (isBeforeSetters != null) {\n          if (typeof type.defaultValue === 'function') {\n            if (!type.defaultValue.$runBeforeSetters && isBeforeSetters) {\n              break;\n            }\n            if (type.defaultValue.$runBeforeSetters && !isBeforeSetters) {\n              break;\n            }\n          } else if (!isBeforeSetters) {\n            // Non-function defaults should always run **before** setters\n            continue;\n          }\n        }\n\n        if (pathsToSkip && pathsToSkip[curPath]) {\n          break;\n        }\n\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n\n            try {\n              def = type.getDefault(doc, false);\n            } catch (err) {\n              doc.invalidate(p, err);\n              break;\n            }\n\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n              applyChangeTracking(doc, p);\n            }\n          } else if (included) {\n            // selected field\n            try {\n              def = type.getDefault(doc, false);\n            } catch (err) {\n              doc.invalidate(p, err);\n              break;\n            }\n\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n              applyChangeTracking(doc, p);\n            }\n          }\n        } else {\n          try {\n            def = type.getDefault(doc, false);\n          } catch (err) {\n            doc.invalidate(p, err);\n            break;\n          }\n\n          if (typeof def !== 'undefined') {\n            doc_[piece] = def;\n            applyChangeTracking(doc, p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece];\n      }\n    }\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction applyChangeTracking(doc, fullPath) {\n  doc.$__.activePaths.default(fullPath);\n  if (doc.$isSubdocument && doc.$isSingleNested && doc.$parent() != null) {\n    doc.$parent().$__.activePaths.default(doc.$__pathRelativeToParent(fullPath));\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZG9jdW1lbnQvYXBwbHlEZWZhdWx0cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiwyQkFBMkIsbUJBQU8sQ0FBQyx1SEFBa0M7O0FBRXJFO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kb2N1bWVudC9hcHBseURlZmF1bHRzLmpzP2YwZmQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpc05lc3RlZFByb2plY3Rpb24gPSByZXF1aXJlKCcuLi9wcm9qZWN0aW9uL2lzTmVzdGVkUHJvamVjdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFwcGx5RGVmYXVsdHMoZG9jLCBmaWVsZHMsIGV4Y2x1ZGUsIGhhc0luY2x1ZGVkQ2hpbGRyZW4sIGlzQmVmb3JlU2V0dGVycywgcGF0aHNUb1NraXApIHtcbiAgY29uc3QgcGF0aHMgPSBPYmplY3Qua2V5cyhkb2MuJF9fc2NoZW1hLnBhdGhzKTtcbiAgY29uc3QgcGxlbiA9IHBhdGhzLmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBsZW47ICsraSkge1xuICAgIGxldCBkZWY7XG4gICAgbGV0IGN1clBhdGggPSAnJztcbiAgICBjb25zdCBwID0gcGF0aHNbaV07XG5cbiAgICBpZiAocCA9PT0gJ19pZCcgJiYgZG9jLiRfXy5za2lwSWQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHR5cGUgPSBkb2MuJF9fc2NoZW1hLnBhdGhzW3BdO1xuICAgIGNvbnN0IHBhdGggPSB0eXBlLnNwbGl0UGF0aCgpO1xuICAgIGNvbnN0IGxlbiA9IHBhdGgubGVuZ3RoO1xuICAgIGxldCBpbmNsdWRlZCA9IGZhbHNlO1xuICAgIGxldCBkb2NfID0gZG9jLl9kb2M7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBsZW47ICsraikge1xuICAgICAgaWYgKGRvY18gPT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGllY2UgPSBwYXRoW2pdO1xuICAgICAgY3VyUGF0aCArPSAoIWN1clBhdGgubGVuZ3RoID8gJycgOiAnLicpICsgcGllY2U7XG5cbiAgICAgIGlmIChleGNsdWRlID09PSB0cnVlKSB7XG4gICAgICAgIGlmIChjdXJQYXRoIGluIGZpZWxkcykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGV4Y2x1ZGUgPT09IGZhbHNlICYmIGZpZWxkcyAmJiAhaW5jbHVkZWQpIHtcbiAgICAgICAgY29uc3QgaGFzU3VicGF0aHMgPSB0eXBlLiRpc1NpbmdsZU5lc3RlZCB8fCB0eXBlLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheTtcbiAgICAgICAgaWYgKChjdXJQYXRoIGluIGZpZWxkcyAmJiAhaXNOZXN0ZWRQcm9qZWN0aW9uKGZpZWxkc1tjdXJQYXRoXSkpIHx8IChqID09PSBsZW4gLSAxICYmIGhhc1N1YnBhdGhzICYmIGhhc0luY2x1ZGVkQ2hpbGRyZW4gIT0gbnVsbCAmJiBoYXNJbmNsdWRlZENoaWxkcmVuW2N1clBhdGhdKSkge1xuICAgICAgICAgIGluY2x1ZGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChoYXNJbmNsdWRlZENoaWxkcmVuICE9IG51bGwgJiYgIWhhc0luY2x1ZGVkQ2hpbGRyZW5bY3VyUGF0aF0pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaiA9PT0gbGVuIC0gMSkge1xuICAgICAgICBpZiAoZG9jX1twaWVjZV0gIT09IHZvaWQgMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQmVmb3JlU2V0dGVycyAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlLmRlZmF1bHRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKCF0eXBlLmRlZmF1bHRWYWx1ZS4kcnVuQmVmb3JlU2V0dGVycyAmJiBpc0JlZm9yZVNldHRlcnMpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZS5kZWZhdWx0VmFsdWUuJHJ1bkJlZm9yZVNldHRlcnMgJiYgIWlzQmVmb3JlU2V0dGVycykge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKCFpc0JlZm9yZVNldHRlcnMpIHtcbiAgICAgICAgICAgIC8vIE5vbi1mdW5jdGlvbiBkZWZhdWx0cyBzaG91bGQgYWx3YXlzIHJ1biAqKmJlZm9yZSoqIHNldHRlcnNcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXRoc1RvU2tpcCAmJiBwYXRoc1RvU2tpcFtjdXJQYXRoXSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpZWxkcyAmJiBleGNsdWRlICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKGV4Y2x1ZGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIGFwcGx5IGRlZmF1bHRzIHRvIGFsbCBub24tZXhjbHVkZWQgZmllbGRzXG4gICAgICAgICAgICBpZiAocCBpbiBmaWVsZHMpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGRlZiA9IHR5cGUuZ2V0RGVmYXVsdChkb2MsIGZhbHNlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBkb2MuaW52YWxpZGF0ZShwLCBlcnIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIGRvY19bcGllY2VdID0gZGVmO1xuICAgICAgICAgICAgICBhcHBseUNoYW5nZVRyYWNraW5nKGRvYywgcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChpbmNsdWRlZCkge1xuICAgICAgICAgICAgLy8gc2VsZWN0ZWQgZmllbGRcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGRlZiA9IHR5cGUuZ2V0RGVmYXVsdChkb2MsIGZhbHNlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBkb2MuaW52YWxpZGF0ZShwLCBlcnIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZWYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIGRvY19bcGllY2VdID0gZGVmO1xuICAgICAgICAgICAgICBhcHBseUNoYW5nZVRyYWNraW5nKGRvYywgcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWYgPSB0eXBlLmdldERlZmF1bHQoZG9jLCBmYWxzZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBkb2MuaW52YWxpZGF0ZShwLCBlcnIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGVvZiBkZWYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBkb2NfW3BpZWNlXSA9IGRlZjtcbiAgICAgICAgICAgIGFwcGx5Q2hhbmdlVHJhY2tpbmcoZG9jLCBwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvY18gPSBkb2NfW3BpZWNlXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gYXBwbHlDaGFuZ2VUcmFja2luZyhkb2MsIGZ1bGxQYXRoKSB7XG4gIGRvYy4kX18uYWN0aXZlUGF0aHMuZGVmYXVsdChmdWxsUGF0aCk7XG4gIGlmIChkb2MuJGlzU3ViZG9jdW1lbnQgJiYgZG9jLiRpc1NpbmdsZU5lc3RlZCAmJiBkb2MuJHBhcmVudCgpICE9IG51bGwpIHtcbiAgICBkb2MuJHBhcmVudCgpLiRfXy5hY3RpdmVQYXRocy5kZWZhdWx0KGRvYy4kX19wYXRoUmVsYXRpdmVUb1BhcmVudChmdWxsUGF0aCkpO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/document/applyDefaults.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/document/cleanModifiedSubpaths.js":
/*!**************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/document/cleanModifiedSubpaths.js ***!
  \**************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = function cleanModifiedSubpaths(doc, path, options) {\n  options = options || {};\n  const skipDocArrays = options.skipDocArrays;\n\n  let deleted = 0;\n  if (!doc) {\n    return deleted;\n  }\n\n  for (const modifiedPath of Object.keys(doc.$__.activePaths.getStatePaths('modify'))) {\n    if (skipDocArrays) {\n      const schemaType = doc.$__schema.path(modifiedPath);\n      if (schemaType && schemaType.$isMongooseDocumentArray) {\n        continue;\n      }\n    }\n    if (modifiedPath.startsWith(path + '.')) {\n      doc.$__.activePaths.clearPath(modifiedPath);\n      ++deleted;\n\n      if (doc.$isSubdocument) {\n        const owner = doc.ownerDocument();\n        const fullPath = doc.$__fullPath(modifiedPath);\n        owner.$__.activePaths.clearPath(fullPath);\n      }\n    }\n  }\n  return deleted;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZG9jdW1lbnQvY2xlYW5Nb2RpZmllZFN1YnBhdGhzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZG9jdW1lbnQvY2xlYW5Nb2RpZmllZFN1YnBhdGhzLmpzPzYwMjUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2xlYW5Nb2RpZmllZFN1YnBhdGhzKGRvYywgcGF0aCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3Qgc2tpcERvY0FycmF5cyA9IG9wdGlvbnMuc2tpcERvY0FycmF5cztcblxuICBsZXQgZGVsZXRlZCA9IDA7XG4gIGlmICghZG9jKSB7XG4gICAgcmV0dXJuIGRlbGV0ZWQ7XG4gIH1cblxuICBmb3IgKGNvbnN0IG1vZGlmaWVkUGF0aCBvZiBPYmplY3Qua2V5cyhkb2MuJF9fLmFjdGl2ZVBhdGhzLmdldFN0YXRlUGF0aHMoJ21vZGlmeScpKSkge1xuICAgIGlmIChza2lwRG9jQXJyYXlzKSB7XG4gICAgICBjb25zdCBzY2hlbWFUeXBlID0gZG9jLiRfX3NjaGVtYS5wYXRoKG1vZGlmaWVkUGF0aCk7XG4gICAgICBpZiAoc2NoZW1hVHlwZSAmJiBzY2hlbWFUeXBlLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1vZGlmaWVkUGF0aC5zdGFydHNXaXRoKHBhdGggKyAnLicpKSB7XG4gICAgICBkb2MuJF9fLmFjdGl2ZVBhdGhzLmNsZWFyUGF0aChtb2RpZmllZFBhdGgpO1xuICAgICAgKytkZWxldGVkO1xuXG4gICAgICBpZiAoZG9jLiRpc1N1YmRvY3VtZW50KSB7XG4gICAgICAgIGNvbnN0IG93bmVyID0gZG9jLm93bmVyRG9jdW1lbnQoKTtcbiAgICAgICAgY29uc3QgZnVsbFBhdGggPSBkb2MuJF9fZnVsbFBhdGgobW9kaWZpZWRQYXRoKTtcbiAgICAgICAgb3duZXIuJF9fLmFjdGl2ZVBhdGhzLmNsZWFyUGF0aChmdWxsUGF0aCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWxldGVkO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/document/cleanModifiedSubpaths.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/document/compile.js":
/*!************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/document/compile.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst clone = __webpack_require__(/*! ../../helpers/clone */ \"../backend/node_modules/mongoose/lib/helpers/clone.js\");\nconst documentSchemaSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").documentSchemaSymbol);\nconst internalToObjectOptions = (__webpack_require__(/*! ../../options */ \"../backend/node_modules/mongoose/lib/options.js\").internalToObjectOptions);\nconst utils = __webpack_require__(/*! ../../utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\n\nlet Document;\nconst getSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").getSymbol);\nconst scopeSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").scopeSymbol);\n\nconst isPOJO = utils.isPOJO;\n\n/*!\n * exports\n */\n\nexports.compile = compile;\nexports.defineKey = defineKey;\n\nconst _isEmptyOptions = Object.freeze({\n  minimize: true,\n  virtuals: false,\n  getters: false,\n  transform: false\n});\n\nconst noDottedPathGetOptions = Object.freeze({\n  noDottedPath: true\n});\n\n/**\n * Compiles schemas.\n * @param {Object} tree\n * @param {Any} proto\n * @param {String} prefix\n * @param {Object} options\n * @api private\n */\n\nfunction compile(tree, proto, prefix, options) {\n  Document = Document || __webpack_require__(/*! ../../document */ \"../backend/node_modules/mongoose/lib/document.js\");\n  const typeKey = options.typeKey;\n\n  for (const key of Object.keys(tree)) {\n    const limb = tree[key];\n\n    const hasSubprops = isPOJO(limb) &&\n      Object.keys(limb).length > 0 &&\n      (!limb[typeKey] || (typeKey === 'type' && isPOJO(limb.type) && limb.type.type));\n    const subprops = hasSubprops ? limb : null;\n\n    defineKey({ prop: key, subprops: subprops, prototype: proto, prefix: prefix, options: options });\n  }\n}\n\n/**\n * Defines the accessor named prop on the incoming prototype.\n * @param {Object} options\n * @param {String} options.prop\n * @param {Boolean} options.subprops\n * @param {Any} options.prototype\n * @param {String} [options.prefix]\n * @param {Object} options.options\n * @api private\n */\n\nfunction defineKey({ prop, subprops, prototype, prefix, options }) {\n  Document = Document || __webpack_require__(/*! ../../document */ \"../backend/node_modules/mongoose/lib/document.js\");\n  const path = (prefix ? prefix + '.' : '') + prop;\n  prefix = prefix || '';\n  const useGetOptions = prefix ? Object.freeze({}) : noDottedPathGetOptions;\n\n  if (subprops) {\n    Object.defineProperty(prototype, prop, {\n      enumerable: true,\n      configurable: true,\n      get: function() {\n        const _this = this;\n        if (!this.$__.getters) {\n          this.$__.getters = {};\n        }\n\n        if (!this.$__.getters[path]) {\n          const nested = Object.create(Document.prototype, getOwnPropertyDescriptors(this));\n\n          // save scope for nested getters/setters\n          if (!prefix) {\n            nested.$__[scopeSymbol] = this;\n          }\n          nested.$__.nestedPath = path;\n\n          Object.defineProperty(nested, 'schema', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: prototype.schema\n          });\n\n          Object.defineProperty(nested, '$__schema', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: prototype.schema\n          });\n\n          Object.defineProperty(nested, documentSchemaSymbol, {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: prototype.schema\n          });\n\n          Object.defineProperty(nested, 'toObject', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: function() {\n              return clone(_this.get(path, null, {\n                virtuals: this &&\n                  this.schema &&\n                  this.schema.options &&\n                  this.schema.options.toObject &&\n                  this.schema.options.toObject.virtuals || null\n              }));\n            }\n          });\n\n          Object.defineProperty(nested, '$__get', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: function() {\n              return _this.get(path, null, {\n                virtuals: this && this.schema && this.schema.options && this.schema.options.toObject && this.schema.options.toObject.virtuals || null\n              });\n            }\n          });\n\n          Object.defineProperty(nested, 'toJSON', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: function() {\n              return _this.get(path, null, {\n                virtuals: this && this.schema && this.schema.options && this.schema.options.toJSON && this.schema.options.toJSON.virtuals || null\n              });\n            }\n          });\n\n          Object.defineProperty(nested, '$__isNested', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: true\n          });\n\n          Object.defineProperty(nested, '$isEmpty', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: function() {\n              return Object.keys(this.get(path, null, _isEmptyOptions) || {}).length === 0;\n            }\n          });\n\n          Object.defineProperty(nested, '$__parent', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: this\n          });\n\n          compile(subprops, nested, path, options);\n          this.$__.getters[path] = nested;\n        }\n\n        return this.$__.getters[path];\n      },\n      set: function(v) {\n        if (v != null && v.$__isNested) {\n          // Convert top-level to POJO, but leave subdocs hydrated so `$set`\n          // can handle them. See gh-9293.\n          v = v.$__get();\n        } else if (v instanceof Document && !v.$__isNested) {\n          v = v.$toObject(internalToObjectOptions);\n        }\n        const doc = this.$__[scopeSymbol] || this;\n        doc.$set(path, v);\n      }\n    });\n  } else {\n    Object.defineProperty(prototype, prop, {\n      enumerable: true,\n      configurable: true,\n      get: function() {\n        return this[getSymbol].call(\n          this.$__[scopeSymbol] || this,\n          path,\n          null,\n          useGetOptions\n        );\n      },\n      set: function(v) {\n        this.$set.call(this.$__[scopeSymbol] || this, path, v);\n      }\n    });\n  }\n}\n\n// gets descriptors for all properties of `object`\n// makes all properties non-enumerable to match previous behavior to #2211\nfunction getOwnPropertyDescriptors(object) {\n  const result = {};\n\n  Object.getOwnPropertyNames(object).forEach(function(key) {\n    const skip = [\n      'isNew',\n      '$__',\n      '$errors',\n      'errors',\n      '_doc',\n      '$locals',\n      '$op',\n      '__parentArray',\n      '__index',\n      '$isDocumentArrayElement'\n    ].indexOf(key) === -1;\n    if (skip) {\n      return;\n    }\n\n    result[key] = Object.getOwnPropertyDescriptor(object, key);\n    result[key].enumerable = false;\n  });\n\n  return result;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZG9jdW1lbnQvY29tcGlsZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsa0ZBQXFCO0FBQzNDLDZCQUE2QixrSUFBcUQ7QUFDbEYsZ0NBQWdDLHFIQUFnRDtBQUNoRixjQUFjLG1CQUFPLENBQUMsa0VBQWE7O0FBRW5DO0FBQ0Esa0JBQWtCLHVIQUEwQztBQUM1RCxvQkFBb0IseUhBQTRDOztBQUVoRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLG1CQUFPLENBQUMsd0VBQWdCO0FBQ2pEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLG1GQUFtRjtBQUNuRztBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBLHFCQUFxQiw0Q0FBNEM7QUFDakUseUJBQXlCLG1CQUFPLENBQUMsd0VBQWdCO0FBQ2pEO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZG9jdW1lbnQvY29tcGlsZS5qcz84ODljIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXJzL2Nsb25lJyk7XG5jb25zdCBkb2N1bWVudFNjaGVtYVN5bWJvbCA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvc3ltYm9scycpLmRvY3VtZW50U2NoZW1hU3ltYm9sO1xuY29uc3QgaW50ZXJuYWxUb09iamVjdE9wdGlvbnMgPSByZXF1aXJlKCcuLi8uLi9vcHRpb25zJykuaW50ZXJuYWxUb09iamVjdE9wdGlvbnM7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5cbmxldCBEb2N1bWVudDtcbmNvbnN0IGdldFN5bWJvbCA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvc3ltYm9scycpLmdldFN5bWJvbDtcbmNvbnN0IHNjb3BlU3ltYm9sID0gcmVxdWlyZSgnLi4vLi4vaGVscGVycy9zeW1ib2xzJykuc2NvcGVTeW1ib2w7XG5cbmNvbnN0IGlzUE9KTyA9IHV0aWxzLmlzUE9KTztcblxuLyohXG4gKiBleHBvcnRzXG4gKi9cblxuZXhwb3J0cy5jb21waWxlID0gY29tcGlsZTtcbmV4cG9ydHMuZGVmaW5lS2V5ID0gZGVmaW5lS2V5O1xuXG5jb25zdCBfaXNFbXB0eU9wdGlvbnMgPSBPYmplY3QuZnJlZXplKHtcbiAgbWluaW1pemU6IHRydWUsXG4gIHZpcnR1YWxzOiBmYWxzZSxcbiAgZ2V0dGVyczogZmFsc2UsXG4gIHRyYW5zZm9ybTogZmFsc2Vcbn0pO1xuXG5jb25zdCBub0RvdHRlZFBhdGhHZXRPcHRpb25zID0gT2JqZWN0LmZyZWV6ZSh7XG4gIG5vRG90dGVkUGF0aDogdHJ1ZVxufSk7XG5cbi8qKlxuICogQ29tcGlsZXMgc2NoZW1hcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSB0cmVlXG4gKiBAcGFyYW0ge0FueX0gcHJvdG9cbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXhcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb21waWxlKHRyZWUsIHByb3RvLCBwcmVmaXgsIG9wdGlvbnMpIHtcbiAgRG9jdW1lbnQgPSBEb2N1bWVudCB8fCByZXF1aXJlKCcuLi8uLi9kb2N1bWVudCcpO1xuICBjb25zdCB0eXBlS2V5ID0gb3B0aW9ucy50eXBlS2V5O1xuXG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRyZWUpKSB7XG4gICAgY29uc3QgbGltYiA9IHRyZWVba2V5XTtcblxuICAgIGNvbnN0IGhhc1N1YnByb3BzID0gaXNQT0pPKGxpbWIpICYmXG4gICAgICBPYmplY3Qua2V5cyhsaW1iKS5sZW5ndGggPiAwICYmXG4gICAgICAoIWxpbWJbdHlwZUtleV0gfHwgKHR5cGVLZXkgPT09ICd0eXBlJyAmJiBpc1BPSk8obGltYi50eXBlKSAmJiBsaW1iLnR5cGUudHlwZSkpO1xuICAgIGNvbnN0IHN1YnByb3BzID0gaGFzU3VicHJvcHMgPyBsaW1iIDogbnVsbDtcblxuICAgIGRlZmluZUtleSh7IHByb3A6IGtleSwgc3VicHJvcHM6IHN1YnByb3BzLCBwcm90b3R5cGU6IHByb3RvLCBwcmVmaXg6IHByZWZpeCwgb3B0aW9uczogb3B0aW9ucyB9KTtcbiAgfVxufVxuXG4vKipcbiAqIERlZmluZXMgdGhlIGFjY2Vzc29yIG5hbWVkIHByb3Agb24gdGhlIGluY29taW5nIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5wcm9wXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMuc3VicHJvcHNcbiAqIEBwYXJhbSB7QW55fSBvcHRpb25zLnByb3RvdHlwZVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnByZWZpeF1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLm9wdGlvbnNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGRlZmluZUtleSh7IHByb3AsIHN1YnByb3BzLCBwcm90b3R5cGUsIHByZWZpeCwgb3B0aW9ucyB9KSB7XG4gIERvY3VtZW50ID0gRG9jdW1lbnQgfHwgcmVxdWlyZSgnLi4vLi4vZG9jdW1lbnQnKTtcbiAgY29uc3QgcGF0aCA9IChwcmVmaXggPyBwcmVmaXggKyAnLicgOiAnJykgKyBwcm9wO1xuICBwcmVmaXggPSBwcmVmaXggfHwgJyc7XG4gIGNvbnN0IHVzZUdldE9wdGlvbnMgPSBwcmVmaXggPyBPYmplY3QuZnJlZXplKHt9KSA6IG5vRG90dGVkUGF0aEdldE9wdGlvbnM7XG5cbiAgaWYgKHN1YnByb3BzKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgcHJvcCwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLiRfXy5nZXR0ZXJzKSB7XG4gICAgICAgICAgdGhpcy4kX18uZ2V0dGVycyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLiRfXy5nZXR0ZXJzW3BhdGhdKSB7XG4gICAgICAgICAgY29uc3QgbmVzdGVkID0gT2JqZWN0LmNyZWF0ZShEb2N1bWVudC5wcm90b3R5cGUsIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnModGhpcykpO1xuXG4gICAgICAgICAgLy8gc2F2ZSBzY29wZSBmb3IgbmVzdGVkIGdldHRlcnMvc2V0dGVyc1xuICAgICAgICAgIGlmICghcHJlZml4KSB7XG4gICAgICAgICAgICBuZXN0ZWQuJF9fW3Njb3BlU3ltYm9sXSA9IHRoaXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5lc3RlZC4kX18ubmVzdGVkUGF0aCA9IHBhdGg7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmVzdGVkLCAnc2NoZW1hJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogcHJvdG90eXBlLnNjaGVtYVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5lc3RlZCwgJyRfX3NjaGVtYScsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IHByb3RvdHlwZS5zY2hlbWFcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXN0ZWQsIGRvY3VtZW50U2NoZW1hU3ltYm9sLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBwcm90b3R5cGUuc2NoZW1hXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmVzdGVkLCAndG9PYmplY3QnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNsb25lKF90aGlzLmdldChwYXRoLCBudWxsLCB7XG4gICAgICAgICAgICAgICAgdmlydHVhbHM6IHRoaXMgJiZcbiAgICAgICAgICAgICAgICAgIHRoaXMuc2NoZW1hICYmXG4gICAgICAgICAgICAgICAgICB0aGlzLnNjaGVtYS5vcHRpb25zICYmXG4gICAgICAgICAgICAgICAgICB0aGlzLnNjaGVtYS5vcHRpb25zLnRvT2JqZWN0ICYmXG4gICAgICAgICAgICAgICAgICB0aGlzLnNjaGVtYS5vcHRpb25zLnRvT2JqZWN0LnZpcnR1YWxzIHx8IG51bGxcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5lc3RlZCwgJyRfX2dldCcsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0KHBhdGgsIG51bGwsIHtcbiAgICAgICAgICAgICAgICB2aXJ0dWFsczogdGhpcyAmJiB0aGlzLnNjaGVtYSAmJiB0aGlzLnNjaGVtYS5vcHRpb25zICYmIHRoaXMuc2NoZW1hLm9wdGlvbnMudG9PYmplY3QgJiYgdGhpcy5zY2hlbWEub3B0aW9ucy50b09iamVjdC52aXJ0dWFscyB8fCBudWxsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5lc3RlZCwgJ3RvSlNPTicsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0KHBhdGgsIG51bGwsIHtcbiAgICAgICAgICAgICAgICB2aXJ0dWFsczogdGhpcyAmJiB0aGlzLnNjaGVtYSAmJiB0aGlzLnNjaGVtYS5vcHRpb25zICYmIHRoaXMuc2NoZW1hLm9wdGlvbnMudG9KU09OICYmIHRoaXMuc2NoZW1hLm9wdGlvbnMudG9KU09OLnZpcnR1YWxzIHx8IG51bGxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmVzdGVkLCAnJF9faXNOZXN0ZWQnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmVzdGVkLCAnJGlzRW1wdHknLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZ2V0KHBhdGgsIG51bGwsIF9pc0VtcHR5T3B0aW9ucykgfHwge30pLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXN0ZWQsICckX19wYXJlbnQnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjb21waWxlKHN1YnByb3BzLCBuZXN0ZWQsIHBhdGgsIG9wdGlvbnMpO1xuICAgICAgICAgIHRoaXMuJF9fLmdldHRlcnNbcGF0aF0gPSBuZXN0ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy4kX18uZ2V0dGVyc1twYXRoXTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgaWYgKHYgIT0gbnVsbCAmJiB2LiRfX2lzTmVzdGVkKSB7XG4gICAgICAgICAgLy8gQ29udmVydCB0b3AtbGV2ZWwgdG8gUE9KTywgYnV0IGxlYXZlIHN1YmRvY3MgaHlkcmF0ZWQgc28gYCRzZXRgXG4gICAgICAgICAgLy8gY2FuIGhhbmRsZSB0aGVtLiBTZWUgZ2gtOTI5My5cbiAgICAgICAgICB2ID0gdi4kX19nZXQoKTtcbiAgICAgICAgfSBlbHNlIGlmICh2IGluc3RhbmNlb2YgRG9jdW1lbnQgJiYgIXYuJF9faXNOZXN0ZWQpIHtcbiAgICAgICAgICB2ID0gdi4kdG9PYmplY3QoaW50ZXJuYWxUb09iamVjdE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvYyA9IHRoaXMuJF9fW3Njb3BlU3ltYm9sXSB8fCB0aGlzO1xuICAgICAgICBkb2MuJHNldChwYXRoLCB2KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBwcm9wLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbZ2V0U3ltYm9sXS5jYWxsKFxuICAgICAgICAgIHRoaXMuJF9fW3Njb3BlU3ltYm9sXSB8fCB0aGlzLFxuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICB1c2VHZXRPcHRpb25zXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgIHRoaXMuJHNldC5jYWxsKHRoaXMuJF9fW3Njb3BlU3ltYm9sXSB8fCB0aGlzLCBwYXRoLCB2KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vLyBnZXRzIGRlc2NyaXB0b3JzIGZvciBhbGwgcHJvcGVydGllcyBvZiBgb2JqZWN0YFxuLy8gbWFrZXMgYWxsIHByb3BlcnRpZXMgbm9uLWVudW1lcmFibGUgdG8gbWF0Y2ggcHJldmlvdXMgYmVoYXZpb3IgdG8gIzIyMTFcbmZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqZWN0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iamVjdCkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBjb25zdCBza2lwID0gW1xuICAgICAgJ2lzTmV3JyxcbiAgICAgICckX18nLFxuICAgICAgJyRlcnJvcnMnLFxuICAgICAgJ2Vycm9ycycsXG4gICAgICAnX2RvYycsXG4gICAgICAnJGxvY2FscycsXG4gICAgICAnJG9wJyxcbiAgICAgICdfX3BhcmVudEFycmF5JyxcbiAgICAgICdfX2luZGV4JyxcbiAgICAgICckaXNEb2N1bWVudEFycmF5RWxlbWVudCdcbiAgICBdLmluZGV4T2Yoa2V5KSA9PT0gLTE7XG4gICAgaWYgKHNraXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXN1bHRba2V5XSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBrZXkpO1xuICAgIHJlc3VsdFtrZXldLmVudW1lcmFibGUgPSBmYWxzZTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/document/compile.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/document/getDeepestSubdocumentForPath.js":
/*!*********************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/document/getDeepestSubdocumentForPath.js ***!
  \*********************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Find the deepest subdocument along a given path to ensure setter functions run\n * with the correct subdocument as `this`. If no subdocuments, returns the top-level\n * document.\n *\n * @param {Document} doc\n * @param {String[]} parts\n * @param {Schema} schema\n * @returns Document\n */\n\nmodule.exports = function getDeepestSubdocumentForPath(doc, parts, schema) {\n  let curPath = parts[0];\n  let curSchema = schema;\n  let subdoc = doc;\n  for (let i = 0; i < parts.length - 1; ++i) {\n    const curSchemaType = curSchema.path(curPath);\n    if (curSchemaType && curSchemaType.schema) {\n      let newSubdoc = subdoc.get(curPath);\n      curSchema = curSchemaType.schema;\n      curPath = parts[i + 1];\n      if (Array.isArray(newSubdoc) && !isNaN(curPath)) {\n        newSubdoc = newSubdoc[curPath];\n        curPath = '';\n      }\n      if (newSubdoc == null) {\n        break;\n      }\n      subdoc = newSubdoc;\n    } else {\n      curPath += curPath.length ? '.' + parts[i + 1] : parts[i + 1];\n    }\n  }\n\n  return subdoc;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZG9jdW1lbnQvZ2V0RGVlcGVzdFN1YmRvY3VtZW50Rm9yUGF0aC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9kb2N1bWVudC9nZXREZWVwZXN0U3ViZG9jdW1lbnRGb3JQYXRoLmpzPzhlNDIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEZpbmQgdGhlIGRlZXBlc3Qgc3ViZG9jdW1lbnQgYWxvbmcgYSBnaXZlbiBwYXRoIHRvIGVuc3VyZSBzZXR0ZXIgZnVuY3Rpb25zIHJ1blxuICogd2l0aCB0aGUgY29ycmVjdCBzdWJkb2N1bWVudCBhcyBgdGhpc2AuIElmIG5vIHN1YmRvY3VtZW50cywgcmV0dXJucyB0aGUgdG9wLWxldmVsXG4gKiBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBkb2NcbiAqIEBwYXJhbSB7U3RyaW5nW119IHBhcnRzXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAcmV0dXJucyBEb2N1bWVudFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0RGVlcGVzdFN1YmRvY3VtZW50Rm9yUGF0aChkb2MsIHBhcnRzLCBzY2hlbWEpIHtcbiAgbGV0IGN1clBhdGggPSBwYXJ0c1swXTtcbiAgbGV0IGN1clNjaGVtYSA9IHNjaGVtYTtcbiAgbGV0IHN1YmRvYyA9IGRvYztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICBjb25zdCBjdXJTY2hlbWFUeXBlID0gY3VyU2NoZW1hLnBhdGgoY3VyUGF0aCk7XG4gICAgaWYgKGN1clNjaGVtYVR5cGUgJiYgY3VyU2NoZW1hVHlwZS5zY2hlbWEpIHtcbiAgICAgIGxldCBuZXdTdWJkb2MgPSBzdWJkb2MuZ2V0KGN1clBhdGgpO1xuICAgICAgY3VyU2NoZW1hID0gY3VyU2NoZW1hVHlwZS5zY2hlbWE7XG4gICAgICBjdXJQYXRoID0gcGFydHNbaSArIDFdO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobmV3U3ViZG9jKSAmJiAhaXNOYU4oY3VyUGF0aCkpIHtcbiAgICAgICAgbmV3U3ViZG9jID0gbmV3U3ViZG9jW2N1clBhdGhdO1xuICAgICAgICBjdXJQYXRoID0gJyc7XG4gICAgICB9XG4gICAgICBpZiAobmV3U3ViZG9jID09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdWJkb2MgPSBuZXdTdWJkb2M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1clBhdGggKz0gY3VyUGF0aC5sZW5ndGggPyAnLicgKyBwYXJ0c1tpICsgMV0gOiBwYXJ0c1tpICsgMV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1YmRvYztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/document/getDeepestSubdocumentForPath.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/document/getEmbeddedDiscriminatorPath.js":
/*!*********************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/document/getEmbeddedDiscriminatorPath.js ***!
  \*********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst get = __webpack_require__(/*! ../get */ \"../backend/node_modules/mongoose/lib/helpers/get.js\");\nconst getSchemaDiscriminatorByValue = __webpack_require__(/*! ../discriminator/getSchemaDiscriminatorByValue */ \"../backend/node_modules/mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js\");\n\n/**\n * Like `schema.path()`, except with a document, because impossible to\n * determine path type without knowing the embedded discriminator key.\n *\n * @param {Document} doc\n * @param {String|String[]} path\n * @param {Object} [options]\n * @api private\n */\n\nmodule.exports = function getEmbeddedDiscriminatorPath(doc, path, options) {\n  options = options || {};\n  const typeOnly = options.typeOnly;\n  const parts = Array.isArray(path) ?\n    path :\n    (path.indexOf('.') === -1 ? [path] : path.split('.'));\n  let schemaType = null;\n  let type = 'adhocOrUndefined';\n\n  const schema = getSchemaDiscriminatorByValue(doc.schema, doc.get(doc.schema.options.discriminatorKey)) || doc.schema;\n\n  for (let i = 0; i < parts.length; ++i) {\n    const subpath = parts.slice(0, i + 1).join('.');\n    schemaType = schema.path(subpath);\n    if (schemaType == null) {\n      type = 'adhocOrUndefined';\n      continue;\n    }\n    if (schemaType.instance === 'Mixed') {\n      return typeOnly ? 'real' : schemaType;\n    }\n    type = schema.pathType(subpath);\n    if ((schemaType.$isSingleNested || schemaType.$isMongooseDocumentArrayElement) &&\n    schemaType.schema.discriminators != null) {\n      const discriminators = schemaType.schema.discriminators;\n      const discriminatorKey = doc.get(subpath + '.' +\n        get(schemaType, 'schema.options.discriminatorKey'));\n      if (discriminatorKey == null || discriminators[discriminatorKey] == null) {\n        continue;\n      }\n      const rest = parts.slice(i + 1).join('.');\n      return getEmbeddedDiscriminatorPath(doc.get(subpath), rest, options);\n    }\n  }\n\n  // Are we getting the whole schema or just the type, 'real', 'nested', etc.\n  return typeOnly ? type : schemaType;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZG9jdW1lbnQvZ2V0RW1iZWRkZWREaXNjcmltaW5hdG9yUGF0aC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsbUVBQVE7QUFDNUIsc0NBQXNDLG1CQUFPLENBQUMsbUpBQWdEOztBQUU5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZG9jdW1lbnQvZ2V0RW1iZWRkZWREaXNjcmltaW5hdG9yUGF0aC5qcz9kNWUzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZ2V0ID0gcmVxdWlyZSgnLi4vZ2V0Jyk7XG5jb25zdCBnZXRTY2hlbWFEaXNjcmltaW5hdG9yQnlWYWx1ZSA9IHJlcXVpcmUoJy4uL2Rpc2NyaW1pbmF0b3IvZ2V0U2NoZW1hRGlzY3JpbWluYXRvckJ5VmFsdWUnKTtcblxuLyoqXG4gKiBMaWtlIGBzY2hlbWEucGF0aCgpYCwgZXhjZXB0IHdpdGggYSBkb2N1bWVudCwgYmVjYXVzZSBpbXBvc3NpYmxlIHRvXG4gKiBkZXRlcm1pbmUgcGF0aCB0eXBlIHdpdGhvdXQga25vd2luZyB0aGUgZW1iZWRkZWQgZGlzY3JpbWluYXRvciBrZXkuXG4gKlxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jXG4gKiBAcGFyYW0ge1N0cmluZ3xTdHJpbmdbXX0gcGF0aFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRFbWJlZGRlZERpc2NyaW1pbmF0b3JQYXRoKGRvYywgcGF0aCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgdHlwZU9ubHkgPSBvcHRpb25zLnR5cGVPbmx5O1xuICBjb25zdCBwYXJ0cyA9IEFycmF5LmlzQXJyYXkocGF0aCkgP1xuICAgIHBhdGggOlxuICAgIChwYXRoLmluZGV4T2YoJy4nKSA9PT0gLTEgPyBbcGF0aF0gOiBwYXRoLnNwbGl0KCcuJykpO1xuICBsZXQgc2NoZW1hVHlwZSA9IG51bGw7XG4gIGxldCB0eXBlID0gJ2FkaG9jT3JVbmRlZmluZWQnO1xuXG4gIGNvbnN0IHNjaGVtYSA9IGdldFNjaGVtYURpc2NyaW1pbmF0b3JCeVZhbHVlKGRvYy5zY2hlbWEsIGRvYy5nZXQoZG9jLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXkpKSB8fCBkb2Muc2NoZW1hO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBzdWJwYXRoID0gcGFydHMuc2xpY2UoMCwgaSArIDEpLmpvaW4oJy4nKTtcbiAgICBzY2hlbWFUeXBlID0gc2NoZW1hLnBhdGgoc3VicGF0aCk7XG4gICAgaWYgKHNjaGVtYVR5cGUgPT0gbnVsbCkge1xuICAgICAgdHlwZSA9ICdhZGhvY09yVW5kZWZpbmVkJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hVHlwZS5pbnN0YW5jZSA9PT0gJ01peGVkJykge1xuICAgICAgcmV0dXJuIHR5cGVPbmx5ID8gJ3JlYWwnIDogc2NoZW1hVHlwZTtcbiAgICB9XG4gICAgdHlwZSA9IHNjaGVtYS5wYXRoVHlwZShzdWJwYXRoKTtcbiAgICBpZiAoKHNjaGVtYVR5cGUuJGlzU2luZ2xlTmVzdGVkIHx8IHNjaGVtYVR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5RWxlbWVudCkgJiZcbiAgICBzY2hlbWFUeXBlLnNjaGVtYS5kaXNjcmltaW5hdG9ycyAhPSBudWxsKSB7XG4gICAgICBjb25zdCBkaXNjcmltaW5hdG9ycyA9IHNjaGVtYVR5cGUuc2NoZW1hLmRpc2NyaW1pbmF0b3JzO1xuICAgICAgY29uc3QgZGlzY3JpbWluYXRvcktleSA9IGRvYy5nZXQoc3VicGF0aCArICcuJyArXG4gICAgICAgIGdldChzY2hlbWFUeXBlLCAnc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleScpKTtcbiAgICAgIGlmIChkaXNjcmltaW5hdG9yS2V5ID09IG51bGwgfHwgZGlzY3JpbWluYXRvcnNbZGlzY3JpbWluYXRvcktleV0gPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3QgPSBwYXJ0cy5zbGljZShpICsgMSkuam9pbignLicpO1xuICAgICAgcmV0dXJuIGdldEVtYmVkZGVkRGlzY3JpbWluYXRvclBhdGgoZG9jLmdldChzdWJwYXRoKSwgcmVzdCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgLy8gQXJlIHdlIGdldHRpbmcgdGhlIHdob2xlIHNjaGVtYSBvciBqdXN0IHRoZSB0eXBlLCAncmVhbCcsICduZXN0ZWQnLCBldGMuXG4gIHJldHVybiB0eXBlT25seSA/IHR5cGUgOiBzY2hlbWFUeXBlO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/document/getEmbeddedDiscriminatorPath.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/document/handleSpreadDoc.js":
/*!********************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/document/handleSpreadDoc.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst utils = __webpack_require__(/*! ../../utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\n\nconst keysToSkip = new Set(['__index', '__parentArray', '_doc']);\n\n/**\n * Using spread operator on a Mongoose document gives you a\n * POJO that has a tendency to cause infinite recursion. So\n * we use this function on `set()` to prevent that.\n */\n\nmodule.exports = function handleSpreadDoc(v, includeExtraKeys) {\n  if (utils.isPOJO(v) && v.$__ != null && v._doc != null) {\n    if (includeExtraKeys) {\n      const extraKeys = {};\n      for (const key of Object.keys(v)) {\n        if (typeof key === 'symbol') {\n          continue;\n        }\n        if (key[0] === '$') {\n          continue;\n        }\n        if (keysToSkip.has(key)) {\n          continue;\n        }\n        extraKeys[key] = v[key];\n      }\n      return { ...v._doc, ...extraKeys };\n    }\n    return v._doc;\n  }\n\n  return v;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZG9jdW1lbnQvaGFuZGxlU3ByZWFkRG9jLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyxrRUFBYTs7QUFFbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2RvY3VtZW50L2hhbmRsZVNwcmVhZERvYy5qcz8wZGQ5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuXG5jb25zdCBrZXlzVG9Ta2lwID0gbmV3IFNldChbJ19faW5kZXgnLCAnX19wYXJlbnRBcnJheScsICdfZG9jJ10pO1xuXG4vKipcbiAqIFVzaW5nIHNwcmVhZCBvcGVyYXRvciBvbiBhIE1vbmdvb3NlIGRvY3VtZW50IGdpdmVzIHlvdSBhXG4gKiBQT0pPIHRoYXQgaGFzIGEgdGVuZGVuY3kgdG8gY2F1c2UgaW5maW5pdGUgcmVjdXJzaW9uLiBTb1xuICogd2UgdXNlIHRoaXMgZnVuY3Rpb24gb24gYHNldCgpYCB0byBwcmV2ZW50IHRoYXQuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYW5kbGVTcHJlYWREb2ModiwgaW5jbHVkZUV4dHJhS2V5cykge1xuICBpZiAodXRpbHMuaXNQT0pPKHYpICYmIHYuJF9fICE9IG51bGwgJiYgdi5fZG9jICE9IG51bGwpIHtcbiAgICBpZiAoaW5jbHVkZUV4dHJhS2V5cykge1xuICAgICAgY29uc3QgZXh0cmFLZXlzID0ge307XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh2KSkge1xuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5WzBdID09PSAnJCcpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5c1RvU2tpcC5oYXMoa2V5KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGV4dHJhS2V5c1trZXldID0gdltrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgLi4udi5fZG9jLCAuLi5leHRyYUtleXMgfTtcbiAgICB9XG4gICAgcmV0dXJuIHYuX2RvYztcbiAgfVxuXG4gIHJldHVybiB2O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/document/handleSpreadDoc.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/each.js":
/*!************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/each.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function each(arr, cb, done) {\n  if (arr.length === 0) {\n    return done();\n  }\n\n  let remaining = arr.length;\n  let err = null;\n  for (const v of arr) {\n    cb(v, function(_err) {\n      if (err != null) {\n        return;\n      }\n      if (_err != null) {\n        err = _err;\n        return done(err);\n      }\n\n      if (--remaining <= 0) {\n        return done();\n      }\n    });\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZWFjaC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZWFjaC5qcz8yNzJkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlYWNoKGFyciwgY2IsIGRvbmUpIHtcbiAgaWYgKGFyci5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZG9uZSgpO1xuICB9XG5cbiAgbGV0IHJlbWFpbmluZyA9IGFyci5sZW5ndGg7XG4gIGxldCBlcnIgPSBudWxsO1xuICBmb3IgKGNvbnN0IHYgb2YgYXJyKSB7XG4gICAgY2IodiwgZnVuY3Rpb24oX2Vycikge1xuICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChfZXJyICE9IG51bGwpIHtcbiAgICAgICAgZXJyID0gX2VycjtcbiAgICAgICAgcmV0dXJuIGRvbmUoZXJyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKC0tcmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/each.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/error/combinePathErrors.js":
/*!*******************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/error/combinePathErrors.js ***!
  \*******************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = function combinePathErrors(err) {\n  const keys = Object.keys(err.errors || {});\n  const len = keys.length;\n  const msgs = [];\n  let key;\n\n  for (let i = 0; i < len; ++i) {\n    key = keys[i];\n    if (err === err.errors[key]) {\n      continue;\n    }\n    msgs.push(key + ': ' + err.errors[key].message);\n  }\n\n  return msgs.join(', ');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZXJyb3IvY29tYmluZVBhdGhFcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2Vycm9yL2NvbWJpbmVQYXRoRXJyb3JzLmpzPzRjODQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29tYmluZVBhdGhFcnJvcnMoZXJyKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhlcnIuZXJyb3JzIHx8IHt9KTtcbiAgY29uc3QgbGVuID0ga2V5cy5sZW5ndGg7XG4gIGNvbnN0IG1zZ3MgPSBbXTtcbiAgbGV0IGtleTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoZXJyID09PSBlcnIuZXJyb3JzW2tleV0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBtc2dzLnB1c2goa2V5ICsgJzogJyArIGVyci5lcnJvcnNba2V5XS5tZXNzYWdlKTtcbiAgfVxuXG4gIHJldHVybiBtc2dzLmpvaW4oJywgJyk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/error/combinePathErrors.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/firstKey.js":
/*!****************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/firstKey.js ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function firstKey(obj) {\n  if (obj == null) {\n    return null;\n  }\n  return Object.keys(obj)[0];\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZmlyc3RLZXkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZmlyc3RLZXkuanM/YmQ3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmlyc3RLZXkob2JqKSB7XG4gIGlmIChvYmogPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopWzBdO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/firstKey.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/get.js":
/*!***********************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/get.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Simplified lodash.get to work around the annoying null quirk. See:\n * https://github.com/lodash/lodash/issues/3659\n * @api private\n */\n\nmodule.exports = function get(obj, path, def) {\n  let parts;\n  let isPathArray = false;\n  if (typeof path === 'string') {\n    if (path.indexOf('.') === -1) {\n      const _v = getProperty(obj, path);\n      if (_v == null) {\n        return def;\n      }\n      return _v;\n    }\n\n    parts = path.split('.');\n  } else {\n    isPathArray = true;\n    parts = path;\n\n    if (parts.length === 1) {\n      const _v = getProperty(obj, parts[0]);\n      if (_v == null) {\n        return def;\n      }\n      return _v;\n    }\n  }\n  let rest = path;\n  let cur = obj;\n  for (const part of parts) {\n    if (cur == null) {\n      return def;\n    }\n\n    // `lib/cast.js` depends on being able to get dotted paths in updates,\n    // like `{ $set: { 'a.b': 42 } }`\n    if (!isPathArray && cur[rest] != null) {\n      return cur[rest];\n    }\n\n    cur = getProperty(cur, part);\n\n    if (!isPathArray) {\n      rest = rest.substr(part.length + 1);\n    }\n  }\n\n  return cur == null ? def : cur;\n};\n\nfunction getProperty(obj, prop) {\n  if (obj == null) {\n    return obj;\n  }\n  if (obj instanceof Map) {\n    return obj.get(prop);\n  }\n  return obj[prop];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZ2V0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVEsYUFBYTtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9nZXQuanM/YmY4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU2ltcGxpZmllZCBsb2Rhc2guZ2V0IHRvIHdvcmsgYXJvdW5kIHRoZSBhbm5veWluZyBudWxsIHF1aXJrLiBTZWU6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9pc3N1ZXMvMzY1OVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXQob2JqLCBwYXRoLCBkZWYpIHtcbiAgbGV0IHBhcnRzO1xuICBsZXQgaXNQYXRoQXJyYXkgPSBmYWxzZTtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgIGlmIChwYXRoLmluZGV4T2YoJy4nKSA9PT0gLTEpIHtcbiAgICAgIGNvbnN0IF92ID0gZ2V0UHJvcGVydHkob2JqLCBwYXRoKTtcbiAgICAgIGlmIChfdiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkZWY7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Y7XG4gICAgfVxuXG4gICAgcGFydHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIH0gZWxzZSB7XG4gICAgaXNQYXRoQXJyYXkgPSB0cnVlO1xuICAgIHBhcnRzID0gcGF0aDtcblxuICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IF92ID0gZ2V0UHJvcGVydHkob2JqLCBwYXJ0c1swXSk7XG4gICAgICBpZiAoX3YgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZGVmO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF92O1xuICAgIH1cbiAgfVxuICBsZXQgcmVzdCA9IHBhdGg7XG4gIGxldCBjdXIgPSBvYmo7XG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgIGlmIChjdXIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGRlZjtcbiAgICB9XG5cbiAgICAvLyBgbGliL2Nhc3QuanNgIGRlcGVuZHMgb24gYmVpbmcgYWJsZSB0byBnZXQgZG90dGVkIHBhdGhzIGluIHVwZGF0ZXMsXG4gICAgLy8gbGlrZSBgeyAkc2V0OiB7ICdhLmInOiA0MiB9IH1gXG4gICAgaWYgKCFpc1BhdGhBcnJheSAmJiBjdXJbcmVzdF0gIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGN1cltyZXN0XTtcbiAgICB9XG5cbiAgICBjdXIgPSBnZXRQcm9wZXJ0eShjdXIsIHBhcnQpO1xuXG4gICAgaWYgKCFpc1BhdGhBcnJheSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKHBhcnQubGVuZ3RoICsgMSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGN1ciA9PSBudWxsID8gZGVmIDogY3VyO1xufTtcblxuZnVuY3Rpb24gZ2V0UHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIGlmIChvYmogPT0gbnVsbCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgaWYgKG9iaiBpbnN0YW5jZW9mIE1hcCkge1xuICAgIHJldHVybiBvYmouZ2V0KHByb3ApO1xuICB9XG4gIHJldHVybiBvYmpbcHJvcF07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/get.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/getConstructorName.js":
/*!**************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/getConstructorName.js ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * If `val` is an object, returns constructor name, if possible. Otherwise returns undefined.\n * @api private\n */\n\nmodule.exports = function getConstructorName(val) {\n  if (val == null) {\n    return void 0;\n  }\n  if (typeof val.constructor !== 'function') {\n    return void 0;\n  }\n  return val.constructor.name;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZ2V0Q29uc3RydWN0b3JOYW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2dldENvbnN0cnVjdG9yTmFtZS5qcz8zMDhlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBJZiBgdmFsYCBpcyBhbiBvYmplY3QsIHJldHVybnMgY29uc3RydWN0b3IgbmFtZSwgaWYgcG9zc2libGUuIE90aGVyd2lzZSByZXR1cm5zIHVuZGVmaW5lZC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0Q29uc3RydWN0b3JOYW1lKHZhbCkge1xuICBpZiAodmFsID09IG51bGwpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsLmNvbnN0cnVjdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gdmFsLmNvbnN0cnVjdG9yLm5hbWU7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/getConstructorName.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/getDefaultBulkwriteResult.js":
/*!*********************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/getDefaultBulkwriteResult.js ***!
  \*********************************************************************************/
/***/ ((module) => {

"use strict";
eval("\nfunction getDefaultBulkwriteResult() {\n  return {\n    result: {\n      ok: 1,\n      writeErrors: [],\n      writeConcernErrors: [],\n      insertedIds: [],\n      nInserted: 0,\n      nUpserted: 0,\n      nMatched: 0,\n      nModified: 0,\n      nRemoved: 0,\n      upserted: []\n    },\n    insertedCount: 0,\n    matchedCount: 0,\n    modifiedCount: 0,\n    deletedCount: 0,\n    upsertedCount: 0,\n    upsertedIds: {},\n    insertedIds: {},\n    n: 0\n  };\n}\n\nmodule.exports = getDefaultBulkwriteResult;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZ2V0RGVmYXVsdEJ1bGt3cml0ZVJlc3VsdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2dldERlZmF1bHRCdWxrd3JpdGVSZXN1bHQuanM/MGJlMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5mdW5jdGlvbiBnZXREZWZhdWx0QnVsa3dyaXRlUmVzdWx0KCkge1xuICByZXR1cm4ge1xuICAgIHJlc3VsdDoge1xuICAgICAgb2s6IDEsXG4gICAgICB3cml0ZUVycm9yczogW10sXG4gICAgICB3cml0ZUNvbmNlcm5FcnJvcnM6IFtdLFxuICAgICAgaW5zZXJ0ZWRJZHM6IFtdLFxuICAgICAgbkluc2VydGVkOiAwLFxuICAgICAgblVwc2VydGVkOiAwLFxuICAgICAgbk1hdGNoZWQ6IDAsXG4gICAgICBuTW9kaWZpZWQ6IDAsXG4gICAgICBuUmVtb3ZlZDogMCxcbiAgICAgIHVwc2VydGVkOiBbXVxuICAgIH0sXG4gICAgaW5zZXJ0ZWRDb3VudDogMCxcbiAgICBtYXRjaGVkQ291bnQ6IDAsXG4gICAgbW9kaWZpZWRDb3VudDogMCxcbiAgICBkZWxldGVkQ291bnQ6IDAsXG4gICAgdXBzZXJ0ZWRDb3VudDogMCxcbiAgICB1cHNlcnRlZElkczoge30sXG4gICAgaW5zZXJ0ZWRJZHM6IHt9LFxuICAgIG46IDBcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXREZWZhdWx0QnVsa3dyaXRlUmVzdWx0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/getDefaultBulkwriteResult.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/getFunctionName.js":
/*!***********************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/getFunctionName.js ***!
  \***********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst functionNameRE = /^function\\s*([^\\s(]+)/;\n\nmodule.exports = function(fn) {\n  return (\n    fn.name ||\n    (fn.toString().trim().match(functionNameRE) || [])[1]\n  );\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvZ2V0RnVuY3Rpb25OYW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2dldEZ1bmN0aW9uTmFtZS5qcz8yMGZjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZnVuY3Rpb25OYW1lUkUgPSAvXmZ1bmN0aW9uXFxzKihbXlxccyhdKykvO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuKSB7XG4gIHJldHVybiAoXG4gICAgZm4ubmFtZSB8fFxuICAgIChmbi50b1N0cmluZygpLnRyaW0oKS5tYXRjaChmdW5jdGlvbk5hbWVSRSkgfHwgW10pWzFdXG4gICk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/getFunctionName.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/immediate.js":
/*!*****************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/immediate.js ***!
  \*****************************************************************/
/***/ ((module) => {

"use strict";
eval("/*!\n * Centralize this so we can more easily work around issues with people\n * stubbing out `process.nextTick()` in tests using sinon:\n * https://github.com/sinonjs/lolex#automatically-incrementing-mocked-time\n * See gh-6074\n */\n\n\n\nconst nextTick = typeof process !== 'undefined' && typeof process.nextTick === 'function' ?\n  process.nextTick.bind(process) :\n  cb => setTimeout(cb, 0); // Fallback for browser build\n\nmodule.exports = function immediate(cb) {\n  return nextTick(cb);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaW1tZWRpYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pbW1lZGlhdGUuanM/MDNmOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENlbnRyYWxpemUgdGhpcyBzbyB3ZSBjYW4gbW9yZSBlYXNpbHkgd29yayBhcm91bmQgaXNzdWVzIHdpdGggcGVvcGxlXG4gKiBzdHViYmluZyBvdXQgYHByb2Nlc3MubmV4dFRpY2soKWAgaW4gdGVzdHMgdXNpbmcgc2lub246XG4gKiBodHRwczovL2dpdGh1Yi5jb20vc2lub25qcy9sb2xleCNhdXRvbWF0aWNhbGx5LWluY3JlbWVudGluZy1tb2NrZWQtdGltZVxuICogU2VlIGdoLTYwNzRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IG5leHRUaWNrID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwcm9jZXNzLm5leHRUaWNrID09PSAnZnVuY3Rpb24nID9cbiAgcHJvY2Vzcy5uZXh0VGljay5iaW5kKHByb2Nlc3MpIDpcbiAgY2IgPT4gc2V0VGltZW91dChjYiwgMCk7IC8vIEZhbGxiYWNrIGZvciBicm93c2VyIGJ1aWxkXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW1tZWRpYXRlKGNiKSB7XG4gIHJldHVybiBuZXh0VGljayhjYik7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/immediate.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/indexes/applySchemaCollation.js":
/*!************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/indexes/applySchemaCollation.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst isTextIndex = __webpack_require__(/*! ./isTextIndex */ \"../backend/node_modules/mongoose/lib/helpers/indexes/isTextIndex.js\");\n\nmodule.exports = function applySchemaCollation(indexKeys, indexOptions, schemaOptions) {\n  if (isTextIndex(indexKeys)) {\n    return;\n  }\n\n  if (schemaOptions.hasOwnProperty('collation') && !indexOptions.hasOwnProperty('collation')) {\n    indexOptions.collation = schemaOptions.collation;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaW5kZXhlcy9hcHBseVNjaGVtYUNvbGxhdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixvQkFBb0IsbUJBQU8sQ0FBQywwRkFBZTs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pbmRleGVzL2FwcGx5U2NoZW1hQ29sbGF0aW9uLmpzPzAwZGUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpc1RleHRJbmRleCA9IHJlcXVpcmUoJy4vaXNUZXh0SW5kZXgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhcHBseVNjaGVtYUNvbGxhdGlvbihpbmRleEtleXMsIGluZGV4T3B0aW9ucywgc2NoZW1hT3B0aW9ucykge1xuICBpZiAoaXNUZXh0SW5kZXgoaW5kZXhLZXlzKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzY2hlbWFPcHRpb25zLmhhc093blByb3BlcnR5KCdjb2xsYXRpb24nKSAmJiAhaW5kZXhPcHRpb25zLmhhc093blByb3BlcnR5KCdjb2xsYXRpb24nKSkge1xuICAgIGluZGV4T3B0aW9ucy5jb2xsYXRpb24gPSBzY2hlbWFPcHRpb25zLmNvbGxhdGlvbjtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/indexes/applySchemaCollation.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/indexes/decorateDiscriminatorIndexOptions.js":
/*!*************************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/indexes/decorateDiscriminatorIndexOptions.js ***!
  \*************************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function decorateDiscriminatorIndexOptions(schema, indexOptions) {\n  // If the model is a discriminator and has an index, add a\n  // partialFilterExpression by default so the index will only apply\n  // to that discriminator.\n  const discriminatorName = schema.discriminatorMapping && schema.discriminatorMapping.value;\n  if (discriminatorName && !('sparse' in indexOptions)) {\n    const discriminatorKey = schema.options.discriminatorKey;\n    indexOptions.partialFilterExpression = indexOptions.partialFilterExpression || {};\n    indexOptions.partialFilterExpression[discriminatorKey] = discriminatorName;\n  }\n  return indexOptions;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaW5kZXhlcy9kZWNvcmF0ZURpc2NyaW1pbmF0b3JJbmRleE9wdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaW5kZXhlcy9kZWNvcmF0ZURpc2NyaW1pbmF0b3JJbmRleE9wdGlvbnMuanM/ZjUwOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVjb3JhdGVEaXNjcmltaW5hdG9ySW5kZXhPcHRpb25zKHNjaGVtYSwgaW5kZXhPcHRpb25zKSB7XG4gIC8vIElmIHRoZSBtb2RlbCBpcyBhIGRpc2NyaW1pbmF0b3IgYW5kIGhhcyBhbiBpbmRleCwgYWRkIGFcbiAgLy8gcGFydGlhbEZpbHRlckV4cHJlc3Npb24gYnkgZGVmYXVsdCBzbyB0aGUgaW5kZXggd2lsbCBvbmx5IGFwcGx5XG4gIC8vIHRvIHRoYXQgZGlzY3JpbWluYXRvci5cbiAgY29uc3QgZGlzY3JpbWluYXRvck5hbWUgPSBzY2hlbWEuZGlzY3JpbWluYXRvck1hcHBpbmcgJiYgc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nLnZhbHVlO1xuICBpZiAoZGlzY3JpbWluYXRvck5hbWUgJiYgISgnc3BhcnNlJyBpbiBpbmRleE9wdGlvbnMpKSB7XG4gICAgY29uc3QgZGlzY3JpbWluYXRvcktleSA9IHNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXk7XG4gICAgaW5kZXhPcHRpb25zLnBhcnRpYWxGaWx0ZXJFeHByZXNzaW9uID0gaW5kZXhPcHRpb25zLnBhcnRpYWxGaWx0ZXJFeHByZXNzaW9uIHx8IHt9O1xuICAgIGluZGV4T3B0aW9ucy5wYXJ0aWFsRmlsdGVyRXhwcmVzc2lvbltkaXNjcmltaW5hdG9yS2V5XSA9IGRpc2NyaW1pbmF0b3JOYW1lO1xuICB9XG4gIHJldHVybiBpbmRleE9wdGlvbnM7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/indexes/decorateDiscriminatorIndexOptions.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/indexes/getRelatedIndexes.js":
/*!*********************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/indexes/getRelatedIndexes.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst hasDollarKeys = __webpack_require__(/*! ../query/hasDollarKeys */ \"../backend/node_modules/mongoose/lib/helpers/query/hasDollarKeys.js\");\n\nfunction getRelatedSchemaIndexes(model, schemaIndexes) {\n  return getRelatedIndexes({\n    baseModelName: model.baseModelName,\n    discriminatorMapping: model.schema.discriminatorMapping,\n    indexes: schemaIndexes,\n    indexesType: 'schema'\n  });\n}\n\nfunction getRelatedDBIndexes(model, dbIndexes) {\n  return getRelatedIndexes({\n    baseModelName: model.baseModelName,\n    discriminatorMapping: model.schema.discriminatorMapping,\n    indexes: dbIndexes,\n    indexesType: 'db'\n  });\n}\n\nmodule.exports = {\n  getRelatedSchemaIndexes,\n  getRelatedDBIndexes\n};\n\nfunction getRelatedIndexes({\n  baseModelName,\n  discriminatorMapping,\n  indexes,\n  indexesType\n}) {\n  const discriminatorKey = discriminatorMapping && discriminatorMapping.key;\n  const discriminatorValue = discriminatorMapping && discriminatorMapping.value;\n\n  if (!discriminatorKey) {\n    return indexes;\n  }\n\n  const isChildDiscriminatorModel = Boolean(baseModelName);\n  if (isChildDiscriminatorModel) {\n    return indexes.filter(index => {\n      const partialFilterExpression = getPartialFilterExpression(index, indexesType);\n      return partialFilterExpression && partialFilterExpression[discriminatorKey] === discriminatorValue;\n    });\n  }\n\n  return indexes.filter(index => {\n    const partialFilterExpression = getPartialFilterExpression(index, indexesType);\n    return !partialFilterExpression\n      || !partialFilterExpression[discriminatorKey]\n      || (hasDollarKeys(partialFilterExpression[discriminatorKey]) && !('$eq' in partialFilterExpression[discriminatorKey]));\n  });\n}\n\nfunction getPartialFilterExpression(index, indexesType) {\n  if (indexesType === 'schema') {\n    const options = index[1];\n    return options && options.partialFilterExpression;\n  }\n  return index.partialFilterExpression;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaW5kZXhlcy9nZXRSZWxhdGVkSW5kZXhlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyxtR0FBd0I7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pbmRleGVzL2dldFJlbGF0ZWRJbmRleGVzLmpzPzMyODYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBoYXNEb2xsYXJLZXlzID0gcmVxdWlyZSgnLi4vcXVlcnkvaGFzRG9sbGFyS2V5cycpO1xuXG5mdW5jdGlvbiBnZXRSZWxhdGVkU2NoZW1hSW5kZXhlcyhtb2RlbCwgc2NoZW1hSW5kZXhlcykge1xuICByZXR1cm4gZ2V0UmVsYXRlZEluZGV4ZXMoe1xuICAgIGJhc2VNb2RlbE5hbWU6IG1vZGVsLmJhc2VNb2RlbE5hbWUsXG4gICAgZGlzY3JpbWluYXRvck1hcHBpbmc6IG1vZGVsLnNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZyxcbiAgICBpbmRleGVzOiBzY2hlbWFJbmRleGVzLFxuICAgIGluZGV4ZXNUeXBlOiAnc2NoZW1hJ1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVsYXRlZERCSW5kZXhlcyhtb2RlbCwgZGJJbmRleGVzKSB7XG4gIHJldHVybiBnZXRSZWxhdGVkSW5kZXhlcyh7XG4gICAgYmFzZU1vZGVsTmFtZTogbW9kZWwuYmFzZU1vZGVsTmFtZSxcbiAgICBkaXNjcmltaW5hdG9yTWFwcGluZzogbW9kZWwuc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nLFxuICAgIGluZGV4ZXM6IGRiSW5kZXhlcyxcbiAgICBpbmRleGVzVHlwZTogJ2RiJ1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldFJlbGF0ZWRTY2hlbWFJbmRleGVzLFxuICBnZXRSZWxhdGVkREJJbmRleGVzXG59O1xuXG5mdW5jdGlvbiBnZXRSZWxhdGVkSW5kZXhlcyh7XG4gIGJhc2VNb2RlbE5hbWUsXG4gIGRpc2NyaW1pbmF0b3JNYXBwaW5nLFxuICBpbmRleGVzLFxuICBpbmRleGVzVHlwZVxufSkge1xuICBjb25zdCBkaXNjcmltaW5hdG9yS2V5ID0gZGlzY3JpbWluYXRvck1hcHBpbmcgJiYgZGlzY3JpbWluYXRvck1hcHBpbmcua2V5O1xuICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWUgPSBkaXNjcmltaW5hdG9yTWFwcGluZyAmJiBkaXNjcmltaW5hdG9yTWFwcGluZy52YWx1ZTtcblxuICBpZiAoIWRpc2NyaW1pbmF0b3JLZXkpIHtcbiAgICByZXR1cm4gaW5kZXhlcztcbiAgfVxuXG4gIGNvbnN0IGlzQ2hpbGREaXNjcmltaW5hdG9yTW9kZWwgPSBCb29sZWFuKGJhc2VNb2RlbE5hbWUpO1xuICBpZiAoaXNDaGlsZERpc2NyaW1pbmF0b3JNb2RlbCkge1xuICAgIHJldHVybiBpbmRleGVzLmZpbHRlcihpbmRleCA9PiB7XG4gICAgICBjb25zdCBwYXJ0aWFsRmlsdGVyRXhwcmVzc2lvbiA9IGdldFBhcnRpYWxGaWx0ZXJFeHByZXNzaW9uKGluZGV4LCBpbmRleGVzVHlwZSk7XG4gICAgICByZXR1cm4gcGFydGlhbEZpbHRlckV4cHJlc3Npb24gJiYgcGFydGlhbEZpbHRlckV4cHJlc3Npb25bZGlzY3JpbWluYXRvcktleV0gPT09IGRpc2NyaW1pbmF0b3JWYWx1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBpbmRleGVzLmZpbHRlcihpbmRleCA9PiB7XG4gICAgY29uc3QgcGFydGlhbEZpbHRlckV4cHJlc3Npb24gPSBnZXRQYXJ0aWFsRmlsdGVyRXhwcmVzc2lvbihpbmRleCwgaW5kZXhlc1R5cGUpO1xuICAgIHJldHVybiAhcGFydGlhbEZpbHRlckV4cHJlc3Npb25cbiAgICAgIHx8ICFwYXJ0aWFsRmlsdGVyRXhwcmVzc2lvbltkaXNjcmltaW5hdG9yS2V5XVxuICAgICAgfHwgKGhhc0RvbGxhcktleXMocGFydGlhbEZpbHRlckV4cHJlc3Npb25bZGlzY3JpbWluYXRvcktleV0pICYmICEoJyRlcScgaW4gcGFydGlhbEZpbHRlckV4cHJlc3Npb25bZGlzY3JpbWluYXRvcktleV0pKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFBhcnRpYWxGaWx0ZXJFeHByZXNzaW9uKGluZGV4LCBpbmRleGVzVHlwZSkge1xuICBpZiAoaW5kZXhlc1R5cGUgPT09ICdzY2hlbWEnKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGluZGV4WzFdO1xuICAgIHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMucGFydGlhbEZpbHRlckV4cHJlc3Npb247XG4gIH1cbiAgcmV0dXJuIGluZGV4LnBhcnRpYWxGaWx0ZXJFeHByZXNzaW9uO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/indexes/getRelatedIndexes.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/indexes/isDefaultIdIndex.js":
/*!********************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/indexes/isDefaultIdIndex.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst get = __webpack_require__(/*! ../get */ \"../backend/node_modules/mongoose/lib/helpers/get.js\");\n\nmodule.exports = function isDefaultIdIndex(index) {\n  if (Array.isArray(index)) {\n    // Mongoose syntax\n    const keys = Object.keys(index[0]);\n    return keys.length === 1 && keys[0] === '_id' && index[0]._id !== 'hashed';\n  }\n\n  if (typeof index !== 'object') {\n    return false;\n  }\n\n  const key = get(index, 'key', {});\n  return Object.keys(key).length === 1 && key.hasOwnProperty('_id');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaW5kZXhlcy9pc0RlZmF1bHRJZEluZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxtRUFBUTs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7QUFDbEM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2luZGV4ZXMvaXNEZWZhdWx0SWRJbmRleC5qcz9mOTVmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZ2V0ID0gcmVxdWlyZSgnLi4vZ2V0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNEZWZhdWx0SWRJbmRleChpbmRleCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShpbmRleCkpIHtcbiAgICAvLyBNb25nb29zZSBzeW50YXhcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaW5kZXhbMF0pO1xuICAgIHJldHVybiBrZXlzLmxlbmd0aCA9PT0gMSAmJiBrZXlzWzBdID09PSAnX2lkJyAmJiBpbmRleFswXS5faWQgIT09ICdoYXNoZWQnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBrZXkgPSBnZXQoaW5kZXgsICdrZXknLCB7fSk7XG4gIHJldHVybiBPYmplY3Qua2V5cyhrZXkpLmxlbmd0aCA9PT0gMSAmJiBrZXkuaGFzT3duUHJvcGVydHkoJ19pZCcpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/indexes/isDefaultIdIndex.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/indexes/isIndexEqual.js":
/*!****************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/indexes/isIndexEqual.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst get = __webpack_require__(/*! ../get */ \"../backend/node_modules/mongoose/lib/helpers/get.js\");\nconst utils = __webpack_require__(/*! ../../utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\n/**\n * Given a Mongoose index definition (key + options objects) and a MongoDB server\n * index definition, determine if the two indexes are equal.\n *\n * @param {Object} schemaIndexKeysObject the Mongoose index spec\n * @param {Object} options the Mongoose index definition's options\n * @param {Object} dbIndex the index in MongoDB as returned by `listIndexes()`\n * @api private\n */\n\nmodule.exports = function isIndexEqual(schemaIndexKeysObject, options, dbIndex) {\n  // Special case: text indexes have a special format in the db. For example,\n  // `{ name: 'text' }` becomes:\n  // {\n  //   v: 2,\n  //   key: { _fts: 'text', _ftsx: 1 },\n  //   name: 'name_text',\n  //   ns: 'test.tests',\n  //   background: true,\n  //   weights: { name: 1 },\n  //   default_language: 'english',\n  //   language_override: 'language',\n  //   textIndexVersion: 3\n  // }\n  if (dbIndex.textIndexVersion != null) {\n    delete dbIndex.key._fts;\n    delete dbIndex.key._ftsx;\n    const weights = { ...dbIndex.weights, ...dbIndex.key };\n    if (Object.keys(weights).length !== Object.keys(schemaIndexKeysObject).length) {\n      return false;\n    }\n    for (const prop of Object.keys(weights)) {\n      if (!(prop in schemaIndexKeysObject)) {\n        return false;\n      }\n      const weight = weights[prop];\n      if (weight !== get(options, 'weights.' + prop) && !(weight === 1 && get(options, 'weights.' + prop) == null)) {\n        return false;\n      }\n    }\n\n    if (options['default_language'] !== dbIndex['default_language']) {\n      return dbIndex['default_language'] === 'english' && options['default_language'] == null;\n    }\n\n    return true;\n  }\n\n  const optionKeys = [\n    'unique',\n    'partialFilterExpression',\n    'sparse',\n    'expireAfterSeconds',\n    'collation'\n  ];\n  for (const key of optionKeys) {\n    if (!(key in options) && !(key in dbIndex)) {\n      continue;\n    }\n    if (key === 'collation') {\n      if (options[key] == null || dbIndex[key] == null) {\n        return options[key] == null && dbIndex[key] == null;\n      }\n      const definedKeys = Object.keys(options.collation);\n      const schemaCollation = options.collation;\n      const dbCollation = dbIndex.collation;\n      for (const opt of definedKeys) {\n        if (get(schemaCollation, opt) !== get(dbCollation, opt)) {\n          return false;\n        }\n      }\n    } else if (!utils.deepEqual(options[key], dbIndex[key])) {\n      return false;\n    }\n  }\n\n  const schemaIndexKeys = Object.keys(schemaIndexKeysObject);\n  const dbIndexKeys = Object.keys(dbIndex.key);\n  if (schemaIndexKeys.length !== dbIndexKeys.length) {\n    return false;\n  }\n  for (let i = 0; i < schemaIndexKeys.length; ++i) {\n    if (schemaIndexKeys[i] !== dbIndexKeys[i]) {\n      return false;\n    }\n    if (!utils.deepEqual(schemaIndexKeysObject[schemaIndexKeys[i]], dbIndex.key[dbIndexKeys[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaW5kZXhlcy9pc0luZGV4RXF1YWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLG1FQUFRO0FBQzVCLGNBQWMsbUJBQU8sQ0FBQyxrRUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsY0FBYztBQUN0QjtBQUNBO0FBQ0EsY0FBYyx3QkFBd0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNEJBQTRCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9pbmRleGVzL2lzSW5kZXhFcXVhbC5qcz8wNDViIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZ2V0ID0gcmVxdWlyZSgnLi4vZ2V0Jyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG4vKipcbiAqIEdpdmVuIGEgTW9uZ29vc2UgaW5kZXggZGVmaW5pdGlvbiAoa2V5ICsgb3B0aW9ucyBvYmplY3RzKSBhbmQgYSBNb25nb0RCIHNlcnZlclxuICogaW5kZXggZGVmaW5pdGlvbiwgZGV0ZXJtaW5lIGlmIHRoZSB0d28gaW5kZXhlcyBhcmUgZXF1YWwuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHNjaGVtYUluZGV4S2V5c09iamVjdCB0aGUgTW9uZ29vc2UgaW5kZXggc3BlY1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdGhlIE1vbmdvb3NlIGluZGV4IGRlZmluaXRpb24ncyBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gZGJJbmRleCB0aGUgaW5kZXggaW4gTW9uZ29EQiBhcyByZXR1cm5lZCBieSBgbGlzdEluZGV4ZXMoKWBcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNJbmRleEVxdWFsKHNjaGVtYUluZGV4S2V5c09iamVjdCwgb3B0aW9ucywgZGJJbmRleCkge1xuICAvLyBTcGVjaWFsIGNhc2U6IHRleHQgaW5kZXhlcyBoYXZlIGEgc3BlY2lhbCBmb3JtYXQgaW4gdGhlIGRiLiBGb3IgZXhhbXBsZSxcbiAgLy8gYHsgbmFtZTogJ3RleHQnIH1gIGJlY29tZXM6XG4gIC8vIHtcbiAgLy8gICB2OiAyLFxuICAvLyAgIGtleTogeyBfZnRzOiAndGV4dCcsIF9mdHN4OiAxIH0sXG4gIC8vICAgbmFtZTogJ25hbWVfdGV4dCcsXG4gIC8vICAgbnM6ICd0ZXN0LnRlc3RzJyxcbiAgLy8gICBiYWNrZ3JvdW5kOiB0cnVlLFxuICAvLyAgIHdlaWdodHM6IHsgbmFtZTogMSB9LFxuICAvLyAgIGRlZmF1bHRfbGFuZ3VhZ2U6ICdlbmdsaXNoJyxcbiAgLy8gICBsYW5ndWFnZV9vdmVycmlkZTogJ2xhbmd1YWdlJyxcbiAgLy8gICB0ZXh0SW5kZXhWZXJzaW9uOiAzXG4gIC8vIH1cbiAgaWYgKGRiSW5kZXgudGV4dEluZGV4VmVyc2lvbiAhPSBudWxsKSB7XG4gICAgZGVsZXRlIGRiSW5kZXgua2V5Ll9mdHM7XG4gICAgZGVsZXRlIGRiSW5kZXgua2V5Ll9mdHN4O1xuICAgIGNvbnN0IHdlaWdodHMgPSB7IC4uLmRiSW5kZXgud2VpZ2h0cywgLi4uZGJJbmRleC5rZXkgfTtcbiAgICBpZiAoT2JqZWN0LmtleXMod2VpZ2h0cykubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhzY2hlbWFJbmRleEtleXNPYmplY3QpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgT2JqZWN0LmtleXMod2VpZ2h0cykpIHtcbiAgICAgIGlmICghKHByb3AgaW4gc2NoZW1hSW5kZXhLZXlzT2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCB3ZWlnaHQgPSB3ZWlnaHRzW3Byb3BdO1xuICAgICAgaWYgKHdlaWdodCAhPT0gZ2V0KG9wdGlvbnMsICd3ZWlnaHRzLicgKyBwcm9wKSAmJiAhKHdlaWdodCA9PT0gMSAmJiBnZXQob3B0aW9ucywgJ3dlaWdodHMuJyArIHByb3ApID09IG51bGwpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9uc1snZGVmYXVsdF9sYW5ndWFnZSddICE9PSBkYkluZGV4WydkZWZhdWx0X2xhbmd1YWdlJ10pIHtcbiAgICAgIHJldHVybiBkYkluZGV4WydkZWZhdWx0X2xhbmd1YWdlJ10gPT09ICdlbmdsaXNoJyAmJiBvcHRpb25zWydkZWZhdWx0X2xhbmd1YWdlJ10gPT0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IG9wdGlvbktleXMgPSBbXG4gICAgJ3VuaXF1ZScsXG4gICAgJ3BhcnRpYWxGaWx0ZXJFeHByZXNzaW9uJyxcbiAgICAnc3BhcnNlJyxcbiAgICAnZXhwaXJlQWZ0ZXJTZWNvbmRzJyxcbiAgICAnY29sbGF0aW9uJ1xuICBdO1xuICBmb3IgKGNvbnN0IGtleSBvZiBvcHRpb25LZXlzKSB7XG4gICAgaWYgKCEoa2V5IGluIG9wdGlvbnMpICYmICEoa2V5IGluIGRiSW5kZXgpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGtleSA9PT0gJ2NvbGxhdGlvbicpIHtcbiAgICAgIGlmIChvcHRpb25zW2tleV0gPT0gbnVsbCB8fCBkYkluZGV4W2tleV0gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gb3B0aW9uc1trZXldID09IG51bGwgJiYgZGJJbmRleFtrZXldID09IG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBkZWZpbmVkS2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMuY29sbGF0aW9uKTtcbiAgICAgIGNvbnN0IHNjaGVtYUNvbGxhdGlvbiA9IG9wdGlvbnMuY29sbGF0aW9uO1xuICAgICAgY29uc3QgZGJDb2xsYXRpb24gPSBkYkluZGV4LmNvbGxhdGlvbjtcbiAgICAgIGZvciAoY29uc3Qgb3B0IG9mIGRlZmluZWRLZXlzKSB7XG4gICAgICAgIGlmIChnZXQoc2NoZW1hQ29sbGF0aW9uLCBvcHQpICE9PSBnZXQoZGJDb2xsYXRpb24sIG9wdCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCF1dGlscy5kZWVwRXF1YWwob3B0aW9uc1trZXldLCBkYkluZGV4W2tleV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc2NoZW1hSW5kZXhLZXlzID0gT2JqZWN0LmtleXMoc2NoZW1hSW5kZXhLZXlzT2JqZWN0KTtcbiAgY29uc3QgZGJJbmRleEtleXMgPSBPYmplY3Qua2V5cyhkYkluZGV4LmtleSk7XG4gIGlmIChzY2hlbWFJbmRleEtleXMubGVuZ3RoICE9PSBkYkluZGV4S2V5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWFJbmRleEtleXMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoc2NoZW1hSW5kZXhLZXlzW2ldICE9PSBkYkluZGV4S2V5c1tpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXV0aWxzLmRlZXBFcXVhbChzY2hlbWFJbmRleEtleXNPYmplY3Rbc2NoZW1hSW5kZXhLZXlzW2ldXSwgZGJJbmRleC5rZXlbZGJJbmRleEtleXNbaV1dKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/indexes/isIndexEqual.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/indexes/isTextIndex.js":
/*!***************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/indexes/isTextIndex.js ***!
  \***************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Returns `true` if the given index options have a `text` option.\n */\n\nmodule.exports = function isTextIndex(indexKeys) {\n  let isTextIndex = false;\n  for (const key of Object.keys(indexKeys)) {\n    if (indexKeys[key] === 'text') {\n      isTextIndex = true;\n    }\n  }\n\n  return isTextIndex;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaW5kZXhlcy9pc1RleHRJbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2luZGV4ZXMvaXNUZXh0SW5kZXguanM/YzU1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGluZGV4IG9wdGlvbnMgaGF2ZSBhIGB0ZXh0YCBvcHRpb24uXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1RleHRJbmRleChpbmRleEtleXMpIHtcbiAgbGV0IGlzVGV4dEluZGV4ID0gZmFsc2U7XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGluZGV4S2V5cykpIHtcbiAgICBpZiAoaW5kZXhLZXlzW2tleV0gPT09ICd0ZXh0Jykge1xuICAgICAgaXNUZXh0SW5kZXggPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpc1RleHRJbmRleDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/indexes/isTextIndex.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/isAsyncFunction.js":
/*!***********************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/isAsyncFunction.js ***!
  \***********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function isAsyncFunction(v) {\n  return (\n    typeof v === 'function' &&\n    v.constructor &&\n    v.constructor.name === 'AsyncFunction'\n  );\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaXNBc3luY0Z1bmN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaXNBc3luY0Z1bmN0aW9uLmpzPzJhMDMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQXN5bmNGdW5jdGlvbih2KSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHYgPT09ICdmdW5jdGlvbicgJiZcbiAgICB2LmNvbnN0cnVjdG9yICYmXG4gICAgdi5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQXN5bmNGdW5jdGlvbidcbiAgKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/isAsyncFunction.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/isBsonType.js":
/*!******************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/isBsonType.js ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Get the bson type, if it exists\n * @api private\n */\n\nfunction isBsonType(obj, typename) {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    obj._bsontype === typename\n  );\n}\n\nmodule.exports = isBsonType;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaXNCc29uVHlwZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2lzQnNvblR5cGUuanM/YzI0YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2V0IHRoZSBic29uIHR5cGUsIGlmIGl0IGV4aXN0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNCc29uVHlwZShvYmosIHR5cGVuYW1lKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiZcbiAgICBvYmogIT09IG51bGwgJiZcbiAgICBvYmouX2Jzb250eXBlID09PSB0eXBlbmFtZVxuICApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnNvblR5cGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/isBsonType.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/isMongooseObject.js":
/*!************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/isMongooseObject.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst isMongooseArray = (__webpack_require__(/*! ../types/array/isMongooseArray */ \"../backend/node_modules/mongoose/lib/types/array/isMongooseArray.js\").isMongooseArray);\n/**\n * Returns if `v` is a mongoose object that has a `toObject()` method we can use.\n *\n * This is for compatibility with libs like Date.js which do foolish things to Natives.\n *\n * @param {Any} v\n * @api private\n */\n\nmodule.exports = function(v) {\n  return (\n    v != null && (\n      isMongooseArray(v) || // Array or Document Array\n      v.$__ != null || // Document\n      v.isMongooseBuffer || // Buffer\n      v.$isMongooseMap // Map\n    )\n  );\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaXNNb25nb29zZU9iamVjdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYix3QkFBd0Isa0pBQXlEO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL2lzTW9uZ29vc2VPYmplY3QuanM/OWZlNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGlzTW9uZ29vc2VBcnJheSA9IHJlcXVpcmUoJy4uL3R5cGVzL2FycmF5L2lzTW9uZ29vc2VBcnJheScpLmlzTW9uZ29vc2VBcnJheTtcbi8qKlxuICogUmV0dXJucyBpZiBgdmAgaXMgYSBtb25nb29zZSBvYmplY3QgdGhhdCBoYXMgYSBgdG9PYmplY3QoKWAgbWV0aG9kIHdlIGNhbiB1c2UuXG4gKlxuICogVGhpcyBpcyBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGxpYnMgbGlrZSBEYXRlLmpzIHdoaWNoIGRvIGZvb2xpc2ggdGhpbmdzIHRvIE5hdGl2ZXMuXG4gKlxuICogQHBhcmFtIHtBbnl9IHZcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gKFxuICAgIHYgIT0gbnVsbCAmJiAoXG4gICAgICBpc01vbmdvb3NlQXJyYXkodikgfHwgLy8gQXJyYXkgb3IgRG9jdW1lbnQgQXJyYXlcbiAgICAgIHYuJF9fICE9IG51bGwgfHwgLy8gRG9jdW1lbnRcbiAgICAgIHYuaXNNb25nb29zZUJ1ZmZlciB8fCAvLyBCdWZmZXJcbiAgICAgIHYuJGlzTW9uZ29vc2VNYXAgLy8gTWFwXG4gICAgKVxuICApO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/isMongooseObject.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/isObject.js":
/*!****************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/isObject.js ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Determines if `arg` is an object.\n *\n * @param {Object|Array|String|Function|RegExp|any} arg\n * @api private\n * @return {Boolean}\n */\n\nmodule.exports = function(arg) {\n  return (\n    Buffer.isBuffer(arg) ||\n    Object.prototype.toString.call(arg) === '[object Object]'\n  );\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaXNPYmplY3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5Q0FBeUM7QUFDcEQ7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaXNPYmplY3QuanM/MDI1YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBgYXJnYCBpcyBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl8U3RyaW5nfEZ1bmN0aW9ufFJlZ0V4cHxhbnl9IGFyZ1xuICogQGFwaSBwcml2YXRlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiAoXG4gICAgQnVmZmVyLmlzQnVmZmVyKGFyZykgfHxcbiAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJnKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSdcbiAgKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/isObject.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/isPOJO.js":
/*!**************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/isPOJO.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function isPOJO(arg) {\n  if (arg == null || typeof arg !== 'object') {\n    return false;\n  }\n  const proto = Object.getPrototypeOf(arg);\n  // Prototype may be null if you used `Object.create(null)`\n  // Checking `proto`'s constructor is safe because `getPrototypeOf()`\n  // explicitly crosses the boundary from object data to object metadata\n  return !proto || proto.constructor.name === 'Object';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaXNQT0pPLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaXNQT0pPLmpzP2JlNDIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzUE9KTyhhcmcpIHtcbiAgaWYgKGFyZyA9PSBudWxsIHx8IHR5cGVvZiBhcmcgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGFyZyk7XG4gIC8vIFByb3RvdHlwZSBtYXkgYmUgbnVsbCBpZiB5b3UgdXNlZCBgT2JqZWN0LmNyZWF0ZShudWxsKWBcbiAgLy8gQ2hlY2tpbmcgYHByb3RvYCdzIGNvbnN0cnVjdG9yIGlzIHNhZmUgYmVjYXVzZSBgZ2V0UHJvdG90eXBlT2YoKWBcbiAgLy8gZXhwbGljaXRseSBjcm9zc2VzIHRoZSBib3VuZGFyeSBmcm9tIG9iamVjdCBkYXRhIHRvIG9iamVjdCBtZXRhZGF0YVxuICByZXR1cm4gIXByb3RvIHx8IHByb3RvLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdPYmplY3QnO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/isPOJO.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/isPromise.js":
/*!*****************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/isPromise.js ***!
  \*****************************************************************/
/***/ ((module) => {

"use strict";
eval("\nfunction isPromise(val) {\n  return !!val && (typeof val === 'object' || typeof val === 'function') && typeof val.then === 'function';\n}\n\nmodule.exports = isPromise;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaXNQcm9taXNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaXNQcm9taXNlLmpzPzk0MGIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuZnVuY3Rpb24gaXNQcm9taXNlKHZhbCkge1xuICByZXR1cm4gISF2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpICYmIHR5cGVvZiB2YWwudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1Byb21pc2U7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/isPromise.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/isSimpleValidator.js":
/*!*************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/isSimpleValidator.js ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Determines if `arg` is a flat object.\n *\n * @param {Object|Array|String|Function|RegExp|any} arg\n * @api private\n * @return {Boolean}\n */\n\nmodule.exports = function isSimpleValidator(obj) {\n  const keys = Object.keys(obj);\n  let result = true;\n  for (let i = 0, len = keys.length; i < len; ++i) {\n    if (typeof obj[keys[i]] === 'object' && obj[keys[i]] !== null) {\n      result = false;\n      break;\n    }\n  }\n\n  return result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaXNTaW1wbGVWYWxpZGF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5Q0FBeUM7QUFDcEQ7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFNBQVM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvaXNTaW1wbGVWYWxpZGF0b3IuanM/YjcyYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBgYXJnYCBpcyBhIGZsYXQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fFN0cmluZ3xGdW5jdGlvbnxSZWdFeHB8YW55fSBhcmdcbiAqIEBhcGkgcHJpdmF0ZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzU2ltcGxlVmFsaWRhdG9yKG9iaikge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgbGV0IHJlc3VsdCA9IHRydWU7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHR5cGVvZiBvYmpba2V5c1tpXV0gPT09ICdvYmplY3QnICYmIG9ialtrZXlzW2ldXSAhPT0gbnVsbCkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/isSimpleValidator.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/minimize.js":
/*!****************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/minimize.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { isPOJO } = __webpack_require__(/*! ../utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\n\nmodule.exports = minimize;\n\n/**\n * Minimizes an object, removing undefined values and empty objects\n *\n * @param {Object} object to minimize\n * @return {Object|undefined}\n * @api private\n */\n\nfunction minimize(obj) {\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let hasKeys;\n  let key;\n  let val;\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    if (isPOJO(val)) {\n      obj[key] = minimize(val);\n    }\n\n    if (undefined === obj[key]) {\n      delete obj[key];\n      continue;\n    }\n\n    hasKeys = true;\n  }\n\n  return hasKeys\n    ? obj\n    : undefined;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvbWluaW1pemUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQywrREFBVTs7QUFFckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9taW5pbWl6ZS5qcz8xMjBjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBpc1BPSk8gfSA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbWluaW1pemU7XG5cbi8qKlxuICogTWluaW1pemVzIGFuIG9iamVjdCwgcmVtb3ZpbmcgdW5kZWZpbmVkIHZhbHVlcyBhbmQgZW1wdHkgb2JqZWN0c1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdG8gbWluaW1pemVcbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBtaW5pbWl6ZShvYmopIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGxldCBpID0ga2V5cy5sZW5ndGg7XG4gIGxldCBoYXNLZXlzO1xuICBsZXQga2V5O1xuICBsZXQgdmFsO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIHZhbCA9IG9ialtrZXldO1xuXG4gICAgaWYgKGlzUE9KTyh2YWwpKSB7XG4gICAgICBvYmpba2V5XSA9IG1pbmltaXplKHZhbCk7XG4gICAgfVxuXG4gICAgaWYgKHVuZGVmaW5lZCA9PT0gb2JqW2tleV0pIHtcbiAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGhhc0tleXMgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGhhc0tleXNcbiAgICA/IG9ialxuICAgIDogdW5kZWZpbmVkO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/minimize.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/model/applyDefaultsToPOJO.js":
/*!*********************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/model/applyDefaultsToPOJO.js ***!
  \*********************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function applyDefaultsToPOJO(doc, schema) {\n  const paths = Object.keys(schema.paths);\n  const plen = paths.length;\n\n  for (let i = 0; i < plen; ++i) {\n    let curPath = '';\n    const p = paths[i];\n\n    const type = schema.paths[p];\n    const path = type.splitPath();\n    const len = path.length;\n    let doc_ = doc;\n    for (let j = 0; j < len; ++j) {\n      if (doc_ == null) {\n        break;\n      }\n\n      const piece = path[j];\n      curPath += (!curPath.length ? '' : '.') + piece;\n\n      if (j === len - 1) {\n        if (typeof doc_[piece] !== 'undefined') {\n          if (type.$isSingleNested) {\n            applyDefaultsToPOJO(doc_[piece], type.caster.schema);\n          } else if (type.$isMongooseDocumentArray && Array.isArray(doc_[piece])) {\n            doc_[piece].forEach(el => applyDefaultsToPOJO(el, type.schema));\n          }\n\n          break;\n        }\n\n        const def = type.getDefault(doc, false, { skipCast: true });\n        if (typeof def !== 'undefined') {\n          doc_[piece] = def;\n\n          if (type.$isSingleNested) {\n            applyDefaultsToPOJO(def, type.caster.schema);\n          } else if (type.$isMongooseDocumentArray && Array.isArray(def)) {\n            def.forEach(el => applyDefaultsToPOJO(el, type.schema));\n          }\n        }\n      } else {\n        if (doc_[piece] == null) {\n          doc_[piece] = {};\n        }\n        doc_ = doc_[piece];\n      }\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvbW9kZWwvYXBwbHlEZWZhdWx0c1RvUE9KTy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFVBQVU7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrREFBa0QsZ0JBQWdCO0FBQ2xFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL21vZGVsL2FwcGx5RGVmYXVsdHNUb1BPSk8uanM/ZjAzZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXBwbHlEZWZhdWx0c1RvUE9KTyhkb2MsIHNjaGVtYSkge1xuICBjb25zdCBwYXRocyA9IE9iamVjdC5rZXlzKHNjaGVtYS5wYXRocyk7XG4gIGNvbnN0IHBsZW4gPSBwYXRocy5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbGVuOyArK2kpIHtcbiAgICBsZXQgY3VyUGF0aCA9ICcnO1xuICAgIGNvbnN0IHAgPSBwYXRoc1tpXTtcblxuICAgIGNvbnN0IHR5cGUgPSBzY2hlbWEucGF0aHNbcF07XG4gICAgY29uc3QgcGF0aCA9IHR5cGUuc3BsaXRQYXRoKCk7XG4gICAgY29uc3QgbGVuID0gcGF0aC5sZW5ndGg7XG4gICAgbGV0IGRvY18gPSBkb2M7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBsZW47ICsraikge1xuICAgICAgaWYgKGRvY18gPT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGllY2UgPSBwYXRoW2pdO1xuICAgICAgY3VyUGF0aCArPSAoIWN1clBhdGgubGVuZ3RoID8gJycgOiAnLicpICsgcGllY2U7XG5cbiAgICAgIGlmIChqID09PSBsZW4gLSAxKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZG9jX1twaWVjZV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgaWYgKHR5cGUuJGlzU2luZ2xlTmVzdGVkKSB7XG4gICAgICAgICAgICBhcHBseURlZmF1bHRzVG9QT0pPKGRvY19bcGllY2VdLCB0eXBlLmNhc3Rlci5zY2hlbWEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkgJiYgQXJyYXkuaXNBcnJheShkb2NfW3BpZWNlXSkpIHtcbiAgICAgICAgICAgIGRvY19bcGllY2VdLmZvckVhY2goZWwgPT4gYXBwbHlEZWZhdWx0c1RvUE9KTyhlbCwgdHlwZS5zY2hlbWEpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRlZiA9IHR5cGUuZ2V0RGVmYXVsdChkb2MsIGZhbHNlLCB7IHNraXBDYXN0OiB0cnVlIH0pO1xuICAgICAgICBpZiAodHlwZW9mIGRlZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBkb2NfW3BpZWNlXSA9IGRlZjtcblxuICAgICAgICAgIGlmICh0eXBlLiRpc1NpbmdsZU5lc3RlZCkge1xuICAgICAgICAgICAgYXBwbHlEZWZhdWx0c1RvUE9KTyhkZWYsIHR5cGUuY2FzdGVyLnNjaGVtYSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSAmJiBBcnJheS5pc0FycmF5KGRlZikpIHtcbiAgICAgICAgICAgIGRlZi5mb3JFYWNoKGVsID0+IGFwcGx5RGVmYXVsdHNUb1BPSk8oZWwsIHR5cGUuc2NoZW1hKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZG9jX1twaWVjZV0gPT0gbnVsbCkge1xuICAgICAgICAgIGRvY19bcGllY2VdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZG9jXyA9IGRvY19bcGllY2VdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/model/applyDefaultsToPOJO.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/model/applyHooks.js":
/*!************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/model/applyHooks.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst symbols = __webpack_require__(/*! ../../schema/symbols */ \"../backend/node_modules/mongoose/lib/schema/symbols.js\");\nconst promiseOrCallback = __webpack_require__(/*! ../promiseOrCallback */ \"../backend/node_modules/mongoose/lib/helpers/promiseOrCallback.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = applyHooks;\n\n/*!\n * ignore\n */\n\napplyHooks.middlewareFunctions = [\n  'deleteOne',\n  'save',\n  'validate',\n  'remove',\n  'updateOne',\n  'init'\n];\n\n/*!\n * ignore\n */\n\nconst alreadyHookedFunctions = new Set(applyHooks.middlewareFunctions.flatMap(fn => ([fn, `$__${fn}`])));\n\n/**\n * Register hooks for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n * @param {Object} options\n * @api private\n */\n\nfunction applyHooks(model, schema, options) {\n  options = options || {};\n\n  const kareemOptions = {\n    useErrorHandlers: true,\n    numCallbackParams: 1,\n    nullResultByDefault: true,\n    contextParameter: true\n  };\n  const objToDecorate = options.decorateDoc ? model : model.prototype;\n\n  model.$appliedHooks = true;\n  for (const key of Object.keys(schema.paths)) {\n    const type = schema.paths[key];\n    let childModel = null;\n    if (type.$isSingleNested) {\n      childModel = type.caster;\n    } else if (type.$isMongooseDocumentArray) {\n      childModel = type.Constructor;\n    } else {\n      continue;\n    }\n\n    if (childModel.$appliedHooks) {\n      continue;\n    }\n\n    applyHooks(childModel, type.schema, { ...options, isChildSchema: true });\n    if (childModel.discriminators != null) {\n      const keys = Object.keys(childModel.discriminators);\n      for (const key of keys) {\n        applyHooks(childModel.discriminators[key],\n          childModel.discriminators[key].schema, options);\n      }\n    }\n  }\n\n  // Built-in hooks rely on hooking internal functions in order to support\n  // promises and make it so that `doc.save.toString()` provides meaningful\n  // information.\n\n  const middleware = schema.s.hooks.\n    filter(hook => {\n      if (hook.name === 'updateOne' || hook.name === 'deleteOne') {\n        return !!hook['document'];\n      }\n      if (hook.name === 'remove' || hook.name === 'init') {\n        return hook['document'] == null || !!hook['document'];\n      }\n      if (hook.query != null || hook.document != null) {\n        return hook.document !== false;\n      }\n      return true;\n    }).\n    filter(hook => {\n      // If user has overwritten the method, don't apply built-in middleware\n      if (schema.methods[hook.name]) {\n        return !hook.fn[symbols.builtInMiddleware];\n      }\n\n      return true;\n    });\n\n  model._middleware = middleware;\n\n  objToDecorate.$__originalValidate = objToDecorate.$__originalValidate || objToDecorate.$__validate;\n\n  const internalMethodsToWrap = options && options.isChildSchema ? ['save', 'validate', 'deleteOne'] : ['save', 'validate'];\n  for (const method of internalMethodsToWrap) {\n    const toWrap = method === 'validate' ? '$__originalValidate' : `$__${method}`;\n    const wrapped = middleware.\n      createWrapper(method, objToDecorate[toWrap], null, kareemOptions);\n    objToDecorate[`$__${method}`] = wrapped;\n  }\n  objToDecorate.$__init = middleware.\n    createWrapperSync('init', objToDecorate.$__init, null, kareemOptions);\n\n  // Support hooks for custom methods\n  const customMethods = Object.keys(schema.methods);\n  const customMethodOptions = Object.assign({}, kareemOptions, {\n    // Only use `checkForPromise` for custom methods, because mongoose\n    // query thunks are not as consistent as I would like about returning\n    // a nullish value rather than the query. If a query thunk returns\n    // a query, `checkForPromise` causes infinite recursion\n    checkForPromise: true\n  });\n  for (const method of customMethods) {\n    if (alreadyHookedFunctions.has(method)) {\n      continue;\n    }\n    if (!middleware.hasHooks(method)) {\n      // Don't wrap if there are no hooks for the custom method to avoid\n      // surprises. Also, `createWrapper()` enforces consistent async,\n      // so wrapping a sync method would break it.\n      continue;\n    }\n    const originalMethod = objToDecorate[method];\n    objToDecorate[method] = function() {\n      const args = Array.prototype.slice.call(arguments);\n      const cb = args.slice(-1).pop();\n      const argsWithoutCallback = typeof cb === 'function' ?\n        args.slice(0, args.length - 1) : args;\n      return promiseOrCallback(cb, callback => {\n        return this[`$__${method}`].apply(this,\n          argsWithoutCallback.concat([callback]));\n      }, model.events);\n    };\n    objToDecorate[`$__${method}`] = middleware.\n      createWrapper(method, originalMethod, null, customMethodOptions);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvbW9kZWwvYXBwbHlIb29rcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixnQkFBZ0IsbUJBQU8sQ0FBQyxvRkFBc0I7QUFDOUMsMEJBQTBCLG1CQUFPLENBQUMsK0ZBQXNCOztBQUV4RDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdHQUFnRyxHQUFHOztBQUVuRztBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxpQ0FBaUM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx5RUFBeUUsT0FBTztBQUNoRjtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakM7QUFDQSxPQUFPO0FBQ1A7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9tb2RlbC9hcHBseUhvb2tzLmpzP2Y0NmQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBzeW1ib2xzID0gcmVxdWlyZSgnLi4vLi4vc2NoZW1hL3N5bWJvbHMnKTtcbmNvbnN0IHByb21pc2VPckNhbGxiYWNrID0gcmVxdWlyZSgnLi4vcHJvbWlzZU9yQ2FsbGJhY2snKTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFwcGx5SG9va3M7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuYXBwbHlIb29rcy5taWRkbGV3YXJlRnVuY3Rpb25zID0gW1xuICAnZGVsZXRlT25lJyxcbiAgJ3NhdmUnLFxuICAndmFsaWRhdGUnLFxuICAncmVtb3ZlJyxcbiAgJ3VwZGF0ZU9uZScsXG4gICdpbml0J1xuXTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5jb25zdCBhbHJlYWR5SG9va2VkRnVuY3Rpb25zID0gbmV3IFNldChhcHBseUhvb2tzLm1pZGRsZXdhcmVGdW5jdGlvbnMuZmxhdE1hcChmbiA9PiAoW2ZuLCBgJF9fJHtmbn1gXSkpKTtcblxuLyoqXG4gKiBSZWdpc3RlciBob29rcyBmb3IgdGhpcyBtb2RlbFxuICpcbiAqIEBwYXJhbSB7TW9kZWx9IG1vZGVsXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gYXBwbHlIb29rcyhtb2RlbCwgc2NoZW1hLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGNvbnN0IGthcmVlbU9wdGlvbnMgPSB7XG4gICAgdXNlRXJyb3JIYW5kbGVyczogdHJ1ZSxcbiAgICBudW1DYWxsYmFja1BhcmFtczogMSxcbiAgICBudWxsUmVzdWx0QnlEZWZhdWx0OiB0cnVlLFxuICAgIGNvbnRleHRQYXJhbWV0ZXI6IHRydWVcbiAgfTtcbiAgY29uc3Qgb2JqVG9EZWNvcmF0ZSA9IG9wdGlvbnMuZGVjb3JhdGVEb2MgPyBtb2RlbCA6IG1vZGVsLnByb3RvdHlwZTtcblxuICBtb2RlbC4kYXBwbGllZEhvb2tzID0gdHJ1ZTtcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NoZW1hLnBhdGhzKSkge1xuICAgIGNvbnN0IHR5cGUgPSBzY2hlbWEucGF0aHNba2V5XTtcbiAgICBsZXQgY2hpbGRNb2RlbCA9IG51bGw7XG4gICAgaWYgKHR5cGUuJGlzU2luZ2xlTmVzdGVkKSB7XG4gICAgICBjaGlsZE1vZGVsID0gdHlwZS5jYXN0ZXI7XG4gICAgfSBlbHNlIGlmICh0eXBlLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSkge1xuICAgICAgY2hpbGRNb2RlbCA9IHR5cGUuQ29uc3RydWN0b3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChjaGlsZE1vZGVsLiRhcHBsaWVkSG9va3MpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGFwcGx5SG9va3MoY2hpbGRNb2RlbCwgdHlwZS5zY2hlbWEsIHsgLi4ub3B0aW9ucywgaXNDaGlsZFNjaGVtYTogdHJ1ZSB9KTtcbiAgICBpZiAoY2hpbGRNb2RlbC5kaXNjcmltaW5hdG9ycyAhPSBudWxsKSB7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoY2hpbGRNb2RlbC5kaXNjcmltaW5hdG9ycyk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGFwcGx5SG9va3MoY2hpbGRNb2RlbC5kaXNjcmltaW5hdG9yc1trZXldLFxuICAgICAgICAgIGNoaWxkTW9kZWwuZGlzY3JpbWluYXRvcnNba2V5XS5zY2hlbWEsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEJ1aWx0LWluIGhvb2tzIHJlbHkgb24gaG9va2luZyBpbnRlcm5hbCBmdW5jdGlvbnMgaW4gb3JkZXIgdG8gc3VwcG9ydFxuICAvLyBwcm9taXNlcyBhbmQgbWFrZSBpdCBzbyB0aGF0IGBkb2Muc2F2ZS50b1N0cmluZygpYCBwcm92aWRlcyBtZWFuaW5nZnVsXG4gIC8vIGluZm9ybWF0aW9uLlxuXG4gIGNvbnN0IG1pZGRsZXdhcmUgPSBzY2hlbWEucy5ob29rcy5cbiAgICBmaWx0ZXIoaG9vayA9PiB7XG4gICAgICBpZiAoaG9vay5uYW1lID09PSAndXBkYXRlT25lJyB8fCBob29rLm5hbWUgPT09ICdkZWxldGVPbmUnKSB7XG4gICAgICAgIHJldHVybiAhIWhvb2tbJ2RvY3VtZW50J107XG4gICAgICB9XG4gICAgICBpZiAoaG9vay5uYW1lID09PSAncmVtb3ZlJyB8fCBob29rLm5hbWUgPT09ICdpbml0Jykge1xuICAgICAgICByZXR1cm4gaG9va1snZG9jdW1lbnQnXSA9PSBudWxsIHx8ICEhaG9va1snZG9jdW1lbnQnXTtcbiAgICAgIH1cbiAgICAgIGlmIChob29rLnF1ZXJ5ICE9IG51bGwgfHwgaG9vay5kb2N1bWVudCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBob29rLmRvY3VtZW50ICE9PSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pLlxuICAgIGZpbHRlcihob29rID0+IHtcbiAgICAgIC8vIElmIHVzZXIgaGFzIG92ZXJ3cml0dGVuIHRoZSBtZXRob2QsIGRvbid0IGFwcGx5IGJ1aWx0LWluIG1pZGRsZXdhcmVcbiAgICAgIGlmIChzY2hlbWEubWV0aG9kc1tob29rLm5hbWVdKSB7XG4gICAgICAgIHJldHVybiAhaG9vay5mbltzeW1ib2xzLmJ1aWx0SW5NaWRkbGV3YXJlXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG5cbiAgbW9kZWwuX21pZGRsZXdhcmUgPSBtaWRkbGV3YXJlO1xuXG4gIG9ialRvRGVjb3JhdGUuJF9fb3JpZ2luYWxWYWxpZGF0ZSA9IG9ialRvRGVjb3JhdGUuJF9fb3JpZ2luYWxWYWxpZGF0ZSB8fCBvYmpUb0RlY29yYXRlLiRfX3ZhbGlkYXRlO1xuXG4gIGNvbnN0IGludGVybmFsTWV0aG9kc1RvV3JhcCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5pc0NoaWxkU2NoZW1hID8gWydzYXZlJywgJ3ZhbGlkYXRlJywgJ2RlbGV0ZU9uZSddIDogWydzYXZlJywgJ3ZhbGlkYXRlJ107XG4gIGZvciAoY29uc3QgbWV0aG9kIG9mIGludGVybmFsTWV0aG9kc1RvV3JhcCkge1xuICAgIGNvbnN0IHRvV3JhcCA9IG1ldGhvZCA9PT0gJ3ZhbGlkYXRlJyA/ICckX19vcmlnaW5hbFZhbGlkYXRlJyA6IGAkX18ke21ldGhvZH1gO1xuICAgIGNvbnN0IHdyYXBwZWQgPSBtaWRkbGV3YXJlLlxuICAgICAgY3JlYXRlV3JhcHBlcihtZXRob2QsIG9ialRvRGVjb3JhdGVbdG9XcmFwXSwgbnVsbCwga2FyZWVtT3B0aW9ucyk7XG4gICAgb2JqVG9EZWNvcmF0ZVtgJF9fJHttZXRob2R9YF0gPSB3cmFwcGVkO1xuICB9XG4gIG9ialRvRGVjb3JhdGUuJF9faW5pdCA9IG1pZGRsZXdhcmUuXG4gICAgY3JlYXRlV3JhcHBlclN5bmMoJ2luaXQnLCBvYmpUb0RlY29yYXRlLiRfX2luaXQsIG51bGwsIGthcmVlbU9wdGlvbnMpO1xuXG4gIC8vIFN1cHBvcnQgaG9va3MgZm9yIGN1c3RvbSBtZXRob2RzXG4gIGNvbnN0IGN1c3RvbU1ldGhvZHMgPSBPYmplY3Qua2V5cyhzY2hlbWEubWV0aG9kcyk7XG4gIGNvbnN0IGN1c3RvbU1ldGhvZE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBrYXJlZW1PcHRpb25zLCB7XG4gICAgLy8gT25seSB1c2UgYGNoZWNrRm9yUHJvbWlzZWAgZm9yIGN1c3RvbSBtZXRob2RzLCBiZWNhdXNlIG1vbmdvb3NlXG4gICAgLy8gcXVlcnkgdGh1bmtzIGFyZSBub3QgYXMgY29uc2lzdGVudCBhcyBJIHdvdWxkIGxpa2UgYWJvdXQgcmV0dXJuaW5nXG4gICAgLy8gYSBudWxsaXNoIHZhbHVlIHJhdGhlciB0aGFuIHRoZSBxdWVyeS4gSWYgYSBxdWVyeSB0aHVuayByZXR1cm5zXG4gICAgLy8gYSBxdWVyeSwgYGNoZWNrRm9yUHJvbWlzZWAgY2F1c2VzIGluZmluaXRlIHJlY3Vyc2lvblxuICAgIGNoZWNrRm9yUHJvbWlzZTogdHJ1ZVxuICB9KTtcbiAgZm9yIChjb25zdCBtZXRob2Qgb2YgY3VzdG9tTWV0aG9kcykge1xuICAgIGlmIChhbHJlYWR5SG9va2VkRnVuY3Rpb25zLmhhcyhtZXRob2QpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCFtaWRkbGV3YXJlLmhhc0hvb2tzKG1ldGhvZCkpIHtcbiAgICAgIC8vIERvbid0IHdyYXAgaWYgdGhlcmUgYXJlIG5vIGhvb2tzIGZvciB0aGUgY3VzdG9tIG1ldGhvZCB0byBhdm9pZFxuICAgICAgLy8gc3VycHJpc2VzLiBBbHNvLCBgY3JlYXRlV3JhcHBlcigpYCBlbmZvcmNlcyBjb25zaXN0ZW50IGFzeW5jLFxuICAgICAgLy8gc28gd3JhcHBpbmcgYSBzeW5jIG1ldGhvZCB3b3VsZCBicmVhayBpdC5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBvcmlnaW5hbE1ldGhvZCA9IG9ialRvRGVjb3JhdGVbbWV0aG9kXTtcbiAgICBvYmpUb0RlY29yYXRlW21ldGhvZF0gPSBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgY29uc3QgY2IgPSBhcmdzLnNsaWNlKC0xKS5wb3AoKTtcbiAgICAgIGNvbnN0IGFyZ3NXaXRob3V0Q2FsbGJhY2sgPSB0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICBhcmdzLnNsaWNlKDAsIGFyZ3MubGVuZ3RoIC0gMSkgOiBhcmdzO1xuICAgICAgcmV0dXJuIHByb21pc2VPckNhbGxiYWNrKGNiLCBjYWxsYmFjayA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzW2AkX18ke21ldGhvZH1gXS5hcHBseSh0aGlzLFxuICAgICAgICAgIGFyZ3NXaXRob3V0Q2FsbGJhY2suY29uY2F0KFtjYWxsYmFja10pKTtcbiAgICAgIH0sIG1vZGVsLmV2ZW50cyk7XG4gICAgfTtcbiAgICBvYmpUb0RlY29yYXRlW2AkX18ke21ldGhvZH1gXSA9IG1pZGRsZXdhcmUuXG4gICAgICBjcmVhdGVXcmFwcGVyKG1ldGhvZCwgb3JpZ2luYWxNZXRob2QsIG51bGwsIGN1c3RvbU1ldGhvZE9wdGlvbnMpO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/model/applyHooks.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/model/applyMethods.js":
/*!**************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/model/applyMethods.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst get = __webpack_require__(/*! ../get */ \"../backend/node_modules/mongoose/lib/helpers/get.js\");\nconst utils = __webpack_require__(/*! ../../utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\n\n/**\n * Register methods for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n * @api private\n */\n\nmodule.exports = function applyMethods(model, schema) {\n  const Model = __webpack_require__(/*! ../../model */ \"../backend/node_modules/mongoose/lib/model.js\");\n\n  function apply(method, schema) {\n    Object.defineProperty(model.prototype, method, {\n      get: function() {\n        const h = {};\n        for (const k in schema.methods[method]) {\n          h[k] = schema.methods[method][k].bind(this);\n        }\n        return h;\n      },\n      configurable: true\n    });\n  }\n  for (const method of Object.keys(schema.methods)) {\n    const fn = schema.methods[method];\n    if (schema.tree.hasOwnProperty(method)) {\n      throw new Error('You have a method and a property in your schema both ' +\n        'named \"' + method + '\"');\n    }\n\n    // Avoid making custom methods if user sets a method to itself, e.g.\n    // `schema.method(save, Document.prototype.save)`. Can happen when\n    // calling `loadClass()` with a class that `extends Document`. See gh-12254\n    if (typeof fn === 'function' &&\n        Model.prototype[method] === fn) {\n      delete schema.methods[method];\n      continue;\n    }\n\n    if (schema.reserved[method] &&\n        !get(schema, `methodOptions.${method}.suppressWarning`, false)) {\n      utils.warn(`mongoose: the method name \"${method}\" is used by mongoose ` +\n        'internally, overwriting it may cause bugs. If you\\'re sure you know ' +\n        'what you\\'re doing, you can suppress this error by using ' +\n        `\\`schema.method('${method}', fn, { suppressWarning: true })\\`.`);\n    }\n    if (typeof fn === 'function') {\n      model.prototype[method] = fn;\n    } else {\n      apply(method, schema);\n    }\n  }\n\n  // Recursively call `applyMethods()` on child schemas\n  model.$appliedMethods = true;\n  for (const key of Object.keys(schema.paths)) {\n    const type = schema.paths[key];\n    if (type.$isSingleNested && !type.caster.$appliedMethods) {\n      applyMethods(type.caster, type.schema);\n    }\n    if (type.$isMongooseDocumentArray && !type.Constructor.$appliedMethods) {\n      applyMethods(type.Constructor, type.schema);\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvbW9kZWwvYXBwbHlNZXRob2RzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxtRUFBUTtBQUM1QixjQUFjLG1CQUFPLENBQUMsa0VBQWE7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLGtFQUFhOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QywrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0EsNEJBQTRCLE9BQU8sU0FBUyx1QkFBdUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9tb2RlbC9hcHBseU1ldGhvZHMuanM/YzMwMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGdldCA9IHJlcXVpcmUoJy4uL2dldCcpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuXG4vKipcbiAqIFJlZ2lzdGVyIG1ldGhvZHMgZm9yIHRoaXMgbW9kZWxcbiAqXG4gKiBAcGFyYW0ge01vZGVsfSBtb2RlbFxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhcHBseU1ldGhvZHMobW9kZWwsIHNjaGVtYSkge1xuICBjb25zdCBNb2RlbCA9IHJlcXVpcmUoJy4uLy4uL21vZGVsJyk7XG5cbiAgZnVuY3Rpb24gYXBwbHkobWV0aG9kLCBzY2hlbWEpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kZWwucHJvdG90eXBlLCBtZXRob2QsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IGggPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrIGluIHNjaGVtYS5tZXRob2RzW21ldGhvZF0pIHtcbiAgICAgICAgICBoW2tdID0gc2NoZW1hLm1ldGhvZHNbbWV0aG9kXVtrXS5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoO1xuICAgICAgfSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGZvciAoY29uc3QgbWV0aG9kIG9mIE9iamVjdC5rZXlzKHNjaGVtYS5tZXRob2RzKSkge1xuICAgIGNvbnN0IGZuID0gc2NoZW1hLm1ldGhvZHNbbWV0aG9kXTtcbiAgICBpZiAoc2NoZW1hLnRyZWUuaGFzT3duUHJvcGVydHkobWV0aG9kKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgaGF2ZSBhIG1ldGhvZCBhbmQgYSBwcm9wZXJ0eSBpbiB5b3VyIHNjaGVtYSBib3RoICcgK1xuICAgICAgICAnbmFtZWQgXCInICsgbWV0aG9kICsgJ1wiJyk7XG4gICAgfVxuXG4gICAgLy8gQXZvaWQgbWFraW5nIGN1c3RvbSBtZXRob2RzIGlmIHVzZXIgc2V0cyBhIG1ldGhvZCB0byBpdHNlbGYsIGUuZy5cbiAgICAvLyBgc2NoZW1hLm1ldGhvZChzYXZlLCBEb2N1bWVudC5wcm90b3R5cGUuc2F2ZSlgLiBDYW4gaGFwcGVuIHdoZW5cbiAgICAvLyBjYWxsaW5nIGBsb2FkQ2xhc3MoKWAgd2l0aCBhIGNsYXNzIHRoYXQgYGV4dGVuZHMgRG9jdW1lbnRgLiBTZWUgZ2gtMTIyNTRcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIE1vZGVsLnByb3RvdHlwZVttZXRob2RdID09PSBmbikge1xuICAgICAgZGVsZXRlIHNjaGVtYS5tZXRob2RzW21ldGhvZF07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoc2NoZW1hLnJlc2VydmVkW21ldGhvZF0gJiZcbiAgICAgICAgIWdldChzY2hlbWEsIGBtZXRob2RPcHRpb25zLiR7bWV0aG9kfS5zdXBwcmVzc1dhcm5pbmdgLCBmYWxzZSkpIHtcbiAgICAgIHV0aWxzLndhcm4oYG1vbmdvb3NlOiB0aGUgbWV0aG9kIG5hbWUgXCIke21ldGhvZH1cIiBpcyB1c2VkIGJ5IG1vbmdvb3NlIGAgK1xuICAgICAgICAnaW50ZXJuYWxseSwgb3ZlcndyaXRpbmcgaXQgbWF5IGNhdXNlIGJ1Z3MuIElmIHlvdVxcJ3JlIHN1cmUgeW91IGtub3cgJyArXG4gICAgICAgICd3aGF0IHlvdVxcJ3JlIGRvaW5nLCB5b3UgY2FuIHN1cHByZXNzIHRoaXMgZXJyb3IgYnkgdXNpbmcgJyArXG4gICAgICAgIGBcXGBzY2hlbWEubWV0aG9kKCcke21ldGhvZH0nLCBmbiwgeyBzdXBwcmVzc1dhcm5pbmc6IHRydWUgfSlcXGAuYCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG1vZGVsLnByb3RvdHlwZVttZXRob2RdID0gZm47XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwcGx5KG1ldGhvZCwgc2NoZW1hKTtcbiAgICB9XG4gIH1cblxuICAvLyBSZWN1cnNpdmVseSBjYWxsIGBhcHBseU1ldGhvZHMoKWAgb24gY2hpbGQgc2NoZW1hc1xuICBtb2RlbC4kYXBwbGllZE1ldGhvZHMgPSB0cnVlO1xuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzY2hlbWEucGF0aHMpKSB7XG4gICAgY29uc3QgdHlwZSA9IHNjaGVtYS5wYXRoc1trZXldO1xuICAgIGlmICh0eXBlLiRpc1NpbmdsZU5lc3RlZCAmJiAhdHlwZS5jYXN0ZXIuJGFwcGxpZWRNZXRob2RzKSB7XG4gICAgICBhcHBseU1ldGhvZHModHlwZS5jYXN0ZXIsIHR5cGUuc2NoZW1hKTtcbiAgICB9XG4gICAgaWYgKHR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5ICYmICF0eXBlLkNvbnN0cnVjdG9yLiRhcHBsaWVkTWV0aG9kcykge1xuICAgICAgYXBwbHlNZXRob2RzKHR5cGUuQ29uc3RydWN0b3IsIHR5cGUuc2NoZW1hKTtcbiAgICB9XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/model/applyMethods.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/model/applyStaticHooks.js":
/*!******************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/model/applyStaticHooks.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst middlewareFunctions = (__webpack_require__(/*! ../../constants */ \"../backend/node_modules/mongoose/lib/constants.js\").queryMiddlewareFunctions);\nconst promiseOrCallback = __webpack_require__(/*! ../promiseOrCallback */ \"../backend/node_modules/mongoose/lib/helpers/promiseOrCallback.js\");\n\nmodule.exports = function applyStaticHooks(model, hooks, statics) {\n  const kareemOptions = {\n    useErrorHandlers: true,\n    numCallbackParams: 1\n  };\n\n  hooks = hooks.filter(hook => {\n    // If the custom static overwrites an existing query middleware, don't apply\n    // middleware to it by default. This avoids a potential backwards breaking\n    // change with plugins like `mongoose-delete` that use statics to overwrite\n    // built-in Mongoose functions.\n    if (middlewareFunctions.indexOf(hook.name) !== -1) {\n      return !!hook.model;\n    }\n    return hook.model !== false;\n  });\n\n  model.$__insertMany = hooks.createWrapper('insertMany',\n    model.$__insertMany, model, kareemOptions);\n\n  for (const key of Object.keys(statics)) {\n    if (hooks.hasHooks(key)) {\n      const original = model[key];\n\n      model[key] = function() {\n        const numArgs = arguments.length;\n        const lastArg = numArgs > 0 ? arguments[numArgs - 1] : null;\n        const cb = typeof lastArg === 'function' ? lastArg : null;\n        const args = Array.prototype.slice.\n          call(arguments, 0, cb == null ? numArgs : numArgs - 1);\n        // Special case: can't use `Kareem#wrap()` because it doesn't currently\n        // support wrapped functions that return a promise.\n        return promiseOrCallback(cb, callback => {\n          hooks.execPre(key, model, args, function(err) {\n            if (err != null) {\n              return callback(err);\n            }\n\n            let postCalled = 0;\n            const ret = original.apply(model, args.concat(post));\n            if (ret != null && typeof ret.then === 'function') {\n              ret.then(res => post(null, res), err => post(err));\n            }\n\n            function post(error, res) {\n              if (postCalled++ > 0) {\n                return;\n              }\n\n              if (error != null) {\n                return callback(error);\n              }\n\n              hooks.execPost(key, model, [res], function(error) {\n                if (error != null) {\n                  return callback(error);\n                }\n                callback(null, res);\n              });\n            }\n          });\n        }, model.events);\n      };\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvbW9kZWwvYXBwbHlTdGF0aWNIb29rcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw0QkFBNEIsMEhBQW1EO0FBQy9FLDBCQUEwQixtQkFBTyxDQUFDLCtGQUFzQjs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvbW9kZWwvYXBwbHlTdGF0aWNIb29rcy5qcz8wYTJhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgbWlkZGxld2FyZUZ1bmN0aW9ucyA9IHJlcXVpcmUoJy4uLy4uL2NvbnN0YW50cycpLnF1ZXJ5TWlkZGxld2FyZUZ1bmN0aW9ucztcbmNvbnN0IHByb21pc2VPckNhbGxiYWNrID0gcmVxdWlyZSgnLi4vcHJvbWlzZU9yQ2FsbGJhY2snKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhcHBseVN0YXRpY0hvb2tzKG1vZGVsLCBob29rcywgc3RhdGljcykge1xuICBjb25zdCBrYXJlZW1PcHRpb25zID0ge1xuICAgIHVzZUVycm9ySGFuZGxlcnM6IHRydWUsXG4gICAgbnVtQ2FsbGJhY2tQYXJhbXM6IDFcbiAgfTtcblxuICBob29rcyA9IGhvb2tzLmZpbHRlcihob29rID0+IHtcbiAgICAvLyBJZiB0aGUgY3VzdG9tIHN0YXRpYyBvdmVyd3JpdGVzIGFuIGV4aXN0aW5nIHF1ZXJ5IG1pZGRsZXdhcmUsIGRvbid0IGFwcGx5XG4gICAgLy8gbWlkZGxld2FyZSB0byBpdCBieSBkZWZhdWx0LiBUaGlzIGF2b2lkcyBhIHBvdGVudGlhbCBiYWNrd2FyZHMgYnJlYWtpbmdcbiAgICAvLyBjaGFuZ2Ugd2l0aCBwbHVnaW5zIGxpa2UgYG1vbmdvb3NlLWRlbGV0ZWAgdGhhdCB1c2Ugc3RhdGljcyB0byBvdmVyd3JpdGVcbiAgICAvLyBidWlsdC1pbiBNb25nb29zZSBmdW5jdGlvbnMuXG4gICAgaWYgKG1pZGRsZXdhcmVGdW5jdGlvbnMuaW5kZXhPZihob29rLm5hbWUpICE9PSAtMSkge1xuICAgICAgcmV0dXJuICEhaG9vay5tb2RlbDtcbiAgICB9XG4gICAgcmV0dXJuIGhvb2subW9kZWwgIT09IGZhbHNlO1xuICB9KTtcblxuICBtb2RlbC4kX19pbnNlcnRNYW55ID0gaG9va3MuY3JlYXRlV3JhcHBlcignaW5zZXJ0TWFueScsXG4gICAgbW9kZWwuJF9faW5zZXJ0TWFueSwgbW9kZWwsIGthcmVlbU9wdGlvbnMpO1xuXG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHN0YXRpY3MpKSB7XG4gICAgaWYgKGhvb2tzLmhhc0hvb2tzKGtleSkpIHtcbiAgICAgIGNvbnN0IG9yaWdpbmFsID0gbW9kZWxba2V5XTtcblxuICAgICAgbW9kZWxba2V5XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBudW1BcmdzID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbGFzdEFyZyA9IG51bUFyZ3MgPiAwID8gYXJndW1lbnRzW251bUFyZ3MgLSAxXSA6IG51bGw7XG4gICAgICAgIGNvbnN0IGNiID0gdHlwZW9mIGxhc3RBcmcgPT09ICdmdW5jdGlvbicgPyBsYXN0QXJnIDogbnVsbDtcbiAgICAgICAgY29uc3QgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5cbiAgICAgICAgICBjYWxsKGFyZ3VtZW50cywgMCwgY2IgPT0gbnVsbCA/IG51bUFyZ3MgOiBudW1BcmdzIC0gMSk7XG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZTogY2FuJ3QgdXNlIGBLYXJlZW0jd3JhcCgpYCBiZWNhdXNlIGl0IGRvZXNuJ3QgY3VycmVudGx5XG4gICAgICAgIC8vIHN1cHBvcnQgd3JhcHBlZCBmdW5jdGlvbnMgdGhhdCByZXR1cm4gYSBwcm9taXNlLlxuICAgICAgICByZXR1cm4gcHJvbWlzZU9yQ2FsbGJhY2soY2IsIGNhbGxiYWNrID0+IHtcbiAgICAgICAgICBob29rcy5leGVjUHJlKGtleSwgbW9kZWwsIGFyZ3MsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgcG9zdENhbGxlZCA9IDA7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBvcmlnaW5hbC5hcHBseShtb2RlbCwgYXJncy5jb25jYXQocG9zdCkpO1xuICAgICAgICAgICAgaWYgKHJldCAhPSBudWxsICYmIHR5cGVvZiByZXQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICByZXQudGhlbihyZXMgPT4gcG9zdChudWxsLCByZXMpLCBlcnIgPT4gcG9zdChlcnIpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gcG9zdChlcnJvciwgcmVzKSB7XG4gICAgICAgICAgICAgIGlmIChwb3N0Q2FsbGVkKysgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGVycm9yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaG9va3MuZXhlY1Bvc3Qoa2V5LCBtb2RlbCwgW3Jlc10sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlcyk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBtb2RlbC5ldmVudHMpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/model/applyStaticHooks.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/model/applyStatics.js":
/*!**************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/model/applyStatics.js ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Register statics for this model\n * @param {Model} model\n * @param {Schema} schema\n * @api private\n */\nmodule.exports = function applyStatics(model, schema) {\n  for (const i in schema.statics) {\n    model[i] = schema.statics[i];\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvbW9kZWwvYXBwbHlTdGF0aWNzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvbW9kZWwvYXBwbHlTdGF0aWNzLmpzPzNiMzciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFJlZ2lzdGVyIHN0YXRpY3MgZm9yIHRoaXMgbW9kZWxcbiAqIEBwYXJhbSB7TW9kZWx9IG1vZGVsXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhcHBseVN0YXRpY3MobW9kZWwsIHNjaGVtYSkge1xuICBmb3IgKGNvbnN0IGkgaW4gc2NoZW1hLnN0YXRpY3MpIHtcbiAgICBtb2RlbFtpXSA9IHNjaGVtYS5zdGF0aWNzW2ldO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/model/applyStatics.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/model/castBulkWrite.js":
/*!***************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/model/castBulkWrite.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst MongooseError = __webpack_require__(/*! ../../error/mongooseError */ \"../backend/node_modules/mongoose/lib/error/mongooseError.js\");\nconst getDiscriminatorByValue = __webpack_require__(/*! ../../helpers/discriminator/getDiscriminatorByValue */ \"../backend/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\nconst applyTimestampsToChildren = __webpack_require__(/*! ../update/applyTimestampsToChildren */ \"../backend/node_modules/mongoose/lib/helpers/update/applyTimestampsToChildren.js\");\nconst applyTimestampsToUpdate = __webpack_require__(/*! ../update/applyTimestampsToUpdate */ \"../backend/node_modules/mongoose/lib/helpers/update/applyTimestampsToUpdate.js\");\nconst cast = __webpack_require__(/*! ../../cast */ \"../backend/node_modules/mongoose/lib/cast.js\");\nconst castUpdate = __webpack_require__(/*! ../query/castUpdate */ \"../backend/node_modules/mongoose/lib/helpers/query/castUpdate.js\");\nconst clone = __webpack_require__(/*! ../clone */ \"../backend/node_modules/mongoose/lib/helpers/clone.js\");\nconst decorateUpdateWithVersionKey = __webpack_require__(/*! ../update/decorateUpdateWithVersionKey */ \"../backend/node_modules/mongoose/lib/helpers/update/decorateUpdateWithVersionKey.js\");\nconst { inspect } = __webpack_require__(/*! util */ \"util\");\nconst setDefaultsOnInsert = __webpack_require__(/*! ../setDefaultsOnInsert */ \"../backend/node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js\");\n\n/**\n * Given a model and a bulkWrite op, return a thunk that handles casting and\n * validating the individual op.\n * @param {Model} originalModel\n * @param {Object} op\n * @param {Object} [options]\n * @api private\n */\n\nmodule.exports = function castBulkWrite(originalModel, op, options) {\n  const now = originalModel.base.now();\n\n  const globalSetDefaultsOnInsert = originalModel.base.options.setDefaultsOnInsert;\n  if (op['insertOne']) {\n    return (callback) => {\n      const model = decideModelByObject(originalModel, op['insertOne']['document']);\n\n      const doc = new model(op['insertOne']['document']);\n      if (model.schema.options.timestamps && options.timestamps !== false) {\n        doc.initializeTimestamps();\n      }\n      if (options.session != null) {\n        doc.$session(options.session);\n      }\n      const versionKey = model?.schema?.options?.versionKey;\n      if (versionKey && doc[versionKey] == null) {\n        doc[versionKey] = 0;\n      }\n      op['insertOne']['document'] = doc;\n\n      if (options.skipValidation || op['insertOne'].skipValidation) {\n        callback(null);\n        return;\n      }\n\n      op['insertOne']['document'].$validate().then(\n        () => { callback(null); },\n        err => { callback(err, null); }\n      );\n    };\n  } else if (op['updateOne']) {\n    return (callback) => {\n      try {\n        if (!op['updateOne']['filter']) {\n          throw new Error('Must provide a filter object.');\n        }\n        if (!op['updateOne']['update']) {\n          throw new Error('Must provide an update object.');\n        }\n\n        const model = decideModelByObject(originalModel, op['updateOne']['filter']);\n        const schema = model.schema;\n        const strict = options.strict != null ? options.strict : model.schema.options.strict;\n\n        const update = clone(op['updateOne']['update']);\n\n        _addDiscriminatorToObject(schema, op['updateOne']['filter']);\n\n        if (model.schema.$timestamps != null && op['updateOne'].timestamps !== false) {\n          const createdAt = model.schema.$timestamps.createdAt;\n          const updatedAt = model.schema.$timestamps.updatedAt;\n          applyTimestampsToUpdate(now, createdAt, updatedAt, update, {});\n        }\n\n        if (op['updateOne'].timestamps !== false) {\n          applyTimestampsToChildren(now, update, model.schema);\n        }\n\n        const shouldSetDefaultsOnInsert = op['updateOne'].setDefaultsOnInsert == null ?\n          globalSetDefaultsOnInsert :\n          op['updateOne'].setDefaultsOnInsert;\n        if (shouldSetDefaultsOnInsert !== false) {\n          setDefaultsOnInsert(op['updateOne']['filter'], model.schema, update, {\n            setDefaultsOnInsert: true,\n            upsert: op['updateOne'].upsert\n          });\n        }\n\n        decorateUpdateWithVersionKey(\n          update,\n          op['updateOne'],\n          model.schema.options.versionKey\n        );\n\n        op['updateOne']['filter'] = cast(model.schema, op['updateOne']['filter'], {\n          strict: strict,\n          upsert: op['updateOne'].upsert\n        });\n        op['updateOne']['update'] = castUpdate(model.schema, update, {\n          strict: strict,\n          upsert: op['updateOne'].upsert\n        }, model, op['updateOne']['filter']);\n      } catch (error) {\n        return callback(error, null);\n      }\n\n      callback(null);\n    };\n  } else if (op['updateMany']) {\n    return (callback) => {\n      try {\n        if (!op['updateMany']['filter']) {\n          throw new Error('Must provide a filter object.');\n        }\n        if (!op['updateMany']['update']) {\n          throw new Error('Must provide an update object.');\n        }\n\n        const model = decideModelByObject(originalModel, op['updateMany']['filter']);\n        const schema = model.schema;\n        const strict = options.strict != null ? options.strict : model.schema.options.strict;\n\n        const shouldSetDefaultsOnInsert = op['updateMany'].setDefaultsOnInsert == null ?\n          globalSetDefaultsOnInsert :\n          op['updateMany'].setDefaultsOnInsert;\n\n        if (shouldSetDefaultsOnInsert !== false) {\n          setDefaultsOnInsert(op['updateMany']['filter'], model.schema, op['updateMany']['update'], {\n            setDefaultsOnInsert: true,\n            upsert: op['updateMany'].upsert\n          });\n        }\n\n        if (model.schema.$timestamps != null && op['updateMany'].timestamps !== false) {\n          const createdAt = model.schema.$timestamps.createdAt;\n          const updatedAt = model.schema.$timestamps.updatedAt;\n          applyTimestampsToUpdate(now, createdAt, updatedAt, op['updateMany']['update'], {});\n        }\n        if (op['updateMany'].timestamps !== false) {\n          applyTimestampsToChildren(now, op['updateMany']['update'], model.schema);\n        }\n\n        _addDiscriminatorToObject(schema, op['updateMany']['filter']);\n\n        decorateUpdateWithVersionKey(\n          op['updateMany']['update'],\n          op['updateMany'],\n          model.schema.options.versionKey\n        );\n\n        op['updateMany']['filter'] = cast(model.schema, op['updateMany']['filter'], {\n          strict: strict,\n          upsert: op['updateMany'].upsert\n        });\n\n        op['updateMany']['update'] = castUpdate(model.schema, op['updateMany']['update'], {\n          strict: strict,\n          upsert: op['updateMany'].upsert\n        }, model, op['updateMany']['filter']);\n      } catch (error) {\n        return callback(error, null);\n      }\n\n      callback(null);\n    };\n  } else if (op['replaceOne']) {\n    return (callback) => {\n      const model = decideModelByObject(originalModel, op['replaceOne']['filter']);\n      const schema = model.schema;\n      const strict = options.strict != null ? options.strict : model.schema.options.strict;\n\n      _addDiscriminatorToObject(schema, op['replaceOne']['filter']);\n      try {\n        op['replaceOne']['filter'] = cast(model.schema, op['replaceOne']['filter'], {\n          strict: strict,\n          upsert: op['replaceOne'].upsert\n        });\n      } catch (error) {\n        return callback(error, null);\n      }\n\n      // set `skipId`, otherwise we get \"_id field cannot be changed\"\n      const doc = new model(op['replaceOne']['replacement'], strict, true);\n      if (model.schema.options.timestamps) {\n        doc.initializeTimestamps();\n      }\n      if (options.session != null) {\n        doc.$session(options.session);\n      }\n      const versionKey = model?.schema?.options?.versionKey;\n      if (versionKey && doc[versionKey] == null) {\n        doc[versionKey] = 0;\n      }\n      op['replaceOne']['replacement'] = doc;\n\n      if (options.skipValidation || op['replaceOne'].skipValidation) {\n        op['replaceOne']['replacement'] = op['replaceOne']['replacement'].toBSON();\n        callback(null);\n        return;\n      }\n\n      op['replaceOne']['replacement'].$validate().then(\n        () => {\n          op['replaceOne']['replacement'] = op['replaceOne']['replacement'].toBSON();\n          callback(null);\n        },\n        error => {\n          callback(error, null);\n        }\n      );\n    };\n  } else if (op['deleteOne']) {\n    return (callback) => {\n      const model = decideModelByObject(originalModel, op['deleteOne']['filter']);\n      const schema = model.schema;\n\n      _addDiscriminatorToObject(schema, op['deleteOne']['filter']);\n\n      try {\n        op['deleteOne']['filter'] = cast(model.schema,\n          op['deleteOne']['filter']);\n      } catch (error) {\n        return callback(error, null);\n      }\n\n      callback(null);\n    };\n  } else if (op['deleteMany']) {\n    return (callback) => {\n      const model = decideModelByObject(originalModel, op['deleteMany']['filter']);\n      const schema = model.schema;\n\n      _addDiscriminatorToObject(schema, op['deleteMany']['filter']);\n\n      try {\n        op['deleteMany']['filter'] = cast(model.schema,\n          op['deleteMany']['filter']);\n      } catch (error) {\n        return callback(error, null);\n      }\n\n      callback(null);\n    };\n  } else {\n    return (callback) => {\n      const error = new MongooseError(`Invalid op passed to \\`bulkWrite()\\`: ${inspect(op)}`);\n      callback(error, null);\n    };\n  }\n};\n\nfunction _addDiscriminatorToObject(schema, obj) {\n  if (schema == null) {\n    return;\n  }\n  if (schema.discriminatorMapping && !schema.discriminatorMapping.isRoot) {\n    obj[schema.discriminatorMapping.key] = schema.discriminatorMapping.value;\n  }\n}\n\n/**\n * gets discriminator model if discriminator key is present in object\n * @api private\n */\n\nfunction decideModelByObject(model, object) {\n  const discriminatorKey = model.schema.options.discriminatorKey;\n  if (object != null && object.hasOwnProperty(discriminatorKey)) {\n    model = getDiscriminatorByValue(model.discriminators, object[discriminatorKey]) || model;\n  }\n  return model;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvbW9kZWwvY2FzdEJ1bGtXcml0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQyw4RkFBMkI7QUFDekQsZ0NBQWdDLG1CQUFPLENBQUMsa0pBQXFEO0FBQzdGLGtDQUFrQyxtQkFBTyxDQUFDLDZIQUFxQztBQUMvRSxnQ0FBZ0MsbUJBQU8sQ0FBQyx5SEFBbUM7QUFDM0UsYUFBYSxtQkFBTyxDQUFDLGdFQUFZO0FBQ2pDLG1CQUFtQixtQkFBTyxDQUFDLDZGQUFxQjtBQUNoRCxjQUFjLG1CQUFPLENBQUMsdUVBQVU7QUFDaEMscUNBQXFDLG1CQUFPLENBQUMsbUlBQXdDO0FBQ3JGLFFBQVEsVUFBVSxFQUFFLG1CQUFPLENBQUMsa0JBQU07QUFDbEMsNEJBQTRCLG1CQUFPLENBQUMsbUdBQXdCOztBQUU1RDtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkY7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsK0VBQStFLFlBQVk7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL21vZGVsL2Nhc3RCdWxrV3JpdGUuanM/ZTdhNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9lcnJvci9tb25nb29zZUVycm9yJyk7XG5jb25zdCBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvZGlzY3JpbWluYXRvci9nZXREaXNjcmltaW5hdG9yQnlWYWx1ZScpO1xuY29uc3QgYXBwbHlUaW1lc3RhbXBzVG9DaGlsZHJlbiA9IHJlcXVpcmUoJy4uL3VwZGF0ZS9hcHBseVRpbWVzdGFtcHNUb0NoaWxkcmVuJyk7XG5jb25zdCBhcHBseVRpbWVzdGFtcHNUb1VwZGF0ZSA9IHJlcXVpcmUoJy4uL3VwZGF0ZS9hcHBseVRpbWVzdGFtcHNUb1VwZGF0ZScpO1xuY29uc3QgY2FzdCA9IHJlcXVpcmUoJy4uLy4uL2Nhc3QnKTtcbmNvbnN0IGNhc3RVcGRhdGUgPSByZXF1aXJlKCcuLi9xdWVyeS9jYXN0VXBkYXRlJyk7XG5jb25zdCBjbG9uZSA9IHJlcXVpcmUoJy4uL2Nsb25lJyk7XG5jb25zdCBkZWNvcmF0ZVVwZGF0ZVdpdGhWZXJzaW9uS2V5ID0gcmVxdWlyZSgnLi4vdXBkYXRlL2RlY29yYXRlVXBkYXRlV2l0aFZlcnNpb25LZXknKTtcbmNvbnN0IHsgaW5zcGVjdCB9ID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3Qgc2V0RGVmYXVsdHNPbkluc2VydCA9IHJlcXVpcmUoJy4uL3NldERlZmF1bHRzT25JbnNlcnQnKTtcblxuLyoqXG4gKiBHaXZlbiBhIG1vZGVsIGFuZCBhIGJ1bGtXcml0ZSBvcCwgcmV0dXJuIGEgdGh1bmsgdGhhdCBoYW5kbGVzIGNhc3RpbmcgYW5kXG4gKiB2YWxpZGF0aW5nIHRoZSBpbmRpdmlkdWFsIG9wLlxuICogQHBhcmFtIHtNb2RlbH0gb3JpZ2luYWxNb2RlbFxuICogQHBhcmFtIHtPYmplY3R9IG9wXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhc3RCdWxrV3JpdGUob3JpZ2luYWxNb2RlbCwgb3AsIG9wdGlvbnMpIHtcbiAgY29uc3Qgbm93ID0gb3JpZ2luYWxNb2RlbC5iYXNlLm5vdygpO1xuXG4gIGNvbnN0IGdsb2JhbFNldERlZmF1bHRzT25JbnNlcnQgPSBvcmlnaW5hbE1vZGVsLmJhc2Uub3B0aW9ucy5zZXREZWZhdWx0c09uSW5zZXJ0O1xuICBpZiAob3BbJ2luc2VydE9uZSddKSB7XG4gICAgcmV0dXJuIChjYWxsYmFjaykgPT4ge1xuICAgICAgY29uc3QgbW9kZWwgPSBkZWNpZGVNb2RlbEJ5T2JqZWN0KG9yaWdpbmFsTW9kZWwsIG9wWydpbnNlcnRPbmUnXVsnZG9jdW1lbnQnXSk7XG5cbiAgICAgIGNvbnN0IGRvYyA9IG5ldyBtb2RlbChvcFsnaW5zZXJ0T25lJ11bJ2RvY3VtZW50J10pO1xuICAgICAgaWYgKG1vZGVsLnNjaGVtYS5vcHRpb25zLnRpbWVzdGFtcHMgJiYgb3B0aW9ucy50aW1lc3RhbXBzICE9PSBmYWxzZSkge1xuICAgICAgICBkb2MuaW5pdGlhbGl6ZVRpbWVzdGFtcHMoKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnNlc3Npb24gIT0gbnVsbCkge1xuICAgICAgICBkb2MuJHNlc3Npb24ob3B0aW9ucy5zZXNzaW9uKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZlcnNpb25LZXkgPSBtb2RlbD8uc2NoZW1hPy5vcHRpb25zPy52ZXJzaW9uS2V5O1xuICAgICAgaWYgKHZlcnNpb25LZXkgJiYgZG9jW3ZlcnNpb25LZXldID09IG51bGwpIHtcbiAgICAgICAgZG9jW3ZlcnNpb25LZXldID0gMDtcbiAgICAgIH1cbiAgICAgIG9wWydpbnNlcnRPbmUnXVsnZG9jdW1lbnQnXSA9IGRvYztcblxuICAgICAgaWYgKG9wdGlvbnMuc2tpcFZhbGlkYXRpb24gfHwgb3BbJ2luc2VydE9uZSddLnNraXBWYWxpZGF0aW9uKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG9wWydpbnNlcnRPbmUnXVsnZG9jdW1lbnQnXS4kdmFsaWRhdGUoKS50aGVuKFxuICAgICAgICAoKSA9PiB7IGNhbGxiYWNrKG51bGwpOyB9LFxuICAgICAgICBlcnIgPT4geyBjYWxsYmFjayhlcnIsIG51bGwpOyB9XG4gICAgICApO1xuICAgIH07XG4gIH0gZWxzZSBpZiAob3BbJ3VwZGF0ZU9uZSddKSB7XG4gICAgcmV0dXJuIChjYWxsYmFjaykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFvcFsndXBkYXRlT25lJ11bJ2ZpbHRlciddKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgYSBmaWx0ZXIgb2JqZWN0LicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3BbJ3VwZGF0ZU9uZSddWyd1cGRhdGUnXSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwcm92aWRlIGFuIHVwZGF0ZSBvYmplY3QuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtb2RlbCA9IGRlY2lkZU1vZGVsQnlPYmplY3Qob3JpZ2luYWxNb2RlbCwgb3BbJ3VwZGF0ZU9uZSddWydmaWx0ZXInXSk7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IG1vZGVsLnNjaGVtYTtcbiAgICAgICAgY29uc3Qgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3QgIT0gbnVsbCA/IG9wdGlvbnMuc3RyaWN0IDogbW9kZWwuc2NoZW1hLm9wdGlvbnMuc3RyaWN0O1xuXG4gICAgICAgIGNvbnN0IHVwZGF0ZSA9IGNsb25lKG9wWyd1cGRhdGVPbmUnXVsndXBkYXRlJ10pO1xuXG4gICAgICAgIF9hZGREaXNjcmltaW5hdG9yVG9PYmplY3Qoc2NoZW1hLCBvcFsndXBkYXRlT25lJ11bJ2ZpbHRlciddKTtcblxuICAgICAgICBpZiAobW9kZWwuc2NoZW1hLiR0aW1lc3RhbXBzICE9IG51bGwgJiYgb3BbJ3VwZGF0ZU9uZSddLnRpbWVzdGFtcHMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgY29uc3QgY3JlYXRlZEF0ID0gbW9kZWwuc2NoZW1hLiR0aW1lc3RhbXBzLmNyZWF0ZWRBdDtcbiAgICAgICAgICBjb25zdCB1cGRhdGVkQXQgPSBtb2RlbC5zY2hlbWEuJHRpbWVzdGFtcHMudXBkYXRlZEF0O1xuICAgICAgICAgIGFwcGx5VGltZXN0YW1wc1RvVXBkYXRlKG5vdywgY3JlYXRlZEF0LCB1cGRhdGVkQXQsIHVwZGF0ZSwge30pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wWyd1cGRhdGVPbmUnXS50aW1lc3RhbXBzICE9PSBmYWxzZSkge1xuICAgICAgICAgIGFwcGx5VGltZXN0YW1wc1RvQ2hpbGRyZW4obm93LCB1cGRhdGUsIG1vZGVsLnNjaGVtYSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzaG91bGRTZXREZWZhdWx0c09uSW5zZXJ0ID0gb3BbJ3VwZGF0ZU9uZSddLnNldERlZmF1bHRzT25JbnNlcnQgPT0gbnVsbCA/XG4gICAgICAgICAgZ2xvYmFsU2V0RGVmYXVsdHNPbkluc2VydCA6XG4gICAgICAgICAgb3BbJ3VwZGF0ZU9uZSddLnNldERlZmF1bHRzT25JbnNlcnQ7XG4gICAgICAgIGlmIChzaG91bGRTZXREZWZhdWx0c09uSW5zZXJ0ICE9PSBmYWxzZSkge1xuICAgICAgICAgIHNldERlZmF1bHRzT25JbnNlcnQob3BbJ3VwZGF0ZU9uZSddWydmaWx0ZXInXSwgbW9kZWwuc2NoZW1hLCB1cGRhdGUsIHtcbiAgICAgICAgICAgIHNldERlZmF1bHRzT25JbnNlcnQ6IHRydWUsXG4gICAgICAgICAgICB1cHNlcnQ6IG9wWyd1cGRhdGVPbmUnXS51cHNlcnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlY29yYXRlVXBkYXRlV2l0aFZlcnNpb25LZXkoXG4gICAgICAgICAgdXBkYXRlLFxuICAgICAgICAgIG9wWyd1cGRhdGVPbmUnXSxcbiAgICAgICAgICBtb2RlbC5zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5XG4gICAgICAgICk7XG5cbiAgICAgICAgb3BbJ3VwZGF0ZU9uZSddWydmaWx0ZXInXSA9IGNhc3QobW9kZWwuc2NoZW1hLCBvcFsndXBkYXRlT25lJ11bJ2ZpbHRlciddLCB7XG4gICAgICAgICAgc3RyaWN0OiBzdHJpY3QsXG4gICAgICAgICAgdXBzZXJ0OiBvcFsndXBkYXRlT25lJ10udXBzZXJ0XG4gICAgICAgIH0pO1xuICAgICAgICBvcFsndXBkYXRlT25lJ11bJ3VwZGF0ZSddID0gY2FzdFVwZGF0ZShtb2RlbC5zY2hlbWEsIHVwZGF0ZSwge1xuICAgICAgICAgIHN0cmljdDogc3RyaWN0LFxuICAgICAgICAgIHVwc2VydDogb3BbJ3VwZGF0ZU9uZSddLnVwc2VydFxuICAgICAgICB9LCBtb2RlbCwgb3BbJ3VwZGF0ZU9uZSddWydmaWx0ZXInXSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3IsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKG9wWyd1cGRhdGVNYW55J10pIHtcbiAgICByZXR1cm4gKGNhbGxiYWNrKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIW9wWyd1cGRhdGVNYW55J11bJ2ZpbHRlciddKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgYSBmaWx0ZXIgb2JqZWN0LicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3BbJ3VwZGF0ZU1hbnknXVsndXBkYXRlJ10pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcHJvdmlkZSBhbiB1cGRhdGUgb2JqZWN0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbW9kZWwgPSBkZWNpZGVNb2RlbEJ5T2JqZWN0KG9yaWdpbmFsTW9kZWwsIG9wWyd1cGRhdGVNYW55J11bJ2ZpbHRlciddKTtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gbW9kZWwuc2NoZW1hO1xuICAgICAgICBjb25zdCBzdHJpY3QgPSBvcHRpb25zLnN0cmljdCAhPSBudWxsID8gb3B0aW9ucy5zdHJpY3QgOiBtb2RlbC5zY2hlbWEub3B0aW9ucy5zdHJpY3Q7XG5cbiAgICAgICAgY29uc3Qgc2hvdWxkU2V0RGVmYXVsdHNPbkluc2VydCA9IG9wWyd1cGRhdGVNYW55J10uc2V0RGVmYXVsdHNPbkluc2VydCA9PSBudWxsID9cbiAgICAgICAgICBnbG9iYWxTZXREZWZhdWx0c09uSW5zZXJ0IDpcbiAgICAgICAgICBvcFsndXBkYXRlTWFueSddLnNldERlZmF1bHRzT25JbnNlcnQ7XG5cbiAgICAgICAgaWYgKHNob3VsZFNldERlZmF1bHRzT25JbnNlcnQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgc2V0RGVmYXVsdHNPbkluc2VydChvcFsndXBkYXRlTWFueSddWydmaWx0ZXInXSwgbW9kZWwuc2NoZW1hLCBvcFsndXBkYXRlTWFueSddWyd1cGRhdGUnXSwge1xuICAgICAgICAgICAgc2V0RGVmYXVsdHNPbkluc2VydDogdHJ1ZSxcbiAgICAgICAgICAgIHVwc2VydDogb3BbJ3VwZGF0ZU1hbnknXS51cHNlcnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb2RlbC5zY2hlbWEuJHRpbWVzdGFtcHMgIT0gbnVsbCAmJiBvcFsndXBkYXRlTWFueSddLnRpbWVzdGFtcHMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgY29uc3QgY3JlYXRlZEF0ID0gbW9kZWwuc2NoZW1hLiR0aW1lc3RhbXBzLmNyZWF0ZWRBdDtcbiAgICAgICAgICBjb25zdCB1cGRhdGVkQXQgPSBtb2RlbC5zY2hlbWEuJHRpbWVzdGFtcHMudXBkYXRlZEF0O1xuICAgICAgICAgIGFwcGx5VGltZXN0YW1wc1RvVXBkYXRlKG5vdywgY3JlYXRlZEF0LCB1cGRhdGVkQXQsIG9wWyd1cGRhdGVNYW55J11bJ3VwZGF0ZSddLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wWyd1cGRhdGVNYW55J10udGltZXN0YW1wcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBhcHBseVRpbWVzdGFtcHNUb0NoaWxkcmVuKG5vdywgb3BbJ3VwZGF0ZU1hbnknXVsndXBkYXRlJ10sIG1vZGVsLnNjaGVtYSk7XG4gICAgICAgIH1cblxuICAgICAgICBfYWRkRGlzY3JpbWluYXRvclRvT2JqZWN0KHNjaGVtYSwgb3BbJ3VwZGF0ZU1hbnknXVsnZmlsdGVyJ10pO1xuXG4gICAgICAgIGRlY29yYXRlVXBkYXRlV2l0aFZlcnNpb25LZXkoXG4gICAgICAgICAgb3BbJ3VwZGF0ZU1hbnknXVsndXBkYXRlJ10sXG4gICAgICAgICAgb3BbJ3VwZGF0ZU1hbnknXSxcbiAgICAgICAgICBtb2RlbC5zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5XG4gICAgICAgICk7XG5cbiAgICAgICAgb3BbJ3VwZGF0ZU1hbnknXVsnZmlsdGVyJ10gPSBjYXN0KG1vZGVsLnNjaGVtYSwgb3BbJ3VwZGF0ZU1hbnknXVsnZmlsdGVyJ10sIHtcbiAgICAgICAgICBzdHJpY3Q6IHN0cmljdCxcbiAgICAgICAgICB1cHNlcnQ6IG9wWyd1cGRhdGVNYW55J10udXBzZXJ0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9wWyd1cGRhdGVNYW55J11bJ3VwZGF0ZSddID0gY2FzdFVwZGF0ZShtb2RlbC5zY2hlbWEsIG9wWyd1cGRhdGVNYW55J11bJ3VwZGF0ZSddLCB7XG4gICAgICAgICAgc3RyaWN0OiBzdHJpY3QsXG4gICAgICAgICAgdXBzZXJ0OiBvcFsndXBkYXRlTWFueSddLnVwc2VydFxuICAgICAgICB9LCBtb2RlbCwgb3BbJ3VwZGF0ZU1hbnknXVsnZmlsdGVyJ10pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChvcFsncmVwbGFjZU9uZSddKSB7XG4gICAgcmV0dXJuIChjYWxsYmFjaykgPT4ge1xuICAgICAgY29uc3QgbW9kZWwgPSBkZWNpZGVNb2RlbEJ5T2JqZWN0KG9yaWdpbmFsTW9kZWwsIG9wWydyZXBsYWNlT25lJ11bJ2ZpbHRlciddKTtcbiAgICAgIGNvbnN0IHNjaGVtYSA9IG1vZGVsLnNjaGVtYTtcbiAgICAgIGNvbnN0IHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0ICE9IG51bGwgPyBvcHRpb25zLnN0cmljdCA6IG1vZGVsLnNjaGVtYS5vcHRpb25zLnN0cmljdDtcblxuICAgICAgX2FkZERpc2NyaW1pbmF0b3JUb09iamVjdChzY2hlbWEsIG9wWydyZXBsYWNlT25lJ11bJ2ZpbHRlciddKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIG9wWydyZXBsYWNlT25lJ11bJ2ZpbHRlciddID0gY2FzdChtb2RlbC5zY2hlbWEsIG9wWydyZXBsYWNlT25lJ11bJ2ZpbHRlciddLCB7XG4gICAgICAgICAgc3RyaWN0OiBzdHJpY3QsXG4gICAgICAgICAgdXBzZXJ0OiBvcFsncmVwbGFjZU9uZSddLnVwc2VydFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvciwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCBgc2tpcElkYCwgb3RoZXJ3aXNlIHdlIGdldCBcIl9pZCBmaWVsZCBjYW5ub3QgYmUgY2hhbmdlZFwiXG4gICAgICBjb25zdCBkb2MgPSBuZXcgbW9kZWwob3BbJ3JlcGxhY2VPbmUnXVsncmVwbGFjZW1lbnQnXSwgc3RyaWN0LCB0cnVlKTtcbiAgICAgIGlmIChtb2RlbC5zY2hlbWEub3B0aW9ucy50aW1lc3RhbXBzKSB7XG4gICAgICAgIGRvYy5pbml0aWFsaXplVGltZXN0YW1wcygpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuc2Vzc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIGRvYy4kc2Vzc2lvbihvcHRpb25zLnNlc3Npb24pO1xuICAgICAgfVxuICAgICAgY29uc3QgdmVyc2lvbktleSA9IG1vZGVsPy5zY2hlbWE/Lm9wdGlvbnM/LnZlcnNpb25LZXk7XG4gICAgICBpZiAodmVyc2lvbktleSAmJiBkb2NbdmVyc2lvbktleV0gPT0gbnVsbCkge1xuICAgICAgICBkb2NbdmVyc2lvbktleV0gPSAwO1xuICAgICAgfVxuICAgICAgb3BbJ3JlcGxhY2VPbmUnXVsncmVwbGFjZW1lbnQnXSA9IGRvYztcblxuICAgICAgaWYgKG9wdGlvbnMuc2tpcFZhbGlkYXRpb24gfHwgb3BbJ3JlcGxhY2VPbmUnXS5za2lwVmFsaWRhdGlvbikge1xuICAgICAgICBvcFsncmVwbGFjZU9uZSddWydyZXBsYWNlbWVudCddID0gb3BbJ3JlcGxhY2VPbmUnXVsncmVwbGFjZW1lbnQnXS50b0JTT04oKTtcbiAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgb3BbJ3JlcGxhY2VPbmUnXVsncmVwbGFjZW1lbnQnXS4kdmFsaWRhdGUoKS50aGVuKFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgb3BbJ3JlcGxhY2VPbmUnXVsncmVwbGFjZW1lbnQnXSA9IG9wWydyZXBsYWNlT25lJ11bJ3JlcGxhY2VtZW50J10udG9CU09OKCk7XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yID0+IHtcbiAgICAgICAgICBjYWxsYmFjayhlcnJvciwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChvcFsnZGVsZXRlT25lJ10pIHtcbiAgICByZXR1cm4gKGNhbGxiYWNrKSA9PiB7XG4gICAgICBjb25zdCBtb2RlbCA9IGRlY2lkZU1vZGVsQnlPYmplY3Qob3JpZ2luYWxNb2RlbCwgb3BbJ2RlbGV0ZU9uZSddWydmaWx0ZXInXSk7XG4gICAgICBjb25zdCBzY2hlbWEgPSBtb2RlbC5zY2hlbWE7XG5cbiAgICAgIF9hZGREaXNjcmltaW5hdG9yVG9PYmplY3Qoc2NoZW1hLCBvcFsnZGVsZXRlT25lJ11bJ2ZpbHRlciddKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgb3BbJ2RlbGV0ZU9uZSddWydmaWx0ZXInXSA9IGNhc3QobW9kZWwuc2NoZW1hLFxuICAgICAgICAgIG9wWydkZWxldGVPbmUnXVsnZmlsdGVyJ10pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChvcFsnZGVsZXRlTWFueSddKSB7XG4gICAgcmV0dXJuIChjYWxsYmFjaykgPT4ge1xuICAgICAgY29uc3QgbW9kZWwgPSBkZWNpZGVNb2RlbEJ5T2JqZWN0KG9yaWdpbmFsTW9kZWwsIG9wWydkZWxldGVNYW55J11bJ2ZpbHRlciddKTtcbiAgICAgIGNvbnN0IHNjaGVtYSA9IG1vZGVsLnNjaGVtYTtcblxuICAgICAgX2FkZERpc2NyaW1pbmF0b3JUb09iamVjdChzY2hlbWEsIG9wWydkZWxldGVNYW55J11bJ2ZpbHRlciddKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgb3BbJ2RlbGV0ZU1hbnknXVsnZmlsdGVyJ10gPSBjYXN0KG1vZGVsLnNjaGVtYSxcbiAgICAgICAgICBvcFsnZGVsZXRlTWFueSddWydmaWx0ZXInXSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3IsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoY2FsbGJhY2spID0+IHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IE1vbmdvb3NlRXJyb3IoYEludmFsaWQgb3AgcGFzc2VkIHRvIFxcYGJ1bGtXcml0ZSgpXFxgOiAke2luc3BlY3Qob3ApfWApO1xuICAgICAgY2FsbGJhY2soZXJyb3IsIG51bGwpO1xuICAgIH07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9hZGREaXNjcmltaW5hdG9yVG9PYmplY3Qoc2NoZW1hLCBvYmopIHtcbiAgaWYgKHNjaGVtYSA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChzY2hlbWEuZGlzY3JpbWluYXRvck1hcHBpbmcgJiYgIXNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZy5pc1Jvb3QpIHtcbiAgICBvYmpbc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nLmtleV0gPSBzY2hlbWEuZGlzY3JpbWluYXRvck1hcHBpbmcudmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBnZXRzIGRpc2NyaW1pbmF0b3IgbW9kZWwgaWYgZGlzY3JpbWluYXRvciBrZXkgaXMgcHJlc2VudCBpbiBvYmplY3RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGRlY2lkZU1vZGVsQnlPYmplY3QobW9kZWwsIG9iamVjdCkge1xuICBjb25zdCBkaXNjcmltaW5hdG9yS2V5ID0gbW9kZWwuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleTtcbiAgaWYgKG9iamVjdCAhPSBudWxsICYmIG9iamVjdC5oYXNPd25Qcm9wZXJ0eShkaXNjcmltaW5hdG9yS2V5KSkge1xuICAgIG1vZGVsID0gZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUobW9kZWwuZGlzY3JpbWluYXRvcnMsIG9iamVjdFtkaXNjcmltaW5hdG9yS2V5XSkgfHwgbW9kZWw7XG4gIH1cbiAgcmV0dXJuIG1vZGVsO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/model/castBulkWrite.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/model/discriminator.js":
/*!***************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/model/discriminator.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Mixed = __webpack_require__(/*! ../../schema/mixed */ \"../backend/node_modules/mongoose/lib/schema/mixed.js\");\nconst applyBuiltinPlugins = __webpack_require__(/*! ../schema/applyBuiltinPlugins */ \"../backend/node_modules/mongoose/lib/helpers/schema/applyBuiltinPlugins.js\");\nconst clone = __webpack_require__(/*! ../clone */ \"../backend/node_modules/mongoose/lib/helpers/clone.js\");\nconst defineKey = (__webpack_require__(/*! ../document/compile */ \"../backend/node_modules/mongoose/lib/helpers/document/compile.js\").defineKey);\nconst get = __webpack_require__(/*! ../get */ \"../backend/node_modules/mongoose/lib/helpers/get.js\");\nconst utils = __webpack_require__(/*! ../../utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\nconst mergeDiscriminatorSchema = __webpack_require__(/*! ../../helpers/discriminator/mergeDiscriminatorSchema */ \"../backend/node_modules/mongoose/lib/helpers/discriminator/mergeDiscriminatorSchema.js\");\n\nconst CUSTOMIZABLE_DISCRIMINATOR_OPTIONS = {\n  toJSON: true,\n  toObject: true,\n  _id: true,\n  id: true,\n  virtuals: true,\n  methods: true\n};\n\n/*!\n * ignore\n */\n\nmodule.exports = function discriminator(model, name, schema, tiedValue, applyPlugins, mergeHooks, overwriteExisting) {\n  if (!(schema && schema.instanceOfSchema)) {\n    throw new Error('You must pass a valid discriminator Schema');\n  }\n\n  mergeHooks = mergeHooks == null ? true : mergeHooks;\n\n  if (model.schema.discriminatorMapping &&\n      !model.schema.discriminatorMapping.isRoot) {\n    throw new Error('Discriminator \"' + name +\n        '\" can only be a discriminator of the root model');\n  }\n\n  if (applyPlugins) {\n    const applyPluginsToDiscriminators = get(model.base,\n      'options.applyPluginsToDiscriminators', false) || !mergeHooks;\n    // Even if `applyPluginsToDiscriminators` isn't set, we should still apply\n    // global plugins to schemas embedded in the discriminator schema (gh-7370)\n    model.base._applyPlugins(schema, {\n      skipTopLevel: !applyPluginsToDiscriminators\n    });\n  } else if (!mergeHooks) {\n    applyBuiltinPlugins(schema);\n  }\n\n  const key = model.schema.options.discriminatorKey;\n\n  const existingPath = model.schema.path(key);\n  if (existingPath != null) {\n    if (!utils.hasUserDefinedProperty(existingPath.options, 'select')) {\n      existingPath.options.select = true;\n    }\n    existingPath.options.$skipDiscriminatorCheck = true;\n  } else {\n    const baseSchemaAddition = {};\n    baseSchemaAddition[key] = {\n      default: void 0,\n      select: true,\n      $skipDiscriminatorCheck: true\n    };\n    baseSchemaAddition[key][model.schema.options.typeKey] = String;\n    model.schema.add(baseSchemaAddition);\n    defineKey({\n      prop: key,\n      prototype: model.prototype,\n      options: model.schema.options\n    });\n  }\n\n  if (schema.path(key) && schema.path(key).options.$skipDiscriminatorCheck !== true) {\n    throw new Error('Discriminator \"' + name +\n        '\" cannot have field with name \"' + key + '\"');\n  }\n\n  let value = name;\n  if ((typeof tiedValue === 'string' && tiedValue.length) || tiedValue != null) {\n    value = tiedValue;\n  }\n\n  function merge(schema, baseSchema) {\n    // Retain original schema before merging base schema\n    schema._baseSchema = baseSchema;\n    if (baseSchema.paths._id &&\n        baseSchema.paths._id.options &&\n        !baseSchema.paths._id.options.auto) {\n      schema.remove('_id');\n    }\n\n    // Find conflicting paths: if something is a path in the base schema\n    // and a nested path in the child schema, overwrite the base schema path.\n    // See gh-6076\n    const baseSchemaPaths = Object.keys(baseSchema.paths);\n    const conflictingPaths = [];\n\n    for (const path of baseSchemaPaths) {\n      if (schema.nested[path]) {\n        conflictingPaths.push(path);\n        continue;\n      }\n\n      if (path.indexOf('.') === -1) {\n        continue;\n      }\n      const sp = path.split('.').slice(0, -1);\n      let cur = '';\n      for (const piece of sp) {\n        cur += (cur.length ? '.' : '') + piece;\n        if (schema.paths[cur] instanceof Mixed ||\n            schema.singleNestedPaths[cur] instanceof Mixed) {\n          conflictingPaths.push(path);\n        }\n      }\n    }\n\n    mergeDiscriminatorSchema(schema, baseSchema);\n\n    // Clean up conflicting paths _after_ merging re: gh-6076\n    for (const conflictingPath of conflictingPaths) {\n      delete schema.paths[conflictingPath];\n    }\n\n    // Rebuild schema models because schemas may have been merged re: #7884\n    schema.childSchemas.forEach(obj => {\n      obj.model.prototype.$__setSchema(obj.schema);\n    });\n\n    const obj = {};\n    obj[key] = {\n      default: value,\n      select: true,\n      set: function(newName) {\n        if (newName === value || (Array.isArray(value) && utils.deepEqual(newName, value))) {\n          return value;\n        }\n        throw new Error('Can\\'t set discriminator key \"' + key + '\"');\n      },\n      $skipDiscriminatorCheck: true\n    };\n    obj[key][schema.options.typeKey] = existingPath ? existingPath.options[schema.options.typeKey] : String;\n    schema.add(obj);\n\n    schema.discriminatorMapping = { key: key, value: value, isRoot: false };\n\n    if (baseSchema.options.collection) {\n      schema.options.collection = baseSchema.options.collection;\n    }\n    const toJSON = schema.options.toJSON;\n    const toObject = schema.options.toObject;\n    const _id = schema.options._id;\n    const id = schema.options.id;\n\n    const keys = Object.keys(schema.options);\n    schema.options.discriminatorKey = baseSchema.options.discriminatorKey;\n    const userProvidedOptions = schema._userProvidedOptions;\n    for (const _key of keys) {\n      if (!CUSTOMIZABLE_DISCRIMINATOR_OPTIONS[_key]) {\n        // Use `schema.options` in `deepEqual()` because of `discriminatorKey`\n        // set above. We don't allow customizing discriminator key, always\n        // overwrite. See gh-9238\n        if (_key in userProvidedOptions && !utils.deepEqual(schema.options[_key], baseSchema.options[_key])) {\n          throw new Error('Can\\'t customize discriminator option ' + _key +\n            ' (can only modify ' +\n            Object.keys(CUSTOMIZABLE_DISCRIMINATOR_OPTIONS).join(', ') +\n            ')');\n        }\n      }\n    }\n    schema.options = clone(baseSchema.options);\n\n    for (const _key of Object.keys(userProvidedOptions)) {\n      schema.options[_key] = userProvidedOptions[_key];\n    }\n    if (toJSON) schema.options.toJSON = toJSON;\n    if (toObject) schema.options.toObject = toObject;\n    if (typeof _id !== 'undefined') {\n      schema.options._id = _id;\n    }\n    schema.options.id = id;\n    if (mergeHooks) {\n      schema.s.hooks = model.schema.s.hooks.merge(schema.s.hooks);\n    }\n    if (applyPlugins) {\n      schema.plugins = Array.prototype.slice.call(baseSchema.plugins);\n    }\n    schema.callQueue = baseSchema.callQueue.concat(schema.callQueue);\n    delete schema._requiredpaths; // reset just in case Schema#requiredPaths() was called on either schema\n  }\n\n  // merges base schema into new discriminator schema and sets new type field.\n  merge(schema, model.schema);\n\n  if (!model.discriminators) {\n    model.discriminators = {};\n  }\n\n  if (!model.schema.discriminatorMapping) {\n    model.schema.discriminatorMapping = { key: key, value: null, isRoot: true };\n  }\n  if (!model.schema.discriminators) {\n    model.schema.discriminators = {};\n  }\n\n  model.schema.discriminators[name] = schema;\n\n  if (model.discriminators[name] && !schema.options.overwriteModels && !overwriteExisting) {\n    throw new Error('Discriminator with name \"' + name + '\" already exists');\n  }\n\n  return schema;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvbW9kZWwvZGlzY3JpbWluYXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsZ0ZBQW9CO0FBQzFDLDRCQUE0QixtQkFBTyxDQUFDLGlIQUErQjtBQUNuRSxjQUFjLG1CQUFPLENBQUMsdUVBQVU7QUFDaEMsa0JBQWtCLDhIQUF3QztBQUMxRCxZQUFZLG1CQUFPLENBQUMsbUVBQVE7QUFDNUIsY0FBYyxtQkFBTyxDQUFDLGtFQUFhO0FBQ25DLGlDQUFpQyxtQkFBTyxDQUFDLG9KQUFzRDs7QUFFL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL21vZGVsL2Rpc2NyaW1pbmF0b3IuanM/M2EzMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1peGVkID0gcmVxdWlyZSgnLi4vLi4vc2NoZW1hL21peGVkJyk7XG5jb25zdCBhcHBseUJ1aWx0aW5QbHVnaW5zID0gcmVxdWlyZSgnLi4vc2NoZW1hL2FwcGx5QnVpbHRpblBsdWdpbnMnKTtcbmNvbnN0IGNsb25lID0gcmVxdWlyZSgnLi4vY2xvbmUnKTtcbmNvbnN0IGRlZmluZUtleSA9IHJlcXVpcmUoJy4uL2RvY3VtZW50L2NvbXBpbGUnKS5kZWZpbmVLZXk7XG5jb25zdCBnZXQgPSByZXF1aXJlKCcuLi9nZXQnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcbmNvbnN0IG1lcmdlRGlzY3JpbWluYXRvclNjaGVtYSA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvZGlzY3JpbWluYXRvci9tZXJnZURpc2NyaW1pbmF0b3JTY2hlbWEnKTtcblxuY29uc3QgQ1VTVE9NSVpBQkxFX0RJU0NSSU1JTkFUT1JfT1BUSU9OUyA9IHtcbiAgdG9KU09OOiB0cnVlLFxuICB0b09iamVjdDogdHJ1ZSxcbiAgX2lkOiB0cnVlLFxuICBpZDogdHJ1ZSxcbiAgdmlydHVhbHM6IHRydWUsXG4gIG1ldGhvZHM6IHRydWVcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkaXNjcmltaW5hdG9yKG1vZGVsLCBuYW1lLCBzY2hlbWEsIHRpZWRWYWx1ZSwgYXBwbHlQbHVnaW5zLCBtZXJnZUhvb2tzLCBvdmVyd3JpdGVFeGlzdGluZykge1xuICBpZiAoIShzY2hlbWEgJiYgc2NoZW1hLmluc3RhbmNlT2ZTY2hlbWEpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBwYXNzIGEgdmFsaWQgZGlzY3JpbWluYXRvciBTY2hlbWEnKTtcbiAgfVxuXG4gIG1lcmdlSG9va3MgPSBtZXJnZUhvb2tzID09IG51bGwgPyB0cnVlIDogbWVyZ2VIb29rcztcblxuICBpZiAobW9kZWwuc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nICYmXG4gICAgICAhbW9kZWwuc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nLmlzUm9vdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRGlzY3JpbWluYXRvciBcIicgKyBuYW1lICtcbiAgICAgICAgJ1wiIGNhbiBvbmx5IGJlIGEgZGlzY3JpbWluYXRvciBvZiB0aGUgcm9vdCBtb2RlbCcpO1xuICB9XG5cbiAgaWYgKGFwcGx5UGx1Z2lucykge1xuICAgIGNvbnN0IGFwcGx5UGx1Z2luc1RvRGlzY3JpbWluYXRvcnMgPSBnZXQobW9kZWwuYmFzZSxcbiAgICAgICdvcHRpb25zLmFwcGx5UGx1Z2luc1RvRGlzY3JpbWluYXRvcnMnLCBmYWxzZSkgfHwgIW1lcmdlSG9va3M7XG4gICAgLy8gRXZlbiBpZiBgYXBwbHlQbHVnaW5zVG9EaXNjcmltaW5hdG9yc2AgaXNuJ3Qgc2V0LCB3ZSBzaG91bGQgc3RpbGwgYXBwbHlcbiAgICAvLyBnbG9iYWwgcGx1Z2lucyB0byBzY2hlbWFzIGVtYmVkZGVkIGluIHRoZSBkaXNjcmltaW5hdG9yIHNjaGVtYSAoZ2gtNzM3MClcbiAgICBtb2RlbC5iYXNlLl9hcHBseVBsdWdpbnMoc2NoZW1hLCB7XG4gICAgICBza2lwVG9wTGV2ZWw6ICFhcHBseVBsdWdpbnNUb0Rpc2NyaW1pbmF0b3JzXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoIW1lcmdlSG9va3MpIHtcbiAgICBhcHBseUJ1aWx0aW5QbHVnaW5zKHNjaGVtYSk7XG4gIH1cblxuICBjb25zdCBrZXkgPSBtb2RlbC5zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5O1xuXG4gIGNvbnN0IGV4aXN0aW5nUGF0aCA9IG1vZGVsLnNjaGVtYS5wYXRoKGtleSk7XG4gIGlmIChleGlzdGluZ1BhdGggIT0gbnVsbCkge1xuICAgIGlmICghdXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eShleGlzdGluZ1BhdGgub3B0aW9ucywgJ3NlbGVjdCcpKSB7XG4gICAgICBleGlzdGluZ1BhdGgub3B0aW9ucy5zZWxlY3QgPSB0cnVlO1xuICAgIH1cbiAgICBleGlzdGluZ1BhdGgub3B0aW9ucy4kc2tpcERpc2NyaW1pbmF0b3JDaGVjayA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgYmFzZVNjaGVtYUFkZGl0aW9uID0ge307XG4gICAgYmFzZVNjaGVtYUFkZGl0aW9uW2tleV0gPSB7XG4gICAgICBkZWZhdWx0OiB2b2lkIDAsXG4gICAgICBzZWxlY3Q6IHRydWUsXG4gICAgICAkc2tpcERpc2NyaW1pbmF0b3JDaGVjazogdHJ1ZVxuICAgIH07XG4gICAgYmFzZVNjaGVtYUFkZGl0aW9uW2tleV1bbW9kZWwuc2NoZW1hLm9wdGlvbnMudHlwZUtleV0gPSBTdHJpbmc7XG4gICAgbW9kZWwuc2NoZW1hLmFkZChiYXNlU2NoZW1hQWRkaXRpb24pO1xuICAgIGRlZmluZUtleSh7XG4gICAgICBwcm9wOiBrZXksXG4gICAgICBwcm90b3R5cGU6IG1vZGVsLnByb3RvdHlwZSxcbiAgICAgIG9wdGlvbnM6IG1vZGVsLnNjaGVtYS5vcHRpb25zXG4gICAgfSk7XG4gIH1cblxuICBpZiAoc2NoZW1hLnBhdGgoa2V5KSAmJiBzY2hlbWEucGF0aChrZXkpLm9wdGlvbnMuJHNraXBEaXNjcmltaW5hdG9yQ2hlY2sgIT09IHRydWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Rpc2NyaW1pbmF0b3IgXCInICsgbmFtZSArXG4gICAgICAgICdcIiBjYW5ub3QgaGF2ZSBmaWVsZCB3aXRoIG5hbWUgXCInICsga2V5ICsgJ1wiJyk7XG4gIH1cblxuICBsZXQgdmFsdWUgPSBuYW1lO1xuICBpZiAoKHR5cGVvZiB0aWVkVmFsdWUgPT09ICdzdHJpbmcnICYmIHRpZWRWYWx1ZS5sZW5ndGgpIHx8IHRpZWRWYWx1ZSAhPSBudWxsKSB7XG4gICAgdmFsdWUgPSB0aWVkVmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZShzY2hlbWEsIGJhc2VTY2hlbWEpIHtcbiAgICAvLyBSZXRhaW4gb3JpZ2luYWwgc2NoZW1hIGJlZm9yZSBtZXJnaW5nIGJhc2Ugc2NoZW1hXG4gICAgc2NoZW1hLl9iYXNlU2NoZW1hID0gYmFzZVNjaGVtYTtcbiAgICBpZiAoYmFzZVNjaGVtYS5wYXRocy5faWQgJiZcbiAgICAgICAgYmFzZVNjaGVtYS5wYXRocy5faWQub3B0aW9ucyAmJlxuICAgICAgICAhYmFzZVNjaGVtYS5wYXRocy5faWQub3B0aW9ucy5hdXRvKSB7XG4gICAgICBzY2hlbWEucmVtb3ZlKCdfaWQnKTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIGNvbmZsaWN0aW5nIHBhdGhzOiBpZiBzb21ldGhpbmcgaXMgYSBwYXRoIGluIHRoZSBiYXNlIHNjaGVtYVxuICAgIC8vIGFuZCBhIG5lc3RlZCBwYXRoIGluIHRoZSBjaGlsZCBzY2hlbWEsIG92ZXJ3cml0ZSB0aGUgYmFzZSBzY2hlbWEgcGF0aC5cbiAgICAvLyBTZWUgZ2gtNjA3NlxuICAgIGNvbnN0IGJhc2VTY2hlbWFQYXRocyA9IE9iamVjdC5rZXlzKGJhc2VTY2hlbWEucGF0aHMpO1xuICAgIGNvbnN0IGNvbmZsaWN0aW5nUGF0aHMgPSBbXTtcblxuICAgIGZvciAoY29uc3QgcGF0aCBvZiBiYXNlU2NoZW1hUGF0aHMpIHtcbiAgICAgIGlmIChzY2hlbWEubmVzdGVkW3BhdGhdKSB7XG4gICAgICAgIGNvbmZsaWN0aW5nUGF0aHMucHVzaChwYXRoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXRoLmluZGV4T2YoJy4nKSA9PT0gLTEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBzcCA9IHBhdGguc3BsaXQoJy4nKS5zbGljZSgwLCAtMSk7XG4gICAgICBsZXQgY3VyID0gJyc7XG4gICAgICBmb3IgKGNvbnN0IHBpZWNlIG9mIHNwKSB7XG4gICAgICAgIGN1ciArPSAoY3VyLmxlbmd0aCA/ICcuJyA6ICcnKSArIHBpZWNlO1xuICAgICAgICBpZiAoc2NoZW1hLnBhdGhzW2N1cl0gaW5zdGFuY2VvZiBNaXhlZCB8fFxuICAgICAgICAgICAgc2NoZW1hLnNpbmdsZU5lc3RlZFBhdGhzW2N1cl0gaW5zdGFuY2VvZiBNaXhlZCkge1xuICAgICAgICAgIGNvbmZsaWN0aW5nUGF0aHMucHVzaChwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIG1lcmdlRGlzY3JpbWluYXRvclNjaGVtYShzY2hlbWEsIGJhc2VTY2hlbWEpO1xuXG4gICAgLy8gQ2xlYW4gdXAgY29uZmxpY3RpbmcgcGF0aHMgX2FmdGVyXyBtZXJnaW5nIHJlOiBnaC02MDc2XG4gICAgZm9yIChjb25zdCBjb25mbGljdGluZ1BhdGggb2YgY29uZmxpY3RpbmdQYXRocykge1xuICAgICAgZGVsZXRlIHNjaGVtYS5wYXRoc1tjb25mbGljdGluZ1BhdGhdO1xuICAgIH1cblxuICAgIC8vIFJlYnVpbGQgc2NoZW1hIG1vZGVscyBiZWNhdXNlIHNjaGVtYXMgbWF5IGhhdmUgYmVlbiBtZXJnZWQgcmU6ICM3ODg0XG4gICAgc2NoZW1hLmNoaWxkU2NoZW1hcy5mb3JFYWNoKG9iaiA9PiB7XG4gICAgICBvYmoubW9kZWwucHJvdG90eXBlLiRfX3NldFNjaGVtYShvYmouc2NoZW1hKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgIG9ialtrZXldID0ge1xuICAgICAgZGVmYXVsdDogdmFsdWUsXG4gICAgICBzZWxlY3Q6IHRydWUsXG4gICAgICBzZXQ6IGZ1bmN0aW9uKG5ld05hbWUpIHtcbiAgICAgICAgaWYgKG5ld05hbWUgPT09IHZhbHVlIHx8IChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB1dGlscy5kZWVwRXF1YWwobmV3TmFtZSwgdmFsdWUpKSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3Qgc2V0IGRpc2NyaW1pbmF0b3Iga2V5IFwiJyArIGtleSArICdcIicpO1xuICAgICAgfSxcbiAgICAgICRza2lwRGlzY3JpbWluYXRvckNoZWNrOiB0cnVlXG4gICAgfTtcbiAgICBvYmpba2V5XVtzY2hlbWEub3B0aW9ucy50eXBlS2V5XSA9IGV4aXN0aW5nUGF0aCA/IGV4aXN0aW5nUGF0aC5vcHRpb25zW3NjaGVtYS5vcHRpb25zLnR5cGVLZXldIDogU3RyaW5nO1xuICAgIHNjaGVtYS5hZGQob2JqKTtcblxuICAgIHNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZyA9IHsga2V5OiBrZXksIHZhbHVlOiB2YWx1ZSwgaXNSb290OiBmYWxzZSB9O1xuXG4gICAgaWYgKGJhc2VTY2hlbWEub3B0aW9ucy5jb2xsZWN0aW9uKSB7XG4gICAgICBzY2hlbWEub3B0aW9ucy5jb2xsZWN0aW9uID0gYmFzZVNjaGVtYS5vcHRpb25zLmNvbGxlY3Rpb247XG4gICAgfVxuICAgIGNvbnN0IHRvSlNPTiA9IHNjaGVtYS5vcHRpb25zLnRvSlNPTjtcbiAgICBjb25zdCB0b09iamVjdCA9IHNjaGVtYS5vcHRpb25zLnRvT2JqZWN0O1xuICAgIGNvbnN0IF9pZCA9IHNjaGVtYS5vcHRpb25zLl9pZDtcbiAgICBjb25zdCBpZCA9IHNjaGVtYS5vcHRpb25zLmlkO1xuXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNjaGVtYS5vcHRpb25zKTtcbiAgICBzY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5ID0gYmFzZVNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXk7XG4gICAgY29uc3QgdXNlclByb3ZpZGVkT3B0aW9ucyA9IHNjaGVtYS5fdXNlclByb3ZpZGVkT3B0aW9ucztcbiAgICBmb3IgKGNvbnN0IF9rZXkgb2Yga2V5cykge1xuICAgICAgaWYgKCFDVVNUT01JWkFCTEVfRElTQ1JJTUlOQVRPUl9PUFRJT05TW19rZXldKSB7XG4gICAgICAgIC8vIFVzZSBgc2NoZW1hLm9wdGlvbnNgIGluIGBkZWVwRXF1YWwoKWAgYmVjYXVzZSBvZiBgZGlzY3JpbWluYXRvcktleWBcbiAgICAgICAgLy8gc2V0IGFib3ZlLiBXZSBkb24ndCBhbGxvdyBjdXN0b21pemluZyBkaXNjcmltaW5hdG9yIGtleSwgYWx3YXlzXG4gICAgICAgIC8vIG92ZXJ3cml0ZS4gU2VlIGdoLTkyMzhcbiAgICAgICAgaWYgKF9rZXkgaW4gdXNlclByb3ZpZGVkT3B0aW9ucyAmJiAhdXRpbHMuZGVlcEVxdWFsKHNjaGVtYS5vcHRpb25zW19rZXldLCBiYXNlU2NoZW1hLm9wdGlvbnNbX2tleV0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IGN1c3RvbWl6ZSBkaXNjcmltaW5hdG9yIG9wdGlvbiAnICsgX2tleSArXG4gICAgICAgICAgICAnIChjYW4gb25seSBtb2RpZnkgJyArXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhDVVNUT01JWkFCTEVfRElTQ1JJTUlOQVRPUl9PUFRJT05TKS5qb2luKCcsICcpICtcbiAgICAgICAgICAgICcpJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc2NoZW1hLm9wdGlvbnMgPSBjbG9uZShiYXNlU2NoZW1hLm9wdGlvbnMpO1xuXG4gICAgZm9yIChjb25zdCBfa2V5IG9mIE9iamVjdC5rZXlzKHVzZXJQcm92aWRlZE9wdGlvbnMpKSB7XG4gICAgICBzY2hlbWEub3B0aW9uc1tfa2V5XSA9IHVzZXJQcm92aWRlZE9wdGlvbnNbX2tleV07XG4gICAgfVxuICAgIGlmICh0b0pTT04pIHNjaGVtYS5vcHRpb25zLnRvSlNPTiA9IHRvSlNPTjtcbiAgICBpZiAodG9PYmplY3QpIHNjaGVtYS5vcHRpb25zLnRvT2JqZWN0ID0gdG9PYmplY3Q7XG4gICAgaWYgKHR5cGVvZiBfaWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBzY2hlbWEub3B0aW9ucy5faWQgPSBfaWQ7XG4gICAgfVxuICAgIHNjaGVtYS5vcHRpb25zLmlkID0gaWQ7XG4gICAgaWYgKG1lcmdlSG9va3MpIHtcbiAgICAgIHNjaGVtYS5zLmhvb2tzID0gbW9kZWwuc2NoZW1hLnMuaG9va3MubWVyZ2Uoc2NoZW1hLnMuaG9va3MpO1xuICAgIH1cbiAgICBpZiAoYXBwbHlQbHVnaW5zKSB7XG4gICAgICBzY2hlbWEucGx1Z2lucyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGJhc2VTY2hlbWEucGx1Z2lucyk7XG4gICAgfVxuICAgIHNjaGVtYS5jYWxsUXVldWUgPSBiYXNlU2NoZW1hLmNhbGxRdWV1ZS5jb25jYXQoc2NoZW1hLmNhbGxRdWV1ZSk7XG4gICAgZGVsZXRlIHNjaGVtYS5fcmVxdWlyZWRwYXRoczsgLy8gcmVzZXQganVzdCBpbiBjYXNlIFNjaGVtYSNyZXF1aXJlZFBhdGhzKCkgd2FzIGNhbGxlZCBvbiBlaXRoZXIgc2NoZW1hXG4gIH1cblxuICAvLyBtZXJnZXMgYmFzZSBzY2hlbWEgaW50byBuZXcgZGlzY3JpbWluYXRvciBzY2hlbWEgYW5kIHNldHMgbmV3IHR5cGUgZmllbGQuXG4gIG1lcmdlKHNjaGVtYSwgbW9kZWwuc2NoZW1hKTtcblxuICBpZiAoIW1vZGVsLmRpc2NyaW1pbmF0b3JzKSB7XG4gICAgbW9kZWwuZGlzY3JpbWluYXRvcnMgPSB7fTtcbiAgfVxuXG4gIGlmICghbW9kZWwuc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nKSB7XG4gICAgbW9kZWwuc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nID0geyBrZXk6IGtleSwgdmFsdWU6IG51bGwsIGlzUm9vdDogdHJ1ZSB9O1xuICB9XG4gIGlmICghbW9kZWwuc2NoZW1hLmRpc2NyaW1pbmF0b3JzKSB7XG4gICAgbW9kZWwuc2NoZW1hLmRpc2NyaW1pbmF0b3JzID0ge307XG4gIH1cblxuICBtb2RlbC5zY2hlbWEuZGlzY3JpbWluYXRvcnNbbmFtZV0gPSBzY2hlbWE7XG5cbiAgaWYgKG1vZGVsLmRpc2NyaW1pbmF0b3JzW25hbWVdICYmICFzY2hlbWEub3B0aW9ucy5vdmVyd3JpdGVNb2RlbHMgJiYgIW92ZXJ3cml0ZUV4aXN0aW5nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEaXNjcmltaW5hdG9yIHdpdGggbmFtZSBcIicgKyBuYW1lICsgJ1wiIGFscmVhZHkgZXhpc3RzJyk7XG4gIH1cblxuICByZXR1cm4gc2NoZW1hO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/model/discriminator.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/model/pushNestedArrayPaths.js":
/*!**********************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/model/pushNestedArrayPaths.js ***!
  \**********************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function pushNestedArrayPaths(paths, nestedArray, path) {\n  if (nestedArray == null) {\n    return;\n  }\n\n  for (let i = 0; i < nestedArray.length; ++i) {\n    if (Array.isArray(nestedArray[i])) {\n      pushNestedArrayPaths(paths, nestedArray[i], path + '.' + i);\n    } else {\n      paths.push(path + '.' + i);\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvbW9kZWwvcHVzaE5lc3RlZEFycmF5UGF0aHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvbW9kZWwvcHVzaE5lc3RlZEFycmF5UGF0aHMuanM/ZDFiMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcHVzaE5lc3RlZEFycmF5UGF0aHMocGF0aHMsIG5lc3RlZEFycmF5LCBwYXRoKSB7XG4gIGlmIChuZXN0ZWRBcnJheSA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXN0ZWRBcnJheS5sZW5ndGg7ICsraSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5lc3RlZEFycmF5W2ldKSkge1xuICAgICAgcHVzaE5lc3RlZEFycmF5UGF0aHMocGF0aHMsIG5lc3RlZEFycmF5W2ldLCBwYXRoICsgJy4nICsgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGhzLnB1c2gocGF0aCArICcuJyArIGkpO1xuICAgIH1cbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/model/pushNestedArrayPaths.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/parallelLimit.js":
/*!*********************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/parallelLimit.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = parallelLimit;\n\n/*!\n * ignore\n */\n\nfunction parallelLimit(fns, limit, callback) {\n  let numInProgress = 0;\n  let numFinished = 0;\n  let error = null;\n\n  if (limit <= 0) {\n    throw new Error('Limit must be positive');\n  }\n\n  if (fns.length === 0) {\n    return callback(null, []);\n  }\n\n  for (let i = 0; i < fns.length && i < limit; ++i) {\n    _start();\n  }\n\n  function _start() {\n    fns[numFinished + numInProgress](_done(numFinished + numInProgress));\n    ++numInProgress;\n  }\n\n  const results = [];\n\n  function _done(index) {\n    return (err, res) => {\n      --numInProgress;\n      ++numFinished;\n\n      if (error != null) {\n        return;\n      }\n      if (err != null) {\n        error = err;\n        return callback(error);\n      }\n\n      results[index] = res;\n\n      if (numFinished === fns.length) {\n        return callback(null, results);\n      } else if (numFinished + numInProgress < fns.length) {\n        _start();\n      }\n    };\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcGFyYWxsZWxMaW1pdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsNkJBQTZCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcGFyYWxsZWxMaW1pdC5qcz83YWE1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJhbGxlbExpbWl0O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIHBhcmFsbGVsTGltaXQoZm5zLCBsaW1pdCwgY2FsbGJhY2spIHtcbiAgbGV0IG51bUluUHJvZ3Jlc3MgPSAwO1xuICBsZXQgbnVtRmluaXNoZWQgPSAwO1xuICBsZXQgZXJyb3IgPSBudWxsO1xuXG4gIGlmIChsaW1pdCA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdMaW1pdCBtdXN0IGJlIHBvc2l0aXZlJyk7XG4gIH1cblxuICBpZiAoZm5zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBbXSk7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGZucy5sZW5ndGggJiYgaSA8IGxpbWl0OyArK2kpIHtcbiAgICBfc3RhcnQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9zdGFydCgpIHtcbiAgICBmbnNbbnVtRmluaXNoZWQgKyBudW1JblByb2dyZXNzXShfZG9uZShudW1GaW5pc2hlZCArIG51bUluUHJvZ3Jlc3MpKTtcbiAgICArK251bUluUHJvZ3Jlc3M7XG4gIH1cblxuICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgZnVuY3Rpb24gX2RvbmUoaW5kZXgpIHtcbiAgICByZXR1cm4gKGVyciwgcmVzKSA9PiB7XG4gICAgICAtLW51bUluUHJvZ3Jlc3M7XG4gICAgICArK251bUZpbmlzaGVkO1xuXG4gICAgICBpZiAoZXJyb3IgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdHNbaW5kZXhdID0gcmVzO1xuXG4gICAgICBpZiAobnVtRmluaXNoZWQgPT09IGZucy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3VsdHMpO1xuICAgICAgfSBlbHNlIGlmIChudW1GaW5pc2hlZCArIG51bUluUHJvZ3Jlc3MgPCBmbnMubGVuZ3RoKSB7XG4gICAgICAgIF9zdGFydCgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/parallelLimit.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/path/parentPaths.js":
/*!************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/path/parentPaths.js ***!
  \************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst dotRE = /\\./g;\nmodule.exports = function parentPaths(path) {\n  if (path.indexOf('.') === -1) {\n    return [path];\n  }\n  const pieces = path.split(dotRE);\n  const len = pieces.length;\n  const ret = new Array(len);\n  let cur = '';\n  for (let i = 0; i < len; ++i) {\n    cur += (cur.length !== 0) ? '.' + pieces[i] : pieces[i];\n    ret[i] = cur;\n  }\n\n  return ret;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcGF0aC9wYXJlbnRQYXRocy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3BhdGgvcGFyZW50UGF0aHMuanM/OWJlOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGRvdFJFID0gL1xcLi9nO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJlbnRQYXRocyhwYXRoKSB7XG4gIGlmIChwYXRoLmluZGV4T2YoJy4nKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gW3BhdGhdO1xuICB9XG4gIGNvbnN0IHBpZWNlcyA9IHBhdGguc3BsaXQoZG90UkUpO1xuICBjb25zdCBsZW4gPSBwaWVjZXMubGVuZ3RoO1xuICBjb25zdCByZXQgPSBuZXcgQXJyYXkobGVuKTtcbiAgbGV0IGN1ciA9ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgY3VyICs9IChjdXIubGVuZ3RoICE9PSAwKSA/ICcuJyArIHBpZWNlc1tpXSA6IHBpZWNlc1tpXTtcbiAgICByZXRbaV0gPSBjdXI7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/path/parentPaths.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/path/setDottedPath.js":
/*!**************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/path/setDottedPath.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst specialProperties = __webpack_require__(/*! ../specialProperties */ \"../backend/node_modules/mongoose/lib/helpers/specialProperties.js\");\n\n\nmodule.exports = function setDottedPath(obj, path, val) {\n  if (path.indexOf('.') === -1) {\n    if (specialProperties.has(path)) {\n      return;\n    }\n\n    obj[path] = val;\n    return;\n  }\n  const parts = path.split('.');\n\n  const last = parts.pop();\n  let cur = obj;\n  for (const part of parts) {\n    if (specialProperties.has(part)) {\n      continue;\n    }\n    if (cur[part] == null) {\n      cur[part] = {};\n    }\n\n    cur = cur[part];\n  }\n\n  if (!specialProperties.has(last)) {\n    cur[last] = val;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcGF0aC9zZXREb3R0ZWRQYXRoLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDBCQUEwQixtQkFBTyxDQUFDLCtGQUFzQjs7O0FBR3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wYXRoL3NldERvdHRlZFBhdGguanM/YWMyMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHNwZWNpYWxQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vc3BlY2lhbFByb3BlcnRpZXMnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNldERvdHRlZFBhdGgob2JqLCBwYXRoLCB2YWwpIHtcbiAgaWYgKHBhdGguaW5kZXhPZignLicpID09PSAtMSkge1xuICAgIGlmIChzcGVjaWFsUHJvcGVydGllcy5oYXMocGF0aCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvYmpbcGF0aF0gPSB2YWw7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdCgnLicpO1xuXG4gIGNvbnN0IGxhc3QgPSBwYXJ0cy5wb3AoKTtcbiAgbGV0IGN1ciA9IG9iajtcbiAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgaWYgKHNwZWNpYWxQcm9wZXJ0aWVzLmhhcyhwYXJ0KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjdXJbcGFydF0gPT0gbnVsbCkge1xuICAgICAgY3VyW3BhcnRdID0ge307XG4gICAgfVxuXG4gICAgY3VyID0gY3VyW3BhcnRdO1xuICB9XG5cbiAgaWYgKCFzcGVjaWFsUHJvcGVydGllcy5oYXMobGFzdCkpIHtcbiAgICBjdXJbbGFzdF0gPSB2YWw7XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/path/setDottedPath.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/pluralize.js":
/*!*****************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/pluralize.js ***!
  \*****************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("\n\nmodule.exports = pluralize;\n\n/**\n * Pluralization rules.\n */\n\nexports.pluralization = [\n  [/human$/gi, 'humans'],\n  [/(m)an$/gi, '$1en'],\n  [/(pe)rson$/gi, '$1ople'],\n  [/(child)$/gi, '$1ren'],\n  [/^(ox)$/gi, '$1en'],\n  [/(ax|test)is$/gi, '$1es'],\n  [/(octop|vir)us$/gi, '$1i'],\n  [/(alias|status)$/gi, '$1es'],\n  [/(bu)s$/gi, '$1ses'],\n  [/(buffal|tomat|potat)o$/gi, '$1oes'],\n  [/([ti])um$/gi, '$1a'],\n  [/sis$/gi, 'ses'],\n  [/(?:([^f])fe|([lr])f)$/gi, '$1$2ves'],\n  [/(hive)$/gi, '$1s'],\n  [/([^aeiouy]|qu)y$/gi, '$1ies'],\n  [/(x|ch|ss|sh)$/gi, '$1es'],\n  [/(matr|vert|ind)ix|ex$/gi, '$1ices'],\n  [/([m|l])ouse$/gi, '$1ice'],\n  [/(kn|w|l)ife$/gi, '$1ives'],\n  [/(quiz)$/gi, '$1zes'],\n  [/^goose$/i, 'geese'],\n  [/s$/gi, 's'],\n  [/([^a-z])$/, '$1'],\n  [/$/gi, 's']\n];\nconst rules = exports.pluralization;\n\n/**\n * Uncountable words.\n *\n * These words are applied while processing the argument to `toCollectionName`.\n * @api public\n */\n\nexports.uncountables = [\n  'advice',\n  'energy',\n  'excretion',\n  'digestion',\n  'cooperation',\n  'health',\n  'justice',\n  'labour',\n  'machinery',\n  'equipment',\n  'information',\n  'pollution',\n  'sewage',\n  'paper',\n  'money',\n  'species',\n  'series',\n  'rain',\n  'rice',\n  'fish',\n  'sheep',\n  'moose',\n  'deer',\n  'news',\n  'expertise',\n  'status',\n  'media'\n];\nconst uncountables = exports.uncountables;\n\n/**\n * Pluralize function.\n *\n * @author TJ Holowaychuk (extracted from _ext.js_)\n * @param {String} string to pluralize\n * @api private\n */\n\nfunction pluralize(str) {\n  let found;\n  str = str.toLowerCase();\n  if (!~uncountables.indexOf(str)) {\n    found = rules.filter(function(rule) {\n      return str.match(rule[0]);\n    });\n    if (found[0]) {\n      return str.replace(found[0][0], found[0][1]);\n    }\n  }\n  return str;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcGx1cmFsaXplLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcGx1cmFsaXplLmpzPzQ1NGIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBsdXJhbGl6ZTtcblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIHJ1bGVzLlxuICovXG5cbmV4cG9ydHMucGx1cmFsaXphdGlvbiA9IFtcbiAgWy9odW1hbiQvZ2ksICdodW1hbnMnXSxcbiAgWy8obSlhbiQvZ2ksICckMWVuJ10sXG4gIFsvKHBlKXJzb24kL2dpLCAnJDFvcGxlJ10sXG4gIFsvKGNoaWxkKSQvZ2ksICckMXJlbiddLFxuICBbL14ob3gpJC9naSwgJyQxZW4nXSxcbiAgWy8oYXh8dGVzdClpcyQvZ2ksICckMWVzJ10sXG4gIFsvKG9jdG9wfHZpcil1cyQvZ2ksICckMWknXSxcbiAgWy8oYWxpYXN8c3RhdHVzKSQvZ2ksICckMWVzJ10sXG4gIFsvKGJ1KXMkL2dpLCAnJDFzZXMnXSxcbiAgWy8oYnVmZmFsfHRvbWF0fHBvdGF0KW8kL2dpLCAnJDFvZXMnXSxcbiAgWy8oW3RpXSl1bSQvZ2ksICckMWEnXSxcbiAgWy9zaXMkL2dpLCAnc2VzJ10sXG4gIFsvKD86KFteZl0pZmV8KFtscl0pZikkL2dpLCAnJDEkMnZlcyddLFxuICBbLyhoaXZlKSQvZ2ksICckMXMnXSxcbiAgWy8oW15hZWlvdXldfHF1KXkkL2dpLCAnJDFpZXMnXSxcbiAgWy8oeHxjaHxzc3xzaCkkL2dpLCAnJDFlcyddLFxuICBbLyhtYXRyfHZlcnR8aW5kKWl4fGV4JC9naSwgJyQxaWNlcyddLFxuICBbLyhbbXxsXSlvdXNlJC9naSwgJyQxaWNlJ10sXG4gIFsvKGtufHd8bClpZmUkL2dpLCAnJDFpdmVzJ10sXG4gIFsvKHF1aXopJC9naSwgJyQxemVzJ10sXG4gIFsvXmdvb3NlJC9pLCAnZ2Vlc2UnXSxcbiAgWy9zJC9naSwgJ3MnXSxcbiAgWy8oW15hLXpdKSQvLCAnJDEnXSxcbiAgWy8kL2dpLCAncyddXG5dO1xuY29uc3QgcnVsZXMgPSBleHBvcnRzLnBsdXJhbGl6YXRpb247XG5cbi8qKlxuICogVW5jb3VudGFibGUgd29yZHMuXG4gKlxuICogVGhlc2Ugd29yZHMgYXJlIGFwcGxpZWQgd2hpbGUgcHJvY2Vzc2luZyB0aGUgYXJndW1lbnQgdG8gYHRvQ29sbGVjdGlvbk5hbWVgLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnVuY291bnRhYmxlcyA9IFtcbiAgJ2FkdmljZScsXG4gICdlbmVyZ3knLFxuICAnZXhjcmV0aW9uJyxcbiAgJ2RpZ2VzdGlvbicsXG4gICdjb29wZXJhdGlvbicsXG4gICdoZWFsdGgnLFxuICAnanVzdGljZScsXG4gICdsYWJvdXInLFxuICAnbWFjaGluZXJ5JyxcbiAgJ2VxdWlwbWVudCcsXG4gICdpbmZvcm1hdGlvbicsXG4gICdwb2xsdXRpb24nLFxuICAnc2V3YWdlJyxcbiAgJ3BhcGVyJyxcbiAgJ21vbmV5JyxcbiAgJ3NwZWNpZXMnLFxuICAnc2VyaWVzJyxcbiAgJ3JhaW4nLFxuICAncmljZScsXG4gICdmaXNoJyxcbiAgJ3NoZWVwJyxcbiAgJ21vb3NlJyxcbiAgJ2RlZXInLFxuICAnbmV3cycsXG4gICdleHBlcnRpc2UnLFxuICAnc3RhdHVzJyxcbiAgJ21lZGlhJ1xuXTtcbmNvbnN0IHVuY291bnRhYmxlcyA9IGV4cG9ydHMudW5jb3VudGFibGVzO1xuXG4vKipcbiAqIFBsdXJhbGl6ZSBmdW5jdGlvbi5cbiAqXG4gKiBAYXV0aG9yIFRKIEhvbG93YXljaHVrIChleHRyYWN0ZWQgZnJvbSBfZXh0LmpzXylcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgdG8gcGx1cmFsaXplXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWxpemUoc3RyKSB7XG4gIGxldCBmb3VuZDtcbiAgc3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghfnVuY291bnRhYmxlcy5pbmRleE9mKHN0cikpIHtcbiAgICBmb3VuZCA9IHJ1bGVzLmZpbHRlcihmdW5jdGlvbihydWxlKSB7XG4gICAgICByZXR1cm4gc3RyLm1hdGNoKHJ1bGVbMF0pO1xuICAgIH0pO1xuICAgIGlmIChmb3VuZFswXSkge1xuICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKGZvdW5kWzBdWzBdLCBmb3VuZFswXVsxXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/pluralize.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/populate/assignRawDocsToIdStructure.js":
/*!*******************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/populate/assignRawDocsToIdStructure.js ***!
  \*******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst clone = __webpack_require__(/*! ../../helpers/clone */ \"../backend/node_modules/mongoose/lib/helpers/clone.js\");\nconst leanPopulateMap = __webpack_require__(/*! ./leanPopulateMap */ \"../backend/node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js\");\nconst modelSymbol = (__webpack_require__(/*! ../symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").modelSymbol);\nconst utils = __webpack_require__(/*! ../../utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\n\nmodule.exports = assignRawDocsToIdStructure;\n\nconst kHasArray = Symbol('mongoose#assignRawDocsToIdStructure#hasArray');\n\n/**\n * Assign `vals` returned by mongo query to the `rawIds`\n * structure returned from utils.getVals() honoring\n * query sort order if specified by user.\n *\n * This can be optimized.\n *\n * Rules:\n *\n *   if the value of the path is not an array, use findOne rules, else find.\n *   for findOne the results are assigned directly to doc path (including null results).\n *   for find, if user specified sort order, results are assigned directly\n *   else documents are put back in original order of array if found in results\n *\n * @param {Array} rawIds\n * @param {Array} resultDocs\n * @param {Array} resultOrder\n * @param {Object} options\n * @param {Boolean} recursed\n * @api private\n */\n\nfunction assignRawDocsToIdStructure(rawIds, resultDocs, resultOrder, options, recursed) {\n  // honor user specified sort order, unless we're populating a single\n  // virtual underneath an array (e.g. populating `employees.mostRecentShift` where\n  // `mostRecentShift` is a virtual with `justOne`)\n  const newOrder = [];\n  const sorting = options.isVirtual && options.justOne && rawIds.length > 1\n    ? false :\n    options.sort && rawIds.length > 1;\n  const nullIfNotFound = options.$nullIfNotFound;\n  let doc;\n  let sid;\n  let id;\n\n  if (utils.isMongooseArray(rawIds)) {\n    rawIds = rawIds.__array;\n  }\n\n  let i = 0;\n  const len = rawIds.length;\n\n  if (sorting && recursed && options[kHasArray] === undefined) {\n    options[kHasArray] = false;\n    for (const key in resultOrder) {\n      if (Array.isArray(resultOrder[key])) {\n        options[kHasArray] = true;\n        break;\n      }\n    }\n  }\n\n  for (i = 0; i < len; ++i) {\n    id = rawIds[i];\n\n    if (Array.isArray(id)) {\n      // handle [ [id0, id2], [id3] ]\n      assignRawDocsToIdStructure(id, resultDocs, resultOrder, options, true);\n      newOrder.push(id);\n      continue;\n    }\n\n    if (id === null && sorting === false) {\n      // keep nulls for findOne unless sorting, which always\n      // removes them (backward compat)\n      newOrder.push(id);\n      continue;\n    }\n\n    sid = String(id);\n    doc = resultDocs[sid];\n    // If user wants separate copies of same doc, use this option\n    if (options.clone && doc != null) {\n      if (options.lean) {\n        const _model = leanPopulateMap.get(doc);\n        doc = clone(doc);\n        leanPopulateMap.set(doc, _model);\n      } else {\n        doc = doc.constructor.hydrate(doc._doc);\n      }\n    }\n\n    if (recursed) {\n      if (doc) {\n        if (sorting) {\n          const _resultOrder = resultOrder[sid];\n          if (options[kHasArray]) {\n            // If result arrays, rely on the MongoDB server response for ordering\n            newOrder.push(doc);\n          } else {\n            newOrder[_resultOrder] = doc;\n          }\n        } else {\n          newOrder.push(doc);\n        }\n      } else if (id != null && id[modelSymbol] != null) {\n        newOrder.push(id);\n      } else {\n        newOrder.push(options.retainNullValues || nullIfNotFound ? null : id);\n      }\n    } else {\n      // apply findOne behavior - if document in results, assign, else assign null\n      newOrder[i] = doc || null;\n    }\n  }\n\n  rawIds.length = 0;\n  if (newOrder.length) {\n    // reassign the documents based on corrected order\n\n    // forEach skips over sparse entries in arrays so we\n    // can safely use this to our advantage dealing with sorted\n    // result sets too.\n    newOrder.forEach(function(doc, i) {\n      rawIds[i] = doc;\n    });\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvYXNzaWduUmF3RG9jc1RvSWRTdHJ1Y3R1cmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLGtGQUFxQjtBQUMzQyx3QkFBd0IsbUJBQU8sQ0FBQyxtR0FBbUI7QUFDbkQsb0JBQW9CLDhHQUFpQztBQUNyRCxjQUFjLG1CQUFPLENBQUMsa0VBQWE7O0FBRW5DOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLFNBQVM7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvYXNzaWduUmF3RG9jc1RvSWRTdHJ1Y3R1cmUuanM/OGU4YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGNsb25lID0gcmVxdWlyZSgnLi4vLi4vaGVscGVycy9jbG9uZScpO1xuY29uc3QgbGVhblBvcHVsYXRlTWFwID0gcmVxdWlyZSgnLi9sZWFuUG9wdWxhdGVNYXAnKTtcbmNvbnN0IG1vZGVsU3ltYm9sID0gcmVxdWlyZSgnLi4vc3ltYm9scycpLm1vZGVsU3ltYm9sO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnblJhd0RvY3NUb0lkU3RydWN0dXJlO1xuXG5jb25zdCBrSGFzQXJyYXkgPSBTeW1ib2woJ21vbmdvb3NlI2Fzc2lnblJhd0RvY3NUb0lkU3RydWN0dXJlI2hhc0FycmF5Jyk7XG5cbi8qKlxuICogQXNzaWduIGB2YWxzYCByZXR1cm5lZCBieSBtb25nbyBxdWVyeSB0byB0aGUgYHJhd0lkc2BcbiAqIHN0cnVjdHVyZSByZXR1cm5lZCBmcm9tIHV0aWxzLmdldFZhbHMoKSBob25vcmluZ1xuICogcXVlcnkgc29ydCBvcmRlciBpZiBzcGVjaWZpZWQgYnkgdXNlci5cbiAqXG4gKiBUaGlzIGNhbiBiZSBvcHRpbWl6ZWQuXG4gKlxuICogUnVsZXM6XG4gKlxuICogICBpZiB0aGUgdmFsdWUgb2YgdGhlIHBhdGggaXMgbm90IGFuIGFycmF5LCB1c2UgZmluZE9uZSBydWxlcywgZWxzZSBmaW5kLlxuICogICBmb3IgZmluZE9uZSB0aGUgcmVzdWx0cyBhcmUgYXNzaWduZWQgZGlyZWN0bHkgdG8gZG9jIHBhdGggKGluY2x1ZGluZyBudWxsIHJlc3VsdHMpLlxuICogICBmb3IgZmluZCwgaWYgdXNlciBzcGVjaWZpZWQgc29ydCBvcmRlciwgcmVzdWx0cyBhcmUgYXNzaWduZWQgZGlyZWN0bHlcbiAqICAgZWxzZSBkb2N1bWVudHMgYXJlIHB1dCBiYWNrIGluIG9yaWdpbmFsIG9yZGVyIG9mIGFycmF5IGlmIGZvdW5kIGluIHJlc3VsdHNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSByYXdJZHNcbiAqIEBwYXJhbSB7QXJyYXl9IHJlc3VsdERvY3NcbiAqIEBwYXJhbSB7QXJyYXl9IHJlc3VsdE9yZGVyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufSByZWN1cnNlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gYXNzaWduUmF3RG9jc1RvSWRTdHJ1Y3R1cmUocmF3SWRzLCByZXN1bHREb2NzLCByZXN1bHRPcmRlciwgb3B0aW9ucywgcmVjdXJzZWQpIHtcbiAgLy8gaG9ub3IgdXNlciBzcGVjaWZpZWQgc29ydCBvcmRlciwgdW5sZXNzIHdlJ3JlIHBvcHVsYXRpbmcgYSBzaW5nbGVcbiAgLy8gdmlydHVhbCB1bmRlcm5lYXRoIGFuIGFycmF5IChlLmcuIHBvcHVsYXRpbmcgYGVtcGxveWVlcy5tb3N0UmVjZW50U2hpZnRgIHdoZXJlXG4gIC8vIGBtb3N0UmVjZW50U2hpZnRgIGlzIGEgdmlydHVhbCB3aXRoIGBqdXN0T25lYClcbiAgY29uc3QgbmV3T3JkZXIgPSBbXTtcbiAgY29uc3Qgc29ydGluZyA9IG9wdGlvbnMuaXNWaXJ0dWFsICYmIG9wdGlvbnMuanVzdE9uZSAmJiByYXdJZHMubGVuZ3RoID4gMVxuICAgID8gZmFsc2UgOlxuICAgIG9wdGlvbnMuc29ydCAmJiByYXdJZHMubGVuZ3RoID4gMTtcbiAgY29uc3QgbnVsbElmTm90Rm91bmQgPSBvcHRpb25zLiRudWxsSWZOb3RGb3VuZDtcbiAgbGV0IGRvYztcbiAgbGV0IHNpZDtcbiAgbGV0IGlkO1xuXG4gIGlmICh1dGlscy5pc01vbmdvb3NlQXJyYXkocmF3SWRzKSkge1xuICAgIHJhd0lkcyA9IHJhd0lkcy5fX2FycmF5O1xuICB9XG5cbiAgbGV0IGkgPSAwO1xuICBjb25zdCBsZW4gPSByYXdJZHMubGVuZ3RoO1xuXG4gIGlmIChzb3J0aW5nICYmIHJlY3Vyc2VkICYmIG9wdGlvbnNba0hhc0FycmF5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgb3B0aW9uc1trSGFzQXJyYXldID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmVzdWx0T3JkZXIpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdE9yZGVyW2tleV0pKSB7XG4gICAgICAgIG9wdGlvbnNba0hhc0FycmF5XSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlkID0gcmF3SWRzW2ldO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaWQpKSB7XG4gICAgICAvLyBoYW5kbGUgWyBbaWQwLCBpZDJdLCBbaWQzXSBdXG4gICAgICBhc3NpZ25SYXdEb2NzVG9JZFN0cnVjdHVyZShpZCwgcmVzdWx0RG9jcywgcmVzdWx0T3JkZXIsIG9wdGlvbnMsIHRydWUpO1xuICAgICAgbmV3T3JkZXIucHVzaChpZCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoaWQgPT09IG51bGwgJiYgc29ydGluZyA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIGtlZXAgbnVsbHMgZm9yIGZpbmRPbmUgdW5sZXNzIHNvcnRpbmcsIHdoaWNoIGFsd2F5c1xuICAgICAgLy8gcmVtb3ZlcyB0aGVtIChiYWNrd2FyZCBjb21wYXQpXG4gICAgICBuZXdPcmRlci5wdXNoKGlkKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHNpZCA9IFN0cmluZyhpZCk7XG4gICAgZG9jID0gcmVzdWx0RG9jc1tzaWRdO1xuICAgIC8vIElmIHVzZXIgd2FudHMgc2VwYXJhdGUgY29waWVzIG9mIHNhbWUgZG9jLCB1c2UgdGhpcyBvcHRpb25cbiAgICBpZiAob3B0aW9ucy5jbG9uZSAmJiBkb2MgIT0gbnVsbCkge1xuICAgICAgaWYgKG9wdGlvbnMubGVhbikge1xuICAgICAgICBjb25zdCBfbW9kZWwgPSBsZWFuUG9wdWxhdGVNYXAuZ2V0KGRvYyk7XG4gICAgICAgIGRvYyA9IGNsb25lKGRvYyk7XG4gICAgICAgIGxlYW5Qb3B1bGF0ZU1hcC5zZXQoZG9jLCBfbW9kZWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9jID0gZG9jLmNvbnN0cnVjdG9yLmh5ZHJhdGUoZG9jLl9kb2MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZWN1cnNlZCkge1xuICAgICAgaWYgKGRvYykge1xuICAgICAgICBpZiAoc29ydGluZykge1xuICAgICAgICAgIGNvbnN0IF9yZXN1bHRPcmRlciA9IHJlc3VsdE9yZGVyW3NpZF07XG4gICAgICAgICAgaWYgKG9wdGlvbnNba0hhc0FycmF5XSkge1xuICAgICAgICAgICAgLy8gSWYgcmVzdWx0IGFycmF5cywgcmVseSBvbiB0aGUgTW9uZ29EQiBzZXJ2ZXIgcmVzcG9uc2UgZm9yIG9yZGVyaW5nXG4gICAgICAgICAgICBuZXdPcmRlci5wdXNoKGRvYyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld09yZGVyW19yZXN1bHRPcmRlcl0gPSBkb2M7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld09yZGVyLnB1c2goZG9jKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpZCAhPSBudWxsICYmIGlkW21vZGVsU3ltYm9sXSAhPSBudWxsKSB7XG4gICAgICAgIG5ld09yZGVyLnB1c2goaWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3T3JkZXIucHVzaChvcHRpb25zLnJldGFpbk51bGxWYWx1ZXMgfHwgbnVsbElmTm90Rm91bmQgPyBudWxsIDogaWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhcHBseSBmaW5kT25lIGJlaGF2aW9yIC0gaWYgZG9jdW1lbnQgaW4gcmVzdWx0cywgYXNzaWduLCBlbHNlIGFzc2lnbiBudWxsXG4gICAgICBuZXdPcmRlcltpXSA9IGRvYyB8fCBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJhd0lkcy5sZW5ndGggPSAwO1xuICBpZiAobmV3T3JkZXIubGVuZ3RoKSB7XG4gICAgLy8gcmVhc3NpZ24gdGhlIGRvY3VtZW50cyBiYXNlZCBvbiBjb3JyZWN0ZWQgb3JkZXJcblxuICAgIC8vIGZvckVhY2ggc2tpcHMgb3ZlciBzcGFyc2UgZW50cmllcyBpbiBhcnJheXMgc28gd2VcbiAgICAvLyBjYW4gc2FmZWx5IHVzZSB0aGlzIHRvIG91ciBhZHZhbnRhZ2UgZGVhbGluZyB3aXRoIHNvcnRlZFxuICAgIC8vIHJlc3VsdCBzZXRzIHRvby5cbiAgICBuZXdPcmRlci5mb3JFYWNoKGZ1bmN0aW9uKGRvYywgaSkge1xuICAgICAgcmF3SWRzW2ldID0gZG9jO1xuICAgIH0pO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/populate/assignRawDocsToIdStructure.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/populate/assignVals.js":
/*!***************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/populate/assignVals.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst MongooseMap = __webpack_require__(/*! ../../types/map */ \"../backend/node_modules/mongoose/lib/types/map.js\");\nconst SkipPopulateValue = __webpack_require__(/*! ./skipPopulateValue */ \"../backend/node_modules/mongoose/lib/helpers/populate/skipPopulateValue.js\");\nconst assignRawDocsToIdStructure = __webpack_require__(/*! ./assignRawDocsToIdStructure */ \"../backend/node_modules/mongoose/lib/helpers/populate/assignRawDocsToIdStructure.js\");\nconst get = __webpack_require__(/*! ../get */ \"../backend/node_modules/mongoose/lib/helpers/get.js\");\nconst getVirtual = __webpack_require__(/*! ./getVirtual */ \"../backend/node_modules/mongoose/lib/helpers/populate/getVirtual.js\");\nconst leanPopulateMap = __webpack_require__(/*! ./leanPopulateMap */ \"../backend/node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js\");\nconst lookupLocalFields = __webpack_require__(/*! ./lookupLocalFields */ \"../backend/node_modules/mongoose/lib/helpers/populate/lookupLocalFields.js\");\nconst markArraySubdocsPopulated = __webpack_require__(/*! ./markArraySubdocsPopulated */ \"../backend/node_modules/mongoose/lib/helpers/populate/markArraySubdocsPopulated.js\");\nconst mpath = __webpack_require__(/*! mpath */ \"../backend/node_modules/mpath/index.js\");\nconst sift = (__webpack_require__(/*! sift */ \"../backend/node_modules/sift/index.js\")[\"default\"]);\nconst utils = __webpack_require__(/*! ../../utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\nconst { populateModelSymbol } = __webpack_require__(/*! ../symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\");\n\nmodule.exports = function assignVals(o) {\n  // Options that aren't explicitly listed in `populateOptions`\n  const userOptions = Object.assign({}, get(o, 'allOptions.options.options'), get(o, 'allOptions.options'));\n  // `o.options` contains options explicitly listed in `populateOptions`, like\n  // `match` and `limit`.\n  const populateOptions = Object.assign({}, o.options, userOptions, {\n    justOne: o.justOne,\n    isVirtual: o.isVirtual\n  });\n  populateOptions.$nullIfNotFound = o.isVirtual;\n  const populatedModel = o.populatedModel;\n\n  const originalIds = [].concat(o.rawIds);\n\n  // replace the original ids in our intermediate _ids structure\n  // with the documents found by query\n  o.allIds = [].concat(o.allIds);\n  assignRawDocsToIdStructure(o.rawIds, o.rawDocs, o.rawOrder, populateOptions);\n\n  // now update the original documents being populated using the\n  // result structure that contains real documents.\n  const docs = o.docs;\n  const rawIds = o.rawIds;\n  const options = o.options;\n  const count = o.count && o.isVirtual;\n  let i;\n  let setValueIndex = 0;\n\n  function setValue(val) {\n    ++setValueIndex;\n    if (count) {\n      return val;\n    }\n    if (val instanceof SkipPopulateValue) {\n      return val.val;\n    }\n    if (val === void 0) {\n      return val;\n    }\n\n    const _allIds = o.allIds[i];\n\n    if (o.path.endsWith('.$*')) {\n      // Skip maps re: gh-12494\n      return valueFilter(val, options, populateOptions, _allIds);\n    }\n\n    if (o.justOne === true && Array.isArray(val)) {\n      // Might be an embedded discriminator (re: gh-9244) with multiple models, so make sure to pick the right\n      // model before assigning.\n      const ret = [];\n      for (const doc of val) {\n        const _docPopulatedModel = leanPopulateMap.get(doc);\n        if (_docPopulatedModel == null || _docPopulatedModel === populatedModel) {\n          ret.push(doc);\n        }\n      }\n      // Since we don't want to have to create a new mongoosearray, make sure to\n      // modify the array in place\n      while (val.length > ret.length) {\n        Array.prototype.pop.apply(val, []);\n      }\n      for (let i = 0; i < ret.length; ++i) {\n        val[i] = ret[i];\n      }\n\n      return valueFilter(val[0], options, populateOptions, _allIds);\n    } else if (o.justOne === false && !Array.isArray(val)) {\n      return valueFilter([val], options, populateOptions, _allIds);\n    } else if (o.justOne === true && !Array.isArray(val) && Array.isArray(_allIds)) {\n      return valueFilter(val, options, populateOptions, val == null ? val : _allIds[setValueIndex - 1]);\n    }\n    return valueFilter(val, options, populateOptions, _allIds);\n  }\n\n  for (i = 0; i < docs.length; ++i) {\n    setValueIndex = 0;\n    const _path = o.path.endsWith('.$*') ? o.path.slice(0, -3) : o.path;\n    const existingVal = mpath.get(_path, docs[i], lookupLocalFields);\n    if (existingVal == null && !getVirtual(o.originalModel.schema, _path)) {\n      continue;\n    }\n\n    let valueToSet;\n    if (count) {\n      valueToSet = numDocs(rawIds[i]);\n    } else if (Array.isArray(o.match)) {\n      valueToSet = Array.isArray(rawIds[i]) ?\n        rawIds[i].filter(v => v == null || sift(o.match[i])(v)) :\n        [rawIds[i]].filter(v => v == null || sift(o.match[i])(v))[0];\n    } else {\n      valueToSet = rawIds[i];\n    }\n\n    // If we're populating a map, the existing value will be an object, so\n    // we need to transform again\n    const originalSchema = o.originalModel.schema;\n    const isDoc = get(docs[i], '$__', null) != null;\n    let isMap = isDoc ?\n      existingVal instanceof Map :\n      utils.isPOJO(existingVal);\n    // If we pass the first check, also make sure the local field's schematype\n    // is map (re: gh-6460)\n    isMap = isMap && get(originalSchema._getSchema(_path), '$isSchemaMap');\n    if (!o.isVirtual && isMap) {\n      const _keys = existingVal instanceof Map ?\n        Array.from(existingVal.keys()) :\n        Object.keys(existingVal);\n      valueToSet = valueToSet.reduce((cur, v, i) => {\n        cur.set(_keys[i], v);\n        return cur;\n      }, new Map());\n    }\n\n    if (isDoc && Array.isArray(valueToSet)) {\n      for (const val of valueToSet) {\n        if (val != null && val.$__ != null) {\n          val.$__.parent = docs[i];\n        }\n      }\n    } else if (isDoc && valueToSet != null && valueToSet.$__ != null) {\n      valueToSet.$__.parent = docs[i];\n    }\n\n    if (o.isVirtual && isDoc) {\n      docs[i].$populated(_path, o.justOne ? originalIds[0] : originalIds, o.allOptions);\n      // If virtual populate and doc is already init-ed, need to walk through\n      // the actual doc to set rather than setting `_doc` directly\n      if (Array.isArray(valueToSet)) {\n        valueToSet = valueToSet.map(v => v == null ? void 0 : v);\n      }\n      mpath.set(_path, valueToSet, docs[i], void 0, setValue, false);\n      continue;\n    }\n\n    const parts = _path.split('.');\n    let cur = docs[i];\n    for (let j = 0; j < parts.length - 1; ++j) {\n      // If we get to an array with a dotted path, like `arr.foo`, don't set\n      // `foo` on the array.\n      if (Array.isArray(cur) && !utils.isArrayIndex(parts[j])) {\n        break;\n      }\n\n      if (parts[j] === '$*') {\n        break;\n      }\n\n      if (cur[parts[j]] == null) {\n        // If nothing to set, avoid creating an unnecessary array. Otherwise\n        // we'll end up with a single doc in the array with only defaults.\n        // See gh-8342, gh-8455\n        const curPath = parts.slice(0, j + 1).join('.');\n        const schematype = originalSchema._getSchema(curPath);\n        if (valueToSet == null && schematype != null && schematype.$isMongooseArray) {\n          break;\n        }\n        cur[parts[j]] = {};\n      }\n      cur = cur[parts[j]];\n      // If the property in MongoDB is a primitive, we won't be able to populate\n      // the nested path, so skip it. See gh-7545\n      if (typeof cur !== 'object') {\n        break;\n      }\n    }\n    if (docs[i].$__) {\n      o.allOptions.options[populateModelSymbol] = o.allOptions.model;\n      docs[i].$populated(_path, o.unpopulatedValues[i], o.allOptions.options);\n\n      if (valueToSet != null && valueToSet.$__ != null) {\n        valueToSet.$__.wasPopulated = { value: o.unpopulatedValues[i] };\n      }\n\n      if (valueToSet instanceof Map && !valueToSet.$isMongooseMap) {\n        valueToSet = new MongooseMap(valueToSet, _path, docs[i], docs[i].schema.path(_path).$__schemaType);\n      }\n    }\n\n    // If lean, need to check that each individual virtual respects\n    // `justOne`, because you may have a populated virtual with `justOne`\n    // underneath an array. See gh-6867\n    mpath.set(_path, valueToSet, docs[i], lookupLocalFields, setValue, false);\n\n    if (docs[i].$__) {\n      markArraySubdocsPopulated(docs[i], [o.allOptions.options]);\n    }\n  }\n};\n\nfunction numDocs(v) {\n  if (Array.isArray(v)) {\n    // If setting underneath an array of populated subdocs, we may have an\n    // array of arrays. See gh-7573\n    if (v.some(el => Array.isArray(el) || el === null)) {\n      return v.map(el => {\n        if (el == null) {\n          return 0;\n        }\n        if (Array.isArray(el)) {\n          return el.filter(el => el != null).length;\n        }\n        return 1;\n      });\n    }\n    return v.filter(el => el != null).length;\n  }\n  return v == null ? 0 : 1;\n}\n\n/**\n * 1) Apply backwards compatible find/findOne behavior to sub documents\n *\n *    find logic:\n *      a) filter out non-documents\n *      b) remove _id from sub docs when user specified\n *\n *    findOne\n *      a) if no doc found, set to null\n *      b) remove _id from sub docs when user specified\n *\n * 2) Remove _ids when specified by users query.\n *\n * background:\n * _ids are left in the query even when user excludes them so\n * that population mapping can occur.\n * @param {Any} val\n * @param {Object} assignmentOpts\n * @param {Object} populateOptions\n * @param {Function} [populateOptions.transform]\n * @param {Boolean} allIds\n * @api private\n */\n\nfunction valueFilter(val, assignmentOpts, populateOptions, allIds) {\n  const userSpecifiedTransform = typeof populateOptions.transform === 'function';\n  const transform = userSpecifiedTransform ? populateOptions.transform : noop;\n  if (Array.isArray(val)) {\n    // find logic\n    const ret = [];\n    const numValues = val.length;\n    for (let i = 0; i < numValues; ++i) {\n      let subdoc = val[i];\n      const _allIds = Array.isArray(allIds) ? allIds[i] : allIds;\n      if (!isPopulatedObject(subdoc) && (!populateOptions.retainNullValues || subdoc != null) && !userSpecifiedTransform) {\n        continue;\n      } else if (!populateOptions.retainNullValues && subdoc == null) {\n        continue;\n      } else if (userSpecifiedTransform) {\n        subdoc = transform(isPopulatedObject(subdoc) ? subdoc : null, _allIds);\n      }\n      maybeRemoveId(subdoc, assignmentOpts);\n      ret.push(subdoc);\n      if (assignmentOpts.originalLimit &&\n          ret.length >= assignmentOpts.originalLimit) {\n        break;\n      }\n    }\n\n    const rLen = ret.length;\n    // Since we don't want to have to create a new mongoosearray, make sure to\n    // modify the array in place\n    while (val.length > rLen) {\n      Array.prototype.pop.apply(val, []);\n    }\n    let i = 0;\n    if (utils.isMongooseArray(val)) {\n      for (i = 0; i < rLen; ++i) {\n        val.set(i, ret[i], true);\n      }\n    } else {\n      for (i = 0; i < rLen; ++i) {\n        val[i] = ret[i];\n      }\n    }\n    return val;\n  }\n\n  // findOne\n  if (isPopulatedObject(val) || utils.isPOJO(val)) {\n    maybeRemoveId(val, assignmentOpts);\n    return transform(val, allIds);\n  }\n  if (val instanceof Map) {\n    return val;\n  }\n\n  if (populateOptions.justOne === false) {\n    return [];\n  }\n\n  return val == null ? transform(val, allIds) : transform(null, allIds);\n}\n\n/**\n * Remove _id from `subdoc` if user specified \"lean\" query option\n * @param {Document} subdoc\n * @param {Object} assignmentOpts\n * @api private\n */\n\nfunction maybeRemoveId(subdoc, assignmentOpts) {\n  if (subdoc != null && assignmentOpts.excludeId) {\n    if (typeof subdoc.$__setValue === 'function') {\n      delete subdoc._doc._id;\n    } else {\n      delete subdoc._id;\n    }\n  }\n}\n\n/**\n * Determine if `obj` is something we can set a populated path to. Can be a\n * document, a lean document, or an array/map that contains docs.\n * @param {Any} obj\n * @api private\n */\n\nfunction isPopulatedObject(obj) {\n  if (obj == null) {\n    return false;\n  }\n\n  return Array.isArray(obj) ||\n    obj.$isMongooseMap ||\n    obj.$__ != null ||\n    leanPopulateMap.has(obj);\n}\n\nfunction noop(v) {\n  return v;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvYXNzaWduVmFscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixvQkFBb0IsbUJBQU8sQ0FBQywwRUFBaUI7QUFDN0MsMEJBQTBCLG1CQUFPLENBQUMsdUdBQXFCO0FBQ3ZELG1DQUFtQyxtQkFBTyxDQUFDLHlIQUE4QjtBQUN6RSxZQUFZLG1CQUFPLENBQUMsbUVBQVE7QUFDNUIsbUJBQW1CLG1CQUFPLENBQUMseUZBQWM7QUFDekMsd0JBQXdCLG1CQUFPLENBQUMsbUdBQW1CO0FBQ25ELDBCQUEwQixtQkFBTyxDQUFDLHVHQUFxQjtBQUN2RCxrQ0FBa0MsbUJBQU8sQ0FBQyx1SEFBNkI7QUFDdkUsY0FBYyxtQkFBTyxDQUFDLHFEQUFPO0FBQzdCLGFBQWEscUZBQXVCO0FBQ3BDLGNBQWMsbUJBQU8sQ0FBQyxrRUFBYTtBQUNuQyxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMsMkVBQVk7O0FBRXBEO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixXQUFXLFNBQVM7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUI7QUFDQTtBQUNBLE1BQU07QUFDTixrQkFBa0IsVUFBVTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3BvcHVsYXRlL2Fzc2lnblZhbHMuanM/MmU2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1vbmdvb3NlTWFwID0gcmVxdWlyZSgnLi4vLi4vdHlwZXMvbWFwJyk7XG5jb25zdCBTa2lwUG9wdWxhdGVWYWx1ZSA9IHJlcXVpcmUoJy4vc2tpcFBvcHVsYXRlVmFsdWUnKTtcbmNvbnN0IGFzc2lnblJhd0RvY3NUb0lkU3RydWN0dXJlID0gcmVxdWlyZSgnLi9hc3NpZ25SYXdEb2NzVG9JZFN0cnVjdHVyZScpO1xuY29uc3QgZ2V0ID0gcmVxdWlyZSgnLi4vZ2V0Jyk7XG5jb25zdCBnZXRWaXJ0dWFsID0gcmVxdWlyZSgnLi9nZXRWaXJ0dWFsJyk7XG5jb25zdCBsZWFuUG9wdWxhdGVNYXAgPSByZXF1aXJlKCcuL2xlYW5Qb3B1bGF0ZU1hcCcpO1xuY29uc3QgbG9va3VwTG9jYWxGaWVsZHMgPSByZXF1aXJlKCcuL2xvb2t1cExvY2FsRmllbGRzJyk7XG5jb25zdCBtYXJrQXJyYXlTdWJkb2NzUG9wdWxhdGVkID0gcmVxdWlyZSgnLi9tYXJrQXJyYXlTdWJkb2NzUG9wdWxhdGVkJyk7XG5jb25zdCBtcGF0aCA9IHJlcXVpcmUoJ21wYXRoJyk7XG5jb25zdCBzaWZ0ID0gcmVxdWlyZSgnc2lmdCcpLmRlZmF1bHQ7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IHBvcHVsYXRlTW9kZWxTeW1ib2wgfSA9IHJlcXVpcmUoJy4uL3N5bWJvbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhc3NpZ25WYWxzKG8pIHtcbiAgLy8gT3B0aW9ucyB0aGF0IGFyZW4ndCBleHBsaWNpdGx5IGxpc3RlZCBpbiBgcG9wdWxhdGVPcHRpb25zYFxuICBjb25zdCB1c2VyT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGdldChvLCAnYWxsT3B0aW9ucy5vcHRpb25zLm9wdGlvbnMnKSwgZ2V0KG8sICdhbGxPcHRpb25zLm9wdGlvbnMnKSk7XG4gIC8vIGBvLm9wdGlvbnNgIGNvbnRhaW5zIG9wdGlvbnMgZXhwbGljaXRseSBsaXN0ZWQgaW4gYHBvcHVsYXRlT3B0aW9uc2AsIGxpa2VcbiAgLy8gYG1hdGNoYCBhbmQgYGxpbWl0YC5cbiAgY29uc3QgcG9wdWxhdGVPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgby5vcHRpb25zLCB1c2VyT3B0aW9ucywge1xuICAgIGp1c3RPbmU6IG8uanVzdE9uZSxcbiAgICBpc1ZpcnR1YWw6IG8uaXNWaXJ0dWFsXG4gIH0pO1xuICBwb3B1bGF0ZU9wdGlvbnMuJG51bGxJZk5vdEZvdW5kID0gby5pc1ZpcnR1YWw7XG4gIGNvbnN0IHBvcHVsYXRlZE1vZGVsID0gby5wb3B1bGF0ZWRNb2RlbDtcblxuICBjb25zdCBvcmlnaW5hbElkcyA9IFtdLmNvbmNhdChvLnJhd0lkcyk7XG5cbiAgLy8gcmVwbGFjZSB0aGUgb3JpZ2luYWwgaWRzIGluIG91ciBpbnRlcm1lZGlhdGUgX2lkcyBzdHJ1Y3R1cmVcbiAgLy8gd2l0aCB0aGUgZG9jdW1lbnRzIGZvdW5kIGJ5IHF1ZXJ5XG4gIG8uYWxsSWRzID0gW10uY29uY2F0KG8uYWxsSWRzKTtcbiAgYXNzaWduUmF3RG9jc1RvSWRTdHJ1Y3R1cmUoby5yYXdJZHMsIG8ucmF3RG9jcywgby5yYXdPcmRlciwgcG9wdWxhdGVPcHRpb25zKTtcblxuICAvLyBub3cgdXBkYXRlIHRoZSBvcmlnaW5hbCBkb2N1bWVudHMgYmVpbmcgcG9wdWxhdGVkIHVzaW5nIHRoZVxuICAvLyByZXN1bHQgc3RydWN0dXJlIHRoYXQgY29udGFpbnMgcmVhbCBkb2N1bWVudHMuXG4gIGNvbnN0IGRvY3MgPSBvLmRvY3M7XG4gIGNvbnN0IHJhd0lkcyA9IG8ucmF3SWRzO1xuICBjb25zdCBvcHRpb25zID0gby5vcHRpb25zO1xuICBjb25zdCBjb3VudCA9IG8uY291bnQgJiYgby5pc1ZpcnR1YWw7XG4gIGxldCBpO1xuICBsZXQgc2V0VmFsdWVJbmRleCA9IDA7XG5cbiAgZnVuY3Rpb24gc2V0VmFsdWUodmFsKSB7XG4gICAgKytzZXRWYWx1ZUluZGV4O1xuICAgIGlmIChjb3VudCkge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIFNraXBQb3B1bGF0ZVZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsLnZhbDtcbiAgICB9XG4gICAgaWYgKHZhbCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cblxuICAgIGNvbnN0IF9hbGxJZHMgPSBvLmFsbElkc1tpXTtcblxuICAgIGlmIChvLnBhdGguZW5kc1dpdGgoJy4kKicpKSB7XG4gICAgICAvLyBTa2lwIG1hcHMgcmU6IGdoLTEyNDk0XG4gICAgICByZXR1cm4gdmFsdWVGaWx0ZXIodmFsLCBvcHRpb25zLCBwb3B1bGF0ZU9wdGlvbnMsIF9hbGxJZHMpO1xuICAgIH1cblxuICAgIGlmIChvLmp1c3RPbmUgPT09IHRydWUgJiYgQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAvLyBNaWdodCBiZSBhbiBlbWJlZGRlZCBkaXNjcmltaW5hdG9yIChyZTogZ2gtOTI0NCkgd2l0aCBtdWx0aXBsZSBtb2RlbHMsIHNvIG1ha2Ugc3VyZSB0byBwaWNrIHRoZSByaWdodFxuICAgICAgLy8gbW9kZWwgYmVmb3JlIGFzc2lnbmluZy5cbiAgICAgIGNvbnN0IHJldCA9IFtdO1xuICAgICAgZm9yIChjb25zdCBkb2Mgb2YgdmFsKSB7XG4gICAgICAgIGNvbnN0IF9kb2NQb3B1bGF0ZWRNb2RlbCA9IGxlYW5Qb3B1bGF0ZU1hcC5nZXQoZG9jKTtcbiAgICAgICAgaWYgKF9kb2NQb3B1bGF0ZWRNb2RlbCA9PSBudWxsIHx8IF9kb2NQb3B1bGF0ZWRNb2RlbCA9PT0gcG9wdWxhdGVkTW9kZWwpIHtcbiAgICAgICAgICByZXQucHVzaChkb2MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBTaW5jZSB3ZSBkb24ndCB3YW50IHRvIGhhdmUgdG8gY3JlYXRlIGEgbmV3IG1vbmdvb3NlYXJyYXksIG1ha2Ugc3VyZSB0b1xuICAgICAgLy8gbW9kaWZ5IHRoZSBhcnJheSBpbiBwbGFjZVxuICAgICAgd2hpbGUgKHZhbC5sZW5ndGggPiByZXQubGVuZ3RoKSB7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wb3AuYXBwbHkodmFsLCBbXSk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YWxbaV0gPSByZXRbaV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWx1ZUZpbHRlcih2YWxbMF0sIG9wdGlvbnMsIHBvcHVsYXRlT3B0aW9ucywgX2FsbElkcyk7XG4gICAgfSBlbHNlIGlmIChvLmp1c3RPbmUgPT09IGZhbHNlICYmICFBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIHJldHVybiB2YWx1ZUZpbHRlcihbdmFsXSwgb3B0aW9ucywgcG9wdWxhdGVPcHRpb25zLCBfYWxsSWRzKTtcbiAgICB9IGVsc2UgaWYgKG8uanVzdE9uZSA9PT0gdHJ1ZSAmJiAhQXJyYXkuaXNBcnJheSh2YWwpICYmIEFycmF5LmlzQXJyYXkoX2FsbElkcykpIHtcbiAgICAgIHJldHVybiB2YWx1ZUZpbHRlcih2YWwsIG9wdGlvbnMsIHBvcHVsYXRlT3B0aW9ucywgdmFsID09IG51bGwgPyB2YWwgOiBfYWxsSWRzW3NldFZhbHVlSW5kZXggLSAxXSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZUZpbHRlcih2YWwsIG9wdGlvbnMsIHBvcHVsYXRlT3B0aW9ucywgX2FsbElkcyk7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZG9jcy5sZW5ndGg7ICsraSkge1xuICAgIHNldFZhbHVlSW5kZXggPSAwO1xuICAgIGNvbnN0IF9wYXRoID0gby5wYXRoLmVuZHNXaXRoKCcuJConKSA/IG8ucGF0aC5zbGljZSgwLCAtMykgOiBvLnBhdGg7XG4gICAgY29uc3QgZXhpc3RpbmdWYWwgPSBtcGF0aC5nZXQoX3BhdGgsIGRvY3NbaV0sIGxvb2t1cExvY2FsRmllbGRzKTtcbiAgICBpZiAoZXhpc3RpbmdWYWwgPT0gbnVsbCAmJiAhZ2V0VmlydHVhbChvLm9yaWdpbmFsTW9kZWwuc2NoZW1hLCBfcGF0aCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGxldCB2YWx1ZVRvU2V0O1xuICAgIGlmIChjb3VudCkge1xuICAgICAgdmFsdWVUb1NldCA9IG51bURvY3MocmF3SWRzW2ldKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoby5tYXRjaCkpIHtcbiAgICAgIHZhbHVlVG9TZXQgPSBBcnJheS5pc0FycmF5KHJhd0lkc1tpXSkgP1xuICAgICAgICByYXdJZHNbaV0uZmlsdGVyKHYgPT4gdiA9PSBudWxsIHx8IHNpZnQoby5tYXRjaFtpXSkodikpIDpcbiAgICAgICAgW3Jhd0lkc1tpXV0uZmlsdGVyKHYgPT4gdiA9PSBudWxsIHx8IHNpZnQoby5tYXRjaFtpXSkodikpWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZVRvU2V0ID0gcmF3SWRzW2ldO1xuICAgIH1cblxuICAgIC8vIElmIHdlJ3JlIHBvcHVsYXRpbmcgYSBtYXAsIHRoZSBleGlzdGluZyB2YWx1ZSB3aWxsIGJlIGFuIG9iamVjdCwgc29cbiAgICAvLyB3ZSBuZWVkIHRvIHRyYW5zZm9ybSBhZ2FpblxuICAgIGNvbnN0IG9yaWdpbmFsU2NoZW1hID0gby5vcmlnaW5hbE1vZGVsLnNjaGVtYTtcbiAgICBjb25zdCBpc0RvYyA9IGdldChkb2NzW2ldLCAnJF9fJywgbnVsbCkgIT0gbnVsbDtcbiAgICBsZXQgaXNNYXAgPSBpc0RvYyA/XG4gICAgICBleGlzdGluZ1ZhbCBpbnN0YW5jZW9mIE1hcCA6XG4gICAgICB1dGlscy5pc1BPSk8oZXhpc3RpbmdWYWwpO1xuICAgIC8vIElmIHdlIHBhc3MgdGhlIGZpcnN0IGNoZWNrLCBhbHNvIG1ha2Ugc3VyZSB0aGUgbG9jYWwgZmllbGQncyBzY2hlbWF0eXBlXG4gICAgLy8gaXMgbWFwIChyZTogZ2gtNjQ2MClcbiAgICBpc01hcCA9IGlzTWFwICYmIGdldChvcmlnaW5hbFNjaGVtYS5fZ2V0U2NoZW1hKF9wYXRoKSwgJyRpc1NjaGVtYU1hcCcpO1xuICAgIGlmICghby5pc1ZpcnR1YWwgJiYgaXNNYXApIHtcbiAgICAgIGNvbnN0IF9rZXlzID0gZXhpc3RpbmdWYWwgaW5zdGFuY2VvZiBNYXAgP1xuICAgICAgICBBcnJheS5mcm9tKGV4aXN0aW5nVmFsLmtleXMoKSkgOlxuICAgICAgICBPYmplY3Qua2V5cyhleGlzdGluZ1ZhbCk7XG4gICAgICB2YWx1ZVRvU2V0ID0gdmFsdWVUb1NldC5yZWR1Y2UoKGN1ciwgdiwgaSkgPT4ge1xuICAgICAgICBjdXIuc2V0KF9rZXlzW2ldLCB2KTtcbiAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgIH0sIG5ldyBNYXAoKSk7XG4gICAgfVxuXG4gICAgaWYgKGlzRG9jICYmIEFycmF5LmlzQXJyYXkodmFsdWVUb1NldCkpIHtcbiAgICAgIGZvciAoY29uc3QgdmFsIG9mIHZhbHVlVG9TZXQpIHtcbiAgICAgICAgaWYgKHZhbCAhPSBudWxsICYmIHZhbC4kX18gIT0gbnVsbCkge1xuICAgICAgICAgIHZhbC4kX18ucGFyZW50ID0gZG9jc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNEb2MgJiYgdmFsdWVUb1NldCAhPSBudWxsICYmIHZhbHVlVG9TZXQuJF9fICE9IG51bGwpIHtcbiAgICAgIHZhbHVlVG9TZXQuJF9fLnBhcmVudCA9IGRvY3NbaV07XG4gICAgfVxuXG4gICAgaWYgKG8uaXNWaXJ0dWFsICYmIGlzRG9jKSB7XG4gICAgICBkb2NzW2ldLiRwb3B1bGF0ZWQoX3BhdGgsIG8uanVzdE9uZSA/IG9yaWdpbmFsSWRzWzBdIDogb3JpZ2luYWxJZHMsIG8uYWxsT3B0aW9ucyk7XG4gICAgICAvLyBJZiB2aXJ0dWFsIHBvcHVsYXRlIGFuZCBkb2MgaXMgYWxyZWFkeSBpbml0LWVkLCBuZWVkIHRvIHdhbGsgdGhyb3VnaFxuICAgICAgLy8gdGhlIGFjdHVhbCBkb2MgdG8gc2V0IHJhdGhlciB0aGFuIHNldHRpbmcgYF9kb2NgIGRpcmVjdGx5XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZVRvU2V0KSkge1xuICAgICAgICB2YWx1ZVRvU2V0ID0gdmFsdWVUb1NldC5tYXAodiA9PiB2ID09IG51bGwgPyB2b2lkIDAgOiB2KTtcbiAgICAgIH1cbiAgICAgIG1wYXRoLnNldChfcGF0aCwgdmFsdWVUb1NldCwgZG9jc1tpXSwgdm9pZCAwLCBzZXRWYWx1ZSwgZmFsc2UpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgcGFydHMgPSBfcGF0aC5zcGxpdCgnLicpO1xuICAgIGxldCBjdXIgPSBkb2NzW2ldO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcGFydHMubGVuZ3RoIC0gMTsgKytqKSB7XG4gICAgICAvLyBJZiB3ZSBnZXQgdG8gYW4gYXJyYXkgd2l0aCBhIGRvdHRlZCBwYXRoLCBsaWtlIGBhcnIuZm9vYCwgZG9uJ3Qgc2V0XG4gICAgICAvLyBgZm9vYCBvbiB0aGUgYXJyYXkuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXIpICYmICF1dGlscy5pc0FycmF5SW5kZXgocGFydHNbal0pKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFydHNbal0gPT09ICckKicpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJbcGFydHNbal1dID09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgbm90aGluZyB0byBzZXQsIGF2b2lkIGNyZWF0aW5nIGFuIHVubmVjZXNzYXJ5IGFycmF5LiBPdGhlcndpc2VcbiAgICAgICAgLy8gd2UnbGwgZW5kIHVwIHdpdGggYSBzaW5nbGUgZG9jIGluIHRoZSBhcnJheSB3aXRoIG9ubHkgZGVmYXVsdHMuXG4gICAgICAgIC8vIFNlZSBnaC04MzQyLCBnaC04NDU1XG4gICAgICAgIGNvbnN0IGN1clBhdGggPSBwYXJ0cy5zbGljZSgwLCBqICsgMSkuam9pbignLicpO1xuICAgICAgICBjb25zdCBzY2hlbWF0eXBlID0gb3JpZ2luYWxTY2hlbWEuX2dldFNjaGVtYShjdXJQYXRoKTtcbiAgICAgICAgaWYgKHZhbHVlVG9TZXQgPT0gbnVsbCAmJiBzY2hlbWF0eXBlICE9IG51bGwgJiYgc2NoZW1hdHlwZS4kaXNNb25nb29zZUFycmF5KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY3VyW3BhcnRzW2pdXSA9IHt9O1xuICAgICAgfVxuICAgICAgY3VyID0gY3VyW3BhcnRzW2pdXTtcbiAgICAgIC8vIElmIHRoZSBwcm9wZXJ0eSBpbiBNb25nb0RCIGlzIGEgcHJpbWl0aXZlLCB3ZSB3b24ndCBiZSBhYmxlIHRvIHBvcHVsYXRlXG4gICAgICAvLyB0aGUgbmVzdGVkIHBhdGgsIHNvIHNraXAgaXQuIFNlZSBnaC03NTQ1XG4gICAgICBpZiAodHlwZW9mIGN1ciAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkb2NzW2ldLiRfXykge1xuICAgICAgby5hbGxPcHRpb25zLm9wdGlvbnNbcG9wdWxhdGVNb2RlbFN5bWJvbF0gPSBvLmFsbE9wdGlvbnMubW9kZWw7XG4gICAgICBkb2NzW2ldLiRwb3B1bGF0ZWQoX3BhdGgsIG8udW5wb3B1bGF0ZWRWYWx1ZXNbaV0sIG8uYWxsT3B0aW9ucy5vcHRpb25zKTtcblxuICAgICAgaWYgKHZhbHVlVG9TZXQgIT0gbnVsbCAmJiB2YWx1ZVRvU2V0LiRfXyAhPSBudWxsKSB7XG4gICAgICAgIHZhbHVlVG9TZXQuJF9fLndhc1BvcHVsYXRlZCA9IHsgdmFsdWU6IG8udW5wb3B1bGF0ZWRWYWx1ZXNbaV0gfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlVG9TZXQgaW5zdGFuY2VvZiBNYXAgJiYgIXZhbHVlVG9TZXQuJGlzTW9uZ29vc2VNYXApIHtcbiAgICAgICAgdmFsdWVUb1NldCA9IG5ldyBNb25nb29zZU1hcCh2YWx1ZVRvU2V0LCBfcGF0aCwgZG9jc1tpXSwgZG9jc1tpXS5zY2hlbWEucGF0aChfcGF0aCkuJF9fc2NoZW1hVHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbGVhbiwgbmVlZCB0byBjaGVjayB0aGF0IGVhY2ggaW5kaXZpZHVhbCB2aXJ0dWFsIHJlc3BlY3RzXG4gICAgLy8gYGp1c3RPbmVgLCBiZWNhdXNlIHlvdSBtYXkgaGF2ZSBhIHBvcHVsYXRlZCB2aXJ0dWFsIHdpdGggYGp1c3RPbmVgXG4gICAgLy8gdW5kZXJuZWF0aCBhbiBhcnJheS4gU2VlIGdoLTY4NjdcbiAgICBtcGF0aC5zZXQoX3BhdGgsIHZhbHVlVG9TZXQsIGRvY3NbaV0sIGxvb2t1cExvY2FsRmllbGRzLCBzZXRWYWx1ZSwgZmFsc2UpO1xuXG4gICAgaWYgKGRvY3NbaV0uJF9fKSB7XG4gICAgICBtYXJrQXJyYXlTdWJkb2NzUG9wdWxhdGVkKGRvY3NbaV0sIFtvLmFsbE9wdGlvbnMub3B0aW9uc10pO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gbnVtRG9jcyh2KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgLy8gSWYgc2V0dGluZyB1bmRlcm5lYXRoIGFuIGFycmF5IG9mIHBvcHVsYXRlZCBzdWJkb2NzLCB3ZSBtYXkgaGF2ZSBhblxuICAgIC8vIGFycmF5IG9mIGFycmF5cy4gU2VlIGdoLTc1NzNcbiAgICBpZiAodi5zb21lKGVsID0+IEFycmF5LmlzQXJyYXkoZWwpIHx8IGVsID09PSBudWxsKSkge1xuICAgICAgcmV0dXJuIHYubWFwKGVsID0+IHtcbiAgICAgICAgaWYgKGVsID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShlbCkpIHtcbiAgICAgICAgICByZXR1cm4gZWwuZmlsdGVyKGVsID0+IGVsICE9IG51bGwpLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdi5maWx0ZXIoZWwgPT4gZWwgIT0gbnVsbCkubGVuZ3RoO1xuICB9XG4gIHJldHVybiB2ID09IG51bGwgPyAwIDogMTtcbn1cblxuLyoqXG4gKiAxKSBBcHBseSBiYWNrd2FyZHMgY29tcGF0aWJsZSBmaW5kL2ZpbmRPbmUgYmVoYXZpb3IgdG8gc3ViIGRvY3VtZW50c1xuICpcbiAqICAgIGZpbmQgbG9naWM6XG4gKiAgICAgIGEpIGZpbHRlciBvdXQgbm9uLWRvY3VtZW50c1xuICogICAgICBiKSByZW1vdmUgX2lkIGZyb20gc3ViIGRvY3Mgd2hlbiB1c2VyIHNwZWNpZmllZFxuICpcbiAqICAgIGZpbmRPbmVcbiAqICAgICAgYSkgaWYgbm8gZG9jIGZvdW5kLCBzZXQgdG8gbnVsbFxuICogICAgICBiKSByZW1vdmUgX2lkIGZyb20gc3ViIGRvY3Mgd2hlbiB1c2VyIHNwZWNpZmllZFxuICpcbiAqIDIpIFJlbW92ZSBfaWRzIHdoZW4gc3BlY2lmaWVkIGJ5IHVzZXJzIHF1ZXJ5LlxuICpcbiAqIGJhY2tncm91bmQ6XG4gKiBfaWRzIGFyZSBsZWZ0IGluIHRoZSBxdWVyeSBldmVuIHdoZW4gdXNlciBleGNsdWRlcyB0aGVtIHNvXG4gKiB0aGF0IHBvcHVsYXRpb24gbWFwcGluZyBjYW4gb2NjdXIuXG4gKiBAcGFyYW0ge0FueX0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gYXNzaWdubWVudE9wdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb3B1bGF0ZU9wdGlvbnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwb3B1bGF0ZU9wdGlvbnMudHJhbnNmb3JtXVxuICogQHBhcmFtIHtCb29sZWFufSBhbGxJZHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHZhbHVlRmlsdGVyKHZhbCwgYXNzaWdubWVudE9wdHMsIHBvcHVsYXRlT3B0aW9ucywgYWxsSWRzKSB7XG4gIGNvbnN0IHVzZXJTcGVjaWZpZWRUcmFuc2Zvcm0gPSB0eXBlb2YgcG9wdWxhdGVPcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJztcbiAgY29uc3QgdHJhbnNmb3JtID0gdXNlclNwZWNpZmllZFRyYW5zZm9ybSA/IHBvcHVsYXRlT3B0aW9ucy50cmFuc2Zvcm0gOiBub29wO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgLy8gZmluZCBsb2dpY1xuICAgIGNvbnN0IHJldCA9IFtdO1xuICAgIGNvbnN0IG51bVZhbHVlcyA9IHZhbC5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1WYWx1ZXM7ICsraSkge1xuICAgICAgbGV0IHN1YmRvYyA9IHZhbFtpXTtcbiAgICAgIGNvbnN0IF9hbGxJZHMgPSBBcnJheS5pc0FycmF5KGFsbElkcykgPyBhbGxJZHNbaV0gOiBhbGxJZHM7XG4gICAgICBpZiAoIWlzUG9wdWxhdGVkT2JqZWN0KHN1YmRvYykgJiYgKCFwb3B1bGF0ZU9wdGlvbnMucmV0YWluTnVsbFZhbHVlcyB8fCBzdWJkb2MgIT0gbnVsbCkgJiYgIXVzZXJTcGVjaWZpZWRUcmFuc2Zvcm0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKCFwb3B1bGF0ZU9wdGlvbnMucmV0YWluTnVsbFZhbHVlcyAmJiBzdWJkb2MgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAodXNlclNwZWNpZmllZFRyYW5zZm9ybSkge1xuICAgICAgICBzdWJkb2MgPSB0cmFuc2Zvcm0oaXNQb3B1bGF0ZWRPYmplY3Qoc3ViZG9jKSA/IHN1YmRvYyA6IG51bGwsIF9hbGxJZHMpO1xuICAgICAgfVxuICAgICAgbWF5YmVSZW1vdmVJZChzdWJkb2MsIGFzc2lnbm1lbnRPcHRzKTtcbiAgICAgIHJldC5wdXNoKHN1YmRvYyk7XG4gICAgICBpZiAoYXNzaWdubWVudE9wdHMub3JpZ2luYWxMaW1pdCAmJlxuICAgICAgICAgIHJldC5sZW5ndGggPj0gYXNzaWdubWVudE9wdHMub3JpZ2luYWxMaW1pdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByTGVuID0gcmV0Lmxlbmd0aDtcbiAgICAvLyBTaW5jZSB3ZSBkb24ndCB3YW50IHRvIGhhdmUgdG8gY3JlYXRlIGEgbmV3IG1vbmdvb3NlYXJyYXksIG1ha2Ugc3VyZSB0b1xuICAgIC8vIG1vZGlmeSB0aGUgYXJyYXkgaW4gcGxhY2VcbiAgICB3aGlsZSAodmFsLmxlbmd0aCA+IHJMZW4pIHtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wb3AuYXBwbHkodmFsLCBbXSk7XG4gICAgfVxuICAgIGxldCBpID0gMDtcbiAgICBpZiAodXRpbHMuaXNNb25nb29zZUFycmF5KHZhbCkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCByTGVuOyArK2kpIHtcbiAgICAgICAgdmFsLnNldChpLCByZXRbaV0sIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgckxlbjsgKytpKSB7XG4gICAgICAgIHZhbFtpXSA9IHJldFtpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIC8vIGZpbmRPbmVcbiAgaWYgKGlzUG9wdWxhdGVkT2JqZWN0KHZhbCkgfHwgdXRpbHMuaXNQT0pPKHZhbCkpIHtcbiAgICBtYXliZVJlbW92ZUlkKHZhbCwgYXNzaWdubWVudE9wdHMpO1xuICAgIHJldHVybiB0cmFuc2Zvcm0odmFsLCBhbGxJZHMpO1xuICB9XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBNYXApIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgaWYgKHBvcHVsYXRlT3B0aW9ucy5qdXN0T25lID09PSBmYWxzZSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHJldHVybiB2YWwgPT0gbnVsbCA/IHRyYW5zZm9ybSh2YWwsIGFsbElkcykgOiB0cmFuc2Zvcm0obnVsbCwgYWxsSWRzKTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgX2lkIGZyb20gYHN1YmRvY2AgaWYgdXNlciBzcGVjaWZpZWQgXCJsZWFuXCIgcXVlcnkgb3B0aW9uXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBzdWJkb2NcbiAqIEBwYXJhbSB7T2JqZWN0fSBhc3NpZ25tZW50T3B0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWF5YmVSZW1vdmVJZChzdWJkb2MsIGFzc2lnbm1lbnRPcHRzKSB7XG4gIGlmIChzdWJkb2MgIT0gbnVsbCAmJiBhc3NpZ25tZW50T3B0cy5leGNsdWRlSWQpIHtcbiAgICBpZiAodHlwZW9mIHN1YmRvYy4kX19zZXRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZGVsZXRlIHN1YmRvYy5fZG9jLl9pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHN1YmRvYy5faWQ7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGBvYmpgIGlzIHNvbWV0aGluZyB3ZSBjYW4gc2V0IGEgcG9wdWxhdGVkIHBhdGggdG8uIENhbiBiZSBhXG4gKiBkb2N1bWVudCwgYSBsZWFuIGRvY3VtZW50LCBvciBhbiBhcnJheS9tYXAgdGhhdCBjb250YWlucyBkb2NzLlxuICogQHBhcmFtIHtBbnl9IG9ialxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNQb3B1bGF0ZWRPYmplY3Qob2JqKSB7XG4gIGlmIChvYmogPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBBcnJheS5pc0FycmF5KG9iaikgfHxcbiAgICBvYmouJGlzTW9uZ29vc2VNYXAgfHxcbiAgICBvYmouJF9fICE9IG51bGwgfHxcbiAgICBsZWFuUG9wdWxhdGVNYXAuaGFzKG9iaik7XG59XG5cbmZ1bmN0aW9uIG5vb3Aodikge1xuICByZXR1cm4gdjtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/populate/assignVals.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/populate/createPopulateQueryFilter.js":
/*!******************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/populate/createPopulateQueryFilter.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SkipPopulateValue = __webpack_require__(/*! ./skipPopulateValue */ \"../backend/node_modules/mongoose/lib/helpers/populate/skipPopulateValue.js\");\nconst parentPaths = __webpack_require__(/*! ../path/parentPaths */ \"../backend/node_modules/mongoose/lib/helpers/path/parentPaths.js\");\nconst { trusted } = __webpack_require__(/*! ../query/trusted */ \"../backend/node_modules/mongoose/lib/helpers/query/trusted.js\");\nconst hasDollarKeys = __webpack_require__(/*! ../query/hasDollarKeys */ \"../backend/node_modules/mongoose/lib/helpers/query/hasDollarKeys.js\");\n\nmodule.exports = function createPopulateQueryFilter(ids, _match, _foreignField, model, skipInvalidIds) {\n  const match = _formatMatch(_match);\n\n  if (_foreignField.size === 1) {\n    const foreignField = Array.from(_foreignField)[0];\n    const foreignSchemaType = model.schema.path(foreignField);\n    if (foreignField !== '_id' || !match['_id']) {\n      ids = _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds);\n      match[foreignField] = trusted({ $in: ids });\n    } else if (foreignField === '_id' && match['_id']) {\n      const userSpecifiedMatch = hasDollarKeys(match[foreignField]) ?\n        match[foreignField] :\n        { $eq: match[foreignField] };\n      match[foreignField] = { ...trusted({ $in: ids }), ...userSpecifiedMatch };\n    }\n\n    const _parentPaths = parentPaths(foreignField);\n    for (let i = 0; i < _parentPaths.length - 1; ++i) {\n      const cur = _parentPaths[i];\n      if (match[cur] != null && match[cur].$elemMatch != null) {\n        match[cur].$elemMatch[foreignField.slice(cur.length + 1)] = trusted({ $in: ids });\n        delete match[foreignField];\n        break;\n      }\n    }\n  } else {\n    const $or = [];\n    if (Array.isArray(match.$or)) {\n      match.$and = [{ $or: match.$or }, { $or: $or }];\n      delete match.$or;\n    } else {\n      match.$or = $or;\n    }\n    for (const foreignField of _foreignField) {\n      if (foreignField !== '_id' || !match['_id']) {\n        const foreignSchemaType = model.schema.path(foreignField);\n        ids = _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds);\n        $or.push({ [foreignField]: { $in: ids } });\n      } else if (foreignField === '_id' && match['_id']) {\n        const userSpecifiedMatch = hasDollarKeys(match[foreignField]) ?\n          match[foreignField] :\n          { $eq: match[foreignField] };\n        match[foreignField] = { ...trusted({ $in: ids }), ...userSpecifiedMatch };\n      }\n    }\n  }\n\n  return match;\n};\n\n/**\n * Optionally filter out invalid ids that don't conform to foreign field's schema\n * to avoid cast errors (gh-7706)\n * @param {Array} ids\n * @param {SchemaType} foreignSchemaType\n * @param {Boolean} [skipInvalidIds]\n * @api private\n */\n\nfunction _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds) {\n  ids = ids.filter(v => !(v instanceof SkipPopulateValue));\n  if (!skipInvalidIds) {\n    return ids;\n  }\n  return ids.filter(id => {\n    try {\n      foreignSchemaType.cast(id);\n      return true;\n    } catch (err) {\n      return false;\n    }\n  });\n}\n\n/**\n * Format `mod.match` given that it may be an array that we need to $or if\n * the client has multiple docs with match functions\n * @param {Array|Any} match\n * @api private\n */\n\nfunction _formatMatch(match) {\n  if (Array.isArray(match)) {\n    if (match.length > 1) {\n      return { $or: [].concat(match.map(m => Object.assign({}, m))) };\n    }\n    return Object.assign({}, match[0]);\n  }\n  return Object.assign({}, match);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvY3JlYXRlUG9wdWxhdGVRdWVyeUZpbHRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiwwQkFBMEIsbUJBQU8sQ0FBQyx1R0FBcUI7QUFDdkQsb0JBQW9CLG1CQUFPLENBQUMsNkZBQXFCO0FBQ2pELFFBQVEsVUFBVSxFQUFFLG1CQUFPLENBQUMsdUZBQWtCO0FBQzlDLHNCQUFzQixtQkFBTyxDQUFDLG1HQUF3Qjs7QUFFdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFVBQVU7QUFDaEQsTUFBTTtBQUNOO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsOEJBQThCLGFBQWEsVUFBVTtBQUNyRDs7QUFFQTtBQUNBLG9CQUFvQiw2QkFBNkI7QUFDakQ7QUFDQTtBQUNBLDhFQUE4RSxVQUFVO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCLElBQUksVUFBVTtBQUNwRDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCLFlBQVk7QUFDakQsUUFBUTtBQUNSO0FBQ0E7QUFDQSxZQUFZO0FBQ1osZ0NBQWdDLGFBQWEsVUFBVTtBQUN2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOENBQThDO0FBQzdEO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EseUJBQXlCO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvY3JlYXRlUG9wdWxhdGVRdWVyeUZpbHRlci5qcz9jNWRkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgU2tpcFBvcHVsYXRlVmFsdWUgPSByZXF1aXJlKCcuL3NraXBQb3B1bGF0ZVZhbHVlJyk7XG5jb25zdCBwYXJlbnRQYXRocyA9IHJlcXVpcmUoJy4uL3BhdGgvcGFyZW50UGF0aHMnKTtcbmNvbnN0IHsgdHJ1c3RlZCB9ID0gcmVxdWlyZSgnLi4vcXVlcnkvdHJ1c3RlZCcpO1xuY29uc3QgaGFzRG9sbGFyS2V5cyA9IHJlcXVpcmUoJy4uL3F1ZXJ5L2hhc0RvbGxhcktleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVQb3B1bGF0ZVF1ZXJ5RmlsdGVyKGlkcywgX21hdGNoLCBfZm9yZWlnbkZpZWxkLCBtb2RlbCwgc2tpcEludmFsaWRJZHMpIHtcbiAgY29uc3QgbWF0Y2ggPSBfZm9ybWF0TWF0Y2goX21hdGNoKTtcblxuICBpZiAoX2ZvcmVpZ25GaWVsZC5zaXplID09PSAxKSB7XG4gICAgY29uc3QgZm9yZWlnbkZpZWxkID0gQXJyYXkuZnJvbShfZm9yZWlnbkZpZWxkKVswXTtcbiAgICBjb25zdCBmb3JlaWduU2NoZW1hVHlwZSA9IG1vZGVsLnNjaGVtYS5wYXRoKGZvcmVpZ25GaWVsZCk7XG4gICAgaWYgKGZvcmVpZ25GaWVsZCAhPT0gJ19pZCcgfHwgIW1hdGNoWydfaWQnXSkge1xuICAgICAgaWRzID0gX2ZpbHRlckludmFsaWRJZHMoaWRzLCBmb3JlaWduU2NoZW1hVHlwZSwgc2tpcEludmFsaWRJZHMpO1xuICAgICAgbWF0Y2hbZm9yZWlnbkZpZWxkXSA9IHRydXN0ZWQoeyAkaW46IGlkcyB9KTtcbiAgICB9IGVsc2UgaWYgKGZvcmVpZ25GaWVsZCA9PT0gJ19pZCcgJiYgbWF0Y2hbJ19pZCddKSB7XG4gICAgICBjb25zdCB1c2VyU3BlY2lmaWVkTWF0Y2ggPSBoYXNEb2xsYXJLZXlzKG1hdGNoW2ZvcmVpZ25GaWVsZF0pID9cbiAgICAgICAgbWF0Y2hbZm9yZWlnbkZpZWxkXSA6XG4gICAgICAgIHsgJGVxOiBtYXRjaFtmb3JlaWduRmllbGRdIH07XG4gICAgICBtYXRjaFtmb3JlaWduRmllbGRdID0geyAuLi50cnVzdGVkKHsgJGluOiBpZHMgfSksIC4uLnVzZXJTcGVjaWZpZWRNYXRjaCB9O1xuICAgIH1cblxuICAgIGNvbnN0IF9wYXJlbnRQYXRocyA9IHBhcmVudFBhdGhzKGZvcmVpZ25GaWVsZCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBfcGFyZW50UGF0aHMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICBjb25zdCBjdXIgPSBfcGFyZW50UGF0aHNbaV07XG4gICAgICBpZiAobWF0Y2hbY3VyXSAhPSBudWxsICYmIG1hdGNoW2N1cl0uJGVsZW1NYXRjaCAhPSBudWxsKSB7XG4gICAgICAgIG1hdGNoW2N1cl0uJGVsZW1NYXRjaFtmb3JlaWduRmllbGQuc2xpY2UoY3VyLmxlbmd0aCArIDEpXSA9IHRydXN0ZWQoeyAkaW46IGlkcyB9KTtcbiAgICAgICAgZGVsZXRlIG1hdGNoW2ZvcmVpZ25GaWVsZF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCAkb3IgPSBbXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtYXRjaC4kb3IpKSB7XG4gICAgICBtYXRjaC4kYW5kID0gW3sgJG9yOiBtYXRjaC4kb3IgfSwgeyAkb3I6ICRvciB9XTtcbiAgICAgIGRlbGV0ZSBtYXRjaC4kb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hdGNoLiRvciA9ICRvcjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBmb3JlaWduRmllbGQgb2YgX2ZvcmVpZ25GaWVsZCkge1xuICAgICAgaWYgKGZvcmVpZ25GaWVsZCAhPT0gJ19pZCcgfHwgIW1hdGNoWydfaWQnXSkge1xuICAgICAgICBjb25zdCBmb3JlaWduU2NoZW1hVHlwZSA9IG1vZGVsLnNjaGVtYS5wYXRoKGZvcmVpZ25GaWVsZCk7XG4gICAgICAgIGlkcyA9IF9maWx0ZXJJbnZhbGlkSWRzKGlkcywgZm9yZWlnblNjaGVtYVR5cGUsIHNraXBJbnZhbGlkSWRzKTtcbiAgICAgICAgJG9yLnB1c2goeyBbZm9yZWlnbkZpZWxkXTogeyAkaW46IGlkcyB9IH0pO1xuICAgICAgfSBlbHNlIGlmIChmb3JlaWduRmllbGQgPT09ICdfaWQnICYmIG1hdGNoWydfaWQnXSkge1xuICAgICAgICBjb25zdCB1c2VyU3BlY2lmaWVkTWF0Y2ggPSBoYXNEb2xsYXJLZXlzKG1hdGNoW2ZvcmVpZ25GaWVsZF0pID9cbiAgICAgICAgICBtYXRjaFtmb3JlaWduRmllbGRdIDpcbiAgICAgICAgICB7ICRlcTogbWF0Y2hbZm9yZWlnbkZpZWxkXSB9O1xuICAgICAgICBtYXRjaFtmb3JlaWduRmllbGRdID0geyAuLi50cnVzdGVkKHsgJGluOiBpZHMgfSksIC4uLnVzZXJTcGVjaWZpZWRNYXRjaCB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXRjaDtcbn07XG5cbi8qKlxuICogT3B0aW9uYWxseSBmaWx0ZXIgb3V0IGludmFsaWQgaWRzIHRoYXQgZG9uJ3QgY29uZm9ybSB0byBmb3JlaWduIGZpZWxkJ3Mgc2NoZW1hXG4gKiB0byBhdm9pZCBjYXN0IGVycm9ycyAoZ2gtNzcwNilcbiAqIEBwYXJhbSB7QXJyYXl9IGlkc1xuICogQHBhcmFtIHtTY2hlbWFUeXBlfSBmb3JlaWduU2NoZW1hVHlwZVxuICogQHBhcmFtIHtCb29sZWFufSBbc2tpcEludmFsaWRJZHNdXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBfZmlsdGVySW52YWxpZElkcyhpZHMsIGZvcmVpZ25TY2hlbWFUeXBlLCBza2lwSW52YWxpZElkcykge1xuICBpZHMgPSBpZHMuZmlsdGVyKHYgPT4gISh2IGluc3RhbmNlb2YgU2tpcFBvcHVsYXRlVmFsdWUpKTtcbiAgaWYgKCFza2lwSW52YWxpZElkcykge1xuICAgIHJldHVybiBpZHM7XG4gIH1cbiAgcmV0dXJuIGlkcy5maWx0ZXIoaWQgPT4ge1xuICAgIHRyeSB7XG4gICAgICBmb3JlaWduU2NoZW1hVHlwZS5jYXN0KGlkKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogRm9ybWF0IGBtb2QubWF0Y2hgIGdpdmVuIHRoYXQgaXQgbWF5IGJlIGFuIGFycmF5IHRoYXQgd2UgbmVlZCB0byAkb3IgaWZcbiAqIHRoZSBjbGllbnQgaGFzIG11bHRpcGxlIGRvY3Mgd2l0aCBtYXRjaCBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7QXJyYXl8QW55fSBtYXRjaFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gX2Zvcm1hdE1hdGNoKG1hdGNoKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG1hdGNoKSkge1xuICAgIGlmIChtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4geyAkb3I6IFtdLmNvbmNhdChtYXRjaC5tYXAobSA9PiBPYmplY3QuYXNzaWduKHt9LCBtKSkpIH07XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBtYXRjaFswXSk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG1hdGNoKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/populate/createPopulateQueryFilter.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js":
/*!****************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst MongooseError = __webpack_require__(/*! ../../error/index */ \"../backend/node_modules/mongoose/lib/error/index.js\");\nconst SkipPopulateValue = __webpack_require__(/*! ./skipPopulateValue */ \"../backend/node_modules/mongoose/lib/helpers/populate/skipPopulateValue.js\");\nconst clone = __webpack_require__(/*! ../clone */ \"../backend/node_modules/mongoose/lib/helpers/clone.js\");\nconst get = __webpack_require__(/*! ../get */ \"../backend/node_modules/mongoose/lib/helpers/get.js\");\nconst getDiscriminatorByValue = __webpack_require__(/*! ../discriminator/getDiscriminatorByValue */ \"../backend/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\nconst getConstructorName = __webpack_require__(/*! ../getConstructorName */ \"../backend/node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst getSchemaTypes = __webpack_require__(/*! ./getSchemaTypes */ \"../backend/node_modules/mongoose/lib/helpers/populate/getSchemaTypes.js\");\nconst getVirtual = __webpack_require__(/*! ./getVirtual */ \"../backend/node_modules/mongoose/lib/helpers/populate/getVirtual.js\");\nconst lookupLocalFields = __webpack_require__(/*! ./lookupLocalFields */ \"../backend/node_modules/mongoose/lib/helpers/populate/lookupLocalFields.js\");\nconst mpath = __webpack_require__(/*! mpath */ \"../backend/node_modules/mpath/index.js\");\nconst modelNamesFromRefPath = __webpack_require__(/*! ./modelNamesFromRefPath */ \"../backend/node_modules/mongoose/lib/helpers/populate/modelNamesFromRefPath.js\");\nconst utils = __webpack_require__(/*! ../../utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\n\nconst modelSymbol = (__webpack_require__(/*! ../symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").modelSymbol);\nconst populateModelSymbol = (__webpack_require__(/*! ../symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").populateModelSymbol);\nconst schemaMixedSymbol = (__webpack_require__(/*! ../../schema/symbols */ \"../backend/node_modules/mongoose/lib/schema/symbols.js\").schemaMixedSymbol);\nconst StrictPopulate = __webpack_require__(/*! ../../error/strictPopulate */ \"../backend/node_modules/mongoose/lib/error/strictPopulate.js\");\n\nmodule.exports = function getModelsMapForPopulate(model, docs, options) {\n  let doc;\n  const len = docs.length;\n  const map = [];\n  const modelNameFromQuery = options.model && options.model.modelName || options.model;\n  let schema;\n  let refPath;\n  let modelNames;\n  const available = {};\n\n  const modelSchema = model.schema;\n\n  // Populating a nested path should always be a no-op re: #9073.\n  // People shouldn't do this, but apparently they do.\n  if (options._localModel != null && options._localModel.schema.nested[options.path]) {\n    return [];\n  }\n\n  const _virtualRes = getVirtual(model.schema, options.path);\n  const virtual = _virtualRes == null ? null : _virtualRes.virtual;\n  if (virtual != null) {\n    return _virtualPopulate(model, docs, options, _virtualRes);\n  }\n\n  let allSchemaTypes = getSchemaTypes(model, modelSchema, null, options.path);\n  allSchemaTypes = Array.isArray(allSchemaTypes) ? allSchemaTypes : [allSchemaTypes].filter(v => v != null);\n\n  const isStrictPopulateDisabled = options.strictPopulate === false || options.options?.strictPopulate === false;\n  if (!isStrictPopulateDisabled && allSchemaTypes.length === 0 && options._localModel != null) {\n    return new StrictPopulate(options._fullPath || options.path);\n  }\n\n  for (let i = 0; i < len; i++) {\n    doc = docs[i];\n    let justOne = null;\n\n    const docSchema = doc != null && doc.$__ != null ? doc.$__schema : modelSchema;\n    schema = getSchemaTypes(model, docSchema, doc, options.path);\n\n    // Special case: populating a path that's a DocumentArray unless\n    // there's an explicit `ref` or `refPath` re: gh-8946\n    if (schema != null &&\n        schema.$isMongooseDocumentArray &&\n        schema.options.ref == null &&\n        schema.options.refPath == null) {\n      continue;\n    }\n    const isUnderneathDocArray = schema && schema.$parentSchemaDocArray;\n    if (isUnderneathDocArray && get(options, 'options.sort') != null) {\n      return new MongooseError('Cannot populate with `sort` on path ' + options.path +\n        ' because it is a subproperty of a document array');\n    }\n\n    modelNames = null;\n    let isRefPath = false;\n    let normalizedRefPath = null;\n    let schemaOptions = null;\n    let modelNamesInOrder = null;\n\n    if (schema != null && schema.instance === 'Embedded') {\n      if (schema.options.ref) {\n        const data = {\n          localField: options.path + '._id',\n          foreignField: '_id',\n          justOne: true\n        };\n        const res = _getModelNames(doc, schema, modelNameFromQuery, model);\n\n        const unpopulatedValue = mpath.get(options.path, doc);\n        const id = mpath.get('_id', unpopulatedValue);\n        addModelNamesToMap(model, map, available, res.modelNames, options, data, id, doc, schemaOptions, unpopulatedValue);\n      }\n      // No-op if no `ref` set. See gh-11538\n      continue;\n    }\n\n    if (Array.isArray(schema)) {\n      const schemasArray = schema;\n      for (const _schema of schemasArray) {\n        let _modelNames;\n        let res;\n        try {\n          res = _getModelNames(doc, _schema, modelNameFromQuery, model);\n          _modelNames = res.modelNames;\n          isRefPath = isRefPath || res.isRefPath;\n          normalizedRefPath = normalizedRefPath || res.refPath;\n          justOne = res.justOne;\n        } catch (error) {\n          return error;\n        }\n\n        if (isRefPath && !res.isRefPath) {\n          continue;\n        }\n        if (!_modelNames) {\n          continue;\n        }\n        modelNames = modelNames || [];\n        for (const modelName of _modelNames) {\n          if (modelNames.indexOf(modelName) === -1) {\n            modelNames.push(modelName);\n          }\n        }\n      }\n    } else {\n      try {\n        const res = _getModelNames(doc, schema, modelNameFromQuery, model);\n        modelNames = res.modelNames;\n        isRefPath = res.isRefPath;\n        normalizedRefPath = normalizedRefPath || res.refPath;\n        justOne = res.justOne;\n        schemaOptions = get(schema, 'options.populate', null);\n        // Dedupe, because `refPath` can return duplicates of the same model name,\n        // and that causes perf issues.\n        if (isRefPath) {\n          modelNamesInOrder = modelNames;\n          modelNames = Array.from(new Set(modelNames));\n        }\n      } catch (error) {\n        return error;\n      }\n\n      if (!modelNames) {\n        continue;\n      }\n    }\n\n    const data = {};\n    const localField = options.path;\n    const foreignField = '_id';\n\n    // `justOne = null` means we don't know from the schema whether the end\n    // result should be an array or a single doc. This can result from\n    // populating a POJO using `Model.populate()`\n    if ('justOne' in options && options.justOne !== void 0) {\n      justOne = options.justOne;\n    } else if (schema && !schema[schemaMixedSymbol]) {\n      // Skip Mixed types because we explicitly don't do casting on those.\n      if (options.path.endsWith('.' + schema.path) || options.path === schema.path) {\n        justOne = Array.isArray(schema) ?\n          schema.every(schema => !schema.$isMongooseArray) :\n          !schema.$isMongooseArray;\n      }\n    }\n\n    if (!modelNames) {\n      continue;\n    }\n\n    data.isVirtual = false;\n    data.justOne = justOne;\n    data.localField = localField;\n    data.foreignField = foreignField;\n\n    // Get local fields\n    const ret = _getLocalFieldValues(doc, localField, model, options, null, schema);\n\n    const id = String(utils.getValue(foreignField, doc));\n    options._docs[id] = Array.isArray(ret) ? ret.slice() : ret;\n\n    let match = get(options, 'match', null);\n\n    const hasMatchFunction = typeof match === 'function';\n    if (hasMatchFunction) {\n      match = match.call(doc, doc);\n    }\n    data.match = match;\n    data.hasMatchFunction = hasMatchFunction;\n    data.isRefPath = isRefPath;\n    data.modelNamesInOrder = modelNamesInOrder;\n\n    if (isRefPath) {\n      const embeddedDiscriminatorModelNames = _findRefPathForDiscriminators(doc,\n        modelSchema, data, options, normalizedRefPath, ret);\n\n      modelNames = embeddedDiscriminatorModelNames || modelNames;\n    }\n\n    try {\n      addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions);\n    } catch (err) {\n      return err;\n    }\n  }\n  return map;\n\n  function _getModelNames(doc, schema, modelNameFromQuery, model) {\n    let modelNames;\n    let isRefPath = false;\n    let justOne = null;\n\n    const originalSchema = schema;\n    if (schema && schema.instance === 'Array') {\n      schema = schema.caster;\n    }\n    if (schema && schema.$isSchemaMap) {\n      schema = schema.$__schemaType;\n    }\n\n    const ref = schema && schema.options && schema.options.ref;\n    refPath = schema && schema.options && schema.options.refPath;\n    if (schema != null &&\n        schema[schemaMixedSymbol] &&\n        !ref &&\n        !refPath &&\n        !modelNameFromQuery) {\n      return { modelNames: null };\n    }\n\n    if (modelNameFromQuery) {\n      modelNames = [modelNameFromQuery]; // query options\n    } else if (refPath != null) {\n      if (typeof refPath === 'function') {\n        const subdocPath = options.path.slice(0, options.path.length - schema.path.length - 1);\n        const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n        const subdocsBeingPopulated = Array.isArray(vals) ?\n          utils.array.flatten(vals) :\n          (vals ? [vals] : []);\n\n        modelNames = new Set();\n        for (const subdoc of subdocsBeingPopulated) {\n          refPath = refPath.call(subdoc, subdoc, options.path);\n          modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection).\n            forEach(name => modelNames.add(name));\n        }\n        modelNames = Array.from(modelNames);\n      } else {\n        modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);\n      }\n\n      isRefPath = true;\n    } else {\n      let ref;\n      let refPath;\n      let schemaForCurrentDoc;\n      let discriminatorValue;\n      let modelForCurrentDoc = model;\n      const discriminatorKey = model.schema.options.discriminatorKey;\n\n      if (!schema && discriminatorKey && (discriminatorValue = utils.getValue(discriminatorKey, doc))) {\n        // `modelNameForFind` is the discriminator value, so we might need\n        // find the discriminated model name\n        const discriminatorModel = getDiscriminatorByValue(model.discriminators, discriminatorValue) || model;\n        if (discriminatorModel != null) {\n          modelForCurrentDoc = discriminatorModel;\n        } else {\n          try {\n            modelForCurrentDoc = _getModelFromConn(model.db, discriminatorValue);\n          } catch (error) {\n            return error;\n          }\n        }\n\n        schemaForCurrentDoc = modelForCurrentDoc.schema._getSchema(options.path);\n\n        if (schemaForCurrentDoc && schemaForCurrentDoc.caster) {\n          schemaForCurrentDoc = schemaForCurrentDoc.caster;\n        }\n      } else {\n        schemaForCurrentDoc = schema;\n      }\n\n      if (originalSchema && originalSchema.path.endsWith('.$*')) {\n        justOne = !originalSchema.$isMongooseArray && !originalSchema._arrayPath;\n      } else if (schemaForCurrentDoc != null) {\n        justOne = !schemaForCurrentDoc.$isMongooseArray && !schemaForCurrentDoc._arrayPath;\n      }\n\n      if ((ref = get(schemaForCurrentDoc, 'options.ref')) != null) {\n        if (schemaForCurrentDoc != null &&\n            typeof ref === 'function' &&\n            options.path.endsWith('.' + schemaForCurrentDoc.path)) {\n          // Ensure correct context for ref functions: subdoc, not top-level doc. See gh-8469\n          modelNames = new Set();\n\n          const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);\n          const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n          const subdocsBeingPopulated = Array.isArray(vals) ?\n            utils.array.flatten(vals) :\n            (vals ? [vals] : []);\n          for (const subdoc of subdocsBeingPopulated) {\n            modelNames.add(handleRefFunction(ref, subdoc));\n          }\n\n          if (subdocsBeingPopulated.length === 0) {\n            modelNames = [handleRefFunction(ref, doc)];\n          } else {\n            modelNames = Array.from(modelNames);\n          }\n        } else {\n          ref = handleRefFunction(ref, doc);\n          modelNames = [ref];\n        }\n      } else if ((schemaForCurrentDoc = get(schema, 'options.refPath')) != null) {\n        isRefPath = true;\n        if (typeof refPath === 'function') {\n          const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);\n          const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n          const subdocsBeingPopulated = Array.isArray(vals) ?\n            utils.array.flatten(vals) :\n            (vals ? [vals] : []);\n\n          modelNames = new Set();\n          for (const subdoc of subdocsBeingPopulated) {\n            refPath = refPath.call(subdoc, subdoc, options.path);\n            modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection).\n              forEach(name => modelNames.add(name));\n          }\n          modelNames = Array.from(modelNames);\n        } else {\n          modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);\n        }\n      }\n    }\n\n    if (!modelNames) {\n      // `Model.populate()` on a POJO with no known local model. Default to using the `Model`\n      if (options._localModel == null) {\n        modelNames = [model.modelName];\n      } else {\n        return { modelNames: modelNames, justOne: justOne, isRefPath: isRefPath, refPath: refPath };\n      }\n    }\n\n    if (!Array.isArray(modelNames)) {\n      modelNames = [modelNames];\n    }\n\n    return { modelNames: modelNames, justOne: justOne, isRefPath: isRefPath, refPath: refPath };\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction _virtualPopulate(model, docs, options, _virtualRes) {\n  const map = [];\n  const available = {};\n  const virtual = _virtualRes.virtual;\n\n  for (const doc of docs) {\n    let modelNames = null;\n    const data = {};\n\n    // localField and foreignField\n    let localField;\n    const virtualPrefix = _virtualRes.nestedSchemaPath ?\n      _virtualRes.nestedSchemaPath + '.' : '';\n    if (typeof options.localField === 'string') {\n      localField = options.localField;\n    } else if (typeof virtual.options.localField === 'function') {\n      localField = virtualPrefix + virtual.options.localField.call(doc, doc);\n    } else if (Array.isArray(virtual.options.localField)) {\n      localField = virtual.options.localField.map(field => virtualPrefix + field);\n    } else {\n      localField = virtualPrefix + virtual.options.localField;\n    }\n    data.count = virtual.options.count;\n\n    if (virtual.options.skip != null && !options.hasOwnProperty('skip')) {\n      options.skip = virtual.options.skip;\n    }\n    if (virtual.options.limit != null && !options.hasOwnProperty('limit')) {\n      options.limit = virtual.options.limit;\n    }\n    if (virtual.options.perDocumentLimit != null && !options.hasOwnProperty('perDocumentLimit')) {\n      options.perDocumentLimit = virtual.options.perDocumentLimit;\n    }\n    let foreignField = virtual.options.foreignField;\n\n    if (!localField || !foreignField) {\n      return new MongooseError(`Cannot populate virtual \\`${options.path}\\` on model \\`${model.modelName}\\`, because options \\`localField\\` and / or \\`foreignField\\` are missing`);\n    }\n\n    if (typeof localField === 'function') {\n      localField = localField.call(doc, doc);\n    }\n    if (typeof foreignField === 'function') {\n      foreignField = foreignField.call(doc, doc);\n    }\n\n    data.isRefPath = false;\n\n    // `justOne = null` means we don't know from the schema whether the end\n    // result should be an array or a single doc. This can result from\n    // populating a POJO using `Model.populate()`\n    let justOne = null;\n    if ('justOne' in options && options.justOne !== void 0) {\n      justOne = options.justOne;\n    }\n\n    if (virtual.options.refPath) {\n      modelNames =\n        modelNamesFromRefPath(virtual.options.refPath, doc, options.path);\n      justOne = !!virtual.options.justOne;\n      data.isRefPath = true;\n    } else if (virtual.options.ref) {\n      let normalizedRef;\n      if (typeof virtual.options.ref === 'function' && !virtual.options.ref[modelSymbol]) {\n        normalizedRef = virtual.options.ref.call(doc, doc);\n      } else {\n        normalizedRef = virtual.options.ref;\n      }\n      justOne = !!virtual.options.justOne;\n      // When referencing nested arrays, the ref should be an Array\n      // of modelNames.\n      if (Array.isArray(normalizedRef)) {\n        modelNames = normalizedRef;\n      } else {\n        modelNames = [normalizedRef];\n      }\n    }\n\n    data.isVirtual = true;\n    data.virtual = virtual;\n    data.justOne = justOne;\n\n    // `match`\n    const baseMatch = get(data, 'virtual.options.match', null) ||\n      get(data, 'virtual.options.options.match', null);\n    let match = get(options, 'match', null) || baseMatch;\n\n    let hasMatchFunction = typeof match === 'function';\n    if (hasMatchFunction) {\n      match = match.call(doc, doc, data.virtual);\n    }\n\n    if (Array.isArray(localField) && Array.isArray(foreignField) && localField.length === foreignField.length) {\n      match = Object.assign({}, match);\n      for (let i = 1; i < localField.length; ++i) {\n        match[foreignField[i]] = convertTo_id(mpath.get(localField[i], doc, lookupLocalFields), model.schema);\n        hasMatchFunction = true;\n      }\n\n      localField = localField[0];\n      foreignField = foreignField[0];\n    }\n    data.localField = localField;\n    data.foreignField = foreignField;\n    data.match = match;\n    data.hasMatchFunction = hasMatchFunction;\n\n    // Get local fields\n    const ret = _getLocalFieldValues(doc, localField, model, options, virtual);\n\n    try {\n      addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc);\n    } catch (err) {\n      return err;\n    }\n  }\n\n  return map;\n}\n\n/*!\n * ignore\n */\n\nfunction addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions, unpopulatedValue) {\n  // `PopulateOptions#connection`: if the model is passed as a string, the\n  // connection matters because different connections have different models.\n  const connection = options.connection != null ? options.connection : model.db;\n\n  unpopulatedValue = unpopulatedValue === void 0 ? ret : unpopulatedValue;\n  if (Array.isArray(unpopulatedValue)) {\n    unpopulatedValue = utils.cloneArrays(unpopulatedValue);\n  }\n\n  if (modelNames == null) {\n    return;\n  }\n\n  let k = modelNames.length;\n  while (k--) {\n    let modelName = modelNames[k];\n    if (modelName == null) {\n      continue;\n    }\n\n    let Model;\n    if (options.model && options.model[modelSymbol]) {\n      Model = options.model;\n    } else if (modelName[modelSymbol]) {\n      Model = modelName;\n      modelName = Model.modelName;\n    } else {\n      try {\n        Model = _getModelFromConn(connection, modelName);\n      } catch (err) {\n        if (ret !== void 0) {\n          throw err;\n        }\n        Model = null;\n      }\n    }\n\n    let ids = ret;\n    const flat = Array.isArray(ret) ? utils.array.flatten(ret) : [];\n\n    const modelNamesForRefPath = data.modelNamesInOrder ? data.modelNamesInOrder : modelNames;\n    if (data.isRefPath && Array.isArray(ret) && flat.length === modelNamesForRefPath.length) {\n      ids = flat.filter((val, i) => modelNamesForRefPath[i] === modelName);\n    }\n\n    const perDocumentLimit = options.perDocumentLimit == null ?\n      get(options, 'options.perDocumentLimit', null) :\n      options.perDocumentLimit;\n\n    if (!available[modelName] || perDocumentLimit != null) {\n      const currentOptions = {\n        model: Model\n      };\n      if (data.isVirtual && get(data.virtual, 'options.options')) {\n        currentOptions.options = clone(data.virtual.options.options);\n      } else if (schemaOptions != null) {\n        currentOptions.options = Object.assign({}, schemaOptions);\n      }\n      utils.merge(currentOptions, options);\n\n      // Used internally for checking what model was used to populate this\n      // path.\n      options[populateModelSymbol] = Model;\n      currentOptions[populateModelSymbol] = Model;\n      available[modelName] = {\n        model: Model,\n        options: currentOptions,\n        match: data.hasMatchFunction ? [data.match] : data.match,\n        docs: [doc],\n        ids: [ids],\n        allIds: [ret],\n        unpopulatedValues: [unpopulatedValue],\n        localField: new Set([data.localField]),\n        foreignField: new Set([data.foreignField]),\n        justOne: data.justOne,\n        isVirtual: data.isVirtual,\n        virtual: data.virtual,\n        count: data.count,\n        [populateModelSymbol]: Model\n      };\n      map.push(available[modelName]);\n    } else {\n      available[modelName].localField.add(data.localField);\n      available[modelName].foreignField.add(data.foreignField);\n      available[modelName].docs.push(doc);\n      available[modelName].ids.push(ids);\n      available[modelName].allIds.push(ret);\n      available[modelName].unpopulatedValues.push(unpopulatedValue);\n      if (data.hasMatchFunction) {\n        available[modelName].match.push(data.match);\n      }\n    }\n  }\n}\n\nfunction _getModelFromConn(conn, modelName) {\n  /* If this connection has a parent from `useDb()`, bubble up to parent's models */\n  if (conn.models[modelName] == null && conn._parent != null) {\n    return _getModelFromConn(conn._parent, modelName);\n  }\n\n  return conn.model(modelName);\n}\n\n/*!\n * ignore\n */\n\nfunction handleRefFunction(ref, doc) {\n  if (typeof ref === 'function' && !ref[modelSymbol]) {\n    return ref.call(doc, doc);\n  }\n  return ref;\n}\n\n/*!\n * ignore\n */\n\nfunction _getLocalFieldValues(doc, localField, model, options, virtual, schema) {\n  // Get Local fields\n  const localFieldPathType = model.schema._getPathType(localField);\n  const localFieldPath = localFieldPathType === 'real' ?\n    model.schema.path(localField) :\n    localFieldPathType.schema;\n  const localFieldGetters = localFieldPath && localFieldPath.getters ?\n    localFieldPath.getters : [];\n\n  localField = localFieldPath != null && localFieldPath.instance === 'Embedded' ? localField + '._id' : localField;\n\n  const _populateOptions = get(options, 'options', {});\n\n  const getters = 'getters' in _populateOptions ?\n    _populateOptions.getters :\n    get(virtual, 'options.getters', false);\n  if (localFieldGetters.length !== 0 && getters) {\n    const hydratedDoc = (doc.$__ != null) ? doc : model.hydrate(doc);\n    const localFieldValue = utils.getValue(localField, doc);\n    if (Array.isArray(localFieldValue)) {\n      const localFieldHydratedValue = utils.getValue(localField.split('.').slice(0, -1), hydratedDoc);\n      return localFieldValue.map((localFieldArrVal, localFieldArrIndex) =>\n        localFieldPath.applyGetters(localFieldArrVal, localFieldHydratedValue[localFieldArrIndex]));\n    } else {\n      return localFieldPath.applyGetters(localFieldValue, hydratedDoc);\n    }\n  } else {\n    return convertTo_id(mpath.get(localField, doc, lookupLocalFields), schema);\n  }\n}\n\n/**\n * Retrieve the _id of `val` if a Document or Array of Documents.\n *\n * @param {Array|Document|Any} val\n * @param {Schema} schema\n * @return {Array|Document|Any}\n * @api private\n */\n\nfunction convertTo_id(val, schema) {\n  if (val != null && val.$__ != null) {\n    return val._id;\n  }\n  if (val != null && val._id != null && (schema == null || !schema.$isSchemaMap)) {\n    return val._id;\n  }\n\n  if (Array.isArray(val)) {\n    const rawVal = val.__array != null ? val.__array : val;\n    for (let i = 0; i < rawVal.length; ++i) {\n      if (rawVal[i] != null && rawVal[i].$__ != null) {\n        rawVal[i] = rawVal[i]._id;\n      }\n    }\n    if (utils.isMongooseArray(val) && val.$schema()) {\n      return val.$schema()._castForPopulate(val, val.$parent());\n    }\n\n    return [].concat(val);\n  }\n\n  // `populate('map')` may be an object if populating on a doc that hasn't\n  // been hydrated yet\n  if (getConstructorName(val) === 'Object' &&\n      // The intent here is we should only flatten the object if we expect\n      // to get a Map in the end. Avoid doing this for mixed types.\n      (schema == null || schema[schemaMixedSymbol] == null)) {\n    const ret = [];\n    for (const key of Object.keys(val)) {\n      ret.push(val[key]);\n    }\n    return ret;\n  }\n  // If doc has already been hydrated, e.g. `doc.populate('map')`\n  // then `val` will already be a map\n  if (val instanceof Map) {\n    return Array.from(val.values());\n  }\n\n  return val;\n}\n\n/*!\n * ignore\n */\n\nfunction _findRefPathForDiscriminators(doc, modelSchema, data, options, normalizedRefPath, ret) {\n  // Re: gh-8452. Embedded discriminators may not have `refPath`, so clear\n  // out embedded discriminator docs that don't have a `refPath` on the\n  // populated path.\n  if (!data.isRefPath || normalizedRefPath == null) {\n    return;\n  }\n\n  const pieces = normalizedRefPath.split('.');\n  let cur = '';\n  let modelNames = void 0;\n  for (let i = 0; i < pieces.length; ++i) {\n    const piece = pieces[i];\n    cur = cur + (cur.length === 0 ? '' : '.') + piece;\n    const schematype = modelSchema.path(cur);\n    if (schematype != null &&\n        schematype.$isMongooseArray &&\n        schematype.caster.discriminators != null &&\n        Object.keys(schematype.caster.discriminators).length !== 0) {\n      const subdocs = utils.getValue(cur, doc);\n      const remnant = options.path.substring(cur.length + 1);\n      const discriminatorKey = schematype.caster.schema.options.discriminatorKey;\n      modelNames = [];\n      for (const subdoc of subdocs) {\n        const discriminatorName = utils.getValue(discriminatorKey, subdoc);\n        const discriminator = schematype.caster.discriminators[discriminatorName];\n        const discriminatorSchema = discriminator && discriminator.schema;\n        if (discriminatorSchema == null) {\n          continue;\n        }\n        const _path = discriminatorSchema.path(remnant);\n        if (_path == null || _path.options.refPath == null) {\n          const docValue = utils.getValue(data.localField.substring(cur.length + 1), subdoc);\n          ret.forEach((v, i) => {\n            if (v === docValue) {\n              ret[i] = SkipPopulateValue(v);\n            }\n          });\n          continue;\n        }\n        const modelName = utils.getValue(pieces.slice(i + 1).join('.'), subdoc);\n        modelNames.push(modelName);\n      }\n    }\n  }\n\n  return modelNames;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvZ2V0TW9kZWxzTWFwRm9yUG9wdWxhdGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsOEVBQW1CO0FBQ2pELDBCQUEwQixtQkFBTyxDQUFDLHVHQUFxQjtBQUN2RCxjQUFjLG1CQUFPLENBQUMsdUVBQVU7QUFDaEMsWUFBWSxtQkFBTyxDQUFDLG1FQUFRO0FBQzVCLGdDQUFnQyxtQkFBTyxDQUFDLHVJQUEwQztBQUNsRiwyQkFBMkIsbUJBQU8sQ0FBQyxpR0FBdUI7QUFDMUQsdUJBQXVCLG1CQUFPLENBQUMsaUdBQWtCO0FBQ2pELG1CQUFtQixtQkFBTyxDQUFDLHlGQUFjO0FBQ3pDLDBCQUEwQixtQkFBTyxDQUFDLHVHQUFxQjtBQUN2RCxjQUFjLG1CQUFPLENBQUMscURBQU87QUFDN0IsOEJBQThCLG1CQUFPLENBQUMsK0dBQXlCO0FBQy9ELGNBQWMsbUJBQU8sQ0FBQyxrRUFBYTs7QUFFbkMsb0JBQW9CLDhHQUFpQztBQUNyRCw0QkFBNEIsc0hBQXlDO0FBQ3JFLDBCQUEwQiw2SEFBaUQ7QUFDM0UsdUJBQXVCLG1CQUFPLENBQUMsZ0dBQTRCOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBLHlDQUF5QztBQUN6QyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNERBQTRELGFBQWEsZ0JBQWdCLGdCQUFnQjtBQUN6Rzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QixzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscURBQXFEOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3BvcHVsYXRlL2dldE1vZGVsc01hcEZvclBvcHVsYXRlLmpzP2U3MGUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi4vLi4vZXJyb3IvaW5kZXgnKTtcbmNvbnN0IFNraXBQb3B1bGF0ZVZhbHVlID0gcmVxdWlyZSgnLi9za2lwUG9wdWxhdGVWYWx1ZScpO1xuY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuLi9jbG9uZScpO1xuY29uc3QgZ2V0ID0gcmVxdWlyZSgnLi4vZ2V0Jyk7XG5jb25zdCBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZSA9IHJlcXVpcmUoJy4uL2Rpc2NyaW1pbmF0b3IvZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUnKTtcbmNvbnN0IGdldENvbnN0cnVjdG9yTmFtZSA9IHJlcXVpcmUoJy4uL2dldENvbnN0cnVjdG9yTmFtZScpO1xuY29uc3QgZ2V0U2NoZW1hVHlwZXMgPSByZXF1aXJlKCcuL2dldFNjaGVtYVR5cGVzJyk7XG5jb25zdCBnZXRWaXJ0dWFsID0gcmVxdWlyZSgnLi9nZXRWaXJ0dWFsJyk7XG5jb25zdCBsb29rdXBMb2NhbEZpZWxkcyA9IHJlcXVpcmUoJy4vbG9va3VwTG9jYWxGaWVsZHMnKTtcbmNvbnN0IG1wYXRoID0gcmVxdWlyZSgnbXBhdGgnKTtcbmNvbnN0IG1vZGVsTmFtZXNGcm9tUmVmUGF0aCA9IHJlcXVpcmUoJy4vbW9kZWxOYW1lc0Zyb21SZWZQYXRoJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5cbmNvbnN0IG1vZGVsU3ltYm9sID0gcmVxdWlyZSgnLi4vc3ltYm9scycpLm1vZGVsU3ltYm9sO1xuY29uc3QgcG9wdWxhdGVNb2RlbFN5bWJvbCA9IHJlcXVpcmUoJy4uL3N5bWJvbHMnKS5wb3B1bGF0ZU1vZGVsU3ltYm9sO1xuY29uc3Qgc2NoZW1hTWl4ZWRTeW1ib2wgPSByZXF1aXJlKCcuLi8uLi9zY2hlbWEvc3ltYm9scycpLnNjaGVtYU1peGVkU3ltYm9sO1xuY29uc3QgU3RyaWN0UG9wdWxhdGUgPSByZXF1aXJlKCcuLi8uLi9lcnJvci9zdHJpY3RQb3B1bGF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldE1vZGVsc01hcEZvclBvcHVsYXRlKG1vZGVsLCBkb2NzLCBvcHRpb25zKSB7XG4gIGxldCBkb2M7XG4gIGNvbnN0IGxlbiA9IGRvY3MubGVuZ3RoO1xuICBjb25zdCBtYXAgPSBbXTtcbiAgY29uc3QgbW9kZWxOYW1lRnJvbVF1ZXJ5ID0gb3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLm1vZGVsTmFtZSB8fCBvcHRpb25zLm1vZGVsO1xuICBsZXQgc2NoZW1hO1xuICBsZXQgcmVmUGF0aDtcbiAgbGV0IG1vZGVsTmFtZXM7XG4gIGNvbnN0IGF2YWlsYWJsZSA9IHt9O1xuXG4gIGNvbnN0IG1vZGVsU2NoZW1hID0gbW9kZWwuc2NoZW1hO1xuXG4gIC8vIFBvcHVsYXRpbmcgYSBuZXN0ZWQgcGF0aCBzaG91bGQgYWx3YXlzIGJlIGEgbm8tb3AgcmU6ICM5MDczLlxuICAvLyBQZW9wbGUgc2hvdWxkbid0IGRvIHRoaXMsIGJ1dCBhcHBhcmVudGx5IHRoZXkgZG8uXG4gIGlmIChvcHRpb25zLl9sb2NhbE1vZGVsICE9IG51bGwgJiYgb3B0aW9ucy5fbG9jYWxNb2RlbC5zY2hlbWEubmVzdGVkW29wdGlvbnMucGF0aF0pIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBfdmlydHVhbFJlcyA9IGdldFZpcnR1YWwobW9kZWwuc2NoZW1hLCBvcHRpb25zLnBhdGgpO1xuICBjb25zdCB2aXJ0dWFsID0gX3ZpcnR1YWxSZXMgPT0gbnVsbCA/IG51bGwgOiBfdmlydHVhbFJlcy52aXJ0dWFsO1xuICBpZiAodmlydHVhbCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIF92aXJ0dWFsUG9wdWxhdGUobW9kZWwsIGRvY3MsIG9wdGlvbnMsIF92aXJ0dWFsUmVzKTtcbiAgfVxuXG4gIGxldCBhbGxTY2hlbWFUeXBlcyA9IGdldFNjaGVtYVR5cGVzKG1vZGVsLCBtb2RlbFNjaGVtYSwgbnVsbCwgb3B0aW9ucy5wYXRoKTtcbiAgYWxsU2NoZW1hVHlwZXMgPSBBcnJheS5pc0FycmF5KGFsbFNjaGVtYVR5cGVzKSA/IGFsbFNjaGVtYVR5cGVzIDogW2FsbFNjaGVtYVR5cGVzXS5maWx0ZXIodiA9PiB2ICE9IG51bGwpO1xuXG4gIGNvbnN0IGlzU3RyaWN0UG9wdWxhdGVEaXNhYmxlZCA9IG9wdGlvbnMuc3RyaWN0UG9wdWxhdGUgPT09IGZhbHNlIHx8IG9wdGlvbnMub3B0aW9ucz8uc3RyaWN0UG9wdWxhdGUgPT09IGZhbHNlO1xuICBpZiAoIWlzU3RyaWN0UG9wdWxhdGVEaXNhYmxlZCAmJiBhbGxTY2hlbWFUeXBlcy5sZW5ndGggPT09IDAgJiYgb3B0aW9ucy5fbG9jYWxNb2RlbCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJpY3RQb3B1bGF0ZShvcHRpb25zLl9mdWxsUGF0aCB8fCBvcHRpb25zLnBhdGgpO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGRvYyA9IGRvY3NbaV07XG4gICAgbGV0IGp1c3RPbmUgPSBudWxsO1xuXG4gICAgY29uc3QgZG9jU2NoZW1hID0gZG9jICE9IG51bGwgJiYgZG9jLiRfXyAhPSBudWxsID8gZG9jLiRfX3NjaGVtYSA6IG1vZGVsU2NoZW1hO1xuICAgIHNjaGVtYSA9IGdldFNjaGVtYVR5cGVzKG1vZGVsLCBkb2NTY2hlbWEsIGRvYywgb3B0aW9ucy5wYXRoKTtcblxuICAgIC8vIFNwZWNpYWwgY2FzZTogcG9wdWxhdGluZyBhIHBhdGggdGhhdCdzIGEgRG9jdW1lbnRBcnJheSB1bmxlc3NcbiAgICAvLyB0aGVyZSdzIGFuIGV4cGxpY2l0IGByZWZgIG9yIGByZWZQYXRoYCByZTogZ2gtODk0NlxuICAgIGlmIChzY2hlbWEgIT0gbnVsbCAmJlxuICAgICAgICBzY2hlbWEuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5ICYmXG4gICAgICAgIHNjaGVtYS5vcHRpb25zLnJlZiA9PSBudWxsICYmXG4gICAgICAgIHNjaGVtYS5vcHRpb25zLnJlZlBhdGggPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGlzVW5kZXJuZWF0aERvY0FycmF5ID0gc2NoZW1hICYmIHNjaGVtYS4kcGFyZW50U2NoZW1hRG9jQXJyYXk7XG4gICAgaWYgKGlzVW5kZXJuZWF0aERvY0FycmF5ICYmIGdldChvcHRpb25zLCAnb3B0aW9ucy5zb3J0JykgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5ldyBNb25nb29zZUVycm9yKCdDYW5ub3QgcG9wdWxhdGUgd2l0aCBgc29ydGAgb24gcGF0aCAnICsgb3B0aW9ucy5wYXRoICtcbiAgICAgICAgJyBiZWNhdXNlIGl0IGlzIGEgc3VicHJvcGVydHkgb2YgYSBkb2N1bWVudCBhcnJheScpO1xuICAgIH1cblxuICAgIG1vZGVsTmFtZXMgPSBudWxsO1xuICAgIGxldCBpc1JlZlBhdGggPSBmYWxzZTtcbiAgICBsZXQgbm9ybWFsaXplZFJlZlBhdGggPSBudWxsO1xuICAgIGxldCBzY2hlbWFPcHRpb25zID0gbnVsbDtcbiAgICBsZXQgbW9kZWxOYW1lc0luT3JkZXIgPSBudWxsO1xuXG4gICAgaWYgKHNjaGVtYSAhPSBudWxsICYmIHNjaGVtYS5pbnN0YW5jZSA9PT0gJ0VtYmVkZGVkJykge1xuICAgICAgaWYgKHNjaGVtYS5vcHRpb25zLnJlZikge1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgIGxvY2FsRmllbGQ6IG9wdGlvbnMucGF0aCArICcuX2lkJyxcbiAgICAgICAgICBmb3JlaWduRmllbGQ6ICdfaWQnLFxuICAgICAgICAgIGp1c3RPbmU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzID0gX2dldE1vZGVsTmFtZXMoZG9jLCBzY2hlbWEsIG1vZGVsTmFtZUZyb21RdWVyeSwgbW9kZWwpO1xuXG4gICAgICAgIGNvbnN0IHVucG9wdWxhdGVkVmFsdWUgPSBtcGF0aC5nZXQob3B0aW9ucy5wYXRoLCBkb2MpO1xuICAgICAgICBjb25zdCBpZCA9IG1wYXRoLmdldCgnX2lkJywgdW5wb3B1bGF0ZWRWYWx1ZSk7XG4gICAgICAgIGFkZE1vZGVsTmFtZXNUb01hcChtb2RlbCwgbWFwLCBhdmFpbGFibGUsIHJlcy5tb2RlbE5hbWVzLCBvcHRpb25zLCBkYXRhLCBpZCwgZG9jLCBzY2hlbWFPcHRpb25zLCB1bnBvcHVsYXRlZFZhbHVlKTtcbiAgICAgIH1cbiAgICAgIC8vIE5vLW9wIGlmIG5vIGByZWZgIHNldC4gU2VlIGdoLTExNTM4XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgICBjb25zdCBzY2hlbWFzQXJyYXkgPSBzY2hlbWE7XG4gICAgICBmb3IgKGNvbnN0IF9zY2hlbWEgb2Ygc2NoZW1hc0FycmF5KSB7XG4gICAgICAgIGxldCBfbW9kZWxOYW1lcztcbiAgICAgICAgbGV0IHJlcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXMgPSBfZ2V0TW9kZWxOYW1lcyhkb2MsIF9zY2hlbWEsIG1vZGVsTmFtZUZyb21RdWVyeSwgbW9kZWwpO1xuICAgICAgICAgIF9tb2RlbE5hbWVzID0gcmVzLm1vZGVsTmFtZXM7XG4gICAgICAgICAgaXNSZWZQYXRoID0gaXNSZWZQYXRoIHx8IHJlcy5pc1JlZlBhdGg7XG4gICAgICAgICAgbm9ybWFsaXplZFJlZlBhdGggPSBub3JtYWxpemVkUmVmUGF0aCB8fCByZXMucmVmUGF0aDtcbiAgICAgICAgICBqdXN0T25lID0gcmVzLmp1c3RPbmU7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUmVmUGF0aCAmJiAhcmVzLmlzUmVmUGF0aCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX21vZGVsTmFtZXMpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBtb2RlbE5hbWVzID0gbW9kZWxOYW1lcyB8fCBbXTtcbiAgICAgICAgZm9yIChjb25zdCBtb2RlbE5hbWUgb2YgX21vZGVsTmFtZXMpIHtcbiAgICAgICAgICBpZiAobW9kZWxOYW1lcy5pbmRleE9mKG1vZGVsTmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICBtb2RlbE5hbWVzLnB1c2gobW9kZWxOYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzID0gX2dldE1vZGVsTmFtZXMoZG9jLCBzY2hlbWEsIG1vZGVsTmFtZUZyb21RdWVyeSwgbW9kZWwpO1xuICAgICAgICBtb2RlbE5hbWVzID0gcmVzLm1vZGVsTmFtZXM7XG4gICAgICAgIGlzUmVmUGF0aCA9IHJlcy5pc1JlZlBhdGg7XG4gICAgICAgIG5vcm1hbGl6ZWRSZWZQYXRoID0gbm9ybWFsaXplZFJlZlBhdGggfHwgcmVzLnJlZlBhdGg7XG4gICAgICAgIGp1c3RPbmUgPSByZXMuanVzdE9uZTtcbiAgICAgICAgc2NoZW1hT3B0aW9ucyA9IGdldChzY2hlbWEsICdvcHRpb25zLnBvcHVsYXRlJywgbnVsbCk7XG4gICAgICAgIC8vIERlZHVwZSwgYmVjYXVzZSBgcmVmUGF0aGAgY2FuIHJldHVybiBkdXBsaWNhdGVzIG9mIHRoZSBzYW1lIG1vZGVsIG5hbWUsXG4gICAgICAgIC8vIGFuZCB0aGF0IGNhdXNlcyBwZXJmIGlzc3Vlcy5cbiAgICAgICAgaWYgKGlzUmVmUGF0aCkge1xuICAgICAgICAgIG1vZGVsTmFtZXNJbk9yZGVyID0gbW9kZWxOYW1lcztcbiAgICAgICAgICBtb2RlbE5hbWVzID0gQXJyYXkuZnJvbShuZXcgU2V0KG1vZGVsTmFtZXMpKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW1vZGVsTmFtZXMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9IHt9O1xuICAgIGNvbnN0IGxvY2FsRmllbGQgPSBvcHRpb25zLnBhdGg7XG4gICAgY29uc3QgZm9yZWlnbkZpZWxkID0gJ19pZCc7XG5cbiAgICAvLyBganVzdE9uZSA9IG51bGxgIG1lYW5zIHdlIGRvbid0IGtub3cgZnJvbSB0aGUgc2NoZW1hIHdoZXRoZXIgdGhlIGVuZFxuICAgIC8vIHJlc3VsdCBzaG91bGQgYmUgYW4gYXJyYXkgb3IgYSBzaW5nbGUgZG9jLiBUaGlzIGNhbiByZXN1bHQgZnJvbVxuICAgIC8vIHBvcHVsYXRpbmcgYSBQT0pPIHVzaW5nIGBNb2RlbC5wb3B1bGF0ZSgpYFxuICAgIGlmICgnanVzdE9uZScgaW4gb3B0aW9ucyAmJiBvcHRpb25zLmp1c3RPbmUgIT09IHZvaWQgMCkge1xuICAgICAganVzdE9uZSA9IG9wdGlvbnMuanVzdE9uZTtcbiAgICB9IGVsc2UgaWYgKHNjaGVtYSAmJiAhc2NoZW1hW3NjaGVtYU1peGVkU3ltYm9sXSkge1xuICAgICAgLy8gU2tpcCBNaXhlZCB0eXBlcyBiZWNhdXNlIHdlIGV4cGxpY2l0bHkgZG9uJ3QgZG8gY2FzdGluZyBvbiB0aG9zZS5cbiAgICAgIGlmIChvcHRpb25zLnBhdGguZW5kc1dpdGgoJy4nICsgc2NoZW1hLnBhdGgpIHx8IG9wdGlvbnMucGF0aCA9PT0gc2NoZW1hLnBhdGgpIHtcbiAgICAgICAganVzdE9uZSA9IEFycmF5LmlzQXJyYXkoc2NoZW1hKSA/XG4gICAgICAgICAgc2NoZW1hLmV2ZXJ5KHNjaGVtYSA9PiAhc2NoZW1hLiRpc01vbmdvb3NlQXJyYXkpIDpcbiAgICAgICAgICAhc2NoZW1hLiRpc01vbmdvb3NlQXJyYXk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFtb2RlbE5hbWVzKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBkYXRhLmlzVmlydHVhbCA9IGZhbHNlO1xuICAgIGRhdGEuanVzdE9uZSA9IGp1c3RPbmU7XG4gICAgZGF0YS5sb2NhbEZpZWxkID0gbG9jYWxGaWVsZDtcbiAgICBkYXRhLmZvcmVpZ25GaWVsZCA9IGZvcmVpZ25GaWVsZDtcblxuICAgIC8vIEdldCBsb2NhbCBmaWVsZHNcbiAgICBjb25zdCByZXQgPSBfZ2V0TG9jYWxGaWVsZFZhbHVlcyhkb2MsIGxvY2FsRmllbGQsIG1vZGVsLCBvcHRpb25zLCBudWxsLCBzY2hlbWEpO1xuXG4gICAgY29uc3QgaWQgPSBTdHJpbmcodXRpbHMuZ2V0VmFsdWUoZm9yZWlnbkZpZWxkLCBkb2MpKTtcbiAgICBvcHRpb25zLl9kb2NzW2lkXSA9IEFycmF5LmlzQXJyYXkocmV0KSA/IHJldC5zbGljZSgpIDogcmV0O1xuXG4gICAgbGV0IG1hdGNoID0gZ2V0KG9wdGlvbnMsICdtYXRjaCcsIG51bGwpO1xuXG4gICAgY29uc3QgaGFzTWF0Y2hGdW5jdGlvbiA9IHR5cGVvZiBtYXRjaCA9PT0gJ2Z1bmN0aW9uJztcbiAgICBpZiAoaGFzTWF0Y2hGdW5jdGlvbikge1xuICAgICAgbWF0Y2ggPSBtYXRjaC5jYWxsKGRvYywgZG9jKTtcbiAgICB9XG4gICAgZGF0YS5tYXRjaCA9IG1hdGNoO1xuICAgIGRhdGEuaGFzTWF0Y2hGdW5jdGlvbiA9IGhhc01hdGNoRnVuY3Rpb247XG4gICAgZGF0YS5pc1JlZlBhdGggPSBpc1JlZlBhdGg7XG4gICAgZGF0YS5tb2RlbE5hbWVzSW5PcmRlciA9IG1vZGVsTmFtZXNJbk9yZGVyO1xuXG4gICAgaWYgKGlzUmVmUGF0aCkge1xuICAgICAgY29uc3QgZW1iZWRkZWREaXNjcmltaW5hdG9yTW9kZWxOYW1lcyA9IF9maW5kUmVmUGF0aEZvckRpc2NyaW1pbmF0b3JzKGRvYyxcbiAgICAgICAgbW9kZWxTY2hlbWEsIGRhdGEsIG9wdGlvbnMsIG5vcm1hbGl6ZWRSZWZQYXRoLCByZXQpO1xuXG4gICAgICBtb2RlbE5hbWVzID0gZW1iZWRkZWREaXNjcmltaW5hdG9yTW9kZWxOYW1lcyB8fCBtb2RlbE5hbWVzO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBhZGRNb2RlbE5hbWVzVG9NYXAobW9kZWwsIG1hcCwgYXZhaWxhYmxlLCBtb2RlbE5hbWVzLCBvcHRpb25zLCBkYXRhLCByZXQsIGRvYywgc2NoZW1hT3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gZXJyO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWFwO1xuXG4gIGZ1bmN0aW9uIF9nZXRNb2RlbE5hbWVzKGRvYywgc2NoZW1hLCBtb2RlbE5hbWVGcm9tUXVlcnksIG1vZGVsKSB7XG4gICAgbGV0IG1vZGVsTmFtZXM7XG4gICAgbGV0IGlzUmVmUGF0aCA9IGZhbHNlO1xuICAgIGxldCBqdXN0T25lID0gbnVsbDtcblxuICAgIGNvbnN0IG9yaWdpbmFsU2NoZW1hID0gc2NoZW1hO1xuICAgIGlmIChzY2hlbWEgJiYgc2NoZW1hLmluc3RhbmNlID09PSAnQXJyYXknKSB7XG4gICAgICBzY2hlbWEgPSBzY2hlbWEuY2FzdGVyO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hICYmIHNjaGVtYS4kaXNTY2hlbWFNYXApIHtcbiAgICAgIHNjaGVtYSA9IHNjaGVtYS4kX19zY2hlbWFUeXBlO1xuICAgIH1cblxuICAgIGNvbnN0IHJlZiA9IHNjaGVtYSAmJiBzY2hlbWEub3B0aW9ucyAmJiBzY2hlbWEub3B0aW9ucy5yZWY7XG4gICAgcmVmUGF0aCA9IHNjaGVtYSAmJiBzY2hlbWEub3B0aW9ucyAmJiBzY2hlbWEub3B0aW9ucy5yZWZQYXRoO1xuICAgIGlmIChzY2hlbWEgIT0gbnVsbCAmJlxuICAgICAgICBzY2hlbWFbc2NoZW1hTWl4ZWRTeW1ib2xdICYmXG4gICAgICAgICFyZWYgJiZcbiAgICAgICAgIXJlZlBhdGggJiZcbiAgICAgICAgIW1vZGVsTmFtZUZyb21RdWVyeSkge1xuICAgICAgcmV0dXJuIHsgbW9kZWxOYW1lczogbnVsbCB9O1xuICAgIH1cblxuICAgIGlmIChtb2RlbE5hbWVGcm9tUXVlcnkpIHtcbiAgICAgIG1vZGVsTmFtZXMgPSBbbW9kZWxOYW1lRnJvbVF1ZXJ5XTsgLy8gcXVlcnkgb3B0aW9uc1xuICAgIH0gZWxzZSBpZiAocmVmUGF0aCAhPSBudWxsKSB7XG4gICAgICBpZiAodHlwZW9mIHJlZlBhdGggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3Qgc3ViZG9jUGF0aCA9IG9wdGlvbnMucGF0aC5zbGljZSgwLCBvcHRpb25zLnBhdGgubGVuZ3RoIC0gc2NoZW1hLnBhdGgubGVuZ3RoIC0gMSk7XG4gICAgICAgIGNvbnN0IHZhbHMgPSBtcGF0aC5nZXQoc3ViZG9jUGF0aCwgZG9jLCBsb29rdXBMb2NhbEZpZWxkcyk7XG4gICAgICAgIGNvbnN0IHN1YmRvY3NCZWluZ1BvcHVsYXRlZCA9IEFycmF5LmlzQXJyYXkodmFscykgP1xuICAgICAgICAgIHV0aWxzLmFycmF5LmZsYXR0ZW4odmFscykgOlxuICAgICAgICAgICh2YWxzID8gW3ZhbHNdIDogW10pO1xuXG4gICAgICAgIG1vZGVsTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3Qgc3ViZG9jIG9mIHN1YmRvY3NCZWluZ1BvcHVsYXRlZCkge1xuICAgICAgICAgIHJlZlBhdGggPSByZWZQYXRoLmNhbGwoc3ViZG9jLCBzdWJkb2MsIG9wdGlvbnMucGF0aCk7XG4gICAgICAgICAgbW9kZWxOYW1lc0Zyb21SZWZQYXRoKHJlZlBhdGgsIGRvYywgb3B0aW9ucy5wYXRoLCBtb2RlbFNjaGVtYSwgb3B0aW9ucy5fcXVlcnlQcm9qZWN0aW9uKS5cbiAgICAgICAgICAgIGZvckVhY2gobmFtZSA9PiBtb2RlbE5hbWVzLmFkZChuYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgbW9kZWxOYW1lcyA9IEFycmF5LmZyb20obW9kZWxOYW1lcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb2RlbE5hbWVzID0gbW9kZWxOYW1lc0Zyb21SZWZQYXRoKHJlZlBhdGgsIGRvYywgb3B0aW9ucy5wYXRoLCBtb2RlbFNjaGVtYSwgb3B0aW9ucy5fcXVlcnlQcm9qZWN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgaXNSZWZQYXRoID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHJlZjtcbiAgICAgIGxldCByZWZQYXRoO1xuICAgICAgbGV0IHNjaGVtYUZvckN1cnJlbnREb2M7XG4gICAgICBsZXQgZGlzY3JpbWluYXRvclZhbHVlO1xuICAgICAgbGV0IG1vZGVsRm9yQ3VycmVudERvYyA9IG1vZGVsO1xuICAgICAgY29uc3QgZGlzY3JpbWluYXRvcktleSA9IG1vZGVsLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXk7XG5cbiAgICAgIGlmICghc2NoZW1hICYmIGRpc2NyaW1pbmF0b3JLZXkgJiYgKGRpc2NyaW1pbmF0b3JWYWx1ZSA9IHV0aWxzLmdldFZhbHVlKGRpc2NyaW1pbmF0b3JLZXksIGRvYykpKSB7XG4gICAgICAgIC8vIGBtb2RlbE5hbWVGb3JGaW5kYCBpcyB0aGUgZGlzY3JpbWluYXRvciB2YWx1ZSwgc28gd2UgbWlnaHQgbmVlZFxuICAgICAgICAvLyBmaW5kIHRoZSBkaXNjcmltaW5hdGVkIG1vZGVsIG5hbWVcbiAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvck1vZGVsID0gZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUobW9kZWwuZGlzY3JpbWluYXRvcnMsIGRpc2NyaW1pbmF0b3JWYWx1ZSkgfHwgbW9kZWw7XG4gICAgICAgIGlmIChkaXNjcmltaW5hdG9yTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICAgIG1vZGVsRm9yQ3VycmVudERvYyA9IGRpc2NyaW1pbmF0b3JNb2RlbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbW9kZWxGb3JDdXJyZW50RG9jID0gX2dldE1vZGVsRnJvbUNvbm4obW9kZWwuZGIsIGRpc2NyaW1pbmF0b3JWYWx1ZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzY2hlbWFGb3JDdXJyZW50RG9jID0gbW9kZWxGb3JDdXJyZW50RG9jLnNjaGVtYS5fZ2V0U2NoZW1hKG9wdGlvbnMucGF0aCk7XG5cbiAgICAgICAgaWYgKHNjaGVtYUZvckN1cnJlbnREb2MgJiYgc2NoZW1hRm9yQ3VycmVudERvYy5jYXN0ZXIpIHtcbiAgICAgICAgICBzY2hlbWFGb3JDdXJyZW50RG9jID0gc2NoZW1hRm9yQ3VycmVudERvYy5jYXN0ZXI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjaGVtYUZvckN1cnJlbnREb2MgPSBzY2hlbWE7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcmlnaW5hbFNjaGVtYSAmJiBvcmlnaW5hbFNjaGVtYS5wYXRoLmVuZHNXaXRoKCcuJConKSkge1xuICAgICAgICBqdXN0T25lID0gIW9yaWdpbmFsU2NoZW1hLiRpc01vbmdvb3NlQXJyYXkgJiYgIW9yaWdpbmFsU2NoZW1hLl9hcnJheVBhdGg7XG4gICAgICB9IGVsc2UgaWYgKHNjaGVtYUZvckN1cnJlbnREb2MgIT0gbnVsbCkge1xuICAgICAgICBqdXN0T25lID0gIXNjaGVtYUZvckN1cnJlbnREb2MuJGlzTW9uZ29vc2VBcnJheSAmJiAhc2NoZW1hRm9yQ3VycmVudERvYy5fYXJyYXlQYXRoO1xuICAgICAgfVxuXG4gICAgICBpZiAoKHJlZiA9IGdldChzY2hlbWFGb3JDdXJyZW50RG9jLCAnb3B0aW9ucy5yZWYnKSkgIT0gbnVsbCkge1xuICAgICAgICBpZiAoc2NoZW1hRm9yQ3VycmVudERvYyAhPSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICBvcHRpb25zLnBhdGguZW5kc1dpdGgoJy4nICsgc2NoZW1hRm9yQ3VycmVudERvYy5wYXRoKSkge1xuICAgICAgICAgIC8vIEVuc3VyZSBjb3JyZWN0IGNvbnRleHQgZm9yIHJlZiBmdW5jdGlvbnM6IHN1YmRvYywgbm90IHRvcC1sZXZlbCBkb2MuIFNlZSBnaC04NDY5XG4gICAgICAgICAgbW9kZWxOYW1lcyA9IG5ldyBTZXQoKTtcblxuICAgICAgICAgIGNvbnN0IHN1YmRvY1BhdGggPSBvcHRpb25zLnBhdGguc2xpY2UoMCwgb3B0aW9ucy5wYXRoLmxlbmd0aCAtIHNjaGVtYUZvckN1cnJlbnREb2MucGF0aC5sZW5ndGggLSAxKTtcbiAgICAgICAgICBjb25zdCB2YWxzID0gbXBhdGguZ2V0KHN1YmRvY1BhdGgsIGRvYywgbG9va3VwTG9jYWxGaWVsZHMpO1xuICAgICAgICAgIGNvbnN0IHN1YmRvY3NCZWluZ1BvcHVsYXRlZCA9IEFycmF5LmlzQXJyYXkodmFscykgP1xuICAgICAgICAgICAgdXRpbHMuYXJyYXkuZmxhdHRlbih2YWxzKSA6XG4gICAgICAgICAgICAodmFscyA/IFt2YWxzXSA6IFtdKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHN1YmRvYyBvZiBzdWJkb2NzQmVpbmdQb3B1bGF0ZWQpIHtcbiAgICAgICAgICAgIG1vZGVsTmFtZXMuYWRkKGhhbmRsZVJlZkZ1bmN0aW9uKHJlZiwgc3ViZG9jKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN1YmRvY3NCZWluZ1BvcHVsYXRlZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG1vZGVsTmFtZXMgPSBbaGFuZGxlUmVmRnVuY3Rpb24ocmVmLCBkb2MpXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9kZWxOYW1lcyA9IEFycmF5LmZyb20obW9kZWxOYW1lcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZiA9IGhhbmRsZVJlZkZ1bmN0aW9uKHJlZiwgZG9jKTtcbiAgICAgICAgICBtb2RlbE5hbWVzID0gW3JlZl07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKHNjaGVtYUZvckN1cnJlbnREb2MgPSBnZXQoc2NoZW1hLCAnb3B0aW9ucy5yZWZQYXRoJykpICE9IG51bGwpIHtcbiAgICAgICAgaXNSZWZQYXRoID0gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiByZWZQYXRoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY29uc3Qgc3ViZG9jUGF0aCA9IG9wdGlvbnMucGF0aC5zbGljZSgwLCBvcHRpb25zLnBhdGgubGVuZ3RoIC0gc2NoZW1hRm9yQ3VycmVudERvYy5wYXRoLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIGNvbnN0IHZhbHMgPSBtcGF0aC5nZXQoc3ViZG9jUGF0aCwgZG9jLCBsb29rdXBMb2NhbEZpZWxkcyk7XG4gICAgICAgICAgY29uc3Qgc3ViZG9jc0JlaW5nUG9wdWxhdGVkID0gQXJyYXkuaXNBcnJheSh2YWxzKSA/XG4gICAgICAgICAgICB1dGlscy5hcnJheS5mbGF0dGVuKHZhbHMpIDpcbiAgICAgICAgICAgICh2YWxzID8gW3ZhbHNdIDogW10pO1xuXG4gICAgICAgICAgbW9kZWxOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHN1YmRvYyBvZiBzdWJkb2NzQmVpbmdQb3B1bGF0ZWQpIHtcbiAgICAgICAgICAgIHJlZlBhdGggPSByZWZQYXRoLmNhbGwoc3ViZG9jLCBzdWJkb2MsIG9wdGlvbnMucGF0aCk7XG4gICAgICAgICAgICBtb2RlbE5hbWVzRnJvbVJlZlBhdGgocmVmUGF0aCwgZG9jLCBvcHRpb25zLnBhdGgsIG1vZGVsU2NoZW1hLCBvcHRpb25zLl9xdWVyeVByb2plY3Rpb24pLlxuICAgICAgICAgICAgICBmb3JFYWNoKG5hbWUgPT4gbW9kZWxOYW1lcy5hZGQobmFtZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb2RlbE5hbWVzID0gQXJyYXkuZnJvbShtb2RlbE5hbWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb2RlbE5hbWVzID0gbW9kZWxOYW1lc0Zyb21SZWZQYXRoKHJlZlBhdGgsIGRvYywgb3B0aW9ucy5wYXRoLCBtb2RlbFNjaGVtYSwgb3B0aW9ucy5fcXVlcnlQcm9qZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghbW9kZWxOYW1lcykge1xuICAgICAgLy8gYE1vZGVsLnBvcHVsYXRlKClgIG9uIGEgUE9KTyB3aXRoIG5vIGtub3duIGxvY2FsIG1vZGVsLiBEZWZhdWx0IHRvIHVzaW5nIHRoZSBgTW9kZWxgXG4gICAgICBpZiAob3B0aW9ucy5fbG9jYWxNb2RlbCA9PSBudWxsKSB7XG4gICAgICAgIG1vZGVsTmFtZXMgPSBbbW9kZWwubW9kZWxOYW1lXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7IG1vZGVsTmFtZXM6IG1vZGVsTmFtZXMsIGp1c3RPbmU6IGp1c3RPbmUsIGlzUmVmUGF0aDogaXNSZWZQYXRoLCByZWZQYXRoOiByZWZQYXRoIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG1vZGVsTmFtZXMpKSB7XG4gICAgICBtb2RlbE5hbWVzID0gW21vZGVsTmFtZXNdO1xuICAgIH1cblxuICAgIHJldHVybiB7IG1vZGVsTmFtZXM6IG1vZGVsTmFtZXMsIGp1c3RPbmU6IGp1c3RPbmUsIGlzUmVmUGF0aDogaXNSZWZQYXRoLCByZWZQYXRoOiByZWZQYXRoIH07XG4gIH1cbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX3ZpcnR1YWxQb3B1bGF0ZShtb2RlbCwgZG9jcywgb3B0aW9ucywgX3ZpcnR1YWxSZXMpIHtcbiAgY29uc3QgbWFwID0gW107XG4gIGNvbnN0IGF2YWlsYWJsZSA9IHt9O1xuICBjb25zdCB2aXJ0dWFsID0gX3ZpcnR1YWxSZXMudmlydHVhbDtcblxuICBmb3IgKGNvbnN0IGRvYyBvZiBkb2NzKSB7XG4gICAgbGV0IG1vZGVsTmFtZXMgPSBudWxsO1xuICAgIGNvbnN0IGRhdGEgPSB7fTtcblxuICAgIC8vIGxvY2FsRmllbGQgYW5kIGZvcmVpZ25GaWVsZFxuICAgIGxldCBsb2NhbEZpZWxkO1xuICAgIGNvbnN0IHZpcnR1YWxQcmVmaXggPSBfdmlydHVhbFJlcy5uZXN0ZWRTY2hlbWFQYXRoID9cbiAgICAgIF92aXJ0dWFsUmVzLm5lc3RlZFNjaGVtYVBhdGggKyAnLicgOiAnJztcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMubG9jYWxGaWVsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGxvY2FsRmllbGQgPSBvcHRpb25zLmxvY2FsRmllbGQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmlydHVhbC5vcHRpb25zLmxvY2FsRmllbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGxvY2FsRmllbGQgPSB2aXJ0dWFsUHJlZml4ICsgdmlydHVhbC5vcHRpb25zLmxvY2FsRmllbGQuY2FsbChkb2MsIGRvYyk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZpcnR1YWwub3B0aW9ucy5sb2NhbEZpZWxkKSkge1xuICAgICAgbG9jYWxGaWVsZCA9IHZpcnR1YWwub3B0aW9ucy5sb2NhbEZpZWxkLm1hcChmaWVsZCA9PiB2aXJ0dWFsUHJlZml4ICsgZmllbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2NhbEZpZWxkID0gdmlydHVhbFByZWZpeCArIHZpcnR1YWwub3B0aW9ucy5sb2NhbEZpZWxkO1xuICAgIH1cbiAgICBkYXRhLmNvdW50ID0gdmlydHVhbC5vcHRpb25zLmNvdW50O1xuXG4gICAgaWYgKHZpcnR1YWwub3B0aW9ucy5za2lwICE9IG51bGwgJiYgIW9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3NraXAnKSkge1xuICAgICAgb3B0aW9ucy5za2lwID0gdmlydHVhbC5vcHRpb25zLnNraXA7XG4gICAgfVxuICAgIGlmICh2aXJ0dWFsLm9wdGlvbnMubGltaXQgIT0gbnVsbCAmJiAhb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnbGltaXQnKSkge1xuICAgICAgb3B0aW9ucy5saW1pdCA9IHZpcnR1YWwub3B0aW9ucy5saW1pdDtcbiAgICB9XG4gICAgaWYgKHZpcnR1YWwub3B0aW9ucy5wZXJEb2N1bWVudExpbWl0ICE9IG51bGwgJiYgIW9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3BlckRvY3VtZW50TGltaXQnKSkge1xuICAgICAgb3B0aW9ucy5wZXJEb2N1bWVudExpbWl0ID0gdmlydHVhbC5vcHRpb25zLnBlckRvY3VtZW50TGltaXQ7XG4gICAgfVxuICAgIGxldCBmb3JlaWduRmllbGQgPSB2aXJ0dWFsLm9wdGlvbnMuZm9yZWlnbkZpZWxkO1xuXG4gICAgaWYgKCFsb2NhbEZpZWxkIHx8ICFmb3JlaWduRmllbGQpIHtcbiAgICAgIHJldHVybiBuZXcgTW9uZ29vc2VFcnJvcihgQ2Fubm90IHBvcHVsYXRlIHZpcnR1YWwgXFxgJHtvcHRpb25zLnBhdGh9XFxgIG9uIG1vZGVsIFxcYCR7bW9kZWwubW9kZWxOYW1lfVxcYCwgYmVjYXVzZSBvcHRpb25zIFxcYGxvY2FsRmllbGRcXGAgYW5kIC8gb3IgXFxgZm9yZWlnbkZpZWxkXFxgIGFyZSBtaXNzaW5nYCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBsb2NhbEZpZWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBsb2NhbEZpZWxkID0gbG9jYWxGaWVsZC5jYWxsKGRvYywgZG9jKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBmb3JlaWduRmllbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZvcmVpZ25GaWVsZCA9IGZvcmVpZ25GaWVsZC5jYWxsKGRvYywgZG9jKTtcbiAgICB9XG5cbiAgICBkYXRhLmlzUmVmUGF0aCA9IGZhbHNlO1xuXG4gICAgLy8gYGp1c3RPbmUgPSBudWxsYCBtZWFucyB3ZSBkb24ndCBrbm93IGZyb20gdGhlIHNjaGVtYSB3aGV0aGVyIHRoZSBlbmRcbiAgICAvLyByZXN1bHQgc2hvdWxkIGJlIGFuIGFycmF5IG9yIGEgc2luZ2xlIGRvYy4gVGhpcyBjYW4gcmVzdWx0IGZyb21cbiAgICAvLyBwb3B1bGF0aW5nIGEgUE9KTyB1c2luZyBgTW9kZWwucG9wdWxhdGUoKWBcbiAgICBsZXQganVzdE9uZSA9IG51bGw7XG4gICAgaWYgKCdqdXN0T25lJyBpbiBvcHRpb25zICYmIG9wdGlvbnMuanVzdE9uZSAhPT0gdm9pZCAwKSB7XG4gICAgICBqdXN0T25lID0gb3B0aW9ucy5qdXN0T25lO1xuICAgIH1cblxuICAgIGlmICh2aXJ0dWFsLm9wdGlvbnMucmVmUGF0aCkge1xuICAgICAgbW9kZWxOYW1lcyA9XG4gICAgICAgIG1vZGVsTmFtZXNGcm9tUmVmUGF0aCh2aXJ0dWFsLm9wdGlvbnMucmVmUGF0aCwgZG9jLCBvcHRpb25zLnBhdGgpO1xuICAgICAganVzdE9uZSA9ICEhdmlydHVhbC5vcHRpb25zLmp1c3RPbmU7XG4gICAgICBkYXRhLmlzUmVmUGF0aCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh2aXJ0dWFsLm9wdGlvbnMucmVmKSB7XG4gICAgICBsZXQgbm9ybWFsaXplZFJlZjtcbiAgICAgIGlmICh0eXBlb2YgdmlydHVhbC5vcHRpb25zLnJlZiA9PT0gJ2Z1bmN0aW9uJyAmJiAhdmlydHVhbC5vcHRpb25zLnJlZlttb2RlbFN5bWJvbF0pIHtcbiAgICAgICAgbm9ybWFsaXplZFJlZiA9IHZpcnR1YWwub3B0aW9ucy5yZWYuY2FsbChkb2MsIGRvYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtYWxpemVkUmVmID0gdmlydHVhbC5vcHRpb25zLnJlZjtcbiAgICAgIH1cbiAgICAgIGp1c3RPbmUgPSAhIXZpcnR1YWwub3B0aW9ucy5qdXN0T25lO1xuICAgICAgLy8gV2hlbiByZWZlcmVuY2luZyBuZXN0ZWQgYXJyYXlzLCB0aGUgcmVmIHNob3VsZCBiZSBhbiBBcnJheVxuICAgICAgLy8gb2YgbW9kZWxOYW1lcy5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vcm1hbGl6ZWRSZWYpKSB7XG4gICAgICAgIG1vZGVsTmFtZXMgPSBub3JtYWxpemVkUmVmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW9kZWxOYW1lcyA9IFtub3JtYWxpemVkUmVmXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkYXRhLmlzVmlydHVhbCA9IHRydWU7XG4gICAgZGF0YS52aXJ0dWFsID0gdmlydHVhbDtcbiAgICBkYXRhLmp1c3RPbmUgPSBqdXN0T25lO1xuXG4gICAgLy8gYG1hdGNoYFxuICAgIGNvbnN0IGJhc2VNYXRjaCA9IGdldChkYXRhLCAndmlydHVhbC5vcHRpb25zLm1hdGNoJywgbnVsbCkgfHxcbiAgICAgIGdldChkYXRhLCAndmlydHVhbC5vcHRpb25zLm9wdGlvbnMubWF0Y2gnLCBudWxsKTtcbiAgICBsZXQgbWF0Y2ggPSBnZXQob3B0aW9ucywgJ21hdGNoJywgbnVsbCkgfHwgYmFzZU1hdGNoO1xuXG4gICAgbGV0IGhhc01hdGNoRnVuY3Rpb24gPSB0eXBlb2YgbWF0Y2ggPT09ICdmdW5jdGlvbic7XG4gICAgaWYgKGhhc01hdGNoRnVuY3Rpb24pIHtcbiAgICAgIG1hdGNoID0gbWF0Y2guY2FsbChkb2MsIGRvYywgZGF0YS52aXJ0dWFsKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShsb2NhbEZpZWxkKSAmJiBBcnJheS5pc0FycmF5KGZvcmVpZ25GaWVsZCkgJiYgbG9jYWxGaWVsZC5sZW5ndGggPT09IGZvcmVpZ25GaWVsZC5sZW5ndGgpIHtcbiAgICAgIG1hdGNoID0gT2JqZWN0LmFzc2lnbih7fSwgbWF0Y2gpO1xuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsb2NhbEZpZWxkLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIG1hdGNoW2ZvcmVpZ25GaWVsZFtpXV0gPSBjb252ZXJ0VG9faWQobXBhdGguZ2V0KGxvY2FsRmllbGRbaV0sIGRvYywgbG9va3VwTG9jYWxGaWVsZHMpLCBtb2RlbC5zY2hlbWEpO1xuICAgICAgICBoYXNNYXRjaEZ1bmN0aW9uID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgbG9jYWxGaWVsZCA9IGxvY2FsRmllbGRbMF07XG4gICAgICBmb3JlaWduRmllbGQgPSBmb3JlaWduRmllbGRbMF07XG4gICAgfVxuICAgIGRhdGEubG9jYWxGaWVsZCA9IGxvY2FsRmllbGQ7XG4gICAgZGF0YS5mb3JlaWduRmllbGQgPSBmb3JlaWduRmllbGQ7XG4gICAgZGF0YS5tYXRjaCA9IG1hdGNoO1xuICAgIGRhdGEuaGFzTWF0Y2hGdW5jdGlvbiA9IGhhc01hdGNoRnVuY3Rpb247XG5cbiAgICAvLyBHZXQgbG9jYWwgZmllbGRzXG4gICAgY29uc3QgcmV0ID0gX2dldExvY2FsRmllbGRWYWx1ZXMoZG9jLCBsb2NhbEZpZWxkLCBtb2RlbCwgb3B0aW9ucywgdmlydHVhbCk7XG5cbiAgICB0cnkge1xuICAgICAgYWRkTW9kZWxOYW1lc1RvTWFwKG1vZGVsLCBtYXAsIGF2YWlsYWJsZSwgbW9kZWxOYW1lcywgb3B0aW9ucywgZGF0YSwgcmV0LCBkb2MpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWFwO1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGFkZE1vZGVsTmFtZXNUb01hcChtb2RlbCwgbWFwLCBhdmFpbGFibGUsIG1vZGVsTmFtZXMsIG9wdGlvbnMsIGRhdGEsIHJldCwgZG9jLCBzY2hlbWFPcHRpb25zLCB1bnBvcHVsYXRlZFZhbHVlKSB7XG4gIC8vIGBQb3B1bGF0ZU9wdGlvbnMjY29ubmVjdGlvbmA6IGlmIHRoZSBtb2RlbCBpcyBwYXNzZWQgYXMgYSBzdHJpbmcsIHRoZVxuICAvLyBjb25uZWN0aW9uIG1hdHRlcnMgYmVjYXVzZSBkaWZmZXJlbnQgY29ubmVjdGlvbnMgaGF2ZSBkaWZmZXJlbnQgbW9kZWxzLlxuICBjb25zdCBjb25uZWN0aW9uID0gb3B0aW9ucy5jb25uZWN0aW9uICE9IG51bGwgPyBvcHRpb25zLmNvbm5lY3Rpb24gOiBtb2RlbC5kYjtcblxuICB1bnBvcHVsYXRlZFZhbHVlID0gdW5wb3B1bGF0ZWRWYWx1ZSA9PT0gdm9pZCAwID8gcmV0IDogdW5wb3B1bGF0ZWRWYWx1ZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodW5wb3B1bGF0ZWRWYWx1ZSkpIHtcbiAgICB1bnBvcHVsYXRlZFZhbHVlID0gdXRpbHMuY2xvbmVBcnJheXModW5wb3B1bGF0ZWRWYWx1ZSk7XG4gIH1cblxuICBpZiAobW9kZWxOYW1lcyA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IGsgPSBtb2RlbE5hbWVzLmxlbmd0aDtcbiAgd2hpbGUgKGstLSkge1xuICAgIGxldCBtb2RlbE5hbWUgPSBtb2RlbE5hbWVzW2tdO1xuICAgIGlmIChtb2RlbE5hbWUgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgbGV0IE1vZGVsO1xuICAgIGlmIChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWxbbW9kZWxTeW1ib2xdKSB7XG4gICAgICBNb2RlbCA9IG9wdGlvbnMubW9kZWw7XG4gICAgfSBlbHNlIGlmIChtb2RlbE5hbWVbbW9kZWxTeW1ib2xdKSB7XG4gICAgICBNb2RlbCA9IG1vZGVsTmFtZTtcbiAgICAgIG1vZGVsTmFtZSA9IE1vZGVsLm1vZGVsTmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgTW9kZWwgPSBfZ2V0TW9kZWxGcm9tQ29ubihjb25uZWN0aW9uLCBtb2RlbE5hbWUpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChyZXQgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBNb2RlbCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGlkcyA9IHJldDtcbiAgICBjb25zdCBmbGF0ID0gQXJyYXkuaXNBcnJheShyZXQpID8gdXRpbHMuYXJyYXkuZmxhdHRlbihyZXQpIDogW107XG5cbiAgICBjb25zdCBtb2RlbE5hbWVzRm9yUmVmUGF0aCA9IGRhdGEubW9kZWxOYW1lc0luT3JkZXIgPyBkYXRhLm1vZGVsTmFtZXNJbk9yZGVyIDogbW9kZWxOYW1lcztcbiAgICBpZiAoZGF0YS5pc1JlZlBhdGggJiYgQXJyYXkuaXNBcnJheShyZXQpICYmIGZsYXQubGVuZ3RoID09PSBtb2RlbE5hbWVzRm9yUmVmUGF0aC5sZW5ndGgpIHtcbiAgICAgIGlkcyA9IGZsYXQuZmlsdGVyKCh2YWwsIGkpID0+IG1vZGVsTmFtZXNGb3JSZWZQYXRoW2ldID09PSBtb2RlbE5hbWUpO1xuICAgIH1cblxuICAgIGNvbnN0IHBlckRvY3VtZW50TGltaXQgPSBvcHRpb25zLnBlckRvY3VtZW50TGltaXQgPT0gbnVsbCA/XG4gICAgICBnZXQob3B0aW9ucywgJ29wdGlvbnMucGVyRG9jdW1lbnRMaW1pdCcsIG51bGwpIDpcbiAgICAgIG9wdGlvbnMucGVyRG9jdW1lbnRMaW1pdDtcblxuICAgIGlmICghYXZhaWxhYmxlW21vZGVsTmFtZV0gfHwgcGVyRG9jdW1lbnRMaW1pdCAhPSBudWxsKSB7XG4gICAgICBjb25zdCBjdXJyZW50T3B0aW9ucyA9IHtcbiAgICAgICAgbW9kZWw6IE1vZGVsXG4gICAgICB9O1xuICAgICAgaWYgKGRhdGEuaXNWaXJ0dWFsICYmIGdldChkYXRhLnZpcnR1YWwsICdvcHRpb25zLm9wdGlvbnMnKSkge1xuICAgICAgICBjdXJyZW50T3B0aW9ucy5vcHRpb25zID0gY2xvbmUoZGF0YS52aXJ0dWFsLm9wdGlvbnMub3B0aW9ucyk7XG4gICAgICB9IGVsc2UgaWYgKHNjaGVtYU9wdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBjdXJyZW50T3B0aW9ucy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgc2NoZW1hT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICB1dGlscy5tZXJnZShjdXJyZW50T3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgIC8vIFVzZWQgaW50ZXJuYWxseSBmb3IgY2hlY2tpbmcgd2hhdCBtb2RlbCB3YXMgdXNlZCB0byBwb3B1bGF0ZSB0aGlzXG4gICAgICAvLyBwYXRoLlxuICAgICAgb3B0aW9uc1twb3B1bGF0ZU1vZGVsU3ltYm9sXSA9IE1vZGVsO1xuICAgICAgY3VycmVudE9wdGlvbnNbcG9wdWxhdGVNb2RlbFN5bWJvbF0gPSBNb2RlbDtcbiAgICAgIGF2YWlsYWJsZVttb2RlbE5hbWVdID0ge1xuICAgICAgICBtb2RlbDogTW9kZWwsXG4gICAgICAgIG9wdGlvbnM6IGN1cnJlbnRPcHRpb25zLFxuICAgICAgICBtYXRjaDogZGF0YS5oYXNNYXRjaEZ1bmN0aW9uID8gW2RhdGEubWF0Y2hdIDogZGF0YS5tYXRjaCxcbiAgICAgICAgZG9jczogW2RvY10sXG4gICAgICAgIGlkczogW2lkc10sXG4gICAgICAgIGFsbElkczogW3JldF0sXG4gICAgICAgIHVucG9wdWxhdGVkVmFsdWVzOiBbdW5wb3B1bGF0ZWRWYWx1ZV0sXG4gICAgICAgIGxvY2FsRmllbGQ6IG5ldyBTZXQoW2RhdGEubG9jYWxGaWVsZF0pLFxuICAgICAgICBmb3JlaWduRmllbGQ6IG5ldyBTZXQoW2RhdGEuZm9yZWlnbkZpZWxkXSksXG4gICAgICAgIGp1c3RPbmU6IGRhdGEuanVzdE9uZSxcbiAgICAgICAgaXNWaXJ0dWFsOiBkYXRhLmlzVmlydHVhbCxcbiAgICAgICAgdmlydHVhbDogZGF0YS52aXJ0dWFsLFxuICAgICAgICBjb3VudDogZGF0YS5jb3VudCxcbiAgICAgICAgW3BvcHVsYXRlTW9kZWxTeW1ib2xdOiBNb2RlbFxuICAgICAgfTtcbiAgICAgIG1hcC5wdXNoKGF2YWlsYWJsZVttb2RlbE5hbWVdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXZhaWxhYmxlW21vZGVsTmFtZV0ubG9jYWxGaWVsZC5hZGQoZGF0YS5sb2NhbEZpZWxkKTtcbiAgICAgIGF2YWlsYWJsZVttb2RlbE5hbWVdLmZvcmVpZ25GaWVsZC5hZGQoZGF0YS5mb3JlaWduRmllbGQpO1xuICAgICAgYXZhaWxhYmxlW21vZGVsTmFtZV0uZG9jcy5wdXNoKGRvYyk7XG4gICAgICBhdmFpbGFibGVbbW9kZWxOYW1lXS5pZHMucHVzaChpZHMpO1xuICAgICAgYXZhaWxhYmxlW21vZGVsTmFtZV0uYWxsSWRzLnB1c2gocmV0KTtcbiAgICAgIGF2YWlsYWJsZVttb2RlbE5hbWVdLnVucG9wdWxhdGVkVmFsdWVzLnB1c2godW5wb3B1bGF0ZWRWYWx1ZSk7XG4gICAgICBpZiAoZGF0YS5oYXNNYXRjaEZ1bmN0aW9uKSB7XG4gICAgICAgIGF2YWlsYWJsZVttb2RlbE5hbWVdLm1hdGNoLnB1c2goZGF0YS5tYXRjaCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIF9nZXRNb2RlbEZyb21Db25uKGNvbm4sIG1vZGVsTmFtZSkge1xuICAvKiBJZiB0aGlzIGNvbm5lY3Rpb24gaGFzIGEgcGFyZW50IGZyb20gYHVzZURiKClgLCBidWJibGUgdXAgdG8gcGFyZW50J3MgbW9kZWxzICovXG4gIGlmIChjb25uLm1vZGVsc1ttb2RlbE5hbWVdID09IG51bGwgJiYgY29ubi5fcGFyZW50ICE9IG51bGwpIHtcbiAgICByZXR1cm4gX2dldE1vZGVsRnJvbUNvbm4oY29ubi5fcGFyZW50LCBtb2RlbE5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIGNvbm4ubW9kZWwobW9kZWxOYW1lKTtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBoYW5kbGVSZWZGdW5jdGlvbihyZWYsIGRvYykge1xuICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJyAmJiAhcmVmW21vZGVsU3ltYm9sXSkge1xuICAgIHJldHVybiByZWYuY2FsbChkb2MsIGRvYyk7XG4gIH1cbiAgcmV0dXJuIHJlZjtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfZ2V0TG9jYWxGaWVsZFZhbHVlcyhkb2MsIGxvY2FsRmllbGQsIG1vZGVsLCBvcHRpb25zLCB2aXJ0dWFsLCBzY2hlbWEpIHtcbiAgLy8gR2V0IExvY2FsIGZpZWxkc1xuICBjb25zdCBsb2NhbEZpZWxkUGF0aFR5cGUgPSBtb2RlbC5zY2hlbWEuX2dldFBhdGhUeXBlKGxvY2FsRmllbGQpO1xuICBjb25zdCBsb2NhbEZpZWxkUGF0aCA9IGxvY2FsRmllbGRQYXRoVHlwZSA9PT0gJ3JlYWwnID9cbiAgICBtb2RlbC5zY2hlbWEucGF0aChsb2NhbEZpZWxkKSA6XG4gICAgbG9jYWxGaWVsZFBhdGhUeXBlLnNjaGVtYTtcbiAgY29uc3QgbG9jYWxGaWVsZEdldHRlcnMgPSBsb2NhbEZpZWxkUGF0aCAmJiBsb2NhbEZpZWxkUGF0aC5nZXR0ZXJzID9cbiAgICBsb2NhbEZpZWxkUGF0aC5nZXR0ZXJzIDogW107XG5cbiAgbG9jYWxGaWVsZCA9IGxvY2FsRmllbGRQYXRoICE9IG51bGwgJiYgbG9jYWxGaWVsZFBhdGguaW5zdGFuY2UgPT09ICdFbWJlZGRlZCcgPyBsb2NhbEZpZWxkICsgJy5faWQnIDogbG9jYWxGaWVsZDtcblxuICBjb25zdCBfcG9wdWxhdGVPcHRpb25zID0gZ2V0KG9wdGlvbnMsICdvcHRpb25zJywge30pO1xuXG4gIGNvbnN0IGdldHRlcnMgPSAnZ2V0dGVycycgaW4gX3BvcHVsYXRlT3B0aW9ucyA/XG4gICAgX3BvcHVsYXRlT3B0aW9ucy5nZXR0ZXJzIDpcbiAgICBnZXQodmlydHVhbCwgJ29wdGlvbnMuZ2V0dGVycycsIGZhbHNlKTtcbiAgaWYgKGxvY2FsRmllbGRHZXR0ZXJzLmxlbmd0aCAhPT0gMCAmJiBnZXR0ZXJzKSB7XG4gICAgY29uc3QgaHlkcmF0ZWREb2MgPSAoZG9jLiRfXyAhPSBudWxsKSA/IGRvYyA6IG1vZGVsLmh5ZHJhdGUoZG9jKTtcbiAgICBjb25zdCBsb2NhbEZpZWxkVmFsdWUgPSB1dGlscy5nZXRWYWx1ZShsb2NhbEZpZWxkLCBkb2MpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGxvY2FsRmllbGRWYWx1ZSkpIHtcbiAgICAgIGNvbnN0IGxvY2FsRmllbGRIeWRyYXRlZFZhbHVlID0gdXRpbHMuZ2V0VmFsdWUobG9jYWxGaWVsZC5zcGxpdCgnLicpLnNsaWNlKDAsIC0xKSwgaHlkcmF0ZWREb2MpO1xuICAgICAgcmV0dXJuIGxvY2FsRmllbGRWYWx1ZS5tYXAoKGxvY2FsRmllbGRBcnJWYWwsIGxvY2FsRmllbGRBcnJJbmRleCkgPT5cbiAgICAgICAgbG9jYWxGaWVsZFBhdGguYXBwbHlHZXR0ZXJzKGxvY2FsRmllbGRBcnJWYWwsIGxvY2FsRmllbGRIeWRyYXRlZFZhbHVlW2xvY2FsRmllbGRBcnJJbmRleF0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGxvY2FsRmllbGRQYXRoLmFwcGx5R2V0dGVycyhsb2NhbEZpZWxkVmFsdWUsIGh5ZHJhdGVkRG9jKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbnZlcnRUb19pZChtcGF0aC5nZXQobG9jYWxGaWVsZCwgZG9jLCBsb29rdXBMb2NhbEZpZWxkcyksIHNjaGVtYSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgX2lkIG9mIGB2YWxgIGlmIGEgRG9jdW1lbnQgb3IgQXJyYXkgb2YgRG9jdW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl8RG9jdW1lbnR8QW55fSB2YWxcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEByZXR1cm4ge0FycmF5fERvY3VtZW50fEFueX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbnZlcnRUb19pZCh2YWwsIHNjaGVtYSkge1xuICBpZiAodmFsICE9IG51bGwgJiYgdmFsLiRfXyAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbC5faWQ7XG4gIH1cbiAgaWYgKHZhbCAhPSBudWxsICYmIHZhbC5faWQgIT0gbnVsbCAmJiAoc2NoZW1hID09IG51bGwgfHwgIXNjaGVtYS4kaXNTY2hlbWFNYXApKSB7XG4gICAgcmV0dXJuIHZhbC5faWQ7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgY29uc3QgcmF3VmFsID0gdmFsLl9fYXJyYXkgIT0gbnVsbCA/IHZhbC5fX2FycmF5IDogdmFsO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmF3VmFsLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAocmF3VmFsW2ldICE9IG51bGwgJiYgcmF3VmFsW2ldLiRfXyAhPSBudWxsKSB7XG4gICAgICAgIHJhd1ZhbFtpXSA9IHJhd1ZhbFtpXS5faWQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh1dGlscy5pc01vbmdvb3NlQXJyYXkodmFsKSAmJiB2YWwuJHNjaGVtYSgpKSB7XG4gICAgICByZXR1cm4gdmFsLiRzY2hlbWEoKS5fY2FzdEZvclBvcHVsYXRlKHZhbCwgdmFsLiRwYXJlbnQoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdLmNvbmNhdCh2YWwpO1xuICB9XG5cbiAgLy8gYHBvcHVsYXRlKCdtYXAnKWAgbWF5IGJlIGFuIG9iamVjdCBpZiBwb3B1bGF0aW5nIG9uIGEgZG9jIHRoYXQgaGFzbid0XG4gIC8vIGJlZW4gaHlkcmF0ZWQgeWV0XG4gIGlmIChnZXRDb25zdHJ1Y3Rvck5hbWUodmFsKSA9PT0gJ09iamVjdCcgJiZcbiAgICAgIC8vIFRoZSBpbnRlbnQgaGVyZSBpcyB3ZSBzaG91bGQgb25seSBmbGF0dGVuIHRoZSBvYmplY3QgaWYgd2UgZXhwZWN0XG4gICAgICAvLyB0byBnZXQgYSBNYXAgaW4gdGhlIGVuZC4gQXZvaWQgZG9pbmcgdGhpcyBmb3IgbWl4ZWQgdHlwZXMuXG4gICAgICAoc2NoZW1hID09IG51bGwgfHwgc2NoZW1hW3NjaGVtYU1peGVkU3ltYm9sXSA9PSBudWxsKSkge1xuICAgIGNvbnN0IHJldCA9IFtdO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHZhbCkpIHtcbiAgICAgIHJldC5wdXNoKHZhbFtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICAvLyBJZiBkb2MgaGFzIGFscmVhZHkgYmVlbiBoeWRyYXRlZCwgZS5nLiBgZG9jLnBvcHVsYXRlKCdtYXAnKWBcbiAgLy8gdGhlbiBgdmFsYCB3aWxsIGFscmVhZHkgYmUgYSBtYXBcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIE1hcCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHZhbC52YWx1ZXMoKSk7XG4gIH1cblxuICByZXR1cm4gdmFsO1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9maW5kUmVmUGF0aEZvckRpc2NyaW1pbmF0b3JzKGRvYywgbW9kZWxTY2hlbWEsIGRhdGEsIG9wdGlvbnMsIG5vcm1hbGl6ZWRSZWZQYXRoLCByZXQpIHtcbiAgLy8gUmU6IGdoLTg0NTIuIEVtYmVkZGVkIGRpc2NyaW1pbmF0b3JzIG1heSBub3QgaGF2ZSBgcmVmUGF0aGAsIHNvIGNsZWFyXG4gIC8vIG91dCBlbWJlZGRlZCBkaXNjcmltaW5hdG9yIGRvY3MgdGhhdCBkb24ndCBoYXZlIGEgYHJlZlBhdGhgIG9uIHRoZVxuICAvLyBwb3B1bGF0ZWQgcGF0aC5cbiAgaWYgKCFkYXRhLmlzUmVmUGF0aCB8fCBub3JtYWxpemVkUmVmUGF0aCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgcGllY2VzID0gbm9ybWFsaXplZFJlZlBhdGguc3BsaXQoJy4nKTtcbiAgbGV0IGN1ciA9ICcnO1xuICBsZXQgbW9kZWxOYW1lcyA9IHZvaWQgMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwaWVjZXMubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBwaWVjZSA9IHBpZWNlc1tpXTtcbiAgICBjdXIgPSBjdXIgKyAoY3VyLmxlbmd0aCA9PT0gMCA/ICcnIDogJy4nKSArIHBpZWNlO1xuICAgIGNvbnN0IHNjaGVtYXR5cGUgPSBtb2RlbFNjaGVtYS5wYXRoKGN1cik7XG4gICAgaWYgKHNjaGVtYXR5cGUgIT0gbnVsbCAmJlxuICAgICAgICBzY2hlbWF0eXBlLiRpc01vbmdvb3NlQXJyYXkgJiZcbiAgICAgICAgc2NoZW1hdHlwZS5jYXN0ZXIuZGlzY3JpbWluYXRvcnMgIT0gbnVsbCAmJlxuICAgICAgICBPYmplY3Qua2V5cyhzY2hlbWF0eXBlLmNhc3Rlci5kaXNjcmltaW5hdG9ycykubGVuZ3RoICE9PSAwKSB7XG4gICAgICBjb25zdCBzdWJkb2NzID0gdXRpbHMuZ2V0VmFsdWUoY3VyLCBkb2MpO1xuICAgICAgY29uc3QgcmVtbmFudCA9IG9wdGlvbnMucGF0aC5zdWJzdHJpbmcoY3VyLmxlbmd0aCArIDEpO1xuICAgICAgY29uc3QgZGlzY3JpbWluYXRvcktleSA9IHNjaGVtYXR5cGUuY2FzdGVyLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXk7XG4gICAgICBtb2RlbE5hbWVzID0gW107XG4gICAgICBmb3IgKGNvbnN0IHN1YmRvYyBvZiBzdWJkb2NzKSB7XG4gICAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JOYW1lID0gdXRpbHMuZ2V0VmFsdWUoZGlzY3JpbWluYXRvcktleSwgc3ViZG9jKTtcbiAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvciA9IHNjaGVtYXR5cGUuY2FzdGVyLmRpc2NyaW1pbmF0b3JzW2Rpc2NyaW1pbmF0b3JOYW1lXTtcbiAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvclNjaGVtYSA9IGRpc2NyaW1pbmF0b3IgJiYgZGlzY3JpbWluYXRvci5zY2hlbWE7XG4gICAgICAgIGlmIChkaXNjcmltaW5hdG9yU2NoZW1hID09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBfcGF0aCA9IGRpc2NyaW1pbmF0b3JTY2hlbWEucGF0aChyZW1uYW50KTtcbiAgICAgICAgaWYgKF9wYXRoID09IG51bGwgfHwgX3BhdGgub3B0aW9ucy5yZWZQYXRoID09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBkb2NWYWx1ZSA9IHV0aWxzLmdldFZhbHVlKGRhdGEubG9jYWxGaWVsZC5zdWJzdHJpbmcoY3VyLmxlbmd0aCArIDEpLCBzdWJkb2MpO1xuICAgICAgICAgIHJldC5mb3JFYWNoKCh2LCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAodiA9PT0gZG9jVmFsdWUpIHtcbiAgICAgICAgICAgICAgcmV0W2ldID0gU2tpcFBvcHVsYXRlVmFsdWUodik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9kZWxOYW1lID0gdXRpbHMuZ2V0VmFsdWUocGllY2VzLnNsaWNlKGkgKyAxKS5qb2luKCcuJyksIHN1YmRvYyk7XG4gICAgICAgIG1vZGVsTmFtZXMucHVzaChtb2RlbE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtb2RlbE5hbWVzO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/populate/getSchemaTypes.js":
/*!*******************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/populate/getSchemaTypes.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nconst Mixed = __webpack_require__(/*! ../../schema/mixed */ \"../backend/node_modules/mongoose/lib/schema/mixed.js\");\nconst get = __webpack_require__(/*! ../get */ \"../backend/node_modules/mongoose/lib/helpers/get.js\");\nconst getDiscriminatorByValue = __webpack_require__(/*! ../discriminator/getDiscriminatorByValue */ \"../backend/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\nconst leanPopulateMap = __webpack_require__(/*! ./leanPopulateMap */ \"../backend/node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js\");\nconst mpath = __webpack_require__(/*! mpath */ \"../backend/node_modules/mpath/index.js\");\n\nconst populateModelSymbol = (__webpack_require__(/*! ../symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").populateModelSymbol);\n\n/**\n * Given a model and its schema, find all possible schema types for `path`,\n * including searching through discriminators. If `doc` is specified, will\n * use the doc's values for discriminator keys when searching, otherwise\n * will search all discriminators.\n *\n * @param {Model} model\n * @param {Schema} schema\n * @param {Object} doc POJO\n * @param {string} path\n * @api private\n */\n\nmodule.exports = function getSchemaTypes(model, schema, doc, path) {\n  const pathschema = schema.path(path);\n  const topLevelDoc = doc;\n  if (pathschema) {\n    return pathschema;\n  }\n\n  const discriminatorKey = schema.discriminatorMapping &&\n    schema.discriminatorMapping.key;\n  if (discriminatorKey && model != null) {\n    if (doc != null && doc[discriminatorKey] != null) {\n      const discriminator = getDiscriminatorByValue(model.discriminators, doc[discriminatorKey]);\n      schema = discriminator ? discriminator.schema : schema;\n    } else if (model.discriminators != null) {\n      return Object.keys(model.discriminators).reduce((arr, name) => {\n        const disc = model.discriminators[name];\n        return arr.concat(getSchemaTypes(disc, disc.schema, null, path));\n      }, []);\n    }\n  }\n\n  function search(parts, schema, subdoc, nestedPath) {\n    let p = parts.length + 1;\n    let foundschema;\n    let trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema == null) {\n        continue;\n      }\n\n      if (foundschema.caster) {\n        // array of Mixed?\n        if (foundschema.caster instanceof Mixed) {\n          return foundschema.caster;\n        }\n\n        let schemas = null;\n        if (foundschema.schema != null && foundschema.schema.discriminators != null) {\n          const discriminators = foundschema.schema.discriminators;\n          const discriminatorKeyPath = trypath + '.' +\n            foundschema.schema.options.discriminatorKey;\n          const keys = subdoc ? mpath.get(discriminatorKeyPath, subdoc) || [] : [];\n          schemas = Object.keys(discriminators).\n            reduce(function(cur, discriminator) {\n              const tiedValue = discriminators[discriminator].discriminatorMapping.value;\n              if (doc == null || keys.indexOf(discriminator) !== -1 || keys.indexOf(tiedValue) !== -1) {\n                cur.push(discriminators[discriminator]);\n              }\n              return cur;\n            }, []);\n        }\n\n        // Now that we found the array, we need to check if there\n        // are remaining document paths to look up for casting.\n        // Also we need to handle array.$.path since schema.path\n        // doesn't work for that.\n        // If there is no foundschema.schema we are dealing with\n        // a path like array.$\n        if (p !== parts.length && foundschema.schema) {\n          let ret;\n          if (parts[p] === '$') {\n            if (p + 1 === parts.length) {\n              // comments.$\n              return foundschema;\n            }\n            // comments.$.comments.$.title\n            ret = search(\n              parts.slice(p + 1),\n              schema,\n              subdoc ? mpath.get(trypath, subdoc) : null,\n              nestedPath.concat(parts.slice(0, p))\n            );\n            if (ret) {\n              ret.$parentSchemaDocArray = ret.$parentSchemaDocArray ||\n                (foundschema.schema.$isSingleNested ? null : foundschema);\n            }\n            return ret;\n          }\n\n          if (schemas != null && schemas.length > 0) {\n            ret = [];\n            for (const schema of schemas) {\n              const _ret = search(\n                parts.slice(p),\n                schema,\n                subdoc ? mpath.get(trypath, subdoc) : null,\n                nestedPath.concat(parts.slice(0, p))\n              );\n              if (_ret != null) {\n                _ret.$parentSchemaDocArray = _ret.$parentSchemaDocArray ||\n                  (foundschema.schema.$isSingleNested ? null : foundschema);\n                if (_ret.$parentSchemaDocArray) {\n                  ret.$parentSchemaDocArray = _ret.$parentSchemaDocArray;\n                }\n                ret.push(_ret);\n              }\n            }\n            return ret;\n          } else {\n            ret = search(\n              parts.slice(p),\n              foundschema.schema,\n              subdoc ? mpath.get(trypath, subdoc) : null,\n              nestedPath.concat(parts.slice(0, p))\n            );\n\n            if (ret) {\n              ret.$parentSchemaDocArray = ret.$parentSchemaDocArray ||\n                (foundschema.schema.$isSingleNested ? null : foundschema);\n            }\n            return ret;\n          }\n        } else if (p !== parts.length &&\n            foundschema.$isMongooseArray &&\n            foundschema.casterConstructor.$isMongooseArray) {\n          // Nested arrays. Drill down to the bottom of the nested array.\n          let type = foundschema;\n          while (type.$isMongooseArray && !type.$isMongooseDocumentArray) {\n            type = type.casterConstructor;\n          }\n\n          const ret = search(\n            parts.slice(p),\n            type.schema,\n            null,\n            nestedPath.concat(parts.slice(0, p))\n          );\n          if (ret != null) {\n            return ret;\n          }\n\n          if (type.schema.discriminators) {\n            const discriminatorPaths = [];\n            for (const discriminatorName of Object.keys(type.schema.discriminators)) {\n              const _schema = type.schema.discriminators[discriminatorName] || type.schema;\n              const ret = search(parts.slice(p), _schema, null, nestedPath.concat(parts.slice(0, p)));\n              if (ret != null) {\n                discriminatorPaths.push(ret);\n              }\n            }\n            if (discriminatorPaths.length > 0) {\n              return discriminatorPaths;\n            }\n          }\n        }\n      } else if (foundschema.$isSchemaMap && foundschema.$__schemaType instanceof Mixed) {\n        return foundschema.$__schemaType;\n      }\n\n      const fullPath = nestedPath.concat([trypath]).join('.');\n      if (topLevelDoc != null && topLevelDoc.$__ && topLevelDoc.$populated(fullPath) && p < parts.length) {\n        const model = doc.$__.populated[fullPath].options[populateModelSymbol];\n        if (model != null) {\n          const ret = search(\n            parts.slice(p),\n            model.schema,\n            subdoc ? mpath.get(trypath, subdoc) : null,\n            nestedPath.concat(parts.slice(0, p))\n          );\n\n          return ret;\n        }\n      }\n\n      const _val = get(topLevelDoc, trypath);\n      if (_val != null) {\n        const model = Array.isArray(_val) && _val.length > 0 ?\n          leanPopulateMap.get(_val[0]) :\n          leanPopulateMap.get(_val);\n        // Populated using lean, `leanPopulateMap` value is the foreign model\n        const schema = model != null ? model.schema : null;\n        if (schema != null) {\n          const ret = search(\n            parts.slice(p),\n            schema,\n            subdoc ? mpath.get(trypath, subdoc) : null,\n            nestedPath.concat(parts.slice(0, p))\n          );\n\n          if (ret != null) {\n            ret.$parentSchemaDocArray = ret.$parentSchemaDocArray ||\n              (schema.$isSingleNested ? null : schema);\n            return ret;\n          }\n        }\n      }\n      return foundschema;\n    }\n  }\n  // look for arrays\n  const parts = path.split('.');\n  for (let i = 0; i < parts.length; ++i) {\n    if (parts[i] === '$') {\n      // Re: gh-5628, because `schema.path()` doesn't take $ into account.\n      parts[i] = '0';\n    }\n  }\n  return search(parts, schema, doc, []);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvZ2V0U2NoZW1hVHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLGNBQWMsbUJBQU8sQ0FBQyxnRkFBb0I7QUFDMUMsWUFBWSxtQkFBTyxDQUFDLG1FQUFRO0FBQzVCLGdDQUFnQyxtQkFBTyxDQUFDLHVJQUEwQztBQUNsRix3QkFBd0IsbUJBQU8sQ0FBQyxtR0FBbUI7QUFDbkQsY0FBYyxtQkFBTyxDQUFDLHFEQUFPOztBQUU3Qiw0QkFBNEIsc0hBQXlDOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS9nZXRTY2hlbWFUeXBlcy5qcz83NjNlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5jb25zdCBNaXhlZCA9IHJlcXVpcmUoJy4uLy4uL3NjaGVtYS9taXhlZCcpO1xuY29uc3QgZ2V0ID0gcmVxdWlyZSgnLi4vZ2V0Jyk7XG5jb25zdCBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZSA9IHJlcXVpcmUoJy4uL2Rpc2NyaW1pbmF0b3IvZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUnKTtcbmNvbnN0IGxlYW5Qb3B1bGF0ZU1hcCA9IHJlcXVpcmUoJy4vbGVhblBvcHVsYXRlTWFwJyk7XG5jb25zdCBtcGF0aCA9IHJlcXVpcmUoJ21wYXRoJyk7XG5cbmNvbnN0IHBvcHVsYXRlTW9kZWxTeW1ib2wgPSByZXF1aXJlKCcuLi9zeW1ib2xzJykucG9wdWxhdGVNb2RlbFN5bWJvbDtcblxuLyoqXG4gKiBHaXZlbiBhIG1vZGVsIGFuZCBpdHMgc2NoZW1hLCBmaW5kIGFsbCBwb3NzaWJsZSBzY2hlbWEgdHlwZXMgZm9yIGBwYXRoYCxcbiAqIGluY2x1ZGluZyBzZWFyY2hpbmcgdGhyb3VnaCBkaXNjcmltaW5hdG9ycy4gSWYgYGRvY2AgaXMgc3BlY2lmaWVkLCB3aWxsXG4gKiB1c2UgdGhlIGRvYydzIHZhbHVlcyBmb3IgZGlzY3JpbWluYXRvciBrZXlzIHdoZW4gc2VhcmNoaW5nLCBvdGhlcndpc2VcbiAqIHdpbGwgc2VhcmNoIGFsbCBkaXNjcmltaW5hdG9ycy5cbiAqXG4gKiBAcGFyYW0ge01vZGVsfSBtb2RlbFxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQHBhcmFtIHtPYmplY3R9IGRvYyBQT0pPXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRTY2hlbWFUeXBlcyhtb2RlbCwgc2NoZW1hLCBkb2MsIHBhdGgpIHtcbiAgY29uc3QgcGF0aHNjaGVtYSA9IHNjaGVtYS5wYXRoKHBhdGgpO1xuICBjb25zdCB0b3BMZXZlbERvYyA9IGRvYztcbiAgaWYgKHBhdGhzY2hlbWEpIHtcbiAgICByZXR1cm4gcGF0aHNjaGVtYTtcbiAgfVxuXG4gIGNvbnN0IGRpc2NyaW1pbmF0b3JLZXkgPSBzY2hlbWEuZGlzY3JpbWluYXRvck1hcHBpbmcgJiZcbiAgICBzY2hlbWEuZGlzY3JpbWluYXRvck1hcHBpbmcua2V5O1xuICBpZiAoZGlzY3JpbWluYXRvcktleSAmJiBtb2RlbCAhPSBudWxsKSB7XG4gICAgaWYgKGRvYyAhPSBudWxsICYmIGRvY1tkaXNjcmltaW5hdG9yS2V5XSAhPSBudWxsKSB7XG4gICAgICBjb25zdCBkaXNjcmltaW5hdG9yID0gZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUobW9kZWwuZGlzY3JpbWluYXRvcnMsIGRvY1tkaXNjcmltaW5hdG9yS2V5XSk7XG4gICAgICBzY2hlbWEgPSBkaXNjcmltaW5hdG9yID8gZGlzY3JpbWluYXRvci5zY2hlbWEgOiBzY2hlbWE7XG4gICAgfSBlbHNlIGlmIChtb2RlbC5kaXNjcmltaW5hdG9ycyAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMobW9kZWwuZGlzY3JpbWluYXRvcnMpLnJlZHVjZSgoYXJyLCBuYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IGRpc2MgPSBtb2RlbC5kaXNjcmltaW5hdG9yc1tuYW1lXTtcbiAgICAgICAgcmV0dXJuIGFyci5jb25jYXQoZ2V0U2NoZW1hVHlwZXMoZGlzYywgZGlzYy5zY2hlbWEsIG51bGwsIHBhdGgpKTtcbiAgICAgIH0sIFtdKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZWFyY2gocGFydHMsIHNjaGVtYSwgc3ViZG9jLCBuZXN0ZWRQYXRoKSB7XG4gICAgbGV0IHAgPSBwYXJ0cy5sZW5ndGggKyAxO1xuICAgIGxldCBmb3VuZHNjaGVtYTtcbiAgICBsZXQgdHJ5cGF0aDtcblxuICAgIHdoaWxlIChwLS0pIHtcbiAgICAgIHRyeXBhdGggPSBwYXJ0cy5zbGljZSgwLCBwKS5qb2luKCcuJyk7XG4gICAgICBmb3VuZHNjaGVtYSA9IHNjaGVtYS5wYXRoKHRyeXBhdGgpO1xuICAgICAgaWYgKGZvdW5kc2NoZW1hID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3VuZHNjaGVtYS5jYXN0ZXIpIHtcbiAgICAgICAgLy8gYXJyYXkgb2YgTWl4ZWQ/XG4gICAgICAgIGlmIChmb3VuZHNjaGVtYS5jYXN0ZXIgaW5zdGFuY2VvZiBNaXhlZCkge1xuICAgICAgICAgIHJldHVybiBmb3VuZHNjaGVtYS5jYXN0ZXI7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc2NoZW1hcyA9IG51bGw7XG4gICAgICAgIGlmIChmb3VuZHNjaGVtYS5zY2hlbWEgIT0gbnVsbCAmJiBmb3VuZHNjaGVtYS5zY2hlbWEuZGlzY3JpbWluYXRvcnMgIT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JzID0gZm91bmRzY2hlbWEuc2NoZW1hLmRpc2NyaW1pbmF0b3JzO1xuICAgICAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JLZXlQYXRoID0gdHJ5cGF0aCArICcuJyArXG4gICAgICAgICAgICBmb3VuZHNjaGVtYS5zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5O1xuICAgICAgICAgIGNvbnN0IGtleXMgPSBzdWJkb2MgPyBtcGF0aC5nZXQoZGlzY3JpbWluYXRvcktleVBhdGgsIHN1YmRvYykgfHwgW10gOiBbXTtcbiAgICAgICAgICBzY2hlbWFzID0gT2JqZWN0LmtleXMoZGlzY3JpbWluYXRvcnMpLlxuICAgICAgICAgICAgcmVkdWNlKGZ1bmN0aW9uKGN1ciwgZGlzY3JpbWluYXRvcikge1xuICAgICAgICAgICAgICBjb25zdCB0aWVkVmFsdWUgPSBkaXNjcmltaW5hdG9yc1tkaXNjcmltaW5hdG9yXS5kaXNjcmltaW5hdG9yTWFwcGluZy52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGRvYyA9PSBudWxsIHx8IGtleXMuaW5kZXhPZihkaXNjcmltaW5hdG9yKSAhPT0gLTEgfHwga2V5cy5pbmRleE9mKHRpZWRWYWx1ZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY3VyLnB1c2goZGlzY3JpbWluYXRvcnNbZGlzY3JpbWluYXRvcl0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3cgdGhhdCB3ZSBmb3VuZCB0aGUgYXJyYXksIHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlcmVcbiAgICAgICAgLy8gYXJlIHJlbWFpbmluZyBkb2N1bWVudCBwYXRocyB0byBsb29rIHVwIGZvciBjYXN0aW5nLlxuICAgICAgICAvLyBBbHNvIHdlIG5lZWQgdG8gaGFuZGxlIGFycmF5LiQucGF0aCBzaW5jZSBzY2hlbWEucGF0aFxuICAgICAgICAvLyBkb2Vzbid0IHdvcmsgZm9yIHRoYXQuXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGZvdW5kc2NoZW1hLnNjaGVtYSB3ZSBhcmUgZGVhbGluZyB3aXRoXG4gICAgICAgIC8vIGEgcGF0aCBsaWtlIGFycmF5LiRcbiAgICAgICAgaWYgKHAgIT09IHBhcnRzLmxlbmd0aCAmJiBmb3VuZHNjaGVtYS5zY2hlbWEpIHtcbiAgICAgICAgICBsZXQgcmV0O1xuICAgICAgICAgIGlmIChwYXJ0c1twXSA9PT0gJyQnKSB7XG4gICAgICAgICAgICBpZiAocCArIDEgPT09IHBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAvLyBjb21tZW50cy4kXG4gICAgICAgICAgICAgIHJldHVybiBmb3VuZHNjaGVtYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbW1lbnRzLiQuY29tbWVudHMuJC50aXRsZVxuICAgICAgICAgICAgcmV0ID0gc2VhcmNoKFxuICAgICAgICAgICAgICBwYXJ0cy5zbGljZShwICsgMSksXG4gICAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgICAgc3ViZG9jID8gbXBhdGguZ2V0KHRyeXBhdGgsIHN1YmRvYykgOiBudWxsLFxuICAgICAgICAgICAgICBuZXN0ZWRQYXRoLmNvbmNhdChwYXJ0cy5zbGljZSgwLCBwKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgICAgIHJldC4kcGFyZW50U2NoZW1hRG9jQXJyYXkgPSByZXQuJHBhcmVudFNjaGVtYURvY0FycmF5IHx8XG4gICAgICAgICAgICAgICAgKGZvdW5kc2NoZW1hLnNjaGVtYS4kaXNTaW5nbGVOZXN0ZWQgPyBudWxsIDogZm91bmRzY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2NoZW1hcyAhPSBudWxsICYmIHNjaGVtYXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0ID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNjaGVtYSBvZiBzY2hlbWFzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IF9yZXQgPSBzZWFyY2goXG4gICAgICAgICAgICAgICAgcGFydHMuc2xpY2UocCksXG4gICAgICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgICAgIHN1YmRvYyA/IG1wYXRoLmdldCh0cnlwYXRoLCBzdWJkb2MpIDogbnVsbCxcbiAgICAgICAgICAgICAgICBuZXN0ZWRQYXRoLmNvbmNhdChwYXJ0cy5zbGljZSgwLCBwKSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKF9yZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF9yZXQuJHBhcmVudFNjaGVtYURvY0FycmF5ID0gX3JldC4kcGFyZW50U2NoZW1hRG9jQXJyYXkgfHxcbiAgICAgICAgICAgICAgICAgIChmb3VuZHNjaGVtYS5zY2hlbWEuJGlzU2luZ2xlTmVzdGVkID8gbnVsbCA6IGZvdW5kc2NoZW1hKTtcbiAgICAgICAgICAgICAgICBpZiAoX3JldC4kcGFyZW50U2NoZW1hRG9jQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgIHJldC4kcGFyZW50U2NoZW1hRG9jQXJyYXkgPSBfcmV0LiRwYXJlbnRTY2hlbWFEb2NBcnJheTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0LnB1c2goX3JldCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldCA9IHNlYXJjaChcbiAgICAgICAgICAgICAgcGFydHMuc2xpY2UocCksXG4gICAgICAgICAgICAgIGZvdW5kc2NoZW1hLnNjaGVtYSxcbiAgICAgICAgICAgICAgc3ViZG9jID8gbXBhdGguZ2V0KHRyeXBhdGgsIHN1YmRvYykgOiBudWxsLFxuICAgICAgICAgICAgICBuZXN0ZWRQYXRoLmNvbmNhdChwYXJ0cy5zbGljZSgwLCBwKSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICAgICAgcmV0LiRwYXJlbnRTY2hlbWFEb2NBcnJheSA9IHJldC4kcGFyZW50U2NoZW1hRG9jQXJyYXkgfHxcbiAgICAgICAgICAgICAgICAoZm91bmRzY2hlbWEuc2NoZW1hLiRpc1NpbmdsZU5lc3RlZCA/IG51bGwgOiBmb3VuZHNjaGVtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwICE9PSBwYXJ0cy5sZW5ndGggJiZcbiAgICAgICAgICAgIGZvdW5kc2NoZW1hLiRpc01vbmdvb3NlQXJyYXkgJiZcbiAgICAgICAgICAgIGZvdW5kc2NoZW1hLmNhc3RlckNvbnN0cnVjdG9yLiRpc01vbmdvb3NlQXJyYXkpIHtcbiAgICAgICAgICAvLyBOZXN0ZWQgYXJyYXlzLiBEcmlsbCBkb3duIHRvIHRoZSBib3R0b20gb2YgdGhlIG5lc3RlZCBhcnJheS5cbiAgICAgICAgICBsZXQgdHlwZSA9IGZvdW5kc2NoZW1hO1xuICAgICAgICAgIHdoaWxlICh0eXBlLiRpc01vbmdvb3NlQXJyYXkgJiYgIXR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5jYXN0ZXJDb25zdHJ1Y3RvcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCByZXQgPSBzZWFyY2goXG4gICAgICAgICAgICBwYXJ0cy5zbGljZShwKSxcbiAgICAgICAgICAgIHR5cGUuc2NoZW1hLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIG5lc3RlZFBhdGguY29uY2F0KHBhcnRzLnNsaWNlKDAsIHApKVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHJldCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0eXBlLnNjaGVtYS5kaXNjcmltaW5hdG9ycykge1xuICAgICAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvclBhdGhzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRpc2NyaW1pbmF0b3JOYW1lIG9mIE9iamVjdC5rZXlzKHR5cGUuc2NoZW1hLmRpc2NyaW1pbmF0b3JzKSkge1xuICAgICAgICAgICAgICBjb25zdCBfc2NoZW1hID0gdHlwZS5zY2hlbWEuZGlzY3JpbWluYXRvcnNbZGlzY3JpbWluYXRvck5hbWVdIHx8IHR5cGUuc2NoZW1hO1xuICAgICAgICAgICAgICBjb25zdCByZXQgPSBzZWFyY2gocGFydHMuc2xpY2UocCksIF9zY2hlbWEsIG51bGwsIG5lc3RlZFBhdGguY29uY2F0KHBhcnRzLnNsaWNlKDAsIHApKSk7XG4gICAgICAgICAgICAgIGlmIChyZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRpc2NyaW1pbmF0b3JQYXRocy5wdXNoKHJldCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaXNjcmltaW5hdG9yUGF0aHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gZGlzY3JpbWluYXRvclBhdGhzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChmb3VuZHNjaGVtYS4kaXNTY2hlbWFNYXAgJiYgZm91bmRzY2hlbWEuJF9fc2NoZW1hVHlwZSBpbnN0YW5jZW9mIE1peGVkKSB7XG4gICAgICAgIHJldHVybiBmb3VuZHNjaGVtYS4kX19zY2hlbWFUeXBlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmdWxsUGF0aCA9IG5lc3RlZFBhdGguY29uY2F0KFt0cnlwYXRoXSkuam9pbignLicpO1xuICAgICAgaWYgKHRvcExldmVsRG9jICE9IG51bGwgJiYgdG9wTGV2ZWxEb2MuJF9fICYmIHRvcExldmVsRG9jLiRwb3B1bGF0ZWQoZnVsbFBhdGgpICYmIHAgPCBwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgbW9kZWwgPSBkb2MuJF9fLnBvcHVsYXRlZFtmdWxsUGF0aF0ub3B0aW9uc1twb3B1bGF0ZU1vZGVsU3ltYm9sXTtcbiAgICAgICAgaWYgKG1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgICBjb25zdCByZXQgPSBzZWFyY2goXG4gICAgICAgICAgICBwYXJ0cy5zbGljZShwKSxcbiAgICAgICAgICAgIG1vZGVsLnNjaGVtYSxcbiAgICAgICAgICAgIHN1YmRvYyA/IG1wYXRoLmdldCh0cnlwYXRoLCBzdWJkb2MpIDogbnVsbCxcbiAgICAgICAgICAgIG5lc3RlZFBhdGguY29uY2F0KHBhcnRzLnNsaWNlKDAsIHApKVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IF92YWwgPSBnZXQodG9wTGV2ZWxEb2MsIHRyeXBhdGgpO1xuICAgICAgaWYgKF92YWwgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBtb2RlbCA9IEFycmF5LmlzQXJyYXkoX3ZhbCkgJiYgX3ZhbC5sZW5ndGggPiAwID9cbiAgICAgICAgICBsZWFuUG9wdWxhdGVNYXAuZ2V0KF92YWxbMF0pIDpcbiAgICAgICAgICBsZWFuUG9wdWxhdGVNYXAuZ2V0KF92YWwpO1xuICAgICAgICAvLyBQb3B1bGF0ZWQgdXNpbmcgbGVhbiwgYGxlYW5Qb3B1bGF0ZU1hcGAgdmFsdWUgaXMgdGhlIGZvcmVpZ24gbW9kZWxcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gbW9kZWwgIT0gbnVsbCA/IG1vZGVsLnNjaGVtYSA6IG51bGw7XG4gICAgICAgIGlmIChzY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IHJldCA9IHNlYXJjaChcbiAgICAgICAgICAgIHBhcnRzLnNsaWNlKHApLFxuICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgc3ViZG9jID8gbXBhdGguZ2V0KHRyeXBhdGgsIHN1YmRvYykgOiBudWxsLFxuICAgICAgICAgICAgbmVzdGVkUGF0aC5jb25jYXQocGFydHMuc2xpY2UoMCwgcCkpXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmIChyZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0LiRwYXJlbnRTY2hlbWFEb2NBcnJheSA9IHJldC4kcGFyZW50U2NoZW1hRG9jQXJyYXkgfHxcbiAgICAgICAgICAgICAgKHNjaGVtYS4kaXNTaW5nbGVOZXN0ZWQgPyBudWxsIDogc2NoZW1hKTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZm91bmRzY2hlbWE7XG4gICAgfVxuICB9XG4gIC8vIGxvb2sgZm9yIGFycmF5c1xuICBjb25zdCBwYXJ0cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgIGlmIChwYXJ0c1tpXSA9PT0gJyQnKSB7XG4gICAgICAvLyBSZTogZ2gtNTYyOCwgYmVjYXVzZSBgc2NoZW1hLnBhdGgoKWAgZG9lc24ndCB0YWtlICQgaW50byBhY2NvdW50LlxuICAgICAgcGFydHNbaV0gPSAnMCc7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZWFyY2gocGFydHMsIHNjaGVtYSwgZG9jLCBbXSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/populate/getSchemaTypes.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/populate/getVirtual.js":
/*!***************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/populate/getVirtual.js ***!
  \***************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = getVirtual;\n\n/*!\n * ignore\n */\n\nfunction getVirtual(schema, name) {\n  if (schema.virtuals[name]) {\n    return { virtual: schema.virtuals[name], path: void 0 };\n  }\n\n  const parts = name.split('.');\n  let cur = '';\n  let nestedSchemaPath = '';\n  for (let i = 0; i < parts.length; ++i) {\n    cur += (cur.length > 0 ? '.' : '') + parts[i];\n    if (schema.virtuals[cur]) {\n      if (i === parts.length - 1) {\n        return { virtual: schema.virtuals[cur], path: nestedSchemaPath };\n      }\n      continue;\n    }\n\n    if (schema.nested[cur]) {\n      continue;\n    }\n\n    if (schema.paths[cur] && schema.paths[cur].schema) {\n      schema = schema.paths[cur].schema;\n      const rest = parts.slice(i + 1).join('.');\n\n      if (schema.virtuals[rest]) {\n        if (i === parts.length - 2) {\n          return {\n            virtual: schema.virtuals[rest],\n            nestedSchemaPath: [nestedSchemaPath, cur].filter(v => !!v).join('.')\n          };\n        }\n        continue;\n      }\n\n      if (i + 1 < parts.length && schema.discriminators) {\n        for (const key of Object.keys(schema.discriminators)) {\n          const res = getVirtual(schema.discriminators[key], rest);\n          if (res != null) {\n            const _path = [nestedSchemaPath, cur, res.nestedSchemaPath].\n              filter(v => !!v).join('.');\n            return {\n              virtual: res.virtual,\n              nestedSchemaPath: _path\n            };\n          }\n        }\n      }\n\n      nestedSchemaPath += (nestedSchemaPath.length > 0 ? '.' : '') + cur;\n      cur = '';\n      continue;\n    }\n\n    if (schema.discriminators) {\n      for (const discriminatorKey of Object.keys(schema.discriminators)) {\n        const virtualFromDiscriminator = getVirtual(schema.discriminators[discriminatorKey], name);\n        if (virtualFromDiscriminator) return virtualFromDiscriminator;\n      }\n    }\n\n    return null;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvZ2V0VmlydHVhbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3BvcHVsYXRlL2dldFZpcnR1YWwuanM/MmZhYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VmlydHVhbDtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBnZXRWaXJ0dWFsKHNjaGVtYSwgbmFtZSkge1xuICBpZiAoc2NoZW1hLnZpcnR1YWxzW25hbWVdKSB7XG4gICAgcmV0dXJuIHsgdmlydHVhbDogc2NoZW1hLnZpcnR1YWxzW25hbWVdLCBwYXRoOiB2b2lkIDAgfTtcbiAgfVxuXG4gIGNvbnN0IHBhcnRzID0gbmFtZS5zcGxpdCgnLicpO1xuICBsZXQgY3VyID0gJyc7XG4gIGxldCBuZXN0ZWRTY2hlbWFQYXRoID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyArK2kpIHtcbiAgICBjdXIgKz0gKGN1ci5sZW5ndGggPiAwID8gJy4nIDogJycpICsgcGFydHNbaV07XG4gICAgaWYgKHNjaGVtYS52aXJ0dWFsc1tjdXJdKSB7XG4gICAgICBpZiAoaSA9PT0gcGFydHMubGVuZ3RoIC0gMSkge1xuICAgICAgICByZXR1cm4geyB2aXJ0dWFsOiBzY2hlbWEudmlydHVhbHNbY3VyXSwgcGF0aDogbmVzdGVkU2NoZW1hUGF0aCB9O1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHNjaGVtYS5uZXN0ZWRbY3VyXSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHNjaGVtYS5wYXRoc1tjdXJdICYmIHNjaGVtYS5wYXRoc1tjdXJdLnNjaGVtYSkge1xuICAgICAgc2NoZW1hID0gc2NoZW1hLnBhdGhzW2N1cl0uc2NoZW1hO1xuICAgICAgY29uc3QgcmVzdCA9IHBhcnRzLnNsaWNlKGkgKyAxKS5qb2luKCcuJyk7XG5cbiAgICAgIGlmIChzY2hlbWEudmlydHVhbHNbcmVzdF0pIHtcbiAgICAgICAgaWYgKGkgPT09IHBhcnRzLmxlbmd0aCAtIDIpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmlydHVhbDogc2NoZW1hLnZpcnR1YWxzW3Jlc3RdLFxuICAgICAgICAgICAgbmVzdGVkU2NoZW1hUGF0aDogW25lc3RlZFNjaGVtYVBhdGgsIGN1cl0uZmlsdGVyKHYgPT4gISF2KS5qb2luKCcuJylcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSArIDEgPCBwYXJ0cy5sZW5ndGggJiYgc2NoZW1hLmRpc2NyaW1pbmF0b3JzKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjaGVtYS5kaXNjcmltaW5hdG9ycykpIHtcbiAgICAgICAgICBjb25zdCByZXMgPSBnZXRWaXJ0dWFsKHNjaGVtYS5kaXNjcmltaW5hdG9yc1trZXldLCByZXN0KTtcbiAgICAgICAgICBpZiAocmVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IF9wYXRoID0gW25lc3RlZFNjaGVtYVBhdGgsIGN1ciwgcmVzLm5lc3RlZFNjaGVtYVBhdGhdLlxuICAgICAgICAgICAgICBmaWx0ZXIodiA9PiAhIXYpLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZpcnR1YWw6IHJlcy52aXJ0dWFsLFxuICAgICAgICAgICAgICBuZXN0ZWRTY2hlbWFQYXRoOiBfcGF0aFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbmVzdGVkU2NoZW1hUGF0aCArPSAobmVzdGVkU2NoZW1hUGF0aC5sZW5ndGggPiAwID8gJy4nIDogJycpICsgY3VyO1xuICAgICAgY3VyID0gJyc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoc2NoZW1hLmRpc2NyaW1pbmF0b3JzKSB7XG4gICAgICBmb3IgKGNvbnN0IGRpc2NyaW1pbmF0b3JLZXkgb2YgT2JqZWN0LmtleXMoc2NoZW1hLmRpc2NyaW1pbmF0b3JzKSkge1xuICAgICAgICBjb25zdCB2aXJ0dWFsRnJvbURpc2NyaW1pbmF0b3IgPSBnZXRWaXJ0dWFsKHNjaGVtYS5kaXNjcmltaW5hdG9yc1tkaXNjcmltaW5hdG9yS2V5XSwgbmFtZSk7XG4gICAgICAgIGlmICh2aXJ0dWFsRnJvbURpc2NyaW1pbmF0b3IpIHJldHVybiB2aXJ0dWFsRnJvbURpc2NyaW1pbmF0b3I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/populate/getVirtual.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js":
/*!********************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js ***!
  \********************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = new WeakMap();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvbGVhblBvcHVsYXRlTWFwLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3BvcHVsYXRlL2xlYW5Qb3B1bGF0ZU1hcC5qcz85ZmQyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBXZWFrTWFwKCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/populate/lookupLocalFields.js":
/*!**********************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/populate/lookupLocalFields.js ***!
  \**********************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function lookupLocalFields(cur, path, val) {\n  if (cur == null) {\n    return cur;\n  }\n\n  if (cur._doc != null) {\n    cur = cur._doc;\n  }\n\n  if (arguments.length >= 3) {\n    if (typeof cur !== 'object') {\n      return void 0;\n    }\n    if (val === void 0) {\n      return void 0;\n    }\n    if (cur instanceof Map) {\n      cur.set(path, val);\n    } else {\n      cur[path] = val;\n    }\n    return val;\n  }\n\n\n  // Support populating paths under maps using `map.$*.subpath`\n  if (path === '$*') {\n    return cur instanceof Map ?\n      Array.from(cur.values()) :\n      Object.keys(cur).map(key => cur[key]);\n  }\n\n  if (cur instanceof Map) {\n    return cur.get(path);\n  }\n\n  return cur[path];\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvbG9va3VwTG9jYWxGaWVsZHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvbG9va3VwTG9jYWxGaWVsZHMuanM/YzMyOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbG9va3VwTG9jYWxGaWVsZHMoY3VyLCBwYXRoLCB2YWwpIHtcbiAgaWYgKGN1ciA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGN1cjtcbiAgfVxuXG4gIGlmIChjdXIuX2RvYyAhPSBudWxsKSB7XG4gICAgY3VyID0gY3VyLl9kb2M7XG4gIH1cblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSB7XG4gICAgaWYgKHR5cGVvZiBjdXIgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAodmFsID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGlmIChjdXIgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgIGN1ci5zZXQocGF0aCwgdmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VyW3BhdGhdID0gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xuICB9XG5cblxuICAvLyBTdXBwb3J0IHBvcHVsYXRpbmcgcGF0aHMgdW5kZXIgbWFwcyB1c2luZyBgbWFwLiQqLnN1YnBhdGhgXG4gIGlmIChwYXRoID09PSAnJConKSB7XG4gICAgcmV0dXJuIGN1ciBpbnN0YW5jZW9mIE1hcCA/XG4gICAgICBBcnJheS5mcm9tKGN1ci52YWx1ZXMoKSkgOlxuICAgICAgT2JqZWN0LmtleXMoY3VyKS5tYXAoa2V5ID0+IGN1cltrZXldKTtcbiAgfVxuXG4gIGlmIChjdXIgaW5zdGFuY2VvZiBNYXApIHtcbiAgICByZXR1cm4gY3VyLmdldChwYXRoKTtcbiAgfVxuXG4gIHJldHVybiBjdXJbcGF0aF07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/populate/lookupLocalFields.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/populate/markArraySubdocsPopulated.js":
/*!******************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/populate/markArraySubdocsPopulated.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst utils = __webpack_require__(/*! ../../utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\n\n/**\n * If populating a path within a document array, make sure each\n * subdoc within the array knows its subpaths are populated.\n *\n * #### Example:\n *\n *     const doc = await Article.findOne().populate('comments.author');\n *     doc.comments[0].populated('author'); // Should be set\n *\n * @param {Document} doc\n * @param {Object} [populated]\n * @api private\n */\n\nmodule.exports = function markArraySubdocsPopulated(doc, populated) {\n  if (doc._id == null || populated == null || populated.length === 0) {\n    return;\n  }\n\n  const id = String(doc._id);\n  for (const item of populated) {\n    if (item.isVirtual) {\n      continue;\n    }\n    const path = item.path;\n    const pieces = path.split('.');\n    for (let i = 0; i < pieces.length - 1; ++i) {\n      const subpath = pieces.slice(0, i + 1).join('.');\n      const rest = pieces.slice(i + 1).join('.');\n      const val = doc.get(subpath);\n      if (val == null) {\n        continue;\n      }\n\n      if (utils.isMongooseDocumentArray(val)) {\n        for (let j = 0; j < val.length; ++j) {\n          if (val[j]) {\n            val[j].populated(rest, item._docs[id] == null ? void 0 : item._docs[id][j], item);\n          }\n        }\n        break;\n      }\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvbWFya0FycmF5U3ViZG9jc1BvcHVsYXRlZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsa0VBQWE7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3BvcHVsYXRlL21hcmtBcnJheVN1YmRvY3NQb3B1bGF0ZWQuanM/MmVhMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBJZiBwb3B1bGF0aW5nIGEgcGF0aCB3aXRoaW4gYSBkb2N1bWVudCBhcnJheSwgbWFrZSBzdXJlIGVhY2hcbiAqIHN1YmRvYyB3aXRoaW4gdGhlIGFycmF5IGtub3dzIGl0cyBzdWJwYXRocyBhcmUgcG9wdWxhdGVkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgZG9jID0gYXdhaXQgQXJ0aWNsZS5maW5kT25lKCkucG9wdWxhdGUoJ2NvbW1lbnRzLmF1dGhvcicpO1xuICogICAgIGRvYy5jb21tZW50c1swXS5wb3B1bGF0ZWQoJ2F1dGhvcicpOyAvLyBTaG91bGQgYmUgc2V0XG4gKlxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jXG4gKiBAcGFyYW0ge09iamVjdH0gW3BvcHVsYXRlZF1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWFya0FycmF5U3ViZG9jc1BvcHVsYXRlZChkb2MsIHBvcHVsYXRlZCkge1xuICBpZiAoZG9jLl9pZCA9PSBudWxsIHx8IHBvcHVsYXRlZCA9PSBudWxsIHx8IHBvcHVsYXRlZC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBpZCA9IFN0cmluZyhkb2MuX2lkKTtcbiAgZm9yIChjb25zdCBpdGVtIG9mIHBvcHVsYXRlZCkge1xuICAgIGlmIChpdGVtLmlzVmlydHVhbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHBhdGggPSBpdGVtLnBhdGg7XG4gICAgY29uc3QgcGllY2VzID0gcGF0aC5zcGxpdCgnLicpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGllY2VzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgY29uc3Qgc3VicGF0aCA9IHBpZWNlcy5zbGljZSgwLCBpICsgMSkuam9pbignLicpO1xuICAgICAgY29uc3QgcmVzdCA9IHBpZWNlcy5zbGljZShpICsgMSkuam9pbignLicpO1xuICAgICAgY29uc3QgdmFsID0gZG9jLmdldChzdWJwYXRoKTtcbiAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHV0aWxzLmlzTW9uZ29vc2VEb2N1bWVudEFycmF5KHZhbCkpIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWwubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICBpZiAodmFsW2pdKSB7XG4gICAgICAgICAgICB2YWxbal0ucG9wdWxhdGVkKHJlc3QsIGl0ZW0uX2RvY3NbaWRdID09IG51bGwgPyB2b2lkIDAgOiBpdGVtLl9kb2NzW2lkXVtqXSwgaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/populate/markArraySubdocsPopulated.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/populate/modelNamesFromRefPath.js":
/*!**************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/populate/modelNamesFromRefPath.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst MongooseError = __webpack_require__(/*! ../../error/mongooseError */ \"../backend/node_modules/mongoose/lib/error/mongooseError.js\");\nconst isPathExcluded = __webpack_require__(/*! ../projection/isPathExcluded */ \"../backend/node_modules/mongoose/lib/helpers/projection/isPathExcluded.js\");\nconst lookupLocalFields = __webpack_require__(/*! ./lookupLocalFields */ \"../backend/node_modules/mongoose/lib/helpers/populate/lookupLocalFields.js\");\nconst mpath = __webpack_require__(/*! mpath */ \"../backend/node_modules/mpath/index.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst utils = __webpack_require__(/*! ../../utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\n\nconst hasNumericPropRE = /(\\.\\d+$|\\.\\d+\\.)/g;\n\nmodule.exports = function modelNamesFromRefPath(refPath, doc, populatedPath, modelSchema, queryProjection) {\n  if (refPath == null) {\n    return [];\n  }\n\n  if (typeof refPath === 'string' && queryProjection != null && isPathExcluded(queryProjection, refPath)) {\n    throw new MongooseError('refPath `' + refPath + '` must not be excluded in projection, got ' +\n      util.inspect(queryProjection));\n  }\n\n  // If populated path has numerics, the end `refPath` should too. For example,\n  // if populating `a.0.b` instead of `a.b` and `b` has `refPath = a.c`, we\n  // should return `a.0.c` for the refPath.\n\n  if (hasNumericPropRE.test(populatedPath)) {\n    const chunks = populatedPath.split(hasNumericPropRE);\n\n    if (chunks[chunks.length - 1] === '') {\n      throw new Error('Can\\'t populate individual element in an array');\n    }\n\n    let _refPath = '';\n    let _remaining = refPath;\n    // 2nd, 4th, etc. will be numeric props. For example: `[ 'a', '.0.', 'b' ]`\n    for (let i = 0; i < chunks.length; i += 2) {\n      const chunk = chunks[i];\n      if (_remaining.startsWith(chunk + '.')) {\n        _refPath += _remaining.substring(0, chunk.length) + chunks[i + 1];\n        _remaining = _remaining.substring(chunk.length + 1);\n      } else if (i === chunks.length - 1) {\n        _refPath += _remaining;\n        _remaining = '';\n        break;\n      } else {\n        throw new Error('Could not normalize ref path, chunk ' + chunk + ' not in populated path');\n      }\n    }\n\n    const refValue = mpath.get(_refPath, doc, lookupLocalFields);\n    let modelNames = Array.isArray(refValue) ? refValue : [refValue];\n    modelNames = utils.array.flatten(modelNames);\n    return modelNames;\n  }\n\n  const refValue = mpath.get(refPath, doc, lookupLocalFields);\n\n  let modelNames;\n  if (modelSchema != null && modelSchema.virtuals.hasOwnProperty(refPath)) {\n    modelNames = [modelSchema.virtuals[refPath].applyGetters(void 0, doc)];\n  } else {\n    modelNames = Array.isArray(refValue) ? refValue : [refValue];\n  }\n\n  modelNames = utils.array.flatten(modelNames);\n\n  return modelNames;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvbW9kZWxOYW1lc0Zyb21SZWZQYXRoLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHNCQUFzQixtQkFBTyxDQUFDLDhGQUEyQjtBQUN6RCx1QkFBdUIsbUJBQU8sQ0FBQywrR0FBOEI7QUFDN0QsMEJBQTBCLG1CQUFPLENBQUMsdUdBQXFCO0FBQ3ZELGNBQWMsbUJBQU8sQ0FBQyxxREFBTztBQUM3QixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsY0FBYyxtQkFBTyxDQUFDLGtFQUFhOztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3BvcHVsYXRlL21vZGVsTmFtZXNGcm9tUmVmUGF0aC5qcz8zMzZlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4uLy4uL2Vycm9yL21vbmdvb3NlRXJyb3InKTtcbmNvbnN0IGlzUGF0aEV4Y2x1ZGVkID0gcmVxdWlyZSgnLi4vcHJvamVjdGlvbi9pc1BhdGhFeGNsdWRlZCcpO1xuY29uc3QgbG9va3VwTG9jYWxGaWVsZHMgPSByZXF1aXJlKCcuL2xvb2t1cExvY2FsRmllbGRzJyk7XG5jb25zdCBtcGF0aCA9IHJlcXVpcmUoJ21wYXRoJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscycpO1xuXG5jb25zdCBoYXNOdW1lcmljUHJvcFJFID0gLyhcXC5cXGQrJHxcXC5cXGQrXFwuKS9nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1vZGVsTmFtZXNGcm9tUmVmUGF0aChyZWZQYXRoLCBkb2MsIHBvcHVsYXRlZFBhdGgsIG1vZGVsU2NoZW1hLCBxdWVyeVByb2plY3Rpb24pIHtcbiAgaWYgKHJlZlBhdGggPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcmVmUGF0aCA9PT0gJ3N0cmluZycgJiYgcXVlcnlQcm9qZWN0aW9uICE9IG51bGwgJiYgaXNQYXRoRXhjbHVkZWQocXVlcnlQcm9qZWN0aW9uLCByZWZQYXRoKSkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdyZWZQYXRoIGAnICsgcmVmUGF0aCArICdgIG11c3Qgbm90IGJlIGV4Y2x1ZGVkIGluIHByb2plY3Rpb24sIGdvdCAnICtcbiAgICAgIHV0aWwuaW5zcGVjdChxdWVyeVByb2plY3Rpb24pKTtcbiAgfVxuXG4gIC8vIElmIHBvcHVsYXRlZCBwYXRoIGhhcyBudW1lcmljcywgdGhlIGVuZCBgcmVmUGF0aGAgc2hvdWxkIHRvby4gRm9yIGV4YW1wbGUsXG4gIC8vIGlmIHBvcHVsYXRpbmcgYGEuMC5iYCBpbnN0ZWFkIG9mIGBhLmJgIGFuZCBgYmAgaGFzIGByZWZQYXRoID0gYS5jYCwgd2VcbiAgLy8gc2hvdWxkIHJldHVybiBgYS4wLmNgIGZvciB0aGUgcmVmUGF0aC5cblxuICBpZiAoaGFzTnVtZXJpY1Byb3BSRS50ZXN0KHBvcHVsYXRlZFBhdGgpKSB7XG4gICAgY29uc3QgY2h1bmtzID0gcG9wdWxhdGVkUGF0aC5zcGxpdChoYXNOdW1lcmljUHJvcFJFKTtcblxuICAgIGlmIChjaHVua3NbY2h1bmtzLmxlbmd0aCAtIDFdID09PSAnJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IHBvcHVsYXRlIGluZGl2aWR1YWwgZWxlbWVudCBpbiBhbiBhcnJheScpO1xuICAgIH1cblxuICAgIGxldCBfcmVmUGF0aCA9ICcnO1xuICAgIGxldCBfcmVtYWluaW5nID0gcmVmUGF0aDtcbiAgICAvLyAybmQsIDR0aCwgZXRjLiB3aWxsIGJlIG51bWVyaWMgcHJvcHMuIEZvciBleGFtcGxlOiBgWyAnYScsICcuMC4nLCAnYicgXWBcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgY29uc3QgY2h1bmsgPSBjaHVua3NbaV07XG4gICAgICBpZiAoX3JlbWFpbmluZy5zdGFydHNXaXRoKGNodW5rICsgJy4nKSkge1xuICAgICAgICBfcmVmUGF0aCArPSBfcmVtYWluaW5nLnN1YnN0cmluZygwLCBjaHVuay5sZW5ndGgpICsgY2h1bmtzW2kgKyAxXTtcbiAgICAgICAgX3JlbWFpbmluZyA9IF9yZW1haW5pbmcuc3Vic3RyaW5nKGNodW5rLmxlbmd0aCArIDEpO1xuICAgICAgfSBlbHNlIGlmIChpID09PSBjaHVua3MubGVuZ3RoIC0gMSkge1xuICAgICAgICBfcmVmUGF0aCArPSBfcmVtYWluaW5nO1xuICAgICAgICBfcmVtYWluaW5nID0gJyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3Qgbm9ybWFsaXplIHJlZiBwYXRoLCBjaHVuayAnICsgY2h1bmsgKyAnIG5vdCBpbiBwb3B1bGF0ZWQgcGF0aCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJlZlZhbHVlID0gbXBhdGguZ2V0KF9yZWZQYXRoLCBkb2MsIGxvb2t1cExvY2FsRmllbGRzKTtcbiAgICBsZXQgbW9kZWxOYW1lcyA9IEFycmF5LmlzQXJyYXkocmVmVmFsdWUpID8gcmVmVmFsdWUgOiBbcmVmVmFsdWVdO1xuICAgIG1vZGVsTmFtZXMgPSB1dGlscy5hcnJheS5mbGF0dGVuKG1vZGVsTmFtZXMpO1xuICAgIHJldHVybiBtb2RlbE5hbWVzO1xuICB9XG5cbiAgY29uc3QgcmVmVmFsdWUgPSBtcGF0aC5nZXQocmVmUGF0aCwgZG9jLCBsb29rdXBMb2NhbEZpZWxkcyk7XG5cbiAgbGV0IG1vZGVsTmFtZXM7XG4gIGlmIChtb2RlbFNjaGVtYSAhPSBudWxsICYmIG1vZGVsU2NoZW1hLnZpcnR1YWxzLmhhc093blByb3BlcnR5KHJlZlBhdGgpKSB7XG4gICAgbW9kZWxOYW1lcyA9IFttb2RlbFNjaGVtYS52aXJ0dWFsc1tyZWZQYXRoXS5hcHBseUdldHRlcnModm9pZCAwLCBkb2MpXTtcbiAgfSBlbHNlIHtcbiAgICBtb2RlbE5hbWVzID0gQXJyYXkuaXNBcnJheShyZWZWYWx1ZSkgPyByZWZWYWx1ZSA6IFtyZWZWYWx1ZV07XG4gIH1cblxuICBtb2RlbE5hbWVzID0gdXRpbHMuYXJyYXkuZmxhdHRlbihtb2RlbE5hbWVzKTtcblxuICByZXR1cm4gbW9kZWxOYW1lcztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/populate/modelNamesFromRefPath.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/populate/removeDeselectedForeignField.js":
/*!*********************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/populate/removeDeselectedForeignField.js ***!
  \*********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst get = __webpack_require__(/*! ../get */ \"../backend/node_modules/mongoose/lib/helpers/get.js\");\nconst mpath = __webpack_require__(/*! mpath */ \"../backend/node_modules/mpath/index.js\");\nconst parseProjection = __webpack_require__(/*! ../projection/parseProjection */ \"../backend/node_modules/mongoose/lib/helpers/projection/parseProjection.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = function removeDeselectedForeignField(foreignFields, options, docs) {\n  const projection = parseProjection(get(options, 'select', null), true) ||\n    parseProjection(get(options, 'options.select', null), true);\n\n  if (projection == null) {\n    return;\n  }\n  for (const foreignField of foreignFields) {\n    if (!projection.hasOwnProperty('-' + foreignField)) {\n      continue;\n    }\n\n    for (const val of docs) {\n      if (val.$__ != null) {\n        mpath.unset(foreignField, val._doc);\n      } else {\n        mpath.unset(foreignField, val);\n      }\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvcmVtb3ZlRGVzZWxlY3RlZEZvcmVpZ25GaWVsZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsbUVBQVE7QUFDNUIsY0FBYyxtQkFBTyxDQUFDLHFEQUFPO0FBQzdCLHdCQUF3QixtQkFBTyxDQUFDLGlIQUErQjs7QUFFL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3BvcHVsYXRlL3JlbW92ZURlc2VsZWN0ZWRGb3JlaWduRmllbGQuanM/NWI4MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGdldCA9IHJlcXVpcmUoJy4uL2dldCcpO1xuY29uc3QgbXBhdGggPSByZXF1aXJlKCdtcGF0aCcpO1xuY29uc3QgcGFyc2VQcm9qZWN0aW9uID0gcmVxdWlyZSgnLi4vcHJvamVjdGlvbi9wYXJzZVByb2plY3Rpb24nKTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlbW92ZURlc2VsZWN0ZWRGb3JlaWduRmllbGQoZm9yZWlnbkZpZWxkcywgb3B0aW9ucywgZG9jcykge1xuICBjb25zdCBwcm9qZWN0aW9uID0gcGFyc2VQcm9qZWN0aW9uKGdldChvcHRpb25zLCAnc2VsZWN0JywgbnVsbCksIHRydWUpIHx8XG4gICAgcGFyc2VQcm9qZWN0aW9uKGdldChvcHRpb25zLCAnb3B0aW9ucy5zZWxlY3QnLCBudWxsKSwgdHJ1ZSk7XG5cbiAgaWYgKHByb2plY3Rpb24gPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKGNvbnN0IGZvcmVpZ25GaWVsZCBvZiBmb3JlaWduRmllbGRzKSB7XG4gICAgaWYgKCFwcm9qZWN0aW9uLmhhc093blByb3BlcnR5KCctJyArIGZvcmVpZ25GaWVsZCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgdmFsIG9mIGRvY3MpIHtcbiAgICAgIGlmICh2YWwuJF9fICE9IG51bGwpIHtcbiAgICAgICAgbXBhdGgudW5zZXQoZm9yZWlnbkZpZWxkLCB2YWwuX2RvYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtcGF0aC51bnNldChmb3JlaWduRmllbGQsIHZhbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/populate/removeDeselectedForeignField.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/populate/setPopulatedVirtualValue.js":
/*!*****************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/populate/setPopulatedVirtualValue.js ***!
  \*****************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Set a populated virtual value on a document's `$$populatedVirtuals` value\n *\n * @param {*} populatedVirtuals A document's `$$populatedVirtuals`\n * @param {*} name The virtual name\n * @param {*} v The result of the populate query\n * @param {*} options The populate options. This function handles `justOne` and `count` options.\n * @returns {Array<Document>|Document|Object|Array<Object>} the populated virtual value that was set\n */\n\nmodule.exports = function setPopulatedVirtualValue(populatedVirtuals, name, v, options) {\n  if (options.justOne || options.count) {\n    populatedVirtuals[name] = Array.isArray(v) ?\n      v[0] :\n      v;\n\n    if (typeof populatedVirtuals[name] !== 'object') {\n      populatedVirtuals[name] = options.count ? v : null;\n    }\n  } else {\n    populatedVirtuals[name] = Array.isArray(v) ?\n      v :\n      v == null ? [] : [v];\n\n    populatedVirtuals[name] = populatedVirtuals[name].filter(function(doc) {\n      return doc && typeof doc === 'object';\n    });\n  }\n\n  return populatedVirtuals[name];\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvc2V0UG9wdWxhdGVkVmlydHVhbFZhbHVlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLGFBQWEsK0NBQStDO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS9zZXRQb3B1bGF0ZWRWaXJ0dWFsVmFsdWUuanM/MThhZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU2V0IGEgcG9wdWxhdGVkIHZpcnR1YWwgdmFsdWUgb24gYSBkb2N1bWVudCdzIGAkJHBvcHVsYXRlZFZpcnR1YWxzYCB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7Kn0gcG9wdWxhdGVkVmlydHVhbHMgQSBkb2N1bWVudCdzIGAkJHBvcHVsYXRlZFZpcnR1YWxzYFxuICogQHBhcmFtIHsqfSBuYW1lIFRoZSB2aXJ0dWFsIG5hbWVcbiAqIEBwYXJhbSB7Kn0gdiBUaGUgcmVzdWx0IG9mIHRoZSBwb3B1bGF0ZSBxdWVyeVxuICogQHBhcmFtIHsqfSBvcHRpb25zIFRoZSBwb3B1bGF0ZSBvcHRpb25zLiBUaGlzIGZ1bmN0aW9uIGhhbmRsZXMgYGp1c3RPbmVgIGFuZCBgY291bnRgIG9wdGlvbnMuXG4gKiBAcmV0dXJucyB7QXJyYXk8RG9jdW1lbnQ+fERvY3VtZW50fE9iamVjdHxBcnJheTxPYmplY3Q+fSB0aGUgcG9wdWxhdGVkIHZpcnR1YWwgdmFsdWUgdGhhdCB3YXMgc2V0XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXRQb3B1bGF0ZWRWaXJ0dWFsVmFsdWUocG9wdWxhdGVkVmlydHVhbHMsIG5hbWUsIHYsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuanVzdE9uZSB8fCBvcHRpb25zLmNvdW50KSB7XG4gICAgcG9wdWxhdGVkVmlydHVhbHNbbmFtZV0gPSBBcnJheS5pc0FycmF5KHYpID9cbiAgICAgIHZbMF0gOlxuICAgICAgdjtcblxuICAgIGlmICh0eXBlb2YgcG9wdWxhdGVkVmlydHVhbHNbbmFtZV0gIT09ICdvYmplY3QnKSB7XG4gICAgICBwb3B1bGF0ZWRWaXJ0dWFsc1tuYW1lXSA9IG9wdGlvbnMuY291bnQgPyB2IDogbnVsbDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcG9wdWxhdGVkVmlydHVhbHNbbmFtZV0gPSBBcnJheS5pc0FycmF5KHYpID9cbiAgICAgIHYgOlxuICAgICAgdiA9PSBudWxsID8gW10gOiBbdl07XG5cbiAgICBwb3B1bGF0ZWRWaXJ0dWFsc1tuYW1lXSA9IHBvcHVsYXRlZFZpcnR1YWxzW25hbWVdLmZpbHRlcihmdW5jdGlvbihkb2MpIHtcbiAgICAgIHJldHVybiBkb2MgJiYgdHlwZW9mIGRvYyA9PT0gJ29iamVjdCc7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcG9wdWxhdGVkVmlydHVhbHNbbmFtZV07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/populate/setPopulatedVirtualValue.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/populate/skipPopulateValue.js":
/*!**********************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/populate/skipPopulateValue.js ***!
  \**********************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function SkipPopulateValue(val) {\n  if (!(this instanceof SkipPopulateValue)) {\n    return new SkipPopulateValue(val);\n  }\n\n  this.val = val;\n  return this;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvc2tpcFBvcHVsYXRlVmFsdWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvc2tpcFBvcHVsYXRlVmFsdWUuanM/N2EzMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gU2tpcFBvcHVsYXRlVmFsdWUodmFsKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTa2lwUG9wdWxhdGVWYWx1ZSkpIHtcbiAgICByZXR1cm4gbmV3IFNraXBQb3B1bGF0ZVZhbHVlKHZhbCk7XG4gIH1cblxuICB0aGlzLnZhbCA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/populate/skipPopulateValue.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/populate/validateRef.js":
/*!****************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/populate/validateRef.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst MongooseError = __webpack_require__(/*! ../../error/mongooseError */ \"../backend/node_modules/mongoose/lib/error/mongooseError.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\nmodule.exports = validateRef;\n\nfunction validateRef(ref, path) {\n  if (typeof ref === 'string') {\n    return;\n  }\n\n  if (typeof ref === 'function') {\n    return;\n  }\n\n  throw new MongooseError('Invalid ref at path \"' + path + '\". Got ' +\n    util.inspect(ref, { depth: 0 }));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcG9wdWxhdGUvdmFsaWRhdGVSZWYuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsOEZBQTJCO0FBQ3pELGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wb3B1bGF0ZS92YWxpZGF0ZVJlZi5qcz85MmM0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4uLy4uL2Vycm9yL21vbmdvb3NlRXJyb3InKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gdmFsaWRhdGVSZWY7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUmVmKHJlZiwgcGF0aCkge1xuICBpZiAodHlwZW9mIHJlZiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdJbnZhbGlkIHJlZiBhdCBwYXRoIFwiJyArIHBhdGggKyAnXCIuIEdvdCAnICtcbiAgICB1dGlsLmluc3BlY3QocmVmLCB7IGRlcHRoOiAwIH0pKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/populate/validateRef.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/printJestWarning.js":
/*!************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/printJestWarning.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst utils = __webpack_require__(/*! ../utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\n\nif (typeof jest !== 'undefined' && !process.env.SUPPRESS_JEST_WARNINGS) {\n  if (typeof window !== 'undefined') {\n    utils.warn('Mongoose: looks like you\\'re trying to test a Mongoose app ' +\n      'with Jest\\'s default jsdom test environment. Please make sure you read ' +\n      'Mongoose\\'s docs on configuring Jest to test Node.js apps: ' +\n      'https://mongoosejs.com/docs/jest.html. Set the SUPPRESS_JEST_WARNINGS to true ' +\n      'to hide this warning.');\n  }\n\n  if (setTimeout.clock != null && typeof setTimeout.clock.Date === 'function') {\n    utils.warn('Mongoose: looks like you\\'re trying to test a Mongoose app ' +\n      'with Jest\\'s mock timers enabled. Please make sure you read ' +\n      'Mongoose\\'s docs on configuring Jest to test Node.js apps: ' +\n      'https://mongoosejs.com/docs/jest.html. Set the SUPPRESS_JEST_WARNINGS to true ' +\n      'to hide this warning.');\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcHJpbnRKZXN0V2FybmluZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsK0RBQVU7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3ByaW50SmVzdFdhcm5pbmcuanM/ZmVkMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuaWYgKHR5cGVvZiBqZXN0ICE9PSAndW5kZWZpbmVkJyAmJiAhcHJvY2Vzcy5lbnYuU1VQUFJFU1NfSkVTVF9XQVJOSU5HUykge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB1dGlscy53YXJuKCdNb25nb29zZTogbG9va3MgbGlrZSB5b3VcXCdyZSB0cnlpbmcgdG8gdGVzdCBhIE1vbmdvb3NlIGFwcCAnICtcbiAgICAgICd3aXRoIEplc3RcXCdzIGRlZmF1bHQganNkb20gdGVzdCBlbnZpcm9ubWVudC4gUGxlYXNlIG1ha2Ugc3VyZSB5b3UgcmVhZCAnICtcbiAgICAgICdNb25nb29zZVxcJ3MgZG9jcyBvbiBjb25maWd1cmluZyBKZXN0IHRvIHRlc3QgTm9kZS5qcyBhcHBzOiAnICtcbiAgICAgICdodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvamVzdC5odG1sLiBTZXQgdGhlIFNVUFBSRVNTX0pFU1RfV0FSTklOR1MgdG8gdHJ1ZSAnICtcbiAgICAgICd0byBoaWRlIHRoaXMgd2FybmluZy4nKTtcbiAgfVxuXG4gIGlmIChzZXRUaW1lb3V0LmNsb2NrICE9IG51bGwgJiYgdHlwZW9mIHNldFRpbWVvdXQuY2xvY2suRGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHV0aWxzLndhcm4oJ01vbmdvb3NlOiBsb29rcyBsaWtlIHlvdVxcJ3JlIHRyeWluZyB0byB0ZXN0IGEgTW9uZ29vc2UgYXBwICcgK1xuICAgICAgJ3dpdGggSmVzdFxcJ3MgbW9jayB0aW1lcnMgZW5hYmxlZC4gUGxlYXNlIG1ha2Ugc3VyZSB5b3UgcmVhZCAnICtcbiAgICAgICdNb25nb29zZVxcJ3MgZG9jcyBvbiBjb25maWd1cmluZyBKZXN0IHRvIHRlc3QgTm9kZS5qcyBhcHBzOiAnICtcbiAgICAgICdodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvamVzdC5odG1sLiBTZXQgdGhlIFNVUFBSRVNTX0pFU1RfV0FSTklOR1MgdG8gdHJ1ZSAnICtcbiAgICAgICd0byBoaWRlIHRoaXMgd2FybmluZy4nKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/printJestWarning.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/processConnectionOptions.js":
/*!********************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/processConnectionOptions.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst clone = __webpack_require__(/*! ./clone */ \"../backend/node_modules/mongoose/lib/helpers/clone.js\");\nconst MongooseError = __webpack_require__(/*! ../error/index */ \"../backend/node_modules/mongoose/lib/error/index.js\");\n\nfunction processConnectionOptions(uri, options) {\n  const opts = options ? options : {};\n  const readPreference = opts.readPreference\n    ? opts.readPreference\n    : getUriReadPreference(uri);\n\n  const clonedOpts = clone(opts);\n  const resolvedOpts = (readPreference && readPreference !== 'primary' && readPreference !== 'primaryPreferred')\n    ? resolveOptsConflicts(readPreference, clonedOpts)\n    : clonedOpts;\n\n  return resolvedOpts;\n}\n\nfunction resolveOptsConflicts(pref, opts) {\n  // don't silently override user-provided indexing options\n  if (setsIndexOptions(opts) && setsSecondaryRead(pref)) {\n    throwReadPreferenceError();\n  }\n\n  // if user has not explicitly set any auto-indexing options,\n  // we can silently default them all to false\n  else {\n    return defaultIndexOptsToFalse(opts);\n  }\n}\n\nfunction setsIndexOptions(opts) {\n  const configIdx = opts.config && opts.config.autoIndex;\n  const { autoCreate, autoIndex } = opts;\n  return !!(configIdx || autoCreate || autoIndex);\n}\n\nfunction setsSecondaryRead(prefString) {\n  return !!(prefString === 'secondary' || prefString === 'secondaryPreferred');\n}\n\nfunction getUriReadPreference(connectionString) {\n  const exp = /(?:&|\\?)readPreference=(\\w+)(?:&|$)/;\n  const match = exp.exec(connectionString);\n  return match ? match[1] : null;\n}\n\nfunction defaultIndexOptsToFalse(opts) {\n  opts.config = { autoIndex: false };\n  opts.autoCreate = false;\n  opts.autoIndex = false;\n  return opts;\n}\n\nfunction throwReadPreferenceError() {\n  throw new MongooseError(\n    'MongoDB prohibits index creation on connections that read from ' +\n            'non-primary replicas.  Connections that set \"readPreference\" to \"secondary\" or ' +\n            '\"secondaryPreferred\" may not opt-in to the following connection options: ' +\n            'autoCreate, autoIndex'\n  );\n}\n\nmodule.exports = processConnectionOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcHJvY2Vzc0Nvbm5lY3Rpb25PcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyxzRUFBUztBQUMvQixzQkFBc0IsbUJBQU8sQ0FBQywyRUFBZ0I7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSx3QkFBd0I7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcHJvY2Vzc0Nvbm5lY3Rpb25PcHRpb25zLmpzPzRhMDIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjbG9uZSA9IHJlcXVpcmUoJy4vY2xvbmUnKTtcbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci9pbmRleCcpO1xuXG5mdW5jdGlvbiBwcm9jZXNzQ29ubmVjdGlvbk9wdGlvbnModXJpLCBvcHRpb25zKSB7XG4gIGNvbnN0IG9wdHMgPSBvcHRpb25zID8gb3B0aW9ucyA6IHt9O1xuICBjb25zdCByZWFkUHJlZmVyZW5jZSA9IG9wdHMucmVhZFByZWZlcmVuY2VcbiAgICA/IG9wdHMucmVhZFByZWZlcmVuY2VcbiAgICA6IGdldFVyaVJlYWRQcmVmZXJlbmNlKHVyaSk7XG5cbiAgY29uc3QgY2xvbmVkT3B0cyA9IGNsb25lKG9wdHMpO1xuICBjb25zdCByZXNvbHZlZE9wdHMgPSAocmVhZFByZWZlcmVuY2UgJiYgcmVhZFByZWZlcmVuY2UgIT09ICdwcmltYXJ5JyAmJiByZWFkUHJlZmVyZW5jZSAhPT0gJ3ByaW1hcnlQcmVmZXJyZWQnKVxuICAgID8gcmVzb2x2ZU9wdHNDb25mbGljdHMocmVhZFByZWZlcmVuY2UsIGNsb25lZE9wdHMpXG4gICAgOiBjbG9uZWRPcHRzO1xuXG4gIHJldHVybiByZXNvbHZlZE9wdHM7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVPcHRzQ29uZmxpY3RzKHByZWYsIG9wdHMpIHtcbiAgLy8gZG9uJ3Qgc2lsZW50bHkgb3ZlcnJpZGUgdXNlci1wcm92aWRlZCBpbmRleGluZyBvcHRpb25zXG4gIGlmIChzZXRzSW5kZXhPcHRpb25zKG9wdHMpICYmIHNldHNTZWNvbmRhcnlSZWFkKHByZWYpKSB7XG4gICAgdGhyb3dSZWFkUHJlZmVyZW5jZUVycm9yKCk7XG4gIH1cblxuICAvLyBpZiB1c2VyIGhhcyBub3QgZXhwbGljaXRseSBzZXQgYW55IGF1dG8taW5kZXhpbmcgb3B0aW9ucyxcbiAgLy8gd2UgY2FuIHNpbGVudGx5IGRlZmF1bHQgdGhlbSBhbGwgdG8gZmFsc2VcbiAgZWxzZSB7XG4gICAgcmV0dXJuIGRlZmF1bHRJbmRleE9wdHNUb0ZhbHNlKG9wdHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldHNJbmRleE9wdGlvbnMob3B0cykge1xuICBjb25zdCBjb25maWdJZHggPSBvcHRzLmNvbmZpZyAmJiBvcHRzLmNvbmZpZy5hdXRvSW5kZXg7XG4gIGNvbnN0IHsgYXV0b0NyZWF0ZSwgYXV0b0luZGV4IH0gPSBvcHRzO1xuICByZXR1cm4gISEoY29uZmlnSWR4IHx8IGF1dG9DcmVhdGUgfHwgYXV0b0luZGV4KTtcbn1cblxuZnVuY3Rpb24gc2V0c1NlY29uZGFyeVJlYWQocHJlZlN0cmluZykge1xuICByZXR1cm4gISEocHJlZlN0cmluZyA9PT0gJ3NlY29uZGFyeScgfHwgcHJlZlN0cmluZyA9PT0gJ3NlY29uZGFyeVByZWZlcnJlZCcpO1xufVxuXG5mdW5jdGlvbiBnZXRVcmlSZWFkUHJlZmVyZW5jZShjb25uZWN0aW9uU3RyaW5nKSB7XG4gIGNvbnN0IGV4cCA9IC8oPzomfFxcPylyZWFkUHJlZmVyZW5jZT0oXFx3KykoPzomfCQpLztcbiAgY29uc3QgbWF0Y2ggPSBleHAuZXhlYyhjb25uZWN0aW9uU3RyaW5nKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiBudWxsO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0SW5kZXhPcHRzVG9GYWxzZShvcHRzKSB7XG4gIG9wdHMuY29uZmlnID0geyBhdXRvSW5kZXg6IGZhbHNlIH07XG4gIG9wdHMuYXV0b0NyZWF0ZSA9IGZhbHNlO1xuICBvcHRzLmF1dG9JbmRleCA9IGZhbHNlO1xuICByZXR1cm4gb3B0cztcbn1cblxuZnVuY3Rpb24gdGhyb3dSZWFkUHJlZmVyZW5jZUVycm9yKCkge1xuICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcihcbiAgICAnTW9uZ29EQiBwcm9oaWJpdHMgaW5kZXggY3JlYXRpb24gb24gY29ubmVjdGlvbnMgdGhhdCByZWFkIGZyb20gJyArXG4gICAgICAgICAgICAnbm9uLXByaW1hcnkgcmVwbGljYXMuICBDb25uZWN0aW9ucyB0aGF0IHNldCBcInJlYWRQcmVmZXJlbmNlXCIgdG8gXCJzZWNvbmRhcnlcIiBvciAnICtcbiAgICAgICAgICAgICdcInNlY29uZGFyeVByZWZlcnJlZFwiIG1heSBub3Qgb3B0LWluIHRvIHRoZSBmb2xsb3dpbmcgY29ubmVjdGlvbiBvcHRpb25zOiAnICtcbiAgICAgICAgICAgICdhdXRvQ3JlYXRlLCBhdXRvSW5kZXgnXG4gICk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcHJvY2Vzc0Nvbm5lY3Rpb25PcHRpb25zO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/processConnectionOptions.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/projection/applyProjection.js":
/*!**********************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/projection/applyProjection.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst hasIncludedChildren = __webpack_require__(/*! ./hasIncludedChildren */ \"../backend/node_modules/mongoose/lib/helpers/projection/hasIncludedChildren.js\");\nconst isExclusive = __webpack_require__(/*! ./isExclusive */ \"../backend/node_modules/mongoose/lib/helpers/projection/isExclusive.js\");\nconst isInclusive = __webpack_require__(/*! ./isInclusive */ \"../backend/node_modules/mongoose/lib/helpers/projection/isInclusive.js\");\nconst isPOJO = (__webpack_require__(/*! ../../utils */ \"../backend/node_modules/mongoose/lib/utils.js\").isPOJO);\n\nmodule.exports = function applyProjection(doc, projection, _hasIncludedChildren) {\n  if (projection == null) {\n    return doc;\n  }\n  if (doc == null) {\n    return doc;\n  }\n\n  let exclude = null;\n  if (isInclusive(projection)) {\n    exclude = false;\n  } else if (isExclusive(projection)) {\n    exclude = true;\n  }\n\n  if (exclude == null) {\n    return doc;\n  } else if (exclude) {\n    _hasIncludedChildren = _hasIncludedChildren || hasIncludedChildren(projection);\n    return applyExclusiveProjection(doc, projection, _hasIncludedChildren);\n  } else {\n    _hasIncludedChildren = _hasIncludedChildren || hasIncludedChildren(projection);\n    return applyInclusiveProjection(doc, projection, _hasIncludedChildren);\n  }\n};\n\nfunction applyExclusiveProjection(doc, projection, hasIncludedChildren, projectionLimb, prefix) {\n  if (doc == null || typeof doc !== 'object') {\n    return doc;\n  }\n  const ret = { ...doc };\n  projectionLimb = prefix ? (projectionLimb || {}) : projection;\n\n  for (const key of Object.keys(ret)) {\n    const fullPath = prefix ? prefix + '.' + key : key;\n    if (projection.hasOwnProperty(fullPath) || projectionLimb.hasOwnProperty(key)) {\n      if (isPOJO(projection[fullPath]) || isPOJO(projectionLimb[key])) {\n        ret[key] = applyExclusiveProjection(ret[key], projection, hasIncludedChildren, projectionLimb[key], fullPath);\n      } else {\n        delete ret[key];\n      }\n    } else if (hasIncludedChildren[fullPath]) {\n      ret[key] = applyExclusiveProjection(ret[key], projection, hasIncludedChildren, projectionLimb[key], fullPath);\n    }\n  }\n  return ret;\n}\n\nfunction applyInclusiveProjection(doc, projection, hasIncludedChildren, projectionLimb, prefix) {\n  if (doc == null || typeof doc !== 'object') {\n    return doc;\n  }\n  const ret = { ...doc };\n  projectionLimb = prefix ? (projectionLimb || {}) : projection;\n\n  for (const key of Object.keys(ret)) {\n    const fullPath = prefix ? prefix + '.' + key : key;\n    if (projection.hasOwnProperty(fullPath) || projectionLimb.hasOwnProperty(key)) {\n      if (isPOJO(projection[fullPath]) || isPOJO(projectionLimb[key])) {\n        ret[key] = applyInclusiveProjection(ret[key], projection, hasIncludedChildren, projectionLimb[key], fullPath);\n      }\n      continue;\n    } else if (hasIncludedChildren[fullPath]) {\n      ret[key] = applyInclusiveProjection(ret[key], projection, hasIncludedChildren, projectionLimb[key], fullPath);\n    } else {\n      delete ret[key];\n    }\n  }\n  return ret;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcHJvamVjdGlvbi9hcHBseVByb2plY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsNEJBQTRCLG1CQUFPLENBQUMsNkdBQXVCO0FBQzNELG9CQUFvQixtQkFBTyxDQUFDLDZGQUFlO0FBQzNDLG9CQUFvQixtQkFBTyxDQUFDLDZGQUFlO0FBQzNDLGVBQWUsZ0dBQTZCOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsaURBQWlEOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9qZWN0aW9uL2FwcGx5UHJvamVjdGlvbi5qcz9hYTc2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaGFzSW5jbHVkZWRDaGlsZHJlbiA9IHJlcXVpcmUoJy4vaGFzSW5jbHVkZWRDaGlsZHJlbicpO1xuY29uc3QgaXNFeGNsdXNpdmUgPSByZXF1aXJlKCcuL2lzRXhjbHVzaXZlJyk7XG5jb25zdCBpc0luY2x1c2l2ZSA9IHJlcXVpcmUoJy4vaXNJbmNsdXNpdmUnKTtcbmNvbnN0IGlzUE9KTyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJykuaXNQT0pPO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGFwcGx5UHJvamVjdGlvbihkb2MsIHByb2plY3Rpb24sIF9oYXNJbmNsdWRlZENoaWxkcmVuKSB7XG4gIGlmIChwcm9qZWN0aW9uID09IG51bGwpIHtcbiAgICByZXR1cm4gZG9jO1xuICB9XG4gIGlmIChkb2MgPT0gbnVsbCkge1xuICAgIHJldHVybiBkb2M7XG4gIH1cblxuICBsZXQgZXhjbHVkZSA9IG51bGw7XG4gIGlmIChpc0luY2x1c2l2ZShwcm9qZWN0aW9uKSkge1xuICAgIGV4Y2x1ZGUgPSBmYWxzZTtcbiAgfSBlbHNlIGlmIChpc0V4Y2x1c2l2ZShwcm9qZWN0aW9uKSkge1xuICAgIGV4Y2x1ZGUgPSB0cnVlO1xuICB9XG5cbiAgaWYgKGV4Y2x1ZGUgPT0gbnVsbCkge1xuICAgIHJldHVybiBkb2M7XG4gIH0gZWxzZSBpZiAoZXhjbHVkZSkge1xuICAgIF9oYXNJbmNsdWRlZENoaWxkcmVuID0gX2hhc0luY2x1ZGVkQ2hpbGRyZW4gfHwgaGFzSW5jbHVkZWRDaGlsZHJlbihwcm9qZWN0aW9uKTtcbiAgICByZXR1cm4gYXBwbHlFeGNsdXNpdmVQcm9qZWN0aW9uKGRvYywgcHJvamVjdGlvbiwgX2hhc0luY2x1ZGVkQ2hpbGRyZW4pO1xuICB9IGVsc2Uge1xuICAgIF9oYXNJbmNsdWRlZENoaWxkcmVuID0gX2hhc0luY2x1ZGVkQ2hpbGRyZW4gfHwgaGFzSW5jbHVkZWRDaGlsZHJlbihwcm9qZWN0aW9uKTtcbiAgICByZXR1cm4gYXBwbHlJbmNsdXNpdmVQcm9qZWN0aW9uKGRvYywgcHJvamVjdGlvbiwgX2hhc0luY2x1ZGVkQ2hpbGRyZW4pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBhcHBseUV4Y2x1c2l2ZVByb2plY3Rpb24oZG9jLCBwcm9qZWN0aW9uLCBoYXNJbmNsdWRlZENoaWxkcmVuLCBwcm9qZWN0aW9uTGltYiwgcHJlZml4KSB7XG4gIGlmIChkb2MgPT0gbnVsbCB8fCB0eXBlb2YgZG9jICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBkb2M7XG4gIH1cbiAgY29uc3QgcmV0ID0geyAuLi5kb2MgfTtcbiAgcHJvamVjdGlvbkxpbWIgPSBwcmVmaXggPyAocHJvamVjdGlvbkxpbWIgfHwge30pIDogcHJvamVjdGlvbjtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhyZXQpKSB7XG4gICAgY29uc3QgZnVsbFBhdGggPSBwcmVmaXggPyBwcmVmaXggKyAnLicgKyBrZXkgOiBrZXk7XG4gICAgaWYgKHByb2plY3Rpb24uaGFzT3duUHJvcGVydHkoZnVsbFBhdGgpIHx8IHByb2plY3Rpb25MaW1iLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGlmIChpc1BPSk8ocHJvamVjdGlvbltmdWxsUGF0aF0pIHx8IGlzUE9KTyhwcm9qZWN0aW9uTGltYltrZXldKSkge1xuICAgICAgICByZXRba2V5XSA9IGFwcGx5RXhjbHVzaXZlUHJvamVjdGlvbihyZXRba2V5XSwgcHJvamVjdGlvbiwgaGFzSW5jbHVkZWRDaGlsZHJlbiwgcHJvamVjdGlvbkxpbWJba2V5XSwgZnVsbFBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHJldFtrZXldO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGFzSW5jbHVkZWRDaGlsZHJlbltmdWxsUGF0aF0pIHtcbiAgICAgIHJldFtrZXldID0gYXBwbHlFeGNsdXNpdmVQcm9qZWN0aW9uKHJldFtrZXldLCBwcm9qZWN0aW9uLCBoYXNJbmNsdWRlZENoaWxkcmVuLCBwcm9qZWN0aW9uTGltYltrZXldLCBmdWxsUGF0aCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGFwcGx5SW5jbHVzaXZlUHJvamVjdGlvbihkb2MsIHByb2plY3Rpb24sIGhhc0luY2x1ZGVkQ2hpbGRyZW4sIHByb2plY3Rpb25MaW1iLCBwcmVmaXgpIHtcbiAgaWYgKGRvYyA9PSBudWxsIHx8IHR5cGVvZiBkb2MgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGRvYztcbiAgfVxuICBjb25zdCByZXQgPSB7IC4uLmRvYyB9O1xuICBwcm9qZWN0aW9uTGltYiA9IHByZWZpeCA/IChwcm9qZWN0aW9uTGltYiB8fCB7fSkgOiBwcm9qZWN0aW9uO1xuXG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHJldCkpIHtcbiAgICBjb25zdCBmdWxsUGF0aCA9IHByZWZpeCA/IHByZWZpeCArICcuJyArIGtleSA6IGtleTtcbiAgICBpZiAocHJvamVjdGlvbi5oYXNPd25Qcm9wZXJ0eShmdWxsUGF0aCkgfHwgcHJvamVjdGlvbkxpbWIuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgaWYgKGlzUE9KTyhwcm9qZWN0aW9uW2Z1bGxQYXRoXSkgfHwgaXNQT0pPKHByb2plY3Rpb25MaW1iW2tleV0pKSB7XG4gICAgICAgIHJldFtrZXldID0gYXBwbHlJbmNsdXNpdmVQcm9qZWN0aW9uKHJldFtrZXldLCBwcm9qZWN0aW9uLCBoYXNJbmNsdWRlZENoaWxkcmVuLCBwcm9qZWN0aW9uTGltYltrZXldLCBmdWxsUGF0aCk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKGhhc0luY2x1ZGVkQ2hpbGRyZW5bZnVsbFBhdGhdKSB7XG4gICAgICByZXRba2V5XSA9IGFwcGx5SW5jbHVzaXZlUHJvamVjdGlvbihyZXRba2V5XSwgcHJvamVjdGlvbiwgaGFzSW5jbHVkZWRDaGlsZHJlbiwgcHJvamVjdGlvbkxpbWJba2V5XSwgZnVsbFBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgcmV0W2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/projection/applyProjection.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/projection/hasIncludedChildren.js":
/*!**************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/projection/hasIncludedChildren.js ***!
  \**************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Creates an object that precomputes whether a given path has child fields in\n * the projection.\n *\n * #### Example:\n *\n *     const res = hasIncludedChildren({ 'a.b.c': 0 });\n *     res.a; // 1\n *     res['a.b']; // 1\n *     res['a.b.c']; // 1\n *     res['a.c']; // undefined\n *\n * @param {Object} fields\n * @api private\n */\n\nmodule.exports = function hasIncludedChildren(fields) {\n  const hasIncludedChildren = {};\n  const keys = Object.keys(fields);\n\n  for (const key of keys) {\n\n    if (key.indexOf('.') === -1) {\n      hasIncludedChildren[key] = 1;\n      continue;\n    }\n    const parts = key.split('.');\n    let c = parts[0];\n\n    for (let i = 0; i < parts.length; ++i) {\n      hasIncludedChildren[c] = 1;\n      if (i + 1 < parts.length) {\n        c = c + '.' + parts[i + 1];\n      }\n    }\n  }\n\n  return hasIncludedChildren;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcHJvamVjdGlvbi9oYXNJbmNsdWRlZENoaWxkcmVuLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxZQUFZO0FBQ3JELGNBQWM7QUFDZCxtQkFBbUI7QUFDbkIscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3Byb2plY3Rpb24vaGFzSW5jbHVkZWRDaGlsZHJlbi5qcz85YThiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCB0aGF0IHByZWNvbXB1dGVzIHdoZXRoZXIgYSBnaXZlbiBwYXRoIGhhcyBjaGlsZCBmaWVsZHMgaW5cbiAqIHRoZSBwcm9qZWN0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcmVzID0gaGFzSW5jbHVkZWRDaGlsZHJlbih7ICdhLmIuYyc6IDAgfSk7XG4gKiAgICAgcmVzLmE7IC8vIDFcbiAqICAgICByZXNbJ2EuYiddOyAvLyAxXG4gKiAgICAgcmVzWydhLmIuYyddOyAvLyAxXG4gKiAgICAgcmVzWydhLmMnXTsgLy8gdW5kZWZpbmVkXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGZpZWxkc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNJbmNsdWRlZENoaWxkcmVuKGZpZWxkcykge1xuICBjb25zdCBoYXNJbmNsdWRlZENoaWxkcmVuID0ge307XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhmaWVsZHMpO1xuXG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcblxuICAgIGlmIChrZXkuaW5kZXhPZignLicpID09PSAtMSkge1xuICAgICAgaGFzSW5jbHVkZWRDaGlsZHJlbltrZXldID0gMTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBwYXJ0cyA9IGtleS5zcGxpdCgnLicpO1xuICAgIGxldCBjID0gcGFydHNbMF07XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBoYXNJbmNsdWRlZENoaWxkcmVuW2NdID0gMTtcbiAgICAgIGlmIChpICsgMSA8IHBhcnRzLmxlbmd0aCkge1xuICAgICAgICBjID0gYyArICcuJyArIHBhcnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gaGFzSW5jbHVkZWRDaGlsZHJlbjtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/projection/hasIncludedChildren.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js":
/*!***************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js ***!
  \***************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = function isDefiningProjection(val) {\n  if (val == null) {\n    // `undefined` or `null` become exclusive projections\n    return true;\n  }\n  if (typeof val === 'object') {\n    // Only cases where a value does **not** define whether the whole projection\n    // is inclusive or exclusive are `$meta` and `$slice`.\n    return !('$meta' in val) && !('$slice' in val);\n  }\n  return true;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcHJvamVjdGlvbi9pc0RlZmluaW5nUHJvamVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcHJvamVjdGlvbi9pc0RlZmluaW5nUHJvamVjdGlvbi5qcz9jZjI2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzRGVmaW5pbmdQcm9qZWN0aW9uKHZhbCkge1xuICBpZiAodmFsID09IG51bGwpIHtcbiAgICAvLyBgdW5kZWZpbmVkYCBvciBgbnVsbGAgYmVjb21lIGV4Y2x1c2l2ZSBwcm9qZWN0aW9uc1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0Jykge1xuICAgIC8vIE9ubHkgY2FzZXMgd2hlcmUgYSB2YWx1ZSBkb2VzICoqbm90KiogZGVmaW5lIHdoZXRoZXIgdGhlIHdob2xlIHByb2plY3Rpb25cbiAgICAvLyBpcyBpbmNsdXNpdmUgb3IgZXhjbHVzaXZlIGFyZSBgJG1ldGFgIGFuZCBgJHNsaWNlYC5cbiAgICByZXR1cm4gISgnJG1ldGEnIGluIHZhbCkgJiYgISgnJHNsaWNlJyBpbiB2YWwpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/projection/isExclusive.js":
/*!******************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/projection/isExclusive.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst isDefiningProjection = __webpack_require__(/*! ./isDefiningProjection */ \"../backend/node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = function isExclusive(projection) {\n  if (projection == null) {\n    return null;\n  }\n\n  const keys = Object.keys(projection);\n  let exclude = null;\n\n  if (keys.length === 1 && keys[0] === '_id') {\n    exclude = !projection._id;\n  } else {\n    for (let ki = 0; ki < keys.length; ++ki) {\n      // Does this projection explicitly define inclusion/exclusion?\n      // Explicitly avoid `$meta` and `$slice`\n      const key = keys[ki];\n      if (key !== '_id' && isDefiningProjection(projection[key])) {\n        exclude = (projection[key] != null && typeof projection[key] === 'object') ?\n          isExclusive(projection[key]) :\n          !projection[key];\n        break;\n      }\n    }\n  }\n\n  return exclude;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcHJvamVjdGlvbi9pc0V4Y2x1c2l2ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw2QkFBNkIsbUJBQU8sQ0FBQywrR0FBd0I7O0FBRTdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0oscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9qZWN0aW9uL2lzRXhjbHVzaXZlLmpzP2FjNWUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpc0RlZmluaW5nUHJvamVjdGlvbiA9IHJlcXVpcmUoJy4vaXNEZWZpbmluZ1Byb2plY3Rpb24nKTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzRXhjbHVzaXZlKHByb2plY3Rpb24pIHtcbiAgaWYgKHByb2plY3Rpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb2plY3Rpb24pO1xuICBsZXQgZXhjbHVkZSA9IG51bGw7XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAxICYmIGtleXNbMF0gPT09ICdfaWQnKSB7XG4gICAgZXhjbHVkZSA9ICFwcm9qZWN0aW9uLl9pZDtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGxldCBraSA9IDA7IGtpIDwga2V5cy5sZW5ndGg7ICsra2kpIHtcbiAgICAgIC8vIERvZXMgdGhpcyBwcm9qZWN0aW9uIGV4cGxpY2l0bHkgZGVmaW5lIGluY2x1c2lvbi9leGNsdXNpb24/XG4gICAgICAvLyBFeHBsaWNpdGx5IGF2b2lkIGAkbWV0YWAgYW5kIGAkc2xpY2VgXG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2tpXTtcbiAgICAgIGlmIChrZXkgIT09ICdfaWQnICYmIGlzRGVmaW5pbmdQcm9qZWN0aW9uKHByb2plY3Rpb25ba2V5XSkpIHtcbiAgICAgICAgZXhjbHVkZSA9IChwcm9qZWN0aW9uW2tleV0gIT0gbnVsbCAmJiB0eXBlb2YgcHJvamVjdGlvbltrZXldID09PSAnb2JqZWN0JykgP1xuICAgICAgICAgIGlzRXhjbHVzaXZlKHByb2plY3Rpb25ba2V5XSkgOlxuICAgICAgICAgICFwcm9qZWN0aW9uW2tleV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBleGNsdWRlO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/projection/isExclusive.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/projection/isInclusive.js":
/*!******************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/projection/isInclusive.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst isDefiningProjection = __webpack_require__(/*! ./isDefiningProjection */ \"../backend/node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = function isInclusive(projection) {\n  if (projection == null) {\n    return false;\n  }\n\n  const props = Object.keys(projection);\n  const numProps = props.length;\n  if (numProps === 0) {\n    return false;\n  }\n\n  for (let i = 0; i < numProps; ++i) {\n    const prop = props[i];\n    // Plus paths can't define the projection (see gh-7050)\n    if (prop.startsWith('+')) {\n      continue;\n    }\n    // If field is truthy (1, true, etc.) and not an object, then this\n    // projection must be inclusive. If object, assume its $meta, $slice, etc.\n    if (isDefiningProjection(projection[prop]) && !!projection[prop]) {\n      if (projection[prop] != null && typeof projection[prop] === 'object') {\n        return isInclusive(projection[prop]);\n      } else {\n        return !!projection[prop];\n      }\n    }\n  }\n\n  return false;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcHJvamVjdGlvbi9pc0luY2x1c2l2ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw2QkFBNkIsbUJBQU8sQ0FBQywrR0FBd0I7O0FBRTdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9qZWN0aW9uL2lzSW5jbHVzaXZlLmpzP2ViNWMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpc0RlZmluaW5nUHJvamVjdGlvbiA9IHJlcXVpcmUoJy4vaXNEZWZpbmluZ1Byb2plY3Rpb24nKTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzSW5jbHVzaXZlKHByb2plY3Rpb24pIHtcbiAgaWYgKHByb2plY3Rpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHByb3BzID0gT2JqZWN0LmtleXMocHJvamVjdGlvbik7XG4gIGNvbnN0IG51bVByb3BzID0gcHJvcHMubGVuZ3RoO1xuICBpZiAobnVtUHJvcHMgPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVByb3BzOyArK2kpIHtcbiAgICBjb25zdCBwcm9wID0gcHJvcHNbaV07XG4gICAgLy8gUGx1cyBwYXRocyBjYW4ndCBkZWZpbmUgdGhlIHByb2plY3Rpb24gKHNlZSBnaC03MDUwKVxuICAgIGlmIChwcm9wLnN0YXJ0c1dpdGgoJysnKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIElmIGZpZWxkIGlzIHRydXRoeSAoMSwgdHJ1ZSwgZXRjLikgYW5kIG5vdCBhbiBvYmplY3QsIHRoZW4gdGhpc1xuICAgIC8vIHByb2plY3Rpb24gbXVzdCBiZSBpbmNsdXNpdmUuIElmIG9iamVjdCwgYXNzdW1lIGl0cyAkbWV0YSwgJHNsaWNlLCBldGMuXG4gICAgaWYgKGlzRGVmaW5pbmdQcm9qZWN0aW9uKHByb2plY3Rpb25bcHJvcF0pICYmICEhcHJvamVjdGlvbltwcm9wXSkge1xuICAgICAgaWYgKHByb2plY3Rpb25bcHJvcF0gIT0gbnVsbCAmJiB0eXBlb2YgcHJvamVjdGlvbltwcm9wXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGlzSW5jbHVzaXZlKHByb2plY3Rpb25bcHJvcF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICEhcHJvamVjdGlvbltwcm9wXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/projection/isInclusive.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/projection/isNestedProjection.js":
/*!*************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/projection/isNestedProjection.js ***!
  \*************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function isNestedProjection(val) {\n  if (val == null || typeof val !== 'object') {\n    return false;\n  }\n  return val.$slice == null && val.$elemMatch == null && val.$meta == null && val.$ == null;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcHJvamVjdGlvbi9pc05lc3RlZFByb2plY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcHJvamVjdGlvbi9pc05lc3RlZFByb2plY3Rpb24uanM/ZThkNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNOZXN0ZWRQcm9qZWN0aW9uKHZhbCkge1xuICBpZiAodmFsID09IG51bGwgfHwgdHlwZW9mIHZhbCAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbC4kc2xpY2UgPT0gbnVsbCAmJiB2YWwuJGVsZW1NYXRjaCA9PSBudWxsICYmIHZhbC4kbWV0YSA9PSBudWxsICYmIHZhbC4kID09IG51bGw7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/projection/isNestedProjection.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/projection/isPathExcluded.js":
/*!*********************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/projection/isPathExcluded.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst isDefiningProjection = __webpack_require__(/*! ./isDefiningProjection */ \"../backend/node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js\");\n\n/**\n * Determines if `path` is excluded by `projection`\n *\n * @param {Object} projection\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\nmodule.exports = function isPathExcluded(projection, path) {\n  if (projection == null) {\n    return false;\n  }\n\n  if (path === '_id') {\n    return projection._id === 0;\n  }\n\n  const paths = Object.keys(projection);\n  let type = null;\n\n  for (const _path of paths) {\n    if (isDefiningProjection(projection[_path])) {\n      type = projection[path] === 1 ? 'inclusive' : 'exclusive';\n      break;\n    }\n  }\n\n  if (type === 'inclusive') {\n    return projection[path] !== 1;\n  }\n  if (type === 'exclusive') {\n    return projection[path] === 0;\n  }\n  return false;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcHJvamVjdGlvbi9pc1BhdGhFeGNsdWRlZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw2QkFBNkIsbUJBQU8sQ0FBQywrR0FBd0I7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9qZWN0aW9uL2lzUGF0aEV4Y2x1ZGVkLmpzPzdkZDQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpc0RlZmluaW5nUHJvamVjdGlvbiA9IHJlcXVpcmUoJy4vaXNEZWZpbmluZ1Byb2plY3Rpb24nKTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGBwYXRoYCBpcyBleGNsdWRlZCBieSBgcHJvamVjdGlvbmBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvamVjdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzUGF0aEV4Y2x1ZGVkKHByb2plY3Rpb24sIHBhdGgpIHtcbiAgaWYgKHByb2plY3Rpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChwYXRoID09PSAnX2lkJykge1xuICAgIHJldHVybiBwcm9qZWN0aW9uLl9pZCA9PT0gMDtcbiAgfVxuXG4gIGNvbnN0IHBhdGhzID0gT2JqZWN0LmtleXMocHJvamVjdGlvbik7XG4gIGxldCB0eXBlID0gbnVsbDtcblxuICBmb3IgKGNvbnN0IF9wYXRoIG9mIHBhdGhzKSB7XG4gICAgaWYgKGlzRGVmaW5pbmdQcm9qZWN0aW9uKHByb2plY3Rpb25bX3BhdGhdKSkge1xuICAgICAgdHlwZSA9IHByb2plY3Rpb25bcGF0aF0gPT09IDEgPyAnaW5jbHVzaXZlJyA6ICdleGNsdXNpdmUnO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGUgPT09ICdpbmNsdXNpdmUnKSB7XG4gICAgcmV0dXJuIHByb2plY3Rpb25bcGF0aF0gIT09IDE7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdleGNsdXNpdmUnKSB7XG4gICAgcmV0dXJuIHByb2plY3Rpb25bcGF0aF0gPT09IDA7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/projection/isPathExcluded.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js":
/*!******************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js ***!
  \******************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = function isPathSelectedInclusive(fields, path) {\n  const chunks = path.split('.');\n  let cur = '';\n  let j;\n  let keys;\n  let numKeys;\n  for (let i = 0; i < chunks.length; ++i) {\n    cur += cur.length ? '.' : '' + chunks[i];\n    if (fields[cur]) {\n      keys = Object.keys(fields);\n      numKeys = keys.length;\n      for (j = 0; j < numKeys; ++j) {\n        if (keys[i].indexOf(cur + '.') === 0 && keys[i].indexOf(path) !== 0) {\n          continue;\n        }\n      }\n      return true;\n    }\n  }\n\n  return false;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcHJvamVjdGlvbi9pc1BhdGhTZWxlY3RlZEluY2x1c2l2ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9qZWN0aW9uL2lzUGF0aFNlbGVjdGVkSW5jbHVzaXZlLmpzPzZiN2QiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNQYXRoU2VsZWN0ZWRJbmNsdXNpdmUoZmllbGRzLCBwYXRoKSB7XG4gIGNvbnN0IGNodW5rcyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgbGV0IGN1ciA9ICcnO1xuICBsZXQgajtcbiAgbGV0IGtleXM7XG4gIGxldCBudW1LZXlzO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7ICsraSkge1xuICAgIGN1ciArPSBjdXIubGVuZ3RoID8gJy4nIDogJycgKyBjaHVua3NbaV07XG4gICAgaWYgKGZpZWxkc1tjdXJdKSB7XG4gICAgICBrZXlzID0gT2JqZWN0LmtleXMoZmllbGRzKTtcbiAgICAgIG51bUtleXMgPSBrZXlzLmxlbmd0aDtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBudW1LZXlzOyArK2opIHtcbiAgICAgICAgaWYgKGtleXNbaV0uaW5kZXhPZihjdXIgKyAnLicpID09PSAwICYmIGtleXNbaV0uaW5kZXhPZihwYXRoKSAhPT0gMCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/projection/isSubpath.js":
/*!****************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/projection/isSubpath.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Determines if `path2` is a subpath of or equal to `path1`\n *\n * @param {string} path1\n * @param {string} path2\n * @return {Boolean}\n * @api private\n */\n\nmodule.exports = function isSubpath(path1, path2) {\n  return path1 === path2 || path2.startsWith(path1 + '.');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcHJvamVjdGlvbi9pc1N1YnBhdGguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9qZWN0aW9uL2lzU3VicGF0aC5qcz9jODczIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGBwYXRoMmAgaXMgYSBzdWJwYXRoIG9mIG9yIGVxdWFsIHRvIGBwYXRoMWBcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aDFcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoMlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNTdWJwYXRoKHBhdGgxLCBwYXRoMikge1xuICByZXR1cm4gcGF0aDEgPT09IHBhdGgyIHx8IHBhdGgyLnN0YXJ0c1dpdGgocGF0aDEgKyAnLicpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/projection/isSubpath.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/projection/parseProjection.js":
/*!**********************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/projection/parseProjection.js ***!
  \**********************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Convert a string or array into a projection object, retaining all\n * `-` and `+` paths.\n */\n\nmodule.exports = function parseProjection(v, retainMinusPaths) {\n  const type = typeof v;\n\n  if (type === 'string') {\n    v = v.split(/\\s+/);\n  }\n  if (!Array.isArray(v) && Object.prototype.toString.call(v) !== '[object Arguments]') {\n    return v;\n  }\n\n  const len = v.length;\n  const ret = {};\n  for (let i = 0; i < len; ++i) {\n    let field = v[i];\n    if (!field) {\n      continue;\n    }\n    const include = '-' == field[0] ? 0 : 1;\n    if (!retainMinusPaths && include === 0) {\n      field = field.substring(1);\n    }\n    ret[field] = include;\n  }\n\n  return ret;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcHJvamVjdGlvbi9wYXJzZVByb2plY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9wcm9qZWN0aW9uL3BhcnNlUHJvamVjdGlvbi5qcz82ZjhlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb252ZXJ0IGEgc3RyaW5nIG9yIGFycmF5IGludG8gYSBwcm9qZWN0aW9uIG9iamVjdCwgcmV0YWluaW5nIGFsbFxuICogYC1gIGFuZCBgK2AgcGF0aHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZVByb2plY3Rpb24odiwgcmV0YWluTWludXNQYXRocykge1xuICBjb25zdCB0eXBlID0gdHlwZW9mIHY7XG5cbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgdiA9IHYuc3BsaXQoL1xccysvKTtcbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkodikgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHYpICE9PSAnW29iamVjdCBBcmd1bWVudHNdJykge1xuICAgIHJldHVybiB2O1xuICB9XG5cbiAgY29uc3QgbGVuID0gdi5sZW5ndGg7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgbGV0IGZpZWxkID0gdltpXTtcbiAgICBpZiAoIWZpZWxkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgaW5jbHVkZSA9ICctJyA9PSBmaWVsZFswXSA/IDAgOiAxO1xuICAgIGlmICghcmV0YWluTWludXNQYXRocyAmJiBpbmNsdWRlID09PSAwKSB7XG4gICAgICBmaWVsZCA9IGZpZWxkLnN1YnN0cmluZygxKTtcbiAgICB9XG4gICAgcmV0W2ZpZWxkXSA9IGluY2x1ZGU7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/projection/parseProjection.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/promiseOrCallback.js":
/*!*************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/promiseOrCallback.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst immediate = __webpack_require__(/*! ./immediate */ \"../backend/node_modules/mongoose/lib/helpers/immediate.js\");\n\nconst emittedSymbol = Symbol('mongoose#emitted');\n\nmodule.exports = function promiseOrCallback(callback, fn, ee, Promise) {\n  if (typeof callback === 'function') {\n    try {\n      return fn(function(error) {\n        if (error != null) {\n          if (ee != null && ee.listeners != null && ee.listeners('error').length > 0 && !error[emittedSymbol]) {\n            error[emittedSymbol] = true;\n            ee.emit('error', error);\n          }\n          try {\n            callback(error);\n          } catch (error) {\n            return immediate(() => {\n              throw error;\n            });\n          }\n          return;\n        }\n        callback.apply(this, arguments);\n      });\n    } catch (error) {\n      if (ee != null && ee.listeners != null && ee.listeners('error').length > 0 && !error[emittedSymbol]) {\n        error[emittedSymbol] = true;\n        ee.emit('error', error);\n      }\n\n      return callback(error);\n    }\n  }\n\n  Promise = Promise || global.Promise;\n\n  return new Promise((resolve, reject) => {\n    fn(function(error, res) {\n      if (error != null) {\n        if (ee != null && ee.listeners != null && ee.listeners('error').length > 0 && !error[emittedSymbol]) {\n          error[emittedSymbol] = true;\n          ee.emit('error', error);\n        }\n        return reject(error);\n      }\n      if (arguments.length > 2) {\n        return resolve(Array.prototype.slice.call(arguments, 1));\n      }\n      resolve(res);\n    });\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcHJvbWlzZU9yQ2FsbGJhY2suanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsa0JBQWtCLG1CQUFPLENBQUMsOEVBQWE7O0FBRXZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3Byb21pc2VPckNhbGxiYWNrLmpzP2I2NTgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpbW1lZGlhdGUgPSByZXF1aXJlKCcuL2ltbWVkaWF0ZScpO1xuXG5jb25zdCBlbWl0dGVkU3ltYm9sID0gU3ltYm9sKCdtb25nb29zZSNlbWl0dGVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcHJvbWlzZU9yQ2FsbGJhY2soY2FsbGJhY2ssIGZuLCBlZSwgUHJvbWlzZSkge1xuICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbihmdW5jdGlvbihlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChlZSAhPSBudWxsICYmIGVlLmxpc3RlbmVycyAhPSBudWxsICYmIGVlLmxpc3RlbmVycygnZXJyb3InKS5sZW5ndGggPiAwICYmICFlcnJvcltlbWl0dGVkU3ltYm9sXSkge1xuICAgICAgICAgICAgZXJyb3JbZW1pdHRlZFN5bWJvbF0gPSB0cnVlO1xuICAgICAgICAgICAgZWUuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBpbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZWUgIT0gbnVsbCAmJiBlZS5saXN0ZW5lcnMgIT0gbnVsbCAmJiBlZS5saXN0ZW5lcnMoJ2Vycm9yJykubGVuZ3RoID4gMCAmJiAhZXJyb3JbZW1pdHRlZFN5bWJvbF0pIHtcbiAgICAgICAgZXJyb3JbZW1pdHRlZFN5bWJvbF0gPSB0cnVlO1xuICAgICAgICBlZS5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yKTtcbiAgICB9XG4gIH1cblxuICBQcm9taXNlID0gUHJvbWlzZSB8fCBnbG9iYWwuUHJvbWlzZTtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGZuKGZ1bmN0aW9uKGVycm9yLCByZXMpIHtcbiAgICAgIGlmIChlcnJvciAhPSBudWxsKSB7XG4gICAgICAgIGlmIChlZSAhPSBudWxsICYmIGVlLmxpc3RlbmVycyAhPSBudWxsICYmIGVlLmxpc3RlbmVycygnZXJyb3InKS5sZW5ndGggPiAwICYmICFlcnJvcltlbWl0dGVkU3ltYm9sXSkge1xuICAgICAgICAgIGVycm9yW2VtaXR0ZWRTeW1ib2xdID0gdHJ1ZTtcbiAgICAgICAgICBlZS5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUocmVzKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/promiseOrCallback.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/query/applyGlobalOption.js":
/*!*******************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/query/applyGlobalOption.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst utils = __webpack_require__(/*! ../../utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\n\nfunction applyGlobalMaxTimeMS(options, connectionOptions, baseOptions) {\n  applyGlobalOption(options, connectionOptions, baseOptions, 'maxTimeMS');\n}\n\nfunction applyGlobalDiskUse(options, connectionOptions, baseOptions) {\n  applyGlobalOption(options, connectionOptions, baseOptions, 'allowDiskUse');\n}\n\nmodule.exports = {\n  applyGlobalMaxTimeMS,\n  applyGlobalDiskUse\n};\n\n\nfunction applyGlobalOption(options, connectionOptions, baseOptions, optionName) {\n  if (utils.hasUserDefinedProperty(options, optionName)) {\n    return;\n  }\n\n  if (utils.hasUserDefinedProperty(connectionOptions, optionName)) {\n    options[optionName] = connectionOptions[optionName];\n  } else if (utils.hasUserDefinedProperty(baseOptions, optionName)) {\n    options[optionName] = baseOptions[optionName];\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvYXBwbHlHbG9iYWxPcHRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLGtFQUFhOztBQUVuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3F1ZXJ5L2FwcGx5R2xvYmFsT3B0aW9uLmpzPzdjMGYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIGFwcGx5R2xvYmFsTWF4VGltZU1TKG9wdGlvbnMsIGNvbm5lY3Rpb25PcHRpb25zLCBiYXNlT3B0aW9ucykge1xuICBhcHBseUdsb2JhbE9wdGlvbihvcHRpb25zLCBjb25uZWN0aW9uT3B0aW9ucywgYmFzZU9wdGlvbnMsICdtYXhUaW1lTVMnKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlHbG9iYWxEaXNrVXNlKG9wdGlvbnMsIGNvbm5lY3Rpb25PcHRpb25zLCBiYXNlT3B0aW9ucykge1xuICBhcHBseUdsb2JhbE9wdGlvbihvcHRpb25zLCBjb25uZWN0aW9uT3B0aW9ucywgYmFzZU9wdGlvbnMsICdhbGxvd0Rpc2tVc2UnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFwcGx5R2xvYmFsTWF4VGltZU1TLFxuICBhcHBseUdsb2JhbERpc2tVc2Vcbn07XG5cblxuZnVuY3Rpb24gYXBwbHlHbG9iYWxPcHRpb24ob3B0aW9ucywgY29ubmVjdGlvbk9wdGlvbnMsIGJhc2VPcHRpb25zLCBvcHRpb25OYW1lKSB7XG4gIGlmICh1dGlscy5oYXNVc2VyRGVmaW5lZFByb3BlcnR5KG9wdGlvbnMsIG9wdGlvbk5hbWUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHV0aWxzLmhhc1VzZXJEZWZpbmVkUHJvcGVydHkoY29ubmVjdGlvbk9wdGlvbnMsIG9wdGlvbk5hbWUpKSB7XG4gICAgb3B0aW9uc1tvcHRpb25OYW1lXSA9IGNvbm5lY3Rpb25PcHRpb25zW29wdGlvbk5hbWVdO1xuICB9IGVsc2UgaWYgKHV0aWxzLmhhc1VzZXJEZWZpbmVkUHJvcGVydHkoYmFzZU9wdGlvbnMsIG9wdGlvbk5hbWUpKSB7XG4gICAgb3B0aW9uc1tvcHRpb25OYW1lXSA9IGJhc2VPcHRpb25zW29wdGlvbk5hbWVdO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/query/applyGlobalOption.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/query/cast$expr.js":
/*!***********************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/query/cast$expr.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst CastError = __webpack_require__(/*! ../../error/cast */ \"../backend/node_modules/mongoose/lib/error/cast.js\");\nconst StrictModeError = __webpack_require__(/*! ../../error/strict */ \"../backend/node_modules/mongoose/lib/error/strict.js\");\nconst castNumber = __webpack_require__(/*! ../../cast/number */ \"../backend/node_modules/mongoose/lib/cast/number.js\");\n\nconst booleanComparison = new Set(['$and', '$or']);\nconst comparisonOperator = new Set(['$cmp', '$eq', '$lt', '$lte', '$gt', '$gte']);\nconst arithmeticOperatorArray = new Set([\n  // avoid casting '$add' or '$subtract', because expressions can be either number or date,\n  // and we don't have a good way of inferring which arguments should be numbers and which should\n  // be dates.\n  '$multiply',\n  '$divide',\n  '$log',\n  '$mod',\n  '$trunc',\n  '$avg',\n  '$max',\n  '$min',\n  '$stdDevPop',\n  '$stdDevSamp',\n  '$sum'\n]);\nconst arithmeticOperatorNumber = new Set([\n  '$abs',\n  '$exp',\n  '$ceil',\n  '$floor',\n  '$ln',\n  '$log10',\n  '$sqrt',\n  '$sin',\n  '$cos',\n  '$tan',\n  '$asin',\n  '$acos',\n  '$atan',\n  '$atan2',\n  '$asinh',\n  '$acosh',\n  '$atanh',\n  '$sinh',\n  '$cosh',\n  '$tanh',\n  '$degreesToRadians',\n  '$radiansToDegrees'\n]);\nconst arrayElementOperators = new Set([\n  '$arrayElemAt',\n  '$first',\n  '$last'\n]);\nconst dateOperators = new Set([\n  '$year',\n  '$month',\n  '$week',\n  '$dayOfMonth',\n  '$dayOfYear',\n  '$hour',\n  '$minute',\n  '$second',\n  '$isoDayOfWeek',\n  '$isoWeekYear',\n  '$isoWeek',\n  '$millisecond'\n]);\nconst expressionOperator = new Set(['$not']);\n\nmodule.exports = function cast$expr(val, schema, strictQuery) {\n  if (typeof val !== 'object' || val === null) {\n    throw new Error('`$expr` must be an object');\n  }\n\n  return _castExpression(val, schema, strictQuery);\n};\n\nfunction _castExpression(val, schema, strictQuery) {\n  // Preserve the value if it represents a path or if it's null\n  if (isPath(val) || val === null) {\n    return val;\n  }\n\n  if (val.$cond != null) {\n    if (Array.isArray(val.$cond)) {\n      val.$cond = val.$cond.map(expr => _castExpression(expr, schema, strictQuery));\n    } else {\n      val.$cond.if = _castExpression(val.$cond.if, schema, strictQuery);\n      val.$cond.then = _castExpression(val.$cond.then, schema, strictQuery);\n      val.$cond.else = _castExpression(val.$cond.else, schema, strictQuery);\n    }\n  } else if (val.$ifNull != null) {\n    val.$ifNull.map(v => _castExpression(v, schema, strictQuery));\n  } else if (val.$switch != null) {\n    val.branches.map(v => _castExpression(v, schema, strictQuery));\n    val.default = _castExpression(val.default, schema, strictQuery);\n  }\n\n  const keys = Object.keys(val);\n  for (const key of keys) {\n    if (booleanComparison.has(key)) {\n      val[key] = val[key].map(v => _castExpression(v, schema, strictQuery));\n    } else if (comparisonOperator.has(key)) {\n      val[key] = castComparison(val[key], schema, strictQuery);\n    } else if (arithmeticOperatorArray.has(key)) {\n      val[key] = castArithmetic(val[key], schema, strictQuery);\n    } else if (arithmeticOperatorNumber.has(key)) {\n      val[key] = castNumberOperator(val[key], schema, strictQuery);\n    } else if (expressionOperator.has(key)) {\n      val[key] = _castExpression(val[key], schema, strictQuery);\n    }\n  }\n\n  if (val.$in) {\n    val.$in = castIn(val.$in, schema, strictQuery);\n  }\n  if (val.$size) {\n    val.$size = castNumberOperator(val.$size, schema, strictQuery);\n  }\n  if (val.$round) {\n    const $round = val.$round;\n    if (!Array.isArray($round) || $round.length < 1 || $round.length > 2) {\n      throw new CastError('Array', $round, '$round');\n    }\n    val.$round = $round.map(v => castNumberOperator(v, schema, strictQuery));\n  }\n\n  _omitUndefined(val);\n\n  return val;\n}\n\nfunction _omitUndefined(val) {\n  const keys = Object.keys(val);\n  for (let i = 0, len = keys.length; i < len; ++i) {\n    (val[keys[i]] === void 0) && delete val[keys[i]];\n  }\n}\n\n// { $op: <number> }\nfunction castNumberOperator(val) {\n  if (!isLiteral(val)) {\n    return val;\n  }\n\n  try {\n    return castNumber(val);\n  } catch (err) {\n    throw new CastError('Number', val);\n  }\n}\n\nfunction castIn(val, schema, strictQuery) {\n  const path = val[1];\n  if (!isPath(path)) {\n    return val;\n  }\n  const search = val[0];\n\n  const schematype = schema.path(path.slice(1));\n  if (schematype === null) {\n    if (strictQuery === false) {\n      return val;\n    } else if (strictQuery === 'throw') {\n      throw new StrictModeError('$in');\n    }\n\n    return void 0;\n  }\n\n  if (!schematype.$isMongooseArray) {\n    throw new Error('Path must be an array for $in');\n  }\n\n  return [\n    schematype.$isMongooseDocumentArray ? schematype.$embeddedSchemaType.cast(search) : schematype.caster.cast(search),\n    path\n  ];\n}\n\n// { $op: [<number>, <number>] }\nfunction castArithmetic(val) {\n  if (!Array.isArray(val)) {\n    if (!isLiteral(val)) {\n      return val;\n    }\n    try {\n      return castNumber(val);\n    } catch (err) {\n      throw new CastError('Number', val);\n    }\n  }\n\n  return val.map(v => {\n    if (!isLiteral(v)) {\n      return v;\n    }\n    try {\n      return castNumber(v);\n    } catch (err) {\n      throw new CastError('Number', v);\n    }\n  });\n}\n\n// { $op: [expression, expression] }\nfunction castComparison(val, schema, strictQuery) {\n  if (!Array.isArray(val) || val.length !== 2) {\n    throw new Error('Comparison operator must be an array of length 2');\n  }\n\n  val[0] = _castExpression(val[0], schema, strictQuery);\n  const lhs = val[0];\n\n  if (isLiteral(val[1])) {\n    let path = null;\n    let schematype = null;\n    let caster = null;\n    if (isPath(lhs)) {\n      path = lhs.slice(1);\n      schematype = schema.path(path);\n    } else if (typeof lhs === 'object' && lhs != null) {\n      for (const key of Object.keys(lhs)) {\n        if (dateOperators.has(key) && isPath(lhs[key])) {\n          path = lhs[key].slice(1) + '.' + key;\n          caster = castNumber;\n        } else if (arrayElementOperators.has(key) && isPath(lhs[key])) {\n          path = lhs[key].slice(1) + '.' + key;\n          schematype = schema.path(lhs[key].slice(1));\n          if (schematype != null) {\n            if (schematype.$isMongooseDocumentArray) {\n              schematype = schematype.$embeddedSchemaType;\n            } else if (schematype.$isMongooseArray) {\n              schematype = schematype.caster;\n            }\n          }\n        }\n      }\n    }\n\n    const is$literal = typeof val[1] === 'object' && val[1] != null && val[1].$literal != null;\n    if (schematype != null) {\n      if (is$literal) {\n        val[1] = { $literal: schematype.cast(val[1].$literal) };\n      } else {\n        val[1] = schematype.cast(val[1]);\n      }\n    } else if (caster != null) {\n      if (is$literal) {\n        try {\n          val[1] = { $literal: caster(val[1].$literal) };\n        } catch (err) {\n          throw new CastError(caster.name.replace(/^cast/, ''), val[1], path + '.$literal');\n        }\n      } else {\n        try {\n          val[1] = caster(val[1]);\n        } catch (err) {\n          throw new CastError(caster.name.replace(/^cast/, ''), val[1], path);\n        }\n      }\n    } else if (path != null && strictQuery === true) {\n      return void 0;\n    } else if (path != null && strictQuery === 'throw') {\n      throw new StrictModeError(path);\n    }\n  } else {\n    val[1] = _castExpression(val[1]);\n  }\n\n  return val;\n}\n\nfunction isPath(val) {\n  return typeof val === 'string' && val[0] === '$';\n}\n\nfunction isLiteral(val) {\n  if (typeof val === 'string' && val[0] === '$') {\n    return false;\n  }\n  if (typeof val === 'object' && val !== null && Object.keys(val).find(key => key[0] === '$')) {\n    // The `$literal` expression can make an object a literal\n    // https://www.mongodb.com/docs/manual/reference/operator/aggregation/literal/#mongodb-expression-exp.-literal\n    return val.$literal != null;\n  }\n  return true;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvY2FzdCRleHByLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGtCQUFrQixtQkFBTyxDQUFDLDRFQUFrQjtBQUM1Qyx3QkFBd0IsbUJBQU8sQ0FBQyxnRkFBb0I7QUFDcEQsbUJBQW1CLG1CQUFPLENBQUMsOEVBQW1COztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3F1ZXJ5L2Nhc3QkZXhwci5qcz8xNWIwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQ2FzdEVycm9yID0gcmVxdWlyZSgnLi4vLi4vZXJyb3IvY2FzdCcpO1xuY29uc3QgU3RyaWN0TW9kZUVycm9yID0gcmVxdWlyZSgnLi4vLi4vZXJyb3Ivc3RyaWN0Jyk7XG5jb25zdCBjYXN0TnVtYmVyID0gcmVxdWlyZSgnLi4vLi4vY2FzdC9udW1iZXInKTtcblxuY29uc3QgYm9vbGVhbkNvbXBhcmlzb24gPSBuZXcgU2V0KFsnJGFuZCcsICckb3InXSk7XG5jb25zdCBjb21wYXJpc29uT3BlcmF0b3IgPSBuZXcgU2V0KFsnJGNtcCcsICckZXEnLCAnJGx0JywgJyRsdGUnLCAnJGd0JywgJyRndGUnXSk7XG5jb25zdCBhcml0aG1ldGljT3BlcmF0b3JBcnJheSA9IG5ldyBTZXQoW1xuICAvLyBhdm9pZCBjYXN0aW5nICckYWRkJyBvciAnJHN1YnRyYWN0JywgYmVjYXVzZSBleHByZXNzaW9ucyBjYW4gYmUgZWl0aGVyIG51bWJlciBvciBkYXRlLFxuICAvLyBhbmQgd2UgZG9uJ3QgaGF2ZSBhIGdvb2Qgd2F5IG9mIGluZmVycmluZyB3aGljaCBhcmd1bWVudHMgc2hvdWxkIGJlIG51bWJlcnMgYW5kIHdoaWNoIHNob3VsZFxuICAvLyBiZSBkYXRlcy5cbiAgJyRtdWx0aXBseScsXG4gICckZGl2aWRlJyxcbiAgJyRsb2cnLFxuICAnJG1vZCcsXG4gICckdHJ1bmMnLFxuICAnJGF2ZycsXG4gICckbWF4JyxcbiAgJyRtaW4nLFxuICAnJHN0ZERldlBvcCcsXG4gICckc3RkRGV2U2FtcCcsXG4gICckc3VtJ1xuXSk7XG5jb25zdCBhcml0aG1ldGljT3BlcmF0b3JOdW1iZXIgPSBuZXcgU2V0KFtcbiAgJyRhYnMnLFxuICAnJGV4cCcsXG4gICckY2VpbCcsXG4gICckZmxvb3InLFxuICAnJGxuJyxcbiAgJyRsb2cxMCcsXG4gICckc3FydCcsXG4gICckc2luJyxcbiAgJyRjb3MnLFxuICAnJHRhbicsXG4gICckYXNpbicsXG4gICckYWNvcycsXG4gICckYXRhbicsXG4gICckYXRhbjInLFxuICAnJGFzaW5oJyxcbiAgJyRhY29zaCcsXG4gICckYXRhbmgnLFxuICAnJHNpbmgnLFxuICAnJGNvc2gnLFxuICAnJHRhbmgnLFxuICAnJGRlZ3JlZXNUb1JhZGlhbnMnLFxuICAnJHJhZGlhbnNUb0RlZ3JlZXMnXG5dKTtcbmNvbnN0IGFycmF5RWxlbWVudE9wZXJhdG9ycyA9IG5ldyBTZXQoW1xuICAnJGFycmF5RWxlbUF0JyxcbiAgJyRmaXJzdCcsXG4gICckbGFzdCdcbl0pO1xuY29uc3QgZGF0ZU9wZXJhdG9ycyA9IG5ldyBTZXQoW1xuICAnJHllYXInLFxuICAnJG1vbnRoJyxcbiAgJyR3ZWVrJyxcbiAgJyRkYXlPZk1vbnRoJyxcbiAgJyRkYXlPZlllYXInLFxuICAnJGhvdXInLFxuICAnJG1pbnV0ZScsXG4gICckc2Vjb25kJyxcbiAgJyRpc29EYXlPZldlZWsnLFxuICAnJGlzb1dlZWtZZWFyJyxcbiAgJyRpc29XZWVrJyxcbiAgJyRtaWxsaXNlY29uZCdcbl0pO1xuY29uc3QgZXhwcmVzc2lvbk9wZXJhdG9yID0gbmV3IFNldChbJyRub3QnXSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FzdCRleHByKHZhbCwgc2NoZW1hLCBzdHJpY3RRdWVyeSkge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gJ29iamVjdCcgfHwgdmFsID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgJGV4cHJgIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gIH1cblxuICByZXR1cm4gX2Nhc3RFeHByZXNzaW9uKHZhbCwgc2NoZW1hLCBzdHJpY3RRdWVyeSk7XG59O1xuXG5mdW5jdGlvbiBfY2FzdEV4cHJlc3Npb24odmFsLCBzY2hlbWEsIHN0cmljdFF1ZXJ5KSB7XG4gIC8vIFByZXNlcnZlIHRoZSB2YWx1ZSBpZiBpdCByZXByZXNlbnRzIGEgcGF0aCBvciBpZiBpdCdzIG51bGxcbiAgaWYgKGlzUGF0aCh2YWwpIHx8IHZhbCA9PT0gbnVsbCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBpZiAodmFsLiRjb25kICE9IG51bGwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwuJGNvbmQpKSB7XG4gICAgICB2YWwuJGNvbmQgPSB2YWwuJGNvbmQubWFwKGV4cHIgPT4gX2Nhc3RFeHByZXNzaW9uKGV4cHIsIHNjaGVtYSwgc3RyaWN0UXVlcnkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsLiRjb25kLmlmID0gX2Nhc3RFeHByZXNzaW9uKHZhbC4kY29uZC5pZiwgc2NoZW1hLCBzdHJpY3RRdWVyeSk7XG4gICAgICB2YWwuJGNvbmQudGhlbiA9IF9jYXN0RXhwcmVzc2lvbih2YWwuJGNvbmQudGhlbiwgc2NoZW1hLCBzdHJpY3RRdWVyeSk7XG4gICAgICB2YWwuJGNvbmQuZWxzZSA9IF9jYXN0RXhwcmVzc2lvbih2YWwuJGNvbmQuZWxzZSwgc2NoZW1hLCBzdHJpY3RRdWVyeSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHZhbC4kaWZOdWxsICE9IG51bGwpIHtcbiAgICB2YWwuJGlmTnVsbC5tYXAodiA9PiBfY2FzdEV4cHJlc3Npb24odiwgc2NoZW1hLCBzdHJpY3RRdWVyeSkpO1xuICB9IGVsc2UgaWYgKHZhbC4kc3dpdGNoICE9IG51bGwpIHtcbiAgICB2YWwuYnJhbmNoZXMubWFwKHYgPT4gX2Nhc3RFeHByZXNzaW9uKHYsIHNjaGVtYSwgc3RyaWN0UXVlcnkpKTtcbiAgICB2YWwuZGVmYXVsdCA9IF9jYXN0RXhwcmVzc2lvbih2YWwuZGVmYXVsdCwgc2NoZW1hLCBzdHJpY3RRdWVyeSk7XG4gIH1cblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGlmIChib29sZWFuQ29tcGFyaXNvbi5oYXMoa2V5KSkge1xuICAgICAgdmFsW2tleV0gPSB2YWxba2V5XS5tYXAodiA9PiBfY2FzdEV4cHJlc3Npb24odiwgc2NoZW1hLCBzdHJpY3RRdWVyeSkpO1xuICAgIH0gZWxzZSBpZiAoY29tcGFyaXNvbk9wZXJhdG9yLmhhcyhrZXkpKSB7XG4gICAgICB2YWxba2V5XSA9IGNhc3RDb21wYXJpc29uKHZhbFtrZXldLCBzY2hlbWEsIHN0cmljdFF1ZXJ5KTtcbiAgICB9IGVsc2UgaWYgKGFyaXRobWV0aWNPcGVyYXRvckFycmF5LmhhcyhrZXkpKSB7XG4gICAgICB2YWxba2V5XSA9IGNhc3RBcml0aG1ldGljKHZhbFtrZXldLCBzY2hlbWEsIHN0cmljdFF1ZXJ5KTtcbiAgICB9IGVsc2UgaWYgKGFyaXRobWV0aWNPcGVyYXRvck51bWJlci5oYXMoa2V5KSkge1xuICAgICAgdmFsW2tleV0gPSBjYXN0TnVtYmVyT3BlcmF0b3IodmFsW2tleV0sIHNjaGVtYSwgc3RyaWN0UXVlcnkpO1xuICAgIH0gZWxzZSBpZiAoZXhwcmVzc2lvbk9wZXJhdG9yLmhhcyhrZXkpKSB7XG4gICAgICB2YWxba2V5XSA9IF9jYXN0RXhwcmVzc2lvbih2YWxba2V5XSwgc2NoZW1hLCBzdHJpY3RRdWVyeSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHZhbC4kaW4pIHtcbiAgICB2YWwuJGluID0gY2FzdEluKHZhbC4kaW4sIHNjaGVtYSwgc3RyaWN0UXVlcnkpO1xuICB9XG4gIGlmICh2YWwuJHNpemUpIHtcbiAgICB2YWwuJHNpemUgPSBjYXN0TnVtYmVyT3BlcmF0b3IodmFsLiRzaXplLCBzY2hlbWEsIHN0cmljdFF1ZXJ5KTtcbiAgfVxuICBpZiAodmFsLiRyb3VuZCkge1xuICAgIGNvbnN0ICRyb3VuZCA9IHZhbC4kcm91bmQ7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KCRyb3VuZCkgfHwgJHJvdW5kLmxlbmd0aCA8IDEgfHwgJHJvdW5kLmxlbmd0aCA+IDIpIHtcbiAgICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJ0FycmF5JywgJHJvdW5kLCAnJHJvdW5kJyk7XG4gICAgfVxuICAgIHZhbC4kcm91bmQgPSAkcm91bmQubWFwKHYgPT4gY2FzdE51bWJlck9wZXJhdG9yKHYsIHNjaGVtYSwgc3RyaWN0UXVlcnkpKTtcbiAgfVxuXG4gIF9vbWl0VW5kZWZpbmVkKHZhbCk7XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gX29taXRVbmRlZmluZWQodmFsKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICh2YWxba2V5c1tpXV0gPT09IHZvaWQgMCkgJiYgZGVsZXRlIHZhbFtrZXlzW2ldXTtcbiAgfVxufVxuXG4vLyB7ICRvcDogPG51bWJlcj4gfVxuZnVuY3Rpb24gY2FzdE51bWJlck9wZXJhdG9yKHZhbCkge1xuICBpZiAoIWlzTGl0ZXJhbCh2YWwpKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGNhc3ROdW1iZXIodmFsKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IENhc3RFcnJvcignTnVtYmVyJywgdmFsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYXN0SW4odmFsLCBzY2hlbWEsIHN0cmljdFF1ZXJ5KSB7XG4gIGNvbnN0IHBhdGggPSB2YWxbMV07XG4gIGlmICghaXNQYXRoKHBhdGgpKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBjb25zdCBzZWFyY2ggPSB2YWxbMF07XG5cbiAgY29uc3Qgc2NoZW1hdHlwZSA9IHNjaGVtYS5wYXRoKHBhdGguc2xpY2UoMSkpO1xuICBpZiAoc2NoZW1hdHlwZSA9PT0gbnVsbCkge1xuICAgIGlmIChzdHJpY3RRdWVyeSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfSBlbHNlIGlmIChzdHJpY3RRdWVyeSA9PT0gJ3Rocm93Jykge1xuICAgICAgdGhyb3cgbmV3IFN0cmljdE1vZGVFcnJvcignJGluJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuXG4gIGlmICghc2NoZW1hdHlwZS4kaXNNb25nb29zZUFycmF5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYXRoIG11c3QgYmUgYW4gYXJyYXkgZm9yICRpbicpO1xuICB9XG5cbiAgcmV0dXJuIFtcbiAgICBzY2hlbWF0eXBlLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSA/IHNjaGVtYXR5cGUuJGVtYmVkZGVkU2NoZW1hVHlwZS5jYXN0KHNlYXJjaCkgOiBzY2hlbWF0eXBlLmNhc3Rlci5jYXN0KHNlYXJjaCksXG4gICAgcGF0aFxuICBdO1xufVxuXG4vLyB7ICRvcDogWzxudW1iZXI+LCA8bnVtYmVyPl0gfVxuZnVuY3Rpb24gY2FzdEFyaXRobWV0aWModmFsKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgaWYgKCFpc0xpdGVyYWwodmFsKSkge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjYXN0TnVtYmVyKHZhbCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdOdW1iZXInLCB2YWwpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YWwubWFwKHYgPT4ge1xuICAgIGlmICghaXNMaXRlcmFsKHYpKSB7XG4gICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjYXN0TnVtYmVyKHYpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IENhc3RFcnJvcignTnVtYmVyJywgdik7XG4gICAgfVxuICB9KTtcbn1cblxuLy8geyAkb3A6IFtleHByZXNzaW9uLCBleHByZXNzaW9uXSB9XG5mdW5jdGlvbiBjYXN0Q29tcGFyaXNvbih2YWwsIHNjaGVtYSwgc3RyaWN0UXVlcnkpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbCkgfHwgdmFsLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29tcGFyaXNvbiBvcGVyYXRvciBtdXN0IGJlIGFuIGFycmF5IG9mIGxlbmd0aCAyJyk7XG4gIH1cblxuICB2YWxbMF0gPSBfY2FzdEV4cHJlc3Npb24odmFsWzBdLCBzY2hlbWEsIHN0cmljdFF1ZXJ5KTtcbiAgY29uc3QgbGhzID0gdmFsWzBdO1xuXG4gIGlmIChpc0xpdGVyYWwodmFsWzFdKSkge1xuICAgIGxldCBwYXRoID0gbnVsbDtcbiAgICBsZXQgc2NoZW1hdHlwZSA9IG51bGw7XG4gICAgbGV0IGNhc3RlciA9IG51bGw7XG4gICAgaWYgKGlzUGF0aChsaHMpKSB7XG4gICAgICBwYXRoID0gbGhzLnNsaWNlKDEpO1xuICAgICAgc2NoZW1hdHlwZSA9IHNjaGVtYS5wYXRoKHBhdGgpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGxocyA9PT0gJ29iamVjdCcgJiYgbGhzICE9IG51bGwpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGxocykpIHtcbiAgICAgICAgaWYgKGRhdGVPcGVyYXRvcnMuaGFzKGtleSkgJiYgaXNQYXRoKGxoc1trZXldKSkge1xuICAgICAgICAgIHBhdGggPSBsaHNba2V5XS5zbGljZSgxKSArICcuJyArIGtleTtcbiAgICAgICAgICBjYXN0ZXIgPSBjYXN0TnVtYmVyO1xuICAgICAgICB9IGVsc2UgaWYgKGFycmF5RWxlbWVudE9wZXJhdG9ycy5oYXMoa2V5KSAmJiBpc1BhdGgobGhzW2tleV0pKSB7XG4gICAgICAgICAgcGF0aCA9IGxoc1trZXldLnNsaWNlKDEpICsgJy4nICsga2V5O1xuICAgICAgICAgIHNjaGVtYXR5cGUgPSBzY2hlbWEucGF0aChsaHNba2V5XS5zbGljZSgxKSk7XG4gICAgICAgICAgaWYgKHNjaGVtYXR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHNjaGVtYXR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB7XG4gICAgICAgICAgICAgIHNjaGVtYXR5cGUgPSBzY2hlbWF0eXBlLiRlbWJlZGRlZFNjaGVtYVR5cGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNjaGVtYXR5cGUuJGlzTW9uZ29vc2VBcnJheSkge1xuICAgICAgICAgICAgICBzY2hlbWF0eXBlID0gc2NoZW1hdHlwZS5jYXN0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaXMkbGl0ZXJhbCA9IHR5cGVvZiB2YWxbMV0gPT09ICdvYmplY3QnICYmIHZhbFsxXSAhPSBudWxsICYmIHZhbFsxXS4kbGl0ZXJhbCAhPSBudWxsO1xuICAgIGlmIChzY2hlbWF0eXBlICE9IG51bGwpIHtcbiAgICAgIGlmIChpcyRsaXRlcmFsKSB7XG4gICAgICAgIHZhbFsxXSA9IHsgJGxpdGVyYWw6IHNjaGVtYXR5cGUuY2FzdCh2YWxbMV0uJGxpdGVyYWwpIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWxbMV0gPSBzY2hlbWF0eXBlLmNhc3QodmFsWzFdKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNhc3RlciAhPSBudWxsKSB7XG4gICAgICBpZiAoaXMkbGl0ZXJhbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhbFsxXSA9IHsgJGxpdGVyYWw6IGNhc3Rlcih2YWxbMV0uJGxpdGVyYWwpIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHRocm93IG5ldyBDYXN0RXJyb3IoY2FzdGVyLm5hbWUucmVwbGFjZSgvXmNhc3QvLCAnJyksIHZhbFsxXSwgcGF0aCArICcuJGxpdGVyYWwnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YWxbMV0gPSBjYXN0ZXIodmFsWzFdKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IENhc3RFcnJvcihjYXN0ZXIubmFtZS5yZXBsYWNlKC9eY2FzdC8sICcnKSwgdmFsWzFdLCBwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGF0aCAhPSBudWxsICYmIHN0cmljdFF1ZXJ5ID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH0gZWxzZSBpZiAocGF0aCAhPSBudWxsICYmIHN0cmljdFF1ZXJ5ID09PSAndGhyb3cnKSB7XG4gICAgICB0aHJvdyBuZXcgU3RyaWN0TW9kZUVycm9yKHBhdGgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWxbMV0gPSBfY2FzdEV4cHJlc3Npb24odmFsWzFdKTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIGlzUGF0aCh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnICYmIHZhbFswXSA9PT0gJyQnO1xufVxuXG5mdW5jdGlvbiBpc0xpdGVyYWwodmFsKSB7XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJyAmJiB2YWxbMF0gPT09ICckJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHZhbCkuZmluZChrZXkgPT4ga2V5WzBdID09PSAnJCcpKSB7XG4gICAgLy8gVGhlIGAkbGl0ZXJhbGAgZXhwcmVzc2lvbiBjYW4gbWFrZSBhbiBvYmplY3QgYSBsaXRlcmFsXG4gICAgLy8gaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2FnZ3JlZ2F0aW9uL2xpdGVyYWwvI21vbmdvZGItZXhwcmVzc2lvbi1leHAuLWxpdGVyYWxcbiAgICByZXR1cm4gdmFsLiRsaXRlcmFsICE9IG51bGw7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/query/cast$expr.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/query/castFilterPath.js":
/*!****************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/query/castFilterPath.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst isOperator = __webpack_require__(/*! ./isOperator */ \"../backend/node_modules/mongoose/lib/helpers/query/isOperator.js\");\n\nmodule.exports = function castFilterPath(ctx, schematype, val) {\n  const any$conditionals = Object.keys(val).some(isOperator);\n\n  if (!any$conditionals) {\n    return schematype.castForQuery(\n      null,\n      val,\n      ctx\n    );\n  }\n\n  const ks = Object.keys(val);\n\n  let k = ks.length;\n\n  while (k--) {\n    const $cond = ks[k];\n    const nested = val[$cond];\n\n    if ($cond === '$not') {\n      if (nested && schematype && !schematype.caster) {\n        const _keys = Object.keys(nested);\n        if (_keys.length && isOperator(_keys[0])) {\n          for (const key of Object.keys(nested)) {\n            nested[key] = schematype.castForQuery(\n              key,\n              nested[key],\n              ctx\n            );\n          }\n        } else {\n          val[$cond] = schematype.castForQuery(\n            $cond,\n            nested,\n            ctx\n          );\n        }\n        continue;\n      }\n    } else {\n      val[$cond] = schematype.castForQuery(\n        $cond,\n        nested,\n        ctx\n      );\n    }\n  }\n\n  return val;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvY2FzdEZpbHRlclBhdGguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsbUJBQW1CLG1CQUFPLENBQUMsc0ZBQWM7O0FBRXpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvY2FzdEZpbHRlclBhdGguanM/ODE3YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGlzT3BlcmF0b3IgPSByZXF1aXJlKCcuL2lzT3BlcmF0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYXN0RmlsdGVyUGF0aChjdHgsIHNjaGVtYXR5cGUsIHZhbCkge1xuICBjb25zdCBhbnkkY29uZGl0aW9uYWxzID0gT2JqZWN0LmtleXModmFsKS5zb21lKGlzT3BlcmF0b3IpO1xuXG4gIGlmICghYW55JGNvbmRpdGlvbmFscykge1xuICAgIHJldHVybiBzY2hlbWF0eXBlLmNhc3RGb3JRdWVyeShcbiAgICAgIG51bGwsXG4gICAgICB2YWwsXG4gICAgICBjdHhcbiAgICApO1xuICB9XG5cbiAgY29uc3Qga3MgPSBPYmplY3Qua2V5cyh2YWwpO1xuXG4gIGxldCBrID0ga3MubGVuZ3RoO1xuXG4gIHdoaWxlIChrLS0pIHtcbiAgICBjb25zdCAkY29uZCA9IGtzW2tdO1xuICAgIGNvbnN0IG5lc3RlZCA9IHZhbFskY29uZF07XG5cbiAgICBpZiAoJGNvbmQgPT09ICckbm90Jykge1xuICAgICAgaWYgKG5lc3RlZCAmJiBzY2hlbWF0eXBlICYmICFzY2hlbWF0eXBlLmNhc3Rlcikge1xuICAgICAgICBjb25zdCBfa2V5cyA9IE9iamVjdC5rZXlzKG5lc3RlZCk7XG4gICAgICAgIGlmIChfa2V5cy5sZW5ndGggJiYgaXNPcGVyYXRvcihfa2V5c1swXSkpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhuZXN0ZWQpKSB7XG4gICAgICAgICAgICBuZXN0ZWRba2V5XSA9IHNjaGVtYXR5cGUuY2FzdEZvclF1ZXJ5KFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIG5lc3RlZFtrZXldLFxuICAgICAgICAgICAgICBjdHhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbFskY29uZF0gPSBzY2hlbWF0eXBlLmNhc3RGb3JRdWVyeShcbiAgICAgICAgICAgICRjb25kLFxuICAgICAgICAgICAgbmVzdGVkLFxuICAgICAgICAgICAgY3R4XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFsWyRjb25kXSA9IHNjaGVtYXR5cGUuY2FzdEZvclF1ZXJ5KFxuICAgICAgICAkY29uZCxcbiAgICAgICAgbmVzdGVkLFxuICAgICAgICBjdHhcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/query/castFilterPath.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/query/castUpdate.js":
/*!************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/query/castUpdate.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst CastError = __webpack_require__(/*! ../../error/cast */ \"../backend/node_modules/mongoose/lib/error/cast.js\");\nconst MongooseError = __webpack_require__(/*! ../../error/mongooseError */ \"../backend/node_modules/mongoose/lib/error/mongooseError.js\");\nconst StrictModeError = __webpack_require__(/*! ../../error/strict */ \"../backend/node_modules/mongoose/lib/error/strict.js\");\nconst ValidationError = __webpack_require__(/*! ../../error/validation */ \"../backend/node_modules/mongoose/lib/error/validation.js\");\nconst castNumber = __webpack_require__(/*! ../../cast/number */ \"../backend/node_modules/mongoose/lib/cast/number.js\");\nconst cast = __webpack_require__(/*! ../../cast */ \"../backend/node_modules/mongoose/lib/cast.js\");\nconst getConstructorName = __webpack_require__(/*! ../getConstructorName */ \"../backend/node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst getEmbeddedDiscriminatorPath = __webpack_require__(/*! ./getEmbeddedDiscriminatorPath */ \"../backend/node_modules/mongoose/lib/helpers/query/getEmbeddedDiscriminatorPath.js\");\nconst handleImmutable = __webpack_require__(/*! ./handleImmutable */ \"../backend/node_modules/mongoose/lib/helpers/query/handleImmutable.js\");\nconst moveImmutableProperties = __webpack_require__(/*! ../update/moveImmutableProperties */ \"../backend/node_modules/mongoose/lib/helpers/update/moveImmutableProperties.js\");\nconst schemaMixedSymbol = (__webpack_require__(/*! ../../schema/symbols */ \"../backend/node_modules/mongoose/lib/schema/symbols.js\").schemaMixedSymbol);\nconst setDottedPath = __webpack_require__(/*! ../path/setDottedPath */ \"../backend/node_modules/mongoose/lib/helpers/path/setDottedPath.js\");\nconst utils = __webpack_require__(/*! ../../utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\nconst { internalToObjectOptions } = __webpack_require__(/*! ../../options */ \"../backend/node_modules/mongoose/lib/options.js\");\n\nconst mongodbUpdateOperators = new Set([\n  '$currentDate',\n  '$inc',\n  '$min',\n  '$max',\n  '$mul',\n  '$rename',\n  '$set',\n  '$setOnInsert',\n  '$unset',\n  '$addToSet',\n  '$pop',\n  '$pull',\n  '$push',\n  '$pullAll',\n  '$bit'\n]);\n\n/**\n * Casts an update op based on the given schema\n *\n * @param {Schema} schema\n * @param {Object} obj\n * @param {Object} [options]\n * @param {Boolean|String} [options.strict] defaults to true\n * @param {Query} context passed to setters\n * @return {Boolean} true iff the update is non-empty\n * @api private\n */\nmodule.exports = function castUpdate(schema, obj, options, context, filter) {\n  if (obj == null) {\n    return undefined;\n  }\n  options = options || {};\n  // Update pipeline\n  if (Array.isArray(obj)) {\n    const len = obj.length;\n    for (let i = 0; i < len; ++i) {\n      const ops = Object.keys(obj[i]);\n      for (const op of ops) {\n        obj[i][op] = castPipelineOperator(op, obj[i][op]);\n      }\n    }\n    return obj;\n  }\n\n  if (options.upsert) {\n    moveImmutableProperties(schema, obj, context);\n  }\n\n  const ops = Object.keys(obj);\n  let i = ops.length;\n  const ret = {};\n  let val;\n  let hasDollarKey = false;\n\n  filter = filter || {};\n  while (i--) {\n    const op = ops[i];\n    if (!mongodbUpdateOperators.has(op)) {\n      // fix up $set sugar\n      if (!ret.$set) {\n        if (obj.$set) {\n          ret.$set = obj.$set;\n        } else {\n          ret.$set = {};\n        }\n      }\n      ret.$set[op] = obj[op];\n      ops.splice(i, 1);\n      if (!~ops.indexOf('$set')) ops.push('$set');\n    } else if (op === '$set') {\n      if (!ret.$set) {\n        ret[op] = obj[op];\n      }\n    } else {\n      ret[op] = obj[op];\n    }\n  }\n  // cast each value\n  i = ops.length;\n  while (i--) {\n    const op = ops[i];\n    val = ret[op];\n    hasDollarKey = hasDollarKey || op.startsWith('$');\n    if (val != null && val.$__) {\n      val = val.toObject(internalToObjectOptions);\n      ret[op] = val;\n    }\n    if (val &&\n        typeof val === 'object' &&\n        !Buffer.isBuffer(val) &&\n        mongodbUpdateOperators.has(op)) {\n      walkUpdatePath(schema, val, op, options, context, filter);\n    } else {\n      const msg = 'Invalid atomic update value for ' + op + '. '\n          + 'Expected an object, received ' + typeof val;\n      throw new Error(msg);\n    }\n\n    if (op.startsWith('$') && utils.isEmptyObject(val)) {\n      delete ret[op];\n    }\n  }\n\n  if (Object.keys(ret).length === 0 &&\n      options.upsert &&\n      Object.keys(filter).length > 0) {\n    // Trick the driver into allowing empty upserts to work around\n    // https://github.com/mongodb/node-mongodb-native/pull/2490\n    // Shallow clone to avoid passing defaults in re: gh-13962\n    return { $setOnInsert: { ...filter } };\n  }\n  return ret;\n};\n\n/*!\n * ignore\n */\n\nfunction castPipelineOperator(op, val) {\n  if (op === '$unset') {\n    if (typeof val !== 'string' && (!Array.isArray(val) || val.find(v => typeof v !== 'string'))) {\n      throw new MongooseError('Invalid $unset in pipeline, must be ' +\n        ' a string or an array of strings');\n    }\n    return val;\n  }\n  if (op === '$project') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid $project in pipeline, must be an object');\n    }\n    return val;\n  }\n  if (op === '$addFields' || op === '$set') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid ' + op + ' in pipeline, must be an object');\n    }\n    return val;\n  } else if (op === '$replaceRoot' || op === '$replaceWith') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid ' + op + ' in pipeline, must be an object');\n    }\n    return val;\n  }\n\n  throw new MongooseError('Invalid update pipeline operator: \"' + op + '\"');\n}\n\n/**\n * Walk each path of obj and cast its values\n * according to its schema.\n *\n * @param {Schema} schema\n * @param {Object} obj part of a query\n * @param {String} op the atomic operator ($pull, $set, etc)\n * @param {Object} [options]\n * @param {Boolean|String} [options.strict]\n * @param {Query} context\n * @param {Object} filter\n * @param {String} pref path prefix (internal only)\n * @return {Bool} true if this path has keys to update\n * @api private\n */\n\nfunction walkUpdatePath(schema, obj, op, options, context, filter, pref) {\n  const strict = options.strict;\n  const prefix = pref ? pref + '.' : '';\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let hasKeys = false;\n  let schematype;\n  let key;\n  let val;\n\n  let aggregatedError = null;\n\n  const strictMode = strict != null ? strict : schema.options.strict;\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    // `$pull` is special because we need to cast the RHS as a query, not as\n    // an update.\n    if (op === '$pull') {\n      schematype = schema._getSchema(prefix + key);\n      if (schematype != null && schematype.schema != null) {\n        obj[key] = cast(schematype.schema, obj[key], options, context);\n        hasKeys = true;\n        continue;\n      }\n    }\n\n    const discriminatorKey = (prefix ? prefix + key : key);\n    if (\n      schema.discriminatorMapping != null &&\n      discriminatorKey === schema.options.discriminatorKey &&\n      schema.discriminatorMapping.value !== obj[key] &&\n      !options.overwriteDiscriminatorKey\n    ) {\n      if (strictMode === 'throw') {\n        const err = new Error('Can\\'t modify discriminator key \"' + discriminatorKey + '\" on discriminator model');\n        aggregatedError = _appendError(err, context, discriminatorKey, aggregatedError);\n        continue;\n      } else if (strictMode) {\n        delete obj[key];\n        continue;\n      }\n    }\n\n    if (getConstructorName(val) === 'Object') {\n      // watch for embedded doc schemas\n      schematype = schema._getSchema(prefix + key);\n\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, prefix + key, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n        }\n      }\n\n      if (op !== '$setOnInsert' &&\n          handleImmutable(schematype, strict, obj, key, prefix + key, context)) {\n        continue;\n      }\n\n      if (schematype && schematype.caster && op in castOps) {\n        // embedded doc schema\n        if ('$each' in val) {\n          hasKeys = true;\n          try {\n            obj[key] = {\n              $each: castUpdateVal(schematype, val.$each, op, key, context, prefix + key)\n            };\n          } catch (error) {\n            aggregatedError = _appendError(error, context, key, aggregatedError);\n          }\n\n          if (val.$slice != null) {\n            obj[key].$slice = val.$slice | 0;\n          }\n\n          if (val.$sort) {\n            obj[key].$sort = val.$sort;\n          }\n\n          if (val.$position != null) {\n            obj[key].$position = castNumber(val.$position);\n          }\n        } else {\n          if (schematype != null && schematype.$isSingleNested) {\n            const _strict = strict == null ? schematype.schema.options.strict : strict;\n            try {\n              obj[key] = schematype.castForQuery(null, val, context, { strict: _strict });\n            } catch (error) {\n              aggregatedError = _appendError(error, context, key, aggregatedError);\n            }\n          } else {\n            try {\n              obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n            } catch (error) {\n              aggregatedError = _appendError(error, context, key, aggregatedError);\n            }\n          }\n\n          if (obj[key] === void 0) {\n            delete obj[key];\n            continue;\n          }\n\n          hasKeys = true;\n        }\n      } else if ((op === '$currentDate') || (op in castOps && schematype)) {\n        // $currentDate can take an object\n        try {\n          obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n        } catch (error) {\n          aggregatedError = _appendError(error, context, key, aggregatedError);\n        }\n\n        if (obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n\n        hasKeys = true;\n      } else {\n        const pathToCheck = (prefix + key);\n        const v = schema._getPathType(pathToCheck);\n        let _strict = strict;\n        if (v && v.schema && _strict == null) {\n          _strict = v.schema.options.strict;\n        }\n\n        if (v.pathType === 'undefined') {\n          if (_strict === 'throw') {\n            throw new StrictModeError(pathToCheck);\n          } else if (_strict) {\n            delete obj[key];\n            continue;\n          }\n        }\n\n        // gh-2314\n        // we should be able to set a schema-less field\n        // to an empty object literal\n        hasKeys |= walkUpdatePath(schema, val, op, options, context, filter, prefix + key) ||\n          (utils.isObject(val) && Object.keys(val).length === 0);\n      }\n    } else {\n      const checkPath = (key === '$each' || key === '$or' || key === '$and' || key === '$in') ?\n        pref : prefix + key;\n      schematype = schema._getSchema(checkPath);\n\n      // You can use `$setOnInsert` with immutable keys\n      if (op !== '$setOnInsert' &&\n          handleImmutable(schematype, strict, obj, key, prefix + key, context)) {\n        continue;\n      }\n\n      let pathDetails = schema._getPathType(checkPath);\n\n      // If no schema type, check for embedded discriminators because the\n      // filter or update may imply an embedded discriminator type. See #8378\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, checkPath, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n          pathDetails = _res.type;\n        }\n      }\n\n      let isStrict = strict;\n      if (pathDetails && pathDetails.schema && strict == null) {\n        isStrict = pathDetails.schema.options.strict;\n      }\n\n      const skip = isStrict &&\n        !schematype &&\n        !/real|nested/.test(pathDetails.pathType);\n\n      if (skip) {\n        // Even if strict is `throw`, avoid throwing an error because of\n        // virtuals because of #6731\n        if (isStrict === 'throw' && schema.virtuals[checkPath] == null) {\n          throw new StrictModeError(prefix + key);\n        } else {\n          delete obj[key];\n        }\n      } else {\n        // gh-1845 temporary fix: ignore $rename. See gh-3027 for tracking\n        // improving this.\n        if (op === '$rename') {\n          hasKeys = true;\n          continue;\n        }\n\n        try {\n          if (prefix.length === 0 || key.indexOf('.') === -1) {\n            obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n          } else if (isStrict !== false || schematype != null) {\n            // Setting a nested dotted path that's in the schema. We don't allow paths with '.' in\n            // a schema, so replace the dotted path with a nested object to avoid ending up with\n            // dotted properties in the updated object. See (gh-10200)\n            setDottedPath(obj, key, castUpdateVal(schematype, val, op, key, context, prefix + key));\n            delete obj[key];\n          }\n        } catch (error) {\n          aggregatedError = _appendError(error, context, key, aggregatedError);\n        }\n\n        if (Array.isArray(obj[key]) && (op === '$addToSet' || op === '$push') && key !== '$each') {\n          if (schematype &&\n              schematype.caster &&\n              !schematype.caster.$isMongooseArray &&\n              !schematype.caster[schemaMixedSymbol]) {\n            obj[key] = { $each: obj[key] };\n          }\n        }\n\n        if (obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n\n        hasKeys = true;\n      }\n    }\n  }\n\n  if (aggregatedError != null) {\n    throw aggregatedError;\n  }\n\n  return hasKeys;\n}\n\n/*!\n * ignore\n */\n\nfunction _appendError(error, query, key, aggregatedError) {\n  if (typeof query !== 'object' || !query.options.multipleCastError) {\n    throw error;\n  }\n  aggregatedError = aggregatedError || new ValidationError();\n  aggregatedError.addError(key, error);\n  return aggregatedError;\n}\n\n/**\n * These operators should be cast to numbers instead\n * of their path schema type.\n * @api private\n */\n\nconst numberOps = {\n  $pop: 1,\n  $inc: 1\n};\n\n/**\n * These ops require no casting because the RHS doesn't do anything.\n * @api private\n */\n\nconst noCastOps = {\n  $unset: 1\n};\n\n/**\n * These operators require casting docs\n * to real Documents for Update operations.\n * @api private\n */\n\nconst castOps = {\n  $push: 1,\n  $addToSet: 1,\n  $set: 1,\n  $setOnInsert: 1\n};\n\n/*!\n * ignore\n */\n\nconst overwriteOps = {\n  $set: 1,\n  $setOnInsert: 1\n};\n\n/**\n * Casts `val` according to `schema` and atomic `op`.\n *\n * @param {SchemaType} schema\n * @param {Object} val\n * @param {String} op the atomic operator ($pull, $set, etc)\n * @param {String} $conditional\n * @param {Query} context\n * @param {String} path\n * @api private\n */\n\nfunction castUpdateVal(schema, val, op, $conditional, context, path) {\n  if (!schema) {\n    // non-existing schema path\n    if (op in numberOps) {\n      try {\n        return castNumber(val);\n      } catch (err) {\n        throw new CastError('number', val, path);\n      }\n    }\n    return val;\n  }\n\n  // console.log('CastUpdateVal', path, op, val, schema);\n\n  const cond = schema.caster && op in castOps &&\n      (utils.isObject(val) || Array.isArray(val));\n  if (cond && !overwriteOps[op]) {\n    // Cast values for ops that add data to MongoDB.\n    // Ensures embedded documents get ObjectIds etc.\n    let schemaArrayDepth = 0;\n    let cur = schema;\n    while (cur.$isMongooseArray) {\n      ++schemaArrayDepth;\n      cur = cur.caster;\n    }\n    let arrayDepth = 0;\n    let _val = val;\n    while (Array.isArray(_val)) {\n      ++arrayDepth;\n      _val = _val[0];\n    }\n\n    const additionalNesting = schemaArrayDepth - arrayDepth;\n    while (arrayDepth < schemaArrayDepth) {\n      val = [val];\n      ++arrayDepth;\n    }\n\n    let tmp = schema.applySetters(Array.isArray(val) ? val : [val], context);\n\n    for (let i = 0; i < additionalNesting; ++i) {\n      tmp = tmp[0];\n    }\n    return tmp;\n  }\n\n  if (op in noCastOps) {\n    return val;\n  }\n  if (op in numberOps) {\n    // Null and undefined not allowed for $pop, $inc\n    if (val == null) {\n      throw new CastError('number', val, schema.path);\n    }\n    if (op === '$inc') {\n      // Support `$inc` with long, int32, etc. (gh-4283)\n      return schema.castForQuery(\n        null,\n        val,\n        context\n      );\n    }\n    try {\n      return castNumber(val);\n    } catch (error) {\n      throw new CastError('number', val, schema.path);\n    }\n  }\n  if (op === '$currentDate') {\n    if (typeof val === 'object') {\n      return { $type: val.$type };\n    }\n    return Boolean(val);\n  }\n\n  if (mongodbUpdateOperators.has($conditional)) {\n    return schema.castForQuery(\n      $conditional,\n      val,\n      context\n    );\n  }\n\n  if (overwriteOps[op]) {\n    const skipQueryCastForUpdate = val != null && schema.$isMongooseArray && schema.$fullPath != null && !schema.$fullPath.match(/\\d+$/);\n    const applySetters = schema[schemaMixedSymbol] != null;\n    if (skipQueryCastForUpdate || applySetters) {\n      return schema.applySetters(val, context);\n    }\n    return schema.castForQuery(\n      null,\n      val,\n      context\n    );\n  }\n\n  return schema.castForQuery(null, val, context);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvY2FzdFVwZGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixrQkFBa0IsbUJBQU8sQ0FBQyw0RUFBa0I7QUFDNUMsc0JBQXNCLG1CQUFPLENBQUMsOEZBQTJCO0FBQ3pELHdCQUF3QixtQkFBTyxDQUFDLGdGQUFvQjtBQUNwRCx3QkFBd0IsbUJBQU8sQ0FBQyx3RkFBd0I7QUFDeEQsbUJBQW1CLG1CQUFPLENBQUMsOEVBQW1CO0FBQzlDLGFBQWEsbUJBQU8sQ0FBQyxnRUFBWTtBQUNqQywyQkFBMkIsbUJBQU8sQ0FBQyxpR0FBdUI7QUFDMUQscUNBQXFDLG1CQUFPLENBQUMsMEhBQWdDO0FBQzdFLHdCQUF3QixtQkFBTyxDQUFDLGdHQUFtQjtBQUNuRCxnQ0FBZ0MsbUJBQU8sQ0FBQyx5SEFBbUM7QUFDM0UsMEJBQTBCLDZIQUFpRDtBQUMzRSxzQkFBc0IsbUJBQU8sQ0FBQyxpR0FBdUI7QUFDckQsY0FBYyxtQkFBTyxDQUFDLGtFQUFhO0FBQ25DLFFBQVEsMEJBQTBCLEVBQUUsbUJBQU8sQ0FBQyxzRUFBZTs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGdCQUFnQjtBQUMzQixXQUFXLE9BQU87QUFDbEIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGdCQUFnQjtBQUMzQixXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLE1BQU07QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLGlCQUFpQjtBQUN4RixjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3F1ZXJ5L2Nhc3RVcGRhdGUuanM/M2E4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IENhc3RFcnJvciA9IHJlcXVpcmUoJy4uLy4uL2Vycm9yL2Nhc3QnKTtcbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9lcnJvci9tb25nb29zZUVycm9yJyk7XG5jb25zdCBTdHJpY3RNb2RlRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9lcnJvci9zdHJpY3QnKTtcbmNvbnN0IFZhbGlkYXRpb25FcnJvciA9IHJlcXVpcmUoJy4uLy4uL2Vycm9yL3ZhbGlkYXRpb24nKTtcbmNvbnN0IGNhc3ROdW1iZXIgPSByZXF1aXJlKCcuLi8uLi9jYXN0L251bWJlcicpO1xuY29uc3QgY2FzdCA9IHJlcXVpcmUoJy4uLy4uL2Nhc3QnKTtcbmNvbnN0IGdldENvbnN0cnVjdG9yTmFtZSA9IHJlcXVpcmUoJy4uL2dldENvbnN0cnVjdG9yTmFtZScpO1xuY29uc3QgZ2V0RW1iZWRkZWREaXNjcmltaW5hdG9yUGF0aCA9IHJlcXVpcmUoJy4vZ2V0RW1iZWRkZWREaXNjcmltaW5hdG9yUGF0aCcpO1xuY29uc3QgaGFuZGxlSW1tdXRhYmxlID0gcmVxdWlyZSgnLi9oYW5kbGVJbW11dGFibGUnKTtcbmNvbnN0IG1vdmVJbW11dGFibGVQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vdXBkYXRlL21vdmVJbW11dGFibGVQcm9wZXJ0aWVzJyk7XG5jb25zdCBzY2hlbWFNaXhlZFN5bWJvbCA9IHJlcXVpcmUoJy4uLy4uL3NjaGVtYS9zeW1ib2xzJykuc2NoZW1hTWl4ZWRTeW1ib2w7XG5jb25zdCBzZXREb3R0ZWRQYXRoID0gcmVxdWlyZSgnLi4vcGF0aC9zZXREb3R0ZWRQYXRoJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzJyk7XG5jb25zdCB7IGludGVybmFsVG9PYmplY3RPcHRpb25zIH0gPSByZXF1aXJlKCcuLi8uLi9vcHRpb25zJyk7XG5cbmNvbnN0IG1vbmdvZGJVcGRhdGVPcGVyYXRvcnMgPSBuZXcgU2V0KFtcbiAgJyRjdXJyZW50RGF0ZScsXG4gICckaW5jJyxcbiAgJyRtaW4nLFxuICAnJG1heCcsXG4gICckbXVsJyxcbiAgJyRyZW5hbWUnLFxuICAnJHNldCcsXG4gICckc2V0T25JbnNlcnQnLFxuICAnJHVuc2V0JyxcbiAgJyRhZGRUb1NldCcsXG4gICckcG9wJyxcbiAgJyRwdWxsJyxcbiAgJyRwdXNoJyxcbiAgJyRwdWxsQWxsJyxcbiAgJyRiaXQnXG5dKTtcblxuLyoqXG4gKiBDYXN0cyBhbiB1cGRhdGUgb3AgYmFzZWQgb24gdGhlIGdpdmVuIHNjaGVtYVxuICpcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Qm9vbGVhbnxTdHJpbmd9IFtvcHRpb25zLnN0cmljdF0gZGVmYXVsdHMgdG8gdHJ1ZVxuICogQHBhcmFtIHtRdWVyeX0gY29udGV4dCBwYXNzZWQgdG8gc2V0dGVyc1xuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZmYgdGhlIHVwZGF0ZSBpcyBub24tZW1wdHlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhc3RVcGRhdGUoc2NoZW1hLCBvYmosIG9wdGlvbnMsIGNvbnRleHQsIGZpbHRlcikge1xuICBpZiAob2JqID09IG51bGwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAvLyBVcGRhdGUgcGlwZWxpbmVcbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIGNvbnN0IGxlbiA9IG9iai5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgY29uc3Qgb3BzID0gT2JqZWN0LmtleXMob2JqW2ldKTtcbiAgICAgIGZvciAoY29uc3Qgb3Agb2Ygb3BzKSB7XG4gICAgICAgIG9ialtpXVtvcF0gPSBjYXN0UGlwZWxpbmVPcGVyYXRvcihvcCwgb2JqW2ldW29wXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBpZiAob3B0aW9ucy51cHNlcnQpIHtcbiAgICBtb3ZlSW1tdXRhYmxlUHJvcGVydGllcyhzY2hlbWEsIG9iaiwgY29udGV4dCk7XG4gIH1cblxuICBjb25zdCBvcHMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBsZXQgaSA9IG9wcy5sZW5ndGg7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBsZXQgdmFsO1xuICBsZXQgaGFzRG9sbGFyS2V5ID0gZmFsc2U7XG5cbiAgZmlsdGVyID0gZmlsdGVyIHx8IHt9O1xuICB3aGlsZSAoaS0tKSB7XG4gICAgY29uc3Qgb3AgPSBvcHNbaV07XG4gICAgaWYgKCFtb25nb2RiVXBkYXRlT3BlcmF0b3JzLmhhcyhvcCkpIHtcbiAgICAgIC8vIGZpeCB1cCAkc2V0IHN1Z2FyXG4gICAgICBpZiAoIXJldC4kc2V0KSB7XG4gICAgICAgIGlmIChvYmouJHNldCkge1xuICAgICAgICAgIHJldC4kc2V0ID0gb2JqLiRzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0LiRzZXQgPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0LiRzZXRbb3BdID0gb2JqW29wXTtcbiAgICAgIG9wcy5zcGxpY2UoaSwgMSk7XG4gICAgICBpZiAoIX5vcHMuaW5kZXhPZignJHNldCcpKSBvcHMucHVzaCgnJHNldCcpO1xuICAgIH0gZWxzZSBpZiAob3AgPT09ICckc2V0Jykge1xuICAgICAgaWYgKCFyZXQuJHNldCkge1xuICAgICAgICByZXRbb3BdID0gb2JqW29wXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0W29wXSA9IG9ialtvcF07XG4gICAgfVxuICB9XG4gIC8vIGNhc3QgZWFjaCB2YWx1ZVxuICBpID0gb3BzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGNvbnN0IG9wID0gb3BzW2ldO1xuICAgIHZhbCA9IHJldFtvcF07XG4gICAgaGFzRG9sbGFyS2V5ID0gaGFzRG9sbGFyS2V5IHx8IG9wLnN0YXJ0c1dpdGgoJyQnKTtcbiAgICBpZiAodmFsICE9IG51bGwgJiYgdmFsLiRfXykge1xuICAgICAgdmFsID0gdmFsLnRvT2JqZWN0KGludGVybmFsVG9PYmplY3RPcHRpb25zKTtcbiAgICAgIHJldFtvcF0gPSB2YWw7XG4gICAgfVxuICAgIGlmICh2YWwgJiZcbiAgICAgICAgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgIUJ1ZmZlci5pc0J1ZmZlcih2YWwpICYmXG4gICAgICAgIG1vbmdvZGJVcGRhdGVPcGVyYXRvcnMuaGFzKG9wKSkge1xuICAgICAgd2Fsa1VwZGF0ZVBhdGgoc2NoZW1hLCB2YWwsIG9wLCBvcHRpb25zLCBjb250ZXh0LCBmaWx0ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtc2cgPSAnSW52YWxpZCBhdG9taWMgdXBkYXRlIHZhbHVlIGZvciAnICsgb3AgKyAnLiAnXG4gICAgICAgICAgKyAnRXhwZWN0ZWQgYW4gb2JqZWN0LCByZWNlaXZlZCAnICsgdHlwZW9mIHZhbDtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cblxuICAgIGlmIChvcC5zdGFydHNXaXRoKCckJykgJiYgdXRpbHMuaXNFbXB0eU9iamVjdCh2YWwpKSB7XG4gICAgICBkZWxldGUgcmV0W29wXTtcbiAgICB9XG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXMocmV0KS5sZW5ndGggPT09IDAgJiZcbiAgICAgIG9wdGlvbnMudXBzZXJ0ICYmXG4gICAgICBPYmplY3Qua2V5cyhmaWx0ZXIpLmxlbmd0aCA+IDApIHtcbiAgICAvLyBUcmljayB0aGUgZHJpdmVyIGludG8gYWxsb3dpbmcgZW1wdHkgdXBzZXJ0cyB0byB3b3JrIGFyb3VuZFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb25nb2RiL25vZGUtbW9uZ29kYi1uYXRpdmUvcHVsbC8yNDkwXG4gICAgLy8gU2hhbGxvdyBjbG9uZSB0byBhdm9pZCBwYXNzaW5nIGRlZmF1bHRzIGluIHJlOiBnaC0xMzk2MlxuICAgIHJldHVybiB7ICRzZXRPbkluc2VydDogeyAuLi5maWx0ZXIgfSB9O1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGNhc3RQaXBlbGluZU9wZXJhdG9yKG9wLCB2YWwpIHtcbiAgaWYgKG9wID09PSAnJHVuc2V0Jykge1xuICAgIGlmICh0eXBlb2YgdmFsICE9PSAnc3RyaW5nJyAmJiAoIUFycmF5LmlzQXJyYXkodmFsKSB8fCB2YWwuZmluZCh2ID0+IHR5cGVvZiB2ICE9PSAnc3RyaW5nJykpKSB7XG4gICAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignSW52YWxpZCAkdW5zZXQgaW4gcGlwZWxpbmUsIG11c3QgYmUgJyArXG4gICAgICAgICcgYSBzdHJpbmcgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIGlmIChvcCA9PT0gJyRwcm9qZWN0Jykge1xuICAgIGlmICh2YWwgPT0gbnVsbCB8fCB0eXBlb2YgdmFsICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0ludmFsaWQgJHByb2plY3QgaW4gcGlwZWxpbmUsIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgaWYgKG9wID09PSAnJGFkZEZpZWxkcycgfHwgb3AgPT09ICckc2V0Jykge1xuICAgIGlmICh2YWwgPT0gbnVsbCB8fCB0eXBlb2YgdmFsICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0ludmFsaWQgJyArIG9wICsgJyBpbiBwaXBlbGluZSwgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfSBlbHNlIGlmIChvcCA9PT0gJyRyZXBsYWNlUm9vdCcgfHwgb3AgPT09ICckcmVwbGFjZVdpdGgnKSB7XG4gICAgaWYgKHZhbCA9PSBudWxsIHx8IHR5cGVvZiB2YWwgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignSW52YWxpZCAnICsgb3AgKyAnIGluIHBpcGVsaW5lLCBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0ludmFsaWQgdXBkYXRlIHBpcGVsaW5lIG9wZXJhdG9yOiBcIicgKyBvcCArICdcIicpO1xufVxuXG4vKipcbiAqIFdhbGsgZWFjaCBwYXRoIG9mIG9iaiBhbmQgY2FzdCBpdHMgdmFsdWVzXG4gKiBhY2NvcmRpbmcgdG8gaXRzIHNjaGVtYS5cbiAqXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIHBhcnQgb2YgYSBxdWVyeVxuICogQHBhcmFtIHtTdHJpbmd9IG9wIHRoZSBhdG9taWMgb3BlcmF0b3IgKCRwdWxsLCAkc2V0LCBldGMpXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBbb3B0aW9ucy5zdHJpY3RdXG4gKiBAcGFyYW0ge1F1ZXJ5fSBjb250ZXh0XG4gKiBAcGFyYW0ge09iamVjdH0gZmlsdGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZiBwYXRoIHByZWZpeCAoaW50ZXJuYWwgb25seSlcbiAqIEByZXR1cm4ge0Jvb2x9IHRydWUgaWYgdGhpcyBwYXRoIGhhcyBrZXlzIHRvIHVwZGF0ZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gd2Fsa1VwZGF0ZVBhdGgoc2NoZW1hLCBvYmosIG9wLCBvcHRpb25zLCBjb250ZXh0LCBmaWx0ZXIsIHByZWYpIHtcbiAgY29uc3Qgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7XG4gIGNvbnN0IHByZWZpeCA9IHByZWYgPyBwcmVmICsgJy4nIDogJyc7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBsZXQgaSA9IGtleXMubGVuZ3RoO1xuICBsZXQgaGFzS2V5cyA9IGZhbHNlO1xuICBsZXQgc2NoZW1hdHlwZTtcbiAgbGV0IGtleTtcbiAgbGV0IHZhbDtcblxuICBsZXQgYWdncmVnYXRlZEVycm9yID0gbnVsbDtcblxuICBjb25zdCBzdHJpY3RNb2RlID0gc3RyaWN0ICE9IG51bGwgPyBzdHJpY3QgOiBzY2hlbWEub3B0aW9ucy5zdHJpY3Q7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgdmFsID0gb2JqW2tleV07XG5cbiAgICAvLyBgJHB1bGxgIGlzIHNwZWNpYWwgYmVjYXVzZSB3ZSBuZWVkIHRvIGNhc3QgdGhlIFJIUyBhcyBhIHF1ZXJ5LCBub3QgYXNcbiAgICAvLyBhbiB1cGRhdGUuXG4gICAgaWYgKG9wID09PSAnJHB1bGwnKSB7XG4gICAgICBzY2hlbWF0eXBlID0gc2NoZW1hLl9nZXRTY2hlbWEocHJlZml4ICsga2V5KTtcbiAgICAgIGlmIChzY2hlbWF0eXBlICE9IG51bGwgJiYgc2NoZW1hdHlwZS5zY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBvYmpba2V5XSA9IGNhc3Qoc2NoZW1hdHlwZS5zY2hlbWEsIG9ialtrZXldLCBvcHRpb25zLCBjb250ZXh0KTtcbiAgICAgICAgaGFzS2V5cyA9IHRydWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JLZXkgPSAocHJlZml4ID8gcHJlZml4ICsga2V5IDoga2V5KTtcbiAgICBpZiAoXG4gICAgICBzY2hlbWEuZGlzY3JpbWluYXRvck1hcHBpbmcgIT0gbnVsbCAmJlxuICAgICAgZGlzY3JpbWluYXRvcktleSA9PT0gc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleSAmJlxuICAgICAgc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nLnZhbHVlICE9PSBvYmpba2V5XSAmJlxuICAgICAgIW9wdGlvbnMub3ZlcndyaXRlRGlzY3JpbWluYXRvcktleVxuICAgICkge1xuICAgICAgaWYgKHN0cmljdE1vZGUgPT09ICd0aHJvdycpIHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdDYW5cXCd0IG1vZGlmeSBkaXNjcmltaW5hdG9yIGtleSBcIicgKyBkaXNjcmltaW5hdG9yS2V5ICsgJ1wiIG9uIGRpc2NyaW1pbmF0b3IgbW9kZWwnKTtcbiAgICAgICAgYWdncmVnYXRlZEVycm9yID0gX2FwcGVuZEVycm9yKGVyciwgY29udGV4dCwgZGlzY3JpbWluYXRvcktleSwgYWdncmVnYXRlZEVycm9yKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKHN0cmljdE1vZGUpIHtcbiAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZ2V0Q29uc3RydWN0b3JOYW1lKHZhbCkgPT09ICdPYmplY3QnKSB7XG4gICAgICAvLyB3YXRjaCBmb3IgZW1iZWRkZWQgZG9jIHNjaGVtYXNcbiAgICAgIHNjaGVtYXR5cGUgPSBzY2hlbWEuX2dldFNjaGVtYShwcmVmaXggKyBrZXkpO1xuXG4gICAgICBpZiAoc2NoZW1hdHlwZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IF9yZXMgPSBnZXRFbWJlZGRlZERpc2NyaW1pbmF0b3JQYXRoKHNjaGVtYSwgb2JqLCBmaWx0ZXIsIHByZWZpeCArIGtleSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChfcmVzLnNjaGVtYXR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgIHNjaGVtYXR5cGUgPSBfcmVzLnNjaGVtYXR5cGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wICE9PSAnJHNldE9uSW5zZXJ0JyAmJlxuICAgICAgICAgIGhhbmRsZUltbXV0YWJsZShzY2hlbWF0eXBlLCBzdHJpY3QsIG9iaiwga2V5LCBwcmVmaXggKyBrZXksIGNvbnRleHQpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2NoZW1hdHlwZSAmJiBzY2hlbWF0eXBlLmNhc3RlciAmJiBvcCBpbiBjYXN0T3BzKSB7XG4gICAgICAgIC8vIGVtYmVkZGVkIGRvYyBzY2hlbWFcbiAgICAgICAgaWYgKCckZWFjaCcgaW4gdmFsKSB7XG4gICAgICAgICAgaGFzS2V5cyA9IHRydWU7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9ialtrZXldID0ge1xuICAgICAgICAgICAgICAkZWFjaDogY2FzdFVwZGF0ZVZhbChzY2hlbWF0eXBlLCB2YWwuJGVhY2gsIG9wLCBrZXksIGNvbnRleHQsIHByZWZpeCArIGtleSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGFnZ3JlZ2F0ZWRFcnJvciA9IF9hcHBlbmRFcnJvcihlcnJvciwgY29udGV4dCwga2V5LCBhZ2dyZWdhdGVkRXJyb3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWwuJHNsaWNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIG9ialtrZXldLiRzbGljZSA9IHZhbC4kc2xpY2UgfCAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWwuJHNvcnQpIHtcbiAgICAgICAgICAgIG9ialtrZXldLiRzb3J0ID0gdmFsLiRzb3J0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWwuJHBvc2l0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgIG9ialtrZXldLiRwb3NpdGlvbiA9IGNhc3ROdW1iZXIodmFsLiRwb3NpdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzY2hlbWF0eXBlICE9IG51bGwgJiYgc2NoZW1hdHlwZS4kaXNTaW5nbGVOZXN0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IF9zdHJpY3QgPSBzdHJpY3QgPT0gbnVsbCA/IHNjaGVtYXR5cGUuc2NoZW1hLm9wdGlvbnMuc3RyaWN0IDogc3RyaWN0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgb2JqW2tleV0gPSBzY2hlbWF0eXBlLmNhc3RGb3JRdWVyeShudWxsLCB2YWwsIGNvbnRleHQsIHsgc3RyaWN0OiBfc3RyaWN0IH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgYWdncmVnYXRlZEVycm9yID0gX2FwcGVuZEVycm9yKGVycm9yLCBjb250ZXh0LCBrZXksIGFnZ3JlZ2F0ZWRFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIG9ialtrZXldID0gY2FzdFVwZGF0ZVZhbChzY2hlbWF0eXBlLCB2YWwsIG9wLCBrZXksIGNvbnRleHQsIHByZWZpeCArIGtleSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBhZ2dyZWdhdGVkRXJyb3IgPSBfYXBwZW5kRXJyb3IoZXJyb3IsIGNvbnRleHQsIGtleSwgYWdncmVnYXRlZEVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob2JqW2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaGFzS2V5cyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKG9wID09PSAnJGN1cnJlbnREYXRlJykgfHwgKG9wIGluIGNhc3RPcHMgJiYgc2NoZW1hdHlwZSkpIHtcbiAgICAgICAgLy8gJGN1cnJlbnREYXRlIGNhbiB0YWtlIGFuIG9iamVjdFxuICAgICAgICB0cnkge1xuICAgICAgICAgIG9ialtrZXldID0gY2FzdFVwZGF0ZVZhbChzY2hlbWF0eXBlLCB2YWwsIG9wLCBrZXksIGNvbnRleHQsIHByZWZpeCArIGtleSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgYWdncmVnYXRlZEVycm9yID0gX2FwcGVuZEVycm9yKGVycm9yLCBjb250ZXh0LCBrZXksIGFnZ3JlZ2F0ZWRFcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2JqW2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhc0tleXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcGF0aFRvQ2hlY2sgPSAocHJlZml4ICsga2V5KTtcbiAgICAgICAgY29uc3QgdiA9IHNjaGVtYS5fZ2V0UGF0aFR5cGUocGF0aFRvQ2hlY2spO1xuICAgICAgICBsZXQgX3N0cmljdCA9IHN0cmljdDtcbiAgICAgICAgaWYgKHYgJiYgdi5zY2hlbWEgJiYgX3N0cmljdCA9PSBudWxsKSB7XG4gICAgICAgICAgX3N0cmljdCA9IHYuc2NoZW1hLm9wdGlvbnMuc3RyaWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHYucGF0aFR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgaWYgKF9zdHJpY3QgPT09ICd0aHJvdycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTdHJpY3RNb2RlRXJyb3IocGF0aFRvQ2hlY2spO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX3N0cmljdCkge1xuICAgICAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2gtMjMxNFxuICAgICAgICAvLyB3ZSBzaG91bGQgYmUgYWJsZSB0byBzZXQgYSBzY2hlbWEtbGVzcyBmaWVsZFxuICAgICAgICAvLyB0byBhbiBlbXB0eSBvYmplY3QgbGl0ZXJhbFxuICAgICAgICBoYXNLZXlzIHw9IHdhbGtVcGRhdGVQYXRoKHNjaGVtYSwgdmFsLCBvcCwgb3B0aW9ucywgY29udGV4dCwgZmlsdGVyLCBwcmVmaXggKyBrZXkpIHx8XG4gICAgICAgICAgKHV0aWxzLmlzT2JqZWN0KHZhbCkgJiYgT2JqZWN0LmtleXModmFsKS5sZW5ndGggPT09IDApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjaGVja1BhdGggPSAoa2V5ID09PSAnJGVhY2gnIHx8IGtleSA9PT0gJyRvcicgfHwga2V5ID09PSAnJGFuZCcgfHwga2V5ID09PSAnJGluJykgP1xuICAgICAgICBwcmVmIDogcHJlZml4ICsga2V5O1xuICAgICAgc2NoZW1hdHlwZSA9IHNjaGVtYS5fZ2V0U2NoZW1hKGNoZWNrUGF0aCk7XG5cbiAgICAgIC8vIFlvdSBjYW4gdXNlIGAkc2V0T25JbnNlcnRgIHdpdGggaW1tdXRhYmxlIGtleXNcbiAgICAgIGlmIChvcCAhPT0gJyRzZXRPbkluc2VydCcgJiZcbiAgICAgICAgICBoYW5kbGVJbW11dGFibGUoc2NoZW1hdHlwZSwgc3RyaWN0LCBvYmosIGtleSwgcHJlZml4ICsga2V5LCBjb250ZXh0KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbGV0IHBhdGhEZXRhaWxzID0gc2NoZW1hLl9nZXRQYXRoVHlwZShjaGVja1BhdGgpO1xuXG4gICAgICAvLyBJZiBubyBzY2hlbWEgdHlwZSwgY2hlY2sgZm9yIGVtYmVkZGVkIGRpc2NyaW1pbmF0b3JzIGJlY2F1c2UgdGhlXG4gICAgICAvLyBmaWx0ZXIgb3IgdXBkYXRlIG1heSBpbXBseSBhbiBlbWJlZGRlZCBkaXNjcmltaW5hdG9yIHR5cGUuIFNlZSAjODM3OFxuICAgICAgaWYgKHNjaGVtYXR5cGUgPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBfcmVzID0gZ2V0RW1iZWRkZWREaXNjcmltaW5hdG9yUGF0aChzY2hlbWEsIG9iaiwgZmlsdGVyLCBjaGVja1BhdGgsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoX3Jlcy5zY2hlbWF0eXBlICE9IG51bGwpIHtcbiAgICAgICAgICBzY2hlbWF0eXBlID0gX3Jlcy5zY2hlbWF0eXBlO1xuICAgICAgICAgIHBhdGhEZXRhaWxzID0gX3Jlcy50eXBlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCBpc1N0cmljdCA9IHN0cmljdDtcbiAgICAgIGlmIChwYXRoRGV0YWlscyAmJiBwYXRoRGV0YWlscy5zY2hlbWEgJiYgc3RyaWN0ID09IG51bGwpIHtcbiAgICAgICAgaXNTdHJpY3QgPSBwYXRoRGV0YWlscy5zY2hlbWEub3B0aW9ucy5zdHJpY3Q7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNraXAgPSBpc1N0cmljdCAmJlxuICAgICAgICAhc2NoZW1hdHlwZSAmJlxuICAgICAgICAhL3JlYWx8bmVzdGVkLy50ZXN0KHBhdGhEZXRhaWxzLnBhdGhUeXBlKTtcblxuICAgICAgaWYgKHNraXApIHtcbiAgICAgICAgLy8gRXZlbiBpZiBzdHJpY3QgaXMgYHRocm93YCwgYXZvaWQgdGhyb3dpbmcgYW4gZXJyb3IgYmVjYXVzZSBvZlxuICAgICAgICAvLyB2aXJ0dWFscyBiZWNhdXNlIG9mICM2NzMxXG4gICAgICAgIGlmIChpc1N0cmljdCA9PT0gJ3Rocm93JyAmJiBzY2hlbWEudmlydHVhbHNbY2hlY2tQYXRoXSA9PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN0cmljdE1vZGVFcnJvcihwcmVmaXggKyBrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZ2gtMTg0NSB0ZW1wb3JhcnkgZml4OiBpZ25vcmUgJHJlbmFtZS4gU2VlIGdoLTMwMjcgZm9yIHRyYWNraW5nXG4gICAgICAgIC8vIGltcHJvdmluZyB0aGlzLlxuICAgICAgICBpZiAob3AgPT09ICckcmVuYW1lJykge1xuICAgICAgICAgIGhhc0tleXMgPSB0cnVlO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAocHJlZml4Lmxlbmd0aCA9PT0gMCB8fCBrZXkuaW5kZXhPZignLicpID09PSAtMSkge1xuICAgICAgICAgICAgb2JqW2tleV0gPSBjYXN0VXBkYXRlVmFsKHNjaGVtYXR5cGUsIHZhbCwgb3AsIGtleSwgY29udGV4dCwgcHJlZml4ICsga2V5KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzU3RyaWN0ICE9PSBmYWxzZSB8fCBzY2hlbWF0eXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFNldHRpbmcgYSBuZXN0ZWQgZG90dGVkIHBhdGggdGhhdCdzIGluIHRoZSBzY2hlbWEuIFdlIGRvbid0IGFsbG93IHBhdGhzIHdpdGggJy4nIGluXG4gICAgICAgICAgICAvLyBhIHNjaGVtYSwgc28gcmVwbGFjZSB0aGUgZG90dGVkIHBhdGggd2l0aCBhIG5lc3RlZCBvYmplY3QgdG8gYXZvaWQgZW5kaW5nIHVwIHdpdGhcbiAgICAgICAgICAgIC8vIGRvdHRlZCBwcm9wZXJ0aWVzIGluIHRoZSB1cGRhdGVkIG9iamVjdC4gU2VlIChnaC0xMDIwMClcbiAgICAgICAgICAgIHNldERvdHRlZFBhdGgob2JqLCBrZXksIGNhc3RVcGRhdGVWYWwoc2NoZW1hdHlwZSwgdmFsLCBvcCwga2V5LCBjb250ZXh0LCBwcmVmaXggKyBrZXkpKTtcbiAgICAgICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgYWdncmVnYXRlZEVycm9yID0gX2FwcGVuZEVycm9yKGVycm9yLCBjb250ZXh0LCBrZXksIGFnZ3JlZ2F0ZWRFcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpba2V5XSkgJiYgKG9wID09PSAnJGFkZFRvU2V0JyB8fCBvcCA9PT0gJyRwdXNoJykgJiYga2V5ICE9PSAnJGVhY2gnKSB7XG4gICAgICAgICAgaWYgKHNjaGVtYXR5cGUgJiZcbiAgICAgICAgICAgICAgc2NoZW1hdHlwZS5jYXN0ZXIgJiZcbiAgICAgICAgICAgICAgIXNjaGVtYXR5cGUuY2FzdGVyLiRpc01vbmdvb3NlQXJyYXkgJiZcbiAgICAgICAgICAgICAgIXNjaGVtYXR5cGUuY2FzdGVyW3NjaGVtYU1peGVkU3ltYm9sXSkge1xuICAgICAgICAgICAgb2JqW2tleV0gPSB7ICRlYWNoOiBvYmpba2V5XSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvYmpba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFzS2V5cyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGFnZ3JlZ2F0ZWRFcnJvciAhPSBudWxsKSB7XG4gICAgdGhyb3cgYWdncmVnYXRlZEVycm9yO1xuICB9XG5cbiAgcmV0dXJuIGhhc0tleXM7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2FwcGVuZEVycm9yKGVycm9yLCBxdWVyeSwga2V5LCBhZ2dyZWdhdGVkRXJyb3IpIHtcbiAgaWYgKHR5cGVvZiBxdWVyeSAhPT0gJ29iamVjdCcgfHwgIXF1ZXJ5Lm9wdGlvbnMubXVsdGlwbGVDYXN0RXJyb3IpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICBhZ2dyZWdhdGVkRXJyb3IgPSBhZ2dyZWdhdGVkRXJyb3IgfHwgbmV3IFZhbGlkYXRpb25FcnJvcigpO1xuICBhZ2dyZWdhdGVkRXJyb3IuYWRkRXJyb3Ioa2V5LCBlcnJvcik7XG4gIHJldHVybiBhZ2dyZWdhdGVkRXJyb3I7XG59XG5cbi8qKlxuICogVGhlc2Ugb3BlcmF0b3JzIHNob3VsZCBiZSBjYXN0IHRvIG51bWJlcnMgaW5zdGVhZFxuICogb2YgdGhlaXIgcGF0aCBzY2hlbWEgdHlwZS5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmNvbnN0IG51bWJlck9wcyA9IHtcbiAgJHBvcDogMSxcbiAgJGluYzogMVxufTtcblxuLyoqXG4gKiBUaGVzZSBvcHMgcmVxdWlyZSBubyBjYXN0aW5nIGJlY2F1c2UgdGhlIFJIUyBkb2Vzbid0IGRvIGFueXRoaW5nLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuY29uc3Qgbm9DYXN0T3BzID0ge1xuICAkdW5zZXQ6IDFcbn07XG5cbi8qKlxuICogVGhlc2Ugb3BlcmF0b3JzIHJlcXVpcmUgY2FzdGluZyBkb2NzXG4gKiB0byByZWFsIERvY3VtZW50cyBmb3IgVXBkYXRlIG9wZXJhdGlvbnMuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5jb25zdCBjYXN0T3BzID0ge1xuICAkcHVzaDogMSxcbiAgJGFkZFRvU2V0OiAxLFxuICAkc2V0OiAxLFxuICAkc2V0T25JbnNlcnQ6IDFcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuY29uc3Qgb3ZlcndyaXRlT3BzID0ge1xuICAkc2V0OiAxLFxuICAkc2V0T25JbnNlcnQ6IDFcbn07XG5cbi8qKlxuICogQ2FzdHMgYHZhbGAgYWNjb3JkaW5nIHRvIGBzY2hlbWFgIGFuZCBhdG9taWMgYG9wYC5cbiAqXG4gKiBAcGFyYW0ge1NjaGVtYVR5cGV9IHNjaGVtYVxuICogQHBhcmFtIHtPYmplY3R9IHZhbFxuICogQHBhcmFtIHtTdHJpbmd9IG9wIHRoZSBhdG9taWMgb3BlcmF0b3IgKCRwdWxsLCAkc2V0LCBldGMpXG4gKiBAcGFyYW0ge1N0cmluZ30gJGNvbmRpdGlvbmFsXG4gKiBAcGFyYW0ge1F1ZXJ5fSBjb250ZXh0XG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY2FzdFVwZGF0ZVZhbChzY2hlbWEsIHZhbCwgb3AsICRjb25kaXRpb25hbCwgY29udGV4dCwgcGF0aCkge1xuICBpZiAoIXNjaGVtYSkge1xuICAgIC8vIG5vbi1leGlzdGluZyBzY2hlbWEgcGF0aFxuICAgIGlmIChvcCBpbiBudW1iZXJPcHMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjYXN0TnVtYmVyKHZhbCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IENhc3RFcnJvcignbnVtYmVyJywgdmFsLCBwYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIC8vIGNvbnNvbGUubG9nKCdDYXN0VXBkYXRlVmFsJywgcGF0aCwgb3AsIHZhbCwgc2NoZW1hKTtcblxuICBjb25zdCBjb25kID0gc2NoZW1hLmNhc3RlciAmJiBvcCBpbiBjYXN0T3BzICYmXG4gICAgICAodXRpbHMuaXNPYmplY3QodmFsKSB8fCBBcnJheS5pc0FycmF5KHZhbCkpO1xuICBpZiAoY29uZCAmJiAhb3ZlcndyaXRlT3BzW29wXSkge1xuICAgIC8vIENhc3QgdmFsdWVzIGZvciBvcHMgdGhhdCBhZGQgZGF0YSB0byBNb25nb0RCLlxuICAgIC8vIEVuc3VyZXMgZW1iZWRkZWQgZG9jdW1lbnRzIGdldCBPYmplY3RJZHMgZXRjLlxuICAgIGxldCBzY2hlbWFBcnJheURlcHRoID0gMDtcbiAgICBsZXQgY3VyID0gc2NoZW1hO1xuICAgIHdoaWxlIChjdXIuJGlzTW9uZ29vc2VBcnJheSkge1xuICAgICAgKytzY2hlbWFBcnJheURlcHRoO1xuICAgICAgY3VyID0gY3VyLmNhc3RlcjtcbiAgICB9XG4gICAgbGV0IGFycmF5RGVwdGggPSAwO1xuICAgIGxldCBfdmFsID0gdmFsO1xuICAgIHdoaWxlIChBcnJheS5pc0FycmF5KF92YWwpKSB7XG4gICAgICArK2FycmF5RGVwdGg7XG4gICAgICBfdmFsID0gX3ZhbFswXTtcbiAgICB9XG5cbiAgICBjb25zdCBhZGRpdGlvbmFsTmVzdGluZyA9IHNjaGVtYUFycmF5RGVwdGggLSBhcnJheURlcHRoO1xuICAgIHdoaWxlIChhcnJheURlcHRoIDwgc2NoZW1hQXJyYXlEZXB0aCkge1xuICAgICAgdmFsID0gW3ZhbF07XG4gICAgICArK2FycmF5RGVwdGg7XG4gICAgfVxuXG4gICAgbGV0IHRtcCA9IHNjaGVtYS5hcHBseVNldHRlcnMoQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsIDogW3ZhbF0sIGNvbnRleHQpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRpdGlvbmFsTmVzdGluZzsgKytpKSB7XG4gICAgICB0bXAgPSB0bXBbMF07XG4gICAgfVxuICAgIHJldHVybiB0bXA7XG4gIH1cblxuICBpZiAob3AgaW4gbm9DYXN0T3BzKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBpZiAob3AgaW4gbnVtYmVyT3BzKSB7XG4gICAgLy8gTnVsbCBhbmQgdW5kZWZpbmVkIG5vdCBhbGxvd2VkIGZvciAkcG9wLCAkaW5jXG4gICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdudW1iZXInLCB2YWwsIHNjaGVtYS5wYXRoKTtcbiAgICB9XG4gICAgaWYgKG9wID09PSAnJGluYycpIHtcbiAgICAgIC8vIFN1cHBvcnQgYCRpbmNgIHdpdGggbG9uZywgaW50MzIsIGV0Yy4gKGdoLTQyODMpXG4gICAgICByZXR1cm4gc2NoZW1hLmNhc3RGb3JRdWVyeShcbiAgICAgICAgbnVsbCxcbiAgICAgICAgdmFsLFxuICAgICAgICBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNhc3ROdW1iZXIodmFsKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IENhc3RFcnJvcignbnVtYmVyJywgdmFsLCBzY2hlbWEucGF0aCk7XG4gICAgfVxuICB9XG4gIGlmIChvcCA9PT0gJyRjdXJyZW50RGF0ZScpIHtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB7ICR0eXBlOiB2YWwuJHR5cGUgfTtcbiAgICB9XG4gICAgcmV0dXJuIEJvb2xlYW4odmFsKTtcbiAgfVxuXG4gIGlmIChtb25nb2RiVXBkYXRlT3BlcmF0b3JzLmhhcygkY29uZGl0aW9uYWwpKSB7XG4gICAgcmV0dXJuIHNjaGVtYS5jYXN0Rm9yUXVlcnkoXG4gICAgICAkY29uZGl0aW9uYWwsXG4gICAgICB2YWwsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgfVxuXG4gIGlmIChvdmVyd3JpdGVPcHNbb3BdKSB7XG4gICAgY29uc3Qgc2tpcFF1ZXJ5Q2FzdEZvclVwZGF0ZSA9IHZhbCAhPSBudWxsICYmIHNjaGVtYS4kaXNNb25nb29zZUFycmF5ICYmIHNjaGVtYS4kZnVsbFBhdGggIT0gbnVsbCAmJiAhc2NoZW1hLiRmdWxsUGF0aC5tYXRjaCgvXFxkKyQvKTtcbiAgICBjb25zdCBhcHBseVNldHRlcnMgPSBzY2hlbWFbc2NoZW1hTWl4ZWRTeW1ib2xdICE9IG51bGw7XG4gICAgaWYgKHNraXBRdWVyeUNhc3RGb3JVcGRhdGUgfHwgYXBwbHlTZXR0ZXJzKSB7XG4gICAgICByZXR1cm4gc2NoZW1hLmFwcGx5U2V0dGVycyh2YWwsIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gc2NoZW1hLmNhc3RGb3JRdWVyeShcbiAgICAgIG51bGwsXG4gICAgICB2YWwsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBzY2hlbWEuY2FzdEZvclF1ZXJ5KG51bGwsIHZhbCwgY29udGV4dCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/query/castUpdate.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/query/getEmbeddedDiscriminatorPath.js":
/*!******************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/query/getEmbeddedDiscriminatorPath.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst cleanPositionalOperators = __webpack_require__(/*! ../schema/cleanPositionalOperators */ \"../backend/node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js\");\nconst get = __webpack_require__(/*! ../get */ \"../backend/node_modules/mongoose/lib/helpers/get.js\");\nconst getDiscriminatorByValue = __webpack_require__(/*! ../discriminator/getDiscriminatorByValue */ \"../backend/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\nconst updatedPathsByArrayFilter = __webpack_require__(/*! ../update/updatedPathsByArrayFilter */ \"../backend/node_modules/mongoose/lib/helpers/update/updatedPathsByArrayFilter.js\");\n\n/**\n * Like `schema.path()`, except with a document, because impossible to\n * determine path type without knowing the embedded discriminator key.\n * @param {Schema} schema\n * @param {Object} [update]\n * @param {Object} [filter]\n * @param {String} path\n * @param {Object} [options]\n * @api private\n */\n\nmodule.exports = function getEmbeddedDiscriminatorPath(schema, update, filter, path, options) {\n  const parts = path.split('.');\n  let schematype = null;\n  let type = 'adhocOrUndefined';\n\n  filter = filter || {};\n  update = update || {};\n  const arrayFilters = options != null && Array.isArray(options.arrayFilters) ?\n    options.arrayFilters : [];\n  const updatedPathsByFilter = updatedPathsByArrayFilter(update);\n\n  for (let i = 0; i < parts.length; ++i) {\n    const subpath = cleanPositionalOperators(parts.slice(0, i + 1).join('.'));\n    schematype = schema.path(subpath);\n    if (schematype == null) {\n      continue;\n    }\n\n    type = schema.pathType(subpath);\n    if ((schematype.$isSingleNested || schematype.$isMongooseDocumentArrayElement) &&\n        schematype.schema.discriminators != null) {\n      const key = get(schematype, 'schema.options.discriminatorKey');\n      const discriminatorValuePath = subpath + '.' + key;\n      const discriminatorFilterPath =\n        discriminatorValuePath.replace(/\\.\\d+\\./, '.');\n      let discriminatorKey = null;\n\n      if (discriminatorValuePath in filter) {\n        discriminatorKey = filter[discriminatorValuePath];\n      }\n      if (discriminatorFilterPath in filter) {\n        discriminatorKey = filter[discriminatorFilterPath];\n      }\n\n      const wrapperPath = subpath.replace(/\\.\\d+$/, '');\n      if (schematype.$isMongooseDocumentArrayElement &&\n          get(filter[wrapperPath], '$elemMatch.' + key) != null) {\n        discriminatorKey = filter[wrapperPath].$elemMatch[key];\n      }\n\n      if (discriminatorValuePath in update) {\n        discriminatorKey = update[discriminatorValuePath];\n      }\n\n      for (const filterKey of Object.keys(updatedPathsByFilter)) {\n        const schemaKey = updatedPathsByFilter[filterKey] + '.' + key;\n        const arrayFilterKey = filterKey + '.' + key;\n        if (schemaKey === discriminatorFilterPath) {\n          const filter = arrayFilters.find(filter => filter.hasOwnProperty(arrayFilterKey));\n          if (filter != null) {\n            discriminatorKey = filter[arrayFilterKey];\n          }\n        }\n      }\n\n      if (discriminatorKey == null) {\n        continue;\n      }\n\n      const discriminator = getDiscriminatorByValue(schematype.caster.discriminators, discriminatorKey);\n      const discriminatorSchema = discriminator && discriminator.schema;\n      if (discriminatorSchema == null) {\n        continue;\n      }\n\n      const rest = parts.slice(i + 1).join('.');\n      schematype = discriminatorSchema.path(rest);\n      if (schematype != null) {\n        type = discriminatorSchema._getPathType(rest);\n        break;\n      }\n    }\n  }\n\n  return { type: type, schematype: schematype };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvZ2V0RW1iZWRkZWREaXNjcmltaW5hdG9yUGF0aC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixpQ0FBaUMsbUJBQU8sQ0FBQywySEFBb0M7QUFDN0UsWUFBWSxtQkFBTyxDQUFDLG1FQUFRO0FBQzVCLGdDQUFnQyxtQkFBTyxDQUFDLHVJQUEwQztBQUNsRixrQ0FBa0MsbUJBQU8sQ0FBQyw2SEFBcUM7O0FBRS9FO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3F1ZXJ5L2dldEVtYmVkZGVkRGlzY3JpbWluYXRvclBhdGguanM/Y2Y2YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGNsZWFuUG9zaXRpb25hbE9wZXJhdG9ycyA9IHJlcXVpcmUoJy4uL3NjaGVtYS9jbGVhblBvc2l0aW9uYWxPcGVyYXRvcnMnKTtcbmNvbnN0IGdldCA9IHJlcXVpcmUoJy4uL2dldCcpO1xuY29uc3QgZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUgPSByZXF1aXJlKCcuLi9kaXNjcmltaW5hdG9yL2dldERpc2NyaW1pbmF0b3JCeVZhbHVlJyk7XG5jb25zdCB1cGRhdGVkUGF0aHNCeUFycmF5RmlsdGVyID0gcmVxdWlyZSgnLi4vdXBkYXRlL3VwZGF0ZWRQYXRoc0J5QXJyYXlGaWx0ZXInKTtcblxuLyoqXG4gKiBMaWtlIGBzY2hlbWEucGF0aCgpYCwgZXhjZXB0IHdpdGggYSBkb2N1bWVudCwgYmVjYXVzZSBpbXBvc3NpYmxlIHRvXG4gKiBkZXRlcm1pbmUgcGF0aCB0eXBlIHdpdGhvdXQga25vd2luZyB0aGUgZW1iZWRkZWQgZGlzY3JpbWluYXRvciBrZXkuXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAcGFyYW0ge09iamVjdH0gW3VwZGF0ZV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbZmlsdGVyXVxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0RW1iZWRkZWREaXNjcmltaW5hdG9yUGF0aChzY2hlbWEsIHVwZGF0ZSwgZmlsdGVyLCBwYXRoLCBvcHRpb25zKSB7XG4gIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICBsZXQgc2NoZW1hdHlwZSA9IG51bGw7XG4gIGxldCB0eXBlID0gJ2FkaG9jT3JVbmRlZmluZWQnO1xuXG4gIGZpbHRlciA9IGZpbHRlciB8fCB7fTtcbiAgdXBkYXRlID0gdXBkYXRlIHx8IHt9O1xuICBjb25zdCBhcnJheUZpbHRlcnMgPSBvcHRpb25zICE9IG51bGwgJiYgQXJyYXkuaXNBcnJheShvcHRpb25zLmFycmF5RmlsdGVycykgP1xuICAgIG9wdGlvbnMuYXJyYXlGaWx0ZXJzIDogW107XG4gIGNvbnN0IHVwZGF0ZWRQYXRoc0J5RmlsdGVyID0gdXBkYXRlZFBhdGhzQnlBcnJheUZpbHRlcih1cGRhdGUpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBzdWJwYXRoID0gY2xlYW5Qb3NpdGlvbmFsT3BlcmF0b3JzKHBhcnRzLnNsaWNlKDAsIGkgKyAxKS5qb2luKCcuJykpO1xuICAgIHNjaGVtYXR5cGUgPSBzY2hlbWEucGF0aChzdWJwYXRoKTtcbiAgICBpZiAoc2NoZW1hdHlwZSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB0eXBlID0gc2NoZW1hLnBhdGhUeXBlKHN1YnBhdGgpO1xuICAgIGlmICgoc2NoZW1hdHlwZS4kaXNTaW5nbGVOZXN0ZWQgfHwgc2NoZW1hdHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXlFbGVtZW50KSAmJlxuICAgICAgICBzY2hlbWF0eXBlLnNjaGVtYS5kaXNjcmltaW5hdG9ycyAhPSBudWxsKSB7XG4gICAgICBjb25zdCBrZXkgPSBnZXQoc2NoZW1hdHlwZSwgJ3NjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXknKTtcbiAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JWYWx1ZVBhdGggPSBzdWJwYXRoICsgJy4nICsga2V5O1xuICAgICAgY29uc3QgZGlzY3JpbWluYXRvckZpbHRlclBhdGggPVxuICAgICAgICBkaXNjcmltaW5hdG9yVmFsdWVQYXRoLnJlcGxhY2UoL1xcLlxcZCtcXC4vLCAnLicpO1xuICAgICAgbGV0IGRpc2NyaW1pbmF0b3JLZXkgPSBudWxsO1xuXG4gICAgICBpZiAoZGlzY3JpbWluYXRvclZhbHVlUGF0aCBpbiBmaWx0ZXIpIHtcbiAgICAgICAgZGlzY3JpbWluYXRvcktleSA9IGZpbHRlcltkaXNjcmltaW5hdG9yVmFsdWVQYXRoXTtcbiAgICAgIH1cbiAgICAgIGlmIChkaXNjcmltaW5hdG9yRmlsdGVyUGF0aCBpbiBmaWx0ZXIpIHtcbiAgICAgICAgZGlzY3JpbWluYXRvcktleSA9IGZpbHRlcltkaXNjcmltaW5hdG9yRmlsdGVyUGF0aF07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHdyYXBwZXJQYXRoID0gc3VicGF0aC5yZXBsYWNlKC9cXC5cXGQrJC8sICcnKTtcbiAgICAgIGlmIChzY2hlbWF0eXBlLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheUVsZW1lbnQgJiZcbiAgICAgICAgICBnZXQoZmlsdGVyW3dyYXBwZXJQYXRoXSwgJyRlbGVtTWF0Y2guJyArIGtleSkgIT0gbnVsbCkge1xuICAgICAgICBkaXNjcmltaW5hdG9yS2V5ID0gZmlsdGVyW3dyYXBwZXJQYXRoXS4kZWxlbU1hdGNoW2tleV07XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXNjcmltaW5hdG9yVmFsdWVQYXRoIGluIHVwZGF0ZSkge1xuICAgICAgICBkaXNjcmltaW5hdG9yS2V5ID0gdXBkYXRlW2Rpc2NyaW1pbmF0b3JWYWx1ZVBhdGhdO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGZpbHRlcktleSBvZiBPYmplY3Qua2V5cyh1cGRhdGVkUGF0aHNCeUZpbHRlcikpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hS2V5ID0gdXBkYXRlZFBhdGhzQnlGaWx0ZXJbZmlsdGVyS2V5XSArICcuJyArIGtleTtcbiAgICAgICAgY29uc3QgYXJyYXlGaWx0ZXJLZXkgPSBmaWx0ZXJLZXkgKyAnLicgKyBrZXk7XG4gICAgICAgIGlmIChzY2hlbWFLZXkgPT09IGRpc2NyaW1pbmF0b3JGaWx0ZXJQYXRoKSB7XG4gICAgICAgICAgY29uc3QgZmlsdGVyID0gYXJyYXlGaWx0ZXJzLmZpbmQoZmlsdGVyID0+IGZpbHRlci5oYXNPd25Qcm9wZXJ0eShhcnJheUZpbHRlcktleSkpO1xuICAgICAgICAgIGlmIChmaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgZGlzY3JpbWluYXRvcktleSA9IGZpbHRlclthcnJheUZpbHRlcktleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXNjcmltaW5hdG9yS2V5ID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3IgPSBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZShzY2hlbWF0eXBlLmNhc3Rlci5kaXNjcmltaW5hdG9ycywgZGlzY3JpbWluYXRvcktleSk7XG4gICAgICBjb25zdCBkaXNjcmltaW5hdG9yU2NoZW1hID0gZGlzY3JpbWluYXRvciAmJiBkaXNjcmltaW5hdG9yLnNjaGVtYTtcbiAgICAgIGlmIChkaXNjcmltaW5hdG9yU2NoZW1hID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3QgPSBwYXJ0cy5zbGljZShpICsgMSkuam9pbignLicpO1xuICAgICAgc2NoZW1hdHlwZSA9IGRpc2NyaW1pbmF0b3JTY2hlbWEucGF0aChyZXN0KTtcbiAgICAgIGlmIChzY2hlbWF0eXBlICE9IG51bGwpIHtcbiAgICAgICAgdHlwZSA9IGRpc2NyaW1pbmF0b3JTY2hlbWEuX2dldFBhdGhUeXBlKHJlc3QpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4geyB0eXBlOiB0eXBlLCBzY2hlbWF0eXBlOiBzY2hlbWF0eXBlIH07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/query/getEmbeddedDiscriminatorPath.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/query/handleImmutable.js":
/*!*****************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/query/handleImmutable.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst StrictModeError = __webpack_require__(/*! ../../error/strict */ \"../backend/node_modules/mongoose/lib/error/strict.js\");\n\nmodule.exports = function handleImmutable(schematype, strict, obj, key, fullPath, ctx) {\n  if (schematype == null || !schematype.options || !schematype.options.immutable) {\n    return false;\n  }\n  let immutable = schematype.options.immutable;\n\n  if (typeof immutable === 'function') {\n    immutable = immutable.call(ctx, ctx);\n  }\n  if (!immutable) {\n    return false;\n  }\n\n  if (strict === false) {\n    return false;\n  }\n  if (strict === 'throw') {\n    throw new StrictModeError(null,\n      `Field ${fullPath} is immutable and strict = 'throw'`);\n  }\n\n  delete obj[key];\n  return true;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvaGFuZGxlSW1tdXRhYmxlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHdCQUF3QixtQkFBTyxDQUFDLGdGQUFvQjs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS9oYW5kbGVJbW11dGFibGUuanM/NmJmNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFN0cmljdE1vZGVFcnJvciA9IHJlcXVpcmUoJy4uLy4uL2Vycm9yL3N0cmljdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhbmRsZUltbXV0YWJsZShzY2hlbWF0eXBlLCBzdHJpY3QsIG9iaiwga2V5LCBmdWxsUGF0aCwgY3R4KSB7XG4gIGlmIChzY2hlbWF0eXBlID09IG51bGwgfHwgIXNjaGVtYXR5cGUub3B0aW9ucyB8fCAhc2NoZW1hdHlwZS5vcHRpb25zLmltbXV0YWJsZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgaW1tdXRhYmxlID0gc2NoZW1hdHlwZS5vcHRpb25zLmltbXV0YWJsZTtcblxuICBpZiAodHlwZW9mIGltbXV0YWJsZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGltbXV0YWJsZSA9IGltbXV0YWJsZS5jYWxsKGN0eCwgY3R4KTtcbiAgfVxuICBpZiAoIWltbXV0YWJsZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChzdHJpY3QgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChzdHJpY3QgPT09ICd0aHJvdycpIHtcbiAgICB0aHJvdyBuZXcgU3RyaWN0TW9kZUVycm9yKG51bGwsXG4gICAgICBgRmllbGQgJHtmdWxsUGF0aH0gaXMgaW1tdXRhYmxlIGFuZCBzdHJpY3QgPSAndGhyb3cnYCk7XG4gIH1cblxuICBkZWxldGUgb2JqW2tleV07XG4gIHJldHVybiB0cnVlO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/query/handleImmutable.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/query/handleReadPreferenceAliases.js":
/*!*****************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/query/handleReadPreferenceAliases.js ***!
  \*****************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function handleReadPreferenceAliases(pref) {\n  switch (pref) {\n    case 'p':\n      pref = 'primary';\n      break;\n    case 'pp':\n      pref = 'primaryPreferred';\n      break;\n    case 's':\n      pref = 'secondary';\n      break;\n    case 'sp':\n      pref = 'secondaryPreferred';\n      break;\n    case 'n':\n      pref = 'nearest';\n      break;\n  }\n\n  return pref;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvaGFuZGxlUmVhZFByZWZlcmVuY2VBbGlhc2VzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvaGFuZGxlUmVhZFByZWZlcmVuY2VBbGlhc2VzLmpzPzA0MDMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhbmRsZVJlYWRQcmVmZXJlbmNlQWxpYXNlcyhwcmVmKSB7XG4gIHN3aXRjaCAocHJlZikge1xuICAgIGNhc2UgJ3AnOlxuICAgICAgcHJlZiA9ICdwcmltYXJ5JztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3BwJzpcbiAgICAgIHByZWYgPSAncHJpbWFyeVByZWZlcnJlZCc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzJzpcbiAgICAgIHByZWYgPSAnc2Vjb25kYXJ5JztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NwJzpcbiAgICAgIHByZWYgPSAnc2Vjb25kYXJ5UHJlZmVycmVkJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ24nOlxuICAgICAgcHJlZiA9ICduZWFyZXN0JztcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHByZWY7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/query/handleReadPreferenceAliases.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/query/hasDollarKeys.js":
/*!***************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/query/hasDollarKeys.js ***!
  \***************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = function hasDollarKeys(obj) {\n\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n\n  const keys = Object.keys(obj);\n  const len = keys.length;\n\n  for (let i = 0; i < len; ++i) {\n    if (keys[i][0] === '$') {\n      return true;\n    }\n  }\n\n  return false;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvaGFzRG9sbGFyS2V5cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3F1ZXJ5L2hhc0RvbGxhcktleXMuanM/MjkyMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNEb2xsYXJLZXlzKG9iaikge1xuXG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgY29uc3QgbGVuID0ga2V5cy5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChrZXlzW2ldWzBdID09PSAnJCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/query/hasDollarKeys.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/query/isOperator.js":
/*!************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/query/isOperator.js ***!
  \************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst specialKeys = new Set([\n  '$ref',\n  '$id',\n  '$db'\n]);\n\nmodule.exports = function isOperator(path) {\n  return (\n    path[0] === '$' &&\n    !specialKeys.has(path)\n  );\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvaXNPcGVyYXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3F1ZXJ5L2lzT3BlcmF0b3IuanM/YmEwOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHNwZWNpYWxLZXlzID0gbmV3IFNldChbXG4gICckcmVmJyxcbiAgJyRpZCcsXG4gICckZGInXG5dKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc09wZXJhdG9yKHBhdGgpIHtcbiAgcmV0dXJuIChcbiAgICBwYXRoWzBdID09PSAnJCcgJiZcbiAgICAhc3BlY2lhbEtleXMuaGFzKHBhdGgpXG4gICk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/query/isOperator.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/query/sanitizeFilter.js":
/*!****************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/query/sanitizeFilter.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst hasDollarKeys = __webpack_require__(/*! ./hasDollarKeys */ \"../backend/node_modules/mongoose/lib/helpers/query/hasDollarKeys.js\");\nconst { trustedSymbol } = __webpack_require__(/*! ./trusted */ \"../backend/node_modules/mongoose/lib/helpers/query/trusted.js\");\n\nmodule.exports = function sanitizeFilter(filter) {\n  if (filter == null || typeof filter !== 'object') {\n    return filter;\n  }\n  if (Array.isArray(filter)) {\n    for (const subfilter of filter) {\n      sanitizeFilter(subfilter);\n    }\n    return filter;\n  }\n\n  const filterKeys = Object.keys(filter);\n  for (const key of filterKeys) {\n    const value = filter[key];\n    if (value != null && value[trustedSymbol]) {\n      continue;\n    }\n    if (key === '$and' || key === '$or') {\n      sanitizeFilter(value);\n      continue;\n    }\n\n    if (hasDollarKeys(value)) {\n      const keys = Object.keys(value);\n      if (keys.length === 1 && keys[0] === '$eq') {\n        continue;\n      }\n      filter[key] = { $eq: filter[key] };\n    }\n  }\n\n  return filter;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvc2FuaXRpemVGaWx0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsNEZBQWlCO0FBQy9DLFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQyxnRkFBVzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS9zYW5pdGl6ZUZpbHRlci5qcz9jZjFmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaGFzRG9sbGFyS2V5cyA9IHJlcXVpcmUoJy4vaGFzRG9sbGFyS2V5cycpO1xuY29uc3QgeyB0cnVzdGVkU3ltYm9sIH0gPSByZXF1aXJlKCcuL3RydXN0ZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzYW5pdGl6ZUZpbHRlcihmaWx0ZXIpIHtcbiAgaWYgKGZpbHRlciA9PSBudWxsIHx8IHR5cGVvZiBmaWx0ZXIgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZpbHRlcjtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShmaWx0ZXIpKSB7XG4gICAgZm9yIChjb25zdCBzdWJmaWx0ZXIgb2YgZmlsdGVyKSB7XG4gICAgICBzYW5pdGl6ZUZpbHRlcihzdWJmaWx0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gZmlsdGVyO1xuICB9XG5cbiAgY29uc3QgZmlsdGVyS2V5cyA9IE9iamVjdC5rZXlzKGZpbHRlcik7XG4gIGZvciAoY29uc3Qga2V5IG9mIGZpbHRlcktleXMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGZpbHRlcltrZXldO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlW3RydXN0ZWRTeW1ib2xdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGtleSA9PT0gJyRhbmQnIHx8IGtleSA9PT0gJyRvcicpIHtcbiAgICAgIHNhbml0aXplRmlsdGVyKHZhbHVlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChoYXNEb2xsYXJLZXlzKHZhbHVlKSkge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMSAmJiBrZXlzWzBdID09PSAnJGVxJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZpbHRlcltrZXldID0geyAkZXE6IGZpbHRlcltrZXldIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpbHRlcjtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/query/sanitizeFilter.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/query/sanitizeProjection.js":
/*!********************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/query/sanitizeProjection.js ***!
  \********************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function sanitizeProjection(projection) {\n  if (projection == null) {\n    return;\n  }\n\n  const keys = Object.keys(projection);\n  for (let i = 0; i < keys.length; ++i) {\n    if (typeof projection[keys[i]] === 'string') {\n      projection[keys[i]] = 1;\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvc2FuaXRpemVQcm9qZWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvc2FuaXRpemVQcm9qZWN0aW9uLmpzPzI5MzUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNhbml0aXplUHJvamVjdGlvbihwcm9qZWN0aW9uKSB7XG4gIGlmIChwcm9qZWN0aW9uID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocHJvamVjdGlvbik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgIGlmICh0eXBlb2YgcHJvamVjdGlvbltrZXlzW2ldXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHByb2plY3Rpb25ba2V5c1tpXV0gPSAxO1xuICAgIH1cbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/query/sanitizeProjection.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/query/selectPopulatedFields.js":
/*!***********************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/query/selectPopulatedFields.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst isExclusive = __webpack_require__(/*! ../projection/isExclusive */ \"../backend/node_modules/mongoose/lib/helpers/projection/isExclusive.js\");\nconst isInclusive = __webpack_require__(/*! ../projection/isInclusive */ \"../backend/node_modules/mongoose/lib/helpers/projection/isInclusive.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = function selectPopulatedFields(fields, userProvidedFields, populateOptions) {\n  if (populateOptions == null) {\n    return;\n  }\n\n  const paths = Object.keys(populateOptions);\n  userProvidedFields = userProvidedFields || {};\n  if (isInclusive(fields)) {\n    for (const path of paths) {\n      if (!isPathInFields(userProvidedFields, path)) {\n        fields[path] = 1;\n      } else if (userProvidedFields[path] === 0) {\n        delete fields[path];\n      }\n\n      const refPath = populateOptions[path]?.refPath;\n      if (typeof refPath === 'string') {\n        if (!isPathInFields(userProvidedFields, refPath)) {\n          fields[refPath] = 1;\n        } else if (userProvidedFields[refPath] === 0) {\n          delete fields[refPath];\n        }\n      }\n    }\n  } else if (isExclusive(fields)) {\n    for (const path of paths) {\n      if (userProvidedFields[path] == null) {\n        delete fields[path];\n      }\n      const refPath = populateOptions[path]?.refPath;\n      if (typeof refPath === 'string' && userProvidedFields[refPath] == null) {\n        delete fields[refPath];\n      }\n    }\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction isPathInFields(userProvidedFields, path) {\n  const pieces = path.split('.');\n  const len = pieces.length;\n  let cur = pieces[0];\n  for (let i = 1; i < len; ++i) {\n    if (userProvidedFields[cur] != null || userProvidedFields[cur + '.$'] != null) {\n      return true;\n    }\n    cur += '.' + pieces[i];\n  }\n  return userProvidedFields[cur] != null || userProvidedFields[cur + '.$'] != null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvc2VsZWN0UG9wdWxhdGVkRmllbGRzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLG9CQUFvQixtQkFBTyxDQUFDLHlHQUEyQjtBQUN2RCxvQkFBb0IsbUJBQU8sQ0FBQyx5R0FBMkI7O0FBRXZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvc2VsZWN0UG9wdWxhdGVkRmllbGRzLmpzPzJlNmQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpc0V4Y2x1c2l2ZSA9IHJlcXVpcmUoJy4uL3Byb2plY3Rpb24vaXNFeGNsdXNpdmUnKTtcbmNvbnN0IGlzSW5jbHVzaXZlID0gcmVxdWlyZSgnLi4vcHJvamVjdGlvbi9pc0luY2x1c2l2ZScpO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2VsZWN0UG9wdWxhdGVkRmllbGRzKGZpZWxkcywgdXNlclByb3ZpZGVkRmllbGRzLCBwb3B1bGF0ZU9wdGlvbnMpIHtcbiAgaWYgKHBvcHVsYXRlT3B0aW9ucyA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgcGF0aHMgPSBPYmplY3Qua2V5cyhwb3B1bGF0ZU9wdGlvbnMpO1xuICB1c2VyUHJvdmlkZWRGaWVsZHMgPSB1c2VyUHJvdmlkZWRGaWVsZHMgfHwge307XG4gIGlmIChpc0luY2x1c2l2ZShmaWVsZHMpKSB7XG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgICBpZiAoIWlzUGF0aEluRmllbGRzKHVzZXJQcm92aWRlZEZpZWxkcywgcGF0aCkpIHtcbiAgICAgICAgZmllbGRzW3BhdGhdID0gMTtcbiAgICAgIH0gZWxzZSBpZiAodXNlclByb3ZpZGVkRmllbGRzW3BhdGhdID09PSAwKSB7XG4gICAgICAgIGRlbGV0ZSBmaWVsZHNbcGF0aF07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlZlBhdGggPSBwb3B1bGF0ZU9wdGlvbnNbcGF0aF0/LnJlZlBhdGg7XG4gICAgICBpZiAodHlwZW9mIHJlZlBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICghaXNQYXRoSW5GaWVsZHModXNlclByb3ZpZGVkRmllbGRzLCByZWZQYXRoKSkge1xuICAgICAgICAgIGZpZWxkc1tyZWZQYXRoXSA9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAodXNlclByb3ZpZGVkRmllbGRzW3JlZlBhdGhdID09PSAwKSB7XG4gICAgICAgICAgZGVsZXRlIGZpZWxkc1tyZWZQYXRoXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc0V4Y2x1c2l2ZShmaWVsZHMpKSB7XG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgICBpZiAodXNlclByb3ZpZGVkRmllbGRzW3BhdGhdID09IG51bGwpIHtcbiAgICAgICAgZGVsZXRlIGZpZWxkc1twYXRoXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlZlBhdGggPSBwb3B1bGF0ZU9wdGlvbnNbcGF0aF0/LnJlZlBhdGg7XG4gICAgICBpZiAodHlwZW9mIHJlZlBhdGggPT09ICdzdHJpbmcnICYmIHVzZXJQcm92aWRlZEZpZWxkc1tyZWZQYXRoXSA9PSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZSBmaWVsZHNbcmVmUGF0aF07XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGlzUGF0aEluRmllbGRzKHVzZXJQcm92aWRlZEZpZWxkcywgcGF0aCkge1xuICBjb25zdCBwaWVjZXMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIGNvbnN0IGxlbiA9IHBpZWNlcy5sZW5ndGg7XG4gIGxldCBjdXIgPSBwaWVjZXNbMF07XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodXNlclByb3ZpZGVkRmllbGRzW2N1cl0gIT0gbnVsbCB8fCB1c2VyUHJvdmlkZWRGaWVsZHNbY3VyICsgJy4kJ10gIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGN1ciArPSAnLicgKyBwaWVjZXNbaV07XG4gIH1cbiAgcmV0dXJuIHVzZXJQcm92aWRlZEZpZWxkc1tjdXJdICE9IG51bGwgfHwgdXNlclByb3ZpZGVkRmllbGRzW2N1ciArICcuJCddICE9IG51bGw7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/query/selectPopulatedFields.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/query/trusted.js":
/*!*********************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/query/trusted.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nconst trustedSymbol = Symbol('mongoose#trustedSymbol');\n\nexports.trustedSymbol = trustedSymbol;\n\nexports.trusted = function trusted(obj) {\n  if (obj == null || typeof obj !== 'object') {\n    return obj;\n  }\n  obj[trustedSymbol] = true;\n  return obj;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvcXVlcnkvdHJ1c3RlZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQSxxQkFBcUI7O0FBRXJCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9xdWVyeS90cnVzdGVkLmpzP2MwYzAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB0cnVzdGVkU3ltYm9sID0gU3ltYm9sKCdtb25nb29zZSN0cnVzdGVkU3ltYm9sJyk7XG5cbmV4cG9ydHMudHJ1c3RlZFN5bWJvbCA9IHRydXN0ZWRTeW1ib2w7XG5cbmV4cG9ydHMudHJ1c3RlZCA9IGZ1bmN0aW9uIHRydXN0ZWQob2JqKSB7XG4gIGlmIChvYmogPT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgb2JqW3RydXN0ZWRTeW1ib2xdID0gdHJ1ZTtcbiAgcmV0dXJuIG9iajtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/query/trusted.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/schema/addAutoId.js":
/*!************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/schema/addAutoId.js ***!
  \************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function addAutoId(schema) {\n  const _obj = { _id: { auto: true } };\n  _obj._id[schema.options.typeKey] = 'ObjectId';\n  schema.add(_obj);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2FkZEF1dG9JZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3NjaGVtYS9hZGRBdXRvSWQuanM/NDkzMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYWRkQXV0b0lkKHNjaGVtYSkge1xuICBjb25zdCBfb2JqID0geyBfaWQ6IHsgYXV0bzogdHJ1ZSB9IH07XG4gIF9vYmouX2lkW3NjaGVtYS5vcHRpb25zLnR5cGVLZXldID0gJ09iamVjdElkJztcbiAgc2NoZW1hLmFkZChfb2JqKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/schema/addAutoId.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/schema/applyBuiltinPlugins.js":
/*!**********************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/schema/applyBuiltinPlugins.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst builtinPlugins = __webpack_require__(/*! ../../plugins */ \"../backend/node_modules/mongoose/lib/plugins/index.js\");\n\nmodule.exports = function applyBuiltinPlugins(schema) {\n  for (const plugin of Object.values(builtinPlugins)) {\n    plugin(schema, { deduplicate: true });\n  }\n  schema.plugins = Object.values(builtinPlugins).\n    map(fn => ({ fn, opts: { deduplicate: true } })).\n    concat(schema.plugins);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2FwcGx5QnVpbHRpblBsdWdpbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsdUJBQXVCLG1CQUFPLENBQUMsNEVBQWU7O0FBRTlDO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWSxxQkFBcUI7QUFDbEQ7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3NjaGVtYS9hcHBseUJ1aWx0aW5QbHVnaW5zLmpzPzBmMzIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBidWlsdGluUGx1Z2lucyA9IHJlcXVpcmUoJy4uLy4uL3BsdWdpbnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhcHBseUJ1aWx0aW5QbHVnaW5zKHNjaGVtYSkge1xuICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBPYmplY3QudmFsdWVzKGJ1aWx0aW5QbHVnaW5zKSkge1xuICAgIHBsdWdpbihzY2hlbWEsIHsgZGVkdXBsaWNhdGU6IHRydWUgfSk7XG4gIH1cbiAgc2NoZW1hLnBsdWdpbnMgPSBPYmplY3QudmFsdWVzKGJ1aWx0aW5QbHVnaW5zKS5cbiAgICBtYXAoZm4gPT4gKHsgZm4sIG9wdHM6IHsgZGVkdXBsaWNhdGU6IHRydWUgfSB9KSkuXG4gICAgY29uY2F0KHNjaGVtYS5wbHVnaW5zKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/schema/applyBuiltinPlugins.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/schema/applyPlugins.js":
/*!***************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/schema/applyPlugins.js ***!
  \***************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function applyPlugins(schema, plugins, options, cacheKey) {\n  if (schema[cacheKey]) {\n    return;\n  }\n  schema[cacheKey] = true;\n\n  if (!options || !options.skipTopLevel) {\n    let pluginTags = null;\n    for (const plugin of plugins) {\n      const tags = plugin[1] == null ? null : plugin[1].tags;\n      if (!Array.isArray(tags)) {\n        schema.plugin(plugin[0], plugin[1]);\n        continue;\n      }\n\n      pluginTags = pluginTags || new Set(schema.options.pluginTags || []);\n      if (!tags.find(tag => pluginTags.has(tag))) {\n        continue;\n      }\n      schema.plugin(plugin[0], plugin[1]);\n    }\n  }\n\n  options = Object.assign({}, options);\n  delete options.skipTopLevel;\n\n  if (options.applyPluginsToChildSchemas !== false) {\n    for (const path of Object.keys(schema.paths)) {\n      const type = schema.paths[path];\n      if (type.schema != null) {\n        applyPlugins(type.schema, plugins, options, cacheKey);\n\n        // Recompile schema because plugins may have changed it, see gh-7572\n        type.caster.prototype.$__setSchema(type.schema);\n      }\n    }\n  }\n\n  const discriminators = schema.discriminators;\n  if (discriminators == null) {\n    return;\n  }\n\n  const applyPluginsToDiscriminators = options.applyPluginsToDiscriminators;\n\n  const keys = Object.keys(discriminators);\n  for (const discriminatorKey of keys) {\n    const discriminatorSchema = discriminators[discriminatorKey];\n\n    applyPlugins(discriminatorSchema, plugins,\n      { skipTopLevel: !applyPluginsToDiscriminators }, cacheKey);\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2FwcGx5UGx1Z2lucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLDZDQUE2QztBQUNyRDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2FwcGx5UGx1Z2lucy5qcz9iYmUxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhcHBseVBsdWdpbnMoc2NoZW1hLCBwbHVnaW5zLCBvcHRpb25zLCBjYWNoZUtleSkge1xuICBpZiAoc2NoZW1hW2NhY2hlS2V5XSkge1xuICAgIHJldHVybjtcbiAgfVxuICBzY2hlbWFbY2FjaGVLZXldID0gdHJ1ZTtcblxuICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMuc2tpcFRvcExldmVsKSB7XG4gICAgbGV0IHBsdWdpblRhZ3MgPSBudWxsO1xuICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHBsdWdpbnMpIHtcbiAgICAgIGNvbnN0IHRhZ3MgPSBwbHVnaW5bMV0gPT0gbnVsbCA/IG51bGwgOiBwbHVnaW5bMV0udGFncztcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0YWdzKSkge1xuICAgICAgICBzY2hlbWEucGx1Z2luKHBsdWdpblswXSwgcGx1Z2luWzFdKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHBsdWdpblRhZ3MgPSBwbHVnaW5UYWdzIHx8IG5ldyBTZXQoc2NoZW1hLm9wdGlvbnMucGx1Z2luVGFncyB8fCBbXSk7XG4gICAgICBpZiAoIXRhZ3MuZmluZCh0YWcgPT4gcGx1Z2luVGFncy5oYXModGFnKSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzY2hlbWEucGx1Z2luKHBsdWdpblswXSwgcGx1Z2luWzFdKTtcbiAgICB9XG4gIH1cblxuICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gIGRlbGV0ZSBvcHRpb25zLnNraXBUb3BMZXZlbDtcblxuICBpZiAob3B0aW9ucy5hcHBseVBsdWdpbnNUb0NoaWxkU2NoZW1hcyAhPT0gZmFsc2UpIHtcbiAgICBmb3IgKGNvbnN0IHBhdGggb2YgT2JqZWN0LmtleXMoc2NoZW1hLnBhdGhzKSkge1xuICAgICAgY29uc3QgdHlwZSA9IHNjaGVtYS5wYXRoc1twYXRoXTtcbiAgICAgIGlmICh0eXBlLnNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIGFwcGx5UGx1Z2lucyh0eXBlLnNjaGVtYSwgcGx1Z2lucywgb3B0aW9ucywgY2FjaGVLZXkpO1xuXG4gICAgICAgIC8vIFJlY29tcGlsZSBzY2hlbWEgYmVjYXVzZSBwbHVnaW5zIG1heSBoYXZlIGNoYW5nZWQgaXQsIHNlZSBnaC03NTcyXG4gICAgICAgIHR5cGUuY2FzdGVyLnByb3RvdHlwZS4kX19zZXRTY2hlbWEodHlwZS5zY2hlbWEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGRpc2NyaW1pbmF0b3JzID0gc2NoZW1hLmRpc2NyaW1pbmF0b3JzO1xuICBpZiAoZGlzY3JpbWluYXRvcnMgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGFwcGx5UGx1Z2luc1RvRGlzY3JpbWluYXRvcnMgPSBvcHRpb25zLmFwcGx5UGx1Z2luc1RvRGlzY3JpbWluYXRvcnM7XG5cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRpc2NyaW1pbmF0b3JzKTtcbiAgZm9yIChjb25zdCBkaXNjcmltaW5hdG9yS2V5IG9mIGtleXMpIHtcbiAgICBjb25zdCBkaXNjcmltaW5hdG9yU2NoZW1hID0gZGlzY3JpbWluYXRvcnNbZGlzY3JpbWluYXRvcktleV07XG5cbiAgICBhcHBseVBsdWdpbnMoZGlzY3JpbWluYXRvclNjaGVtYSwgcGx1Z2lucyxcbiAgICAgIHsgc2tpcFRvcExldmVsOiAhYXBwbHlQbHVnaW5zVG9EaXNjcmltaW5hdG9ycyB9LCBjYWNoZUtleSk7XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/schema/applyPlugins.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/schema/applyWriteConcern.js":
/*!********************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/schema/applyWriteConcern.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst get = __webpack_require__(/*! ../get */ \"../backend/node_modules/mongoose/lib/helpers/get.js\");\n\nmodule.exports = function applyWriteConcern(schema, options) {\n  if (options.writeConcern != null) {\n    return;\n  }\n  // Don't apply default write concern to operations in transactions,\n  // because setting write concern on an operation in a transaction is an error\n  // See: https://www.mongodb.com/docs/manual/reference/write-concern/\n  if (options && options.session && options.session.transaction) {\n    return;\n  }\n  const writeConcern = get(schema, 'options.writeConcern', {});\n  if (Object.keys(writeConcern).length != 0) {\n    options.writeConcern = {};\n    if (!('w' in options) && writeConcern.w != null) {\n      options.writeConcern.w = writeConcern.w;\n    }\n    if (!('j' in options) && writeConcern.j != null) {\n      options.writeConcern.j = writeConcern.j;\n    }\n    if (!('wtimeout' in options) && writeConcern.wtimeout != null) {\n      options.writeConcern.wtimeout = writeConcern.wtimeout;\n    }\n  }\n  else {\n    if (!('w' in options) && writeConcern.w != null) {\n      options.w = writeConcern.w;\n    }\n    if (!('j' in options) && writeConcern.j != null) {\n      options.j = writeConcern.j;\n    }\n    if (!('wtimeout' in options) && writeConcern.wtimeout != null) {\n      options.wtimeout = writeConcern.wtimeout;\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2FwcGx5V3JpdGVDb25jZXJuLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxtRUFBUTs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2FwcGx5V3JpdGVDb25jZXJuLmpzPzBmM2IiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBnZXQgPSByZXF1aXJlKCcuLi9nZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBhcHBseVdyaXRlQ29uY2VybihzY2hlbWEsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMud3JpdGVDb25jZXJuICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gRG9uJ3QgYXBwbHkgZGVmYXVsdCB3cml0ZSBjb25jZXJuIHRvIG9wZXJhdGlvbnMgaW4gdHJhbnNhY3Rpb25zLFxuICAvLyBiZWNhdXNlIHNldHRpbmcgd3JpdGUgY29uY2VybiBvbiBhbiBvcGVyYXRpb24gaW4gYSB0cmFuc2FjdGlvbiBpcyBhbiBlcnJvclxuICAvLyBTZWU6IGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuL1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNlc3Npb24gJiYgb3B0aW9ucy5zZXNzaW9uLnRyYW5zYWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHdyaXRlQ29uY2VybiA9IGdldChzY2hlbWEsICdvcHRpb25zLndyaXRlQ29uY2VybicsIHt9KTtcbiAgaWYgKE9iamVjdC5rZXlzKHdyaXRlQ29uY2VybikubGVuZ3RoICE9IDApIHtcbiAgICBvcHRpb25zLndyaXRlQ29uY2VybiA9IHt9O1xuICAgIGlmICghKCd3JyBpbiBvcHRpb25zKSAmJiB3cml0ZUNvbmNlcm4udyAhPSBudWxsKSB7XG4gICAgICBvcHRpb25zLndyaXRlQ29uY2Vybi53ID0gd3JpdGVDb25jZXJuLnc7XG4gICAgfVxuICAgIGlmICghKCdqJyBpbiBvcHRpb25zKSAmJiB3cml0ZUNvbmNlcm4uaiAhPSBudWxsKSB7XG4gICAgICBvcHRpb25zLndyaXRlQ29uY2Vybi5qID0gd3JpdGVDb25jZXJuLmo7XG4gICAgfVxuICAgIGlmICghKCd3dGltZW91dCcgaW4gb3B0aW9ucykgJiYgd3JpdGVDb25jZXJuLnd0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgIG9wdGlvbnMud3JpdGVDb25jZXJuLnd0aW1lb3V0ID0gd3JpdGVDb25jZXJuLnd0aW1lb3V0O1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBpZiAoISgndycgaW4gb3B0aW9ucykgJiYgd3JpdGVDb25jZXJuLncgIT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy53ID0gd3JpdGVDb25jZXJuLnc7XG4gICAgfVxuICAgIGlmICghKCdqJyBpbiBvcHRpb25zKSAmJiB3cml0ZUNvbmNlcm4uaiAhPSBudWxsKSB7XG4gICAgICBvcHRpb25zLmogPSB3cml0ZUNvbmNlcm4uajtcbiAgICB9XG4gICAgaWYgKCEoJ3d0aW1lb3V0JyBpbiBvcHRpb25zKSAmJiB3cml0ZUNvbmNlcm4ud3RpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy53dGltZW91dCA9IHdyaXRlQ29uY2Vybi53dGltZW91dDtcbiAgICB9XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/schema/applyWriteConcern.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js":
/*!***************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js ***!
  \***************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * For consistency's sake, we replace positional operator `$` and array filters\n * `$[]` and `$[foo]` with `0` when looking up schema paths.\n */\n\nmodule.exports = function cleanPositionalOperators(path) {\n  return path.\n    replace(/\\.\\$(\\[[^\\]]*\\])?(?=\\.)/g, '.0').\n    replace(/\\.\\$(\\[[^\\]]*\\])?$/g, '.0');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2NsZWFuUG9zaXRpb25hbE9wZXJhdG9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2NsZWFuUG9zaXRpb25hbE9wZXJhdG9ycy5qcz9kZDg0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBGb3IgY29uc2lzdGVuY3kncyBzYWtlLCB3ZSByZXBsYWNlIHBvc2l0aW9uYWwgb3BlcmF0b3IgYCRgIGFuZCBhcnJheSBmaWx0ZXJzXG4gKiBgJFtdYCBhbmQgYCRbZm9vXWAgd2l0aCBgMGAgd2hlbiBsb29raW5nIHVwIHNjaGVtYSBwYXRocy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNsZWFuUG9zaXRpb25hbE9wZXJhdG9ycyhwYXRoKSB7XG4gIHJldHVybiBwYXRoLlxuICAgIHJlcGxhY2UoL1xcLlxcJChcXFtbXlxcXV0qXFxdKT8oPz1cXC4pL2csICcuMCcpLlxuICAgIHJlcGxhY2UoL1xcLlxcJChcXFtbXlxcXV0qXFxdKT8kL2csICcuMCcpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/schema/getIndexes.js":
/*!*************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/schema/getIndexes.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst get = __webpack_require__(/*! ../get */ \"../backend/node_modules/mongoose/lib/helpers/get.js\");\nconst helperIsObject = __webpack_require__(/*! ../isObject */ \"../backend/node_modules/mongoose/lib/helpers/isObject.js\");\nconst decorateDiscriminatorIndexOptions = __webpack_require__(/*! ../indexes/decorateDiscriminatorIndexOptions */ \"../backend/node_modules/mongoose/lib/helpers/indexes/decorateDiscriminatorIndexOptions.js\");\n\n/**\n * Gather all indexes defined in the schema, including single nested,\n * document arrays, and embedded discriminators.\n * @param {Schema} schema\n * @api private\n */\n\nmodule.exports = function getIndexes(schema) {\n  let indexes = [];\n  const schemaStack = new WeakMap();\n  const indexTypes = schema.constructor.indexTypes;\n  const indexByName = new Map();\n\n  collectIndexes(schema);\n  return indexes;\n\n  function collectIndexes(schema, prefix, baseSchema) {\n    // Ignore infinitely nested schemas, if we've already seen this schema\n    // along this path there must be a cycle\n    if (schemaStack.has(schema)) {\n      return;\n    }\n    schemaStack.set(schema, true);\n\n    prefix = prefix || '';\n    const keys = Object.keys(schema.paths);\n\n    for (const key of keys) {\n      const path = schema.paths[key];\n      if (baseSchema != null && baseSchema.paths[key]) {\n        // If looking at an embedded discriminator schema, don't look at paths\n        // that the\n        continue;\n      }\n\n      if (path.$isMongooseDocumentArray || path.$isSingleNested) {\n        if (get(path, 'options.excludeIndexes') !== true &&\n            get(path, 'schemaOptions.excludeIndexes') !== true &&\n            get(path, 'schema.options.excludeIndexes') !== true) {\n          collectIndexes(path.schema, prefix + key + '.');\n        }\n\n        if (path.schema.discriminators != null) {\n          const discriminators = path.schema.discriminators;\n          const discriminatorKeys = Object.keys(discriminators);\n          for (const discriminatorKey of discriminatorKeys) {\n            collectIndexes(discriminators[discriminatorKey],\n              prefix + key + '.', path.schema);\n          }\n        }\n\n        // Retained to minimize risk of backwards breaking changes due to\n        // gh-6113\n        if (path.$isMongooseDocumentArray) {\n          continue;\n        }\n      }\n\n      const index = path._index || (path.caster && path.caster._index);\n\n      if (index !== false && index !== null && index !== undefined) {\n        const field = {};\n        const isObject = helperIsObject(index);\n        const options = isObject ? index : {};\n        const type = typeof index === 'string' ? index :\n          isObject ? index.type :\n            false;\n\n        if (type && indexTypes.indexOf(type) !== -1) {\n          field[prefix + key] = type;\n        } else if (options.text) {\n          field[prefix + key] = 'text';\n          delete options.text;\n        } else {\n          let isDescendingIndex = false;\n          if (index === 'descending' || index === 'desc') {\n            isDescendingIndex = true;\n          } else if (index === 'ascending' || index === 'asc') {\n            isDescendingIndex = false;\n          } else {\n            isDescendingIndex = Number(index) === -1;\n          }\n\n          field[prefix + key] = isDescendingIndex ? -1 : 1;\n        }\n\n        delete options.type;\n        if (!('background' in options)) {\n          options.background = true;\n        }\n        if (schema.options.autoIndex != null) {\n          options._autoIndex = schema.options.autoIndex;\n        }\n\n        const indexName = options && options.name;\n\n        if (typeof indexName === 'string') {\n          if (indexByName.has(indexName)) {\n            Object.assign(indexByName.get(indexName), field);\n          } else {\n            indexes.push([field, options]);\n            indexByName.set(indexName, field);\n          }\n        } else {\n          indexes.push([field, options]);\n          indexByName.set(indexName, field);\n        }\n      }\n    }\n\n    schemaStack.delete(schema);\n\n    if (prefix) {\n      fixSubIndexPaths(schema, prefix);\n    } else {\n      schema._indexes.forEach(function(index) {\n        const options = index[1];\n        if (!('background' in options)) {\n          options.background = true;\n        }\n        decorateDiscriminatorIndexOptions(schema, options);\n      });\n      indexes = indexes.concat(schema._indexes);\n    }\n  }\n\n  /**\n   * Checks for indexes added to subdocs using Schema.index().\n   * These indexes need their paths prefixed properly.\n   *\n   * schema._indexes = [ [indexObj, options], [indexObj, options] ..]\n   * @param {Schema} schema\n   * @param {String} prefix\n   * @api private\n   */\n\n  function fixSubIndexPaths(schema, prefix) {\n    const subindexes = schema._indexes;\n    const len = subindexes.length;\n    for (let i = 0; i < len; ++i) {\n      const indexObj = subindexes[i][0];\n      const indexOptions = subindexes[i][1];\n      const keys = Object.keys(indexObj);\n      const klen = keys.length;\n      const newindex = {};\n\n      // use forward iteration, order matters\n      for (let j = 0; j < klen; ++j) {\n        const key = keys[j];\n        newindex[prefix + key] = indexObj[key];\n      }\n\n      const newIndexOptions = Object.assign({}, indexOptions);\n      if (indexOptions != null && indexOptions.partialFilterExpression != null) {\n        newIndexOptions.partialFilterExpression = {};\n        const partialFilterExpression = indexOptions.partialFilterExpression;\n        for (const key of Object.keys(partialFilterExpression)) {\n          newIndexOptions.partialFilterExpression[prefix + key] =\n            partialFilterExpression[key];\n        }\n      }\n\n      indexes.push([newindex, newIndexOptions]);\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2dldEluZGV4ZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLG1FQUFRO0FBQzVCLHVCQUF1QixtQkFBTyxDQUFDLDZFQUFhO0FBQzVDLDBDQUEwQyxtQkFBTyxDQUFDLCtJQUE4Qzs7QUFFaEc7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2dldEluZGV4ZXMuanM/ODczOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGdldCA9IHJlcXVpcmUoJy4uL2dldCcpO1xuY29uc3QgaGVscGVySXNPYmplY3QgPSByZXF1aXJlKCcuLi9pc09iamVjdCcpO1xuY29uc3QgZGVjb3JhdGVEaXNjcmltaW5hdG9ySW5kZXhPcHRpb25zID0gcmVxdWlyZSgnLi4vaW5kZXhlcy9kZWNvcmF0ZURpc2NyaW1pbmF0b3JJbmRleE9wdGlvbnMnKTtcblxuLyoqXG4gKiBHYXRoZXIgYWxsIGluZGV4ZXMgZGVmaW5lZCBpbiB0aGUgc2NoZW1hLCBpbmNsdWRpbmcgc2luZ2xlIG5lc3RlZCxcbiAqIGRvY3VtZW50IGFycmF5cywgYW5kIGVtYmVkZGVkIGRpc2NyaW1pbmF0b3JzLlxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRJbmRleGVzKHNjaGVtYSkge1xuICBsZXQgaW5kZXhlcyA9IFtdO1xuICBjb25zdCBzY2hlbWFTdGFjayA9IG5ldyBXZWFrTWFwKCk7XG4gIGNvbnN0IGluZGV4VHlwZXMgPSBzY2hlbWEuY29uc3RydWN0b3IuaW5kZXhUeXBlcztcbiAgY29uc3QgaW5kZXhCeU5hbWUgPSBuZXcgTWFwKCk7XG5cbiAgY29sbGVjdEluZGV4ZXMoc2NoZW1hKTtcbiAgcmV0dXJuIGluZGV4ZXM7XG5cbiAgZnVuY3Rpb24gY29sbGVjdEluZGV4ZXMoc2NoZW1hLCBwcmVmaXgsIGJhc2VTY2hlbWEpIHtcbiAgICAvLyBJZ25vcmUgaW5maW5pdGVseSBuZXN0ZWQgc2NoZW1hcywgaWYgd2UndmUgYWxyZWFkeSBzZWVuIHRoaXMgc2NoZW1hXG4gICAgLy8gYWxvbmcgdGhpcyBwYXRoIHRoZXJlIG11c3QgYmUgYSBjeWNsZVxuICAgIGlmIChzY2hlbWFTdGFjay5oYXMoc2NoZW1hKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzY2hlbWFTdGFjay5zZXQoc2NoZW1hLCB0cnVlKTtcblxuICAgIHByZWZpeCA9IHByZWZpeCB8fCAnJztcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc2NoZW1hLnBhdGhzKTtcblxuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIGNvbnN0IHBhdGggPSBzY2hlbWEucGF0aHNba2V5XTtcbiAgICAgIGlmIChiYXNlU2NoZW1hICE9IG51bGwgJiYgYmFzZVNjaGVtYS5wYXRoc1trZXldKSB7XG4gICAgICAgIC8vIElmIGxvb2tpbmcgYXQgYW4gZW1iZWRkZWQgZGlzY3JpbWluYXRvciBzY2hlbWEsIGRvbid0IGxvb2sgYXQgcGF0aHNcbiAgICAgICAgLy8gdGhhdCB0aGVcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXRoLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSB8fCBwYXRoLiRpc1NpbmdsZU5lc3RlZCkge1xuICAgICAgICBpZiAoZ2V0KHBhdGgsICdvcHRpb25zLmV4Y2x1ZGVJbmRleGVzJykgIT09IHRydWUgJiZcbiAgICAgICAgICAgIGdldChwYXRoLCAnc2NoZW1hT3B0aW9ucy5leGNsdWRlSW5kZXhlcycpICE9PSB0cnVlICYmXG4gICAgICAgICAgICBnZXQocGF0aCwgJ3NjaGVtYS5vcHRpb25zLmV4Y2x1ZGVJbmRleGVzJykgIT09IHRydWUpIHtcbiAgICAgICAgICBjb2xsZWN0SW5kZXhlcyhwYXRoLnNjaGVtYSwgcHJlZml4ICsga2V5ICsgJy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXRoLnNjaGVtYS5kaXNjcmltaW5hdG9ycyAhPSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvcnMgPSBwYXRoLnNjaGVtYS5kaXNjcmltaW5hdG9ycztcbiAgICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yS2V5cyA9IE9iamVjdC5rZXlzKGRpc2NyaW1pbmF0b3JzKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGRpc2NyaW1pbmF0b3JLZXkgb2YgZGlzY3JpbWluYXRvcktleXMpIHtcbiAgICAgICAgICAgIGNvbGxlY3RJbmRleGVzKGRpc2NyaW1pbmF0b3JzW2Rpc2NyaW1pbmF0b3JLZXldLFxuICAgICAgICAgICAgICBwcmVmaXggKyBrZXkgKyAnLicsIHBhdGguc2NoZW1hKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXRhaW5lZCB0byBtaW5pbWl6ZSByaXNrIG9mIGJhY2t3YXJkcyBicmVha2luZyBjaGFuZ2VzIGR1ZSB0b1xuICAgICAgICAvLyBnaC02MTEzXG4gICAgICAgIGlmIChwYXRoLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGluZGV4ID0gcGF0aC5faW5kZXggfHwgKHBhdGguY2FzdGVyICYmIHBhdGguY2FzdGVyLl9pbmRleCk7XG5cbiAgICAgIGlmIChpbmRleCAhPT0gZmFsc2UgJiYgaW5kZXggIT09IG51bGwgJiYgaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBmaWVsZCA9IHt9O1xuICAgICAgICBjb25zdCBpc09iamVjdCA9IGhlbHBlcklzT2JqZWN0KGluZGV4KTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGlzT2JqZWN0ID8gaW5kZXggOiB7fTtcbiAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiBpbmRleCA9PT0gJ3N0cmluZycgPyBpbmRleCA6XG4gICAgICAgICAgaXNPYmplY3QgPyBpbmRleC50eXBlIDpcbiAgICAgICAgICAgIGZhbHNlO1xuXG4gICAgICAgIGlmICh0eXBlICYmIGluZGV4VHlwZXMuaW5kZXhPZih0eXBlKSAhPT0gLTEpIHtcbiAgICAgICAgICBmaWVsZFtwcmVmaXggKyBrZXldID0gdHlwZTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnRleHQpIHtcbiAgICAgICAgICBmaWVsZFtwcmVmaXggKyBrZXldID0gJ3RleHQnO1xuICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLnRleHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IGlzRGVzY2VuZGluZ0luZGV4ID0gZmFsc2U7XG4gICAgICAgICAgaWYgKGluZGV4ID09PSAnZGVzY2VuZGluZycgfHwgaW5kZXggPT09ICdkZXNjJykge1xuICAgICAgICAgICAgaXNEZXNjZW5kaW5nSW5kZXggPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09ICdhc2NlbmRpbmcnIHx8IGluZGV4ID09PSAnYXNjJykge1xuICAgICAgICAgICAgaXNEZXNjZW5kaW5nSW5kZXggPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXNEZXNjZW5kaW5nSW5kZXggPSBOdW1iZXIoaW5kZXgpID09PSAtMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmaWVsZFtwcmVmaXggKyBrZXldID0gaXNEZXNjZW5kaW5nSW5kZXggPyAtMSA6IDE7XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgb3B0aW9ucy50eXBlO1xuICAgICAgICBpZiAoISgnYmFja2dyb3VuZCcgaW4gb3B0aW9ucykpIHtcbiAgICAgICAgICBvcHRpb25zLmJhY2tncm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEub3B0aW9ucy5hdXRvSW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgIG9wdGlvbnMuX2F1dG9JbmRleCA9IHNjaGVtYS5vcHRpb25zLmF1dG9JbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGluZGV4TmFtZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5uYW1lO1xuXG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXhOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmIChpbmRleEJ5TmFtZS5oYXMoaW5kZXhOYW1lKSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihpbmRleEJ5TmFtZS5nZXQoaW5kZXhOYW1lKSwgZmllbGQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmRleGVzLnB1c2goW2ZpZWxkLCBvcHRpb25zXSk7XG4gICAgICAgICAgICBpbmRleEJ5TmFtZS5zZXQoaW5kZXhOYW1lLCBmaWVsZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZGV4ZXMucHVzaChbZmllbGQsIG9wdGlvbnNdKTtcbiAgICAgICAgICBpbmRleEJ5TmFtZS5zZXQoaW5kZXhOYW1lLCBmaWVsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzY2hlbWFTdGFjay5kZWxldGUoc2NoZW1hKTtcblxuICAgIGlmIChwcmVmaXgpIHtcbiAgICAgIGZpeFN1YkluZGV4UGF0aHMoc2NoZW1hLCBwcmVmaXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlbWEuX2luZGV4ZXMuZm9yRWFjaChmdW5jdGlvbihpbmRleCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gaW5kZXhbMV07XG4gICAgICAgIGlmICghKCdiYWNrZ3JvdW5kJyBpbiBvcHRpb25zKSkge1xuICAgICAgICAgIG9wdGlvbnMuYmFja2dyb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZGVjb3JhdGVEaXNjcmltaW5hdG9ySW5kZXhPcHRpb25zKHNjaGVtYSwgb3B0aW9ucyk7XG4gICAgICB9KTtcbiAgICAgIGluZGV4ZXMgPSBpbmRleGVzLmNvbmNhdChzY2hlbWEuX2luZGV4ZXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgZm9yIGluZGV4ZXMgYWRkZWQgdG8gc3ViZG9jcyB1c2luZyBTY2hlbWEuaW5kZXgoKS5cbiAgICogVGhlc2UgaW5kZXhlcyBuZWVkIHRoZWlyIHBhdGhzIHByZWZpeGVkIHByb3Blcmx5LlxuICAgKlxuICAgKiBzY2hlbWEuX2luZGV4ZXMgPSBbIFtpbmRleE9iaiwgb3B0aW9uc10sIFtpbmRleE9iaiwgb3B0aW9uc10gLi5dXG4gICAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeFxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgZnVuY3Rpb24gZml4U3ViSW5kZXhQYXRocyhzY2hlbWEsIHByZWZpeCkge1xuICAgIGNvbnN0IHN1YmluZGV4ZXMgPSBzY2hlbWEuX2luZGV4ZXM7XG4gICAgY29uc3QgbGVuID0gc3ViaW5kZXhlcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgY29uc3QgaW5kZXhPYmogPSBzdWJpbmRleGVzW2ldWzBdO1xuICAgICAgY29uc3QgaW5kZXhPcHRpb25zID0gc3ViaW5kZXhlc1tpXVsxXTtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhpbmRleE9iaik7XG4gICAgICBjb25zdCBrbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgICBjb25zdCBuZXdpbmRleCA9IHt9O1xuXG4gICAgICAvLyB1c2UgZm9yd2FyZCBpdGVyYXRpb24sIG9yZGVyIG1hdHRlcnNcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwga2xlbjsgKytqKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbal07XG4gICAgICAgIG5ld2luZGV4W3ByZWZpeCArIGtleV0gPSBpbmRleE9ialtrZXldO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXdJbmRleE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBpbmRleE9wdGlvbnMpO1xuICAgICAgaWYgKGluZGV4T3B0aW9ucyAhPSBudWxsICYmIGluZGV4T3B0aW9ucy5wYXJ0aWFsRmlsdGVyRXhwcmVzc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIG5ld0luZGV4T3B0aW9ucy5wYXJ0aWFsRmlsdGVyRXhwcmVzc2lvbiA9IHt9O1xuICAgICAgICBjb25zdCBwYXJ0aWFsRmlsdGVyRXhwcmVzc2lvbiA9IGluZGV4T3B0aW9ucy5wYXJ0aWFsRmlsdGVyRXhwcmVzc2lvbjtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocGFydGlhbEZpbHRlckV4cHJlc3Npb24pKSB7XG4gICAgICAgICAgbmV3SW5kZXhPcHRpb25zLnBhcnRpYWxGaWx0ZXJFeHByZXNzaW9uW3ByZWZpeCArIGtleV0gPVxuICAgICAgICAgICAgcGFydGlhbEZpbHRlckV4cHJlc3Npb25ba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpbmRleGVzLnB1c2goW25ld2luZGV4LCBuZXdJbmRleE9wdGlvbnNdKTtcbiAgICB9XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/schema/getIndexes.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/schema/getKeysInSchemaOrder.js":
/*!***********************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/schema/getKeysInSchemaOrder.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst get = __webpack_require__(/*! ../get */ \"../backend/node_modules/mongoose/lib/helpers/get.js\");\n\nmodule.exports = function getKeysInSchemaOrder(schema, val, path) {\n  const schemaKeys = path != null ? Object.keys(get(schema.tree, path, {})) : Object.keys(schema.tree);\n  const valKeys = new Set(Object.keys(val));\n\n  let keys;\n  if (valKeys.size > 1) {\n    keys = new Set();\n    for (const key of schemaKeys) {\n      if (valKeys.has(key)) {\n        keys.add(key);\n      }\n    }\n    for (const key of valKeys) {\n      if (!keys.has(key)) {\n        keys.add(key);\n      }\n    }\n    keys = Array.from(keys);\n  } else {\n    keys = Array.from(valKeys);\n  }\n\n  return keys;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2dldEtleXNJblNjaGVtYU9yZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxtRUFBUTs7QUFFNUI7QUFDQSx5RUFBeUU7QUFDekU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvZ2V0S2V5c0luU2NoZW1hT3JkZXIuanM/OTU3YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGdldCA9IHJlcXVpcmUoJy4uL2dldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldEtleXNJblNjaGVtYU9yZGVyKHNjaGVtYSwgdmFsLCBwYXRoKSB7XG4gIGNvbnN0IHNjaGVtYUtleXMgPSBwYXRoICE9IG51bGwgPyBPYmplY3Qua2V5cyhnZXQoc2NoZW1hLnRyZWUsIHBhdGgsIHt9KSkgOiBPYmplY3Qua2V5cyhzY2hlbWEudHJlZSk7XG4gIGNvbnN0IHZhbEtleXMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHZhbCkpO1xuXG4gIGxldCBrZXlzO1xuICBpZiAodmFsS2V5cy5zaXplID4gMSkge1xuICAgIGtleXMgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBrZXkgb2Ygc2NoZW1hS2V5cykge1xuICAgICAgaWYgKHZhbEtleXMuaGFzKGtleSkpIHtcbiAgICAgICAga2V5cy5hZGQoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgb2YgdmFsS2V5cykge1xuICAgICAgaWYgKCFrZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgIGtleXMuYWRkKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGtleXMgPSBBcnJheS5mcm9tKGtleXMpO1xuICB9IGVsc2Uge1xuICAgIGtleXMgPSBBcnJheS5mcm9tKHZhbEtleXMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/schema/getKeysInSchemaOrder.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/schema/getPath.js":
/*!**********************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/schema/getPath.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst numberRE = /^\\d+$/;\n\n/**\n * Behaves like `Schema#path()`, except for it also digs into arrays without\n * needing to put `.0.`, so `getPath(schema, 'docArr.elProp')` works.\n * @api private\n */\n\nmodule.exports = function getPath(schema, path) {\n  let schematype = schema.path(path);\n  if (schematype != null) {\n    return schematype;\n  }\n  const pieces = path.split('.');\n  let cur = '';\n  let isArray = false;\n\n  for (const piece of pieces) {\n    if (isArray && numberRE.test(piece)) {\n      continue;\n    }\n    cur = cur.length === 0 ? piece : cur + '.' + piece;\n\n    schematype = schema.path(cur);\n    if (schematype != null && schematype.schema) {\n      schema = schematype.schema;\n      cur = '';\n      if (!isArray && schematype.$isMongooseDocumentArray) {\n        isArray = true;\n      }\n    }\n  }\n\n  return schematype;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2dldFBhdGguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zY2hlbWEvZ2V0UGF0aC5qcz8xYTVkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgbnVtYmVyUkUgPSAvXlxcZCskLztcblxuLyoqXG4gKiBCZWhhdmVzIGxpa2UgYFNjaGVtYSNwYXRoKClgLCBleGNlcHQgZm9yIGl0IGFsc28gZGlncyBpbnRvIGFycmF5cyB3aXRob3V0XG4gKiBuZWVkaW5nIHRvIHB1dCBgLjAuYCwgc28gYGdldFBhdGgoc2NoZW1hLCAnZG9jQXJyLmVsUHJvcCcpYCB3b3Jrcy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UGF0aChzY2hlbWEsIHBhdGgpIHtcbiAgbGV0IHNjaGVtYXR5cGUgPSBzY2hlbWEucGF0aChwYXRoKTtcbiAgaWYgKHNjaGVtYXR5cGUgIT0gbnVsbCkge1xuICAgIHJldHVybiBzY2hlbWF0eXBlO1xuICB9XG4gIGNvbnN0IHBpZWNlcyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgbGV0IGN1ciA9ICcnO1xuICBsZXQgaXNBcnJheSA9IGZhbHNlO1xuXG4gIGZvciAoY29uc3QgcGllY2Ugb2YgcGllY2VzKSB7XG4gICAgaWYgKGlzQXJyYXkgJiYgbnVtYmVyUkUudGVzdChwaWVjZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjdXIgPSBjdXIubGVuZ3RoID09PSAwID8gcGllY2UgOiBjdXIgKyAnLicgKyBwaWVjZTtcblxuICAgIHNjaGVtYXR5cGUgPSBzY2hlbWEucGF0aChjdXIpO1xuICAgIGlmIChzY2hlbWF0eXBlICE9IG51bGwgJiYgc2NoZW1hdHlwZS5zY2hlbWEpIHtcbiAgICAgIHNjaGVtYSA9IHNjaGVtYXR5cGUuc2NoZW1hO1xuICAgICAgY3VyID0gJyc7XG4gICAgICBpZiAoIWlzQXJyYXkgJiYgc2NoZW1hdHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkpIHtcbiAgICAgICAgaXNBcnJheSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNjaGVtYXR5cGU7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/schema/getPath.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/schema/getSubdocumentStrictValue.js":
/*!****************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/schema/getSubdocumentStrictValue.js ***!
  \****************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Find the `strict` mode setting for the deepest subdocument along a given path\n * to ensure we have the correct default value for `strict`. When setting values\n * underneath a subdocument, we should use the subdocument's `strict` setting by\n * default, not the top-level document's.\n *\n * @param {Schema} schema\n * @param {String[]} parts\n * @returns {boolean | 'throw' | undefined}\n */\n\nmodule.exports = function getSubdocumentStrictValue(schema, parts) {\n  if (parts.length === 1) {\n    return undefined;\n  }\n  let cur = parts[0];\n  let strict = undefined;\n  for (let i = 0; i < parts.length - 1; ++i) {\n    const curSchemaType = schema.path(cur);\n    if (curSchemaType && curSchemaType.schema) {\n      strict = curSchemaType.schema.options.strict;\n      schema = curSchemaType.schema;\n      cur = curSchemaType.$isMongooseDocumentArray && !isNaN(parts[i + 1]) ? '' : parts[i + 1];\n    } else {\n      cur += cur.length ? ('.' + parts[i + 1]) : parts[i + 1];\n    }\n  }\n\n  return strict;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2dldFN1YmRvY3VtZW50U3RyaWN0VmFsdWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2dldFN1YmRvY3VtZW50U3RyaWN0VmFsdWUuanM/NjE3YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRmluZCB0aGUgYHN0cmljdGAgbW9kZSBzZXR0aW5nIGZvciB0aGUgZGVlcGVzdCBzdWJkb2N1bWVudCBhbG9uZyBhIGdpdmVuIHBhdGhcbiAqIHRvIGVuc3VyZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IGRlZmF1bHQgdmFsdWUgZm9yIGBzdHJpY3RgLiBXaGVuIHNldHRpbmcgdmFsdWVzXG4gKiB1bmRlcm5lYXRoIGEgc3ViZG9jdW1lbnQsIHdlIHNob3VsZCB1c2UgdGhlIHN1YmRvY3VtZW50J3MgYHN0cmljdGAgc2V0dGluZyBieVxuICogZGVmYXVsdCwgbm90IHRoZSB0b3AtbGV2ZWwgZG9jdW1lbnQncy5cbiAqXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAcGFyYW0ge1N0cmluZ1tdfSBwYXJ0c1xuICogQHJldHVybnMge2Jvb2xlYW4gfCAndGhyb3cnIHwgdW5kZWZpbmVkfVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0U3ViZG9jdW1lbnRTdHJpY3RWYWx1ZShzY2hlbWEsIHBhcnRzKSB7XG4gIGlmIChwYXJ0cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGxldCBjdXIgPSBwYXJ0c1swXTtcbiAgbGV0IHN0cmljdCA9IHVuZGVmaW5lZDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICBjb25zdCBjdXJTY2hlbWFUeXBlID0gc2NoZW1hLnBhdGgoY3VyKTtcbiAgICBpZiAoY3VyU2NoZW1hVHlwZSAmJiBjdXJTY2hlbWFUeXBlLnNjaGVtYSkge1xuICAgICAgc3RyaWN0ID0gY3VyU2NoZW1hVHlwZS5zY2hlbWEub3B0aW9ucy5zdHJpY3Q7XG4gICAgICBzY2hlbWEgPSBjdXJTY2hlbWFUeXBlLnNjaGVtYTtcbiAgICAgIGN1ciA9IGN1clNjaGVtYVR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5ICYmICFpc05hTihwYXJ0c1tpICsgMV0pID8gJycgOiBwYXJ0c1tpICsgMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1ciArPSBjdXIubGVuZ3RoID8gKCcuJyArIHBhcnRzW2kgKyAxXSkgOiBwYXJ0c1tpICsgMV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0cmljdDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/schema/getSubdocumentStrictValue.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/schema/handleIdOption.js":
/*!*****************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/schema/handleIdOption.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst addAutoId = __webpack_require__(/*! ./addAutoId */ \"../backend/node_modules/mongoose/lib/helpers/schema/addAutoId.js\");\n\nmodule.exports = function handleIdOption(schema, options) {\n  if (options == null || options._id == null) {\n    return schema;\n  }\n\n  schema = schema.clone();\n  if (!options._id) {\n    schema.remove('_id');\n    schema.options._id = false;\n  } else if (!schema.paths['_id']) {\n    addAutoId(schema);\n    schema.options._id = true;\n  }\n\n  return schema;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2hhbmRsZUlkT3B0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGtCQUFrQixtQkFBTyxDQUFDLHFGQUFhOztBQUV2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3NjaGVtYS9oYW5kbGVJZE9wdGlvbi5qcz9mYzQ0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgYWRkQXV0b0lkID0gcmVxdWlyZSgnLi9hZGRBdXRvSWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYW5kbGVJZE9wdGlvbihzY2hlbWEsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT0gbnVsbCB8fCBvcHRpb25zLl9pZCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHNjaGVtYTtcbiAgfVxuXG4gIHNjaGVtYSA9IHNjaGVtYS5jbG9uZSgpO1xuICBpZiAoIW9wdGlvbnMuX2lkKSB7XG4gICAgc2NoZW1hLnJlbW92ZSgnX2lkJyk7XG4gICAgc2NoZW1hLm9wdGlvbnMuX2lkID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAoIXNjaGVtYS5wYXRoc1snX2lkJ10pIHtcbiAgICBhZGRBdXRvSWQoc2NoZW1hKTtcbiAgICBzY2hlbWEub3B0aW9ucy5faWQgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHNjaGVtYTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/schema/handleIdOption.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/schema/handleTimestampOption.js":
/*!************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/schema/handleTimestampOption.js ***!
  \************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = handleTimestampOption;\n\n/*!\n * ignore\n */\n\nfunction handleTimestampOption(arg, prop) {\n  if (arg == null) {\n    return null;\n  }\n\n  if (typeof arg === 'boolean') {\n    return prop;\n  }\n  if (typeof arg[prop] === 'boolean') {\n    return arg[prop] ? prop : null;\n  }\n  if (!(prop in arg)) {\n    return prop;\n  }\n  return arg[prop];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2hhbmRsZVRpbWVzdGFtcE9wdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3NjaGVtYS9oYW5kbGVUaW1lc3RhbXBPcHRpb24uanM/YjI4YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gaGFuZGxlVGltZXN0YW1wT3B0aW9uO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGhhbmRsZVRpbWVzdGFtcE9wdGlvbihhcmcsIHByb3ApIHtcbiAgaWYgKGFyZyA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIHByb3A7XG4gIH1cbiAgaWYgKHR5cGVvZiBhcmdbcHJvcF0gPT09ICdib29sZWFuJykge1xuICAgIHJldHVybiBhcmdbcHJvcF0gPyBwcm9wIDogbnVsbDtcbiAgfVxuICBpZiAoIShwcm9wIGluIGFyZykpIHtcbiAgICByZXR1cm4gcHJvcDtcbiAgfVxuICByZXR1cm4gYXJnW3Byb3BdO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/schema/handleTimestampOption.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/schema/idGetter.js":
/*!***********************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/schema/idGetter.js ***!
  \***********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = function addIdGetter(schema) {\n  // ensure the documents receive an id getter unless disabled\n  const autoIdGetter = !schema.paths['id'] &&\n    schema.paths['_id'] &&\n    schema.options.id;\n  if (!autoIdGetter) {\n    return schema;\n  }\n  if (schema.aliases && schema.aliases.id) {\n    return schema;\n  }\n  schema.virtual('id').get(idGetter);\n\n  return schema;\n};\n\n/**\n * Returns this documents _id cast to a string.\n * @api private\n */\n\nfunction idGetter() {\n  if (this._id != null) {\n    return String(this._id);\n  }\n\n  return null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2lkR2V0dGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL2lkR2V0dGVyLmpzPzQwOTAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYWRkSWRHZXR0ZXIoc2NoZW1hKSB7XG4gIC8vIGVuc3VyZSB0aGUgZG9jdW1lbnRzIHJlY2VpdmUgYW4gaWQgZ2V0dGVyIHVubGVzcyBkaXNhYmxlZFxuICBjb25zdCBhdXRvSWRHZXR0ZXIgPSAhc2NoZW1hLnBhdGhzWydpZCddICYmXG4gICAgc2NoZW1hLnBhdGhzWydfaWQnXSAmJlxuICAgIHNjaGVtYS5vcHRpb25zLmlkO1xuICBpZiAoIWF1dG9JZEdldHRlcikge1xuICAgIHJldHVybiBzY2hlbWE7XG4gIH1cbiAgaWYgKHNjaGVtYS5hbGlhc2VzICYmIHNjaGVtYS5hbGlhc2VzLmlkKSB7XG4gICAgcmV0dXJuIHNjaGVtYTtcbiAgfVxuICBzY2hlbWEudmlydHVhbCgnaWQnKS5nZXQoaWRHZXR0ZXIpO1xuXG4gIHJldHVybiBzY2hlbWE7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBkb2N1bWVudHMgX2lkIGNhc3QgdG8gYSBzdHJpbmcuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpZEdldHRlcigpIHtcbiAgaWYgKHRoaXMuX2lkICE9IG51bGwpIHtcbiAgICByZXR1cm4gU3RyaW5nKHRoaXMuX2lkKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/schema/idGetter.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/schema/merge.js":
/*!********************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/schema/merge.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function merge(s1, s2, skipConflictingPaths) {\n  const paths = Object.keys(s2.tree);\n  const pathsToAdd = {};\n  for (const key of paths) {\n    if (skipConflictingPaths && (s1.paths[key] || s1.nested[key] || s1.singleNestedPaths[key])) {\n      continue;\n    }\n    pathsToAdd[key] = s2.tree[key];\n  }\n  s1.options._isMerging = true;\n  s1.add(pathsToAdd, null);\n  delete s1.options._isMerging;\n\n  s1.callQueue = s1.callQueue.concat(s2.callQueue);\n  s1.method(s2.methods);\n  s1.static(s2.statics);\n\n  for (const [option, value] of Object.entries(s2._userProvidedOptions)) {\n    if (!(option in s1._userProvidedOptions)) {\n      s1.set(option, value);\n    }\n  }\n\n  for (const query in s2.query) {\n    s1.query[query] = s2.query[query];\n  }\n\n  for (const virtual in s2.virtuals) {\n    s1.virtuals[virtual] = s2.virtuals[virtual].clone();\n  }\n\n  s1._indexes = s1._indexes.concat(s2._indexes || []);\n  s1.s.hooks.merge(s2.s.hooks, false);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hL21lcmdlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3NjaGVtYS9tZXJnZS5qcz83Y2E3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtZXJnZShzMSwgczIsIHNraXBDb25mbGljdGluZ1BhdGhzKSB7XG4gIGNvbnN0IHBhdGhzID0gT2JqZWN0LmtleXMoczIudHJlZSk7XG4gIGNvbnN0IHBhdGhzVG9BZGQgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgb2YgcGF0aHMpIHtcbiAgICBpZiAoc2tpcENvbmZsaWN0aW5nUGF0aHMgJiYgKHMxLnBhdGhzW2tleV0gfHwgczEubmVzdGVkW2tleV0gfHwgczEuc2luZ2xlTmVzdGVkUGF0aHNba2V5XSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBwYXRoc1RvQWRkW2tleV0gPSBzMi50cmVlW2tleV07XG4gIH1cbiAgczEub3B0aW9ucy5faXNNZXJnaW5nID0gdHJ1ZTtcbiAgczEuYWRkKHBhdGhzVG9BZGQsIG51bGwpO1xuICBkZWxldGUgczEub3B0aW9ucy5faXNNZXJnaW5nO1xuXG4gIHMxLmNhbGxRdWV1ZSA9IHMxLmNhbGxRdWV1ZS5jb25jYXQoczIuY2FsbFF1ZXVlKTtcbiAgczEubWV0aG9kKHMyLm1ldGhvZHMpO1xuICBzMS5zdGF0aWMoczIuc3RhdGljcyk7XG5cbiAgZm9yIChjb25zdCBbb3B0aW9uLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoczIuX3VzZXJQcm92aWRlZE9wdGlvbnMpKSB7XG4gICAgaWYgKCEob3B0aW9uIGluIHMxLl91c2VyUHJvdmlkZWRPcHRpb25zKSkge1xuICAgICAgczEuc2V0KG9wdGlvbiwgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoY29uc3QgcXVlcnkgaW4gczIucXVlcnkpIHtcbiAgICBzMS5xdWVyeVtxdWVyeV0gPSBzMi5xdWVyeVtxdWVyeV07XG4gIH1cblxuICBmb3IgKGNvbnN0IHZpcnR1YWwgaW4gczIudmlydHVhbHMpIHtcbiAgICBzMS52aXJ0dWFsc1t2aXJ0dWFsXSA9IHMyLnZpcnR1YWxzW3ZpcnR1YWxdLmNsb25lKCk7XG4gIH1cblxuICBzMS5faW5kZXhlcyA9IHMxLl9pbmRleGVzLmNvbmNhdChzMi5faW5kZXhlcyB8fCBbXSk7XG4gIHMxLnMuaG9va3MubWVyZ2UoczIucy5ob29rcywgZmFsc2UpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/schema/merge.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/schematype/handleImmutable.js":
/*!**********************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/schematype/handleImmutable.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst StrictModeError = __webpack_require__(/*! ../../error/strict */ \"../backend/node_modules/mongoose/lib/error/strict.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = function(schematype) {\n  if (schematype.$immutable) {\n    schematype.$immutableSetter = createImmutableSetter(schematype.path,\n      schematype.options.immutable);\n    schematype.set(schematype.$immutableSetter);\n  } else if (schematype.$immutableSetter) {\n    schematype.setters = schematype.setters.\n      filter(fn => fn !== schematype.$immutableSetter);\n    delete schematype.$immutableSetter;\n  }\n};\n\nfunction createImmutableSetter(path, immutable) {\n  return function immutableSetter(v, _priorVal, _doc, options) {\n    if (this == null || this.$__ == null) {\n      return v;\n    }\n    if (this.isNew) {\n      return v;\n    }\n    if (options && options.overwriteImmutable) {\n      return v;\n    }\n\n    const _immutable = typeof immutable === 'function' ?\n      immutable.call(this, this) :\n      immutable;\n    if (!_immutable) {\n      return v;\n    }\n\n    const _value = this.$__.priorDoc != null ?\n      this.$__.priorDoc.$__getValue(path) :\n      this.$__getValue(path);\n    if (this.$__.strictMode === 'throw' && v !== _value) {\n      throw new StrictModeError(path, 'Path `' + path + '` is immutable ' +\n        'and strict mode is set to throw.', true);\n    }\n\n    return _value;\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2NoZW1hdHlwZS9oYW5kbGVJbW11dGFibGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsd0JBQXdCLG1CQUFPLENBQUMsZ0ZBQW9COztBQUVwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3NjaGVtYXR5cGUvaGFuZGxlSW1tdXRhYmxlLmpzPzYyODUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBTdHJpY3RNb2RlRXJyb3IgPSByZXF1aXJlKCcuLi8uLi9lcnJvci9zdHJpY3QnKTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNjaGVtYXR5cGUpIHtcbiAgaWYgKHNjaGVtYXR5cGUuJGltbXV0YWJsZSkge1xuICAgIHNjaGVtYXR5cGUuJGltbXV0YWJsZVNldHRlciA9IGNyZWF0ZUltbXV0YWJsZVNldHRlcihzY2hlbWF0eXBlLnBhdGgsXG4gICAgICBzY2hlbWF0eXBlLm9wdGlvbnMuaW1tdXRhYmxlKTtcbiAgICBzY2hlbWF0eXBlLnNldChzY2hlbWF0eXBlLiRpbW11dGFibGVTZXR0ZXIpO1xuICB9IGVsc2UgaWYgKHNjaGVtYXR5cGUuJGltbXV0YWJsZVNldHRlcikge1xuICAgIHNjaGVtYXR5cGUuc2V0dGVycyA9IHNjaGVtYXR5cGUuc2V0dGVycy5cbiAgICAgIGZpbHRlcihmbiA9PiBmbiAhPT0gc2NoZW1hdHlwZS4kaW1tdXRhYmxlU2V0dGVyKTtcbiAgICBkZWxldGUgc2NoZW1hdHlwZS4kaW1tdXRhYmxlU2V0dGVyO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVJbW11dGFibGVTZXR0ZXIocGF0aCwgaW1tdXRhYmxlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpbW11dGFibGVTZXR0ZXIodiwgX3ByaW9yVmFsLCBfZG9jLCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMgPT0gbnVsbCB8fCB0aGlzLiRfXyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNOZXcpIHtcbiAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm92ZXJ3cml0ZUltbXV0YWJsZSkge1xuICAgICAgcmV0dXJuIHY7XG4gICAgfVxuXG4gICAgY29uc3QgX2ltbXV0YWJsZSA9IHR5cGVvZiBpbW11dGFibGUgPT09ICdmdW5jdGlvbicgP1xuICAgICAgaW1tdXRhYmxlLmNhbGwodGhpcywgdGhpcykgOlxuICAgICAgaW1tdXRhYmxlO1xuICAgIGlmICghX2ltbXV0YWJsZSkge1xuICAgICAgcmV0dXJuIHY7XG4gICAgfVxuXG4gICAgY29uc3QgX3ZhbHVlID0gdGhpcy4kX18ucHJpb3JEb2MgIT0gbnVsbCA/XG4gICAgICB0aGlzLiRfXy5wcmlvckRvYy4kX19nZXRWYWx1ZShwYXRoKSA6XG4gICAgICB0aGlzLiRfX2dldFZhbHVlKHBhdGgpO1xuICAgIGlmICh0aGlzLiRfXy5zdHJpY3RNb2RlID09PSAndGhyb3cnICYmIHYgIT09IF92YWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IFN0cmljdE1vZGVFcnJvcihwYXRoLCAnUGF0aCBgJyArIHBhdGggKyAnYCBpcyBpbW11dGFibGUgJyArXG4gICAgICAgICdhbmQgc3RyaWN0IG1vZGUgaXMgc2V0IHRvIHRocm93LicsIHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiBfdmFsdWU7XG4gIH07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/schematype/handleImmutable.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js":
/*!***************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst modifiedPaths = (__webpack_require__(/*! ./common */ \"../backend/node_modules/mongoose/lib/helpers/common.js\").modifiedPaths);\nconst get = __webpack_require__(/*! ./get */ \"../backend/node_modules/mongoose/lib/helpers/get.js\");\n\n/**\n * Applies defaults to update and findOneAndUpdate operations.\n *\n * @param {Object} filter\n * @param {Schema} schema\n * @param {Object} castedDoc\n * @param {Object} options\n * @method setDefaultsOnInsert\n * @api private\n */\n\nmodule.exports = function(filter, schema, castedDoc, options) {\n  options = options || {};\n\n  const shouldSetDefaultsOnInsert =\n    options.setDefaultsOnInsert != null ?\n      options.setDefaultsOnInsert :\n      schema.base.options.setDefaultsOnInsert;\n\n  if (!options.upsert || shouldSetDefaultsOnInsert === false) {\n    return castedDoc;\n  }\n\n  const keys = Object.keys(castedDoc || {});\n  const updatedKeys = {};\n  const updatedValues = {};\n  const numKeys = keys.length;\n  const modified = {};\n\n  let hasDollarUpdate = false;\n\n  for (let i = 0; i < numKeys; ++i) {\n    if (keys[i].startsWith('$')) {\n      modifiedPaths(castedDoc[keys[i]], '', modified);\n      hasDollarUpdate = true;\n    }\n  }\n\n  if (!hasDollarUpdate) {\n    modifiedPaths(castedDoc, '', modified);\n  }\n\n  const paths = Object.keys(filter);\n  const numPaths = paths.length;\n  for (let i = 0; i < numPaths; ++i) {\n    const path = paths[i];\n    const condition = filter[path];\n    if (condition && typeof condition === 'object') {\n      const conditionKeys = Object.keys(condition);\n      const numConditionKeys = conditionKeys.length;\n      let hasDollarKey = false;\n      for (let j = 0; j < numConditionKeys; ++j) {\n        if (conditionKeys[j].startsWith('$')) {\n          hasDollarKey = true;\n          break;\n        }\n      }\n      if (hasDollarKey) {\n        continue;\n      }\n    }\n    updatedKeys[path] = true;\n    modified[path] = true;\n  }\n\n  if (options && options.overwrite && !hasDollarUpdate) {\n    // Defaults will be set later, since we're overwriting we'll cast\n    // the whole update to a document\n    return castedDoc;\n  }\n\n  schema.eachPath(function(path, schemaType) {\n    // Skip single nested paths if underneath a map\n    if (schemaType.path === '_id' && schemaType.options.auto) {\n      return;\n    }\n    const def = schemaType.getDefault(null, true);\n    if (isModified(modified, path)) {\n      return;\n    }\n    if (typeof def === 'undefined') {\n      return;\n    }\n    if (schemaType.splitPath().includes('$*')) {\n      // Skip defaults underneath maps. We should never do `$setOnInsert` on a path with `$*`\n      return;\n    }\n\n    castedDoc = castedDoc || {};\n    castedDoc.$setOnInsert = castedDoc.$setOnInsert || {};\n    if (get(castedDoc, path) == null) {\n      castedDoc.$setOnInsert[path] = def;\n    }\n    updatedValues[path] = def;\n  });\n\n  return castedDoc;\n};\n\nfunction isModified(modified, path) {\n  if (modified[path]) {\n    return true;\n  }\n\n  // Is any parent path of `path` modified?\n  const sp = path.split('.');\n  let cur = sp[0];\n  for (let i = 1; i < sp.length; ++i) {\n    if (modified[cur]) {\n      return true;\n    }\n    cur += '.' + sp[i];\n  }\n\n  // Is any child of `path` modified?\n  const modifiedKeys = Object.keys(modified);\n  if (modifiedKeys.length) {\n    const parentPath = path + '.';\n\n    for (const modifiedPath of modifiedKeys) {\n      if (modifiedPath.slice(0, path.length + 1) === parentPath) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc2V0RGVmYXVsdHNPbkluc2VydC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLHNCQUFzQiw2R0FBaUM7QUFDdkQsWUFBWSxtQkFBTyxDQUFDLGtFQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3NldERlZmF1bHRzT25JbnNlcnQuanM/OTcxMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBtb2RpZmllZFBhdGhzID0gcmVxdWlyZSgnLi9jb21tb24nKS5tb2RpZmllZFBhdGhzO1xuY29uc3QgZ2V0ID0gcmVxdWlyZSgnLi9nZXQnKTtcblxuLyoqXG4gKiBBcHBsaWVzIGRlZmF1bHRzIHRvIHVwZGF0ZSBhbmQgZmluZE9uZUFuZFVwZGF0ZSBvcGVyYXRpb25zLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaWx0ZXJcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYXN0ZWREb2NcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAbWV0aG9kIHNldERlZmF1bHRzT25JbnNlcnRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZmlsdGVyLCBzY2hlbWEsIGNhc3RlZERvYywgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBjb25zdCBzaG91bGRTZXREZWZhdWx0c09uSW5zZXJ0ID1cbiAgICBvcHRpb25zLnNldERlZmF1bHRzT25JbnNlcnQgIT0gbnVsbCA/XG4gICAgICBvcHRpb25zLnNldERlZmF1bHRzT25JbnNlcnQgOlxuICAgICAgc2NoZW1hLmJhc2Uub3B0aW9ucy5zZXREZWZhdWx0c09uSW5zZXJ0O1xuXG4gIGlmICghb3B0aW9ucy51cHNlcnQgfHwgc2hvdWxkU2V0RGVmYXVsdHNPbkluc2VydCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gY2FzdGVkRG9jO1xuICB9XG5cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGNhc3RlZERvYyB8fCB7fSk7XG4gIGNvbnN0IHVwZGF0ZWRLZXlzID0ge307XG4gIGNvbnN0IHVwZGF0ZWRWYWx1ZXMgPSB7fTtcbiAgY29uc3QgbnVtS2V5cyA9IGtleXMubGVuZ3RoO1xuICBjb25zdCBtb2RpZmllZCA9IHt9O1xuXG4gIGxldCBoYXNEb2xsYXJVcGRhdGUgPSBmYWxzZTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUtleXM7ICsraSkge1xuICAgIGlmIChrZXlzW2ldLnN0YXJ0c1dpdGgoJyQnKSkge1xuICAgICAgbW9kaWZpZWRQYXRocyhjYXN0ZWREb2Nba2V5c1tpXV0sICcnLCBtb2RpZmllZCk7XG4gICAgICBoYXNEb2xsYXJVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaGFzRG9sbGFyVXBkYXRlKSB7XG4gICAgbW9kaWZpZWRQYXRocyhjYXN0ZWREb2MsICcnLCBtb2RpZmllZCk7XG4gIH1cblxuICBjb25zdCBwYXRocyA9IE9iamVjdC5rZXlzKGZpbHRlcik7XG4gIGNvbnN0IG51bVBhdGhzID0gcGF0aHMubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVBhdGhzOyArK2kpIHtcbiAgICBjb25zdCBwYXRoID0gcGF0aHNbaV07XG4gICAgY29uc3QgY29uZGl0aW9uID0gZmlsdGVyW3BhdGhdO1xuICAgIGlmIChjb25kaXRpb24gJiYgdHlwZW9mIGNvbmRpdGlvbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbnN0IGNvbmRpdGlvbktleXMgPSBPYmplY3Qua2V5cyhjb25kaXRpb24pO1xuICAgICAgY29uc3QgbnVtQ29uZGl0aW9uS2V5cyA9IGNvbmRpdGlvbktleXMubGVuZ3RoO1xuICAgICAgbGV0IGhhc0RvbGxhcktleSA9IGZhbHNlO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1Db25kaXRpb25LZXlzOyArK2opIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbktleXNbal0uc3RhcnRzV2l0aCgnJCcpKSB7XG4gICAgICAgICAgaGFzRG9sbGFyS2V5ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGhhc0RvbGxhcktleSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlZEtleXNbcGF0aF0gPSB0cnVlO1xuICAgIG1vZGlmaWVkW3BhdGhdID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMub3ZlcndyaXRlICYmICFoYXNEb2xsYXJVcGRhdGUpIHtcbiAgICAvLyBEZWZhdWx0cyB3aWxsIGJlIHNldCBsYXRlciwgc2luY2Ugd2UncmUgb3ZlcndyaXRpbmcgd2UnbGwgY2FzdFxuICAgIC8vIHRoZSB3aG9sZSB1cGRhdGUgdG8gYSBkb2N1bWVudFxuICAgIHJldHVybiBjYXN0ZWREb2M7XG4gIH1cblxuICBzY2hlbWEuZWFjaFBhdGgoZnVuY3Rpb24ocGF0aCwgc2NoZW1hVHlwZSkge1xuICAgIC8vIFNraXAgc2luZ2xlIG5lc3RlZCBwYXRocyBpZiB1bmRlcm5lYXRoIGEgbWFwXG4gICAgaWYgKHNjaGVtYVR5cGUucGF0aCA9PT0gJ19pZCcgJiYgc2NoZW1hVHlwZS5vcHRpb25zLmF1dG8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGVmID0gc2NoZW1hVHlwZS5nZXREZWZhdWx0KG51bGwsIHRydWUpO1xuICAgIGlmIChpc01vZGlmaWVkKG1vZGlmaWVkLCBwYXRoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNjaGVtYVR5cGUuc3BsaXRQYXRoKCkuaW5jbHVkZXMoJyQqJykpIHtcbiAgICAgIC8vIFNraXAgZGVmYXVsdHMgdW5kZXJuZWF0aCBtYXBzLiBXZSBzaG91bGQgbmV2ZXIgZG8gYCRzZXRPbkluc2VydGAgb24gYSBwYXRoIHdpdGggYCQqYFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhc3RlZERvYyA9IGNhc3RlZERvYyB8fCB7fTtcbiAgICBjYXN0ZWREb2MuJHNldE9uSW5zZXJ0ID0gY2FzdGVkRG9jLiRzZXRPbkluc2VydCB8fCB7fTtcbiAgICBpZiAoZ2V0KGNhc3RlZERvYywgcGF0aCkgPT0gbnVsbCkge1xuICAgICAgY2FzdGVkRG9jLiRzZXRPbkluc2VydFtwYXRoXSA9IGRlZjtcbiAgICB9XG4gICAgdXBkYXRlZFZhbHVlc1twYXRoXSA9IGRlZjtcbiAgfSk7XG5cbiAgcmV0dXJuIGNhc3RlZERvYztcbn07XG5cbmZ1bmN0aW9uIGlzTW9kaWZpZWQobW9kaWZpZWQsIHBhdGgpIHtcbiAgaWYgKG1vZGlmaWVkW3BhdGhdKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBJcyBhbnkgcGFyZW50IHBhdGggb2YgYHBhdGhgIG1vZGlmaWVkP1xuICBjb25zdCBzcCA9IHBhdGguc3BsaXQoJy4nKTtcbiAgbGV0IGN1ciA9IHNwWzBdO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IHNwLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKG1vZGlmaWVkW2N1cl0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjdXIgKz0gJy4nICsgc3BbaV07XG4gIH1cblxuICAvLyBJcyBhbnkgY2hpbGQgb2YgYHBhdGhgIG1vZGlmaWVkP1xuICBjb25zdCBtb2RpZmllZEtleXMgPSBPYmplY3Qua2V5cyhtb2RpZmllZCk7XG4gIGlmIChtb2RpZmllZEtleXMubGVuZ3RoKSB7XG4gICAgY29uc3QgcGFyZW50UGF0aCA9IHBhdGggKyAnLic7XG5cbiAgICBmb3IgKGNvbnN0IG1vZGlmaWVkUGF0aCBvZiBtb2RpZmllZEtleXMpIHtcbiAgICAgIGlmIChtb2RpZmllZFBhdGguc2xpY2UoMCwgcGF0aC5sZW5ndGggKyAxKSA9PT0gcGFyZW50UGF0aCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/specialProperties.js":
/*!*************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/specialProperties.js ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = new Set(['__proto__', 'constructor', 'prototype']);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc3BlY2lhbFByb3BlcnRpZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy9zcGVjaWFsUHJvcGVydGllcy5qcz9lMDQzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgU2V0KFsnX19wcm90b19fJywgJ2NvbnN0cnVjdG9yJywgJ3Byb3RvdHlwZSddKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/specialProperties.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/symbols.js":
/*!***************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/symbols.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.arrayAtomicsBackupSymbol = Symbol('mongoose#Array#atomicsBackup');\nexports.arrayAtomicsSymbol = Symbol('mongoose#Array#_atomics');\nexports.arrayParentSymbol = Symbol('mongoose#Array#_parent');\nexports.arrayPathSymbol = Symbol('mongoose#Array#_path');\nexports.arraySchemaSymbol = Symbol('mongoose#Array#_schema');\nexports.documentArrayParent = Symbol('mongoose#documentArrayParent');\nexports.documentIsSelected = Symbol('mongoose#Document#isSelected');\nexports.documentIsModified = Symbol('mongoose#Document#isModified');\nexports.documentModifiedPaths = Symbol('mongoose#Document#modifiedPaths');\nexports.documentSchemaSymbol = Symbol('mongoose#Document#schema');\nexports.getSymbol = Symbol('mongoose#Document#get');\nexports.modelSymbol = Symbol('mongoose#Model');\nexports.objectIdSymbol = Symbol('mongoose#ObjectId');\nexports.populateModelSymbol = Symbol('mongoose#PopulateOptions#Model');\nexports.schemaTypeSymbol = Symbol('mongoose#schemaType');\nexports.sessionNewDocuments = Symbol('mongoose#ClientSession#newDocuments');\nexports.scopeSymbol = Symbol('mongoose#Document#scope');\nexports.validatorErrorSymbol = Symbol('mongoose#validatorError');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvc3ltYm9scy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixnQ0FBZ0M7QUFDaEMsMEJBQTBCO0FBQzFCLHlCQUF5QjtBQUN6Qix1QkFBdUI7QUFDdkIseUJBQXlCO0FBQ3pCLDJCQUEyQjtBQUMzQiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUIsaUJBQWlCO0FBQ2pCLG1CQUFtQjtBQUNuQixzQkFBc0I7QUFDdEIsMkJBQTJCO0FBQzNCLHdCQUF3QjtBQUN4QiwyQkFBMkI7QUFDM0IsbUJBQW1CO0FBQ25CLDRCQUE0QiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3N5bWJvbHMuanM/MTI0OSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuYXJyYXlBdG9taWNzQmFja3VwU3ltYm9sID0gU3ltYm9sKCdtb25nb29zZSNBcnJheSNhdG9taWNzQmFja3VwJyk7XG5leHBvcnRzLmFycmF5QXRvbWljc1N5bWJvbCA9IFN5bWJvbCgnbW9uZ29vc2UjQXJyYXkjX2F0b21pY3MnKTtcbmV4cG9ydHMuYXJyYXlQYXJlbnRTeW1ib2wgPSBTeW1ib2woJ21vbmdvb3NlI0FycmF5I19wYXJlbnQnKTtcbmV4cG9ydHMuYXJyYXlQYXRoU3ltYm9sID0gU3ltYm9sKCdtb25nb29zZSNBcnJheSNfcGF0aCcpO1xuZXhwb3J0cy5hcnJheVNjaGVtYVN5bWJvbCA9IFN5bWJvbCgnbW9uZ29vc2UjQXJyYXkjX3NjaGVtYScpO1xuZXhwb3J0cy5kb2N1bWVudEFycmF5UGFyZW50ID0gU3ltYm9sKCdtb25nb29zZSNkb2N1bWVudEFycmF5UGFyZW50Jyk7XG5leHBvcnRzLmRvY3VtZW50SXNTZWxlY3RlZCA9IFN5bWJvbCgnbW9uZ29vc2UjRG9jdW1lbnQjaXNTZWxlY3RlZCcpO1xuZXhwb3J0cy5kb2N1bWVudElzTW9kaWZpZWQgPSBTeW1ib2woJ21vbmdvb3NlI0RvY3VtZW50I2lzTW9kaWZpZWQnKTtcbmV4cG9ydHMuZG9jdW1lbnRNb2RpZmllZFBhdGhzID0gU3ltYm9sKCdtb25nb29zZSNEb2N1bWVudCNtb2RpZmllZFBhdGhzJyk7XG5leHBvcnRzLmRvY3VtZW50U2NoZW1hU3ltYm9sID0gU3ltYm9sKCdtb25nb29zZSNEb2N1bWVudCNzY2hlbWEnKTtcbmV4cG9ydHMuZ2V0U3ltYm9sID0gU3ltYm9sKCdtb25nb29zZSNEb2N1bWVudCNnZXQnKTtcbmV4cG9ydHMubW9kZWxTeW1ib2wgPSBTeW1ib2woJ21vbmdvb3NlI01vZGVsJyk7XG5leHBvcnRzLm9iamVjdElkU3ltYm9sID0gU3ltYm9sKCdtb25nb29zZSNPYmplY3RJZCcpO1xuZXhwb3J0cy5wb3B1bGF0ZU1vZGVsU3ltYm9sID0gU3ltYm9sKCdtb25nb29zZSNQb3B1bGF0ZU9wdGlvbnMjTW9kZWwnKTtcbmV4cG9ydHMuc2NoZW1hVHlwZVN5bWJvbCA9IFN5bWJvbCgnbW9uZ29vc2Ujc2NoZW1hVHlwZScpO1xuZXhwb3J0cy5zZXNzaW9uTmV3RG9jdW1lbnRzID0gU3ltYm9sKCdtb25nb29zZSNDbGllbnRTZXNzaW9uI25ld0RvY3VtZW50cycpO1xuZXhwb3J0cy5zY29wZVN5bWJvbCA9IFN5bWJvbCgnbW9uZ29vc2UjRG9jdW1lbnQjc2NvcGUnKTtcbmV4cG9ydHMudmFsaWRhdG9yRXJyb3JTeW1ib2wgPSBTeW1ib2woJ21vbmdvb3NlI3ZhbGlkYXRvckVycm9yJyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/symbols.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/timers.js":
/*!**************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/timers.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.setTimeout = setTimeout;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdGltZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3RpbWVycy5qcz9lMTFmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/timers.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/timestamps/setDocumentTimestamps.js":
/*!****************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/timestamps/setDocumentTimestamps.js ***!
  \****************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function setDocumentTimestamps(doc, timestampOption, currentTime, createdAt, updatedAt) {\n  const skipUpdatedAt = timestampOption != null && timestampOption.updatedAt === false;\n  const skipCreatedAt = timestampOption != null && timestampOption.createdAt === false;\n\n  const defaultTimestamp = currentTime != null ?\n    currentTime() :\n    doc.ownerDocument().constructor.base.now();\n\n  if (!skipCreatedAt &&\n      (doc.isNew || doc.$isSubdocument) &&\n      createdAt &&\n      !doc.$__getValue(createdAt) &&\n      doc.$__isSelected(createdAt)) {\n    doc.$set(createdAt, defaultTimestamp, undefined, { overwriteImmutable: true });\n  }\n\n  if (!skipUpdatedAt && updatedAt && (doc.isNew || doc.$isModified())) {\n    let ts = defaultTimestamp;\n    if (doc.isNew && createdAt != null) {\n      ts = doc.$__getValue(createdAt);\n    }\n    doc.$set(updatedAt, ts);\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdGltZXN0YW1wcy9zZXREb2N1bWVudFRpbWVzdGFtcHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELDBCQUEwQjtBQUNqRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdGltZXN0YW1wcy9zZXREb2N1bWVudFRpbWVzdGFtcHMuanM/MjRiNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2V0RG9jdW1lbnRUaW1lc3RhbXBzKGRvYywgdGltZXN0YW1wT3B0aW9uLCBjdXJyZW50VGltZSwgY3JlYXRlZEF0LCB1cGRhdGVkQXQpIHtcbiAgY29uc3Qgc2tpcFVwZGF0ZWRBdCA9IHRpbWVzdGFtcE9wdGlvbiAhPSBudWxsICYmIHRpbWVzdGFtcE9wdGlvbi51cGRhdGVkQXQgPT09IGZhbHNlO1xuICBjb25zdCBza2lwQ3JlYXRlZEF0ID0gdGltZXN0YW1wT3B0aW9uICE9IG51bGwgJiYgdGltZXN0YW1wT3B0aW9uLmNyZWF0ZWRBdCA9PT0gZmFsc2U7XG5cbiAgY29uc3QgZGVmYXVsdFRpbWVzdGFtcCA9IGN1cnJlbnRUaW1lICE9IG51bGwgP1xuICAgIGN1cnJlbnRUaW1lKCkgOlxuICAgIGRvYy5vd25lckRvY3VtZW50KCkuY29uc3RydWN0b3IuYmFzZS5ub3coKTtcblxuICBpZiAoIXNraXBDcmVhdGVkQXQgJiZcbiAgICAgIChkb2MuaXNOZXcgfHwgZG9jLiRpc1N1YmRvY3VtZW50KSAmJlxuICAgICAgY3JlYXRlZEF0ICYmXG4gICAgICAhZG9jLiRfX2dldFZhbHVlKGNyZWF0ZWRBdCkgJiZcbiAgICAgIGRvYy4kX19pc1NlbGVjdGVkKGNyZWF0ZWRBdCkpIHtcbiAgICBkb2MuJHNldChjcmVhdGVkQXQsIGRlZmF1bHRUaW1lc3RhbXAsIHVuZGVmaW5lZCwgeyBvdmVyd3JpdGVJbW11dGFibGU6IHRydWUgfSk7XG4gIH1cblxuICBpZiAoIXNraXBVcGRhdGVkQXQgJiYgdXBkYXRlZEF0ICYmIChkb2MuaXNOZXcgfHwgZG9jLiRpc01vZGlmaWVkKCkpKSB7XG4gICAgbGV0IHRzID0gZGVmYXVsdFRpbWVzdGFtcDtcbiAgICBpZiAoZG9jLmlzTmV3ICYmIGNyZWF0ZWRBdCAhPSBudWxsKSB7XG4gICAgICB0cyA9IGRvYy4kX19nZXRWYWx1ZShjcmVhdGVkQXQpO1xuICAgIH1cbiAgICBkb2MuJHNldCh1cGRhdGVkQXQsIHRzKTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/timestamps/setDocumentTimestamps.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/timestamps/setupTimestamps.js":
/*!**********************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/timestamps/setupTimestamps.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst applyTimestampsToChildren = __webpack_require__(/*! ../update/applyTimestampsToChildren */ \"../backend/node_modules/mongoose/lib/helpers/update/applyTimestampsToChildren.js\");\nconst applyTimestampsToUpdate = __webpack_require__(/*! ../update/applyTimestampsToUpdate */ \"../backend/node_modules/mongoose/lib/helpers/update/applyTimestampsToUpdate.js\");\nconst get = __webpack_require__(/*! ../get */ \"../backend/node_modules/mongoose/lib/helpers/get.js\");\nconst handleTimestampOption = __webpack_require__(/*! ../schema/handleTimestampOption */ \"../backend/node_modules/mongoose/lib/helpers/schema/handleTimestampOption.js\");\nconst setDocumentTimestamps = __webpack_require__(/*! ./setDocumentTimestamps */ \"../backend/node_modules/mongoose/lib/helpers/timestamps/setDocumentTimestamps.js\");\nconst symbols = __webpack_require__(/*! ../../schema/symbols */ \"../backend/node_modules/mongoose/lib/schema/symbols.js\");\n\nconst replaceOps = new Set([\n  'replaceOne',\n  'findOneAndReplace'\n]);\n\nmodule.exports = function setupTimestamps(schema, timestamps) {\n  const childHasTimestamp = schema.childSchemas.find(withTimestamp);\n  function withTimestamp(s) {\n    const ts = s.schema.options.timestamps;\n    return !!ts;\n  }\n  if (!timestamps && !childHasTimestamp) {\n    return;\n  }\n  const createdAt = handleTimestampOption(timestamps, 'createdAt');\n  const updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n  const currentTime = timestamps != null && timestamps.hasOwnProperty('currentTime') ?\n    timestamps.currentTime :\n    null;\n  const schemaAdditions = {};\n\n  schema.$timestamps = { createdAt: createdAt, updatedAt: updatedAt };\n\n  if (createdAt && !schema.paths[createdAt]) {\n    const baseImmutableCreatedAt = schema.base != null ? schema.base.get('timestamps.createdAt.immutable') : null;\n    const immutable = baseImmutableCreatedAt != null ? baseImmutableCreatedAt : true;\n    schemaAdditions[createdAt] = { [schema.options.typeKey || 'type']: Date, immutable };\n  }\n\n  if (updatedAt && !schema.paths[updatedAt]) {\n    schemaAdditions[updatedAt] = Date;\n  }\n\n  schema.add(schemaAdditions);\n\n  schema.pre('save', function timestampsPreSave(next) {\n    const timestampOption = get(this, '$__.saveOptions.timestamps');\n    if (timestampOption === false) {\n      return next();\n    }\n\n    setDocumentTimestamps(this, timestampOption, currentTime, createdAt, updatedAt);\n\n    next();\n  });\n\n  schema.methods.initializeTimestamps = function() {\n    const ts = currentTime != null ?\n      currentTime() : this.constructor.base.now();\n\n\n    if (createdAt && !this.get(createdAt)) {\n      this.$set(createdAt, ts);\n    }\n    if (updatedAt && !this.get(updatedAt)) {\n      this.$set(updatedAt, ts);\n    }\n    if (this.$isSubdocument) {\n      return this;\n    }\n\n    const subdocs = this.$getAllSubdocs();\n    for (const subdoc of subdocs) {\n      if (subdoc.initializeTimestamps) {\n        subdoc.initializeTimestamps();\n      }\n    }\n\n    return this;\n  };\n\n  _setTimestampsOnUpdate[symbols.builtInMiddleware] = true;\n\n  const opts = { query: true, model: false };\n  schema.pre('findOneAndReplace', opts, _setTimestampsOnUpdate);\n  schema.pre('findOneAndUpdate', opts, _setTimestampsOnUpdate);\n  schema.pre('replaceOne', opts, _setTimestampsOnUpdate);\n  schema.pre('update', opts, _setTimestampsOnUpdate);\n  schema.pre('updateOne', opts, _setTimestampsOnUpdate);\n  schema.pre('updateMany', opts, _setTimestampsOnUpdate);\n\n  function _setTimestampsOnUpdate(next) {\n    const now = currentTime != null ?\n      currentTime() :\n      this.model.base.now();\n    // Replacing with null update should still trigger timestamps\n    if (replaceOps.has(this.op) && this.getUpdate() == null) {\n      this.setUpdate({});\n    }\n    applyTimestampsToUpdate(\n      now,\n      createdAt,\n      updatedAt,\n      this.getUpdate(),\n      this._mongooseOptions,\n      replaceOps.has(this.op)\n    );\n    applyTimestampsToChildren(now, this.getUpdate(), this.model.schema);\n    next();\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdGltZXN0YW1wcy9zZXR1cFRpbWVzdGFtcHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsa0NBQWtDLG1CQUFPLENBQUMsNkhBQXFDO0FBQy9FLGdDQUFnQyxtQkFBTyxDQUFDLHlIQUFtQztBQUMzRSxZQUFZLG1CQUFPLENBQUMsbUVBQVE7QUFDNUIsOEJBQThCLG1CQUFPLENBQUMscUhBQWlDO0FBQ3ZFLDhCQUE4QixtQkFBTyxDQUFDLGlIQUF5QjtBQUMvRCxnQkFBZ0IsbUJBQU8sQ0FBQyxvRkFBc0I7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy90aW1lc3RhbXBzL3NldHVwVGltZXN0YW1wcy5qcz9jMWRlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgYXBwbHlUaW1lc3RhbXBzVG9DaGlsZHJlbiA9IHJlcXVpcmUoJy4uL3VwZGF0ZS9hcHBseVRpbWVzdGFtcHNUb0NoaWxkcmVuJyk7XG5jb25zdCBhcHBseVRpbWVzdGFtcHNUb1VwZGF0ZSA9IHJlcXVpcmUoJy4uL3VwZGF0ZS9hcHBseVRpbWVzdGFtcHNUb1VwZGF0ZScpO1xuY29uc3QgZ2V0ID0gcmVxdWlyZSgnLi4vZ2V0Jyk7XG5jb25zdCBoYW5kbGVUaW1lc3RhbXBPcHRpb24gPSByZXF1aXJlKCcuLi9zY2hlbWEvaGFuZGxlVGltZXN0YW1wT3B0aW9uJyk7XG5jb25zdCBzZXREb2N1bWVudFRpbWVzdGFtcHMgPSByZXF1aXJlKCcuL3NldERvY3VtZW50VGltZXN0YW1wcycpO1xuY29uc3Qgc3ltYm9scyA9IHJlcXVpcmUoJy4uLy4uL3NjaGVtYS9zeW1ib2xzJyk7XG5cbmNvbnN0IHJlcGxhY2VPcHMgPSBuZXcgU2V0KFtcbiAgJ3JlcGxhY2VPbmUnLFxuICAnZmluZE9uZUFuZFJlcGxhY2UnXG5dKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXR1cFRpbWVzdGFtcHMoc2NoZW1hLCB0aW1lc3RhbXBzKSB7XG4gIGNvbnN0IGNoaWxkSGFzVGltZXN0YW1wID0gc2NoZW1hLmNoaWxkU2NoZW1hcy5maW5kKHdpdGhUaW1lc3RhbXApO1xuICBmdW5jdGlvbiB3aXRoVGltZXN0YW1wKHMpIHtcbiAgICBjb25zdCB0cyA9IHMuc2NoZW1hLm9wdGlvbnMudGltZXN0YW1wcztcbiAgICByZXR1cm4gISF0cztcbiAgfVxuICBpZiAoIXRpbWVzdGFtcHMgJiYgIWNoaWxkSGFzVGltZXN0YW1wKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNyZWF0ZWRBdCA9IGhhbmRsZVRpbWVzdGFtcE9wdGlvbih0aW1lc3RhbXBzLCAnY3JlYXRlZEF0Jyk7XG4gIGNvbnN0IHVwZGF0ZWRBdCA9IGhhbmRsZVRpbWVzdGFtcE9wdGlvbih0aW1lc3RhbXBzLCAndXBkYXRlZEF0Jyk7XG4gIGNvbnN0IGN1cnJlbnRUaW1lID0gdGltZXN0YW1wcyAhPSBudWxsICYmIHRpbWVzdGFtcHMuaGFzT3duUHJvcGVydHkoJ2N1cnJlbnRUaW1lJykgP1xuICAgIHRpbWVzdGFtcHMuY3VycmVudFRpbWUgOlxuICAgIG51bGw7XG4gIGNvbnN0IHNjaGVtYUFkZGl0aW9ucyA9IHt9O1xuXG4gIHNjaGVtYS4kdGltZXN0YW1wcyA9IHsgY3JlYXRlZEF0OiBjcmVhdGVkQXQsIHVwZGF0ZWRBdDogdXBkYXRlZEF0IH07XG5cbiAgaWYgKGNyZWF0ZWRBdCAmJiAhc2NoZW1hLnBhdGhzW2NyZWF0ZWRBdF0pIHtcbiAgICBjb25zdCBiYXNlSW1tdXRhYmxlQ3JlYXRlZEF0ID0gc2NoZW1hLmJhc2UgIT0gbnVsbCA/IHNjaGVtYS5iYXNlLmdldCgndGltZXN0YW1wcy5jcmVhdGVkQXQuaW1tdXRhYmxlJykgOiBudWxsO1xuICAgIGNvbnN0IGltbXV0YWJsZSA9IGJhc2VJbW11dGFibGVDcmVhdGVkQXQgIT0gbnVsbCA/IGJhc2VJbW11dGFibGVDcmVhdGVkQXQgOiB0cnVlO1xuICAgIHNjaGVtYUFkZGl0aW9uc1tjcmVhdGVkQXRdID0geyBbc2NoZW1hLm9wdGlvbnMudHlwZUtleSB8fCAndHlwZSddOiBEYXRlLCBpbW11dGFibGUgfTtcbiAgfVxuXG4gIGlmICh1cGRhdGVkQXQgJiYgIXNjaGVtYS5wYXRoc1t1cGRhdGVkQXRdKSB7XG4gICAgc2NoZW1hQWRkaXRpb25zW3VwZGF0ZWRBdF0gPSBEYXRlO1xuICB9XG5cbiAgc2NoZW1hLmFkZChzY2hlbWFBZGRpdGlvbnMpO1xuXG4gIHNjaGVtYS5wcmUoJ3NhdmUnLCBmdW5jdGlvbiB0aW1lc3RhbXBzUHJlU2F2ZShuZXh0KSB7XG4gICAgY29uc3QgdGltZXN0YW1wT3B0aW9uID0gZ2V0KHRoaXMsICckX18uc2F2ZU9wdGlvbnMudGltZXN0YW1wcycpO1xuICAgIGlmICh0aW1lc3RhbXBPcHRpb24gPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH1cblxuICAgIHNldERvY3VtZW50VGltZXN0YW1wcyh0aGlzLCB0aW1lc3RhbXBPcHRpb24sIGN1cnJlbnRUaW1lLCBjcmVhdGVkQXQsIHVwZGF0ZWRBdCk7XG5cbiAgICBuZXh0KCk7XG4gIH0pO1xuXG4gIHNjaGVtYS5tZXRob2RzLmluaXRpYWxpemVUaW1lc3RhbXBzID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgdHMgPSBjdXJyZW50VGltZSAhPSBudWxsID9cbiAgICAgIGN1cnJlbnRUaW1lKCkgOiB0aGlzLmNvbnN0cnVjdG9yLmJhc2Uubm93KCk7XG5cblxuICAgIGlmIChjcmVhdGVkQXQgJiYgIXRoaXMuZ2V0KGNyZWF0ZWRBdCkpIHtcbiAgICAgIHRoaXMuJHNldChjcmVhdGVkQXQsIHRzKTtcbiAgICB9XG4gICAgaWYgKHVwZGF0ZWRBdCAmJiAhdGhpcy5nZXQodXBkYXRlZEF0KSkge1xuICAgICAgdGhpcy4kc2V0KHVwZGF0ZWRBdCwgdHMpO1xuICAgIH1cbiAgICBpZiAodGhpcy4kaXNTdWJkb2N1bWVudCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY29uc3Qgc3ViZG9jcyA9IHRoaXMuJGdldEFsbFN1YmRvY3MoKTtcbiAgICBmb3IgKGNvbnN0IHN1YmRvYyBvZiBzdWJkb2NzKSB7XG4gICAgICBpZiAoc3ViZG9jLmluaXRpYWxpemVUaW1lc3RhbXBzKSB7XG4gICAgICAgIHN1YmRvYy5pbml0aWFsaXplVGltZXN0YW1wcygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9zZXRUaW1lc3RhbXBzT25VcGRhdGVbc3ltYm9scy5idWlsdEluTWlkZGxld2FyZV0gPSB0cnVlO1xuXG4gIGNvbnN0IG9wdHMgPSB7IHF1ZXJ5OiB0cnVlLCBtb2RlbDogZmFsc2UgfTtcbiAgc2NoZW1hLnByZSgnZmluZE9uZUFuZFJlcGxhY2UnLCBvcHRzLCBfc2V0VGltZXN0YW1wc09uVXBkYXRlKTtcbiAgc2NoZW1hLnByZSgnZmluZE9uZUFuZFVwZGF0ZScsIG9wdHMsIF9zZXRUaW1lc3RhbXBzT25VcGRhdGUpO1xuICBzY2hlbWEucHJlKCdyZXBsYWNlT25lJywgb3B0cywgX3NldFRpbWVzdGFtcHNPblVwZGF0ZSk7XG4gIHNjaGVtYS5wcmUoJ3VwZGF0ZScsIG9wdHMsIF9zZXRUaW1lc3RhbXBzT25VcGRhdGUpO1xuICBzY2hlbWEucHJlKCd1cGRhdGVPbmUnLCBvcHRzLCBfc2V0VGltZXN0YW1wc09uVXBkYXRlKTtcbiAgc2NoZW1hLnByZSgndXBkYXRlTWFueScsIG9wdHMsIF9zZXRUaW1lc3RhbXBzT25VcGRhdGUpO1xuXG4gIGZ1bmN0aW9uIF9zZXRUaW1lc3RhbXBzT25VcGRhdGUobmV4dCkge1xuICAgIGNvbnN0IG5vdyA9IGN1cnJlbnRUaW1lICE9IG51bGwgP1xuICAgICAgY3VycmVudFRpbWUoKSA6XG4gICAgICB0aGlzLm1vZGVsLmJhc2Uubm93KCk7XG4gICAgLy8gUmVwbGFjaW5nIHdpdGggbnVsbCB1cGRhdGUgc2hvdWxkIHN0aWxsIHRyaWdnZXIgdGltZXN0YW1wc1xuICAgIGlmIChyZXBsYWNlT3BzLmhhcyh0aGlzLm9wKSAmJiB0aGlzLmdldFVwZGF0ZSgpID09IG51bGwpIHtcbiAgICAgIHRoaXMuc2V0VXBkYXRlKHt9KTtcbiAgICB9XG4gICAgYXBwbHlUaW1lc3RhbXBzVG9VcGRhdGUoXG4gICAgICBub3csXG4gICAgICBjcmVhdGVkQXQsXG4gICAgICB1cGRhdGVkQXQsXG4gICAgICB0aGlzLmdldFVwZGF0ZSgpLFxuICAgICAgdGhpcy5fbW9uZ29vc2VPcHRpb25zLFxuICAgICAgcmVwbGFjZU9wcy5oYXModGhpcy5vcClcbiAgICApO1xuICAgIGFwcGx5VGltZXN0YW1wc1RvQ2hpbGRyZW4obm93LCB0aGlzLmdldFVwZGF0ZSgpLCB0aGlzLm1vZGVsLnNjaGVtYSk7XG4gICAgbmV4dCgpO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/timestamps/setupTimestamps.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/topology/allServersUnknown.js":
/*!**********************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/topology/allServersUnknown.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst getConstructorName = __webpack_require__(/*! ../getConstructorName */ \"../backend/node_modules/mongoose/lib/helpers/getConstructorName.js\");\n\nmodule.exports = function allServersUnknown(topologyDescription) {\n  if (getConstructorName(topologyDescription) !== 'TopologyDescription') {\n    return false;\n  }\n\n  const servers = Array.from(topologyDescription.servers.values());\n  return servers.length > 0 && servers.every(server => server.type === 'Unknown');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdG9wb2xvZ3kvYWxsU2VydmVyc1Vua25vd24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsMkJBQTJCLG1CQUFPLENBQUMsaUdBQXVCOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy90b3BvbG9neS9hbGxTZXJ2ZXJzVW5rbm93bi5qcz8xYzQwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgZ2V0Q29uc3RydWN0b3JOYW1lID0gcmVxdWlyZSgnLi4vZ2V0Q29uc3RydWN0b3JOYW1lJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYWxsU2VydmVyc1Vua25vd24odG9wb2xvZ3lEZXNjcmlwdGlvbikge1xuICBpZiAoZ2V0Q29uc3RydWN0b3JOYW1lKHRvcG9sb2d5RGVzY3JpcHRpb24pICE9PSAnVG9wb2xvZ3lEZXNjcmlwdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBzZXJ2ZXJzID0gQXJyYXkuZnJvbSh0b3BvbG9neURlc2NyaXB0aW9uLnNlcnZlcnMudmFsdWVzKCkpO1xuICByZXR1cm4gc2VydmVycy5sZW5ndGggPiAwICYmIHNlcnZlcnMuZXZlcnkoc2VydmVyID0+IHNlcnZlci50eXBlID09PSAnVW5rbm93bicpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/topology/allServersUnknown.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/topology/isAtlas.js":
/*!************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/topology/isAtlas.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst getConstructorName = __webpack_require__(/*! ../getConstructorName */ \"../backend/node_modules/mongoose/lib/helpers/getConstructorName.js\");\n\n/**\n * @typedef { import('mongodb').TopologyDescription } TopologyDescription\n */\n\n/**\n * Checks if topologyDescription contains servers connected to an atlas instance\n *\n * @param  {TopologyDescription} topologyDescription\n * @returns {boolean}\n */\nmodule.exports = function isAtlas(topologyDescription) {\n  if (getConstructorName(topologyDescription) !== 'TopologyDescription') {\n    return false;\n  }\n\n  if (topologyDescription.servers.size === 0) {\n    return false;\n  }\n\n  for (const server of topologyDescription.servers.values()) {\n    if (server.host.endsWith('.mongodb.net') === false || server.port !== 27017) {\n      return false;\n    }\n  }\n\n  return true;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdG9wb2xvZ3kvaXNBdGxhcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiwyQkFBMkIsbUJBQU8sQ0FBQyxpR0FBdUI7O0FBRTFEO0FBQ0EsY0FBYyx3Q0FBd0M7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3RvcG9sb2d5L2lzQXRsYXMuanM/NmQxMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGdldENvbnN0cnVjdG9yTmFtZSA9IHJlcXVpcmUoJy4uL2dldENvbnN0cnVjdG9yTmFtZScpO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCdtb25nb2RiJykuVG9wb2xvZ3lEZXNjcmlwdGlvbiB9IFRvcG9sb2d5RGVzY3JpcHRpb25cbiAqL1xuXG4vKipcbiAqIENoZWNrcyBpZiB0b3BvbG9neURlc2NyaXB0aW9uIGNvbnRhaW5zIHNlcnZlcnMgY29ubmVjdGVkIHRvIGFuIGF0bGFzIGluc3RhbmNlXG4gKlxuICogQHBhcmFtICB7VG9wb2xvZ3lEZXNjcmlwdGlvbn0gdG9wb2xvZ3lEZXNjcmlwdGlvblxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBdGxhcyh0b3BvbG9neURlc2NyaXB0aW9uKSB7XG4gIGlmIChnZXRDb25zdHJ1Y3Rvck5hbWUodG9wb2xvZ3lEZXNjcmlwdGlvbikgIT09ICdUb3BvbG9neURlc2NyaXB0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0b3BvbG9neURlc2NyaXB0aW9uLnNlcnZlcnMuc2l6ZSA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAoY29uc3Qgc2VydmVyIG9mIHRvcG9sb2d5RGVzY3JpcHRpb24uc2VydmVycy52YWx1ZXMoKSkge1xuICAgIGlmIChzZXJ2ZXIuaG9zdC5lbmRzV2l0aCgnLm1vbmdvZGIubmV0JykgPT09IGZhbHNlIHx8IHNlcnZlci5wb3J0ICE9PSAyNzAxNykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/topology/isAtlas.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/topology/isSSLError.js":
/*!***************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/topology/isSSLError.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst getConstructorName = __webpack_require__(/*! ../getConstructorName */ \"../backend/node_modules/mongoose/lib/helpers/getConstructorName.js\");\n\nconst nonSSLMessage = 'Client network socket disconnected before secure TLS ' +\n  'connection was established';\n\nmodule.exports = function isSSLError(topologyDescription) {\n  if (getConstructorName(topologyDescription) !== 'TopologyDescription') {\n    return false;\n  }\n\n  const descriptions = Array.from(topologyDescription.servers.values());\n  return descriptions.length > 0 &&\n    descriptions.every(descr => descr.error && descr.error.message.indexOf(nonSSLMessage) !== -1);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdG9wb2xvZ3kvaXNTU0xFcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiwyQkFBMkIsbUJBQU8sQ0FBQyxpR0FBdUI7O0FBRTFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy90b3BvbG9neS9pc1NTTEVycm9yLmpzP2E0MTkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBnZXRDb25zdHJ1Y3Rvck5hbWUgPSByZXF1aXJlKCcuLi9nZXRDb25zdHJ1Y3Rvck5hbWUnKTtcblxuY29uc3Qgbm9uU1NMTWVzc2FnZSA9ICdDbGllbnQgbmV0d29yayBzb2NrZXQgZGlzY29ubmVjdGVkIGJlZm9yZSBzZWN1cmUgVExTICcgK1xuICAnY29ubmVjdGlvbiB3YXMgZXN0YWJsaXNoZWQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzU1NMRXJyb3IodG9wb2xvZ3lEZXNjcmlwdGlvbikge1xuICBpZiAoZ2V0Q29uc3RydWN0b3JOYW1lKHRvcG9sb2d5RGVzY3JpcHRpb24pICE9PSAnVG9wb2xvZ3lEZXNjcmlwdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBkZXNjcmlwdGlvbnMgPSBBcnJheS5mcm9tKHRvcG9sb2d5RGVzY3JpcHRpb24uc2VydmVycy52YWx1ZXMoKSk7XG4gIHJldHVybiBkZXNjcmlwdGlvbnMubGVuZ3RoID4gMCAmJlxuICAgIGRlc2NyaXB0aW9ucy5ldmVyeShkZXNjciA9PiBkZXNjci5lcnJvciAmJiBkZXNjci5lcnJvci5tZXNzYWdlLmluZGV4T2Yobm9uU1NMTWVzc2FnZSkgIT09IC0xKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/topology/isSSLError.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/updateValidators.js":
/*!************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/updateValidators.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst ValidationError = __webpack_require__(/*! ../error/validation */ \"../backend/node_modules/mongoose/lib/error/validation.js\");\nconst cleanPositionalOperators = __webpack_require__(/*! ./schema/cleanPositionalOperators */ \"../backend/node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js\");\nconst flatten = (__webpack_require__(/*! ./common */ \"../backend/node_modules/mongoose/lib/helpers/common.js\").flatten);\nconst modifiedPaths = (__webpack_require__(/*! ./common */ \"../backend/node_modules/mongoose/lib/helpers/common.js\").modifiedPaths);\n\n/**\n * Applies validators and defaults to update and findOneAndUpdate operations,\n * specifically passing a null doc as `this` to validators and defaults\n *\n * @param {Query} query\n * @param {Schema} schema\n * @param {Object} castedDoc\n * @param {Object} options\n * @method runValidatorsOnUpdate\n * @api private\n */\n\nmodule.exports = function(query, schema, castedDoc, options, callback) {\n  const keys = Object.keys(castedDoc || {});\n  let updatedKeys = {};\n  let updatedValues = {};\n  const isPull = {};\n  const arrayAtomicUpdates = {};\n  const numKeys = keys.length;\n  let hasDollarUpdate = false;\n  const modified = {};\n  let currentUpdate;\n  let key;\n  let i;\n\n  for (i = 0; i < numKeys; ++i) {\n    if (keys[i].startsWith('$')) {\n      hasDollarUpdate = true;\n      if (keys[i] === '$push' || keys[i] === '$addToSet') {\n        const _keys = Object.keys(castedDoc[keys[i]]);\n        for (let ii = 0; ii < _keys.length; ++ii) {\n          currentUpdate = castedDoc[keys[i]][_keys[ii]];\n          if (currentUpdate && currentUpdate.$each) {\n            arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).\n              concat(currentUpdate.$each);\n          } else {\n            arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).\n              concat([currentUpdate]);\n          }\n        }\n        continue;\n      }\n      modifiedPaths(castedDoc[keys[i]], '', modified);\n      const flat = flatten(castedDoc[keys[i]], null, null, schema);\n      const paths = Object.keys(flat);\n      const numPaths = paths.length;\n      for (let j = 0; j < numPaths; ++j) {\n        const updatedPath = cleanPositionalOperators(paths[j]);\n        key = keys[i];\n        // With `$pull` we might flatten `$in`. Skip stuff nested under `$in`\n        // for the rest of the logic, it will get handled later.\n        if (updatedPath.includes('$')) {\n          continue;\n        }\n        if (key === '$set' || key === '$setOnInsert' ||\n            key === '$pull' || key === '$pullAll') {\n          updatedValues[updatedPath] = flat[paths[j]];\n          isPull[updatedPath] = key === '$pull' || key === '$pullAll';\n        } else if (key === '$unset') {\n          updatedValues[updatedPath] = undefined;\n        }\n        updatedKeys[updatedPath] = true;\n      }\n    }\n  }\n\n  if (!hasDollarUpdate) {\n    modifiedPaths(castedDoc, '', modified);\n    updatedValues = flatten(castedDoc, null, null, schema);\n    updatedKeys = Object.keys(updatedValues);\n  }\n\n  const updates = Object.keys(updatedValues);\n  const numUpdates = updates.length;\n  const validatorsToExecute = [];\n  const validationErrors = [];\n\n  const alreadyValidated = [];\n\n  const context = query;\n  function iter(i, v) {\n    const schemaPath = schema._getSchema(updates[i]);\n    if (schemaPath == null) {\n      return;\n    }\n    if (schemaPath.instance === 'Mixed' && schemaPath.path !== updates[i]) {\n      return;\n    }\n\n    if (v && Array.isArray(v.$in)) {\n      v.$in.forEach((v, i) => {\n        validatorsToExecute.push(function(callback) {\n          schemaPath.doValidate(\n            v,\n            function(err) {\n              if (err) {\n                err.path = updates[i] + '.$in.' + i;\n                validationErrors.push(err);\n              }\n              callback(null);\n            },\n            context,\n            { updateValidator: true });\n        });\n      });\n    } else {\n      if (isPull[updates[i]] &&\n          schemaPath.$isMongooseArray) {\n        return;\n      }\n\n      if (schemaPath.$isMongooseDocumentArrayElement && v != null && v.$__ != null) {\n        alreadyValidated.push(updates[i]);\n        validatorsToExecute.push(function(callback) {\n          schemaPath.doValidate(v, function(err) {\n            if (err) {\n              if (err.errors) {\n                for (const key of Object.keys(err.errors)) {\n                  const _err = err.errors[key];\n                  _err.path = updates[i] + '.' + key;\n                  validationErrors.push(_err);\n                }\n              } else {\n                err.path = updates[i];\n                validationErrors.push(err);\n              }\n            }\n\n            return callback(null);\n          }, context, { updateValidator: true });\n        });\n      } else {\n        validatorsToExecute.push(function(callback) {\n          for (const path of alreadyValidated) {\n            if (updates[i].startsWith(path + '.')) {\n              return callback(null);\n            }\n          }\n\n          schemaPath.doValidate(v, function(err) {\n            if (schemaPath.schema != null &&\n                schemaPath.schema.options.storeSubdocValidationError === false &&\n                err instanceof ValidationError) {\n              return callback(null);\n            }\n\n            if (err) {\n              err.path = updates[i];\n              validationErrors.push(err);\n            }\n            callback(null);\n          }, context, { updateValidator: true });\n        });\n      }\n    }\n  }\n  for (i = 0; i < numUpdates; ++i) {\n    iter(i, updatedValues[updates[i]]);\n  }\n\n  const arrayUpdates = Object.keys(arrayAtomicUpdates);\n  for (const arrayUpdate of arrayUpdates) {\n    let schemaPath = schema._getSchema(arrayUpdate);\n    if (schemaPath && schemaPath.$isMongooseDocumentArray) {\n      validatorsToExecute.push(function(callback) {\n        schemaPath.doValidate(\n          arrayAtomicUpdates[arrayUpdate],\n          getValidationCallback(arrayUpdate, validationErrors, callback),\n          options && options.context === 'query' ? query : null);\n      });\n    } else {\n      schemaPath = schema._getSchema(arrayUpdate + '.0');\n      for (const atomicUpdate of arrayAtomicUpdates[arrayUpdate]) {\n        validatorsToExecute.push(function(callback) {\n          schemaPath.doValidate(\n            atomicUpdate,\n            getValidationCallback(arrayUpdate, validationErrors, callback),\n            options && options.context === 'query' ? query : null,\n            { updateValidator: true });\n        });\n      }\n    }\n  }\n\n  if (callback != null) {\n    let numValidators = validatorsToExecute.length;\n    if (numValidators === 0) {\n      return _done(callback);\n    }\n    for (const validator of validatorsToExecute) {\n      validator(function() {\n        if (--numValidators <= 0) {\n          _done(callback);\n        }\n      });\n    }\n\n    return;\n  }\n\n  return function(callback) {\n    let numValidators = validatorsToExecute.length;\n    if (numValidators === 0) {\n      return _done(callback);\n    }\n    for (const validator of validatorsToExecute) {\n      validator(function() {\n        if (--numValidators <= 0) {\n          _done(callback);\n        }\n      });\n    }\n  };\n\n  function _done(callback) {\n    if (validationErrors.length) {\n      const err = new ValidationError(null);\n\n      for (const validationError of validationErrors) {\n        err.addError(validationError.path, validationError);\n      }\n\n      return callback(err);\n    }\n    callback(null);\n  }\n\n  function getValidationCallback(arrayUpdate, validationErrors, callback) {\n    return function(err) {\n      if (err) {\n        err.path = arrayUpdate;\n        validationErrors.push(err);\n      }\n      callback(null);\n    };\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdXBkYXRlVmFsaWRhdG9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLG1CQUFPLENBQUMscUZBQXFCO0FBQ3JELGlDQUFpQyxtQkFBTyxDQUFDLDBIQUFtQztBQUM1RSxnQkFBZ0IsdUdBQTJCO0FBQzNDLHNCQUFzQiw2R0FBaUM7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQW1CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDLFNBQVM7QUFDVCxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGFBQWEsdUJBQXVCO0FBQy9DLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhLHVCQUF1QjtBQUMvQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckMsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3VwZGF0ZVZhbGlkYXRvcnMuanM/NDhkMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBWYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci92YWxpZGF0aW9uJyk7XG5jb25zdCBjbGVhblBvc2l0aW9uYWxPcGVyYXRvcnMgPSByZXF1aXJlKCcuL3NjaGVtYS9jbGVhblBvc2l0aW9uYWxPcGVyYXRvcnMnKTtcbmNvbnN0IGZsYXR0ZW4gPSByZXF1aXJlKCcuL2NvbW1vbicpLmZsYXR0ZW47XG5jb25zdCBtb2RpZmllZFBhdGhzID0gcmVxdWlyZSgnLi9jb21tb24nKS5tb2RpZmllZFBhdGhzO1xuXG4vKipcbiAqIEFwcGxpZXMgdmFsaWRhdG9ycyBhbmQgZGVmYXVsdHMgdG8gdXBkYXRlIGFuZCBmaW5kT25lQW5kVXBkYXRlIG9wZXJhdGlvbnMsXG4gKiBzcGVjaWZpY2FsbHkgcGFzc2luZyBhIG51bGwgZG9jIGFzIGB0aGlzYCB0byB2YWxpZGF0b3JzIGFuZCBkZWZhdWx0c1xuICpcbiAqIEBwYXJhbSB7UXVlcnl9IHF1ZXJ5XG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAcGFyYW0ge09iamVjdH0gY2FzdGVkRG9jXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQG1ldGhvZCBydW5WYWxpZGF0b3JzT25VcGRhdGVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXVlcnksIHNjaGVtYSwgY2FzdGVkRG9jLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoY2FzdGVkRG9jIHx8IHt9KTtcbiAgbGV0IHVwZGF0ZWRLZXlzID0ge307XG4gIGxldCB1cGRhdGVkVmFsdWVzID0ge307XG4gIGNvbnN0IGlzUHVsbCA9IHt9O1xuICBjb25zdCBhcnJheUF0b21pY1VwZGF0ZXMgPSB7fTtcbiAgY29uc3QgbnVtS2V5cyA9IGtleXMubGVuZ3RoO1xuICBsZXQgaGFzRG9sbGFyVXBkYXRlID0gZmFsc2U7XG4gIGNvbnN0IG1vZGlmaWVkID0ge307XG4gIGxldCBjdXJyZW50VXBkYXRlO1xuICBsZXQga2V5O1xuICBsZXQgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbnVtS2V5czsgKytpKSB7XG4gICAgaWYgKGtleXNbaV0uc3RhcnRzV2l0aCgnJCcpKSB7XG4gICAgICBoYXNEb2xsYXJVcGRhdGUgPSB0cnVlO1xuICAgICAgaWYgKGtleXNbaV0gPT09ICckcHVzaCcgfHwga2V5c1tpXSA9PT0gJyRhZGRUb1NldCcpIHtcbiAgICAgICAgY29uc3QgX2tleXMgPSBPYmplY3Qua2V5cyhjYXN0ZWREb2Nba2V5c1tpXV0pO1xuICAgICAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgX2tleXMubGVuZ3RoOyArK2lpKSB7XG4gICAgICAgICAgY3VycmVudFVwZGF0ZSA9IGNhc3RlZERvY1trZXlzW2ldXVtfa2V5c1tpaV1dO1xuICAgICAgICAgIGlmIChjdXJyZW50VXBkYXRlICYmIGN1cnJlbnRVcGRhdGUuJGVhY2gpIHtcbiAgICAgICAgICAgIGFycmF5QXRvbWljVXBkYXRlc1tfa2V5c1tpaV1dID0gKGFycmF5QXRvbWljVXBkYXRlc1tfa2V5c1tpaV1dIHx8IFtdKS5cbiAgICAgICAgICAgICAgY29uY2F0KGN1cnJlbnRVcGRhdGUuJGVhY2gpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcnJheUF0b21pY1VwZGF0ZXNbX2tleXNbaWldXSA9IChhcnJheUF0b21pY1VwZGF0ZXNbX2tleXNbaWldXSB8fCBbXSkuXG4gICAgICAgICAgICAgIGNvbmNhdChbY3VycmVudFVwZGF0ZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG1vZGlmaWVkUGF0aHMoY2FzdGVkRG9jW2tleXNbaV1dLCAnJywgbW9kaWZpZWQpO1xuICAgICAgY29uc3QgZmxhdCA9IGZsYXR0ZW4oY2FzdGVkRG9jW2tleXNbaV1dLCBudWxsLCBudWxsLCBzY2hlbWEpO1xuICAgICAgY29uc3QgcGF0aHMgPSBPYmplY3Qua2V5cyhmbGF0KTtcbiAgICAgIGNvbnN0IG51bVBhdGhzID0gcGF0aHMubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1QYXRoczsgKytqKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRQYXRoID0gY2xlYW5Qb3NpdGlvbmFsT3BlcmF0b3JzKHBhdGhzW2pdKTtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgLy8gV2l0aCBgJHB1bGxgIHdlIG1pZ2h0IGZsYXR0ZW4gYCRpbmAuIFNraXAgc3R1ZmYgbmVzdGVkIHVuZGVyIGAkaW5gXG4gICAgICAgIC8vIGZvciB0aGUgcmVzdCBvZiB0aGUgbG9naWMsIGl0IHdpbGwgZ2V0IGhhbmRsZWQgbGF0ZXIuXG4gICAgICAgIGlmICh1cGRhdGVkUGF0aC5pbmNsdWRlcygnJCcpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleSA9PT0gJyRzZXQnIHx8IGtleSA9PT0gJyRzZXRPbkluc2VydCcgfHxcbiAgICAgICAgICAgIGtleSA9PT0gJyRwdWxsJyB8fCBrZXkgPT09ICckcHVsbEFsbCcpIHtcbiAgICAgICAgICB1cGRhdGVkVmFsdWVzW3VwZGF0ZWRQYXRoXSA9IGZsYXRbcGF0aHNbal1dO1xuICAgICAgICAgIGlzUHVsbFt1cGRhdGVkUGF0aF0gPSBrZXkgPT09ICckcHVsbCcgfHwga2V5ID09PSAnJHB1bGxBbGwnO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJyR1bnNldCcpIHtcbiAgICAgICAgICB1cGRhdGVkVmFsdWVzW3VwZGF0ZWRQYXRoXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVkS2V5c1t1cGRhdGVkUGF0aF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghaGFzRG9sbGFyVXBkYXRlKSB7XG4gICAgbW9kaWZpZWRQYXRocyhjYXN0ZWREb2MsICcnLCBtb2RpZmllZCk7XG4gICAgdXBkYXRlZFZhbHVlcyA9IGZsYXR0ZW4oY2FzdGVkRG9jLCBudWxsLCBudWxsLCBzY2hlbWEpO1xuICAgIHVwZGF0ZWRLZXlzID0gT2JqZWN0LmtleXModXBkYXRlZFZhbHVlcyk7XG4gIH1cblxuICBjb25zdCB1cGRhdGVzID0gT2JqZWN0LmtleXModXBkYXRlZFZhbHVlcyk7XG4gIGNvbnN0IG51bVVwZGF0ZXMgPSB1cGRhdGVzLmxlbmd0aDtcbiAgY29uc3QgdmFsaWRhdG9yc1RvRXhlY3V0ZSA9IFtdO1xuICBjb25zdCB2YWxpZGF0aW9uRXJyb3JzID0gW107XG5cbiAgY29uc3QgYWxyZWFkeVZhbGlkYXRlZCA9IFtdO1xuXG4gIGNvbnN0IGNvbnRleHQgPSBxdWVyeTtcbiAgZnVuY3Rpb24gaXRlcihpLCB2KSB7XG4gICAgY29uc3Qgc2NoZW1hUGF0aCA9IHNjaGVtYS5fZ2V0U2NoZW1hKHVwZGF0ZXNbaV0pO1xuICAgIGlmIChzY2hlbWFQYXRoID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNjaGVtYVBhdGguaW5zdGFuY2UgPT09ICdNaXhlZCcgJiYgc2NoZW1hUGF0aC5wYXRoICE9PSB1cGRhdGVzW2ldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHYgJiYgQXJyYXkuaXNBcnJheSh2LiRpbikpIHtcbiAgICAgIHYuJGluLmZvckVhY2goKHYsIGkpID0+IHtcbiAgICAgICAgdmFsaWRhdG9yc1RvRXhlY3V0ZS5wdXNoKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgc2NoZW1hUGF0aC5kb1ZhbGlkYXRlKFxuICAgICAgICAgICAgdixcbiAgICAgICAgICAgIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZXJyLnBhdGggPSB1cGRhdGVzW2ldICsgJy4kaW4uJyArIGk7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvbkVycm9ycy5wdXNoKGVycik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIHsgdXBkYXRlVmFsaWRhdG9yOiB0cnVlIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNQdWxsW3VwZGF0ZXNbaV1dICYmXG4gICAgICAgICAgc2NoZW1hUGF0aC4kaXNNb25nb29zZUFycmF5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNjaGVtYVBhdGguJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5RWxlbWVudCAmJiB2ICE9IG51bGwgJiYgdi4kX18gIT0gbnVsbCkge1xuICAgICAgICBhbHJlYWR5VmFsaWRhdGVkLnB1c2godXBkYXRlc1tpXSk7XG4gICAgICAgIHZhbGlkYXRvcnNUb0V4ZWN1dGUucHVzaChmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgIHNjaGVtYVBhdGguZG9WYWxpZGF0ZSh2LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgaWYgKGVyci5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhlcnIuZXJyb3JzKSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgX2VyciA9IGVyci5lcnJvcnNba2V5XTtcbiAgICAgICAgICAgICAgICAgIF9lcnIucGF0aCA9IHVwZGF0ZXNbaV0gKyAnLicgKyBrZXk7XG4gICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uRXJyb3JzLnB1c2goX2Vycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVyci5wYXRoID0gdXBkYXRlc1tpXTtcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uRXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgfSwgY29udGV4dCwgeyB1cGRhdGVWYWxpZGF0b3I6IHRydWUgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsaWRhdG9yc1RvRXhlY3V0ZS5wdXNoKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBwYXRoIG9mIGFscmVhZHlWYWxpZGF0ZWQpIHtcbiAgICAgICAgICAgIGlmICh1cGRhdGVzW2ldLnN0YXJ0c1dpdGgocGF0aCArICcuJykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHNjaGVtYVBhdGguZG9WYWxpZGF0ZSh2LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWFQYXRoLnNjaGVtYSAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgc2NoZW1hUGF0aC5zY2hlbWEub3B0aW9ucy5zdG9yZVN1YmRvY1ZhbGlkYXRpb25FcnJvciA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICBlcnIgaW5zdGFuY2VvZiBWYWxpZGF0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIGVyci5wYXRoID0gdXBkYXRlc1tpXTtcbiAgICAgICAgICAgICAgdmFsaWRhdGlvbkVycm9ycy5wdXNoKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICB9LCBjb250ZXh0LCB7IHVwZGF0ZVZhbGlkYXRvcjogdHJ1ZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBudW1VcGRhdGVzOyArK2kpIHtcbiAgICBpdGVyKGksIHVwZGF0ZWRWYWx1ZXNbdXBkYXRlc1tpXV0pO1xuICB9XG5cbiAgY29uc3QgYXJyYXlVcGRhdGVzID0gT2JqZWN0LmtleXMoYXJyYXlBdG9taWNVcGRhdGVzKTtcbiAgZm9yIChjb25zdCBhcnJheVVwZGF0ZSBvZiBhcnJheVVwZGF0ZXMpIHtcbiAgICBsZXQgc2NoZW1hUGF0aCA9IHNjaGVtYS5fZ2V0U2NoZW1hKGFycmF5VXBkYXRlKTtcbiAgICBpZiAoc2NoZW1hUGF0aCAmJiBzY2hlbWFQYXRoLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSkge1xuICAgICAgdmFsaWRhdG9yc1RvRXhlY3V0ZS5wdXNoKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIHNjaGVtYVBhdGguZG9WYWxpZGF0ZShcbiAgICAgICAgICBhcnJheUF0b21pY1VwZGF0ZXNbYXJyYXlVcGRhdGVdLFxuICAgICAgICAgIGdldFZhbGlkYXRpb25DYWxsYmFjayhhcnJheVVwZGF0ZSwgdmFsaWRhdGlvbkVycm9ycywgY2FsbGJhY2spLFxuICAgICAgICAgIG9wdGlvbnMgJiYgb3B0aW9ucy5jb250ZXh0ID09PSAncXVlcnknID8gcXVlcnkgOiBudWxsKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlbWFQYXRoID0gc2NoZW1hLl9nZXRTY2hlbWEoYXJyYXlVcGRhdGUgKyAnLjAnKTtcbiAgICAgIGZvciAoY29uc3QgYXRvbWljVXBkYXRlIG9mIGFycmF5QXRvbWljVXBkYXRlc1thcnJheVVwZGF0ZV0pIHtcbiAgICAgICAgdmFsaWRhdG9yc1RvRXhlY3V0ZS5wdXNoKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgc2NoZW1hUGF0aC5kb1ZhbGlkYXRlKFxuICAgICAgICAgICAgYXRvbWljVXBkYXRlLFxuICAgICAgICAgICAgZ2V0VmFsaWRhdGlvbkNhbGxiYWNrKGFycmF5VXBkYXRlLCB2YWxpZGF0aW9uRXJyb3JzLCBjYWxsYmFjayksXG4gICAgICAgICAgICBvcHRpb25zICYmIG9wdGlvbnMuY29udGV4dCA9PT0gJ3F1ZXJ5JyA/IHF1ZXJ5IDogbnVsbCxcbiAgICAgICAgICAgIHsgdXBkYXRlVmFsaWRhdG9yOiB0cnVlIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkge1xuICAgIGxldCBudW1WYWxpZGF0b3JzID0gdmFsaWRhdG9yc1RvRXhlY3V0ZS5sZW5ndGg7XG4gICAgaWYgKG51bVZhbGlkYXRvcnMgPT09IDApIHtcbiAgICAgIHJldHVybiBfZG9uZShjYWxsYmFjayk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgdmFsaWRhdG9yIG9mIHZhbGlkYXRvcnNUb0V4ZWN1dGUpIHtcbiAgICAgIHZhbGlkYXRvcihmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKC0tbnVtVmFsaWRhdG9ycyA8PSAwKSB7XG4gICAgICAgICAgX2RvbmUoY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBsZXQgbnVtVmFsaWRhdG9ycyA9IHZhbGlkYXRvcnNUb0V4ZWN1dGUubGVuZ3RoO1xuICAgIGlmIChudW1WYWxpZGF0b3JzID09PSAwKSB7XG4gICAgICByZXR1cm4gX2RvbmUoY2FsbGJhY2spO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHZhbGlkYXRvciBvZiB2YWxpZGF0b3JzVG9FeGVjdXRlKSB7XG4gICAgICB2YWxpZGF0b3IoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgtLW51bVZhbGlkYXRvcnMgPD0gMCkge1xuICAgICAgICAgIF9kb25lKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIF9kb25lKGNhbGxiYWNrKSB7XG4gICAgaWYgKHZhbGlkYXRpb25FcnJvcnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgVmFsaWRhdGlvbkVycm9yKG51bGwpO1xuXG4gICAgICBmb3IgKGNvbnN0IHZhbGlkYXRpb25FcnJvciBvZiB2YWxpZGF0aW9uRXJyb3JzKSB7XG4gICAgICAgIGVyci5hZGRFcnJvcih2YWxpZGF0aW9uRXJyb3IucGF0aCwgdmFsaWRhdGlvbkVycm9yKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgfVxuICAgIGNhbGxiYWNrKG51bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VmFsaWRhdGlvbkNhbGxiYWNrKGFycmF5VXBkYXRlLCB2YWxpZGF0aW9uRXJyb3JzLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZXJyLnBhdGggPSBhcnJheVVwZGF0ZTtcbiAgICAgICAgdmFsaWRhdGlvbkVycm9ycy5wdXNoKGVycik7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhudWxsKTtcbiAgICB9O1xuICB9XG59O1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/updateValidators.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/update/applyTimestampsToChildren.js":
/*!****************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/update/applyTimestampsToChildren.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst cleanPositionalOperators = __webpack_require__(/*! ../schema/cleanPositionalOperators */ \"../backend/node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js\");\nconst handleTimestampOption = __webpack_require__(/*! ../schema/handleTimestampOption */ \"../backend/node_modules/mongoose/lib/helpers/schema/handleTimestampOption.js\");\n\nmodule.exports = applyTimestampsToChildren;\n\n/*!\n * ignore\n */\n\nfunction applyTimestampsToChildren(now, update, schema) {\n  if (update == null) {\n    return;\n  }\n\n  const keys = Object.keys(update);\n  const hasDollarKey = keys.some(key => key[0] === '$');\n\n  if (hasDollarKey) {\n    if (update.$push) {\n      _applyTimestampToUpdateOperator(update.$push);\n    }\n    if (update.$addToSet) {\n      _applyTimestampToUpdateOperator(update.$addToSet);\n    }\n    if (update.$set != null) {\n      const keys = Object.keys(update.$set);\n      for (const key of keys) {\n        applyTimestampsToUpdateKey(schema, key, update.$set, now);\n      }\n    }\n    if (update.$setOnInsert != null) {\n      const keys = Object.keys(update.$setOnInsert);\n      for (const key of keys) {\n        applyTimestampsToUpdateKey(schema, key, update.$setOnInsert, now);\n      }\n    }\n  }\n\n  const updateKeys = Object.keys(update).filter(key => key[0] !== '$');\n  for (const key of updateKeys) {\n    applyTimestampsToUpdateKey(schema, key, update, now);\n  }\n\n  function _applyTimestampToUpdateOperator(op) {\n    for (const key of Object.keys(op)) {\n      const $path = schema.path(key.replace(/\\.\\$\\./i, '.').replace(/.\\$$/, ''));\n      if (op[key] &&\n          $path &&\n          $path.$isMongooseDocumentArray &&\n          $path.schema.options.timestamps) {\n        const timestamps = $path.schema.options.timestamps;\n        const createdAt = handleTimestampOption(timestamps, 'createdAt');\n        const updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n        if (op[key].$each) {\n          op[key].$each.forEach(function(subdoc) {\n            if (updatedAt != null) {\n              subdoc[updatedAt] = now;\n            }\n            if (createdAt != null) {\n              subdoc[createdAt] = now;\n            }\n\n            applyTimestampsToChildren(now, subdoc, $path.schema);\n          });\n        } else {\n          if (updatedAt != null) {\n            op[key][updatedAt] = now;\n          }\n          if (createdAt != null) {\n            op[key][createdAt] = now;\n          }\n\n          applyTimestampsToChildren(now, op[key], $path.schema);\n        }\n      }\n    }\n  }\n}\n\nfunction applyTimestampsToDocumentArray(arr, schematype, now) {\n  const timestamps = schematype.schema.options.timestamps;\n\n  const len = arr.length;\n\n  if (!timestamps) {\n    for (let i = 0; i < len; ++i) {\n      applyTimestampsToChildren(now, arr[i], schematype.schema);\n    }\n    return;\n  }\n\n  const createdAt = handleTimestampOption(timestamps, 'createdAt');\n  const updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n  for (let i = 0; i < len; ++i) {\n    if (updatedAt != null) {\n      arr[i][updatedAt] = now;\n    }\n    if (createdAt != null) {\n      arr[i][createdAt] = now;\n    }\n\n    applyTimestampsToChildren(now, arr[i], schematype.schema);\n  }\n}\n\nfunction applyTimestampsToSingleNested(subdoc, schematype, now) {\n  const timestamps = schematype.schema.options.timestamps;\n  if (!timestamps) {\n    applyTimestampsToChildren(now, subdoc, schematype.schema);\n    return;\n  }\n\n  const createdAt = handleTimestampOption(timestamps, 'createdAt');\n  const updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n  if (updatedAt != null) {\n    subdoc[updatedAt] = now;\n  }\n  if (createdAt != null) {\n    subdoc[createdAt] = now;\n  }\n\n  applyTimestampsToChildren(now, subdoc, schematype.schema);\n}\n\nfunction applyTimestampsToUpdateKey(schema, key, update, now) {\n  // Replace positional operator `$` and array filters `$[]` and `$[.*]`\n  const keyToSearch = cleanPositionalOperators(key);\n  const path = schema.path(keyToSearch);\n  if (!path) {\n    return;\n  }\n\n  const parentSchemaTypes = [];\n  const pieces = keyToSearch.split('.');\n  for (let i = pieces.length - 1; i > 0; --i) {\n    const s = schema.path(pieces.slice(0, i).join('.'));\n    if (s != null &&\n      (s.$isMongooseDocumentArray || s.$isSingleNested)) {\n      parentSchemaTypes.push({ parentPath: key.split('.').slice(0, i).join('.'), parentSchemaType: s });\n    }\n  }\n\n  if (Array.isArray(update[key]) && path.$isMongooseDocumentArray) {\n    applyTimestampsToDocumentArray(update[key], path, now);\n  } else if (update[key] && path.$isSingleNested) {\n    applyTimestampsToSingleNested(update[key], path, now);\n  } else if (parentSchemaTypes.length > 0) {\n    for (const item of parentSchemaTypes) {\n      const parentPath = item.parentPath;\n      const parentSchemaType = item.parentSchemaType;\n      const timestamps = parentSchemaType.schema.options.timestamps;\n      const updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n\n      if (!timestamps || updatedAt == null) {\n        continue;\n      }\n\n      if (parentSchemaType.$isSingleNested) {\n        // Single nested is easy\n        update[parentPath + '.' + updatedAt] = now;\n      } else if (parentSchemaType.$isMongooseDocumentArray) {\n        let childPath = key.substring(parentPath.length + 1);\n\n        if (/^\\d+$/.test(childPath)) {\n          update[parentPath + '.' + childPath][updatedAt] = now;\n          continue;\n        }\n\n        const firstDot = childPath.indexOf('.');\n        childPath = firstDot !== -1 ? childPath.substring(0, firstDot) : childPath;\n\n        update[parentPath + '.' + childPath + '.' + updatedAt] = now;\n      }\n    }\n  } else if (path.schema != null && path.schema != schema && update[key]) {\n    const timestamps = path.schema.options.timestamps;\n    const createdAt = handleTimestampOption(timestamps, 'createdAt');\n    const updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n\n    if (!timestamps) {\n      return;\n    }\n\n    if (updatedAt != null) {\n      update[key][updatedAt] = now;\n    }\n    if (createdAt != null) {\n      update[key][createdAt] = now;\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdXBkYXRlL2FwcGx5VGltZXN0YW1wc1RvQ2hpbGRyZW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsaUNBQWlDLG1CQUFPLENBQUMsMkhBQW9DO0FBQzdFLDhCQUE4QixtQkFBTyxDQUFDLHFIQUFpQzs7QUFFdkU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix1RUFBdUU7QUFDdEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy91cGRhdGUvYXBwbHlUaW1lc3RhbXBzVG9DaGlsZHJlbi5qcz81Yzk5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgY2xlYW5Qb3NpdGlvbmFsT3BlcmF0b3JzID0gcmVxdWlyZSgnLi4vc2NoZW1hL2NsZWFuUG9zaXRpb25hbE9wZXJhdG9ycycpO1xuY29uc3QgaGFuZGxlVGltZXN0YW1wT3B0aW9uID0gcmVxdWlyZSgnLi4vc2NoZW1hL2hhbmRsZVRpbWVzdGFtcE9wdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFwcGx5VGltZXN0YW1wc1RvQ2hpbGRyZW47XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gYXBwbHlUaW1lc3RhbXBzVG9DaGlsZHJlbihub3csIHVwZGF0ZSwgc2NoZW1hKSB7XG4gIGlmICh1cGRhdGUgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh1cGRhdGUpO1xuICBjb25zdCBoYXNEb2xsYXJLZXkgPSBrZXlzLnNvbWUoa2V5ID0+IGtleVswXSA9PT0gJyQnKTtcblxuICBpZiAoaGFzRG9sbGFyS2V5KSB7XG4gICAgaWYgKHVwZGF0ZS4kcHVzaCkge1xuICAgICAgX2FwcGx5VGltZXN0YW1wVG9VcGRhdGVPcGVyYXRvcih1cGRhdGUuJHB1c2gpO1xuICAgIH1cbiAgICBpZiAodXBkYXRlLiRhZGRUb1NldCkge1xuICAgICAgX2FwcGx5VGltZXN0YW1wVG9VcGRhdGVPcGVyYXRvcih1cGRhdGUuJGFkZFRvU2V0KTtcbiAgICB9XG4gICAgaWYgKHVwZGF0ZS4kc2V0ICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh1cGRhdGUuJHNldCk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGFwcGx5VGltZXN0YW1wc1RvVXBkYXRlS2V5KHNjaGVtYSwga2V5LCB1cGRhdGUuJHNldCwgbm93KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHVwZGF0ZS4kc2V0T25JbnNlcnQgIT0gbnVsbCkge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHVwZGF0ZS4kc2V0T25JbnNlcnQpO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBhcHBseVRpbWVzdGFtcHNUb1VwZGF0ZUtleShzY2hlbWEsIGtleSwgdXBkYXRlLiRzZXRPbkluc2VydCwgbm93KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCB1cGRhdGVLZXlzID0gT2JqZWN0LmtleXModXBkYXRlKS5maWx0ZXIoa2V5ID0+IGtleVswXSAhPT0gJyQnKTtcbiAgZm9yIChjb25zdCBrZXkgb2YgdXBkYXRlS2V5cykge1xuICAgIGFwcGx5VGltZXN0YW1wc1RvVXBkYXRlS2V5KHNjaGVtYSwga2V5LCB1cGRhdGUsIG5vdyk7XG4gIH1cblxuICBmdW5jdGlvbiBfYXBwbHlUaW1lc3RhbXBUb1VwZGF0ZU9wZXJhdG9yKG9wKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob3ApKSB7XG4gICAgICBjb25zdCAkcGF0aCA9IHNjaGVtYS5wYXRoKGtleS5yZXBsYWNlKC9cXC5cXCRcXC4vaSwgJy4nKS5yZXBsYWNlKC8uXFwkJC8sICcnKSk7XG4gICAgICBpZiAob3Bba2V5XSAmJlxuICAgICAgICAgICRwYXRoICYmXG4gICAgICAgICAgJHBhdGguJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5ICYmXG4gICAgICAgICAgJHBhdGguc2NoZW1hLm9wdGlvbnMudGltZXN0YW1wcykge1xuICAgICAgICBjb25zdCB0aW1lc3RhbXBzID0gJHBhdGguc2NoZW1hLm9wdGlvbnMudGltZXN0YW1wcztcbiAgICAgICAgY29uc3QgY3JlYXRlZEF0ID0gaGFuZGxlVGltZXN0YW1wT3B0aW9uKHRpbWVzdGFtcHMsICdjcmVhdGVkQXQnKTtcbiAgICAgICAgY29uc3QgdXBkYXRlZEF0ID0gaGFuZGxlVGltZXN0YW1wT3B0aW9uKHRpbWVzdGFtcHMsICd1cGRhdGVkQXQnKTtcbiAgICAgICAgaWYgKG9wW2tleV0uJGVhY2gpIHtcbiAgICAgICAgICBvcFtrZXldLiRlYWNoLmZvckVhY2goZnVuY3Rpb24oc3ViZG9jKSB7XG4gICAgICAgICAgICBpZiAodXBkYXRlZEF0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgc3ViZG9jW3VwZGF0ZWRBdF0gPSBub3c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3JlYXRlZEF0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgc3ViZG9jW2NyZWF0ZWRBdF0gPSBub3c7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFwcGx5VGltZXN0YW1wc1RvQ2hpbGRyZW4obm93LCBzdWJkb2MsICRwYXRoLnNjaGVtYSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHVwZGF0ZWRBdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBvcFtrZXldW3VwZGF0ZWRBdF0gPSBub3c7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjcmVhdGVkQXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgb3Bba2V5XVtjcmVhdGVkQXRdID0gbm93O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFwcGx5VGltZXN0YW1wc1RvQ2hpbGRyZW4obm93LCBvcFtrZXldLCAkcGF0aC5zY2hlbWEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VGltZXN0YW1wc1RvRG9jdW1lbnRBcnJheShhcnIsIHNjaGVtYXR5cGUsIG5vdykge1xuICBjb25zdCB0aW1lc3RhbXBzID0gc2NoZW1hdHlwZS5zY2hlbWEub3B0aW9ucy50aW1lc3RhbXBzO1xuXG4gIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgaWYgKCF0aW1lc3RhbXBzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgYXBwbHlUaW1lc3RhbXBzVG9DaGlsZHJlbihub3csIGFycltpXSwgc2NoZW1hdHlwZS5zY2hlbWEpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBjcmVhdGVkQXQgPSBoYW5kbGVUaW1lc3RhbXBPcHRpb24odGltZXN0YW1wcywgJ2NyZWF0ZWRBdCcpO1xuICBjb25zdCB1cGRhdGVkQXQgPSBoYW5kbGVUaW1lc3RhbXBPcHRpb24odGltZXN0YW1wcywgJ3VwZGF0ZWRBdCcpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHVwZGF0ZWRBdCAhPSBudWxsKSB7XG4gICAgICBhcnJbaV1bdXBkYXRlZEF0XSA9IG5vdztcbiAgICB9XG4gICAgaWYgKGNyZWF0ZWRBdCAhPSBudWxsKSB7XG4gICAgICBhcnJbaV1bY3JlYXRlZEF0XSA9IG5vdztcbiAgICB9XG5cbiAgICBhcHBseVRpbWVzdGFtcHNUb0NoaWxkcmVuKG5vdywgYXJyW2ldLCBzY2hlbWF0eXBlLnNjaGVtYSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUaW1lc3RhbXBzVG9TaW5nbGVOZXN0ZWQoc3ViZG9jLCBzY2hlbWF0eXBlLCBub3cpIHtcbiAgY29uc3QgdGltZXN0YW1wcyA9IHNjaGVtYXR5cGUuc2NoZW1hLm9wdGlvbnMudGltZXN0YW1wcztcbiAgaWYgKCF0aW1lc3RhbXBzKSB7XG4gICAgYXBwbHlUaW1lc3RhbXBzVG9DaGlsZHJlbihub3csIHN1YmRvYywgc2NoZW1hdHlwZS5zY2hlbWEpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGNyZWF0ZWRBdCA9IGhhbmRsZVRpbWVzdGFtcE9wdGlvbih0aW1lc3RhbXBzLCAnY3JlYXRlZEF0Jyk7XG4gIGNvbnN0IHVwZGF0ZWRBdCA9IGhhbmRsZVRpbWVzdGFtcE9wdGlvbih0aW1lc3RhbXBzLCAndXBkYXRlZEF0Jyk7XG4gIGlmICh1cGRhdGVkQXQgIT0gbnVsbCkge1xuICAgIHN1YmRvY1t1cGRhdGVkQXRdID0gbm93O1xuICB9XG4gIGlmIChjcmVhdGVkQXQgIT0gbnVsbCkge1xuICAgIHN1YmRvY1tjcmVhdGVkQXRdID0gbm93O1xuICB9XG5cbiAgYXBwbHlUaW1lc3RhbXBzVG9DaGlsZHJlbihub3csIHN1YmRvYywgc2NoZW1hdHlwZS5zY2hlbWEpO1xufVxuXG5mdW5jdGlvbiBhcHBseVRpbWVzdGFtcHNUb1VwZGF0ZUtleShzY2hlbWEsIGtleSwgdXBkYXRlLCBub3cpIHtcbiAgLy8gUmVwbGFjZSBwb3NpdGlvbmFsIG9wZXJhdG9yIGAkYCBhbmQgYXJyYXkgZmlsdGVycyBgJFtdYCBhbmQgYCRbLipdYFxuICBjb25zdCBrZXlUb1NlYXJjaCA9IGNsZWFuUG9zaXRpb25hbE9wZXJhdG9ycyhrZXkpO1xuICBjb25zdCBwYXRoID0gc2NoZW1hLnBhdGgoa2V5VG9TZWFyY2gpO1xuICBpZiAoIXBhdGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBwYXJlbnRTY2hlbWFUeXBlcyA9IFtdO1xuICBjb25zdCBwaWVjZXMgPSBrZXlUb1NlYXJjaC5zcGxpdCgnLicpO1xuICBmb3IgKGxldCBpID0gcGllY2VzLmxlbmd0aCAtIDE7IGkgPiAwOyAtLWkpIHtcbiAgICBjb25zdCBzID0gc2NoZW1hLnBhdGgocGllY2VzLnNsaWNlKDAsIGkpLmpvaW4oJy4nKSk7XG4gICAgaWYgKHMgIT0gbnVsbCAmJlxuICAgICAgKHMuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5IHx8IHMuJGlzU2luZ2xlTmVzdGVkKSkge1xuICAgICAgcGFyZW50U2NoZW1hVHlwZXMucHVzaCh7IHBhcmVudFBhdGg6IGtleS5zcGxpdCgnLicpLnNsaWNlKDAsIGkpLmpvaW4oJy4nKSwgcGFyZW50U2NoZW1hVHlwZTogcyB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh1cGRhdGVba2V5XSkgJiYgcGF0aC4kaXNNb25nb29zZURvY3VtZW50QXJyYXkpIHtcbiAgICBhcHBseVRpbWVzdGFtcHNUb0RvY3VtZW50QXJyYXkodXBkYXRlW2tleV0sIHBhdGgsIG5vdyk7XG4gIH0gZWxzZSBpZiAodXBkYXRlW2tleV0gJiYgcGF0aC4kaXNTaW5nbGVOZXN0ZWQpIHtcbiAgICBhcHBseVRpbWVzdGFtcHNUb1NpbmdsZU5lc3RlZCh1cGRhdGVba2V5XSwgcGF0aCwgbm93KTtcbiAgfSBlbHNlIGlmIChwYXJlbnRTY2hlbWFUeXBlcy5sZW5ndGggPiAwKSB7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHBhcmVudFNjaGVtYVR5cGVzKSB7XG4gICAgICBjb25zdCBwYXJlbnRQYXRoID0gaXRlbS5wYXJlbnRQYXRoO1xuICAgICAgY29uc3QgcGFyZW50U2NoZW1hVHlwZSA9IGl0ZW0ucGFyZW50U2NoZW1hVHlwZTtcbiAgICAgIGNvbnN0IHRpbWVzdGFtcHMgPSBwYXJlbnRTY2hlbWFUeXBlLnNjaGVtYS5vcHRpb25zLnRpbWVzdGFtcHM7XG4gICAgICBjb25zdCB1cGRhdGVkQXQgPSBoYW5kbGVUaW1lc3RhbXBPcHRpb24odGltZXN0YW1wcywgJ3VwZGF0ZWRBdCcpO1xuXG4gICAgICBpZiAoIXRpbWVzdGFtcHMgfHwgdXBkYXRlZEF0ID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJlbnRTY2hlbWFUeXBlLiRpc1NpbmdsZU5lc3RlZCkge1xuICAgICAgICAvLyBTaW5nbGUgbmVzdGVkIGlzIGVhc3lcbiAgICAgICAgdXBkYXRlW3BhcmVudFBhdGggKyAnLicgKyB1cGRhdGVkQXRdID0gbm93O1xuICAgICAgfSBlbHNlIGlmIChwYXJlbnRTY2hlbWFUeXBlLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSkge1xuICAgICAgICBsZXQgY2hpbGRQYXRoID0ga2V5LnN1YnN0cmluZyhwYXJlbnRQYXRoLmxlbmd0aCArIDEpO1xuXG4gICAgICAgIGlmICgvXlxcZCskLy50ZXN0KGNoaWxkUGF0aCkpIHtcbiAgICAgICAgICB1cGRhdGVbcGFyZW50UGF0aCArICcuJyArIGNoaWxkUGF0aF1bdXBkYXRlZEF0XSA9IG5vdztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZpcnN0RG90ID0gY2hpbGRQYXRoLmluZGV4T2YoJy4nKTtcbiAgICAgICAgY2hpbGRQYXRoID0gZmlyc3REb3QgIT09IC0xID8gY2hpbGRQYXRoLnN1YnN0cmluZygwLCBmaXJzdERvdCkgOiBjaGlsZFBhdGg7XG5cbiAgICAgICAgdXBkYXRlW3BhcmVudFBhdGggKyAnLicgKyBjaGlsZFBhdGggKyAnLicgKyB1cGRhdGVkQXRdID0gbm93O1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChwYXRoLnNjaGVtYSAhPSBudWxsICYmIHBhdGguc2NoZW1hICE9IHNjaGVtYSAmJiB1cGRhdGVba2V5XSkge1xuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSBwYXRoLnNjaGVtYS5vcHRpb25zLnRpbWVzdGFtcHM7XG4gICAgY29uc3QgY3JlYXRlZEF0ID0gaGFuZGxlVGltZXN0YW1wT3B0aW9uKHRpbWVzdGFtcHMsICdjcmVhdGVkQXQnKTtcbiAgICBjb25zdCB1cGRhdGVkQXQgPSBoYW5kbGVUaW1lc3RhbXBPcHRpb24odGltZXN0YW1wcywgJ3VwZGF0ZWRBdCcpO1xuXG4gICAgaWYgKCF0aW1lc3RhbXBzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHVwZGF0ZWRBdCAhPSBudWxsKSB7XG4gICAgICB1cGRhdGVba2V5XVt1cGRhdGVkQXRdID0gbm93O1xuICAgIH1cbiAgICBpZiAoY3JlYXRlZEF0ICE9IG51bGwpIHtcbiAgICAgIHVwZGF0ZVtrZXldW2NyZWF0ZWRBdF0gPSBub3c7XG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/update/applyTimestampsToChildren.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/update/applyTimestampsToUpdate.js":
/*!**************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/update/applyTimestampsToUpdate.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nconst get = __webpack_require__(/*! ../get */ \"../backend/node_modules/mongoose/lib/helpers/get.js\");\n\nmodule.exports = applyTimestampsToUpdate;\n\n/*!\n * ignore\n */\n\nfunction applyTimestampsToUpdate(now, createdAt, updatedAt, currentUpdate, options, isReplace) {\n  const updates = currentUpdate;\n  let _updates = updates;\n  const timestamps = get(options, 'timestamps', true);\n\n  // Support skipping timestamps at the query level, see gh-6980\n  if (!timestamps || updates == null) {\n    return currentUpdate;\n  }\n\n  const skipCreatedAt = timestamps != null && timestamps.createdAt === false;\n  const skipUpdatedAt = timestamps != null && timestamps.updatedAt === false;\n\n  if (isReplace) {\n    if (currentUpdate && currentUpdate.$set) {\n      currentUpdate = currentUpdate.$set;\n      updates.$set = {};\n      _updates = updates.$set;\n    }\n    if (!skipUpdatedAt && updatedAt && !currentUpdate[updatedAt]) {\n      _updates[updatedAt] = now;\n    }\n    if (!skipCreatedAt && createdAt && !currentUpdate[createdAt]) {\n      _updates[createdAt] = now;\n    }\n    return updates;\n  }\n  currentUpdate = currentUpdate || {};\n\n  if (Array.isArray(updates)) {\n    // Update with aggregation pipeline\n    if (updatedAt == null) {\n      return updates;\n    }\n    updates.push({ $set: { [updatedAt]: now } });\n    return updates;\n  }\n  updates.$set = updates.$set || {};\n  if (!skipUpdatedAt && updatedAt &&\n      (!currentUpdate.$currentDate || !currentUpdate.$currentDate[updatedAt])) {\n    let timestampSet = false;\n    if (updatedAt.indexOf('.') !== -1) {\n      const pieces = updatedAt.split('.');\n      for (let i = 1; i < pieces.length; ++i) {\n        const remnant = pieces.slice(-i).join('.');\n        const start = pieces.slice(0, -i).join('.');\n        if (currentUpdate[start] != null) {\n          currentUpdate[start][remnant] = now;\n          timestampSet = true;\n          break;\n        } else if (currentUpdate.$set && currentUpdate.$set[start]) {\n          currentUpdate.$set[start][remnant] = now;\n          timestampSet = true;\n          break;\n        }\n      }\n    }\n\n    if (!timestampSet) {\n      updates.$set[updatedAt] = now;\n    }\n\n    if (updates.hasOwnProperty(updatedAt)) {\n      delete updates[updatedAt];\n    }\n  }\n\n  if (!skipCreatedAt && createdAt) {\n    if (currentUpdate[createdAt]) {\n      delete currentUpdate[createdAt];\n    }\n    if (currentUpdate.$set && currentUpdate.$set[createdAt]) {\n      delete currentUpdate.$set[createdAt];\n    }\n    let timestampSet = false;\n    if (createdAt.indexOf('.') !== -1) {\n      const pieces = createdAt.split('.');\n      for (let i = 1; i < pieces.length; ++i) {\n        const remnant = pieces.slice(-i).join('.');\n        const start = pieces.slice(0, -i).join('.');\n        if (currentUpdate[start] != null) {\n          currentUpdate[start][remnant] = now;\n          timestampSet = true;\n          break;\n        } else if (currentUpdate.$set && currentUpdate.$set[start]) {\n          currentUpdate.$set[start][remnant] = now;\n          timestampSet = true;\n          break;\n        }\n      }\n    }\n\n    if (!timestampSet) {\n      updates.$setOnInsert = updates.$setOnInsert || {};\n      updates.$setOnInsert[createdAt] = now;\n    }\n  }\n\n  if (Object.keys(updates.$set).length === 0) {\n    delete updates.$set;\n  }\n  return updates;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdXBkYXRlL2FwcGx5VGltZXN0YW1wc1RvVXBkYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLG1CQUFPLENBQUMsbUVBQVE7O0FBRTVCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVEsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3VwZGF0ZS9hcHBseVRpbWVzdGFtcHNUb1VwZGF0ZS5qcz83Mjg4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5jb25zdCBnZXQgPSByZXF1aXJlKCcuLi9nZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBhcHBseVRpbWVzdGFtcHNUb1VwZGF0ZTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBhcHBseVRpbWVzdGFtcHNUb1VwZGF0ZShub3csIGNyZWF0ZWRBdCwgdXBkYXRlZEF0LCBjdXJyZW50VXBkYXRlLCBvcHRpb25zLCBpc1JlcGxhY2UpIHtcbiAgY29uc3QgdXBkYXRlcyA9IGN1cnJlbnRVcGRhdGU7XG4gIGxldCBfdXBkYXRlcyA9IHVwZGF0ZXM7XG4gIGNvbnN0IHRpbWVzdGFtcHMgPSBnZXQob3B0aW9ucywgJ3RpbWVzdGFtcHMnLCB0cnVlKTtcblxuICAvLyBTdXBwb3J0IHNraXBwaW5nIHRpbWVzdGFtcHMgYXQgdGhlIHF1ZXJ5IGxldmVsLCBzZWUgZ2gtNjk4MFxuICBpZiAoIXRpbWVzdGFtcHMgfHwgdXBkYXRlcyA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRVcGRhdGU7XG4gIH1cblxuICBjb25zdCBza2lwQ3JlYXRlZEF0ID0gdGltZXN0YW1wcyAhPSBudWxsICYmIHRpbWVzdGFtcHMuY3JlYXRlZEF0ID09PSBmYWxzZTtcbiAgY29uc3Qgc2tpcFVwZGF0ZWRBdCA9IHRpbWVzdGFtcHMgIT0gbnVsbCAmJiB0aW1lc3RhbXBzLnVwZGF0ZWRBdCA9PT0gZmFsc2U7XG5cbiAgaWYgKGlzUmVwbGFjZSkge1xuICAgIGlmIChjdXJyZW50VXBkYXRlICYmIGN1cnJlbnRVcGRhdGUuJHNldCkge1xuICAgICAgY3VycmVudFVwZGF0ZSA9IGN1cnJlbnRVcGRhdGUuJHNldDtcbiAgICAgIHVwZGF0ZXMuJHNldCA9IHt9O1xuICAgICAgX3VwZGF0ZXMgPSB1cGRhdGVzLiRzZXQ7XG4gICAgfVxuICAgIGlmICghc2tpcFVwZGF0ZWRBdCAmJiB1cGRhdGVkQXQgJiYgIWN1cnJlbnRVcGRhdGVbdXBkYXRlZEF0XSkge1xuICAgICAgX3VwZGF0ZXNbdXBkYXRlZEF0XSA9IG5vdztcbiAgICB9XG4gICAgaWYgKCFza2lwQ3JlYXRlZEF0ICYmIGNyZWF0ZWRBdCAmJiAhY3VycmVudFVwZGF0ZVtjcmVhdGVkQXRdKSB7XG4gICAgICBfdXBkYXRlc1tjcmVhdGVkQXRdID0gbm93O1xuICAgIH1cbiAgICByZXR1cm4gdXBkYXRlcztcbiAgfVxuICBjdXJyZW50VXBkYXRlID0gY3VycmVudFVwZGF0ZSB8fCB7fTtcblxuICBpZiAoQXJyYXkuaXNBcnJheSh1cGRhdGVzKSkge1xuICAgIC8vIFVwZGF0ZSB3aXRoIGFnZ3JlZ2F0aW9uIHBpcGVsaW5lXG4gICAgaWYgKHVwZGF0ZWRBdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdXBkYXRlcztcbiAgICB9XG4gICAgdXBkYXRlcy5wdXNoKHsgJHNldDogeyBbdXBkYXRlZEF0XTogbm93IH0gfSk7XG4gICAgcmV0dXJuIHVwZGF0ZXM7XG4gIH1cbiAgdXBkYXRlcy4kc2V0ID0gdXBkYXRlcy4kc2V0IHx8IHt9O1xuICBpZiAoIXNraXBVcGRhdGVkQXQgJiYgdXBkYXRlZEF0ICYmXG4gICAgICAoIWN1cnJlbnRVcGRhdGUuJGN1cnJlbnREYXRlIHx8ICFjdXJyZW50VXBkYXRlLiRjdXJyZW50RGF0ZVt1cGRhdGVkQXRdKSkge1xuICAgIGxldCB0aW1lc3RhbXBTZXQgPSBmYWxzZTtcbiAgICBpZiAodXBkYXRlZEF0LmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IHBpZWNlcyA9IHVwZGF0ZWRBdC5zcGxpdCgnLicpO1xuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwaWVjZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgcmVtbmFudCA9IHBpZWNlcy5zbGljZSgtaSkuam9pbignLicpO1xuICAgICAgICBjb25zdCBzdGFydCA9IHBpZWNlcy5zbGljZSgwLCAtaSkuam9pbignLicpO1xuICAgICAgICBpZiAoY3VycmVudFVwZGF0ZVtzdGFydF0gIT0gbnVsbCkge1xuICAgICAgICAgIGN1cnJlbnRVcGRhdGVbc3RhcnRdW3JlbW5hbnRdID0gbm93O1xuICAgICAgICAgIHRpbWVzdGFtcFNldCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFVwZGF0ZS4kc2V0ICYmIGN1cnJlbnRVcGRhdGUuJHNldFtzdGFydF0pIHtcbiAgICAgICAgICBjdXJyZW50VXBkYXRlLiRzZXRbc3RhcnRdW3JlbW5hbnRdID0gbm93O1xuICAgICAgICAgIHRpbWVzdGFtcFNldCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRpbWVzdGFtcFNldCkge1xuICAgICAgdXBkYXRlcy4kc2V0W3VwZGF0ZWRBdF0gPSBub3c7XG4gICAgfVxuXG4gICAgaWYgKHVwZGF0ZXMuaGFzT3duUHJvcGVydHkodXBkYXRlZEF0KSkge1xuICAgICAgZGVsZXRlIHVwZGF0ZXNbdXBkYXRlZEF0XTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXNraXBDcmVhdGVkQXQgJiYgY3JlYXRlZEF0KSB7XG4gICAgaWYgKGN1cnJlbnRVcGRhdGVbY3JlYXRlZEF0XSkge1xuICAgICAgZGVsZXRlIGN1cnJlbnRVcGRhdGVbY3JlYXRlZEF0XTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRVcGRhdGUuJHNldCAmJiBjdXJyZW50VXBkYXRlLiRzZXRbY3JlYXRlZEF0XSkge1xuICAgICAgZGVsZXRlIGN1cnJlbnRVcGRhdGUuJHNldFtjcmVhdGVkQXRdO1xuICAgIH1cbiAgICBsZXQgdGltZXN0YW1wU2V0ID0gZmFsc2U7XG4gICAgaWYgKGNyZWF0ZWRBdC5pbmRleE9mKCcuJykgIT09IC0xKSB7XG4gICAgICBjb25zdCBwaWVjZXMgPSBjcmVhdGVkQXQuc3BsaXQoJy4nKTtcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGllY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHJlbW5hbnQgPSBwaWVjZXMuc2xpY2UoLWkpLmpvaW4oJy4nKTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBwaWVjZXMuc2xpY2UoMCwgLWkpLmpvaW4oJy4nKTtcbiAgICAgICAgaWYgKGN1cnJlbnRVcGRhdGVbc3RhcnRdICE9IG51bGwpIHtcbiAgICAgICAgICBjdXJyZW50VXBkYXRlW3N0YXJ0XVtyZW1uYW50XSA9IG5vdztcbiAgICAgICAgICB0aW1lc3RhbXBTZXQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRVcGRhdGUuJHNldCAmJiBjdXJyZW50VXBkYXRlLiRzZXRbc3RhcnRdKSB7XG4gICAgICAgICAgY3VycmVudFVwZGF0ZS4kc2V0W3N0YXJ0XVtyZW1uYW50XSA9IG5vdztcbiAgICAgICAgICB0aW1lc3RhbXBTZXQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aW1lc3RhbXBTZXQpIHtcbiAgICAgIHVwZGF0ZXMuJHNldE9uSW5zZXJ0ID0gdXBkYXRlcy4kc2V0T25JbnNlcnQgfHwge307XG4gICAgICB1cGRhdGVzLiRzZXRPbkluc2VydFtjcmVhdGVkQXRdID0gbm93O1xuICAgIH1cbiAgfVxuXG4gIGlmIChPYmplY3Qua2V5cyh1cGRhdGVzLiRzZXQpLmxlbmd0aCA9PT0gMCkge1xuICAgIGRlbGV0ZSB1cGRhdGVzLiRzZXQ7XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZXM7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/update/applyTimestampsToUpdate.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/update/castArrayFilters.js":
/*!*******************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/update/castArrayFilters.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst castFilterPath = __webpack_require__(/*! ../query/castFilterPath */ \"../backend/node_modules/mongoose/lib/helpers/query/castFilterPath.js\");\nconst cleanPositionalOperators = __webpack_require__(/*! ../schema/cleanPositionalOperators */ \"../backend/node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js\");\nconst getPath = __webpack_require__(/*! ../schema/getPath */ \"../backend/node_modules/mongoose/lib/helpers/schema/getPath.js\");\nconst updatedPathsByArrayFilter = __webpack_require__(/*! ./updatedPathsByArrayFilter */ \"../backend/node_modules/mongoose/lib/helpers/update/updatedPathsByArrayFilter.js\");\n\nmodule.exports = function castArrayFilters(query) {\n  const arrayFilters = query.options.arrayFilters;\n  const update = query.getUpdate();\n  const schema = query.schema;\n  const updatedPathsByFilter = updatedPathsByArrayFilter(update);\n\n  let strictQuery = schema.options.strict;\n  if (query._mongooseOptions.strict != null) {\n    strictQuery = query._mongooseOptions.strict;\n  }\n  if (query.model && query.model.base.options.strictQuery != null) {\n    strictQuery = query.model.base.options.strictQuery;\n  }\n  if (schema._userProvidedOptions.strictQuery != null) {\n    strictQuery = schema._userProvidedOptions.strictQuery;\n  }\n  if (query._mongooseOptions.strictQuery != null) {\n    strictQuery = query._mongooseOptions.strictQuery;\n  }\n\n  _castArrayFilters(arrayFilters, schema, strictQuery, updatedPathsByFilter, query);\n};\n\nfunction _castArrayFilters(arrayFilters, schema, strictQuery, updatedPathsByFilter, query) {\n  if (!Array.isArray(arrayFilters)) {\n    return;\n  }\n\n  for (const filter of arrayFilters) {\n    if (filter == null) {\n      throw new Error(`Got null array filter in ${arrayFilters}`);\n    }\n    const keys = Object.keys(filter).filter(key => filter[key] != null);\n    if (keys.length === 0) {\n      continue;\n    }\n\n    const firstKey = keys[0];\n    if (firstKey === '$and' || firstKey === '$or') {\n      for (const key of keys) {\n        _castArrayFilters(filter[key], schema, strictQuery, updatedPathsByFilter, query);\n      }\n      continue;\n    }\n    const dot = firstKey.indexOf('.');\n    const filterWildcardPath = dot === -1 ? firstKey : firstKey.substring(0, dot);\n    if (updatedPathsByFilter[filterWildcardPath] == null) {\n      continue;\n    }\n    const baseFilterPath = cleanPositionalOperators(\n      updatedPathsByFilter[filterWildcardPath]\n    );\n\n    const baseSchematype = getPath(schema, baseFilterPath);\n    let filterBaseSchema = baseSchematype != null ? baseSchematype.schema : null;\n    if (filterBaseSchema != null &&\n        filterBaseSchema.discriminators != null &&\n        filter[filterWildcardPath + '.' + filterBaseSchema.options.discriminatorKey]) {\n      filterBaseSchema = filterBaseSchema.discriminators[filter[filterWildcardPath + '.' + filterBaseSchema.options.discriminatorKey]] || filterBaseSchema;\n    }\n\n    for (const key of keys) {\n      if (updatedPathsByFilter[key] === null) {\n        continue;\n      }\n      if (Object.keys(updatedPathsByFilter).length === 0) {\n        continue;\n      }\n      const dot = key.indexOf('.');\n\n      let filterPathRelativeToBase = dot === -1 ? null : key.substring(dot);\n      let schematype;\n      if (filterPathRelativeToBase == null || filterBaseSchema == null) {\n        schematype = baseSchematype;\n      } else {\n        // If there are multiple array filters in the path being updated, make sure\n        // to replace them so we can get the schema path.\n        filterPathRelativeToBase = cleanPositionalOperators(filterPathRelativeToBase);\n        schematype = getPath(filterBaseSchema, filterPathRelativeToBase);\n      }\n\n      if (schematype == null) {\n        if (!strictQuery) {\n          return;\n        }\n        const filterPath = filterPathRelativeToBase == null ?\n          baseFilterPath + '.0' :\n          baseFilterPath + '.0' + filterPathRelativeToBase;\n        // For now, treat `strictQuery = true` and `strictQuery = 'throw'` as\n        // equivalent for casting array filters. `strictQuery = true` doesn't\n        // quite work in this context because we never want to silently strip out\n        // array filters, even if the path isn't in the schema.\n        throw new Error(`Could not find path \"${filterPath}\" in schema`);\n      }\n      if (typeof filter[key] === 'object') {\n        filter[key] = castFilterPath(query, schematype, filter[key]);\n      } else {\n        filter[key] = schematype.castForQuery(null, filter[key]);\n      }\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdXBkYXRlL2Nhc3RBcnJheUZpbHRlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsdUJBQXVCLG1CQUFPLENBQUMscUdBQXlCO0FBQ3hELGlDQUFpQyxtQkFBTyxDQUFDLDJIQUFvQztBQUM3RSxnQkFBZ0IsbUJBQU8sQ0FBQyx5RkFBbUI7QUFDM0Msa0NBQWtDLG1CQUFPLENBQUMscUhBQTZCOztBQUV2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtEQUFrRCxhQUFhO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFdBQVc7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy91cGRhdGUvY2FzdEFycmF5RmlsdGVycy5qcz9hYmQ3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgY2FzdEZpbHRlclBhdGggPSByZXF1aXJlKCcuLi9xdWVyeS9jYXN0RmlsdGVyUGF0aCcpO1xuY29uc3QgY2xlYW5Qb3NpdGlvbmFsT3BlcmF0b3JzID0gcmVxdWlyZSgnLi4vc2NoZW1hL2NsZWFuUG9zaXRpb25hbE9wZXJhdG9ycycpO1xuY29uc3QgZ2V0UGF0aCA9IHJlcXVpcmUoJy4uL3NjaGVtYS9nZXRQYXRoJyk7XG5jb25zdCB1cGRhdGVkUGF0aHNCeUFycmF5RmlsdGVyID0gcmVxdWlyZSgnLi91cGRhdGVkUGF0aHNCeUFycmF5RmlsdGVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FzdEFycmF5RmlsdGVycyhxdWVyeSkge1xuICBjb25zdCBhcnJheUZpbHRlcnMgPSBxdWVyeS5vcHRpb25zLmFycmF5RmlsdGVycztcbiAgY29uc3QgdXBkYXRlID0gcXVlcnkuZ2V0VXBkYXRlKCk7XG4gIGNvbnN0IHNjaGVtYSA9IHF1ZXJ5LnNjaGVtYTtcbiAgY29uc3QgdXBkYXRlZFBhdGhzQnlGaWx0ZXIgPSB1cGRhdGVkUGF0aHNCeUFycmF5RmlsdGVyKHVwZGF0ZSk7XG5cbiAgbGV0IHN0cmljdFF1ZXJ5ID0gc2NoZW1hLm9wdGlvbnMuc3RyaWN0O1xuICBpZiAocXVlcnkuX21vbmdvb3NlT3B0aW9ucy5zdHJpY3QgIT0gbnVsbCkge1xuICAgIHN0cmljdFF1ZXJ5ID0gcXVlcnkuX21vbmdvb3NlT3B0aW9ucy5zdHJpY3Q7XG4gIH1cbiAgaWYgKHF1ZXJ5Lm1vZGVsICYmIHF1ZXJ5Lm1vZGVsLmJhc2Uub3B0aW9ucy5zdHJpY3RRdWVyeSAhPSBudWxsKSB7XG4gICAgc3RyaWN0UXVlcnkgPSBxdWVyeS5tb2RlbC5iYXNlLm9wdGlvbnMuc3RyaWN0UXVlcnk7XG4gIH1cbiAgaWYgKHNjaGVtYS5fdXNlclByb3ZpZGVkT3B0aW9ucy5zdHJpY3RRdWVyeSAhPSBudWxsKSB7XG4gICAgc3RyaWN0UXVlcnkgPSBzY2hlbWEuX3VzZXJQcm92aWRlZE9wdGlvbnMuc3RyaWN0UXVlcnk7XG4gIH1cbiAgaWYgKHF1ZXJ5Ll9tb25nb29zZU9wdGlvbnMuc3RyaWN0UXVlcnkgIT0gbnVsbCkge1xuICAgIHN0cmljdFF1ZXJ5ID0gcXVlcnkuX21vbmdvb3NlT3B0aW9ucy5zdHJpY3RRdWVyeTtcbiAgfVxuXG4gIF9jYXN0QXJyYXlGaWx0ZXJzKGFycmF5RmlsdGVycywgc2NoZW1hLCBzdHJpY3RRdWVyeSwgdXBkYXRlZFBhdGhzQnlGaWx0ZXIsIHF1ZXJ5KTtcbn07XG5cbmZ1bmN0aW9uIF9jYXN0QXJyYXlGaWx0ZXJzKGFycmF5RmlsdGVycywgc2NoZW1hLCBzdHJpY3RRdWVyeSwgdXBkYXRlZFBhdGhzQnlGaWx0ZXIsIHF1ZXJ5KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShhcnJheUZpbHRlcnMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yIChjb25zdCBmaWx0ZXIgb2YgYXJyYXlGaWx0ZXJzKSB7XG4gICAgaWYgKGZpbHRlciA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEdvdCBudWxsIGFycmF5IGZpbHRlciBpbiAke2FycmF5RmlsdGVyc31gKTtcbiAgICB9XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGZpbHRlcikuZmlsdGVyKGtleSA9PiBmaWx0ZXJba2V5XSAhPSBudWxsKTtcbiAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGZpcnN0S2V5ID0ga2V5c1swXTtcbiAgICBpZiAoZmlyc3RLZXkgPT09ICckYW5kJyB8fCBmaXJzdEtleSA9PT0gJyRvcicpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgX2Nhc3RBcnJheUZpbHRlcnMoZmlsdGVyW2tleV0sIHNjaGVtYSwgc3RyaWN0UXVlcnksIHVwZGF0ZWRQYXRoc0J5RmlsdGVyLCBxdWVyeSk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgZG90ID0gZmlyc3RLZXkuaW5kZXhPZignLicpO1xuICAgIGNvbnN0IGZpbHRlcldpbGRjYXJkUGF0aCA9IGRvdCA9PT0gLTEgPyBmaXJzdEtleSA6IGZpcnN0S2V5LnN1YnN0cmluZygwLCBkb3QpO1xuICAgIGlmICh1cGRhdGVkUGF0aHNCeUZpbHRlcltmaWx0ZXJXaWxkY2FyZFBhdGhdID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBiYXNlRmlsdGVyUGF0aCA9IGNsZWFuUG9zaXRpb25hbE9wZXJhdG9ycyhcbiAgICAgIHVwZGF0ZWRQYXRoc0J5RmlsdGVyW2ZpbHRlcldpbGRjYXJkUGF0aF1cbiAgICApO1xuXG4gICAgY29uc3QgYmFzZVNjaGVtYXR5cGUgPSBnZXRQYXRoKHNjaGVtYSwgYmFzZUZpbHRlclBhdGgpO1xuICAgIGxldCBmaWx0ZXJCYXNlU2NoZW1hID0gYmFzZVNjaGVtYXR5cGUgIT0gbnVsbCA/IGJhc2VTY2hlbWF0eXBlLnNjaGVtYSA6IG51bGw7XG4gICAgaWYgKGZpbHRlckJhc2VTY2hlbWEgIT0gbnVsbCAmJlxuICAgICAgICBmaWx0ZXJCYXNlU2NoZW1hLmRpc2NyaW1pbmF0b3JzICE9IG51bGwgJiZcbiAgICAgICAgZmlsdGVyW2ZpbHRlcldpbGRjYXJkUGF0aCArICcuJyArIGZpbHRlckJhc2VTY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5XSkge1xuICAgICAgZmlsdGVyQmFzZVNjaGVtYSA9IGZpbHRlckJhc2VTY2hlbWEuZGlzY3JpbWluYXRvcnNbZmlsdGVyW2ZpbHRlcldpbGRjYXJkUGF0aCArICcuJyArIGZpbHRlckJhc2VTY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5XV0gfHwgZmlsdGVyQmFzZVNjaGVtYTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBpZiAodXBkYXRlZFBhdGhzQnlGaWx0ZXJba2V5XSA9PT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChPYmplY3Qua2V5cyh1cGRhdGVkUGF0aHNCeUZpbHRlcikubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZG90ID0ga2V5LmluZGV4T2YoJy4nKTtcblxuICAgICAgbGV0IGZpbHRlclBhdGhSZWxhdGl2ZVRvQmFzZSA9IGRvdCA9PT0gLTEgPyBudWxsIDoga2V5LnN1YnN0cmluZyhkb3QpO1xuICAgICAgbGV0IHNjaGVtYXR5cGU7XG4gICAgICBpZiAoZmlsdGVyUGF0aFJlbGF0aXZlVG9CYXNlID09IG51bGwgfHwgZmlsdGVyQmFzZVNjaGVtYSA9PSBudWxsKSB7XG4gICAgICAgIHNjaGVtYXR5cGUgPSBiYXNlU2NoZW1hdHlwZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBhcnJheSBmaWx0ZXJzIGluIHRoZSBwYXRoIGJlaW5nIHVwZGF0ZWQsIG1ha2Ugc3VyZVxuICAgICAgICAvLyB0byByZXBsYWNlIHRoZW0gc28gd2UgY2FuIGdldCB0aGUgc2NoZW1hIHBhdGguXG4gICAgICAgIGZpbHRlclBhdGhSZWxhdGl2ZVRvQmFzZSA9IGNsZWFuUG9zaXRpb25hbE9wZXJhdG9ycyhmaWx0ZXJQYXRoUmVsYXRpdmVUb0Jhc2UpO1xuICAgICAgICBzY2hlbWF0eXBlID0gZ2V0UGF0aChmaWx0ZXJCYXNlU2NoZW1hLCBmaWx0ZXJQYXRoUmVsYXRpdmVUb0Jhc2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2NoZW1hdHlwZSA9PSBudWxsKSB7XG4gICAgICAgIGlmICghc3RyaWN0UXVlcnkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlsdGVyUGF0aCA9IGZpbHRlclBhdGhSZWxhdGl2ZVRvQmFzZSA9PSBudWxsID9cbiAgICAgICAgICBiYXNlRmlsdGVyUGF0aCArICcuMCcgOlxuICAgICAgICAgIGJhc2VGaWx0ZXJQYXRoICsgJy4wJyArIGZpbHRlclBhdGhSZWxhdGl2ZVRvQmFzZTtcbiAgICAgICAgLy8gRm9yIG5vdywgdHJlYXQgYHN0cmljdFF1ZXJ5ID0gdHJ1ZWAgYW5kIGBzdHJpY3RRdWVyeSA9ICd0aHJvdydgIGFzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgZm9yIGNhc3RpbmcgYXJyYXkgZmlsdGVycy4gYHN0cmljdFF1ZXJ5ID0gdHJ1ZWAgZG9lc24ndFxuICAgICAgICAvLyBxdWl0ZSB3b3JrIGluIHRoaXMgY29udGV4dCBiZWNhdXNlIHdlIG5ldmVyIHdhbnQgdG8gc2lsZW50bHkgc3RyaXAgb3V0XG4gICAgICAgIC8vIGFycmF5IGZpbHRlcnMsIGV2ZW4gaWYgdGhlIHBhdGggaXNuJ3QgaW4gdGhlIHNjaGVtYS5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBwYXRoIFwiJHtmaWx0ZXJQYXRofVwiIGluIHNjaGVtYWApO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBmaWx0ZXJba2V5XSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZmlsdGVyW2tleV0gPSBjYXN0RmlsdGVyUGF0aChxdWVyeSwgc2NoZW1hdHlwZSwgZmlsdGVyW2tleV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlsdGVyW2tleV0gPSBzY2hlbWF0eXBlLmNhc3RGb3JRdWVyeShudWxsLCBmaWx0ZXJba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/update/castArrayFilters.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/update/decorateUpdateWithVersionKey.js":
/*!*******************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/update/decorateUpdateWithVersionKey.js ***!
  \*******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst modifiedPaths = __webpack_require__(/*! ./modifiedPaths */ \"../backend/node_modules/mongoose/lib/helpers/update/modifiedPaths.js\");\n\n/**\n * Decorate the update with a version key, if necessary\n * @api private\n */\n\nmodule.exports = function decorateUpdateWithVersionKey(update, options, versionKey) {\n  if (!versionKey || !(options && options.upsert || false)) {\n    return;\n  }\n\n  const updatedPaths = modifiedPaths(update);\n  if (!updatedPaths[versionKey]) {\n    if (options.overwrite) {\n      update[versionKey] = 0;\n    } else {\n      if (!update.$setOnInsert) {\n        update.$setOnInsert = {};\n      }\n      update.$setOnInsert[versionKey] = 0;\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdXBkYXRlL2RlY29yYXRlVXBkYXRlV2l0aFZlcnNpb25LZXkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsNkZBQWlCOztBQUUvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3VwZGF0ZS9kZWNvcmF0ZVVwZGF0ZVdpdGhWZXJzaW9uS2V5LmpzP2ExMjEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBtb2RpZmllZFBhdGhzID0gcmVxdWlyZSgnLi9tb2RpZmllZFBhdGhzJyk7XG5cbi8qKlxuICogRGVjb3JhdGUgdGhlIHVwZGF0ZSB3aXRoIGEgdmVyc2lvbiBrZXksIGlmIG5lY2Vzc2FyeVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWNvcmF0ZVVwZGF0ZVdpdGhWZXJzaW9uS2V5KHVwZGF0ZSwgb3B0aW9ucywgdmVyc2lvbktleSkge1xuICBpZiAoIXZlcnNpb25LZXkgfHwgIShvcHRpb25zICYmIG9wdGlvbnMudXBzZXJ0IHx8IGZhbHNlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHVwZGF0ZWRQYXRocyA9IG1vZGlmaWVkUGF0aHModXBkYXRlKTtcbiAgaWYgKCF1cGRhdGVkUGF0aHNbdmVyc2lvbktleV0pIHtcbiAgICBpZiAob3B0aW9ucy5vdmVyd3JpdGUpIHtcbiAgICAgIHVwZGF0ZVt2ZXJzaW9uS2V5XSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdXBkYXRlLiRzZXRPbkluc2VydCkge1xuICAgICAgICB1cGRhdGUuJHNldE9uSW5zZXJ0ID0ge307XG4gICAgICB9XG4gICAgICB1cGRhdGUuJHNldE9uSW5zZXJ0W3ZlcnNpb25LZXldID0gMDtcbiAgICB9XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/update/decorateUpdateWithVersionKey.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/update/modifiedPaths.js":
/*!****************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/update/modifiedPaths.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst _modifiedPaths = (__webpack_require__(/*! ../common */ \"../backend/node_modules/mongoose/lib/helpers/common.js\").modifiedPaths);\n\n/**\n * Given an update document with potential update operators (`$set`, etc.)\n * returns an object whose keys are the directly modified paths.\n *\n * If there are any top-level keys that don't start with `$`, we assume those\n * will get wrapped in a `$set`. The Mongoose Query is responsible for wrapping\n * top-level keys in `$set`.\n *\n * @param {Object} update\n * @return {Object} modified\n */\n\nmodule.exports = function modifiedPaths(update) {\n  const keys = Object.keys(update);\n  const res = {};\n\n  const withoutDollarKeys = {};\n  for (const key of keys) {\n    if (key.startsWith('$')) {\n      _modifiedPaths(update[key], '', res);\n      continue;\n    }\n    withoutDollarKeys[key] = update[key];\n  }\n\n  _modifiedPaths(withoutDollarKeys, '', res);\n\n  return res;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdXBkYXRlL21vZGlmaWVkUGF0aHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsdUJBQXVCLDhHQUFrQzs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3VwZGF0ZS9tb2RpZmllZFBhdGhzLmpzP2UzNjMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBfbW9kaWZpZWRQYXRocyA9IHJlcXVpcmUoJy4uL2NvbW1vbicpLm1vZGlmaWVkUGF0aHM7XG5cbi8qKlxuICogR2l2ZW4gYW4gdXBkYXRlIGRvY3VtZW50IHdpdGggcG90ZW50aWFsIHVwZGF0ZSBvcGVyYXRvcnMgKGAkc2V0YCwgZXRjLilcbiAqIHJldHVybnMgYW4gb2JqZWN0IHdob3NlIGtleXMgYXJlIHRoZSBkaXJlY3RseSBtb2RpZmllZCBwYXRocy5cbiAqXG4gKiBJZiB0aGVyZSBhcmUgYW55IHRvcC1sZXZlbCBrZXlzIHRoYXQgZG9uJ3Qgc3RhcnQgd2l0aCBgJGAsIHdlIGFzc3VtZSB0aG9zZVxuICogd2lsbCBnZXQgd3JhcHBlZCBpbiBhIGAkc2V0YC4gVGhlIE1vbmdvb3NlIFF1ZXJ5IGlzIHJlc3BvbnNpYmxlIGZvciB3cmFwcGluZ1xuICogdG9wLWxldmVsIGtleXMgaW4gYCRzZXRgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB1cGRhdGVcbiAqIEByZXR1cm4ge09iamVjdH0gbW9kaWZpZWRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1vZGlmaWVkUGF0aHModXBkYXRlKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh1cGRhdGUpO1xuICBjb25zdCByZXMgPSB7fTtcblxuICBjb25zdCB3aXRob3V0RG9sbGFyS2V5cyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgaWYgKGtleS5zdGFydHNXaXRoKCckJykpIHtcbiAgICAgIF9tb2RpZmllZFBhdGhzKHVwZGF0ZVtrZXldLCAnJywgcmVzKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB3aXRob3V0RG9sbGFyS2V5c1trZXldID0gdXBkYXRlW2tleV07XG4gIH1cblxuICBfbW9kaWZpZWRQYXRocyh3aXRob3V0RG9sbGFyS2V5cywgJycsIHJlcyk7XG5cbiAgcmV0dXJuIHJlcztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/update/modifiedPaths.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/update/moveImmutableProperties.js":
/*!**************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/update/moveImmutableProperties.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst get = __webpack_require__(/*! ../get */ \"../backend/node_modules/mongoose/lib/helpers/get.js\");\n\n/**\n * Given an update, move all $set on immutable properties to $setOnInsert.\n * This should only be called for upserts, because $setOnInsert bypasses the\n * strictness check for immutable properties.\n */\n\nmodule.exports = function moveImmutableProperties(schema, update, ctx) {\n  if (update == null) {\n    return;\n  }\n\n  const keys = Object.keys(update);\n  for (const key of keys) {\n    const isDollarKey = key.startsWith('$');\n\n    if (key === '$set') {\n      const updatedPaths = Object.keys(update[key]);\n      for (const path of updatedPaths) {\n        _walkUpdatePath(schema, update[key], path, update, ctx);\n      }\n    } else if (!isDollarKey) {\n      _walkUpdatePath(schema, update, key, update, ctx);\n    }\n\n  }\n};\n\nfunction _walkUpdatePath(schema, op, path, update, ctx) {\n  const schematype = schema.path(path);\n  if (schematype == null) {\n    return;\n  }\n\n  let immutable = get(schematype, 'options.immutable', null);\n  if (immutable == null) {\n    return;\n  }\n  if (typeof immutable === 'function') {\n    immutable = immutable.call(ctx, ctx);\n  }\n\n  if (!immutable) {\n    return;\n  }\n\n  update.$setOnInsert = update.$setOnInsert || {};\n  update.$setOnInsert[path] = op[path];\n  delete op[path];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdXBkYXRlL21vdmVJbW11dGFibGVQcm9wZXJ0aWVzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxtRUFBUTs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy91cGRhdGUvbW92ZUltbXV0YWJsZVByb3BlcnRpZXMuanM/Nzc3YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGdldCA9IHJlcXVpcmUoJy4uL2dldCcpO1xuXG4vKipcbiAqIEdpdmVuIGFuIHVwZGF0ZSwgbW92ZSBhbGwgJHNldCBvbiBpbW11dGFibGUgcHJvcGVydGllcyB0byAkc2V0T25JbnNlcnQuXG4gKiBUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBmb3IgdXBzZXJ0cywgYmVjYXVzZSAkc2V0T25JbnNlcnQgYnlwYXNzZXMgdGhlXG4gKiBzdHJpY3RuZXNzIGNoZWNrIGZvciBpbW11dGFibGUgcHJvcGVydGllcy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1vdmVJbW11dGFibGVQcm9wZXJ0aWVzKHNjaGVtYSwgdXBkYXRlLCBjdHgpIHtcbiAgaWYgKHVwZGF0ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHVwZGF0ZSk7XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBjb25zdCBpc0RvbGxhcktleSA9IGtleS5zdGFydHNXaXRoKCckJyk7XG5cbiAgICBpZiAoa2V5ID09PSAnJHNldCcpIHtcbiAgICAgIGNvbnN0IHVwZGF0ZWRQYXRocyA9IE9iamVjdC5rZXlzKHVwZGF0ZVtrZXldKTtcbiAgICAgIGZvciAoY29uc3QgcGF0aCBvZiB1cGRhdGVkUGF0aHMpIHtcbiAgICAgICAgX3dhbGtVcGRhdGVQYXRoKHNjaGVtYSwgdXBkYXRlW2tleV0sIHBhdGgsIHVwZGF0ZSwgY3R4KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc0RvbGxhcktleSkge1xuICAgICAgX3dhbGtVcGRhdGVQYXRoKHNjaGVtYSwgdXBkYXRlLCBrZXksIHVwZGF0ZSwgY3R4KTtcbiAgICB9XG5cbiAgfVxufTtcblxuZnVuY3Rpb24gX3dhbGtVcGRhdGVQYXRoKHNjaGVtYSwgb3AsIHBhdGgsIHVwZGF0ZSwgY3R4KSB7XG4gIGNvbnN0IHNjaGVtYXR5cGUgPSBzY2hlbWEucGF0aChwYXRoKTtcbiAgaWYgKHNjaGVtYXR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBpbW11dGFibGUgPSBnZXQoc2NoZW1hdHlwZSwgJ29wdGlvbnMuaW1tdXRhYmxlJywgbnVsbCk7XG4gIGlmIChpbW11dGFibGUgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZW9mIGltbXV0YWJsZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGltbXV0YWJsZSA9IGltbXV0YWJsZS5jYWxsKGN0eCwgY3R4KTtcbiAgfVxuXG4gIGlmICghaW1tdXRhYmxlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdXBkYXRlLiRzZXRPbkluc2VydCA9IHVwZGF0ZS4kc2V0T25JbnNlcnQgfHwge307XG4gIHVwZGF0ZS4kc2V0T25JbnNlcnRbcGF0aF0gPSBvcFtwYXRoXTtcbiAgZGVsZXRlIG9wW3BhdGhdO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/update/moveImmutableProperties.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/update/removeUnusedArrayFilters.js":
/*!***************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/update/removeUnusedArrayFilters.js ***!
  \***************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * MongoDB throws an error if there's unused array filters. That is, if `options.arrayFilters` defines\n * a filter, but none of the `update` keys use it. This should be enough to filter out all unused array\n * filters.\n */\n\nmodule.exports = function removeUnusedArrayFilters(update, arrayFilters) {\n  const updateKeys = Object.keys(update).\n    map(key => Object.keys(update[key])).\n    reduce((cur, arr) => cur.concat(arr), []);\n  return arrayFilters.filter(obj => {\n    return _checkSingleFilterKey(obj, updateKeys);\n  });\n};\n\nfunction _checkSingleFilterKey(arrayFilter, updateKeys) {\n  const firstKey = Object.keys(arrayFilter)[0];\n\n  if (firstKey === '$and' || firstKey === '$or') {\n    if (!Array.isArray(arrayFilter[firstKey])) {\n      return false;\n    }\n    return arrayFilter[firstKey].find(filter => _checkSingleFilterKey(filter, updateKeys)) != null;\n  }\n\n  const firstDot = firstKey.indexOf('.');\n  const arrayFilterKey = firstDot === -1 ? firstKey : firstKey.slice(0, firstDot);\n\n  return updateKeys.find(key => key.includes('$[' + arrayFilterKey + ']')) != null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdXBkYXRlL3JlbW92ZVVudXNlZEFycmF5RmlsdGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvaGVscGVycy91cGRhdGUvcmVtb3ZlVW51c2VkQXJyYXlGaWx0ZXJzLmpzP2M4YmUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vbmdvREIgdGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlJ3MgdW51c2VkIGFycmF5IGZpbHRlcnMuIFRoYXQgaXMsIGlmIGBvcHRpb25zLmFycmF5RmlsdGVyc2AgZGVmaW5lc1xuICogYSBmaWx0ZXIsIGJ1dCBub25lIG9mIHRoZSBgdXBkYXRlYCBrZXlzIHVzZSBpdC4gVGhpcyBzaG91bGQgYmUgZW5vdWdoIHRvIGZpbHRlciBvdXQgYWxsIHVudXNlZCBhcnJheVxuICogZmlsdGVycy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlbW92ZVVudXNlZEFycmF5RmlsdGVycyh1cGRhdGUsIGFycmF5RmlsdGVycykge1xuICBjb25zdCB1cGRhdGVLZXlzID0gT2JqZWN0LmtleXModXBkYXRlKS5cbiAgICBtYXAoa2V5ID0+IE9iamVjdC5rZXlzKHVwZGF0ZVtrZXldKSkuXG4gICAgcmVkdWNlKChjdXIsIGFycikgPT4gY3VyLmNvbmNhdChhcnIpLCBbXSk7XG4gIHJldHVybiBhcnJheUZpbHRlcnMuZmlsdGVyKG9iaiA9PiB7XG4gICAgcmV0dXJuIF9jaGVja1NpbmdsZUZpbHRlcktleShvYmosIHVwZGF0ZUtleXMpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIF9jaGVja1NpbmdsZUZpbHRlcktleShhcnJheUZpbHRlciwgdXBkYXRlS2V5cykge1xuICBjb25zdCBmaXJzdEtleSA9IE9iamVjdC5rZXlzKGFycmF5RmlsdGVyKVswXTtcblxuICBpZiAoZmlyc3RLZXkgPT09ICckYW5kJyB8fCBmaXJzdEtleSA9PT0gJyRvcicpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlGaWx0ZXJbZmlyc3RLZXldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlGaWx0ZXJbZmlyc3RLZXldLmZpbmQoZmlsdGVyID0+IF9jaGVja1NpbmdsZUZpbHRlcktleShmaWx0ZXIsIHVwZGF0ZUtleXMpKSAhPSBudWxsO1xuICB9XG5cbiAgY29uc3QgZmlyc3REb3QgPSBmaXJzdEtleS5pbmRleE9mKCcuJyk7XG4gIGNvbnN0IGFycmF5RmlsdGVyS2V5ID0gZmlyc3REb3QgPT09IC0xID8gZmlyc3RLZXkgOiBmaXJzdEtleS5zbGljZSgwLCBmaXJzdERvdCk7XG5cbiAgcmV0dXJuIHVwZGF0ZUtleXMuZmluZChrZXkgPT4ga2V5LmluY2x1ZGVzKCckWycgKyBhcnJheUZpbHRlcktleSArICddJykpICE9IG51bGw7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/update/removeUnusedArrayFilters.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/helpers/update/updatedPathsByArrayFilter.js":
/*!****************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/helpers/update/updatedPathsByArrayFilter.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst modifiedPaths = __webpack_require__(/*! ./modifiedPaths */ \"../backend/node_modules/mongoose/lib/helpers/update/modifiedPaths.js\");\n\nmodule.exports = function updatedPathsByArrayFilter(update) {\n  if (update == null) {\n    return {};\n  }\n  const updatedPaths = modifiedPaths(update);\n\n  return Object.keys(updatedPaths).reduce((cur, path) => {\n    const matches = path.match(/\\$\\[[^\\]]+\\]/g);\n    if (matches == null) {\n      return cur;\n    }\n    for (const match of matches) {\n      const firstMatch = path.indexOf(match);\n      if (firstMatch !== path.lastIndexOf(match)) {\n        throw new Error(`Path '${path}' contains the same array filter multiple times`);\n      }\n      cur[match.substring(2, match.length - 1)] = path.\n        substring(0, firstMatch - 1).\n        replace(/\\$\\[[^\\]]+\\]/g, '0');\n    }\n    return cur;\n  }, {});\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2hlbHBlcnMvdXBkYXRlL3VwZGF0ZWRQYXRoc0J5QXJyYXlGaWx0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsNkZBQWlCOztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsS0FBSztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9oZWxwZXJzL3VwZGF0ZS91cGRhdGVkUGF0aHNCeUFycmF5RmlsdGVyLmpzP2UxOTYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBtb2RpZmllZFBhdGhzID0gcmVxdWlyZSgnLi9tb2RpZmllZFBhdGhzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdXBkYXRlZFBhdGhzQnlBcnJheUZpbHRlcih1cGRhdGUpIHtcbiAgaWYgKHVwZGF0ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGNvbnN0IHVwZGF0ZWRQYXRocyA9IG1vZGlmaWVkUGF0aHModXBkYXRlKTtcblxuICByZXR1cm4gT2JqZWN0LmtleXModXBkYXRlZFBhdGhzKS5yZWR1Y2UoKGN1ciwgcGF0aCkgPT4ge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBwYXRoLm1hdGNoKC9cXCRcXFtbXlxcXV0rXFxdL2cpO1xuICAgIGlmIChtYXRjaGVzID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjdXI7XG4gICAgfVxuICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgICAgY29uc3QgZmlyc3RNYXRjaCA9IHBhdGguaW5kZXhPZihtYXRjaCk7XG4gICAgICBpZiAoZmlyc3RNYXRjaCAhPT0gcGF0aC5sYXN0SW5kZXhPZihtYXRjaCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXRoICcke3BhdGh9JyBjb250YWlucyB0aGUgc2FtZSBhcnJheSBmaWx0ZXIgbXVsdGlwbGUgdGltZXNgKTtcbiAgICAgIH1cbiAgICAgIGN1clttYXRjaC5zdWJzdHJpbmcoMiwgbWF0Y2gubGVuZ3RoIC0gMSldID0gcGF0aC5cbiAgICAgICAgc3Vic3RyaW5nKDAsIGZpcnN0TWF0Y2ggLSAxKS5cbiAgICAgICAgcmVwbGFjZSgvXFwkXFxbW15cXF1dK1xcXS9nLCAnMCcpO1xuICAgIH1cbiAgICByZXR1cm4gY3VyO1xuICB9LCB7fSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/helpers/update/updatedPathsByArrayFilter.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/index.js":
/*!*****************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\n(__webpack_require__(/*! ./driver */ \"../backend/node_modules/mongoose/lib/driver.js\").set)(__webpack_require__(/*! ./drivers/node-mongodb-native */ \"../backend/node_modules/mongoose/lib/drivers/node-mongodb-native/index.js\"));\n\nconst mongoose = __webpack_require__(/*! ./mongoose */ \"../backend/node_modules/mongoose/lib/mongoose.js\");\n\nmongoose.Mongoose.prototype.mongo = __webpack_require__(/*! mongodb */ \"../backend/node_modules/mongodb/lib/index.js\");\n\nmodule.exports = mongoose;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSwyRkFBdUIsQ0FBQyxtQkFBTyxDQUFDLGdIQUErQjs7QUFFL0QsaUJBQWlCLG1CQUFPLENBQUMsb0VBQVk7O0FBRXJDLG9DQUFvQyxtQkFBTyxDQUFDLDZEQUFTOztBQUVyRCIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9pbmRleC5qcz84YmUzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnJlcXVpcmUoJy4vZHJpdmVyJykuc2V0KHJlcXVpcmUoJy4vZHJpdmVycy9ub2RlLW1vbmdvZGItbmF0aXZlJykpO1xuXG5jb25zdCBtb25nb29zZSA9IHJlcXVpcmUoJy4vbW9uZ29vc2UnKTtcblxubW9uZ29vc2UuTW9uZ29vc2UucHJvdG90eXBlLm1vbmdvID0gcmVxdWlyZSgnbW9uZ29kYicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1vbmdvb3NlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/index.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/internal.js":
/*!********************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/internal.js ***!
  \********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Dependencies\n */\n\n\n\nconst StateMachine = __webpack_require__(/*! ./stateMachine */ \"../backend/node_modules/mongoose/lib/stateMachine.js\");\nconst ActiveRoster = StateMachine.ctor('require', 'modify', 'init', 'default', 'ignore');\n\nmodule.exports = exports = InternalCache;\n\nfunction InternalCache() {\n  this.activePaths = new ActiveRoster();\n}\n\nInternalCache.prototype.strictMode = true;\n\nInternalCache.prototype.fullPath = undefined;\nInternalCache.prototype.selected = undefined;\nInternalCache.prototype.shardval = undefined;\nInternalCache.prototype.saveError = undefined;\nInternalCache.prototype.validationError = undefined;\nInternalCache.prototype.adhocPaths = undefined;\nInternalCache.prototype.removing = undefined;\nInternalCache.prototype.inserting = undefined;\nInternalCache.prototype.saving = undefined;\nInternalCache.prototype.version = undefined;\nInternalCache.prototype._id = undefined;\nInternalCache.prototype.ownerDocument = undefined;\nInternalCache.prototype.populate = undefined; // what we want to populate in this doc\nInternalCache.prototype.populated = undefined;// the _ids that have been populated\nInternalCache.prototype.primitiveAtomics = undefined;\n\n/**\n * If `false`, this document was not the result of population.\n * If `true`, this document is a populated doc underneath another doc\n * If an object, this document is a populated doc and the `value` property of the\n * object contains the original depopulated value.\n */\nInternalCache.prototype.wasPopulated = false;\n\nInternalCache.prototype.scope = undefined;\n\nInternalCache.prototype.session = null;\nInternalCache.prototype.pathsToScopes = null;\nInternalCache.prototype.cachedRequired = null;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2ludGVybmFsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixxQkFBcUIsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDN0M7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qyw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL2ludGVybmFsLmpzP2U1ZjEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBEZXBlbmRlbmNpZXNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IFN0YXRlTWFjaGluZSA9IHJlcXVpcmUoJy4vc3RhdGVNYWNoaW5lJyk7XG5jb25zdCBBY3RpdmVSb3N0ZXIgPSBTdGF0ZU1hY2hpbmUuY3RvcigncmVxdWlyZScsICdtb2RpZnknLCAnaW5pdCcsICdkZWZhdWx0JywgJ2lnbm9yZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBJbnRlcm5hbENhY2hlO1xuXG5mdW5jdGlvbiBJbnRlcm5hbENhY2hlKCkge1xuICB0aGlzLmFjdGl2ZVBhdGhzID0gbmV3IEFjdGl2ZVJvc3RlcigpO1xufVxuXG5JbnRlcm5hbENhY2hlLnByb3RvdHlwZS5zdHJpY3RNb2RlID0gdHJ1ZTtcblxuSW50ZXJuYWxDYWNoZS5wcm90b3R5cGUuZnVsbFBhdGggPSB1bmRlZmluZWQ7XG5JbnRlcm5hbENhY2hlLnByb3RvdHlwZS5zZWxlY3RlZCA9IHVuZGVmaW5lZDtcbkludGVybmFsQ2FjaGUucHJvdG90eXBlLnNoYXJkdmFsID0gdW5kZWZpbmVkO1xuSW50ZXJuYWxDYWNoZS5wcm90b3R5cGUuc2F2ZUVycm9yID0gdW5kZWZpbmVkO1xuSW50ZXJuYWxDYWNoZS5wcm90b3R5cGUudmFsaWRhdGlvbkVycm9yID0gdW5kZWZpbmVkO1xuSW50ZXJuYWxDYWNoZS5wcm90b3R5cGUuYWRob2NQYXRocyA9IHVuZGVmaW5lZDtcbkludGVybmFsQ2FjaGUucHJvdG90eXBlLnJlbW92aW5nID0gdW5kZWZpbmVkO1xuSW50ZXJuYWxDYWNoZS5wcm90b3R5cGUuaW5zZXJ0aW5nID0gdW5kZWZpbmVkO1xuSW50ZXJuYWxDYWNoZS5wcm90b3R5cGUuc2F2aW5nID0gdW5kZWZpbmVkO1xuSW50ZXJuYWxDYWNoZS5wcm90b3R5cGUudmVyc2lvbiA9IHVuZGVmaW5lZDtcbkludGVybmFsQ2FjaGUucHJvdG90eXBlLl9pZCA9IHVuZGVmaW5lZDtcbkludGVybmFsQ2FjaGUucHJvdG90eXBlLm93bmVyRG9jdW1lbnQgPSB1bmRlZmluZWQ7XG5JbnRlcm5hbENhY2hlLnByb3RvdHlwZS5wb3B1bGF0ZSA9IHVuZGVmaW5lZDsgLy8gd2hhdCB3ZSB3YW50IHRvIHBvcHVsYXRlIGluIHRoaXMgZG9jXG5JbnRlcm5hbENhY2hlLnByb3RvdHlwZS5wb3B1bGF0ZWQgPSB1bmRlZmluZWQ7Ly8gdGhlIF9pZHMgdGhhdCBoYXZlIGJlZW4gcG9wdWxhdGVkXG5JbnRlcm5hbENhY2hlLnByb3RvdHlwZS5wcmltaXRpdmVBdG9taWNzID0gdW5kZWZpbmVkO1xuXG4vKipcbiAqIElmIGBmYWxzZWAsIHRoaXMgZG9jdW1lbnQgd2FzIG5vdCB0aGUgcmVzdWx0IG9mIHBvcHVsYXRpb24uXG4gKiBJZiBgdHJ1ZWAsIHRoaXMgZG9jdW1lbnQgaXMgYSBwb3B1bGF0ZWQgZG9jIHVuZGVybmVhdGggYW5vdGhlciBkb2NcbiAqIElmIGFuIG9iamVjdCwgdGhpcyBkb2N1bWVudCBpcyBhIHBvcHVsYXRlZCBkb2MgYW5kIHRoZSBgdmFsdWVgIHByb3BlcnR5IG9mIHRoZVxuICogb2JqZWN0IGNvbnRhaW5zIHRoZSBvcmlnaW5hbCBkZXBvcHVsYXRlZCB2YWx1ZS5cbiAqL1xuSW50ZXJuYWxDYWNoZS5wcm90b3R5cGUud2FzUG9wdWxhdGVkID0gZmFsc2U7XG5cbkludGVybmFsQ2FjaGUucHJvdG90eXBlLnNjb3BlID0gdW5kZWZpbmVkO1xuXG5JbnRlcm5hbENhY2hlLnByb3RvdHlwZS5zZXNzaW9uID0gbnVsbDtcbkludGVybmFsQ2FjaGUucHJvdG90eXBlLnBhdGhzVG9TY29wZXMgPSBudWxsO1xuSW50ZXJuYWxDYWNoZS5wcm90b3R5cGUuY2FjaGVkUmVxdWlyZWQgPSBudWxsO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/internal.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/model.js":
/*!*****************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/model.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst Aggregate = __webpack_require__(/*! ./aggregate */ \"../backend/node_modules/mongoose/lib/aggregate.js\");\nconst ChangeStream = __webpack_require__(/*! ./cursor/changeStream */ \"../backend/node_modules/mongoose/lib/cursor/changeStream.js\");\nconst Document = __webpack_require__(/*! ./document */ \"../backend/node_modules/mongoose/lib/document.js\");\nconst DocumentNotFoundError = __webpack_require__(/*! ./error/notFound */ \"../backend/node_modules/mongoose/lib/error/notFound.js\");\nconst DivergentArrayError = __webpack_require__(/*! ./error/divergentArray */ \"../backend/node_modules/mongoose/lib/error/divergentArray.js\");\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Kareem = __webpack_require__(/*! kareem */ \"../backend/node_modules/kareem/index.js\");\nconst MongooseBuffer = __webpack_require__(/*! ./types/buffer */ \"../backend/node_modules/mongoose/lib/types/buffer.js\");\nconst MongooseError = __webpack_require__(/*! ./error/index */ \"../backend/node_modules/mongoose/lib/error/index.js\");\nconst ObjectParameterError = __webpack_require__(/*! ./error/objectParameter */ \"../backend/node_modules/mongoose/lib/error/objectParameter.js\");\nconst OverwriteModelError = __webpack_require__(/*! ./error/overwriteModel */ \"../backend/node_modules/mongoose/lib/error/overwriteModel.js\");\nconst Query = __webpack_require__(/*! ./query */ \"../backend/node_modules/mongoose/lib/query.js\");\nconst SaveOptions = __webpack_require__(/*! ./options/saveOptions */ \"../backend/node_modules/mongoose/lib/options/saveOptions.js\");\nconst Schema = __webpack_require__(/*! ./schema */ \"../backend/node_modules/mongoose/lib/schema.js\");\nconst ValidationError = __webpack_require__(/*! ./error/validation */ \"../backend/node_modules/mongoose/lib/error/validation.js\");\nconst VersionError = __webpack_require__(/*! ./error/version */ \"../backend/node_modules/mongoose/lib/error/version.js\");\nconst ParallelSaveError = __webpack_require__(/*! ./error/parallelSave */ \"../backend/node_modules/mongoose/lib/error/parallelSave.js\");\nconst applyDefaultsHelper = __webpack_require__(/*! ./helpers/document/applyDefaults */ \"../backend/node_modules/mongoose/lib/helpers/document/applyDefaults.js\");\nconst applyDefaultsToPOJO = __webpack_require__(/*! ./helpers/model/applyDefaultsToPOJO */ \"../backend/node_modules/mongoose/lib/helpers/model/applyDefaultsToPOJO.js\");\nconst applyEmbeddedDiscriminators = __webpack_require__(/*! ./helpers/discriminator/applyEmbeddedDiscriminators */ \"../backend/node_modules/mongoose/lib/helpers/discriminator/applyEmbeddedDiscriminators.js\");\nconst applyHooks = __webpack_require__(/*! ./helpers/model/applyHooks */ \"../backend/node_modules/mongoose/lib/helpers/model/applyHooks.js\");\nconst applyMethods = __webpack_require__(/*! ./helpers/model/applyMethods */ \"../backend/node_modules/mongoose/lib/helpers/model/applyMethods.js\");\nconst applyProjection = __webpack_require__(/*! ./helpers/projection/applyProjection */ \"../backend/node_modules/mongoose/lib/helpers/projection/applyProjection.js\");\nconst applySchemaCollation = __webpack_require__(/*! ./helpers/indexes/applySchemaCollation */ \"../backend/node_modules/mongoose/lib/helpers/indexes/applySchemaCollation.js\");\nconst applyStaticHooks = __webpack_require__(/*! ./helpers/model/applyStaticHooks */ \"../backend/node_modules/mongoose/lib/helpers/model/applyStaticHooks.js\");\nconst applyStatics = __webpack_require__(/*! ./helpers/model/applyStatics */ \"../backend/node_modules/mongoose/lib/helpers/model/applyStatics.js\");\nconst applyWriteConcern = __webpack_require__(/*! ./helpers/schema/applyWriteConcern */ \"../backend/node_modules/mongoose/lib/helpers/schema/applyWriteConcern.js\");\nconst assignVals = __webpack_require__(/*! ./helpers/populate/assignVals */ \"../backend/node_modules/mongoose/lib/helpers/populate/assignVals.js\");\nconst castBulkWrite = __webpack_require__(/*! ./helpers/model/castBulkWrite */ \"../backend/node_modules/mongoose/lib/helpers/model/castBulkWrite.js\");\nconst clone = __webpack_require__(/*! ./helpers/clone */ \"../backend/node_modules/mongoose/lib/helpers/clone.js\");\nconst createPopulateQueryFilter = __webpack_require__(/*! ./helpers/populate/createPopulateQueryFilter */ \"../backend/node_modules/mongoose/lib/helpers/populate/createPopulateQueryFilter.js\");\nconst decorateUpdateWithVersionKey = __webpack_require__(/*! ./helpers/update/decorateUpdateWithVersionKey */ \"../backend/node_modules/mongoose/lib/helpers/update/decorateUpdateWithVersionKey.js\");\nconst getDefaultBulkwriteResult = __webpack_require__(/*! ./helpers/getDefaultBulkwriteResult */ \"../backend/node_modules/mongoose/lib/helpers/getDefaultBulkwriteResult.js\");\nconst getSchemaDiscriminatorByValue = __webpack_require__(/*! ./helpers/discriminator/getSchemaDiscriminatorByValue */ \"../backend/node_modules/mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js\");\nconst discriminator = __webpack_require__(/*! ./helpers/model/discriminator */ \"../backend/node_modules/mongoose/lib/helpers/model/discriminator.js\");\nconst firstKey = __webpack_require__(/*! ./helpers/firstKey */ \"../backend/node_modules/mongoose/lib/helpers/firstKey.js\");\nconst each = __webpack_require__(/*! ./helpers/each */ \"../backend/node_modules/mongoose/lib/helpers/each.js\");\nconst get = __webpack_require__(/*! ./helpers/get */ \"../backend/node_modules/mongoose/lib/helpers/get.js\");\nconst getConstructorName = __webpack_require__(/*! ./helpers/getConstructorName */ \"../backend/node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst getDiscriminatorByValue = __webpack_require__(/*! ./helpers/discriminator/getDiscriminatorByValue */ \"../backend/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\nconst getModelsMapForPopulate = __webpack_require__(/*! ./helpers/populate/getModelsMapForPopulate */ \"../backend/node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js\");\nconst immediate = __webpack_require__(/*! ./helpers/immediate */ \"../backend/node_modules/mongoose/lib/helpers/immediate.js\");\nconst internalToObjectOptions = (__webpack_require__(/*! ./options */ \"../backend/node_modules/mongoose/lib/options.js\").internalToObjectOptions);\nconst isDefaultIdIndex = __webpack_require__(/*! ./helpers/indexes/isDefaultIdIndex */ \"../backend/node_modules/mongoose/lib/helpers/indexes/isDefaultIdIndex.js\");\nconst isIndexEqual = __webpack_require__(/*! ./helpers/indexes/isIndexEqual */ \"../backend/node_modules/mongoose/lib/helpers/indexes/isIndexEqual.js\");\nconst {\n  getRelatedDBIndexes,\n  getRelatedSchemaIndexes\n} = __webpack_require__(/*! ./helpers/indexes/getRelatedIndexes */ \"../backend/node_modules/mongoose/lib/helpers/indexes/getRelatedIndexes.js\");\nconst isPathExcluded = __webpack_require__(/*! ./helpers/projection/isPathExcluded */ \"../backend/node_modules/mongoose/lib/helpers/projection/isPathExcluded.js\");\nconst decorateDiscriminatorIndexOptions = __webpack_require__(/*! ./helpers/indexes/decorateDiscriminatorIndexOptions */ \"../backend/node_modules/mongoose/lib/helpers/indexes/decorateDiscriminatorIndexOptions.js\");\nconst isPathSelectedInclusive = __webpack_require__(/*! ./helpers/projection/isPathSelectedInclusive */ \"../backend/node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js\");\nconst leanPopulateMap = __webpack_require__(/*! ./helpers/populate/leanPopulateMap */ \"../backend/node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js\");\nconst parallelLimit = __webpack_require__(/*! ./helpers/parallelLimit */ \"../backend/node_modules/mongoose/lib/helpers/parallelLimit.js\");\nconst parentPaths = __webpack_require__(/*! ./helpers/path/parentPaths */ \"../backend/node_modules/mongoose/lib/helpers/path/parentPaths.js\");\nconst prepareDiscriminatorPipeline = __webpack_require__(/*! ./helpers/aggregate/prepareDiscriminatorPipeline */ \"../backend/node_modules/mongoose/lib/helpers/aggregate/prepareDiscriminatorPipeline.js\");\nconst pushNestedArrayPaths = __webpack_require__(/*! ./helpers/model/pushNestedArrayPaths */ \"../backend/node_modules/mongoose/lib/helpers/model/pushNestedArrayPaths.js\");\nconst removeDeselectedForeignField = __webpack_require__(/*! ./helpers/populate/removeDeselectedForeignField */ \"../backend/node_modules/mongoose/lib/helpers/populate/removeDeselectedForeignField.js\");\nconst setDottedPath = __webpack_require__(/*! ./helpers/path/setDottedPath */ \"../backend/node_modules/mongoose/lib/helpers/path/setDottedPath.js\");\nconst STATES = __webpack_require__(/*! ./connectionState */ \"../backend/node_modules/mongoose/lib/connectionState.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst utils = __webpack_require__(/*! ./utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\nconst MongooseBulkWriteError = __webpack_require__(/*! ./error/bulkWriteError */ \"../backend/node_modules/mongoose/lib/error/bulkWriteError.js\");\nconst minimize = __webpack_require__(/*! ./helpers/minimize */ \"../backend/node_modules/mongoose/lib/helpers/minimize.js\");\n\nconst VERSION_WHERE = 1;\nconst VERSION_INC = 2;\nconst VERSION_ALL = VERSION_WHERE | VERSION_INC;\n\nconst arrayAtomicsSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsSymbol);\nconst modelCollectionSymbol = Symbol('mongoose#Model#collection');\nconst modelDbSymbol = Symbol('mongoose#Model#db');\nconst modelSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").modelSymbol);\nconst subclassedSymbol = Symbol('mongoose#Model#subclassed');\n\nconst saveToObjectOptions = Object.assign({}, internalToObjectOptions, {\n  bson: true,\n  flattenObjectIds: false\n});\n\n/**\n * A Model is a class that's your primary tool for interacting with MongoDB.\n * An instance of a Model is called a [Document](https://mongoosejs.com/docs/api/document.html#Document).\n *\n * In Mongoose, the term \"Model\" refers to subclasses of the `mongoose.Model`\n * class. You should not use the `mongoose.Model` class directly. The\n * [`mongoose.model()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.model()) and\n * [`connection.model()`](https://mongoosejs.com/docs/api/connection.html#Connection.prototype.model()) functions\n * create subclasses of `mongoose.Model` as shown below.\n *\n * #### Example:\n *\n *     // `UserModel` is a \"Model\", a subclass of `mongoose.Model`.\n *     const UserModel = mongoose.model('User', new Schema({ name: String }));\n *\n *     // You can use a Model to create new documents using `new`:\n *     const userDoc = new UserModel({ name: 'Foo' });\n *     await userDoc.save();\n *\n *     // You also use a model to create queries:\n *     const userFromDb = await UserModel.findOne({ name: 'Foo' });\n *\n * @param {Object} doc values for initial set\n * @param {Object} [fields] optional object containing the fields that were selected in the query which returned this document. You do **not** need to set this parameter to ensure Mongoose handles your [query projection](https://mongoosejs.com/docs/api/query.html#Query.prototype.select()).\n * @param {Boolean} [skipId=false] optional boolean. If true, mongoose doesn't add an `_id` field to the document.\n * @inherits Document https://mongoosejs.com/docs/api/document.html\n * @event `error`: If listening to this event, 'error' is emitted when a document was saved and an `error` occurred. If not listening, the event bubbles to the connection used to create this Model.\n * @event `index`: Emitted after `Model#ensureIndexes` completes. If an error occurred it is passed with the event.\n * @event `index-single-start`: Emitted when an individual index starts within `Model#ensureIndexes`. The fields and options being used to build the index are also passed with the event.\n * @event `index-single-done`: Emitted when an individual index finishes within `Model#ensureIndexes`. If an error occurred it is passed with the event. The fields, options, and index name are also passed.\n * @api public\n */\n\nfunction Model(doc, fields, skipId) {\n  if (fields instanceof Schema) {\n    throw new TypeError('2nd argument to `Model` constructor must be a POJO or string, ' +\n      '**not** a schema. Make sure you\\'re calling `mongoose.model()`, not ' +\n      '`mongoose.Model()`.');\n  }\n  if (typeof doc === 'string') {\n    throw new TypeError('First argument to `Model` constructor must be an object, ' +\n      '**not** a string. Make sure you\\'re calling `mongoose.model()`, not ' +\n      '`mongoose.Model()`.');\n  }\n  Document.call(this, doc, fields, skipId);\n}\n\n/**\n * Inherits from Document.\n *\n * All Model.prototype features are available on\n * top level (non-sub) documents.\n * @api private\n */\n\nObject.setPrototypeOf(Model.prototype, Document.prototype);\nModel.prototype.$isMongooseModelPrototype = true;\n\n/**\n * Connection the model uses.\n *\n * @api public\n * @property db\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.db;\n\n/**\n * The collection instance this model uses.\n * A Mongoose collection is a thin wrapper around a [MongoDB Node.js driver collection]([MongoDB Node.js driver collection](https://mongodb.github.io/node-mongodb-native/Next/classes/Collection.html)).\n * Using `Model.collection` means you bypass Mongoose middleware, validation, and casting.\n *\n * This property is read-only. Modifying this property is a no-op.\n *\n * @api public\n * @property collection\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.collection;\n\n/**\n * Internal collection the model uses.\n *\n * This property is read-only. Modifying this property is a no-op.\n *\n * @api private\n * @property collection\n * @memberOf Model\n * @instance\n */\n\n\nModel.prototype.$__collection;\n\n/**\n * The name of the model\n *\n * @api public\n * @property modelName\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.modelName;\n\n/**\n * Additional properties to attach to the query when calling `save()` and\n * `isNew` is false.\n *\n * @api public\n * @property $where\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$where;\n\n/**\n * If this is a discriminator model, `baseModelName` is the name of\n * the base model.\n *\n * @api public\n * @property baseModelName\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.baseModelName;\n\n/**\n * Event emitter that reports any errors that occurred. Useful for global error\n * handling.\n *\n * #### Example:\n *\n *     MyModel.events.on('error', err => console.log(err.message));\n *\n *     // Prints a 'CastError' because of the above handler\n *     await MyModel.findOne({ _id: 'Not a valid ObjectId' }).catch(noop);\n *\n * @api public\n * @property events\n * @fires error whenever any query or model function errors\n * @memberOf Model\n * @static\n */\n\nModel.events;\n\n/**\n * Compiled middleware for this model. Set in `applyHooks()`.\n *\n * @api private\n * @property _middleware\n * @memberOf Model\n * @static\n */\n\nModel._middleware;\n\n/*!\n * ignore\n */\n\nfunction _applyCustomWhere(doc, where) {\n  if (doc.$where == null) {\n    return;\n  }\n  for (const key of Object.keys(doc.$where)) {\n    where[key] = doc.$where[key];\n  }\n}\n\n/*!\n * ignore\n */\n\nModel.prototype.$__handleSave = function(options, callback) {\n  const saveOptions = {};\n\n  applyWriteConcern(this.$__schema, options);\n  if (typeof options.writeConcern !== 'undefined') {\n    saveOptions.writeConcern = {};\n    if ('w' in options.writeConcern) {\n      saveOptions.writeConcern.w = options.writeConcern.w;\n    }\n    if ('j' in options.writeConcern) {\n      saveOptions.writeConcern.j = options.writeConcern.j;\n    }\n    if ('wtimeout' in options.writeConcern) {\n      saveOptions.writeConcern.wtimeout = options.writeConcern.wtimeout;\n    }\n  } else {\n    if ('w' in options) {\n      saveOptions.w = options.w;\n    }\n    if ('j' in options) {\n      saveOptions.j = options.j;\n    }\n    if ('wtimeout' in options) {\n      saveOptions.wtimeout = options.wtimeout;\n    }\n  }\n  if ('checkKeys' in options) {\n    saveOptions.checkKeys = options.checkKeys;\n  }\n\n  const session = this.$session();\n  if (!saveOptions.hasOwnProperty('session') && session != null) {\n    saveOptions.session = session;\n  }\n  if (this.$isNew) {\n    // send entire doc\n    const obj = this.toObject(saveToObjectOptions);\n    if ((obj || {})._id === void 0) {\n      // documents must have an _id else mongoose won't know\n      // what to update later if more changes are made. the user\n      // wouldn't know what _id was generated by mongodb either\n      // nor would the ObjectId generated by mongodb necessarily\n      // match the schema definition.\n      immediate(function() {\n        callback(new MongooseError('document must have an _id before saving'));\n      });\n      return;\n    }\n\n    this.$__version(true, obj);\n    this[modelCollectionSymbol].insertOne(obj, saveOptions).then(\n      ret => callback(null, ret),\n      err => {\n        _setIsNew(this, true);\n\n        callback(err, null);\n      }\n    );\n\n    this.$__reset();\n    _setIsNew(this, false);\n    // Make it possible to retry the insert\n    this.$__.inserting = true;\n    return;\n  }\n\n  // Make sure we don't treat it as a new object on error,\n  // since it already exists\n  this.$__.inserting = false;\n  const delta = this.$__delta();\n\n  if (options.pathsToSave) {\n    for (const key in delta[1]['$set']) {\n      if (options.pathsToSave.includes(key)) {\n        continue;\n      } else if (options.pathsToSave.some(pathToSave => key.slice(0, pathToSave.length) === pathToSave && key.charAt(pathToSave.length) === '.')) {\n        continue;\n      } else {\n        delete delta[1]['$set'][key];\n      }\n    }\n  }\n  if (delta) {\n    if (delta instanceof MongooseError) {\n      callback(delta);\n      return;\n    }\n\n    const where = this.$__where(delta[0]);\n    if (where instanceof MongooseError) {\n      callback(where);\n      return;\n    }\n\n    _applyCustomWhere(this, where);\n\n    const update = delta[1];\n    if (this.$__schema.options.minimize) {\n      for (const updateOp of Object.values(update)) {\n        if (updateOp == null) {\n          continue;\n        }\n        for (const key of Object.keys(updateOp)) {\n          if (updateOp[key] == null || typeof updateOp[key] !== 'object') {\n            continue;\n          }\n          if (!utils.isPOJO(updateOp[key])) {\n            continue;\n          }\n          minimize(updateOp[key]);\n          if (Object.keys(updateOp[key]).length === 0) {\n            delete updateOp[key];\n            update.$unset = update.$unset || {};\n            update.$unset[key] = 1;\n          }\n        }\n      }\n    }\n\n    this[modelCollectionSymbol].updateOne(where, update, saveOptions).then(\n      ret => {\n        ret.$where = where;\n        callback(null, ret);\n      },\n      err => {\n        this.$__undoReset();\n\n        callback(err);\n      }\n    );\n  } else {\n    handleEmptyUpdate.call(this);\n    return;\n  }\n\n  // store the modified paths before the document is reset\n  this.$__.modifiedPaths = this.modifiedPaths();\n  this.$__reset();\n\n  _setIsNew(this, false);\n\n  function handleEmptyUpdate() {\n    const optionsWithCustomValues = Object.assign({}, options, saveOptions);\n    const where = this.$__where();\n    const optimisticConcurrency = this.$__schema.options.optimisticConcurrency;\n    if (optimisticConcurrency && !Array.isArray(optimisticConcurrency)) {\n      const key = this.$__schema.options.versionKey;\n      const val = this.$__getValue(key);\n      if (val != null) {\n        where[key] = val;\n      }\n    }\n    this.constructor.collection.findOne(where, optionsWithCustomValues)\n      .then(documentExists => {\n        const matchedCount = !documentExists ? 0 : 1;\n        callback(null, { $where: where, matchedCount });\n      })\n      .catch(callback);\n  }\n};\n\n/*!\n * ignore\n */\n\nModel.prototype.$__save = function(options, callback) {\n  this.$__handleSave(options, (error, result) => {\n    if (error) {\n      const hooks = this.$__schema.s.hooks;\n      return hooks.execPost('save:error', this, [this], { error: error }, (error) => {\n        callback(error, this);\n      });\n    }\n    let numAffected = 0;\n    const writeConcern = options != null ?\n      options.writeConcern != null ?\n        options.writeConcern.w :\n        options.w :\n      0;\n    if (writeConcern !== 0) {\n      // Skip checking if write succeeded if writeConcern is set to\n      // unacknowledged writes, because otherwise `numAffected` will always be 0\n      if (result != null) {\n        if (Array.isArray(result)) {\n          numAffected = result.length;\n        } else if (result.matchedCount != null) {\n          numAffected = result.matchedCount;\n        } else {\n          numAffected = result;\n        }\n      }\n\n      const versionBump = this.$__.version;\n      // was this an update that required a version bump?\n      if (versionBump && !this.$__.inserting) {\n        const doIncrement = VERSION_INC === (VERSION_INC & this.$__.version);\n        this.$__.version = undefined;\n        const key = this.$__schema.options.versionKey;\n        const version = this.$__getValue(key) || 0;\n        if (numAffected <= 0) {\n          // the update failed. pass an error back\n          this.$__undoReset();\n          const err = this.$__.$versionError ||\n            new VersionError(this, version, this.$__.modifiedPaths);\n          return callback(err);\n        }\n\n        // increment version if was successful\n        if (doIncrement) {\n          this.$__setValue(key, version + 1);\n        }\n      }\n      if (result != null && numAffected <= 0) {\n        this.$__undoReset();\n        error = new DocumentNotFoundError(result.$where,\n          this.constructor.modelName, numAffected, result);\n        const hooks = this.$__schema.s.hooks;\n        return hooks.execPost('save:error', this, [this], { error: error }, (error) => {\n          callback(error, this);\n        });\n      }\n    }\n    this.$__.saving = undefined;\n    this.$__.savedState = {};\n    this.$emit('save', this, numAffected);\n    this.constructor.emit('save', this, numAffected);\n    callback(null, this);\n  });\n};\n\n/*!\n * ignore\n */\n\nfunction generateVersionError(doc, modifiedPaths) {\n  const key = doc.$__schema.options.versionKey;\n  if (!key) {\n    return null;\n  }\n  const version = doc.$__getValue(key) || 0;\n  return new VersionError(doc, version, modifiedPaths);\n}\n\n/**\n * Saves this document by inserting a new document into the database if [document.isNew](https://mongoosejs.com/docs/api/document.html#Document.prototype.isNew) is `true`,\n * or sends an [updateOne](https://mongoosejs.com/docs/api/document.html#Document.prototype.updateOne()) operation with just the modified paths if `isNew` is `false`.\n *\n * #### Example:\n *\n *     product.sold = Date.now();\n *     product = await product.save();\n *\n * If save is successful, the returned promise will fulfill with the document\n * saved.\n *\n * #### Example:\n *\n *     const newProduct = await product.save();\n *     newProduct === product; // true\n *\n * @param {Object} [options] options optional options\n * @param {Session} [options.session=null] the [session](https://www.mongodb.com/docs/manual/reference/server-sessions/) associated with this save operation. If not specified, defaults to the [document's associated session](https://mongoosejs.com/docs/api/document.html#Document.prototype.session()).\n * @param {Object} [options.safe] (DEPRECATED) overrides [schema's safe option](https://mongoosejs.com/docs/guide.html#safe). Use the `w` option instead.\n * @param {Boolean} [options.validateBeforeSave] set to false to save without validating.\n * @param {Boolean} [options.validateModifiedOnly=false] if `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @param {Number|String} [options.w] set the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#w-option). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.j] set to true for MongoDB to wait until this `save()` has been [journaled before resolving the returned promise](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Number} [options.wtimeout] sets a [timeout for the write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern).\n * @param {Boolean} [options.checkKeys=true] the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to `false` to skip that check. See [restrictions on field names](https://docs.mongodb.com/manual/reference/limits/#mongodb-limit-Restrictions-on-Field-Names)\n * @param {Boolean} [options.timestamps=true] if `false` and [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this `save()`.\n * @param {Array} [options.pathsToSave] An array of paths that tell mongoose to only validate and save the paths in `pathsToSave`.\n * @throws {DocumentNotFoundError} if this [save updates an existing document](https://mongoosejs.com/docs/api/document.html#Document.prototype.isNew) but the document doesn't exist in the database. For example, you will get this error if the document is [deleted between when you retrieved the document and when you saved it](documents.html#updating).\n * @return {Promise}\n * @api public\n * @see middleware https://mongoosejs.com/docs/middleware.html\n */\n\nModel.prototype.save = async function save(options) {\n  if (typeof options === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.prototype.save() no longer accepts a callback');\n  }\n\n  let parallelSave;\n  this.$op = 'save';\n\n  if (this.$__.saving) {\n    parallelSave = new ParallelSaveError(this);\n  } else {\n    this.$__.saving = new ParallelSaveError(this);\n  }\n\n  options = new SaveOptions(options);\n  if (options.hasOwnProperty('session')) {\n    this.$session(options.session);\n  }\n  if (this.$__.timestamps != null) {\n    options.timestamps = this.$__.timestamps;\n  }\n  this.$__.$versionError = generateVersionError(this, this.modifiedPaths());\n\n  if (parallelSave) {\n    this.$__handleReject(parallelSave);\n    throw parallelSave;\n  }\n\n  this.$__.saveOptions = options;\n\n  await new Promise((resolve, reject) => {\n    this.$__save(options, error => {\n      this.$__.saving = null;\n      this.$__.saveOptions = null;\n      this.$__.$versionError = null;\n      this.$op = null;\n      if (error != null) {\n        this.$__handleReject(error);\n        return reject(error);\n      }\n\n      resolve();\n    });\n  });\n\n  return this;\n};\n\nModel.prototype.$save = Model.prototype.save;\n\n/**\n * Determines whether versioning should be skipped for the given path\n *\n * @param {Document} self\n * @param {String} path\n * @return {Boolean} true if versioning should be skipped for the given path\n * @api private\n */\nfunction shouldSkipVersioning(self, path) {\n  const skipVersioning = self.$__schema.options.skipVersioning;\n  if (!skipVersioning) return false;\n\n  // Remove any array indexes from the path\n  path = path.replace(/\\.\\d+\\./, '.');\n\n  return skipVersioning[path];\n}\n\n/**\n * Apply the operation to the delta (update) clause as\n * well as track versioning for our where clause.\n *\n * @param {Document} self\n * @param {Object} where Unused\n * @param {Object} delta\n * @param {Object} data\n * @param {Mixed} val\n * @param {String} [op]\n * @api private\n */\n\nfunction operand(self, where, delta, data, val, op) {\n  // delta\n  op || (op = '$set');\n  if (!delta[op]) delta[op] = {};\n  delta[op][data.path] = val;\n  // disabled versioning?\n  if (self.$__schema.options.versionKey === false) return;\n\n  // path excluded from versioning?\n  if (shouldSkipVersioning(self, data.path)) return;\n\n  // already marked for versioning?\n  if (VERSION_ALL === (VERSION_ALL & self.$__.version)) return;\n\n  if (self.$__schema.options.optimisticConcurrency) {\n    return;\n  }\n\n  switch (op) {\n    case '$set':\n    case '$unset':\n    case '$pop':\n    case '$pull':\n    case '$pullAll':\n    case '$push':\n    case '$addToSet':\n    case '$inc':\n      break;\n    default:\n      // nothing to do\n      return;\n  }\n\n  // ensure updates sent with positional notation are\n  // editing the correct array element.\n  // only increment the version if an array position changes.\n  // modifying elements of an array is ok if position does not change.\n  if (op === '$push' || op === '$addToSet' || op === '$pullAll' || op === '$pull') {\n    if (/\\.\\d+\\.|\\.\\d+$/.test(data.path)) {\n      increment.call(self);\n    } else {\n      self.$__.version = VERSION_INC;\n    }\n  } else if (/^\\$p/.test(op)) {\n    // potentially changing array positions\n    increment.call(self);\n  } else if (Array.isArray(val)) {\n    // $set an array\n    increment.call(self);\n  } else if (/\\.\\d+\\.|\\.\\d+$/.test(data.path)) {\n    // now handling $set, $unset\n    // subpath of array\n    self.$__.version = VERSION_WHERE;\n  }\n}\n\n/**\n * Compiles an update and where clause for a `val` with _atomics.\n *\n * @param {Document} self\n * @param {Object} where\n * @param {Object} delta\n * @param {Object} data\n * @param {Array} value\n * @api private\n */\n\nfunction handleAtomics(self, where, delta, data, value) {\n  if (delta.$set && delta.$set[data.path]) {\n    // $set has precedence over other atomics\n    return;\n  }\n\n  if (typeof value.$__getAtomics === 'function') {\n    value.$__getAtomics().forEach(function(atomic) {\n      const op = atomic[0];\n      const val = atomic[1];\n      operand(self, where, delta, data, val, op);\n    });\n    return;\n  }\n\n  // legacy support for plugins\n\n  const atomics = value[arrayAtomicsSymbol];\n  const ops = Object.keys(atomics);\n  let i = ops.length;\n  let val;\n  let op;\n\n  if (i === 0) {\n    // $set\n\n    if (utils.isMongooseObject(value)) {\n      value = value.toObject({ depopulate: 1, _isNested: true });\n    } else if (value.valueOf) {\n      value = value.valueOf();\n    }\n\n    return operand(self, where, delta, data, value);\n  }\n\n  function iter(mem) {\n    return utils.isMongooseObject(mem)\n      ? mem.toObject({ depopulate: 1, _isNested: true })\n      : mem;\n  }\n\n  while (i--) {\n    op = ops[i];\n    val = atomics[op];\n\n    if (utils.isMongooseObject(val)) {\n      val = val.toObject({ depopulate: true, transform: false, _isNested: true });\n    } else if (Array.isArray(val)) {\n      val = val.map(iter);\n    } else if (val.valueOf) {\n      val = val.valueOf();\n    }\n\n    if (op === '$addToSet') {\n      val = { $each: val };\n    }\n\n    operand(self, where, delta, data, val, op);\n  }\n}\n\n/**\n * Produces a special query document of the modified properties used in updates.\n *\n * @api private\n * @method $__delta\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$__delta = function() {\n  const dirty = this.$__dirty();\n  const optimisticConcurrency = this.$__schema.options.optimisticConcurrency;\n  if (optimisticConcurrency) {\n    if (Array.isArray(optimisticConcurrency)) {\n      const optCon = new Set(optimisticConcurrency);\n      const modPaths = this.modifiedPaths();\n      if (modPaths.find(path => optCon.has(path))) {\n        this.$__.version = dirty.length ? VERSION_ALL : VERSION_WHERE;\n      }\n    } else {\n      this.$__.version = dirty.length ? VERSION_ALL : VERSION_WHERE;\n    }\n  }\n\n  if (!dirty.length && VERSION_ALL !== this.$__.version) {\n    return;\n  }\n  const where = {};\n  const delta = {};\n  const len = dirty.length;\n  const divergent = [];\n  let d = 0;\n\n  where._id = this._doc._id;\n  // If `_id` is an object, need to depopulate, but also need to be careful\n  // because `_id` can technically be null (see gh-6406)\n  if ((where && where._id && where._id.$__ || null) != null) {\n    where._id = where._id.toObject({ transform: false, depopulate: true });\n  }\n  for (; d < len; ++d) {\n    const data = dirty[d];\n    let value = data.value;\n    const match = checkDivergentArray(this, data.path, value);\n    if (match) {\n      divergent.push(match);\n      continue;\n    }\n\n    const pop = this.$populated(data.path, true);\n    if (!pop && this.$__.selected) {\n      // If any array was selected using an $elemMatch projection, we alter the path and where clause\n      // NOTE: MongoDB only supports projected $elemMatch on top level array.\n      const pathSplit = data.path.split('.');\n      const top = pathSplit[0];\n      if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {\n        // If the selected array entry was modified\n        if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === 'undefined') {\n          where[top] = this.$__.selected[top];\n          pathSplit[1] = '$';\n          data.path = pathSplit.join('.');\n        }\n        // if the selected array was modified in any other way throw an error\n        else {\n          divergent.push(data.path);\n          continue;\n        }\n      }\n    }\n\n    // If this path is set to default, and either this path or one of\n    // its parents is excluded, don't treat this path as dirty.\n    if (this.$isDefault(data.path) && this.$__.selected) {\n      if (data.path.indexOf('.') === -1 && isPathExcluded(this.$__.selected, data.path)) {\n        continue;\n      }\n\n      const pathsToCheck = parentPaths(data.path);\n      if (pathsToCheck.find(path => isPathExcluded(this.$__.isSelected, path))) {\n        continue;\n      }\n    }\n\n    if (divergent.length) continue;\n    if (value === undefined) {\n      operand(this, where, delta, data, 1, '$unset');\n    } else if (value === null) {\n      operand(this, where, delta, data, null);\n    } else if (utils.isMongooseArray(value) && value.$path() && value[arrayAtomicsSymbol]) {\n      // arrays and other custom types (support plugins etc)\n      handleAtomics(this, where, delta, data, value);\n    } else if (value[MongooseBuffer.pathSymbol] && Buffer.isBuffer(value)) {\n      // MongooseBuffer\n      value = value.toObject();\n      operand(this, where, delta, data, value);\n    } else {\n      if (this.$__.primitiveAtomics && this.$__.primitiveAtomics[data.path] != null) {\n        const val = this.$__.primitiveAtomics[data.path];\n        const op = firstKey(val);\n        operand(this, where, delta, data, val[op], op);\n      } else {\n        value = clone(value, {\n          depopulate: true,\n          transform: false,\n          virtuals: false,\n          getters: false,\n          omitUndefined: true,\n          _isNested: true\n        });\n        operand(this, where, delta, data, value);\n      }\n    }\n  }\n\n  if (divergent.length) {\n    return new DivergentArrayError(divergent);\n  }\n\n  if (this.$__.version) {\n    this.$__version(where, delta);\n  }\n\n  if (Object.keys(delta).length === 0) {\n    return [where, null];\n  }\n\n  return [where, delta];\n};\n\n/**\n * Determine if array was populated with some form of filter and is now\n * being updated in a manner which could overwrite data unintentionally.\n *\n * @see https://github.com/Automattic/mongoose/issues/1334\n * @param {Document} doc\n * @param {String} path\n * @param {Any} array\n * @return {String|undefined}\n * @api private\n */\n\nfunction checkDivergentArray(doc, path, array) {\n  // see if we populated this path\n  const pop = doc.$populated(path, true);\n\n  if (!pop && doc.$__.selected) {\n    // If any array was selected using an $elemMatch projection, we deny the update.\n    // NOTE: MongoDB only supports projected $elemMatch on top level array.\n    const top = path.split('.')[0];\n    if (doc.$__.selected[top + '.$']) {\n      return top;\n    }\n  }\n\n  if (!(pop && utils.isMongooseArray(array))) return;\n\n  // If the array was populated using options that prevented all\n  // documents from being returned (match, skip, limit) or they\n  // deselected the _id field, $pop and $set of the array are\n  // not safe operations. If _id was deselected, we do not know\n  // how to remove elements. $pop will pop off the _id from the end\n  // of the array in the db which is not guaranteed to be the\n  // same as the last element we have here. $set of the entire array\n  // would be similarly destructive as we never received all\n  // elements of the array and potentially would overwrite data.\n  const check = pop.options.match ||\n      pop.options.options && utils.object.hasOwnProperty(pop.options.options, 'limit') || // 0 is not permitted\n      pop.options.options && pop.options.options.skip || // 0 is permitted\n      pop.options.select && // deselected _id?\n      (pop.options.select._id === 0 ||\n      /\\s?-_id\\s?/.test(pop.options.select));\n\n  if (check) {\n    const atomics = array[arrayAtomicsSymbol];\n    if (Object.keys(atomics).length === 0 || atomics.$set || atomics.$pop) {\n      return path;\n    }\n  }\n}\n\n/**\n * Appends versioning to the where and update clauses.\n *\n * @api private\n * @method $__version\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$__version = function(where, delta) {\n  const key = this.$__schema.options.versionKey;\n  if (where === true) {\n    // this is an insert\n    if (key) {\n      setDottedPath(delta, key, 0);\n      this.$__setValue(key, 0);\n    }\n    return;\n  }\n\n  if (key === false) {\n    return;\n  }\n\n  // updates\n\n  // only apply versioning if our versionKey was selected. else\n  // there is no way to select the correct version. we could fail\n  // fast here and force them to include the versionKey but\n  // thats a bit intrusive. can we do this automatically?\n\n  if (!this.$__isSelected(key)) {\n    return;\n  }\n\n  // $push $addToSet don't need the where clause set\n  if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {\n    const value = this.$__getValue(key);\n    if (value != null) where[key] = value;\n  }\n\n  if (VERSION_INC === (VERSION_INC & this.$__.version)) {\n    if (get(delta.$set, key, null) != null) {\n      // Version key is getting set, means we'll increment the doc's version\n      // after a successful save, so we should set the incremented version so\n      // future saves don't fail (gh-5779)\n      ++delta.$set[key];\n    } else {\n      delta.$inc = delta.$inc || {};\n      delta.$inc[key] = 1;\n    }\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction increment() {\n  this.$__.version = VERSION_ALL;\n  return this;\n}\n\n/**\n * Signal that we desire an increment of this documents version.\n *\n * #### Example:\n *\n *     const doc = await Model.findById(id);\n *     doc.increment();\n *     await doc.save();\n *\n * @see versionKeys https://mongoosejs.com/docs/guide.html#versionKey\n * @memberOf Model\n * @method increment\n * @api public\n */\n\nModel.prototype.increment = increment;\n\n/**\n * Returns a query object\n *\n * @api private\n * @method $__where\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$__where = function _where(where) {\n  where || (where = {});\n\n  if (!where._id) {\n    where._id = this._doc._id;\n  }\n\n  if (this._doc._id === void 0) {\n    return new MongooseError('No _id found on document!');\n  }\n\n  return where;\n};\n\n/**\n * Delete this document from the db.\n *\n * #### Example:\n *\n *     await product.deleteOne();\n *     await Product.findById(product._id); // null\n *\n * @return {Query} Query\n * @api public\n */\n\nModel.prototype.deleteOne = function deleteOne(options) {\n  if (typeof options === 'function' ||\n      typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.prototype.deleteOne() no longer accepts a callback');\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  if (options.hasOwnProperty('session')) {\n    this.$session(options.session);\n  }\n\n  const self = this;\n  const where = this.$__where();\n  if (where instanceof Error) {\n    throw where;\n  }\n  const query = self.constructor.deleteOne(where, options);\n\n  if (this.$session() != null) {\n    if (!('session' in query.options)) {\n      query.options.session = this.$session();\n    }\n  }\n\n  query.pre(function queryPreDeleteOne(cb) {\n    self.constructor._middleware.execPre('deleteOne', self, [self], cb);\n  });\n  query.pre(function callSubdocPreHooks(cb) {\n    each(self.$getAllSubdocs(), (subdoc, cb) => {\n      subdoc.constructor._middleware.execPre('deleteOne', subdoc, [subdoc], cb);\n    }, cb);\n  });\n  query.pre(function skipIfAlreadyDeleted(cb) {\n    if (self.$__.isDeleted) {\n      return cb(Kareem.skipWrappedFunction());\n    }\n    return cb();\n  });\n  query.post(function callSubdocPostHooks(cb) {\n    each(self.$getAllSubdocs(), (subdoc, cb) => {\n      subdoc.constructor._middleware.execPost('deleteOne', subdoc, [subdoc], {}, cb);\n    }, cb);\n  });\n  query.post(function queryPostDeleteOne(cb) {\n    self.constructor._middleware.execPost('deleteOne', self, [self], {}, cb);\n  });\n\n  return query;\n};\n\n/**\n * Returns the model instance used to create this document if no `name` specified.\n * If `name` specified, returns the model with the given `name`.\n *\n * #### Example:\n *\n *     const doc = new Tank({});\n *     doc.$model() === Tank; // true\n *     await doc.$model('User').findById(id);\n *\n * @param {String} [name] model name\n * @method $model\n * @api public\n * @return {Model}\n */\n\nModel.prototype.$model = function $model(name) {\n  if (arguments.length === 0) {\n    return this.constructor;\n  }\n  return this[modelDbSymbol].model(name);\n};\n\n/**\n * Returns the model instance used to create this document if no `name` specified.\n * If `name` specified, returns the model with the given `name`.\n *\n * #### Example:\n *\n *     const doc = new Tank({});\n *     doc.$model() === Tank; // true\n *     await doc.$model('User').findById(id);\n *\n * @param {String} [name] model name\n * @method model\n * @api public\n * @return {Model}\n */\n\nModel.prototype.model = Model.prototype.$model;\n\n/**\n * Returns a document with `_id` only if at least one document exists in the database that matches\n * the given `filter`, and `null` otherwise.\n *\n * Under the hood, `MyModel.exists({ answer: 42 })` is equivalent to\n * `MyModel.findOne({ answer: 42 }).select({ _id: 1 }).lean()`\n *\n * #### Example:\n *\n *     await Character.deleteMany({});\n *     await Character.create({ name: 'Jean-Luc Picard' });\n *\n *     await Character.exists({ name: /picard/i }); // { _id: ... }\n *     await Character.exists({ name: /riker/i }); // null\n *\n * This function triggers the following middleware.\n *\n * - `findOne()`\n *\n * @param {Object} filter\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @return {Query}\n */\n\nModel.exists = function exists(filter, options) {\n  _checkContext(this, 'exists');\n  if (typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.exists() no longer accepts a callback');\n  }\n\n  const query = this.findOne(filter).\n    select({ _id: 1 }).\n    lean().\n    setOptions(options);\n\n  return query;\n};\n\n/**\n * Adds a discriminator type.\n *\n * #### Example:\n *\n *     function BaseSchema() {\n *       Schema.apply(this, arguments);\n *\n *       this.add({\n *         name: String,\n *         createdAt: Date\n *       });\n *     }\n *     util.inherits(BaseSchema, Schema);\n *\n *     const PersonSchema = new BaseSchema();\n *     const BossSchema = new BaseSchema({ department: String });\n *\n *     const Person = mongoose.model('Person', PersonSchema);\n *     const Boss = Person.discriminator('Boss', BossSchema);\n *     new Boss().__t; // \"Boss\". `__t` is the default `discriminatorKey`\n *\n *     const employeeSchema = new Schema({ boss: ObjectId });\n *     const Employee = Person.discriminator('Employee', employeeSchema, 'staff');\n *     new Employee().__t; // \"staff\" because of 3rd argument above\n *\n * @param {String} name discriminator model name\n * @param {Schema} schema discriminator model schema\n * @param {Object|String} [options] If string, same as `options.value`.\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @param {Boolean} [options.overwriteModels=false] by default, Mongoose does not allow you to define a discriminator with the same name as another discriminator. Set this to allow overwriting discriminators with the same name.\n * @param {Boolean} [options.mergeHooks=true] By default, Mongoose merges the base schema's hooks with the discriminator schema's hooks. Set this option to `false` to make Mongoose use the discriminator schema's hooks instead.\n * @param {Boolean} [options.mergePlugins=true] By default, Mongoose merges the base schema's plugins with the discriminator schema's plugins. Set this option to `false` to make Mongoose use the discriminator schema's plugins instead.\n * @return {Model} The newly created discriminator model\n * @api public\n */\n\nModel.discriminator = function(name, schema, options) {\n  let model;\n  if (typeof name === 'function') {\n    model = name;\n    name = utils.getFunctionName(model);\n    if (!(model.prototype instanceof Model)) {\n      throw new MongooseError('The provided class ' + name + ' must extend Model');\n    }\n  }\n\n  options = options || {};\n  const value = utils.isPOJO(options) ? options.value : options;\n  const clone = typeof options.clone === 'boolean' ? options.clone : true;\n  const mergePlugins = typeof options.mergePlugins === 'boolean' ? options.mergePlugins : true;\n\n  _checkContext(this, 'discriminator');\n\n  if (utils.isObject(schema) && !schema.instanceOfSchema) {\n    schema = new Schema(schema);\n  }\n  if (schema instanceof Schema && clone) {\n    schema = schema.clone();\n  }\n\n  schema = discriminator(this, name, schema, value, mergePlugins, options.mergeHooks);\n  if (this.db.models[name] && !schema.options.overwriteModels) {\n    throw new OverwriteModelError(name);\n  }\n\n  schema.$isRootDiscriminator = true;\n  schema.$globalPluginsApplied = true;\n\n  model = this.db.model(model || name, schema, this.$__collection.name);\n  this.discriminators[name] = model;\n  const d = this.discriminators[name];\n  Object.setPrototypeOf(d.prototype, this.prototype);\n  Object.defineProperty(d, 'baseModelName', {\n    value: this.modelName,\n    configurable: true,\n    writable: false\n  });\n\n  // apply methods and statics\n  applyMethods(d, schema);\n  applyStatics(d, schema);\n\n  if (this[subclassedSymbol] != null) {\n    for (const submodel of this[subclassedSymbol]) {\n      submodel.discriminators = submodel.discriminators || {};\n      submodel.discriminators[name] =\n        model.__subclass(model.db, schema, submodel.collection.name);\n    }\n  }\n\n  return d;\n};\n\n/**\n * Make sure `this` is a model\n * @api private\n */\n\nfunction _checkContext(ctx, fnName) {\n  // Check context, because it is easy to mistakenly type\n  // `new Model.discriminator()` and get an incomprehensible error\n  if (ctx == null || ctx === global) {\n    throw new MongooseError('`Model.' + fnName + '()` cannot run without a ' +\n      'model as `this`. Make sure you are calling `MyModel.' + fnName + '()` ' +\n      'where `MyModel` is a Mongoose model.');\n  } else if (ctx[modelSymbol] == null) {\n    throw new MongooseError('`Model.' + fnName + '()` cannot run without a ' +\n      'model as `this`. Make sure you are not calling ' +\n      '`new Model.' + fnName + '()`');\n  }\n}\n\n// Model (class) features\n\n/*!\n * Give the constructor the ability to emit events.\n */\n\nfor (const i in EventEmitter.prototype) {\n  Model[i] = EventEmitter.prototype[i];\n}\n\n/**\n * This function is responsible for initializing the underlying connection in MongoDB based on schema options.\n * This function performs the following operations:\n *\n * - `createCollection()` unless [`autoCreate`](https://mongoosejs.com/docs/guide.html#autoCreate) option is turned off\n * - `ensureIndexes()` unless [`autoIndex`](https://mongoosejs.com/docs/guide.html#autoIndex) option is turned off\n * - `createSearchIndex()` on all schema search indexes if `autoSearchIndex` is enabled.\n *\n * Mongoose calls this function automatically when a model is a created using\n * [`mongoose.model()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.model()) or\n * [`connection.model()`](https://mongoosejs.com/docs/api/connection.html#Connection.prototype.model()), so you\n * don't need to call `init()` to trigger index builds.\n *\n * However, you _may_ need to call `init()`  to get back a promise that will resolve when your indexes are finished.\n * Calling `await Model.init()` is helpful if you need to wait for indexes to build before continuing.\n * For example, if you want to wait for unique indexes to build before continuing with a test case.\n *\n * #### Example:\n *\n *     const eventSchema = new Schema({ thing: { type: 'string', unique: true } })\n *     // This calls `Event.init()` implicitly, so you don't need to call\n *     // `Event.init()` on your own.\n *     const Event = mongoose.model('Event', eventSchema);\n *\n *     await Event.init();\n *     console.log('Indexes are done building!');\n *\n * @api public\n * @returns {Promise}\n */\n\nModel.init = function init() {\n  _checkContext(this, 'init');\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('Model.init() no longer accepts a callback');\n  }\n\n  this.schema.emit('init', this);\n\n  if (this.$init != null) {\n    return this.$init;\n  }\n\n  const conn = this.db;\n  const _ensureIndexes = async() => {\n    const autoIndex = utils.getOption(\n      'autoIndex',\n      this.schema.options,\n      conn.config,\n      conn.base.options\n    );\n    if (!autoIndex) {\n      return;\n    }\n    return await this.ensureIndexes({ _automatic: true });\n  };\n  const _createSearchIndexes = async() => {\n    const autoSearchIndex = utils.getOption(\n      'autoSearchIndex',\n      this.schema.options,\n      conn.config,\n      conn.base.options\n    );\n    if (!autoSearchIndex) {\n      return;\n    }\n\n    const results = [];\n    for (const searchIndex of this.schema._searchIndexes) {\n      results.push(await this.createSearchIndex(searchIndex));\n    }\n    return results;\n  };\n  const _createCollection = async() => {\n    if ((conn.readyState === STATES.connecting || conn.readyState === STATES.disconnected) && conn._shouldBufferCommands()) {\n      await new Promise(resolve => {\n        conn._queue.push({ fn: resolve });\n      });\n    }\n    const autoCreate = utils.getOption(\n      'autoCreate',\n      this.schema.options,\n      conn.config,\n      conn.base.options\n    );\n    if (!autoCreate) {\n      return;\n    }\n    return await this.createCollection();\n  };\n\n  this.$init = _createCollection().\n    then(() => _ensureIndexes()).\n    then(() => _createSearchIndexes());\n\n  const _catch = this.$init.catch;\n  const _this = this;\n  this.$init.catch = function() {\n    _this.$caught = true;\n    return _catch.apply(_this.$init, arguments);\n  };\n\n  return this.$init;\n};\n\n\n/**\n * Create the collection for this model. By default, if no indexes are specified,\n * mongoose will not create the collection for the model until any documents are\n * created. Use this method to create the collection explicitly.\n *\n * Note 1: You may need to call this before starting a transaction\n * See https://www.mongodb.com/docs/manual/core/transactions/#transactions-and-operations\n *\n * Note 2: You don't have to call this if your schema contains index or unique field.\n * In that case, just use `Model.init()`\n *\n * #### Example:\n *\n *     const userSchema = new Schema({ name: String })\n *     const User = mongoose.model('User', userSchema);\n *\n *     User.createCollection().then(function(collection) {\n *       console.log('Collection is created!');\n *     });\n *\n * @api public\n * @param {Object} [options] see [MongoDB driver docs](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createCollection)\n * @returns {Promise}\n */\n\nModel.createCollection = async function createCollection(options) {\n  _checkContext(this, 'createCollection');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.createCollection() no longer accepts a callback');\n  }\n\n  const shouldSkip = await new Promise((resolve, reject) => {\n    this.hooks.execPre('createCollection', this, [options], (err) => {\n      if (err != null) {\n        if (err instanceof Kareem.skipWrappedFunction) {\n          return resolve(true);\n        }\n        return reject(err);\n      }\n      resolve();\n    });\n  });\n\n  const collectionOptions = this &&\n    this.schema &&\n    this.schema.options &&\n    this.schema.options.collectionOptions;\n  if (collectionOptions != null) {\n    options = Object.assign({}, collectionOptions, options);\n  }\n\n  const schemaCollation = this &&\n    this.schema &&\n    this.schema.options &&\n    this.schema.options.collation;\n  if (schemaCollation != null) {\n    options = Object.assign({ collation: schemaCollation }, options);\n  }\n  const capped = this &&\n    this.schema &&\n    this.schema.options &&\n    this.schema.options.capped;\n  if (capped != null) {\n    if (typeof capped === 'number') {\n      options = Object.assign({ capped: true, size: capped }, options);\n    } else if (typeof capped === 'object') {\n      options = Object.assign({ capped: true }, capped, options);\n    }\n  }\n  const timeseries = this &&\n    this.schema &&\n    this.schema.options &&\n    this.schema.options.timeseries;\n  if (timeseries != null) {\n    options = Object.assign({ timeseries }, options);\n    if (options.expireAfterSeconds != null) {\n      // do nothing\n    } else if (options.expires != null) {\n      utils.expires(options);\n    } else if (this.schema.options.expireAfterSeconds != null) {\n      options.expireAfterSeconds = this.schema.options.expireAfterSeconds;\n    } else if (this.schema.options.expires != null) {\n      options.expires = this.schema.options.expires;\n      utils.expires(options);\n    }\n  }\n\n  const clusteredIndex = this &&\n    this.schema &&\n    this.schema.options &&\n    this.schema.options.clusteredIndex;\n  if (clusteredIndex != null) {\n    options = Object.assign({ clusteredIndex: { ...clusteredIndex, unique: true } }, options);\n  }\n\n  try {\n    if (!shouldSkip) {\n      await this.db.createCollection(this.$__collection.collectionName, options);\n    }\n  } catch (err) {\n    if (err != null && (err.name !== 'MongoServerError' || err.code !== 48)) {\n      await new Promise((resolve, reject) => {\n        const _opts = { error: err };\n        this.hooks.execPost('createCollection', this, [null], _opts, (err) => {\n          if (err != null) {\n            return reject(err);\n          }\n          resolve();\n        });\n      });\n    }\n  }\n\n  await new Promise((resolve, reject) => {\n    this.hooks.execPost('createCollection', this, [this.$__collection], (err) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve();\n    });\n  });\n\n  return this.$__collection;\n};\n\n/**\n * Makes the indexes in MongoDB match the indexes defined in this model's\n * schema. This function will drop any indexes that are not defined in\n * the model's schema except the `_id` index, and build any indexes that\n * are in your schema but not in MongoDB.\n *\n * See the [introductory blog post](https://thecodebarbarian.com/whats-new-in-mongoose-5-2-syncindexes)\n * for more information.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: { type: String, unique: true } });\n *     const Customer = mongoose.model('Customer', schema);\n *     await Customer.collection.createIndex({ age: 1 }); // Index is not in schema\n *     // Will drop the 'age' index and create an index on `name`\n *     await Customer.syncIndexes();\n *\n * You should be careful about running `syncIndexes()` on production applications under heavy load,\n * because index builds are expensive operations, and unexpected index drops can lead to degraded\n * performance. Before running `syncIndexes()`, you can use the [`diffIndexes()` function](#Model.diffIndexes())\n * to check what indexes `syncIndexes()` will drop and create.\n *\n * #### Example:\n *\n *     const { toDrop, toCreate } = await Model.diffIndexes();\n *     toDrop; // Array of strings containing names of indexes that `syncIndexes()` will drop\n *     toCreate; // Array of strings containing names of indexes that `syncIndexes()` will create\n *\n * @param {Object} [options] options to pass to `ensureIndexes()`\n * @param {Boolean} [options.background=null] if specified, overrides each index's `background` property\n * @return {Promise}\n * @api public\n */\n\nModel.syncIndexes = async function syncIndexes(options) {\n  _checkContext(this, 'syncIndexes');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.syncIndexes() no longer accepts a callback');\n  }\n\n  const model = this;\n\n  try {\n    await model.createCollection();\n  } catch (err) {\n    if (err != null && (err.name !== 'MongoServerError' || err.code !== 48)) {\n      throw err;\n    }\n  }\n\n  const diffIndexesResult = await model.diffIndexes();\n  const dropped = await model.cleanIndexes({ ...options, toDrop: diffIndexesResult.toDrop });\n  await model.createIndexes({ ...options, toCreate: diffIndexesResult.toCreate });\n\n  return dropped;\n};\n\n/**\n * Create an [Atlas search index](https://www.mongodb.com/docs/atlas/atlas-search/create-index/).\n * This function only works when connected to MongoDB Atlas.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: { type: String, unique: true } });\n *     const Customer = mongoose.model('Customer', schema);\n *     await Customer.createSearchIndex({ name: 'test', definition: { mappings: { dynamic: true } } });\n *\n * @param {Object} description index options, including `name` and `definition`\n * @param {String} description.name\n * @param {Object} description.definition\n * @return {Promise}\n * @api public\n */\n\nModel.createSearchIndex = async function createSearchIndex(description) {\n  _checkContext(this, 'createSearchIndex');\n\n  return await this.$__collection.createSearchIndex(description);\n};\n\n/**\n * Update an existing [Atlas search index](https://www.mongodb.com/docs/atlas/atlas-search/create-index/).\n * This function only works when connected to MongoDB Atlas.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: { type: String, unique: true } });\n *     const Customer = mongoose.model('Customer', schema);\n *     await Customer.updateSearchIndex('test', { mappings: { dynamic: true } });\n *\n * @param {String} name\n * @param {Object} definition\n * @return {Promise}\n * @api public\n */\n\nModel.updateSearchIndex = async function updateSearchIndex(name, definition) {\n  _checkContext(this, 'updateSearchIndex');\n\n  return await this.$__collection.updateSearchIndex(name, definition);\n};\n\n/**\n * Delete an existing [Atlas search index](https://www.mongodb.com/docs/atlas/atlas-search/create-index/) by name.\n * This function only works when connected to MongoDB Atlas.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: { type: String, unique: true } });\n *     const Customer = mongoose.model('Customer', schema);\n *     await Customer.dropSearchIndex('test');\n *\n * @param {String} name\n * @return {Promise}\n * @api public\n */\n\nModel.dropSearchIndex = async function dropSearchIndex(name) {\n  _checkContext(this, 'dropSearchIndex');\n\n  return await this.$__collection.dropSearchIndex(name);\n};\n\n/**\n * Does a dry-run of `Model.syncIndexes()`, returning the indexes that `syncIndexes()` would drop and create if you were to run `syncIndexes()`.\n *\n * #### Example:\n *\n *     const { toDrop, toCreate } = await Model.diffIndexes();\n *     toDrop; // Array of strings containing names of indexes that `syncIndexes()` will drop\n *     toCreate; // Array of strings containing names of indexes that `syncIndexes()` will create\n *\n * @param {Object} [options]\n * @return {Promise<Object>} contains the indexes that would be dropped in MongoDB and indexes that would be created in MongoDB as `{ toDrop: string[], toCreate: string[] }`.\n */\n\nModel.diffIndexes = async function diffIndexes() {\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.syncIndexes() no longer accepts a callback');\n  }\n\n  const model = this;\n\n  let dbIndexes = await model.listIndexes().catch(err => {\n    if (err.codeName == 'NamespaceNotFound') {\n      return undefined;\n    }\n    throw err;\n  });\n  if (dbIndexes === undefined) {\n    dbIndexes = [];\n  }\n  dbIndexes = getRelatedDBIndexes(model, dbIndexes);\n\n  const schema = model.schema;\n  const schemaIndexes = getRelatedSchemaIndexes(model, schema.indexes());\n\n  const toDrop = getIndexesToDrop(schema, schemaIndexes, dbIndexes);\n  const toCreate = getIndexesToCreate(schema, schemaIndexes, dbIndexes, toDrop);\n\n  return { toDrop, toCreate };\n};\n\nfunction getIndexesToCreate(schema, schemaIndexes, dbIndexes, toDrop) {\n  const toCreate = [];\n\n  for (const [schemaIndexKeysObject, schemaIndexOptions] of schemaIndexes) {\n    let found = false;\n\n    const options = decorateDiscriminatorIndexOptions(schema, clone(schemaIndexOptions));\n\n    for (const index of dbIndexes) {\n      if (isDefaultIdIndex(index)) {\n        continue;\n      }\n      if (\n        isIndexEqual(schemaIndexKeysObject, options, index) &&\n        !toDrop.includes(index.name)\n      ) {\n        found = true;\n        break;\n      }\n    }\n\n    if (!found) {\n      toCreate.push(schemaIndexKeysObject);\n    }\n  }\n\n  return toCreate;\n}\n\nfunction getIndexesToDrop(schema, schemaIndexes, dbIndexes) {\n  const toDrop = [];\n\n  for (const dbIndex of dbIndexes) {\n    let found = false;\n    // Never try to drop `_id` index, MongoDB server doesn't allow it\n    if (isDefaultIdIndex(dbIndex)) {\n      continue;\n    }\n\n    for (const [schemaIndexKeysObject, schemaIndexOptions] of schemaIndexes) {\n      const options = decorateDiscriminatorIndexOptions(schema, clone(schemaIndexOptions));\n      applySchemaCollation(schemaIndexKeysObject, options, schema.options);\n\n      if (isIndexEqual(schemaIndexKeysObject, options, dbIndex)) {\n        found = true;\n        break;\n      }\n    }\n\n    if (!found) {\n      toDrop.push(dbIndex.name);\n    }\n  }\n\n  return toDrop;\n}\n/**\n * Deletes all indexes that aren't defined in this model's schema. Used by\n * `syncIndexes()`.\n *\n * The returned promise resolves to a list of the dropped indexes' names as an array\n *\n * @param {Function} [callback] optional callback\n * @return {Promise|undefined} Returns `undefined` if callback is specified, returns a promise if no callback.\n * @api public\n */\n\nModel.cleanIndexes = async function cleanIndexes(options) {\n  _checkContext(this, 'cleanIndexes');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.cleanIndexes() no longer accepts a callback');\n  }\n  const model = this;\n\n  const collection = model.$__collection;\n\n  if (Array.isArray(options && options.toDrop)) {\n    const res = await _dropIndexes(options.toDrop, collection);\n    return res;\n  }\n\n  const res = await model.diffIndexes();\n  return await _dropIndexes(res.toDrop, collection);\n};\n\nasync function _dropIndexes(toDrop, collection) {\n  if (toDrop.length === 0) {\n    return [];\n  }\n\n  await Promise.all(toDrop.map(indexName => collection.dropIndex(indexName)));\n  return toDrop;\n}\n\n/**\n * Lists the indexes currently defined in MongoDB. This may or may not be\n * the same as the indexes defined in your schema depending on whether you\n * use the [`autoIndex` option](https://mongoosejs.com/docs/guide.html#autoIndex) and if you\n * build indexes manually.\n *\n * @return {Promise}\n * @api public\n */\n\nModel.listIndexes = async function listIndexes() {\n  _checkContext(this, 'listIndexes');\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('Model.listIndexes() no longer accepts a callback');\n  }\n\n  if (this.$__collection.buffer) {\n    await new Promise(resolve => {\n      this.$__collection.addQueue(resolve);\n    });\n  }\n\n  return this.$__collection.listIndexes().toArray();\n};\n\n/**\n * Sends `createIndex` commands to mongo for each index declared in the schema.\n * The `createIndex` commands are sent in series.\n *\n * #### Example:\n *\n *     await Event.ensureIndexes();\n *\n * After completion, an `index` event is emitted on this `Model` passing an error if one occurred.\n *\n * #### Example:\n *\n *     const eventSchema = new Schema({ thing: { type: 'string', unique: true } })\n *     const Event = mongoose.model('Event', eventSchema);\n *\n *     Event.on('index', function (err) {\n *       if (err) console.error(err); // error occurred during index creation\n *     });\n *\n * _NOTE: It is not recommended that you run this in production. Index creation may impact database performance depending on your load. Use with caution._\n *\n * @param {Object} [options] internal options\n * @return {Promise}\n * @api public\n */\n\nModel.ensureIndexes = async function ensureIndexes(options) {\n  _checkContext(this, 'ensureIndexes');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.ensureIndexes() no longer accepts a callback');\n  }\n\n  await new Promise((resolve, reject) => {\n    _ensureIndexes(this, options, (err) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve();\n    });\n  });\n};\n\n/**\n * Similar to `ensureIndexes()`, except for it uses the [`createIndex`](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createIndex)\n * function.\n *\n * @param {Object} [options] internal options\n * @return {Promise}\n * @api public\n */\n\nModel.createIndexes = async function createIndexes(options) {\n  _checkContext(this, 'createIndexes');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.createIndexes() no longer accepts a callback');\n  }\n\n  return this.ensureIndexes(options);\n};\n\n\n/*!\n * ignore\n */\n\nfunction _ensureIndexes(model, options, callback) {\n  const indexes = model.schema.indexes();\n  let indexError;\n\n  options = options || {};\n  const done = function(err) {\n    if (err && !model.$caught) {\n      model.emit('error', err);\n    }\n    model.emit('index', err || indexError);\n    callback && callback(err || indexError);\n  };\n\n  for (const index of indexes) {\n    if (isDefaultIdIndex(index)) {\n      utils.warn('mongoose: Cannot specify a custom index on `_id` for ' +\n        'model name \"' + model.modelName + '\", ' +\n        'MongoDB does not allow overwriting the default `_id` index. See ' +\n        'https://bit.ly/mongodb-id-index');\n    }\n  }\n\n  if (!indexes.length) {\n    immediate(function() {\n      done();\n    });\n    return;\n  }\n  // Indexes are created one-by-one to support how MongoDB < 2.4 deals\n  // with background indexes.\n\n  const indexSingleDone = function(err, fields, options, name) {\n    model.emit('index-single-done', err, fields, options, name);\n  };\n  const indexSingleStart = function(fields, options) {\n    model.emit('index-single-start', fields, options);\n  };\n\n  const baseSchema = model.schema._baseSchema;\n  const baseSchemaIndexes = baseSchema ? baseSchema.indexes() : [];\n\n  immediate(function() {\n    // If buffering is off, do this manually.\n    if (options._automatic && !model.collection.collection) {\n      model.collection.addQueue(create, []);\n    } else {\n      create();\n    }\n  });\n\n\n  function create() {\n    if (options._automatic) {\n      if (model.schema.options.autoIndex === false ||\n          (model.schema.options.autoIndex == null && model.db.config.autoIndex === false)) {\n        return done();\n      }\n    }\n\n    const index = indexes.shift();\n    if (!index) {\n      return done();\n    }\n    if (options._automatic && index[1]._autoIndex === false) {\n      return create();\n    }\n\n    if (baseSchemaIndexes.find(i => utils.deepEqual(i, index))) {\n      return create();\n    }\n\n    const indexFields = clone(index[0]);\n    const indexOptions = clone(index[1]);\n\n    delete indexOptions._autoIndex;\n    decorateDiscriminatorIndexOptions(model.schema, indexOptions);\n    applyWriteConcern(model.schema, indexOptions);\n    applySchemaCollation(indexFields, indexOptions, model.schema.options);\n\n    indexSingleStart(indexFields, options);\n\n    if ('background' in options) {\n      indexOptions.background = options.background;\n    }\n\n    if ('toCreate' in options) {\n      if (options.toCreate.length === 0) {\n        return done();\n      }\n    }\n\n    model.collection.createIndex(indexFields, indexOptions).then(\n      name => {\n        indexSingleDone(null, indexFields, indexOptions, name);\n        create();\n      },\n      err => {\n        if (!indexError) {\n          indexError = err;\n        }\n        if (!model.$caught) {\n          model.emit('error', err);\n        }\n\n        indexSingleDone(err, indexFields, indexOptions);\n        create();\n      }\n    );\n  }\n}\n\n/**\n * Schema the model uses.\n *\n * @property schema\n * @static\n * @api public\n * @memberOf Model\n */\n\nModel.schema;\n\n/**\n * Connection instance the model uses.\n *\n * @property db\n * @static\n * @api public\n * @memberOf Model\n */\n\nModel.db;\n\n/**\n * Collection the model uses.\n *\n * @property collection\n * @api public\n * @memberOf Model\n */\n\nModel.collection;\n\n/**\n * Internal collection the model uses.\n *\n * @property collection\n * @api private\n * @memberOf Model\n */\nModel.$__collection;\n\n/**\n * Base Mongoose instance the model uses.\n *\n * @property base\n * @api public\n * @memberOf Model\n */\n\nModel.base;\n\n/**\n * Registered discriminators for this model.\n *\n * @property discriminators\n * @api public\n * @memberOf Model\n */\n\nModel.discriminators;\n\n/**\n * Translate any aliases fields/conditions so the final query or document object is pure\n *\n * #### Example:\n *\n *     await Character.find(Character.translateAliases({\n *        '': 'Eddard Stark' // Alias for 'name'\n *     });\n *\n * By default, `translateAliases()` overwrites raw fields with aliased fields.\n * So if `n` is an alias for `name`, `{ n: 'alias', name: 'raw' }` will resolve to `{ name: 'alias' }`.\n * However, you can set the `errorOnDuplicates` option to throw an error if there are potentially conflicting paths.\n * The `translateAliases` option for queries uses `errorOnDuplicates`.\n *\n * #### Note:\n *\n * Only translate arguments of object type anything else is returned raw\n *\n * @param {Object} fields fields/conditions that may contain aliased keys\n * @param {Boolean} [errorOnDuplicates] if true, throw an error if there's both a key and an alias for that key in `fields`\n * @return {Object} the translated 'pure' fields/conditions\n */\nModel.translateAliases = function translateAliases(fields, errorOnDuplicates) {\n  _checkContext(this, 'translateAliases');\n\n  const translate = (key, value) => {\n    let alias;\n    const translated = [];\n    const fieldKeys = key.split('.');\n    let currentSchema = this.schema;\n    for (const i in fieldKeys) {\n      const name = fieldKeys[i];\n      if (currentSchema && currentSchema.aliases[name]) {\n        alias = currentSchema.aliases[name];\n        if (errorOnDuplicates && alias in fields) {\n          throw new MongooseError(`Provided object has both field \"${name}\" and its alias \"${alias}\"`);\n        }\n        // Alias found,\n        translated.push(alias);\n      } else {\n        alias = name;\n        // Alias not found, so treat as un-aliased key\n        translated.push(name);\n      }\n\n      // Check if aliased path is a schema\n      if (currentSchema && currentSchema.paths[alias]) {\n        currentSchema = currentSchema.paths[alias].schema;\n      }\n      else\n        currentSchema = null;\n    }\n\n    const translatedKey = translated.join('.');\n    if (fields instanceof Map)\n      fields.set(translatedKey, value);\n    else\n      fields[translatedKey] = value;\n\n    if (translatedKey !== key) {\n      // We'll be using the translated key instead\n      if (fields instanceof Map) {\n        // Delete from map\n        fields.delete(key);\n      } else {\n        // Delete from object\n        delete fields[key]; // We'll be using the translated key instead\n      }\n    }\n    return fields;\n  };\n\n  if (typeof fields === 'object') {\n    // Fields is an object (query conditions or document fields)\n    if (fields instanceof Map) {\n      // A Map was supplied\n      for (const field of new Map(fields)) {\n        fields = translate(field[0], field[1]);\n      }\n    } else {\n      // Infer a regular object was supplied\n      for (const key of Object.keys(fields)) {\n        fields = translate(key, fields[key]);\n        if (key[0] === '$') {\n          if (Array.isArray(fields[key])) {\n            for (const i in fields[key]) {\n              // Recursively translate nested queries\n              fields[key][i] = this.translateAliases(fields[key][i]);\n            }\n          } else {\n            this.translateAliases(fields[key]);\n          }\n        }\n      }\n    }\n\n    return fields;\n  } else {\n    // Don't know typeof fields\n    return fields;\n  }\n};\n\n/**\n * Deletes the first document that matches `conditions` from the collection.\n * It returns an object with the property `deletedCount` indicating how many documents were deleted.\n * Behaves like `remove()`, but deletes at most one document regardless of the\n * `single` option.\n *\n * #### Example:\n *\n *     await Character.deleteOne({ name: 'Eddard Stark' }); // returns {deletedCount: 1}\n *\n * #### Note:\n *\n * This function triggers `deleteOne` query hooks. Read the\n * [middleware docs](https://mongoosejs.com/docs/middleware.html#naming) to learn more.\n *\n * @param {Object} conditions\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @api public\n */\n\nModel.deleteOne = function deleteOne(conditions, options) {\n  _checkContext(this, 'deleteOne');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.prototype.deleteOne() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.setOptions(options);\n\n  return mq.deleteOne(conditions);\n};\n\n/**\n * Deletes all of the documents that match `conditions` from the collection.\n * It returns an object with the property `deletedCount` containing the number of documents deleted.\n * Behaves like `remove()`, but deletes all documents that match `conditions`\n * regardless of the `single` option.\n *\n * #### Example:\n *\n *     await Character.deleteMany({ name: /Stark/, age: { $gte: 18 } }); // returns {deletedCount: x} where x is the number of documents deleted.\n *\n * #### Note:\n *\n * This function triggers `deleteMany` query hooks. Read the\n * [middleware docs](https://mongoosejs.com/docs/middleware.html#naming) to learn more.\n *\n * @param {Object} conditions\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @api public\n */\n\nModel.deleteMany = function deleteMany(conditions, options) {\n  _checkContext(this, 'deleteMany');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.deleteMany() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.setOptions(options);\n\n  return mq.deleteMany(conditions);\n};\n\n/**\n * Finds documents.\n *\n * Mongoose casts the `filter` to match the model's schema before the command is sent.\n * See our [query casting tutorial](https://mongoosejs.com/docs/tutorials/query_casting.html) for\n * more information on how Mongoose casts `filter`.\n *\n * #### Example:\n *\n *     // find all documents\n *     await MyModel.find({});\n *\n *     // find all documents named john and at least 18\n *     await MyModel.find({ name: 'john', age: { $gte: 18 } }).exec();\n *\n *     // executes, name LIKE john and only selecting the \"name\" and \"friends\" fields\n *     await MyModel.find({ name: /john/i }, 'name friends').exec();\n *\n *     // passing options\n *     await MyModel.find({ name: /john/i }, null, { skip: 10 }).exec();\n *\n * @param {Object|ObjectId} filter\n * @param {Object|String|String[]} [projection] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see field selection https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @see query casting https://mongoosejs.com/docs/tutorials/query_casting.html\n * @api public\n */\n\nModel.find = function find(conditions, projection, options) {\n  _checkContext(this, 'find');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.find() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(projection);\n  mq.setOptions(options);\n\n  return mq.find(conditions);\n};\n\n/**\n * Finds a single document by its _id field. `findById(id)` is almost*\n * equivalent to `findOne({ _id: id })`. If you want to query by a document's\n * `_id`, use `findById()` instead of `findOne()`.\n *\n * The `id` is cast based on the Schema before sending the command.\n *\n * This function triggers the following middleware.\n *\n * - `findOne()`\n *\n * \\* Except for how it treats `undefined`. If you use `findOne()`, you'll see\n * that `findOne(undefined)` and `findOne({ _id: undefined })` are equivalent\n * to `findOne({})` and return arbitrary documents. However, mongoose\n * translates `findById(undefined)` into `findOne({ _id: null })`.\n *\n * #### Example:\n *\n *     // Find the adventure with the given `id`, or `null` if not found\n *     await Adventure.findById(id).exec();\n *\n *     // select only the adventures name and length\n *     await Adventure.findById(id, 'name length').exec();\n *\n * @param {Any} id value of `_id` to query by\n * @param {Object|String|String[]} [projection] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @return {Query}\n * @see field selection https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @see lean queries https://mongoosejs.com/docs/tutorials/lean.html\n * @see findById in Mongoose https://masteringjs.io/tutorials/mongoose/find-by-id\n * @api public\n */\n\nModel.findById = function findById(id, projection, options) {\n  _checkContext(this, 'findById');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.findById() no longer accepts a callback');\n  }\n\n  if (typeof id === 'undefined') {\n    id = null;\n  }\n\n  return this.findOne({ _id: id }, projection, options);\n};\n\n/**\n * Finds one document.\n *\n * The `conditions` are cast to their respective SchemaTypes before the command is sent.\n *\n * *Note:* `conditions` is optional, and if `conditions` is null or undefined,\n * mongoose will send an empty `findOne` command to MongoDB, which will return\n * an arbitrary document. If you're querying by `_id`, use `findById()` instead.\n *\n * #### Example:\n *\n *     // Find one adventure whose `country` is 'Croatia', otherwise `null`\n *     await Adventure.findOne({ country: 'Croatia' }).exec();\n *\n *     // Model.findOne() no longer accepts a callback\n *\n *     // Select only the adventures name and length\n *     await Adventure.findOne({ country: 'Croatia' }, 'name length').exec();\n *\n * @param {Object} [conditions]\n * @param {Object|String|String[]} [projection] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see field selection https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @see lean queries https://mongoosejs.com/docs/tutorials/lean.html\n * @api public\n */\n\nModel.findOne = function findOne(conditions, projection, options) {\n  _checkContext(this, 'findOne');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.findOne() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(projection);\n  mq.setOptions(options);\n\n  return mq.findOne(conditions);\n};\n\n/**\n * Estimates the number of documents in the MongoDB collection. Faster than\n * using `countDocuments()` for large collections because\n * `estimatedDocumentCount()` uses collection metadata rather than scanning\n * the entire collection.\n *\n * #### Example:\n *\n *     const numAdventures = await Adventure.estimatedDocumentCount();\n *\n * @param {Object} [options]\n * @return {Query}\n * @api public\n */\n\nModel.estimatedDocumentCount = function estimatedDocumentCount(options) {\n  _checkContext(this, 'estimatedDocumentCount');\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n\n  return mq.estimatedDocumentCount(options);\n};\n\n/**\n * Counts number of documents matching `filter` in a database collection.\n *\n * #### Example:\n *\n *     Adventure.countDocuments({ type: 'jungle' }, function (err, count) {\n *       console.log('there are %d jungle adventures', count);\n *     });\n *\n * If you want to count all documents in a large collection,\n * use the [`estimatedDocumentCount()` function](https://mongoosejs.com/docs/api/model.html#Model.estimatedDocumentCount())\n * instead. If you call `countDocuments({})`, MongoDB will always execute\n * a full collection scan and **not** use any indexes.\n *\n * The `countDocuments()` function is similar to `count()`, but there are a\n * [few operators that `countDocuments()` does not support](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments).\n * Below are the operators that `count()` supports but `countDocuments()` does not,\n * and the suggested replacement:\n *\n * - `$where`: [`$expr`](https://www.mongodb.com/docs/manual/reference/operator/query/expr/)\n * - `$near`: [`$geoWithin`](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/) with [`$center`](https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center)\n * - `$nearSphere`: [`$geoWithin`](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/) with [`$centerSphere`](https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere)\n *\n * @param {Object} filter\n * @return {Query}\n * @api public\n */\n\nModel.countDocuments = function countDocuments(conditions, options) {\n  _checkContext(this, 'countDocuments');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.countDocuments() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  if (options != null) {\n    mq.setOptions(options);\n  }\n\n  return mq.countDocuments(conditions);\n};\n\n\n/**\n * Creates a Query for a `distinct` operation.\n *\n * #### Example:\n *\n *     const query = Link.distinct('url');\n *     query.exec();\n *\n * @param {String} field\n * @param {Object} [conditions] optional\n * @return {Query}\n * @api public\n */\n\nModel.distinct = function distinct(field, conditions) {\n  _checkContext(this, 'distinct');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.distinct() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n\n  return mq.distinct(field, conditions);\n};\n\n/**\n * Creates a Query, applies the passed conditions, and returns the Query.\n *\n * For example, instead of writing:\n *\n *     User.find({ age: { $gte: 21, $lte: 65 } });\n *\n * we can instead write:\n *\n *     User.where('age').gte(21).lte(65).exec();\n *\n * Since the Query class also supports `where` you can continue chaining\n *\n *     User\n *     .where('age').gte(21).lte(65)\n *     .where('name', /^b/i)\n *     ... etc\n *\n * @param {String} path\n * @param {Object} [val] optional value\n * @return {Query}\n * @api public\n */\n\nModel.where = function where(path, val) {\n  _checkContext(this, 'where');\n\n  void val; // eslint\n  const mq = new this.Query({}, {}, this, this.$__collection).find({});\n  return mq.where.apply(mq, arguments);\n};\n\n/**\n * Creates a `Query` and specifies a `$where` condition.\n *\n * Sometimes you need to query for things in mongodb using a JavaScript expression. You can do so via `find({ $where: javascript })`, or you can use the mongoose shortcut method $where via a Query chain or from your mongoose Model.\n *\n *     Blog.$where('this.username.indexOf(\"val\") !== -1').exec(function (err, docs) {});\n *\n * @param {String|Function} argument is a javascript string or anonymous function\n * @method $where\n * @memberOf Model\n * @return {Query}\n * @see Query.$where https://mongoosejs.com/docs/api/query.html#Query.prototype.$where\n * @api public\n */\n\nModel.$where = function $where() {\n  _checkContext(this, '$where');\n\n  const mq = new this.Query({}, {}, this, this.$__collection).find({});\n  return mq.$where.apply(mq, arguments);\n};\n\n/**\n * Issues a mongodb findOneAndUpdate command.\n *\n * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any) to the callback. The query executes if `callback` is passed else a Query object is returned.\n *\n * #### Example:\n *\n *     A.findOneAndUpdate(conditions, update, options)  // returns Query\n *     A.findOneAndUpdate(conditions, update)           // returns Query\n *     A.findOneAndUpdate()                             // returns Query\n *\n * #### Note:\n *\n * All top level update keys which are not `atomic` operation names are treated as set operations:\n *\n * #### Example:\n *\n *     const query = { name: 'borne' };\n *     Model.findOneAndUpdate(query, { name: 'jason bourne' }, options)\n *\n *     // is sent as\n *     Model.findOneAndUpdate(query, { $set: { name: 'jason bourne' }}, options)\n *\n * #### Note:\n *\n * `findOneAndX` and `findByIdAndX` functions support limited validation that\n * you can enable by setting the `runValidators` option.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     const doc = await Model.findById(id);\n *     doc.name = 'jason bourne';\n *     await doc.save();\n *\n * @param {Object} [conditions]\n * @param {Object} [update]\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {String} [options.returnDocument='before'] Has two possible values, `'before'` and `'after'`. By default, it will return the document before the update was applied.\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and [the Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Boolean} [options.new=false] if true, return the modified document rather than the original\n * @param {Object|String} [options.fields] Field selection. Equivalent to `.select(fields).findOneAndUpdate()`\n * @param {Number} [options.maxTimeMS] puts a time limit on the query - requires mongodb >= 2.6.0\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Boolean} [options.runValidators] if true, runs [update validators](https://mongoosejs.com/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema\n * @param {Boolean} [options.setDefaultsOnInsert=true] If `setDefaultsOnInsert` and `upsert` are true, mongoose will apply the [defaults](https://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created\n * @param {Boolean} [options.includeResultMetadata] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @param {Boolean} [options.overwriteDiscriminatorKey=false] Mongoose removes discriminator key updates from `update` by default, set `overwriteDiscriminatorKey` to `true` to allow updating the discriminator key\n * @return {Query}\n * @see Tutorial https://mongoosejs.com/docs/tutorials/findoneandupdate.html\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n * @api public\n */\n\nModel.findOneAndUpdate = function(conditions, update, options) {\n  _checkContext(this, 'findOneAndUpdate');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.findOneAndUpdate() no longer accepts a callback');\n  }\n\n  if (arguments.length === 1) {\n    update = conditions;\n    conditions = null;\n    options = null;\n  }\n\n  let fields;\n  if (options) {\n    fields = options.fields || options.projection;\n  }\n\n  update = clone(update, {\n    depopulate: true,\n    _isNested: true\n  });\n\n  decorateUpdateWithVersionKey(update, options, this.schema.options.versionKey);\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(fields);\n\n  return mq.findOneAndUpdate(conditions, update, options);\n};\n\n/**\n * Issues a mongodb findOneAndUpdate command by a document's _id field.\n * `findByIdAndUpdate(id, ...)` is equivalent to `findOneAndUpdate({ _id: id }, ...)`.\n *\n * Finds a matching document, updates it according to the `update` arg,\n * passing any `options`, and returns the found document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndUpdate()`\n *\n * #### Example:\n *\n *     A.findByIdAndUpdate(id, update, options)  // returns Query\n *     A.findByIdAndUpdate(id, update)           // returns Query\n *     A.findByIdAndUpdate()                     // returns Query\n *\n * #### Note:\n *\n * All top level update keys which are not `atomic` operation names are treated as set operations:\n *\n * #### Example:\n *\n *     Model.findByIdAndUpdate(id, { name: 'jason bourne' }, options)\n *\n *     // is sent as\n *     Model.findByIdAndUpdate(id, { $set: { name: 'jason bourne' }}, options)\n *\n * #### Note:\n *\n * `findOneAndX` and `findByIdAndX` functions support limited validation. You can\n * enable validation by setting the `runValidators` option.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     const doc = await Model.findById(id)\n *     doc.name = 'jason bourne';\n *     await doc.save();\n *\n * @param {Object|Number|String} id value of `_id` to query by\n * @param {Object} [update]\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {String} [options.returnDocument='before'] Has two possible values, `'before'` and `'after'`. By default, it will return the document before the update was applied.\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and [the Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Boolean} [options.runValidators] if true, runs [update validators](https://mongoosejs.com/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema\n * @param {Boolean} [options.setDefaultsOnInsert=true] If `setDefaultsOnInsert` and `upsert` are true, mongoose will apply the [defaults](https://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created\n * @param {Boolean} [options.includeResultMetadata] if true, returns the full [ModifyResult from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html) rather than just the document\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Boolean} [options.new=false] if true, return the modified document rather than the original\n * @param {Object|String} [options.select] sets the document fields to return.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @param {Boolean} [options.overwriteDiscriminatorKey=false] Mongoose removes discriminator key updates from `update` by default, set `overwriteDiscriminatorKey` to `true` to allow updating the discriminator key\n * @return {Query}\n * @see Model.findOneAndUpdate https://mongoosejs.com/docs/api/model.html#Model.findOneAndUpdate()\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n * @api public\n */\n\nModel.findByIdAndUpdate = function(id, update, options) {\n  _checkContext(this, 'findByIdAndUpdate');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.findByIdAndUpdate() no longer accepts a callback');\n  }\n\n  // if a model is passed in instead of an id\n  if (id instanceof Document) {\n    id = id._id;\n  }\n\n  return this.findOneAndUpdate.call(this, { _id: id }, update, options);\n};\n\n/**\n * Issue a MongoDB `findOneAndDelete()` command.\n *\n * Finds a matching document, removes it, and returns the found document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndDelete()`\n *\n * #### Example:\n *\n *     A.findOneAndDelete(conditions, options)  // return Query\n *     A.findOneAndDelete(conditions) // returns Query\n *     A.findOneAndDelete()           // returns Query\n *\n * `findOneAndX` and `findByIdAndX` functions support limited validation. You can\n * enable validation by setting the `runValidators` option.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     const doc = await Model.findById(id)\n *     doc.name = 'jason bourne';\n *     await doc.save();\n *\n * @param {Object} conditions\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean} [options.includeResultMetadata] if true, returns the full [ModifyResult from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html) rather than just the document\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Object|String} [options.select] sets the document fields to return.\n * @param {Number} [options.maxTimeMS] puts a time limit on the query - requires mongodb >= 2.6.0\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @api public\n */\n\nModel.findOneAndDelete = function(conditions, options) {\n  _checkContext(this, 'findOneAndDelete');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.findOneAndDelete() no longer accepts a callback');\n  }\n\n  let fields;\n  if (options) {\n    fields = options.select;\n    options.select = undefined;\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(fields);\n\n  return mq.findOneAndDelete(conditions, options);\n};\n\n/**\n * Issue a MongoDB `findOneAndDelete()` command by a document's _id field.\n * In other words, `findByIdAndDelete(id)` is a shorthand for\n * `findOneAndDelete({ _id: id })`.\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndDelete()`\n *\n * @param {Object|Number|String} id value of `_id` to query by\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see Model.findOneAndDelete https://mongoosejs.com/docs/api/model.html#Model.findOneAndDelete()\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n */\n\nModel.findByIdAndDelete = function(id, options) {\n  _checkContext(this, 'findByIdAndDelete');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.findByIdAndDelete() no longer accepts a callback');\n  }\n\n  return this.findOneAndDelete({ _id: id }, options);\n};\n\n/**\n * Issue a MongoDB `findOneAndReplace()` command.\n *\n * Finds a matching document, replaces it with the provided doc, and returns the document.\n *\n * This function triggers the following query middleware.\n *\n * - `findOneAndReplace()`\n *\n * #### Example:\n *\n *     A.findOneAndReplace(filter, replacement, options)  // return Query\n *     A.findOneAndReplace(filter, replacement) // returns Query\n *     A.findOneAndReplace()                    // returns Query\n *\n * @param {Object} filter Replace the first document that matches this filter\n * @param {Object} [replacement] Replace with this document\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {String} [options.returnDocument='before'] Has two possible values, `'before'` and `'after'`. By default, it will return the document before the update was applied.\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and [the Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Boolean} [options.includeResultMetadata] if true, returns the full [ModifyResult from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html) rather than just the document\n * @param {Object|String} [options.select] sets the document fields to return.\n * @param {Number} [options.maxTimeMS] puts a time limit on the query - requires mongodb >= 2.6.0\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @api public\n */\n\nModel.findOneAndReplace = function(filter, replacement, options) {\n  _checkContext(this, 'findOneAndReplace');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.findOneAndReplace() no longer accepts a callback');\n  }\n\n  let fields;\n  if (options) {\n    fields = options.select;\n    options.select = undefined;\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(fields);\n\n  return mq.findOneAndReplace(filter, replacement, options);\n};\n\n/**\n * Shortcut for saving one or more documents to the database.\n * `MyModel.create(docs)` does `new MyModel(doc).save()` for every doc in\n * docs.\n *\n * This function triggers the following middleware.\n *\n * - `save()`\n *\n * #### Example:\n *\n *     // Insert one new `Character` document\n *     await Character.create({ name: 'Jean-Luc Picard' });\n *\n *     // Insert multiple new `Character` documents\n *     await Character.create([{ name: 'Will Riker' }, { name: 'Geordi LaForge' }]);\n *\n *     // Create a new character within a transaction. Note that you **must**\n *     // pass an array as the first parameter to `create()` if you want to\n *     // specify options.\n *     await Character.create([{ name: 'Jean-Luc Picard' }], { session });\n *\n * @param {Array|Object} docs Documents to insert, as a spread or array\n * @param {Object} [options] Options passed down to `save()`. To specify `options`, `docs` **must** be an array, not a spread. See [Model.save](https://mongoosejs.com/docs/api/model.html#Model.prototype.save()) for available options.\n * @param {Boolean} [options.ordered] saves the docs in series rather than parallel.\n * @param {Boolean} [options.aggregateErrors] Aggregate Errors instead of throwing the first one that occurs. Default: false\n * @return {Promise}\n * @api public\n */\n\nModel.create = async function create(doc, options) {\n  if (typeof options === 'function' ||\n      typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.create() no longer accepts a callback');\n  }\n\n  _checkContext(this, 'create');\n\n  let args;\n  const discriminatorKey = this.schema.options.discriminatorKey;\n\n  if (Array.isArray(doc)) {\n    args = doc;\n    options = options != null && typeof options === 'object' ? options : {};\n  } else {\n    const last = arguments[arguments.length - 1];\n    options = {};\n    const hasCallback = typeof last === 'function' ||\n      typeof options === 'function' ||\n      typeof arguments[2] === 'function';\n    if (hasCallback) {\n      throw new MongooseError('Model.create() no longer accepts a callback');\n    } else {\n      args = [...arguments];\n      // For backwards compatibility with 6.x, because of gh-5061 Mongoose 6.x and\n      // older would treat a falsy last arg as a callback. We don't want to throw\n      // an error here, because it would look strange if `Test.create({}, void 0)`\n      // threw a callback error. But we also don't want to create an unnecessary document.\n      if (args.length > 1 && !last) {\n        args.pop();\n      }\n    }\n\n    if (args.length === 2 &&\n        args[0] != null &&\n        args[1] != null &&\n        args[0].session == null &&\n        last &&\n        getConstructorName(last.session) === 'ClientSession' &&\n        !this.schema.path('session')) {\n      // Probably means the user is running into the common mistake of trying\n      // to use a spread to specify options, see gh-7535\n      utils.warn('WARNING: to pass a `session` to `Model.create()` in ' +\n        'Mongoose, you **must** pass an array as the first argument. See: ' +\n        'https://mongoosejs.com/docs/api/model.html#Model.create()');\n    }\n  }\n\n  if (args.length === 0) {\n    return Array.isArray(doc) ? [] : null;\n  }\n  let res = [];\n  const immediateError = typeof options.aggregateErrors === 'boolean' ? !options.aggregateErrors : true;\n\n  delete options.aggregateErrors; // dont pass on the option to \"$save\"\n\n  if (options.ordered) {\n    for (let i = 0; i < args.length; i++) {\n      try {\n        const doc = args[i];\n        const Model = this.discriminators && doc[discriminatorKey] != null ?\n          this.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc[discriminatorKey]) :\n          this;\n        if (Model == null) {\n          throw new MongooseError(`Discriminator \"${doc[discriminatorKey]}\" not ` +\n          `found for model \"${this.modelName}\"`);\n        }\n        let toSave = doc;\n        if (!(toSave instanceof Model)) {\n          toSave = new Model(toSave);\n        }\n\n        await toSave.$save(options);\n        res.push(toSave);\n      } catch (err) {\n        if (!immediateError) {\n          res.push(err);\n        } else {\n          throw err;\n        }\n      }\n    }\n    return res;\n  } else if (!immediateError) {\n    res = await Promise.allSettled(args.map(async doc => {\n      const Model = this.discriminators && doc[discriminatorKey] != null ?\n        this.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc[discriminatorKey]) :\n        this;\n      if (Model == null) {\n        throw new MongooseError(`Discriminator \"${doc[discriminatorKey]}\" not ` +\n            `found for model \"${this.modelName}\"`);\n      }\n      let toSave = doc;\n\n      if (!(toSave instanceof Model)) {\n        toSave = new Model(toSave);\n      }\n\n      await toSave.$save(options);\n\n      return toSave;\n    }));\n    res = res.map(result => result.status === 'fulfilled' ? result.value : result.reason);\n  } else {\n    let firstError = null;\n    res = await Promise.all(args.map(async doc => {\n      const Model = this.discriminators && doc[discriminatorKey] != null ?\n        this.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc[discriminatorKey]) :\n        this;\n      if (Model == null) {\n        throw new MongooseError(`Discriminator \"${doc[discriminatorKey]}\" not ` +\n            `found for model \"${this.modelName}\"`);\n      }\n      try {\n        let toSave = doc;\n\n        if (!(toSave instanceof Model)) {\n          toSave = new Model(toSave);\n        }\n\n        await toSave.$save(options);\n\n        return toSave;\n      } catch (err) {\n        if (!firstError) {\n          firstError = err;\n        }\n      }\n    }));\n    if (firstError) {\n      throw firstError;\n    }\n  }\n\n\n  if (!Array.isArray(doc) && args.length === 1) {\n    return res[0];\n  }\n\n  return res;\n};\n\n/**\n * _Requires a replica set running MongoDB >= 3.6.0._ Watches the\n * underlying collection for changes using\n * [MongoDB change streams](https://www.mongodb.com/docs/manual/changeStreams/).\n *\n * This function does **not** trigger any middleware. In particular, it\n * does **not** trigger aggregate middleware.\n *\n * The ChangeStream object is an event emitter that emits the following events:\n *\n * - 'change': A change occurred, see below example\n * - 'error': An unrecoverable error occurred. In particular, change streams currently error out if they lose connection to the replica set primary. Follow [this GitHub issue](https://github.com/Automattic/mongoose/issues/6799) for updates.\n * - 'end': Emitted if the underlying stream is closed\n * - 'close': Emitted if the underlying stream is closed\n *\n * #### Example:\n *\n *     const doc = await Person.create({ name: 'Ned Stark' });\n *     const changeStream = Person.watch().on('change', change => console.log(change));\n *     // Will print from the above `console.log()`:\n *     // { _id: { _data: ... },\n *     //   operationType: 'delete',\n *     //   ns: { db: 'mydb', coll: 'Person' },\n *     //   documentKey: { _id: 5a51b125c5500f5aa094c7bd } }\n *     await doc.remove();\n *\n * @param {Array} [pipeline]\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#watch)\n * @param {Boolean} [options.hydrate=false] if true and `fullDocument: 'updateLookup'` is set, Mongoose will automatically hydrate `fullDocument` into a fully fledged Mongoose document\n * @return {ChangeStream} mongoose-specific change stream wrapper, inherits from EventEmitter\n * @api public\n */\n\nModel.watch = function(pipeline, options) {\n  _checkContext(this, 'watch');\n\n  const changeStreamThunk = cb => {\n    pipeline = pipeline || [];\n    prepareDiscriminatorPipeline(pipeline, this.schema, 'fullDocument');\n    if (this.$__collection.buffer) {\n      this.$__collection.addQueue(() => {\n        if (this.closed) {\n          return;\n        }\n        const driverChangeStream = this.$__collection.watch(pipeline, options);\n        cb(null, driverChangeStream);\n      });\n    } else {\n      const driverChangeStream = this.$__collection.watch(pipeline, options);\n      cb(null, driverChangeStream);\n    }\n  };\n\n  options = options || {};\n  options.model = this;\n\n  return new ChangeStream(changeStreamThunk, pipeline, options);\n};\n\n/**\n * _Requires MongoDB >= 3.6.0._ Starts a [MongoDB session](https://www.mongodb.com/docs/manual/release-notes/3.6/#client-sessions)\n * for benefits like causal consistency, [retryable writes](https://www.mongodb.com/docs/manual/core/retryable-writes/),\n * and [transactions](https://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html).\n *\n * Calling `MyModel.startSession()` is equivalent to calling `MyModel.db.startSession()`.\n *\n * This function does not trigger any middleware.\n *\n * #### Example:\n *\n *     const session = await Person.startSession();\n *     let doc = await Person.findOne({ name: 'Ned Stark' }, null, { session });\n *     await doc.remove();\n *     // `doc` will always be null, even if reading from a replica set\n *     // secondary. Without causal consistency, it is possible to\n *     // get a doc back from the below query if the query reads from a\n *     // secondary that is experiencing replication lag.\n *     doc = await Person.findOne({ name: 'Ned Stark' }, null, { session, readPreference: 'secondary' });\n *\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#startSession)\n * @param {Boolean} [options.causalConsistency=true] set to false to disable causal consistency\n * @return {Promise<ClientSession>} promise that resolves to a MongoDB driver `ClientSession`\n * @api public\n */\n\nModel.startSession = function() {\n  _checkContext(this, 'startSession');\n\n  return this.db.startSession.apply(this.db, arguments);\n};\n\n/**\n * Shortcut for validating an array of documents and inserting them into\n * MongoDB if they're all valid. This function is faster than `.create()`\n * because it only sends one operation to the server, rather than one for each\n * document.\n *\n * Mongoose always validates each document **before** sending `insertMany`\n * to MongoDB. So if one document has a validation error, no documents will\n * be saved, unless you set\n * [the `ordered` option to false](https://www.mongodb.com/docs/manual/reference/method/db.collection.insertMany/#error-handling).\n *\n * This function does **not** trigger save middleware.\n *\n * This function triggers the following middleware.\n *\n * - `insertMany()`\n *\n * #### Example:\n *\n *     await Movies.insertMany([\n *       { name: 'Star Wars' },\n *       { name: 'The Empire Strikes Back' }\n *     ]);\n *\n * @param {Array|Object|*} doc(s)\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#insertMany)\n * @param {Boolean} [options.ordered=true] if true, will fail fast on the first error encountered. If false, will insert all the documents it can and report errors later. An `insertMany()` with `ordered = false` is called an \"unordered\" `insertMany()`.\n * @param {Boolean} [options.rawResult=false] if false, the returned promise resolves to the documents that passed mongoose document validation. If `true`, will return the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/InsertManyResult.html) with a `mongoose` property that contains `validationErrors` and `results` if this is an unordered `insertMany`.\n * @param {Boolean} [options.lean=false] if `true`, skips hydrating the documents. This means Mongoose will **not** cast or validate any of the documents passed to `insertMany()`. This option is useful if you need the extra performance, but comes with data integrity risk. Consider using with [`castObject()`](https://mongoosejs.com/docs/api/model.html#Model.castObject()).\n * @param {Number} [options.limit=null] this limits the number of documents being processed (validation/casting) by mongoose in parallel, this does **NOT** send the documents in batches to MongoDB. Use this option if you're processing a large number of documents and your app is running out of memory.\n * @param {String|Object|Array} [options.populate=null] populates the result documents. This option is a no-op if `rawResult` is set.\n * @param {Boolean} [options.throwOnValidationError=false] If true and `ordered: false`, throw an error if one of the operations failed validation, but all valid operations completed successfully.\n * @return {Promise} resolving to the raw result from the MongoDB driver if `options.rawResult` was `true`, or the documents that passed validation, otherwise\n * @api public\n */\n\nModel.insertMany = async function insertMany(arr, options) {\n  _checkContext(this, 'insertMany');\n  if (typeof options === 'function' ||\n    typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.insertMany() no longer accepts a callback');\n  }\n\n  return new Promise((resolve, reject) => {\n    this.$__insertMany(arr, options, (err, res) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n};\n\n/**\n * ignore\n *\n * @param {Array} arr\n * @param {Object} options\n * @param {Function} callback\n * @api private\n * @memberOf Model\n * @method $__insertMany\n * @static\n */\n\nModel.$__insertMany = function(arr, options, callback) {\n  const _this = this;\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  callback = callback || utils.noop;\n  options = options || {};\n  const limit = options.limit || 1000;\n  const rawResult = !!options.rawResult;\n  const ordered = typeof options.ordered === 'boolean' ? options.ordered : true;\n  const throwOnValidationError = typeof options.throwOnValidationError === 'boolean' ? options.throwOnValidationError : false;\n  const lean = !!options.lean;\n\n  if (!Array.isArray(arr)) {\n    arr = [arr];\n  }\n\n  const validationErrors = [];\n  const validationErrorsToOriginalOrder = new Map();\n  const results = ordered ? null : new Array(arr.length);\n  const toExecute = arr.map((doc, index) =>\n    callback => {\n      // If option `lean` is set to true bypass validation and hydration\n      if (lean) {\n        // we have to execute callback at the nextTick to be compatible\n        // with parallelLimit, as `results` variable has TDZ issue if we\n        // execute the callback synchronously\n        return immediate(() => callback(null, doc));\n      }\n      if (!(doc instanceof _this)) {\n        if (doc != null && typeof doc !== 'object') {\n          return callback(new ObjectParameterError(doc, 'arr.' + index, 'insertMany'));\n        }\n        try {\n          doc = new _this(doc);\n        } catch (err) {\n          return callback(err);\n        }\n      }\n      if (options.session != null) {\n        doc.$session(options.session);\n      }\n      // If option `lean` is set to true bypass validation\n      if (lean) {\n        // we have to execute callback at the nextTick to be compatible\n        // with parallelLimit, as `results` variable has TDZ issue if we\n        // execute the callback synchronously\n        return immediate(() => callback(null, doc));\n      }\n      doc.$validate().then(\n        () => { callback(null, doc); },\n        error => {\n          if (ordered === false) {\n            validationErrors.push(error);\n            validationErrorsToOriginalOrder.set(error, index);\n            results[index] = error;\n            return callback(null, null);\n          }\n          callback(error);\n        }\n      );\n    });\n\n  parallelLimit(toExecute, limit, function(error, docs) {\n    if (error) {\n      callback(error, null);\n      return;\n    }\n\n    const originalDocIndex = new Map();\n    const validDocIndexToOriginalIndex = new Map();\n    for (let i = 0; i < docs.length; ++i) {\n      originalDocIndex.set(docs[i], i);\n    }\n\n    // We filter all failed pre-validations by removing nulls\n    const docAttributes = docs.filter(function(doc) {\n      return doc != null;\n    });\n    for (let i = 0; i < docAttributes.length; ++i) {\n      validDocIndexToOriginalIndex.set(i, originalDocIndex.get(docAttributes[i]));\n    }\n\n    // Make sure validation errors are in the same order as the\n    // original documents, so if both doc1 and doc2 both fail validation,\n    // `Model.insertMany([doc1, doc2])` will always have doc1's validation\n    // error before doc2's. Re: gh-12791.\n    if (validationErrors.length > 0) {\n      validationErrors.sort((err1, err2) => {\n        return validationErrorsToOriginalOrder.get(err1) - validationErrorsToOriginalOrder.get(err2);\n      });\n    }\n\n    // Quickly escape while there aren't any valid docAttributes\n    if (docAttributes.length === 0) {\n      if (rawResult) {\n        const res = {\n          acknowledged: true,\n          insertedCount: 0,\n          insertedIds: {},\n          mongoose: {\n            validationErrors: validationErrors\n          }\n        };\n        return callback(null, res);\n      }\n      callback(null, []);\n      return;\n    }\n    const docObjects = lean ? docAttributes : docAttributes.map(function(doc) {\n      if (doc.$__schema.options.versionKey) {\n        doc[doc.$__schema.options.versionKey] = 0;\n      }\n      const shouldSetTimestamps = (!options || options.timestamps !== false) && doc.initializeTimestamps && (!doc.$__ || doc.$__.timestamps !== false);\n      if (shouldSetTimestamps) {\n        return doc.initializeTimestamps().toObject(internalToObjectOptions);\n      }\n      return doc.toObject(internalToObjectOptions);\n    });\n\n    _this.$__collection.insertMany(docObjects, options).then(\n      res => {\n        if (!lean) {\n          for (const attribute of docAttributes) {\n            attribute.$__reset();\n            _setIsNew(attribute, false);\n          }\n        }\n\n        if (ordered === false && throwOnValidationError && validationErrors.length > 0) {\n          for (let i = 0; i < results.length; ++i) {\n            if (results[i] === void 0) {\n              results[i] = docs[i];\n            }\n          }\n          return callback(new MongooseBulkWriteError(\n            validationErrors,\n            results,\n            res,\n            'insertMany'\n          ));\n        }\n\n        if (rawResult) {\n          if (ordered === false) {\n            for (let i = 0; i < results.length; ++i) {\n              if (results[i] === void 0) {\n                results[i] = docs[i];\n              }\n            }\n\n            // Decorate with mongoose validation errors in case of unordered,\n            // because then still do `insertMany()`\n            res.mongoose = {\n              validationErrors: validationErrors,\n              results: results\n            };\n          }\n          return callback(null, res);\n        }\n\n        if (options.populate != null) {\n          return _this.populate(docAttributes, options.populate).then(\n            docs => { callback(null, docs); },\n            err => {\n              if (err != null) {\n                err.insertedDocs = docAttributes;\n              }\n              throw err;\n            }\n          );\n        }\n\n        callback(null, docAttributes);\n      },\n      error => {\n        // `writeErrors` is a property reported by the MongoDB driver,\n        // just not if there's only 1 error.\n        if (error.writeErrors == null &&\n            (error.result && error.result.result && error.result.result.writeErrors) != null) {\n          error.writeErrors = error.result.result.writeErrors;\n        }\n\n        // `insertedDocs` is a Mongoose-specific property\n        const hasWriteErrors = error && error.writeErrors;\n        const erroredIndexes = new Set((error && error.writeErrors || []).map(err => err.index));\n\n        if (error.writeErrors != null) {\n          for (let i = 0; i < error.writeErrors.length; ++i) {\n            const originalIndex = validDocIndexToOriginalIndex.get(error.writeErrors[i].index);\n            error.writeErrors[i] = {\n              ...error.writeErrors[i],\n              index: originalIndex\n            };\n            if (!ordered) {\n              results[originalIndex] = error.writeErrors[i];\n            }\n          }\n        }\n\n        if (!ordered) {\n          for (let i = 0; i < results.length; ++i) {\n            if (results[i] === void 0) {\n              results[i] = docs[i];\n            }\n          }\n\n          error.results = results;\n        }\n\n        let firstErroredIndex = -1;\n        error.insertedDocs = docAttributes.\n          filter((doc, i) => {\n            const isErrored = !hasWriteErrors || erroredIndexes.has(i);\n\n            if (ordered) {\n              if (firstErroredIndex > -1) {\n                return i < firstErroredIndex;\n              }\n\n              if (isErrored) {\n                firstErroredIndex = i;\n              }\n            }\n\n            return !isErrored;\n          }).\n          map(function setIsNewForInsertedDoc(doc) {\n            if (lean) {\n              return doc;\n            }\n            doc.$__reset();\n            _setIsNew(doc, false);\n            return doc;\n          });\n\n        if (rawResult && ordered === false) {\n          error.mongoose = {\n            validationErrors: validationErrors,\n            results: results\n          };\n        }\n\n        callback(error, null);\n      }\n    );\n  });\n};\n\n/*!\n * ignore\n */\n\nfunction _setIsNew(doc, val) {\n  doc.$isNew = val;\n  doc.$emit('isNew', val);\n  doc.constructor.emit('isNew', val);\n\n  const subdocs = doc.$getAllSubdocs();\n  for (const subdoc of subdocs) {\n    subdoc.$isNew = val;\n    subdoc.$emit('isNew', val);\n  }\n}\n\n/**\n * Sends multiple `insertOne`, `updateOne`, `updateMany`, `replaceOne`,\n * `deleteOne`, and/or `deleteMany` operations to the MongoDB server in one\n * command. This is faster than sending multiple independent operations (e.g.\n * if you use `create()`) because with `bulkWrite()` there is only one round\n * trip to MongoDB.\n *\n * Mongoose will perform casting on all operations you provide.\n * The only exception is [setting the `update` operator for `updateOne` or `updateMany` to a pipeline](https://www.mongodb.com/docs/manual/reference/method/db.collection.bulkWrite/#updateone-and-updatemany): Mongoose does **not** cast update pipelines.\n *\n * This function does **not** trigger any middleware, neither `save()`, nor `update()`.\n * If you need to trigger\n * `save()` middleware for every document use [`create()`](https://mongoosejs.com/docs/api/model.html#Model.create()) instead.\n *\n * #### Example:\n *\n *     Character.bulkWrite([\n *       {\n *         insertOne: {\n *           document: {\n *             name: 'Eddard Stark',\n *             title: 'Warden of the North'\n *           }\n *         }\n *       },\n *       {\n *         updateOne: {\n *           filter: { name: 'Eddard Stark' },\n *           // If you were using the MongoDB driver directly, you'd need to do\n *           // `update: { $set: { title: ... } }` but mongoose adds $set for\n *           // you.\n *           update: { title: 'Hand of the King' }\n *         }\n *       },\n *       {\n *         deleteOne: {\n *           filter: { name: 'Eddard Stark' }\n *         }\n *       }\n *     ]).then(res => {\n *      // Prints \"1 1 1\"\n *      console.log(res.insertedCount, res.modifiedCount, res.deletedCount);\n *     });\n *\n *     // Mongoose does **not** cast update pipelines, so no casting for the `update` option below.\n *     // Mongoose does still cast `filter`\n *     await Character.bulkWrite([{\n *       updateOne: {\n *         filter: { name: 'Annika Hansen' },\n *         update: [{ $set: { name: 7 } }] // Array means update pipeline, so Mongoose skips casting\n *       }\n *     }]);\n *\n * The [supported operations](https://www.mongodb.com/docs/manual/reference/method/db.collection.bulkWrite/#db.collection.bulkWrite) are:\n *\n * - `insertOne`\n * - `updateOne`\n * - `updateMany`\n * - `deleteOne`\n * - `deleteMany`\n * - `replaceOne`\n *\n * @param {Array} ops\n * @param {Object} [ops.insertOne.document] The document to insert\n * @param {Object} [ops.updateOne.filter] Update the first document that matches this filter\n * @param {Object} [ops.updateOne.update] An object containing [update operators](https://www.mongodb.com/docs/manual/reference/operator/update/)\n * @param {Boolean} [ops.updateOne.upsert=false] If true, insert a doc if none match\n * @param {Boolean} [ops.updateOne.timestamps=true] If false, do not apply [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) to the operation\n * @param {Object} [ops.updateOne.collation] The [MongoDB collation](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-collations) to use\n * @param {Array} [ops.updateOne.arrayFilters] The [array filters](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-36-array-filters.html) used in `update`\n * @param {Object} [ops.updateMany.filter] Update all the documents that match this filter\n * @param {Object} [ops.updateMany.update] An object containing [update operators](https://www.mongodb.com/docs/manual/reference/operator/update/)\n * @param {Boolean} [ops.updateMany.upsert=false] If true, insert a doc if no documents match `filter`\n * @param {Boolean} [ops.updateMany.timestamps=true] If false, do not apply [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) to the operation\n * @param {Object} [ops.updateMany.collation] The [MongoDB collation](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-collations) to use\n * @param {Array} [ops.updateMany.arrayFilters] The [array filters](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-36-array-filters.html) used in `update`\n * @param {Object} [ops.deleteOne.filter] Delete the first document that matches this filter\n * @param {Object} [ops.deleteMany.filter] Delete all documents that match this filter\n * @param {Object} [ops.replaceOne.filter] Replace the first document that matches this filter\n * @param {Object} [ops.replaceOne.replacement] The replacement document\n * @param {Boolean} [ops.replaceOne.upsert=false] If true, insert a doc if no documents match `filter`\n * @param {Object} [options]\n * @param {Boolean} [options.ordered=true] If true, execute writes in order and stop at the first error. If false, execute writes in parallel and continue until all writes have either succeeded or errored.\n * @param {ClientSession} [options.session=null] The session associated with this bulk write. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {String|number} [options.w=1] The [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/). See [`Query#w()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.w()) for more information.\n * @param {number} [options.wtimeout=null] The [write concern timeout](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout).\n * @param {Boolean} [options.j=true] If false, disable [journal acknowledgement](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option)\n * @param {Boolean} [options.skipValidation=false] Set to true to skip Mongoose schema validation on bulk write operations. Mongoose currently runs validation on `insertOne` and `replaceOne` operations by default.\n * @param {Boolean} [options.bypassDocumentValidation=false] If true, disable [MongoDB server-side schema validation](https://www.mongodb.com/docs/manual/core/schema-validation/) for all writes in this bulk.\n * @param {Boolean} [options.throwOnValidationError=false] If true and `ordered: false`, throw an error if one of the operations failed validation, but all valid operations completed successfully.\n * @param {Boolean} [options.strict=null] Overwrites the [`strict` option](https://mongoosejs.com/docs/guide.html#strict) on schema. If false, allows filtering and writing fields not defined in the schema for all writes in this bulk.\n * @return {Promise} resolves to a [`BulkWriteOpResult`](https://mongodb.github.io/node-mongodb-native/4.9/classes/BulkWriteResult.html) if the operation succeeds\n * @api public\n */\n\nModel.bulkWrite = async function bulkWrite(ops, options) {\n  _checkContext(this, 'bulkWrite');\n\n  if (typeof options === 'function' ||\n      typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.bulkWrite() no longer accepts a callback');\n  }\n  options = options || {};\n\n  const shouldSkip = await new Promise((resolve, reject) => {\n    this.hooks.execPre('bulkWrite', this, [ops, options], (err) => {\n      if (err != null) {\n        if (err instanceof Kareem.skipWrappedFunction) {\n          return resolve(err);\n        }\n        return reject(err);\n      }\n      resolve();\n    });\n  });\n\n  if (shouldSkip) {\n    return shouldSkip.args[0];\n  }\n\n  const ordered = options.ordered == null ? true : options.ordered;\n\n  if (ops.length === 0) {\n    return getDefaultBulkwriteResult();\n  }\n\n  const validations = ops.map(op => castBulkWrite(this, op, options));\n\n  let res = null;\n  if (ordered) {\n    await new Promise((resolve, reject) => {\n      each(validations, (fn, cb) => fn(cb), error => {\n        if (error) {\n          return reject(error);\n        }\n\n        resolve();\n      });\n    });\n\n    try {\n      res = await this.$__collection.bulkWrite(ops, options);\n    } catch (error) {\n      await new Promise((resolve, reject) => {\n        const _opts = { error: error };\n        this.hooks.execPost('bulkWrite', this, [null], _opts, (err) => {\n          if (err != null) {\n            return reject(err);\n          }\n          resolve();\n        });\n      });\n    }\n  } else {\n    let remaining = validations.length;\n    let validOps = [];\n    let validationErrors = [];\n    const results = [];\n    await new Promise((resolve) => {\n      for (let i = 0; i < validations.length; ++i) {\n        validations[i]((err) => {\n          if (err == null) {\n            validOps.push(i);\n          } else {\n            validationErrors.push({ index: i, error: err });\n            results[i] = err;\n          }\n          if (--remaining <= 0) {\n            resolve();\n          }\n        });\n      }\n    });\n\n    validationErrors = validationErrors.\n      sort((v1, v2) => v1.index - v2.index).\n      map(v => v.error);\n\n    const validOpIndexes = validOps;\n    validOps = validOps.sort().map(index => ops[index]);\n\n    if (validOps.length === 0) {\n      return getDefaultBulkwriteResult();\n    }\n\n    let error;\n    [res, error] = await this.$__collection.bulkWrite(validOps, options).\n      then(res => ([res, null])).\n      catch(err => ([null, err]));\n\n    if (error) {\n      if (validationErrors.length > 0) {\n        error.mongoose = error.mongoose || {};\n        error.mongoose.validationErrors = validationErrors;\n      }\n\n      await new Promise((resolve, reject) => {\n        const _opts = { error: error };\n        this.hooks.execPost('bulkWrite', this, [null], _opts, (err) => {\n          if (err != null) {\n            return reject(err);\n          }\n          resolve();\n        });\n      });\n    }\n\n    for (let i = 0; i < validOpIndexes.length; ++i) {\n      results[validOpIndexes[i]] = null;\n    }\n    if (validationErrors.length > 0) {\n      if (options.throwOnValidationError) {\n        throw new MongooseBulkWriteError(\n          validationErrors,\n          results,\n          res,\n          'bulkWrite'\n        );\n      } else {\n        res.mongoose = res.mongoose || {};\n        res.mongoose.validationErrors = validationErrors;\n        res.mongoose.results = results;\n      }\n    }\n  }\n\n  await new Promise((resolve, reject) => {\n    this.hooks.execPost('bulkWrite', this, [res], (err) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve();\n    });\n  });\n\n  return res;\n};\n\n/**\n *  takes an array of documents, gets the changes and inserts/updates documents in the database\n *  according to whether or not the document is new, or whether it has changes or not.\n *\n * `bulkSave` uses `bulkWrite` under the hood, so it's mostly useful when dealing with many documents (10K+)\n *\n * @param {Array<Document>} documents\n * @param {Object} [options] options passed to the underlying `bulkWrite()`\n * @param {Boolean} [options.timestamps] defaults to `null`, when set to false, mongoose will not add/update timestamps to the documents.\n * @param {ClientSession} [options.session=null] The session associated with this bulk write. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {String|number} [options.w=1] The [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/). See [`Query#w()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.w()) for more information.\n * @param {number} [options.wtimeout=null] The [write concern timeout](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout).\n * @param {Boolean} [options.j=true] If false, disable [journal acknowledgement](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option)\n *\n */\nModel.bulkSave = async function bulkSave(documents, options) {\n  options = options || {};\n\n  if (options.timestamps != null) {\n    for (const document of documents) {\n      document.$__.saveOptions = document.$__.saveOptions || {};\n      document.$__.saveOptions.timestamps = options.timestamps;\n    }\n  } else {\n    for (const document of documents) {\n      if (document.$__.timestamps != null) {\n        document.$__.saveOptions = document.$__.saveOptions || {};\n        document.$__.saveOptions.timestamps = document.$__.timestamps;\n      }\n    }\n  }\n\n  await Promise.all(documents.map(buildPreSavePromise));\n\n  const writeOperations = this.buildBulkWriteOperations(documents, { skipValidation: true, timestamps: options.timestamps });\n\n  const { bulkWriteResult, bulkWriteError } = await this.bulkWrite(writeOperations, options).then(\n    (res) => ({ bulkWriteResult: res, bulkWriteError: null }),\n    (err) => ({ bulkWriteResult: null, bulkWriteError: err })\n  );\n\n  await Promise.all(\n    documents.map(async(document) => {\n      const documentError = bulkWriteError && bulkWriteError.writeErrors.find(writeError => {\n        const writeErrorDocumentId = writeError.err.op._id || writeError.err.op.q._id;\n        return writeErrorDocumentId.toString() === document._id.toString();\n      });\n\n      if (documentError == null) {\n        await handleSuccessfulWrite(document);\n      }\n    })\n  );\n\n  if (bulkWriteError && bulkWriteError.writeErrors && bulkWriteError.writeErrors.length) {\n    throw bulkWriteError;\n  }\n\n  return bulkWriteResult;\n};\n\nfunction buildPreSavePromise(document) {\n  return new Promise((resolve, reject) => {\n    document.schema.s.hooks.execPre('save', document, (err) => {\n      if (err) {\n        reject(err);\n        return;\n      }\n      resolve();\n    });\n  });\n}\n\nfunction handleSuccessfulWrite(document) {\n  return new Promise((resolve, reject) => {\n    if (document.$isNew) {\n      _setIsNew(document, false);\n    }\n\n    document.$__reset();\n    document.schema.s.hooks.execPost('save', document, [document], {}, (err) => {\n      if (err) {\n        reject(err);\n        return;\n      }\n      resolve();\n    });\n\n  });\n}\n\n/**\n * Apply defaults to the given document or POJO.\n *\n * @param {Object|Document} obj object or document to apply defaults on\n * @returns {Object|Document}\n * @api public\n */\n\nModel.applyDefaults = function applyDefaults(doc) {\n  if (doc.$__ != null) {\n    applyDefaultsHelper(doc, doc.$__.fields, doc.$__.exclude);\n\n    for (const subdoc of doc.$getAllSubdocs()) {\n      applyDefaults(subdoc, subdoc.$__.fields, subdoc.$__.exclude);\n    }\n\n    return doc;\n  }\n\n  applyDefaultsToPOJO(doc, this.schema);\n\n  return doc;\n};\n\n/**\n * Cast the given POJO to the model's schema\n *\n * #### Example:\n *\n *     const Test = mongoose.model('Test', Schema({ num: Number }));\n *\n *     const obj = Test.castObject({ num: '42' });\n *     obj.num; // 42 as a number\n *\n *     Test.castObject({ num: 'not a number' }); // Throws a ValidationError\n *\n * @param {Object} obj object or document to cast\n * @param {Object} options options passed to castObject\n * @param {Boolean} options.ignoreCastErrors If set to `true` will not throw a ValidationError and only return values that were successfully cast.\n * @returns {Object} POJO casted to the model's schema\n * @throws {ValidationError} if casting failed for at least one path\n * @api public\n */\n\nModel.castObject = function castObject(obj, options) {\n  options = options || {};\n  const ret = {};\n\n  const schema = this.schema;\n  const paths = Object.keys(schema.paths);\n\n  for (const path of paths) {\n    const schemaType = schema.path(path);\n    if (!schemaType || !schemaType.$isMongooseArray) {\n      continue;\n    }\n\n    const val = get(obj, path);\n    pushNestedArrayPaths(paths, val, path);\n  }\n\n  let error = null;\n\n  for (const path of paths) {\n    const schemaType = schema.path(path);\n    if (schemaType == null) {\n      continue;\n    }\n\n    let val = get(obj, path, void 0);\n\n    if (val == null) {\n      continue;\n    }\n\n    const pieces = path.indexOf('.') === -1 ? [path] : path.split('.');\n    let cur = ret;\n    for (let i = 0; i < pieces.length - 1; ++i) {\n      if (cur[pieces[i]] == null) {\n        cur[pieces[i]] = isNaN(pieces[i + 1]) ? {} : [];\n      }\n      cur = cur[pieces[i]];\n    }\n\n    if (schemaType.$isMongooseDocumentArray) {\n      continue;\n    }\n    if (schemaType.$isSingleNested || schemaType.$isMongooseDocumentArrayElement) {\n      try {\n        val = Model.castObject.call(schemaType.caster, val);\n      } catch (err) {\n        if (!options.ignoreCastErrors) {\n          error = error || new ValidationError();\n          error.addError(path, err);\n        }\n        continue;\n      }\n\n      cur[pieces[pieces.length - 1]] = val;\n      continue;\n    }\n\n    try {\n      val = schemaType.cast(val);\n      cur[pieces[pieces.length - 1]] = val;\n    } catch (err) {\n      if (!options.ignoreCastErrors) {\n        error = error || new ValidationError();\n        error.addError(path, err);\n      }\n\n      continue;\n    }\n  }\n\n  if (error != null) {\n    throw error;\n  }\n\n  return ret;\n};\n\n/**\n * Build bulk write operations for `bulkSave()`.\n *\n * @param {Array<Document>} documents The array of documents to build write operations of\n * @param {Object} options\n * @param {Boolean} options.skipValidation defaults to `false`, when set to true, building the write operations will bypass validating the documents.\n * @param {Boolean} options.timestamps defaults to `null`, when set to false, mongoose will not add/update timestamps to the documents.\n * @return {Array<Promise>} Returns a array of all Promises the function executes to be awaited.\n * @api private\n */\n\nModel.buildBulkWriteOperations = function buildBulkWriteOperations(documents, options) {\n  if (!Array.isArray(documents)) {\n    throw new Error(`bulkSave expects an array of documents to be passed, received \\`${documents}\\` instead`);\n  }\n\n  setDefaultOptions();\n  const discriminatorKey = this.schema.options.discriminatorKey;\n\n  const writeOperations = documents.reduce((accumulator, document, i) => {\n    if (!options.skipValidation) {\n      if (!(document instanceof Document)) {\n        throw new Error(`documents.${i} was not a mongoose document, documents must be an array of mongoose documents (instanceof mongoose.Document).`);\n      }\n      const validationError = document.validateSync();\n      if (validationError) {\n        throw validationError;\n      }\n    }\n\n    const isANewDocument = document.isNew;\n    if (isANewDocument) {\n      const writeOperation = { insertOne: { document } };\n      utils.injectTimestampsOption(writeOperation.insertOne, options.timestamps);\n      accumulator.push(writeOperation);\n\n      return accumulator;\n    }\n\n    const delta = document.$__delta();\n    const isDocumentWithChanges = delta != null && !utils.isEmptyObject(delta[0]);\n\n    if (isDocumentWithChanges) {\n      const where = document.$__where(delta[0]);\n      const changes = delta[1];\n\n      _applyCustomWhere(document, where);\n\n      // Set the discriminator key, so bulk write casting knows which\n      // schema to use re: gh-13907\n      if (document[discriminatorKey] != null && !(discriminatorKey in where)) {\n        where[discriminatorKey] = document[discriminatorKey];\n      }\n\n      document.$__version(where, delta);\n      const writeOperation = { updateOne: { filter: where, update: changes } };\n      utils.injectTimestampsOption(writeOperation.updateOne, options.timestamps);\n      accumulator.push(writeOperation);\n\n      return accumulator;\n    }\n\n    return accumulator;\n  }, []);\n\n  return writeOperations;\n\n\n  function setDefaultOptions() {\n    options = options || {};\n    if (options.skipValidation == null) {\n      options.skipValidation = false;\n    }\n  }\n};\n\n\n/**\n * Shortcut for creating a new Document from existing raw data, pre-saved in the DB.\n * The document returned has no paths marked as modified initially.\n *\n * #### Example:\n *\n *     // hydrate previous data into a Mongoose document\n *     const mongooseCandy = Candy.hydrate({ _id: '54108337212ffb6d459f854c', type: 'jelly bean' });\n *\n * @param {Object} obj\n * @param {Object|String|String[]} [projection] optional projection containing which fields should be selected for this document\n * @param {Object} [options] optional options\n * @param {Boolean} [options.setters=false] if true, apply schema setters when hydrating\n * @param {Boolean} [options.hydratedPopulatedDocs=false] if true, populates the docs if passing pre-populated data\n * @return {Document} document instance\n * @api public\n */\n\nModel.hydrate = function(obj, projection, options) {\n  _checkContext(this, 'hydrate');\n\n  if (projection != null) {\n    if (obj != null && obj.$__ != null) {\n      obj = obj.toObject(internalToObjectOptions);\n    }\n    obj = applyProjection(obj, projection);\n  }\n  const document = (__webpack_require__(/*! ./queryHelpers */ \"../backend/node_modules/mongoose/lib/queryHelpers.js\").createModel)(this, obj, projection);\n  document.$init(obj, options);\n  return document;\n};\n\n/**\n * Same as `updateOne()`, except MongoDB will update _all_ documents that match\n * `filter` (as opposed to just the first one) regardless of the value of\n * the `multi` option.\n *\n * **Note** updateMany will _not_ fire update middleware. Use `pre('updateMany')`\n * and `post('updateMany')` instead.\n *\n * #### Example:\n *\n *     const res = await Person.updateMany({ name: /Stark$/ }, { isDeleted: true });\n *     res.matchedCount; // Number of documents matched\n *     res.modifiedCount; // Number of documents modified\n *     res.acknowledged; // Boolean indicating everything went smoothly.\n *     res.upsertedId; // null or an id containing a document that had to be upserted.\n *     res.upsertedCount; // Number indicating how many documents had to be upserted. Will either be 0 or 1.\n *\n * This function triggers the following middleware.\n *\n * - `updateMany()`\n *\n * @param {Object} filter\n * @param {Object|Array} update. If array, this update will be treated as an update pipeline and not casted.\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @param {Boolean} [options.overwriteDiscriminatorKey=false] Mongoose removes discriminator key updates from `update` by default, set `overwriteDiscriminatorKey` to `true` to allow updating the discriminator key\n * @return {Query}\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see MongoDB docs https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @api public\n */\n\nModel.updateMany = function updateMany(conditions, doc, options) {\n  _checkContext(this, 'updateMany');\n\n  return _update(this, 'updateMany', conditions, doc, options);\n};\n\n/**\n * Update _only_ the first document that matches `filter`.\n *\n * - Use `replaceOne()` if you want to overwrite an entire document rather than using atomic operators like `$set`.\n *\n * #### Example:\n *\n *     const res = await Person.updateOne({ name: 'Jean-Luc Picard' }, { ship: 'USS Enterprise' });\n *     res.matchedCount; // Number of documents matched\n *     res.modifiedCount; // Number of documents modified\n *     res.acknowledged; // Boolean indicating everything went smoothly.\n *     res.upsertedId; // null or an id containing a document that had to be upserted.\n *     res.upsertedCount; // Number indicating how many documents had to be upserted. Will either be 0 or 1.\n *\n * This function triggers the following middleware.\n *\n * - `updateOne()`\n *\n * @param {Object} filter\n * @param {Object|Array} update. If array, this update will be treated as an update pipeline and not casted.\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @param {Boolean} [options.overwriteDiscriminatorKey=false] Mongoose removes discriminator key updates from `update` by default, set `overwriteDiscriminatorKey` to `true` to allow updating the discriminator key\n * @return {Query}\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see MongoDB docs https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @api public\n */\n\nModel.updateOne = function updateOne(conditions, doc, options) {\n  _checkContext(this, 'updateOne');\n\n  return _update(this, 'updateOne', conditions, doc, options);\n};\n\n/**\n * Replace the existing document with the given document (no atomic operators like `$set`).\n *\n * #### Example:\n *\n *     const res = await Person.replaceOne({ _id: 24601 }, { name: 'Jean Valjean' });\n *     res.matchedCount; // Number of documents matched\n *     res.modifiedCount; // Number of documents modified\n *     res.acknowledged; // Boolean indicating everything went smoothly.\n *     res.upsertedId; // null or an id containing a document that had to be upserted.\n *     res.upsertedCount; // Number indicating how many documents had to be upserted. Will either be 0 or 1.\n *\n * This function triggers the following middleware.\n *\n * - `replaceOne()`\n *\n * @param {Object} filter\n * @param {Object} doc\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @return {Query}\n * @api public\n */\n\nModel.replaceOne = function replaceOne(conditions, doc, options) {\n  _checkContext(this, 'replaceOne');\n\n  const versionKey = this && this.schema && this.schema.options && this.schema.options.versionKey || null;\n  if (versionKey && !doc[versionKey]) {\n    doc[versionKey] = 0;\n  }\n\n  return _update(this, 'replaceOne', conditions, doc, options);\n};\n\n/**\n * Common code for `updateOne()`, `updateMany()`, `replaceOne()`, and `update()`\n * because they need to do the same thing\n * @api private\n */\n\nfunction _update(model, op, conditions, doc, options) {\n  const mq = new model.Query({}, {}, model, model.collection);\n\n  // gh-2406\n  // make local deep copy of conditions\n  if (conditions instanceof Document) {\n    conditions = conditions.toObject();\n  } else {\n    conditions = clone(conditions);\n  }\n  options = typeof options === 'function' ? options : clone(options);\n\n  const versionKey = model &&\n  model.schema &&\n  model.schema.options &&\n  model.schema.options.versionKey || null;\n  decorateUpdateWithVersionKey(doc, options, versionKey);\n\n  return mq[op](conditions, doc, options);\n}\n\n/**\n * Performs [aggregations](https://www.mongodb.com/docs/manual/aggregation/) on the models collection.\n *\n * If a `callback` is passed, the `aggregate` is executed and a `Promise` is returned. If a callback is not passed, the `aggregate` itself is returned.\n *\n * This function triggers the following middleware.\n *\n * - `aggregate()`\n *\n * #### Example:\n *\n *     // Find the max balance of all accounts\n *     const res = await Users.aggregate([\n *       { $group: { _id: null, maxBalance: { $max: '$balance' }}},\n *       { $project: { _id: 0, maxBalance: 1 }}\n *     ]);\n *\n *     console.log(res); // [ { maxBalance: 98000 } ]\n *\n *     // Or use the aggregation pipeline builder.\n *     const res = await Users.aggregate().\n *       group({ _id: null, maxBalance: { $max: '$balance' } }).\n *       project('-id maxBalance').\n *       exec();\n *     console.log(res); // [ { maxBalance: 98 } ]\n *\n * #### Note:\n *\n * - Mongoose does **not** cast aggregation pipelines to the model's schema because `$project` and `$group` operators allow redefining the \"shape\" of the documents at any stage of the pipeline, which may leave documents in an incompatible format. You can use the [mongoose-cast-aggregation plugin](https://github.com/AbdelrahmanHafez/mongoose-cast-aggregation) to enable minimal casting for aggregation pipelines.\n * - The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).\n *\n * #### More About Aggregations:\n *\n * - [Mongoose `Aggregate`](https://mongoosejs.com/docs/api/aggregate.html)\n * - [An Introduction to Mongoose Aggregate](https://masteringjs.io/tutorials/mongoose/aggregate)\n * - [MongoDB Aggregation docs](https://www.mongodb.com/docs/manual/applications/aggregation/)\n *\n * @see Aggregate https://mongoosejs.com/docs/api/aggregate.html#Aggregate()\n * @see MongoDB https://www.mongodb.com/docs/manual/applications/aggregation/\n * @param {Array} [pipeline] aggregation pipeline as an array of objects\n * @param {Object} [options] aggregation options\n * @return {Aggregate}\n * @api public\n */\n\nModel.aggregate = function aggregate(pipeline, options) {\n  _checkContext(this, 'aggregate');\n\n  if (typeof options === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.aggregate() no longer accepts a callback');\n  }\n\n  const aggregate = new Aggregate(pipeline || []);\n  aggregate.model(this);\n  if (options != null) {\n    aggregate.option(options);\n  }\n\n  if (typeof callback === 'undefined') {\n    return aggregate;\n  }\n\n  return aggregate;\n};\n\n/**\n * Casts and validates the given object against this model's schema, passing the\n * given `context` to custom validators.\n *\n * #### Example:\n *\n *     const Model = mongoose.model('Test', Schema({\n *       name: { type: String, required: true },\n *       age: { type: Number, required: true }\n *     });\n *\n *     try {\n *       await Model.validate({ name: null }, ['name'])\n *     } catch (err) {\n *       err instanceof mongoose.Error.ValidationError; // true\n *       Object.keys(err.errors); // ['name']\n *     }\n *\n * @param {Object} obj\n * @param {Object|Array|String} pathsOrOptions\n * @param {Object} [context]\n * @return {Promise<Object>} casted and validated copy of `obj` if validation succeeded\n * @api public\n */\n\nModel.validate = async function validate(obj, pathsOrOptions, context) {\n  if ((arguments.length < 3) || (arguments.length === 3 && typeof arguments[2] === 'function')) {\n    // For convenience, if we're validating a document or an object, make `context` default to\n    // the model so users don't have to always pass `context`, re: gh-10132, gh-10346\n    context = obj;\n  }\n  if (typeof context === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.validate() no longer accepts a callback');\n  }\n\n  let schema = this.schema;\n  const discriminatorKey = schema.options.discriminatorKey;\n  if (schema.discriminators != null && obj != null && obj[discriminatorKey] != null) {\n    schema = getSchemaDiscriminatorByValue(schema, obj[discriminatorKey]) || schema;\n  }\n  let paths = Object.keys(schema.paths);\n\n  if (pathsOrOptions != null) {\n    const _pathsToValidate = typeof pathsOrOptions === 'string' ? new Set(pathsOrOptions.split(' ')) : Array.isArray(pathsOrOptions) ? new Set(pathsOrOptions) : new Set(paths);\n    paths = paths.filter(p => {\n      if (pathsOrOptions.pathsToSkip) {\n        if (Array.isArray(pathsOrOptions.pathsToSkip)) {\n          if (pathsOrOptions.pathsToSkip.find(x => x == p)) {\n            return false;\n          }\n        } else if (typeof pathsOrOptions.pathsToSkip == 'string') {\n          if (pathsOrOptions.pathsToSkip.includes(p)) {\n            return false;\n          }\n        }\n      }\n      const pieces = p.split('.');\n      let cur = pieces[0];\n\n      for (const piece of pieces) {\n        if (_pathsToValidate.has(cur)) {\n          return true;\n        }\n        cur += '.' + piece;\n      }\n\n      return _pathsToValidate.has(p);\n    });\n  }\n\n  for (const path of paths) {\n    const schemaType = schema.path(path);\n    if (!schemaType || !schemaType.$isMongooseArray || schemaType.$isMongooseDocumentArray) {\n      continue;\n    }\n\n    const val = get(obj, path);\n    pushNestedArrayPaths(paths, val, path);\n  }\n\n  let error = null;\n  paths = new Set(paths);\n\n  try {\n    obj = this.castObject(obj);\n  } catch (err) {\n    error = err;\n    for (const key of Object.keys(error.errors || {})) {\n      paths.delete(key);\n    }\n  }\n\n  let remaining = paths.size;\n\n  return new Promise((resolve, reject) => {\n    for (const path of paths) {\n      const schemaType = schema.path(path);\n      if (schemaType == null) {\n        _checkDone();\n        continue;\n      }\n\n      const pieces = path.indexOf('.') === -1 ? [path] : path.split('.');\n      let cur = obj;\n      for (let i = 0; i < pieces.length - 1; ++i) {\n        cur = cur[pieces[i]];\n      }\n\n      const val = get(obj, path, void 0);\n\n      schemaType.doValidate(val, err => {\n        if (err) {\n          error = error || new ValidationError();\n          error.addError(path, err);\n        }\n        _checkDone();\n      }, context, { path: path });\n    }\n\n    function _checkDone() {\n      if (--remaining <= 0) {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(obj);\n        }\n      }\n    }\n  });\n};\n\n/**\n * Populates document references.\n *\n * Changed in Mongoose 6: the model you call `populate()` on should be the\n * \"local field\" model, **not** the \"foreign field\" model.\n *\n * #### Available top-level options:\n *\n * - path: space delimited path(s) to populate\n * - select: optional fields to select\n * - match: optional query conditions to match\n * - model: optional name of the model to use for population\n * - options: optional query options like sort, limit, etc\n * - justOne: optional boolean, if true Mongoose will always set `path` to a document, or `null` if no document was found. If false, Mongoose will always set `path` to an array, which will be empty if no documents are found. Inferred from schema by default.\n * - strictPopulate: optional boolean, set to `false` to allow populating paths that aren't in the schema.\n *\n * #### Example:\n *\n *     const Dog = mongoose.model('Dog', new Schema({ name: String, breed: String }));\n *     const Person = mongoose.model('Person', new Schema({\n *       name: String,\n *       pet: { type: mongoose.ObjectId, ref: 'Dog' }\n *     }));\n *\n *     const pets = await Pet.create([\n *       { name: 'Daisy', breed: 'Beagle' },\n *       { name: 'Einstein', breed: 'Catalan Sheepdog' }\n *     ]);\n *\n *     // populate many plain objects\n *     const users = [\n *       { name: 'John Wick', dog: pets[0]._id },\n *       { name: 'Doc Brown', dog: pets[1]._id }\n *     ];\n *     await User.populate(users, { path: 'dog', select: 'name' });\n *     users[0].dog.name; // 'Daisy'\n *     users[0].dog.breed; // undefined because of `select`\n *\n * @param {Document|Array} docs Either a single document or array of documents to populate.\n * @param {Object|String} options Either the paths to populate or an object specifying all parameters\n * @param {string} [options.path=null] The path to populate.\n * @param {string|PopulateOptions} [options.populate=null] Recursively populate paths in the populated documents. See [deep populate docs](https://mongoosejs.com/docs/populate.html#deep-populate).\n * @param {boolean} [options.retainNullValues=false] By default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.\n * @param {boolean} [options.getters=false] If true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](https://mongoosejs.com/docs/schematypes.html#schematype-options).\n * @param {boolean} [options.clone=false] When you do `BlogPost.find().populate('author')`, blog posts with the same author will share 1 copy of an `author` doc. Enable this option to make Mongoose clone populated docs before assigning them.\n * @param {Object|Function} [options.match=null] Add an additional filter to the populate query. Can be a filter object containing [MongoDB query syntax](https://www.mongodb.com/docs/manual/tutorial/query-documents/), or a function that returns a filter object.\n * @param {Boolean} [options.skipInvalidIds=false] By default, Mongoose throws a cast error if `localField` and `foreignField` schemas don't line up. If you enable this option, Mongoose will instead filter out any `localField` properties that cannot be casted to `foreignField`'s schema type.\n * @param {Number} [options.perDocumentLimit=null] For legacy reasons, `limit` with `populate()` may give incorrect results because it only executes a single query for every document being populated. If you set `perDocumentLimit`, Mongoose will ensure correct `limit` per document by executing a separate query for each document to `populate()`. For example, `.find().populate({ path: 'test', perDocumentLimit: 2 })` will execute 2 additional queries if `.find()` returns 2 documents.\n * @param {Boolean} [options.strictPopulate=true] Set to false to allow populating paths that aren't defined in the given model's schema.\n * @param {Object} [options.options=null] Additional options like `limit` and `lean`.\n * @param {Function} [options.transform=null] Function that Mongoose will call on every populated document that allows you to transform the populated document.\n * @param {Function} [callback(err,doc)] Optional callback, executed upon completion. Receives `err` and the `doc(s)`.\n * @return {Promise}\n * @api public\n */\n\nModel.populate = async function populate(docs, paths) {\n  _checkContext(this, 'populate');\n  if (typeof paths === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.populate() no longer accepts a callback');\n  }\n  const _this = this;\n  // normalized paths\n  paths = utils.populate(paths);\n  // data that should persist across subPopulate calls\n  const cache = {};\n\n  return new Promise((resolve, reject) => {\n    _populate(_this, docs, paths, cache, (err, res) => {\n      if (err) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n};\n\n/**\n * Populate helper\n *\n * @param {Model} model the model to use\n * @param {Document|Array} docs Either a single document or array of documents to populate.\n * @param {Object} paths\n * @param {never} cache Unused\n * @param {Function} [callback] Optional callback, executed upon completion. Receives `err` and the `doc(s)`.\n * @return {Function}\n * @api private\n */\n\nfunction _populate(model, docs, paths, cache, callback) {\n  let pending = paths.length;\n  if (paths.length === 0) {\n    return callback(null, docs);\n  }\n  // each path has its own query options and must be executed separately\n  for (const path of paths) {\n    populate(model, docs, path, next);\n  }\n\n  function next(err) {\n    if (err) {\n      return callback(err, null);\n    }\n    if (--pending) {\n      return;\n    }\n    callback(null, docs);\n  }\n}\n\n/*!\n * Populates `docs`\n */\nconst excludeIdReg = /\\s?-_id\\s?/;\nconst excludeIdRegGlobal = /\\s?-_id\\s?/g;\n\nfunction populate(model, docs, options, callback) {\n  const populateOptions = options;\n  if (options.strictPopulate == null) {\n    if (options._localModel != null && options._localModel.schema._userProvidedOptions.strictPopulate != null) {\n      populateOptions.strictPopulate = options._localModel.schema._userProvidedOptions.strictPopulate;\n    } else if (options._localModel != null && model.base.options.strictPopulate != null) {\n      populateOptions.strictPopulate = model.base.options.strictPopulate;\n    } else if (model.base.options.strictPopulate != null) {\n      populateOptions.strictPopulate = model.base.options.strictPopulate;\n    }\n  }\n\n  // normalize single / multiple docs passed\n  if (!Array.isArray(docs)) {\n    docs = [docs];\n  }\n  if (docs.length === 0 || docs.every(utils.isNullOrUndefined)) {\n    return callback();\n  }\n\n  const modelsMap = getModelsMapForPopulate(model, docs, populateOptions);\n\n  if (modelsMap instanceof MongooseError) {\n    return immediate(function() {\n      callback(modelsMap);\n    });\n  }\n  const len = modelsMap.length;\n  let vals = [];\n\n  function flatten(item) {\n    // no need to include undefined values in our query\n    return undefined !== item;\n  }\n\n  let _remaining = len;\n  let hasOne = false;\n  const params = [];\n  for (let i = 0; i < len; ++i) {\n    const mod = modelsMap[i];\n    let select = mod.options.select;\n    let ids = utils.array.flatten(mod.ids, flatten);\n    ids = utils.array.unique(ids);\n\n    const assignmentOpts = {};\n    assignmentOpts.sort = mod &&\n      mod.options &&\n      mod.options.options &&\n      mod.options.options.sort || void 0;\n    assignmentOpts.excludeId = excludeIdReg.test(select) || (select && select._id === 0);\n\n    // Lean transform may delete `_id`, which would cause assignment\n    // to fail. So delay running lean transform until _after_\n    // `_assign()`\n    if (mod.options &&\n        mod.options.options &&\n        mod.options.options.lean &&\n        mod.options.options.lean.transform) {\n      mod.options.options._leanTransform = mod.options.options.lean.transform;\n      mod.options.options.lean = true;\n    }\n\n    if (ids.length === 0 || ids.every(utils.isNullOrUndefined)) {\n      // Ensure that we set to 0 or empty array even\n      // if we don't actually execute a query to make sure there's a value\n      // and we know this path was populated for future sets. See gh-7731, gh-8230\n      --_remaining;\n      _assign(model, [], mod, assignmentOpts);\n      continue;\n    }\n\n    hasOne = true;\n    if (typeof populateOptions.foreignField === 'string') {\n      mod.foreignField.clear();\n      mod.foreignField.add(populateOptions.foreignField);\n    }\n    const match = createPopulateQueryFilter(ids, mod.match, mod.foreignField, mod.model, mod.options.skipInvalidIds);\n    if (assignmentOpts.excludeId) {\n      // override the exclusion from the query so we can use the _id\n      // for document matching during assignment. we'll delete the\n      // _id back off before returning the result.\n      if (typeof select === 'string') {\n        select = select.replace(excludeIdRegGlobal, ' ');\n      } else if (Array.isArray(select)) {\n        select = select.filter(field => field !== '-_id');\n      } else {\n        // preserve original select conditions by copying\n        select = { ...select };\n        delete select._id;\n      }\n    }\n\n    if (mod.options.options && mod.options.options.limit != null) {\n      assignmentOpts.originalLimit = mod.options.options.limit;\n    } else if (mod.options.limit != null) {\n      assignmentOpts.originalLimit = mod.options.limit;\n    }\n    params.push([mod, match, select, assignmentOpts, _next]);\n  }\n  if (!hasOne) {\n    // If models but no docs, skip further deep populate.\n    if (modelsMap.length !== 0) {\n      return callback();\n    }\n    // If no models to populate but we have a nested populate,\n    // keep trying, re: gh-8946\n    if (populateOptions.populate != null) {\n      const opts = utils.populate(populateOptions.populate).map(pop => Object.assign({}, pop, {\n        path: populateOptions.path + '.' + pop.path\n      }));\n      model.populate(docs, opts).then(res => { callback(null, res); }, err => { callback(err); });\n      return;\n    }\n    return callback();\n  }\n\n  for (const arr of params) {\n    _execPopulateQuery.apply(null, arr);\n  }\n  function _next(err, valsFromDb) {\n    if (err != null) {\n      return callback(err, null);\n    }\n    vals = vals.concat(valsFromDb);\n    if (--_remaining === 0) {\n      _done();\n    }\n  }\n\n  function _done() {\n    for (const arr of params) {\n      const mod = arr[0];\n      const assignmentOpts = arr[3];\n      for (const val of vals) {\n        mod.options._childDocs.push(val);\n      }\n      try {\n        _assign(model, vals, mod, assignmentOpts);\n      } catch (err) {\n        return callback(err);\n      }\n    }\n\n    for (const arr of params) {\n      removeDeselectedForeignField(arr[0].foreignField, arr[0].options, vals);\n    }\n    for (const arr of params) {\n      const mod = arr[0];\n      if (mod.options && mod.options.options && mod.options.options._leanTransform) {\n        for (const doc of vals) {\n          mod.options.options._leanTransform(doc);\n        }\n      }\n    }\n    callback();\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _execPopulateQuery(mod, match, select, assignmentOpts, callback) {\n  let subPopulate = clone(mod.options.populate);\n  const queryOptions = Object.assign({\n    skip: mod.options.skip,\n    limit: mod.options.limit,\n    perDocumentLimit: mod.options.perDocumentLimit\n  }, mod.options.options);\n\n  if (mod.count) {\n    delete queryOptions.skip;\n  }\n\n  if (queryOptions.perDocumentLimit != null) {\n    queryOptions.limit = queryOptions.perDocumentLimit;\n    delete queryOptions.perDocumentLimit;\n  } else if (queryOptions.limit != null) {\n    queryOptions.limit = queryOptions.limit * mod.ids.length;\n  }\n\n  const query = mod.model.find(match, select, queryOptions);\n  // If we're doing virtual populate and projection is inclusive and foreign\n  // field is not selected, automatically select it because mongoose needs it.\n  // If projection is exclusive and client explicitly unselected the foreign\n  // field, that's the client's fault.\n  for (const foreignField of mod.foreignField) {\n    if (foreignField !== '_id' &&\n        query.selectedInclusively() &&\n        !isPathSelectedInclusive(query._fields, foreignField)) {\n      query.select(foreignField);\n    }\n  }\n\n  // If using count, still need the `foreignField` so we can match counts\n  // to documents, otherwise we would need a separate `count()` for every doc.\n  if (mod.count) {\n    for (const foreignField of mod.foreignField) {\n      query.select(foreignField);\n    }\n  }\n\n  // If we need to sub-populate, call populate recursively\n  if (subPopulate) {\n    // If subpopulating on a discriminator, skip check for non-existent\n    // paths. Because the discriminator may not have the path defined.\n    if (mod.model.baseModelName != null) {\n      if (Array.isArray(subPopulate)) {\n        subPopulate.forEach(pop => { pop.strictPopulate = false; });\n      } else if (typeof subPopulate === 'string') {\n        subPopulate = { path: subPopulate, strictPopulate: false };\n      } else {\n        subPopulate.strictPopulate = false;\n      }\n    }\n    const basePath = mod.options._fullPath || mod.options.path;\n\n    if (Array.isArray(subPopulate)) {\n      for (const pop of subPopulate) {\n        pop._fullPath = basePath + '.' + pop.path;\n      }\n    } else if (typeof subPopulate === 'object') {\n      subPopulate._fullPath = basePath + '.' + subPopulate.path;\n    }\n\n    query.populate(subPopulate);\n  }\n\n  query.exec().then(\n    docs => {\n      for (const val of docs) {\n        leanPopulateMap.set(val, mod.model);\n      }\n      callback(null, docs);\n    },\n    err => {\n      callback(err);\n    }\n  );\n}\n\n/*!\n * ignore\n */\n\nfunction _assign(model, vals, mod, assignmentOpts) {\n  const options = mod.options;\n  const isVirtual = mod.isVirtual;\n  const justOne = mod.justOne;\n  let _val;\n  const lean = options &&\n    options.options &&\n    options.options.lean || false;\n  const len = vals.length;\n  const rawOrder = {};\n  const rawDocs = {};\n  let key;\n  let val;\n\n  // Clone because `assignRawDocsToIdStructure` will mutate the array\n  const allIds = clone(mod.allIds);\n  // optimization:\n  // record the document positions as returned by\n  // the query result.\n  for (let i = 0; i < len; i++) {\n    val = vals[i];\n    if (val == null) {\n      continue;\n    }\n    for (const foreignField of mod.foreignField) {\n      _val = utils.getValue(foreignField, val);\n      if (Array.isArray(_val)) {\n        _val = utils.array.unique(utils.array.flatten(_val));\n\n        for (let __val of _val) {\n          if (__val instanceof Document) {\n            __val = __val._id;\n          }\n          key = String(__val);\n          if (rawDocs[key]) {\n            if (Array.isArray(rawDocs[key])) {\n              rawDocs[key].push(val);\n              rawOrder[key].push(i);\n            } else {\n              rawDocs[key] = [rawDocs[key], val];\n              rawOrder[key] = [rawOrder[key], i];\n            }\n          } else {\n            if (isVirtual && !justOne) {\n              rawDocs[key] = [val];\n              rawOrder[key] = [i];\n            } else {\n              rawDocs[key] = val;\n              rawOrder[key] = i;\n            }\n          }\n        }\n      } else {\n        if (_val instanceof Document) {\n          _val = _val._id;\n        }\n        key = String(_val);\n        if (rawDocs[key]) {\n          if (Array.isArray(rawDocs[key])) {\n            rawDocs[key].push(val);\n            rawOrder[key].push(i);\n          } else if (isVirtual ||\n            rawDocs[key].constructor !== val.constructor ||\n            String(rawDocs[key]._id) !== String(val._id)) {\n            // May need to store multiple docs with the same id if there's multiple models\n            // if we have discriminators or a ref function. But avoid converting to an array\n            // if we have multiple queries on the same model because of `perDocumentLimit` re: gh-9906\n            rawDocs[key] = [rawDocs[key], val];\n            rawOrder[key] = [rawOrder[key], i];\n          }\n        } else {\n          rawDocs[key] = val;\n          rawOrder[key] = i;\n        }\n      }\n      // flag each as result of population\n      if (!lean) {\n        val.$__.wasPopulated = val.$__.wasPopulated || { value: _val };\n      }\n    }\n  }\n\n  assignVals({\n    originalModel: model,\n    // If virtual, make sure to not mutate original field\n    rawIds: mod.isVirtual ? allIds : mod.allIds,\n    allIds: allIds,\n    unpopulatedValues: mod.unpopulatedValues,\n    foreignField: mod.foreignField,\n    rawDocs: rawDocs,\n    rawOrder: rawOrder,\n    docs: mod.docs,\n    path: options.path,\n    options: assignmentOpts,\n    justOne: mod.justOne,\n    isVirtual: mod.isVirtual,\n    allOptions: mod,\n    populatedModel: mod.model,\n    lean: lean,\n    virtual: mod.virtual,\n    count: mod.count,\n    match: mod.match\n  });\n}\n\n/**\n * Compiler utility.\n *\n * @param {String|Function} name model name or class extending Model\n * @param {Schema} schema\n * @param {String} collectionName\n * @param {Connection} connection\n * @param {Mongoose} base mongoose instance\n * @api private\n */\n\nModel.compile = function compile(name, schema, collectionName, connection, base) {\n  const versioningEnabled = schema.options.versionKey !== false;\n\n  if (versioningEnabled && !schema.paths[schema.options.versionKey]) {\n    // add versioning to top level documents only\n    const o = {};\n    o[schema.options.versionKey] = Number;\n    schema.add(o);\n  }\n  let model;\n  if (typeof name === 'function' && name.prototype instanceof Model) {\n    model = name;\n    name = model.name;\n    schema.loadClass(model, false);\n    model.prototype.$isMongooseModelPrototype = true;\n  } else {\n    // generate new class\n    model = function model(doc, fields, skipId) {\n      model.hooks.execPreSync('createModel', doc);\n      if (!(this instanceof model)) {\n        return new model(doc, fields, skipId);\n      }\n      const discriminatorKey = model.schema.options.discriminatorKey;\n\n      if (model.discriminators == null || doc == null || doc[discriminatorKey] == null) {\n        Model.call(this, doc, fields, skipId);\n        return;\n      }\n\n      // If discriminator key is set, use the discriminator instead (gh-7586)\n      const Discriminator = model.discriminators[doc[discriminatorKey]] ||\n        getDiscriminatorByValue(model.discriminators, doc[discriminatorKey]);\n      if (Discriminator != null) {\n        return new Discriminator(doc, fields, skipId);\n      }\n\n      // Otherwise, just use the top-level model\n      Model.call(this, doc, fields, skipId);\n    };\n  }\n\n  model.hooks = schema.s.hooks.clone();\n  model.base = base;\n  model.modelName = name;\n\n  if (!(model.prototype instanceof Model)) {\n    Object.setPrototypeOf(model, Model);\n    Object.setPrototypeOf(model.prototype, Model.prototype);\n  }\n  model.model = function model(name) {\n    return this.db.model(name);\n  };\n\n  model.db = connection;\n  model.prototype.db = connection;\n  model.prototype[modelDbSymbol] = connection;\n  model.discriminators = model.prototype.discriminators = undefined;\n  model[modelSymbol] = true;\n  model.events = new EventEmitter();\n\n  schema._preCompile();\n\n  const _userProvidedOptions = schema._userProvidedOptions || {};\n\n  const collectionOptions = {\n    schemaUserProvidedOptions: _userProvidedOptions,\n    capped: schema.options.capped,\n    Promise: model.base.Promise,\n    modelName: name\n  };\n  if (schema.options.autoCreate !== void 0) {\n    collectionOptions.autoCreate = schema.options.autoCreate;\n  }\n\n  const collection = connection.collection(\n    collectionName,\n    collectionOptions\n  );\n\n  model.prototype.collection = collection;\n  model.prototype.$collection = collection;\n  model.prototype[modelCollectionSymbol] = collection;\n\n  model.prototype.$__setSchema(schema);\n\n  // apply methods and statics\n  applyMethods(model, schema);\n  applyStatics(model, schema);\n  applyHooks(model, schema);\n  applyStaticHooks(model, schema.s.hooks, schema.statics);\n\n  model.schema = model.prototype.$__schema;\n  model.collection = collection;\n  model.$__collection = collection;\n\n  // Create custom query constructor\n  model.Query = function() {\n    Query.apply(this, arguments);\n  };\n  Object.setPrototypeOf(model.Query.prototype, Query.prototype);\n  model.Query.base = Query.base;\n  model.Query.prototype.constructor = Query;\n  model._applyQueryMiddleware();\n  applyQueryMethods(model, schema.query);\n\n  return model;\n};\n\n/**\n * Update this model to use the new connection, including updating all internal\n * references and creating a new `Collection` instance using the new connection.\n * Not for external use, only used by `setDriver()` to ensure that you can still\n * call `setDriver()` after creating a model using `mongoose.model()`.\n *\n * @param {Connection} newConnection the new connection to use\n * @api private\n */\n\nModel.$__updateConnection = function $__updateConnection(newConnection) {\n  this.db = newConnection;\n  this.prototype.db = newConnection;\n  this.prototype[modelDbSymbol] = newConnection;\n\n  const collection = newConnection.collection(\n    this.collection.collectionName,\n    this.collection.opts\n  );\n\n  this.prototype.collection = collection;\n  this.prototype.$collection = collection;\n  this.prototype[modelCollectionSymbol] = collection;\n\n  this.collection = collection;\n  this.$__collection = collection;\n};\n\n/**\n * Register custom query methods for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n * @api private\n */\n\nfunction applyQueryMethods(model, methods) {\n  for (const i in methods) {\n    model.Query.prototype[i] = methods[i];\n  }\n}\n\n/**\n * Subclass this model with `conn`, `schema`, and `collection` settings.\n *\n * @param {Connection} conn\n * @param {Schema} [schema]\n * @param {String} [collection]\n * @return {Model}\n * @api private\n * @memberOf Model\n * @static\n * @method __subclass\n */\n\nModel.__subclass = function subclass(conn, schema, collection) {\n  // subclass model using this connection and collection name\n  const _this = this;\n\n  const Model = function Model(doc, fields, skipId) {\n    if (!(this instanceof Model)) {\n      return new Model(doc, fields, skipId);\n    }\n    _this.call(this, doc, fields, skipId);\n  };\n\n  Object.setPrototypeOf(Model, _this);\n  Object.setPrototypeOf(Model.prototype, _this.prototype);\n  Model.db = conn;\n  Model.prototype.db = conn;\n  Model.prototype[modelDbSymbol] = conn;\n\n  _this[subclassedSymbol] = _this[subclassedSymbol] || [];\n  _this[subclassedSymbol].push(Model);\n  if (_this.discriminators != null) {\n    Model.discriminators = {};\n    for (const key of Object.keys(_this.discriminators)) {\n      Model.discriminators[key] = _this.discriminators[key].\n        __subclass(_this.db, _this.discriminators[key].schema, collection);\n    }\n  }\n\n  const s = schema && typeof schema !== 'string'\n    ? schema\n    : _this.prototype.$__schema;\n\n  const options = s.options || {};\n  const _userProvidedOptions = s._userProvidedOptions || {};\n\n  if (!collection) {\n    collection = _this.prototype.$__schema.get('collection') ||\n      utils.toCollectionName(_this.modelName, this.base.pluralize());\n  }\n\n  const collectionOptions = {\n    schemaUserProvidedOptions: _userProvidedOptions,\n    capped: s && options.capped\n  };\n\n  Model.prototype.collection = conn.collection(collection, collectionOptions);\n  Model.prototype.$collection = Model.prototype.collection;\n  Model.prototype[modelCollectionSymbol] = Model.prototype.collection;\n  Model.collection = Model.prototype.collection;\n  Model.$__collection = Model.collection;\n  // Errors handled internally, so ignore\n  Model.init().catch(() => {});\n  return Model;\n};\n\n/**\n * Apply changes made to this model's schema after this model was compiled.\n * By default, adding virtuals and other properties to a schema after the model is compiled does nothing.\n * Call this function to apply virtuals and properties that were added later.\n *\n * #### Example:\n *\n *     const schema = new mongoose.Schema({ field: String });\n *     const TestModel = mongoose.model('Test', schema);\n *     TestModel.schema.virtual('myVirtual').get(function() {\n *       return this.field + ' from myVirtual';\n *     });\n *     const doc = new TestModel({ field: 'Hello' });\n *     doc.myVirtual; // undefined\n *\n *     TestModel.recompileSchema();\n *     doc.myVirtual; // 'Hello from myVirtual'\n *\n * @return {undefined}\n * @api public\n * @memberOf Model\n * @static\n * @method recompileSchema\n */\n\nModel.recompileSchema = function recompileSchema() {\n  this.prototype.$__setSchema(this.schema);\n\n  if (this.schema._applyDiscriminators != null) {\n    for (const disc of this.schema._applyDiscriminators.keys()) {\n      this.discriminator(disc, this.schema._applyDiscriminators.get(disc));\n    }\n  }\n\n  applyEmbeddedDiscriminators(this.schema, new WeakSet(), true);\n};\n\n/**\n * Helper for console.log. Given a model named 'MyModel', returns the string\n * `'Model { MyModel }'`.\n *\n * #### Example:\n *\n *     const MyModel = mongoose.model('Test', Schema({ name: String }));\n *     MyModel.inspect(); // 'Model { Test }'\n *     console.log(MyModel); // Prints 'Model { Test }'\n *\n * @api public\n */\n\nModel.inspect = function() {\n  return `Model { ${this.modelName} }`;\n};\n\nif (util.inspect.custom) {\n  // Avoid Node deprecation warning DEP0079\n  Model[util.inspect.custom] = Model.inspect;\n}\n\n/*!\n * Applies query middleware from this model's schema to this model's\n * Query constructor.\n */\n\nModel._applyQueryMiddleware = function _applyQueryMiddleware() {\n  const Query = this.Query;\n  const queryMiddleware = this.schema.s.hooks.filter(hook => {\n    const contexts = _getContexts(hook);\n    if (hook.name === 'validate') {\n      return !!contexts.query;\n    }\n    if (hook.name === 'deleteOne' || hook.name === 'updateOne') {\n      return !!contexts.query || Object.keys(contexts).length === 0;\n    }\n    if (hook.query != null || hook.document != null) {\n      return !!hook.query;\n    }\n    return true;\n  });\n\n  Query.prototype._queryMiddleware = queryMiddleware;\n};\n\nfunction _getContexts(hook) {\n  const ret = {};\n  if (hook.hasOwnProperty('query')) {\n    ret.query = hook.query;\n  }\n  if (hook.hasOwnProperty('document')) {\n    ret.document = hook.document;\n  }\n  return ret;\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = Model;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL21vZGVsLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsbUJBQU8sQ0FBQyxzRUFBYTtBQUN2QyxxQkFBcUIsbUJBQU8sQ0FBQywwRkFBdUI7QUFDcEQsaUJBQWlCLG1CQUFPLENBQUMsb0VBQVk7QUFDckMsOEJBQThCLG1CQUFPLENBQUMsZ0ZBQWtCO0FBQ3hELDRCQUE0QixtQkFBTyxDQUFDLDRGQUF3QjtBQUM1RCxxQkFBcUIsMERBQThCO0FBQ25ELGVBQWUsbUJBQU8sQ0FBQyx1REFBUTtBQUMvQix1QkFBdUIsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDL0Msc0JBQXNCLG1CQUFPLENBQUMsMEVBQWU7QUFDN0MsNkJBQTZCLG1CQUFPLENBQUMsOEZBQXlCO0FBQzlELDRCQUE0QixtQkFBTyxDQUFDLDRGQUF3QjtBQUM1RCxjQUFjLG1CQUFPLENBQUMsOERBQVM7QUFDL0Isb0JBQW9CLG1CQUFPLENBQUMsMEZBQXVCO0FBQ25ELGVBQWUsbUJBQU8sQ0FBQyxnRUFBVTtBQUNqQyx3QkFBd0IsbUJBQU8sQ0FBQyxvRkFBb0I7QUFDcEQscUJBQXFCLG1CQUFPLENBQUMsOEVBQWlCO0FBQzlDLDBCQUEwQixtQkFBTyxDQUFDLHdGQUFzQjtBQUN4RCw0QkFBNEIsbUJBQU8sQ0FBQyxnSEFBa0M7QUFDdEUsNEJBQTRCLG1CQUFPLENBQUMsc0hBQXFDO0FBQ3pFLG9DQUFvQyxtQkFBTyxDQUFDLHNKQUFxRDtBQUNqRyxtQkFBbUIsbUJBQU8sQ0FBQyxvR0FBNEI7QUFDdkQscUJBQXFCLG1CQUFPLENBQUMsd0dBQThCO0FBQzNELHdCQUF3QixtQkFBTyxDQUFDLHdIQUFzQztBQUN0RSw2QkFBNkIsbUJBQU8sQ0FBQyw0SEFBd0M7QUFDN0UseUJBQXlCLG1CQUFPLENBQUMsZ0hBQWtDO0FBQ25FLHFCQUFxQixtQkFBTyxDQUFDLHdHQUE4QjtBQUMzRCwwQkFBMEIsbUJB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw2QkFBNkI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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Q0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGVBQWU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLG1DQUFtQyxnQkFBZ0I7QUFDbkQsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxjQUFjO0FBQ3JFLDBCQUEwQixZQUFZLE1BQU07QUFDNUMsNkJBQTZCLG1CQUFtQixNQUFNO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixFQUFFLGlCQUFpQjtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9tb2RlbC5qcz85N2RiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IEFnZ3JlZ2F0ZSA9IHJlcXVpcmUoJy4vYWdncmVnYXRlJyk7XG5jb25zdCBDaGFuZ2VTdHJlYW0gPSByZXF1aXJlKCcuL2N1cnNvci9jaGFuZ2VTdHJlYW0nKTtcbmNvbnN0IERvY3VtZW50ID0gcmVxdWlyZSgnLi9kb2N1bWVudCcpO1xuY29uc3QgRG9jdW1lbnROb3RGb3VuZEVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9ub3RGb3VuZCcpO1xuY29uc3QgRGl2ZXJnZW50QXJyYXlFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3IvZGl2ZXJnZW50QXJyYXknKTtcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbmNvbnN0IEthcmVlbSA9IHJlcXVpcmUoJ2thcmVlbScpO1xuY29uc3QgTW9uZ29vc2VCdWZmZXIgPSByZXF1aXJlKCcuL3R5cGVzL2J1ZmZlcicpO1xuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3IvaW5kZXgnKTtcbmNvbnN0IE9iamVjdFBhcmFtZXRlckVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9vYmplY3RQYXJhbWV0ZXInKTtcbmNvbnN0IE92ZXJ3cml0ZU1vZGVsRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL292ZXJ3cml0ZU1vZGVsJyk7XG5jb25zdCBRdWVyeSA9IHJlcXVpcmUoJy4vcXVlcnknKTtcbmNvbnN0IFNhdmVPcHRpb25zID0gcmVxdWlyZSgnLi9vcHRpb25zL3NhdmVPcHRpb25zJyk7XG5jb25zdCBTY2hlbWEgPSByZXF1aXJlKCcuL3NjaGVtYScpO1xuY29uc3QgVmFsaWRhdGlvbkVycm9yID0gcmVxdWlyZSgnLi9lcnJvci92YWxpZGF0aW9uJyk7XG5jb25zdCBWZXJzaW9uRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL3ZlcnNpb24nKTtcbmNvbnN0IFBhcmFsbGVsU2F2ZUVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9wYXJhbGxlbFNhdmUnKTtcbmNvbnN0IGFwcGx5RGVmYXVsdHNIZWxwZXIgPSByZXF1aXJlKCcuL2hlbHBlcnMvZG9jdW1lbnQvYXBwbHlEZWZhdWx0cycpO1xuY29uc3QgYXBwbHlEZWZhdWx0c1RvUE9KTyA9IHJlcXVpcmUoJy4vaGVscGVycy9tb2RlbC9hcHBseURlZmF1bHRzVG9QT0pPJyk7XG5jb25zdCBhcHBseUVtYmVkZGVkRGlzY3JpbWluYXRvcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMvZGlzY3JpbWluYXRvci9hcHBseUVtYmVkZGVkRGlzY3JpbWluYXRvcnMnKTtcbmNvbnN0IGFwcGx5SG9va3MgPSByZXF1aXJlKCcuL2hlbHBlcnMvbW9kZWwvYXBwbHlIb29rcycpO1xuY29uc3QgYXBwbHlNZXRob2RzID0gcmVxdWlyZSgnLi9oZWxwZXJzL21vZGVsL2FwcGx5TWV0aG9kcycpO1xuY29uc3QgYXBwbHlQcm9qZWN0aW9uID0gcmVxdWlyZSgnLi9oZWxwZXJzL3Byb2plY3Rpb24vYXBwbHlQcm9qZWN0aW9uJyk7XG5jb25zdCBhcHBseVNjaGVtYUNvbGxhdGlvbiA9IHJlcXVpcmUoJy4vaGVscGVycy9pbmRleGVzL2FwcGx5U2NoZW1hQ29sbGF0aW9uJyk7XG5jb25zdCBhcHBseVN0YXRpY0hvb2tzID0gcmVxdWlyZSgnLi9oZWxwZXJzL21vZGVsL2FwcGx5U3RhdGljSG9va3MnKTtcbmNvbnN0IGFwcGx5U3RhdGljcyA9IHJlcXVpcmUoJy4vaGVscGVycy9tb2RlbC9hcHBseVN0YXRpY3MnKTtcbmNvbnN0IGFwcGx5V3JpdGVDb25jZXJuID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NjaGVtYS9hcHBseVdyaXRlQ29uY2VybicpO1xuY29uc3QgYXNzaWduVmFscyA9IHJlcXVpcmUoJy4vaGVscGVycy9wb3B1bGF0ZS9hc3NpZ25WYWxzJyk7XG5jb25zdCBjYXN0QnVsa1dyaXRlID0gcmVxdWlyZSgnLi9oZWxwZXJzL21vZGVsL2Nhc3RCdWxrV3JpdGUnKTtcbmNvbnN0IGNsb25lID0gcmVxdWlyZSgnLi9oZWxwZXJzL2Nsb25lJyk7XG5jb25zdCBjcmVhdGVQb3B1bGF0ZVF1ZXJ5RmlsdGVyID0gcmVxdWlyZSgnLi9oZWxwZXJzL3BvcHVsYXRlL2NyZWF0ZVBvcHVsYXRlUXVlcnlGaWx0ZXInKTtcbmNvbnN0IGRlY29yYXRlVXBkYXRlV2l0aFZlcnNpb25LZXkgPSByZXF1aXJlKCcuL2hlbHBlcnMvdXBkYXRlL2RlY29yYXRlVXBkYXRlV2l0aFZlcnNpb25LZXknKTtcbmNvbnN0IGdldERlZmF1bHRCdWxrd3JpdGVSZXN1bHQgPSByZXF1aXJlKCcuL2hlbHBlcnMvZ2V0RGVmYXVsdEJ1bGt3cml0ZVJlc3VsdCcpO1xuY29uc3QgZ2V0U2NoZW1hRGlzY3JpbWluYXRvckJ5VmFsdWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvZGlzY3JpbWluYXRvci9nZXRTY2hlbWFEaXNjcmltaW5hdG9yQnlWYWx1ZScpO1xuY29uc3QgZGlzY3JpbWluYXRvciA9IHJlcXVpcmUoJy4vaGVscGVycy9tb2RlbC9kaXNjcmltaW5hdG9yJyk7XG5jb25zdCBmaXJzdEtleSA9IHJlcXVpcmUoJy4vaGVscGVycy9maXJzdEtleScpO1xuY29uc3QgZWFjaCA9IHJlcXVpcmUoJy4vaGVscGVycy9lYWNoJyk7XG5jb25zdCBnZXQgPSByZXF1aXJlKCcuL2hlbHBlcnMvZ2V0Jyk7XG5jb25zdCBnZXRDb25zdHJ1Y3Rvck5hbWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvZ2V0Q29uc3RydWN0b3JOYW1lJyk7XG5jb25zdCBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9kaXNjcmltaW5hdG9yL2dldERpc2NyaW1pbmF0b3JCeVZhbHVlJyk7XG5jb25zdCBnZXRNb2RlbHNNYXBGb3JQb3B1bGF0ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9wb3B1bGF0ZS9nZXRNb2RlbHNNYXBGb3JQb3B1bGF0ZScpO1xuY29uc3QgaW1tZWRpYXRlID0gcmVxdWlyZSgnLi9oZWxwZXJzL2ltbWVkaWF0ZScpO1xuY29uc3QgaW50ZXJuYWxUb09iamVjdE9wdGlvbnMgPSByZXF1aXJlKCcuL29wdGlvbnMnKS5pbnRlcm5hbFRvT2JqZWN0T3B0aW9ucztcbmNvbnN0IGlzRGVmYXVsdElkSW5kZXggPSByZXF1aXJlKCcuL2hlbHBlcnMvaW5kZXhlcy9pc0RlZmF1bHRJZEluZGV4Jyk7XG5jb25zdCBpc0luZGV4RXF1YWwgPSByZXF1aXJlKCcuL2hlbHBlcnMvaW5kZXhlcy9pc0luZGV4RXF1YWwnKTtcbmNvbnN0IHtcbiAgZ2V0UmVsYXRlZERCSW5kZXhlcyxcbiAgZ2V0UmVsYXRlZFNjaGVtYUluZGV4ZXNcbn0gPSByZXF1aXJlKCcuL2hlbHBlcnMvaW5kZXhlcy9nZXRSZWxhdGVkSW5kZXhlcycpO1xuY29uc3QgaXNQYXRoRXhjbHVkZWQgPSByZXF1aXJlKCcuL2hlbHBlcnMvcHJvamVjdGlvbi9pc1BhdGhFeGNsdWRlZCcpO1xuY29uc3QgZGVjb3JhdGVEaXNjcmltaW5hdG9ySW5kZXhPcHRpb25zID0gcmVxdWlyZSgnLi9oZWxwZXJzL2luZGV4ZXMvZGVjb3JhdGVEaXNjcmltaW5hdG9ySW5kZXhPcHRpb25zJyk7XG5jb25zdCBpc1BhdGhTZWxlY3RlZEluY2x1c2l2ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9wcm9qZWN0aW9uL2lzUGF0aFNlbGVjdGVkSW5jbHVzaXZlJyk7XG5jb25zdCBsZWFuUG9wdWxhdGVNYXAgPSByZXF1aXJlKCcuL2hlbHBlcnMvcG9wdWxhdGUvbGVhblBvcHVsYXRlTWFwJyk7XG5jb25zdCBwYXJhbGxlbExpbWl0ID0gcmVxdWlyZSgnLi9oZWxwZXJzL3BhcmFsbGVsTGltaXQnKTtcbmNvbnN0IHBhcmVudFBhdGhzID0gcmVxdWlyZSgnLi9oZWxwZXJzL3BhdGgvcGFyZW50UGF0aHMnKTtcbmNvbnN0IHByZXBhcmVEaXNjcmltaW5hdG9yUGlwZWxpbmUgPSByZXF1aXJlKCcuL2hlbHBlcnMvYWdncmVnYXRlL3ByZXBhcmVEaXNjcmltaW5hdG9yUGlwZWxpbmUnKTtcbmNvbnN0IHB1c2hOZXN0ZWRBcnJheVBhdGhzID0gcmVxdWlyZSgnLi9oZWxwZXJzL21vZGVsL3B1c2hOZXN0ZWRBcnJheVBhdGhzJyk7XG5jb25zdCByZW1vdmVEZXNlbGVjdGVkRm9yZWlnbkZpZWxkID0gcmVxdWlyZSgnLi9oZWxwZXJzL3BvcHVsYXRlL3JlbW92ZURlc2VsZWN0ZWRGb3JlaWduRmllbGQnKTtcbmNvbnN0IHNldERvdHRlZFBhdGggPSByZXF1aXJlKCcuL2hlbHBlcnMvcGF0aC9zZXREb3R0ZWRQYXRoJyk7XG5jb25zdCBTVEFURVMgPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb25TdGF0ZScpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuY29uc3QgTW9uZ29vc2VCdWxrV3JpdGVFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3IvYnVsa1dyaXRlRXJyb3InKTtcbmNvbnN0IG1pbmltaXplID0gcmVxdWlyZSgnLi9oZWxwZXJzL21pbmltaXplJyk7XG5cbmNvbnN0IFZFUlNJT05fV0hFUkUgPSAxO1xuY29uc3QgVkVSU0lPTl9JTkMgPSAyO1xuY29uc3QgVkVSU0lPTl9BTEwgPSBWRVJTSU9OX1dIRVJFIHwgVkVSU0lPTl9JTkM7XG5cbmNvbnN0IGFycmF5QXRvbWljc1N5bWJvbCA9IHJlcXVpcmUoJy4vaGVscGVycy9zeW1ib2xzJykuYXJyYXlBdG9taWNzU3ltYm9sO1xuY29uc3QgbW9kZWxDb2xsZWN0aW9uU3ltYm9sID0gU3ltYm9sKCdtb25nb29zZSNNb2RlbCNjb2xsZWN0aW9uJyk7XG5jb25zdCBtb2RlbERiU3ltYm9sID0gU3ltYm9sKCdtb25nb29zZSNNb2RlbCNkYicpO1xuY29uc3QgbW9kZWxTeW1ib2wgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ltYm9scycpLm1vZGVsU3ltYm9sO1xuY29uc3Qgc3ViY2xhc3NlZFN5bWJvbCA9IFN5bWJvbCgnbW9uZ29vc2UjTW9kZWwjc3ViY2xhc3NlZCcpO1xuXG5jb25zdCBzYXZlVG9PYmplY3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgaW50ZXJuYWxUb09iamVjdE9wdGlvbnMsIHtcbiAgYnNvbjogdHJ1ZSxcbiAgZmxhdHRlbk9iamVjdElkczogZmFsc2Vcbn0pO1xuXG4vKipcbiAqIEEgTW9kZWwgaXMgYSBjbGFzcyB0aGF0J3MgeW91ciBwcmltYXJ5IHRvb2wgZm9yIGludGVyYWN0aW5nIHdpdGggTW9uZ29EQi5cbiAqIEFuIGluc3RhbmNlIG9mIGEgTW9kZWwgaXMgY2FsbGVkIGEgW0RvY3VtZW50XShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQpLlxuICpcbiAqIEluIE1vbmdvb3NlLCB0aGUgdGVybSBcIk1vZGVsXCIgcmVmZXJzIHRvIHN1YmNsYXNzZXMgb2YgdGhlIGBtb25nb29zZS5Nb2RlbGBcbiAqIGNsYXNzLiBZb3Ugc2hvdWxkIG5vdCB1c2UgdGhlIGBtb25nb29zZS5Nb2RlbGAgY2xhc3MgZGlyZWN0bHkuIFRoZVxuICogW2Btb25nb29zZS5tb2RlbCgpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb25nb29zZS5odG1sI01vbmdvb3NlLnByb3RvdHlwZS5tb2RlbCgpKSBhbmRcbiAqIFtgY29ubmVjdGlvbi5tb2RlbCgpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9jb25uZWN0aW9uLmh0bWwjQ29ubmVjdGlvbi5wcm90b3R5cGUubW9kZWwoKSkgZnVuY3Rpb25zXG4gKiBjcmVhdGUgc3ViY2xhc3NlcyBvZiBgbW9uZ29vc2UuTW9kZWxgIGFzIHNob3duIGJlbG93LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gYFVzZXJNb2RlbGAgaXMgYSBcIk1vZGVsXCIsIGEgc3ViY2xhc3Mgb2YgYG1vbmdvb3NlLk1vZGVsYC5cbiAqICAgICBjb25zdCBVc2VyTW9kZWwgPSBtb25nb29zZS5tb2RlbCgnVXNlcicsIG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSkpO1xuICpcbiAqICAgICAvLyBZb3UgY2FuIHVzZSBhIE1vZGVsIHRvIGNyZWF0ZSBuZXcgZG9jdW1lbnRzIHVzaW5nIGBuZXdgOlxuICogICAgIGNvbnN0IHVzZXJEb2MgPSBuZXcgVXNlck1vZGVsKHsgbmFtZTogJ0ZvbycgfSk7XG4gKiAgICAgYXdhaXQgdXNlckRvYy5zYXZlKCk7XG4gKlxuICogICAgIC8vIFlvdSBhbHNvIHVzZSBhIG1vZGVsIHRvIGNyZWF0ZSBxdWVyaWVzOlxuICogICAgIGNvbnN0IHVzZXJGcm9tRGIgPSBhd2FpdCBVc2VyTW9kZWwuZmluZE9uZSh7IG5hbWU6ICdGb28nIH0pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2MgdmFsdWVzIGZvciBpbml0aWFsIHNldFxuICogQHBhcmFtIHtPYmplY3R9IFtmaWVsZHNdIG9wdGlvbmFsIG9iamVjdCBjb250YWluaW5nIHRoZSBmaWVsZHMgdGhhdCB3ZXJlIHNlbGVjdGVkIGluIHRoZSBxdWVyeSB3aGljaCByZXR1cm5lZCB0aGlzIGRvY3VtZW50LiBZb3UgZG8gKipub3QqKiBuZWVkIHRvIHNldCB0aGlzIHBhcmFtZXRlciB0byBlbnN1cmUgTW9uZ29vc2UgaGFuZGxlcyB5b3VyIFtxdWVyeSBwcm9qZWN0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNlbGVjdCgpKS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NraXBJZD1mYWxzZV0gb3B0aW9uYWwgYm9vbGVhbi4gSWYgdHJ1ZSwgbW9uZ29vc2UgZG9lc24ndCBhZGQgYW4gYF9pZGAgZmllbGQgdG8gdGhlIGRvY3VtZW50LlxuICogQGluaGVyaXRzIERvY3VtZW50IGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbFxuICogQGV2ZW50IGBlcnJvcmA6IElmIGxpc3RlbmluZyB0byB0aGlzIGV2ZW50LCAnZXJyb3InIGlzIGVtaXR0ZWQgd2hlbiBhIGRvY3VtZW50IHdhcyBzYXZlZCBhbmQgYW4gYGVycm9yYCBvY2N1cnJlZC4gSWYgbm90IGxpc3RlbmluZywgdGhlIGV2ZW50IGJ1YmJsZXMgdG8gdGhlIGNvbm5lY3Rpb24gdXNlZCB0byBjcmVhdGUgdGhpcyBNb2RlbC5cbiAqIEBldmVudCBgaW5kZXhgOiBFbWl0dGVkIGFmdGVyIGBNb2RlbCNlbnN1cmVJbmRleGVzYCBjb21wbGV0ZXMuIElmIGFuIGVycm9yIG9jY3VycmVkIGl0IGlzIHBhc3NlZCB3aXRoIHRoZSBldmVudC5cbiAqIEBldmVudCBgaW5kZXgtc2luZ2xlLXN0YXJ0YDogRW1pdHRlZCB3aGVuIGFuIGluZGl2aWR1YWwgaW5kZXggc3RhcnRzIHdpdGhpbiBgTW9kZWwjZW5zdXJlSW5kZXhlc2AuIFRoZSBmaWVsZHMgYW5kIG9wdGlvbnMgYmVpbmcgdXNlZCB0byBidWlsZCB0aGUgaW5kZXggYXJlIGFsc28gcGFzc2VkIHdpdGggdGhlIGV2ZW50LlxuICogQGV2ZW50IGBpbmRleC1zaW5nbGUtZG9uZWA6IEVtaXR0ZWQgd2hlbiBhbiBpbmRpdmlkdWFsIGluZGV4IGZpbmlzaGVzIHdpdGhpbiBgTW9kZWwjZW5zdXJlSW5kZXhlc2AuIElmIGFuIGVycm9yIG9jY3VycmVkIGl0IGlzIHBhc3NlZCB3aXRoIHRoZSBldmVudC4gVGhlIGZpZWxkcywgb3B0aW9ucywgYW5kIGluZGV4IG5hbWUgYXJlIGFsc28gcGFzc2VkLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBNb2RlbChkb2MsIGZpZWxkcywgc2tpcElkKSB7XG4gIGlmIChmaWVsZHMgaW5zdGFuY2VvZiBTY2hlbWEpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcybmQgYXJndW1lbnQgdG8gYE1vZGVsYCBjb25zdHJ1Y3RvciBtdXN0IGJlIGEgUE9KTyBvciBzdHJpbmcsICcgK1xuICAgICAgJyoqbm90KiogYSBzY2hlbWEuIE1ha2Ugc3VyZSB5b3VcXCdyZSBjYWxsaW5nIGBtb25nb29zZS5tb2RlbCgpYCwgbm90ICcgK1xuICAgICAgJ2Btb25nb29zZS5Nb2RlbCgpYC4nKTtcbiAgfVxuICBpZiAodHlwZW9mIGRvYyA9PT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCB0byBgTW9kZWxgIGNvbnN0cnVjdG9yIG11c3QgYmUgYW4gb2JqZWN0LCAnICtcbiAgICAgICcqKm5vdCoqIGEgc3RyaW5nLiBNYWtlIHN1cmUgeW91XFwncmUgY2FsbGluZyBgbW9uZ29vc2UubW9kZWwoKWAsIG5vdCAnICtcbiAgICAgICdgbW9uZ29vc2UuTW9kZWwoKWAuJyk7XG4gIH1cbiAgRG9jdW1lbnQuY2FsbCh0aGlzLCBkb2MsIGZpZWxkcywgc2tpcElkKTtcbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIERvY3VtZW50LlxuICpcbiAqIEFsbCBNb2RlbC5wcm90b3R5cGUgZmVhdHVyZXMgYXJlIGF2YWlsYWJsZSBvblxuICogdG9wIGxldmVsIChub24tc3ViKSBkb2N1bWVudHMuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoTW9kZWwucHJvdG90eXBlLCBEb2N1bWVudC5wcm90b3R5cGUpO1xuTW9kZWwucHJvdG90eXBlLiRpc01vbmdvb3NlTW9kZWxQcm90b3R5cGUgPSB0cnVlO1xuXG4vKipcbiAqIENvbm5lY3Rpb24gdGhlIG1vZGVsIHVzZXMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBkYlxuICogQG1lbWJlck9mIE1vZGVsXG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Nb2RlbC5wcm90b3R5cGUuZGI7XG5cbi8qKlxuICogVGhlIGNvbGxlY3Rpb24gaW5zdGFuY2UgdGhpcyBtb2RlbCB1c2VzLlxuICogQSBNb25nb29zZSBjb2xsZWN0aW9uIGlzIGEgdGhpbiB3cmFwcGVyIGFyb3VuZCBhIFtNb25nb0RCIE5vZGUuanMgZHJpdmVyIGNvbGxlY3Rpb25dKFtNb25nb0RCIE5vZGUuanMgZHJpdmVyIGNvbGxlY3Rpb25dKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS9OZXh0L2NsYXNzZXMvQ29sbGVjdGlvbi5odG1sKSkuXG4gKiBVc2luZyBgTW9kZWwuY29sbGVjdGlvbmAgbWVhbnMgeW91IGJ5cGFzcyBNb25nb29zZSBtaWRkbGV3YXJlLCB2YWxpZGF0aW9uLCBhbmQgY2FzdGluZy5cbiAqXG4gKiBUaGlzIHByb3BlcnR5IGlzIHJlYWQtb25seS4gTW9kaWZ5aW5nIHRoaXMgcHJvcGVydHkgaXMgYSBuby1vcC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IGNvbGxlY3Rpb25cbiAqIEBtZW1iZXJPZiBNb2RlbFxuICogQGluc3RhbmNlXG4gKi9cblxuTW9kZWwucHJvdG90eXBlLmNvbGxlY3Rpb247XG5cbi8qKlxuICogSW50ZXJuYWwgY29sbGVjdGlvbiB0aGUgbW9kZWwgdXNlcy5cbiAqXG4gKiBUaGlzIHByb3BlcnR5IGlzIHJlYWQtb25seS4gTW9kaWZ5aW5nIHRoaXMgcHJvcGVydHkgaXMgYSBuby1vcC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqIEBwcm9wZXJ0eSBjb2xsZWN0aW9uXG4gKiBAbWVtYmVyT2YgTW9kZWxcbiAqIEBpbnN0YW5jZVxuICovXG5cblxuTW9kZWwucHJvdG90eXBlLiRfX2NvbGxlY3Rpb247XG5cbi8qKlxuICogVGhlIG5hbWUgb2YgdGhlIG1vZGVsXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBtb2RlbE5hbWVcbiAqIEBtZW1iZXJPZiBNb2RlbFxuICogQGluc3RhbmNlXG4gKi9cblxuTW9kZWwucHJvdG90eXBlLm1vZGVsTmFtZTtcblxuLyoqXG4gKiBBZGRpdGlvbmFsIHByb3BlcnRpZXMgdG8gYXR0YWNoIHRvIHRoZSBxdWVyeSB3aGVuIGNhbGxpbmcgYHNhdmUoKWAgYW5kXG4gKiBgaXNOZXdgIGlzIGZhbHNlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgJHdoZXJlXG4gKiBAbWVtYmVyT2YgTW9kZWxcbiAqIEBpbnN0YW5jZVxuICovXG5cbk1vZGVsLnByb3RvdHlwZS4kd2hlcmU7XG5cbi8qKlxuICogSWYgdGhpcyBpcyBhIGRpc2NyaW1pbmF0b3IgbW9kZWwsIGBiYXNlTW9kZWxOYW1lYCBpcyB0aGUgbmFtZSBvZlxuICogdGhlIGJhc2UgbW9kZWwuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBiYXNlTW9kZWxOYW1lXG4gKiBAbWVtYmVyT2YgTW9kZWxcbiAqIEBpbnN0YW5jZVxuICovXG5cbk1vZGVsLnByb3RvdHlwZS5iYXNlTW9kZWxOYW1lO1xuXG4vKipcbiAqIEV2ZW50IGVtaXR0ZXIgdGhhdCByZXBvcnRzIGFueSBlcnJvcnMgdGhhdCBvY2N1cnJlZC4gVXNlZnVsIGZvciBnbG9iYWwgZXJyb3JcbiAqIGhhbmRsaW5nLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgTXlNb2RlbC5ldmVudHMub24oJ2Vycm9yJywgZXJyID0+IGNvbnNvbGUubG9nKGVyci5tZXNzYWdlKSk7XG4gKlxuICogICAgIC8vIFByaW50cyBhICdDYXN0RXJyb3InIGJlY2F1c2Ugb2YgdGhlIGFib3ZlIGhhbmRsZXJcbiAqICAgICBhd2FpdCBNeU1vZGVsLmZpbmRPbmUoeyBfaWQ6ICdOb3QgYSB2YWxpZCBPYmplY3RJZCcgfSkuY2F0Y2gobm9vcCk7XG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBldmVudHNcbiAqIEBmaXJlcyBlcnJvciB3aGVuZXZlciBhbnkgcXVlcnkgb3IgbW9kZWwgZnVuY3Rpb24gZXJyb3JzXG4gKiBAbWVtYmVyT2YgTW9kZWxcbiAqIEBzdGF0aWNcbiAqL1xuXG5Nb2RlbC5ldmVudHM7XG5cbi8qKlxuICogQ29tcGlsZWQgbWlkZGxld2FyZSBmb3IgdGhpcyBtb2RlbC4gU2V0IGluIGBhcHBseUhvb2tzKClgLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICogQHByb3BlcnR5IF9taWRkbGV3YXJlXG4gKiBAbWVtYmVyT2YgTW9kZWxcbiAqIEBzdGF0aWNcbiAqL1xuXG5Nb2RlbC5fbWlkZGxld2FyZTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfYXBwbHlDdXN0b21XaGVyZShkb2MsIHdoZXJlKSB7XG4gIGlmIChkb2MuJHdoZXJlID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoZG9jLiR3aGVyZSkpIHtcbiAgICB3aGVyZVtrZXldID0gZG9jLiR3aGVyZVtrZXldO1xuICB9XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuTW9kZWwucHJvdG90eXBlLiRfX2hhbmRsZVNhdmUgPSBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuICBjb25zdCBzYXZlT3B0aW9ucyA9IHt9O1xuXG4gIGFwcGx5V3JpdGVDb25jZXJuKHRoaXMuJF9fc2NoZW1hLCBvcHRpb25zKTtcbiAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlQ29uY2VybiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzYXZlT3B0aW9ucy53cml0ZUNvbmNlcm4gPSB7fTtcbiAgICBpZiAoJ3cnIGluIG9wdGlvbnMud3JpdGVDb25jZXJuKSB7XG4gICAgICBzYXZlT3B0aW9ucy53cml0ZUNvbmNlcm4udyA9IG9wdGlvbnMud3JpdGVDb25jZXJuLnc7XG4gICAgfVxuICAgIGlmICgnaicgaW4gb3B0aW9ucy53cml0ZUNvbmNlcm4pIHtcbiAgICAgIHNhdmVPcHRpb25zLndyaXRlQ29uY2Vybi5qID0gb3B0aW9ucy53cml0ZUNvbmNlcm4uajtcbiAgICB9XG4gICAgaWYgKCd3dGltZW91dCcgaW4gb3B0aW9ucy53cml0ZUNvbmNlcm4pIHtcbiAgICAgIHNhdmVPcHRpb25zLndyaXRlQ29uY2Vybi53dGltZW91dCA9IG9wdGlvbnMud3JpdGVDb25jZXJuLnd0aW1lb3V0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoJ3cnIGluIG9wdGlvbnMpIHtcbiAgICAgIHNhdmVPcHRpb25zLncgPSBvcHRpb25zLnc7XG4gICAgfVxuICAgIGlmICgnaicgaW4gb3B0aW9ucykge1xuICAgICAgc2F2ZU9wdGlvbnMuaiA9IG9wdGlvbnMuajtcbiAgICB9XG4gICAgaWYgKCd3dGltZW91dCcgaW4gb3B0aW9ucykge1xuICAgICAgc2F2ZU9wdGlvbnMud3RpbWVvdXQgPSBvcHRpb25zLnd0aW1lb3V0O1xuICAgIH1cbiAgfVxuICBpZiAoJ2NoZWNrS2V5cycgaW4gb3B0aW9ucykge1xuICAgIHNhdmVPcHRpb25zLmNoZWNrS2V5cyA9IG9wdGlvbnMuY2hlY2tLZXlzO1xuICB9XG5cbiAgY29uc3Qgc2Vzc2lvbiA9IHRoaXMuJHNlc3Npb24oKTtcbiAgaWYgKCFzYXZlT3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnc2Vzc2lvbicpICYmIHNlc3Npb24gIT0gbnVsbCkge1xuICAgIHNhdmVPcHRpb25zLnNlc3Npb24gPSBzZXNzaW9uO1xuICB9XG4gIGlmICh0aGlzLiRpc05ldykge1xuICAgIC8vIHNlbmQgZW50aXJlIGRvY1xuICAgIGNvbnN0IG9iaiA9IHRoaXMudG9PYmplY3Qoc2F2ZVRvT2JqZWN0T3B0aW9ucyk7XG4gICAgaWYgKChvYmogfHwge30pLl9pZCA9PT0gdm9pZCAwKSB7XG4gICAgICAvLyBkb2N1bWVudHMgbXVzdCBoYXZlIGFuIF9pZCBlbHNlIG1vbmdvb3NlIHdvbid0IGtub3dcbiAgICAgIC8vIHdoYXQgdG8gdXBkYXRlIGxhdGVyIGlmIG1vcmUgY2hhbmdlcyBhcmUgbWFkZS4gdGhlIHVzZXJcbiAgICAgIC8vIHdvdWxkbid0IGtub3cgd2hhdCBfaWQgd2FzIGdlbmVyYXRlZCBieSBtb25nb2RiIGVpdGhlclxuICAgICAgLy8gbm9yIHdvdWxkIHRoZSBPYmplY3RJZCBnZW5lcmF0ZWQgYnkgbW9uZ29kYiBuZWNlc3NhcmlseVxuICAgICAgLy8gbWF0Y2ggdGhlIHNjaGVtYSBkZWZpbml0aW9uLlxuICAgICAgaW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICBjYWxsYmFjayhuZXcgTW9uZ29vc2VFcnJvcignZG9jdW1lbnQgbXVzdCBoYXZlIGFuIF9pZCBiZWZvcmUgc2F2aW5nJykpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy4kX192ZXJzaW9uKHRydWUsIG9iaik7XG4gICAgdGhpc1ttb2RlbENvbGxlY3Rpb25TeW1ib2xdLmluc2VydE9uZShvYmosIHNhdmVPcHRpb25zKS50aGVuKFxuICAgICAgcmV0ID0+IGNhbGxiYWNrKG51bGwsIHJldCksXG4gICAgICBlcnIgPT4ge1xuICAgICAgICBfc2V0SXNOZXcodGhpcywgdHJ1ZSk7XG5cbiAgICAgICAgY2FsbGJhY2soZXJyLCBudWxsKTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgdGhpcy4kX19yZXNldCgpO1xuICAgIF9zZXRJc05ldyh0aGlzLCBmYWxzZSk7XG4gICAgLy8gTWFrZSBpdCBwb3NzaWJsZSB0byByZXRyeSB0aGUgaW5zZXJ0XG4gICAgdGhpcy4kX18uaW5zZXJ0aW5nID0gdHJ1ZTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgd2UgZG9uJ3QgdHJlYXQgaXQgYXMgYSBuZXcgb2JqZWN0IG9uIGVycm9yLFxuICAvLyBzaW5jZSBpdCBhbHJlYWR5IGV4aXN0c1xuICB0aGlzLiRfXy5pbnNlcnRpbmcgPSBmYWxzZTtcbiAgY29uc3QgZGVsdGEgPSB0aGlzLiRfX2RlbHRhKCk7XG5cbiAgaWYgKG9wdGlvbnMucGF0aHNUb1NhdmUpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBkZWx0YVsxXVsnJHNldCddKSB7XG4gICAgICBpZiAob3B0aW9ucy5wYXRoc1RvU2F2ZS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnBhdGhzVG9TYXZlLnNvbWUocGF0aFRvU2F2ZSA9PiBrZXkuc2xpY2UoMCwgcGF0aFRvU2F2ZS5sZW5ndGgpID09PSBwYXRoVG9TYXZlICYmIGtleS5jaGFyQXQocGF0aFRvU2F2ZS5sZW5ndGgpID09PSAnLicpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIGRlbHRhWzFdWyckc2V0J11ba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGRlbHRhKSB7XG4gICAgaWYgKGRlbHRhIGluc3RhbmNlb2YgTW9uZ29vc2VFcnJvcikge1xuICAgICAgY2FsbGJhY2soZGVsdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHdoZXJlID0gdGhpcy4kX193aGVyZShkZWx0YVswXSk7XG4gICAgaWYgKHdoZXJlIGluc3RhbmNlb2YgTW9uZ29vc2VFcnJvcikge1xuICAgICAgY2FsbGJhY2sod2hlcmUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIF9hcHBseUN1c3RvbVdoZXJlKHRoaXMsIHdoZXJlKTtcblxuICAgIGNvbnN0IHVwZGF0ZSA9IGRlbHRhWzFdO1xuICAgIGlmICh0aGlzLiRfX3NjaGVtYS5vcHRpb25zLm1pbmltaXplKSB7XG4gICAgICBmb3IgKGNvbnN0IHVwZGF0ZU9wIG9mIE9iamVjdC52YWx1ZXModXBkYXRlKSkge1xuICAgICAgICBpZiAodXBkYXRlT3AgPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHVwZGF0ZU9wKSkge1xuICAgICAgICAgIGlmICh1cGRhdGVPcFtrZXldID09IG51bGwgfHwgdHlwZW9mIHVwZGF0ZU9wW2tleV0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF1dGlscy5pc1BPSk8odXBkYXRlT3Bba2V5XSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtaW5pbWl6ZSh1cGRhdGVPcFtrZXldKTtcbiAgICAgICAgICBpZiAoT2JqZWN0LmtleXModXBkYXRlT3Bba2V5XSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBkZWxldGUgdXBkYXRlT3Bba2V5XTtcbiAgICAgICAgICAgIHVwZGF0ZS4kdW5zZXQgPSB1cGRhdGUuJHVuc2V0IHx8IHt9O1xuICAgICAgICAgICAgdXBkYXRlLiR1bnNldFtrZXldID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzW21vZGVsQ29sbGVjdGlvblN5bWJvbF0udXBkYXRlT25lKHdoZXJlLCB1cGRhdGUsIHNhdmVPcHRpb25zKS50aGVuKFxuICAgICAgcmV0ID0+IHtcbiAgICAgICAgcmV0LiR3aGVyZSA9IHdoZXJlO1xuICAgICAgICBjYWxsYmFjayhudWxsLCByZXQpO1xuICAgICAgfSxcbiAgICAgIGVyciA9PiB7XG4gICAgICAgIHRoaXMuJF9fdW5kb1Jlc2V0KCk7XG5cbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGhhbmRsZUVtcHR5VXBkYXRlLmNhbGwodGhpcyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc3RvcmUgdGhlIG1vZGlmaWVkIHBhdGhzIGJlZm9yZSB0aGUgZG9jdW1lbnQgaXMgcmVzZXRcbiAgdGhpcy4kX18ubW9kaWZpZWRQYXRocyA9IHRoaXMubW9kaWZpZWRQYXRocygpO1xuICB0aGlzLiRfX3Jlc2V0KCk7XG5cbiAgX3NldElzTmV3KHRoaXMsIGZhbHNlKTtcblxuICBmdW5jdGlvbiBoYW5kbGVFbXB0eVVwZGF0ZSgpIHtcbiAgICBjb25zdCBvcHRpb25zV2l0aEN1c3RvbVZhbHVlcyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHNhdmVPcHRpb25zKTtcbiAgICBjb25zdCB3aGVyZSA9IHRoaXMuJF9fd2hlcmUoKTtcbiAgICBjb25zdCBvcHRpbWlzdGljQ29uY3VycmVuY3kgPSB0aGlzLiRfX3NjaGVtYS5vcHRpb25zLm9wdGltaXN0aWNDb25jdXJyZW5jeTtcbiAgICBpZiAob3B0aW1pc3RpY0NvbmN1cnJlbmN5ICYmICFBcnJheS5pc0FycmF5KG9wdGltaXN0aWNDb25jdXJyZW5jeSkpIHtcbiAgICAgIGNvbnN0IGtleSA9IHRoaXMuJF9fc2NoZW1hLm9wdGlvbnMudmVyc2lvbktleTtcbiAgICAgIGNvbnN0IHZhbCA9IHRoaXMuJF9fZ2V0VmFsdWUoa2V5KTtcbiAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICB3aGVyZVtrZXldID0gdmFsO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvbnN0cnVjdG9yLmNvbGxlY3Rpb24uZmluZE9uZSh3aGVyZSwgb3B0aW9uc1dpdGhDdXN0b21WYWx1ZXMpXG4gICAgICAudGhlbihkb2N1bWVudEV4aXN0cyA9PiB7XG4gICAgICAgIGNvbnN0IG1hdGNoZWRDb3VudCA9ICFkb2N1bWVudEV4aXN0cyA/IDAgOiAxO1xuICAgICAgICBjYWxsYmFjayhudWxsLCB7ICR3aGVyZTogd2hlcmUsIG1hdGNoZWRDb3VudCB9KTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goY2FsbGJhY2spO1xuICB9XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbk1vZGVsLnByb3RvdHlwZS4kX19zYXZlID0gZnVuY3Rpb24ob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgdGhpcy4kX19oYW5kbGVTYXZlKG9wdGlvbnMsIChlcnJvciwgcmVzdWx0KSA9PiB7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zdCBob29rcyA9IHRoaXMuJF9fc2NoZW1hLnMuaG9va3M7XG4gICAgICByZXR1cm4gaG9va3MuZXhlY1Bvc3QoJ3NhdmU6ZXJyb3InLCB0aGlzLCBbdGhpc10sIHsgZXJyb3I6IGVycm9yIH0sIChlcnJvcikgPT4ge1xuICAgICAgICBjYWxsYmFjayhlcnJvciwgdGhpcyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGV0IG51bUFmZmVjdGVkID0gMDtcbiAgICBjb25zdCB3cml0ZUNvbmNlcm4gPSBvcHRpb25zICE9IG51bGwgP1xuICAgICAgb3B0aW9ucy53cml0ZUNvbmNlcm4gIT0gbnVsbCA/XG4gICAgICAgIG9wdGlvbnMud3JpdGVDb25jZXJuLncgOlxuICAgICAgICBvcHRpb25zLncgOlxuICAgICAgMDtcbiAgICBpZiAod3JpdGVDb25jZXJuICE9PSAwKSB7XG4gICAgICAvLyBTa2lwIGNoZWNraW5nIGlmIHdyaXRlIHN1Y2NlZWRlZCBpZiB3cml0ZUNvbmNlcm4gaXMgc2V0IHRvXG4gICAgICAvLyB1bmFja25vd2xlZGdlZCB3cml0ZXMsIGJlY2F1c2Ugb3RoZXJ3aXNlIGBudW1BZmZlY3RlZGAgd2lsbCBhbHdheXMgYmUgMFxuICAgICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgICAgICBudW1BZmZlY3RlZCA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0Lm1hdGNoZWRDb3VudCAhPSBudWxsKSB7XG4gICAgICAgICAgbnVtQWZmZWN0ZWQgPSByZXN1bHQubWF0Y2hlZENvdW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG51bUFmZmVjdGVkID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHZlcnNpb25CdW1wID0gdGhpcy4kX18udmVyc2lvbjtcbiAgICAgIC8vIHdhcyB0aGlzIGFuIHVwZGF0ZSB0aGF0IHJlcXVpcmVkIGEgdmVyc2lvbiBidW1wP1xuICAgICAgaWYgKHZlcnNpb25CdW1wICYmICF0aGlzLiRfXy5pbnNlcnRpbmcpIHtcbiAgICAgICAgY29uc3QgZG9JbmNyZW1lbnQgPSBWRVJTSU9OX0lOQyA9PT0gKFZFUlNJT05fSU5DICYgdGhpcy4kX18udmVyc2lvbik7XG4gICAgICAgIHRoaXMuJF9fLnZlcnNpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuJF9fc2NoZW1hLm9wdGlvbnMudmVyc2lvbktleTtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IHRoaXMuJF9fZ2V0VmFsdWUoa2V5KSB8fCAwO1xuICAgICAgICBpZiAobnVtQWZmZWN0ZWQgPD0gMCkge1xuICAgICAgICAgIC8vIHRoZSB1cGRhdGUgZmFpbGVkLiBwYXNzIGFuIGVycm9yIGJhY2tcbiAgICAgICAgICB0aGlzLiRfX3VuZG9SZXNldCgpO1xuICAgICAgICAgIGNvbnN0IGVyciA9IHRoaXMuJF9fLiR2ZXJzaW9uRXJyb3IgfHxcbiAgICAgICAgICAgIG5ldyBWZXJzaW9uRXJyb3IodGhpcywgdmVyc2lvbiwgdGhpcy4kX18ubW9kaWZpZWRQYXRocyk7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbmNyZW1lbnQgdmVyc2lvbiBpZiB3YXMgc3VjY2Vzc2Z1bFxuICAgICAgICBpZiAoZG9JbmNyZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLiRfX3NldFZhbHVlKGtleSwgdmVyc2lvbiArIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0ICE9IG51bGwgJiYgbnVtQWZmZWN0ZWQgPD0gMCkge1xuICAgICAgICB0aGlzLiRfX3VuZG9SZXNldCgpO1xuICAgICAgICBlcnJvciA9IG5ldyBEb2N1bWVudE5vdEZvdW5kRXJyb3IocmVzdWx0LiR3aGVyZSxcbiAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLm1vZGVsTmFtZSwgbnVtQWZmZWN0ZWQsIHJlc3VsdCk7XG4gICAgICAgIGNvbnN0IGhvb2tzID0gdGhpcy4kX19zY2hlbWEucy5ob29rcztcbiAgICAgICAgcmV0dXJuIGhvb2tzLmV4ZWNQb3N0KCdzYXZlOmVycm9yJywgdGhpcywgW3RoaXNdLCB7IGVycm9yOiBlcnJvciB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICBjYWxsYmFjayhlcnJvciwgdGhpcyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiRfXy5zYXZpbmcgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4kX18uc2F2ZWRTdGF0ZSA9IHt9O1xuICAgIHRoaXMuJGVtaXQoJ3NhdmUnLCB0aGlzLCBudW1BZmZlY3RlZCk7XG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5lbWl0KCdzYXZlJywgdGhpcywgbnVtQWZmZWN0ZWQpO1xuICAgIGNhbGxiYWNrKG51bGwsIHRoaXMpO1xuICB9KTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gZ2VuZXJhdGVWZXJzaW9uRXJyb3IoZG9jLCBtb2RpZmllZFBhdGhzKSB7XG4gIGNvbnN0IGtleSA9IGRvYy4kX19zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5O1xuICBpZiAoIWtleSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHZlcnNpb24gPSBkb2MuJF9fZ2V0VmFsdWUoa2V5KSB8fCAwO1xuICByZXR1cm4gbmV3IFZlcnNpb25FcnJvcihkb2MsIHZlcnNpb24sIG1vZGlmaWVkUGF0aHMpO1xufVxuXG4vKipcbiAqIFNhdmVzIHRoaXMgZG9jdW1lbnQgYnkgaW5zZXJ0aW5nIGEgbmV3IGRvY3VtZW50IGludG8gdGhlIGRhdGFiYXNlIGlmIFtkb2N1bWVudC5pc05ld10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS5pc05ldykgaXMgYHRydWVgLFxuICogb3Igc2VuZHMgYW4gW3VwZGF0ZU9uZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS51cGRhdGVPbmUoKSkgb3BlcmF0aW9uIHdpdGgganVzdCB0aGUgbW9kaWZpZWQgcGF0aHMgaWYgYGlzTmV3YCBpcyBgZmFsc2VgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcHJvZHVjdC5zb2xkID0gRGF0ZS5ub3coKTtcbiAqICAgICBwcm9kdWN0ID0gYXdhaXQgcHJvZHVjdC5zYXZlKCk7XG4gKlxuICogSWYgc2F2ZSBpcyBzdWNjZXNzZnVsLCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGZ1bGZpbGwgd2l0aCB0aGUgZG9jdW1lbnRcbiAqIHNhdmVkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgbmV3UHJvZHVjdCA9IGF3YWl0IHByb2R1Y3Quc2F2ZSgpO1xuICogICAgIG5ld1Byb2R1Y3QgPT09IHByb2R1Y3Q7IC8vIHRydWVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbnMgb3B0aW9uYWwgb3B0aW9uc1xuICogQHBhcmFtIHtTZXNzaW9ufSBbb3B0aW9ucy5zZXNzaW9uPW51bGxdIHRoZSBbc2Vzc2lvbl0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3NlcnZlci1zZXNzaW9ucy8pIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHNhdmUgb3BlcmF0aW9uLiBJZiBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byB0aGUgW2RvY3VtZW50J3MgYXNzb2NpYXRlZCBzZXNzaW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLnNlc3Npb24oKSkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuc2FmZV0gKERFUFJFQ0FURUQpIG92ZXJyaWRlcyBbc2NoZW1hJ3Mgc2FmZSBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3NhZmUpLiBVc2UgdGhlIGB3YCBvcHRpb24gaW5zdGVhZC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudmFsaWRhdGVCZWZvcmVTYXZlXSBzZXQgdG8gZmFsc2UgdG8gc2F2ZSB3aXRob3V0IHZhbGlkYXRpbmcuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnZhbGlkYXRlTW9kaWZpZWRPbmx5PWZhbHNlXSBpZiBgdHJ1ZWAsIE1vbmdvb3NlIHdpbGwgb25seSB2YWxpZGF0ZSBtb2RpZmllZCBwYXRocywgYXMgb3Bwb3NlZCB0byBtb2RpZmllZCBwYXRocyBhbmQgYHJlcXVpcmVkYCBwYXRocy5cbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW29wdGlvbnMud10gc2V0IHRoZSBbd3JpdGUgY29uY2Vybl0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vI3ctb3B0aW9uKS4gT3ZlcnJpZGVzIHRoZSBbc2NoZW1hLWxldmVsIGB3cml0ZUNvbmNlcm5gIG9wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjd3JpdGVDb25jZXJuKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5qXSBzZXQgdG8gdHJ1ZSBmb3IgTW9uZ29EQiB0byB3YWl0IHVudGlsIHRoaXMgYHNhdmUoKWAgaGFzIGJlZW4gW2pvdXJuYWxlZCBiZWZvcmUgcmVzb2x2aW5nIHRoZSByZXR1cm5lZCBwcm9taXNlXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvd3JpdGUtY29uY2Vybi8jai1vcHRpb24pLiBPdmVycmlkZXMgdGhlIFtzY2hlbWEtbGV2ZWwgYHdyaXRlQ29uY2VybmAgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN3cml0ZUNvbmNlcm4pXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud3RpbWVvdXRdIHNldHMgYSBbdGltZW91dCBmb3IgdGhlIHdyaXRlIGNvbmNlcm5dKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLyN3dGltZW91dCkuIE92ZXJyaWRlcyB0aGUgW3NjaGVtYS1sZXZlbCBgd3JpdGVDb25jZXJuYCBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3dyaXRlQ29uY2VybikuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNoZWNrS2V5cz10cnVlXSB0aGUgTW9uZ29EQiBkcml2ZXIgcHJldmVudHMgeW91IGZyb20gc2F2aW5nIGtleXMgdGhhdCBzdGFydCB3aXRoICckJyBvciBjb250YWluICcuJyBieSBkZWZhdWx0LiBTZXQgdGhpcyBvcHRpb24gdG8gYGZhbHNlYCB0byBza2lwIHRoYXQgY2hlY2suIFNlZSBbcmVzdHJpY3Rpb25zIG9uIGZpZWxkIG5hbWVzXShodHRwczovL2RvY3MubW9uZ29kYi5jb20vbWFudWFsL3JlZmVyZW5jZS9saW1pdHMvI21vbmdvZGItbGltaXQtUmVzdHJpY3Rpb25zLW9uLUZpZWxkLU5hbWVzKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50aW1lc3RhbXBzPXRydWVdIGlmIGBmYWxzZWAgYW5kIFt0aW1lc3RhbXBzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0aW1lc3RhbXBzKSBhcmUgZW5hYmxlZCwgc2tpcCB0aW1lc3RhbXBzIGZvciB0aGlzIGBzYXZlKClgLlxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMucGF0aHNUb1NhdmVdIEFuIGFycmF5IG9mIHBhdGhzIHRoYXQgdGVsbCBtb25nb29zZSB0byBvbmx5IHZhbGlkYXRlIGFuZCBzYXZlIHRoZSBwYXRocyBpbiBgcGF0aHNUb1NhdmVgLlxuICogQHRocm93cyB7RG9jdW1lbnROb3RGb3VuZEVycm9yfSBpZiB0aGlzIFtzYXZlIHVwZGF0ZXMgYW4gZXhpc3RpbmcgZG9jdW1lbnRdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudC5wcm90b3R5cGUuaXNOZXcpIGJ1dCB0aGUgZG9jdW1lbnQgZG9lc24ndCBleGlzdCBpbiB0aGUgZGF0YWJhc2UuIEZvciBleGFtcGxlLCB5b3Ugd2lsbCBnZXQgdGhpcyBlcnJvciBpZiB0aGUgZG9jdW1lbnQgaXMgW2RlbGV0ZWQgYmV0d2VlbiB3aGVuIHlvdSByZXRyaWV2ZWQgdGhlIGRvY3VtZW50IGFuZCB3aGVuIHlvdSBzYXZlZCBpdF0oZG9jdW1lbnRzLmh0bWwjdXBkYXRpbmcpLlxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKiBAc2VlIG1pZGRsZXdhcmUgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL21pZGRsZXdhcmUuaHRtbFxuICovXG5cbk1vZGVsLnByb3RvdHlwZS5zYXZlID0gYXN5bmMgZnVuY3Rpb24gc2F2ZShvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLnByb3RvdHlwZS5zYXZlKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgbGV0IHBhcmFsbGVsU2F2ZTtcbiAgdGhpcy4kb3AgPSAnc2F2ZSc7XG5cbiAgaWYgKHRoaXMuJF9fLnNhdmluZykge1xuICAgIHBhcmFsbGVsU2F2ZSA9IG5ldyBQYXJhbGxlbFNhdmVFcnJvcih0aGlzKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLiRfXy5zYXZpbmcgPSBuZXcgUGFyYWxsZWxTYXZlRXJyb3IodGhpcyk7XG4gIH1cblxuICBvcHRpb25zID0gbmV3IFNhdmVPcHRpb25zKG9wdGlvbnMpO1xuICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnc2Vzc2lvbicpKSB7XG4gICAgdGhpcy4kc2Vzc2lvbihvcHRpb25zLnNlc3Npb24pO1xuICB9XG4gIGlmICh0aGlzLiRfXy50aW1lc3RhbXBzICE9IG51bGwpIHtcbiAgICBvcHRpb25zLnRpbWVzdGFtcHMgPSB0aGlzLiRfXy50aW1lc3RhbXBzO1xuICB9XG4gIHRoaXMuJF9fLiR2ZXJzaW9uRXJyb3IgPSBnZW5lcmF0ZVZlcnNpb25FcnJvcih0aGlzLCB0aGlzLm1vZGlmaWVkUGF0aHMoKSk7XG5cbiAgaWYgKHBhcmFsbGVsU2F2ZSkge1xuICAgIHRoaXMuJF9faGFuZGxlUmVqZWN0KHBhcmFsbGVsU2F2ZSk7XG4gICAgdGhyb3cgcGFyYWxsZWxTYXZlO1xuICB9XG5cbiAgdGhpcy4kX18uc2F2ZU9wdGlvbnMgPSBvcHRpb25zO1xuXG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB0aGlzLiRfX3NhdmUob3B0aW9ucywgZXJyb3IgPT4ge1xuICAgICAgdGhpcy4kX18uc2F2aW5nID0gbnVsbDtcbiAgICAgIHRoaXMuJF9fLnNhdmVPcHRpb25zID0gbnVsbDtcbiAgICAgIHRoaXMuJF9fLiR2ZXJzaW9uRXJyb3IgPSBudWxsO1xuICAgICAgdGhpcy4kb3AgPSBudWxsO1xuICAgICAgaWYgKGVycm9yICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy4kX19oYW5kbGVSZWplY3QoZXJyb3IpO1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk1vZGVsLnByb3RvdHlwZS4kc2F2ZSA9IE1vZGVsLnByb3RvdHlwZS5zYXZlO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB2ZXJzaW9uaW5nIHNob3VsZCBiZSBza2lwcGVkIGZvciB0aGUgZ2l2ZW4gcGF0aFxuICpcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IHNlbGZcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHZlcnNpb25pbmcgc2hvdWxkIGJlIHNraXBwZWQgZm9yIHRoZSBnaXZlbiBwYXRoXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2hvdWxkU2tpcFZlcnNpb25pbmcoc2VsZiwgcGF0aCkge1xuICBjb25zdCBza2lwVmVyc2lvbmluZyA9IHNlbGYuJF9fc2NoZW1hLm9wdGlvbnMuc2tpcFZlcnNpb25pbmc7XG4gIGlmICghc2tpcFZlcnNpb25pbmcpIHJldHVybiBmYWxzZTtcblxuICAvLyBSZW1vdmUgYW55IGFycmF5IGluZGV4ZXMgZnJvbSB0aGUgcGF0aFxuICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXC5cXGQrXFwuLywgJy4nKTtcblxuICByZXR1cm4gc2tpcFZlcnNpb25pbmdbcGF0aF07XG59XG5cbi8qKlxuICogQXBwbHkgdGhlIG9wZXJhdGlvbiB0byB0aGUgZGVsdGEgKHVwZGF0ZSkgY2xhdXNlIGFzXG4gKiB3ZWxsIGFzIHRyYWNrIHZlcnNpb25pbmcgZm9yIG91ciB3aGVyZSBjbGF1c2UuXG4gKlxuICogQHBhcmFtIHtEb2N1bWVudH0gc2VsZlxuICogQHBhcmFtIHtPYmplY3R9IHdoZXJlIFVudXNlZFxuICogQHBhcmFtIHtPYmplY3R9IGRlbHRhXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wXVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gb3BlcmFuZChzZWxmLCB3aGVyZSwgZGVsdGEsIGRhdGEsIHZhbCwgb3ApIHtcbiAgLy8gZGVsdGFcbiAgb3AgfHwgKG9wID0gJyRzZXQnKTtcbiAgaWYgKCFkZWx0YVtvcF0pIGRlbHRhW29wXSA9IHt9O1xuICBkZWx0YVtvcF1bZGF0YS5wYXRoXSA9IHZhbDtcbiAgLy8gZGlzYWJsZWQgdmVyc2lvbmluZz9cbiAgaWYgKHNlbGYuJF9fc2NoZW1hLm9wdGlvbnMudmVyc2lvbktleSA9PT0gZmFsc2UpIHJldHVybjtcblxuICAvLyBwYXRoIGV4Y2x1ZGVkIGZyb20gdmVyc2lvbmluZz9cbiAgaWYgKHNob3VsZFNraXBWZXJzaW9uaW5nKHNlbGYsIGRhdGEucGF0aCkpIHJldHVybjtcblxuICAvLyBhbHJlYWR5IG1hcmtlZCBmb3IgdmVyc2lvbmluZz9cbiAgaWYgKFZFUlNJT05fQUxMID09PSAoVkVSU0lPTl9BTEwgJiBzZWxmLiRfXy52ZXJzaW9uKSkgcmV0dXJuO1xuXG4gIGlmIChzZWxmLiRfX3NjaGVtYS5vcHRpb25zLm9wdGltaXN0aWNDb25jdXJyZW5jeSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAob3ApIHtcbiAgICBjYXNlICckc2V0JzpcbiAgICBjYXNlICckdW5zZXQnOlxuICAgIGNhc2UgJyRwb3AnOlxuICAgIGNhc2UgJyRwdWxsJzpcbiAgICBjYXNlICckcHVsbEFsbCc6XG4gICAgY2FzZSAnJHB1c2gnOlxuICAgIGNhc2UgJyRhZGRUb1NldCc6XG4gICAgY2FzZSAnJGluYyc6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZW5zdXJlIHVwZGF0ZXMgc2VudCB3aXRoIHBvc2l0aW9uYWwgbm90YXRpb24gYXJlXG4gIC8vIGVkaXRpbmcgdGhlIGNvcnJlY3QgYXJyYXkgZWxlbWVudC5cbiAgLy8gb25seSBpbmNyZW1lbnQgdGhlIHZlcnNpb24gaWYgYW4gYXJyYXkgcG9zaXRpb24gY2hhbmdlcy5cbiAgLy8gbW9kaWZ5aW5nIGVsZW1lbnRzIG9mIGFuIGFycmF5IGlzIG9rIGlmIHBvc2l0aW9uIGRvZXMgbm90IGNoYW5nZS5cbiAgaWYgKG9wID09PSAnJHB1c2gnIHx8IG9wID09PSAnJGFkZFRvU2V0JyB8fCBvcCA9PT0gJyRwdWxsQWxsJyB8fCBvcCA9PT0gJyRwdWxsJykge1xuICAgIGlmICgvXFwuXFxkK1xcLnxcXC5cXGQrJC8udGVzdChkYXRhLnBhdGgpKSB7XG4gICAgICBpbmNyZW1lbnQuY2FsbChzZWxmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi4kX18udmVyc2lvbiA9IFZFUlNJT05fSU5DO1xuICAgIH1cbiAgfSBlbHNlIGlmICgvXlxcJHAvLnRlc3Qob3ApKSB7XG4gICAgLy8gcG90ZW50aWFsbHkgY2hhbmdpbmcgYXJyYXkgcG9zaXRpb25zXG4gICAgaW5jcmVtZW50LmNhbGwoc2VsZik7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgLy8gJHNldCBhbiBhcnJheVxuICAgIGluY3JlbWVudC5jYWxsKHNlbGYpO1xuICB9IGVsc2UgaWYgKC9cXC5cXGQrXFwufFxcLlxcZCskLy50ZXN0KGRhdGEucGF0aCkpIHtcbiAgICAvLyBub3cgaGFuZGxpbmcgJHNldCwgJHVuc2V0XG4gICAgLy8gc3VicGF0aCBvZiBhcnJheVxuICAgIHNlbGYuJF9fLnZlcnNpb24gPSBWRVJTSU9OX1dIRVJFO1xuICB9XG59XG5cbi8qKlxuICogQ29tcGlsZXMgYW4gdXBkYXRlIGFuZCB3aGVyZSBjbGF1c2UgZm9yIGEgYHZhbGAgd2l0aCBfYXRvbWljcy5cbiAqXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBzZWxmXG4gKiBAcGFyYW0ge09iamVjdH0gd2hlcmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWx0YVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBoYW5kbGVBdG9taWNzKHNlbGYsIHdoZXJlLCBkZWx0YSwgZGF0YSwgdmFsdWUpIHtcbiAgaWYgKGRlbHRhLiRzZXQgJiYgZGVsdGEuJHNldFtkYXRhLnBhdGhdKSB7XG4gICAgLy8gJHNldCBoYXMgcHJlY2VkZW5jZSBvdmVyIG90aGVyIGF0b21pY3NcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlLiRfX2dldEF0b21pY3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YWx1ZS4kX19nZXRBdG9taWNzKCkuZm9yRWFjaChmdW5jdGlvbihhdG9taWMpIHtcbiAgICAgIGNvbnN0IG9wID0gYXRvbWljWzBdO1xuICAgICAgY29uc3QgdmFsID0gYXRvbWljWzFdO1xuICAgICAgb3BlcmFuZChzZWxmLCB3aGVyZSwgZGVsdGEsIGRhdGEsIHZhbCwgb3ApO1xuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGxlZ2FjeSBzdXBwb3J0IGZvciBwbHVnaW5zXG5cbiAgY29uc3QgYXRvbWljcyA9IHZhbHVlW2FycmF5QXRvbWljc1N5bWJvbF07XG4gIGNvbnN0IG9wcyA9IE9iamVjdC5rZXlzKGF0b21pY3MpO1xuICBsZXQgaSA9IG9wcy5sZW5ndGg7XG4gIGxldCB2YWw7XG4gIGxldCBvcDtcblxuICBpZiAoaSA9PT0gMCkge1xuICAgIC8vICRzZXRcblxuICAgIGlmICh1dGlscy5pc01vbmdvb3NlT2JqZWN0KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS50b09iamVjdCh7IGRlcG9wdWxhdGU6IDEsIF9pc05lc3RlZDogdHJ1ZSB9KTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlLnZhbHVlT2YpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUudmFsdWVPZigpO1xuICAgIH1cblxuICAgIHJldHVybiBvcGVyYW5kKHNlbGYsIHdoZXJlLCBkZWx0YSwgZGF0YSwgdmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXRlcihtZW0pIHtcbiAgICByZXR1cm4gdXRpbHMuaXNNb25nb29zZU9iamVjdChtZW0pXG4gICAgICA/IG1lbS50b09iamVjdCh7IGRlcG9wdWxhdGU6IDEsIF9pc05lc3RlZDogdHJ1ZSB9KVxuICAgICAgOiBtZW07XG4gIH1cblxuICB3aGlsZSAoaS0tKSB7XG4gICAgb3AgPSBvcHNbaV07XG4gICAgdmFsID0gYXRvbWljc1tvcF07XG5cbiAgICBpZiAodXRpbHMuaXNNb25nb29zZU9iamVjdCh2YWwpKSB7XG4gICAgICB2YWwgPSB2YWwudG9PYmplY3QoeyBkZXBvcHVsYXRlOiB0cnVlLCB0cmFuc2Zvcm06IGZhbHNlLCBfaXNOZXN0ZWQ6IHRydWUgfSk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIHZhbCA9IHZhbC5tYXAoaXRlcik7XG4gICAgfSBlbHNlIGlmICh2YWwudmFsdWVPZikge1xuICAgICAgdmFsID0gdmFsLnZhbHVlT2YoKTtcbiAgICB9XG5cbiAgICBpZiAob3AgPT09ICckYWRkVG9TZXQnKSB7XG4gICAgICB2YWwgPSB7ICRlYWNoOiB2YWwgfTtcbiAgICB9XG5cbiAgICBvcGVyYW5kKHNlbGYsIHdoZXJlLCBkZWx0YSwgZGF0YSwgdmFsLCBvcCk7XG4gIH1cbn1cblxuLyoqXG4gKiBQcm9kdWNlcyBhIHNwZWNpYWwgcXVlcnkgZG9jdW1lbnQgb2YgdGhlIG1vZGlmaWVkIHByb3BlcnRpZXMgdXNlZCBpbiB1cGRhdGVzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICogQG1ldGhvZCAkX19kZWx0YVxuICogQG1lbWJlck9mIE1vZGVsXG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5Nb2RlbC5wcm90b3R5cGUuJF9fZGVsdGEgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgZGlydHkgPSB0aGlzLiRfX2RpcnR5KCk7XG4gIGNvbnN0IG9wdGltaXN0aWNDb25jdXJyZW5jeSA9IHRoaXMuJF9fc2NoZW1hLm9wdGlvbnMub3B0aW1pc3RpY0NvbmN1cnJlbmN5O1xuICBpZiAob3B0aW1pc3RpY0NvbmN1cnJlbmN5KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW1pc3RpY0NvbmN1cnJlbmN5KSkge1xuICAgICAgY29uc3Qgb3B0Q29uID0gbmV3IFNldChvcHRpbWlzdGljQ29uY3VycmVuY3kpO1xuICAgICAgY29uc3QgbW9kUGF0aHMgPSB0aGlzLm1vZGlmaWVkUGF0aHMoKTtcbiAgICAgIGlmIChtb2RQYXRocy5maW5kKHBhdGggPT4gb3B0Q29uLmhhcyhwYXRoKSkpIHtcbiAgICAgICAgdGhpcy4kX18udmVyc2lvbiA9IGRpcnR5Lmxlbmd0aCA/IFZFUlNJT05fQUxMIDogVkVSU0lPTl9XSEVSRTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4kX18udmVyc2lvbiA9IGRpcnR5Lmxlbmd0aCA/IFZFUlNJT05fQUxMIDogVkVSU0lPTl9XSEVSRTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWRpcnR5Lmxlbmd0aCAmJiBWRVJTSU9OX0FMTCAhPT0gdGhpcy4kX18udmVyc2lvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB3aGVyZSA9IHt9O1xuICBjb25zdCBkZWx0YSA9IHt9O1xuICBjb25zdCBsZW4gPSBkaXJ0eS5sZW5ndGg7XG4gIGNvbnN0IGRpdmVyZ2VudCA9IFtdO1xuICBsZXQgZCA9IDA7XG5cbiAgd2hlcmUuX2lkID0gdGhpcy5fZG9jLl9pZDtcbiAgLy8gSWYgYF9pZGAgaXMgYW4gb2JqZWN0LCBuZWVkIHRvIGRlcG9wdWxhdGUsIGJ1dCBhbHNvIG5lZWQgdG8gYmUgY2FyZWZ1bFxuICAvLyBiZWNhdXNlIGBfaWRgIGNhbiB0ZWNobmljYWxseSBiZSBudWxsIChzZWUgZ2gtNjQwNilcbiAgaWYgKCh3aGVyZSAmJiB3aGVyZS5faWQgJiYgd2hlcmUuX2lkLiRfXyB8fCBudWxsKSAhPSBudWxsKSB7XG4gICAgd2hlcmUuX2lkID0gd2hlcmUuX2lkLnRvT2JqZWN0KHsgdHJhbnNmb3JtOiBmYWxzZSwgZGVwb3B1bGF0ZTogdHJ1ZSB9KTtcbiAgfVxuICBmb3IgKDsgZCA8IGxlbjsgKytkKSB7XG4gICAgY29uc3QgZGF0YSA9IGRpcnR5W2RdO1xuICAgIGxldCB2YWx1ZSA9IGRhdGEudmFsdWU7XG4gICAgY29uc3QgbWF0Y2ggPSBjaGVja0RpdmVyZ2VudEFycmF5KHRoaXMsIGRhdGEucGF0aCwgdmFsdWUpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgZGl2ZXJnZW50LnB1c2gobWF0Y2gpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgcG9wID0gdGhpcy4kcG9wdWxhdGVkKGRhdGEucGF0aCwgdHJ1ZSk7XG4gICAgaWYgKCFwb3AgJiYgdGhpcy4kX18uc2VsZWN0ZWQpIHtcbiAgICAgIC8vIElmIGFueSBhcnJheSB3YXMgc2VsZWN0ZWQgdXNpbmcgYW4gJGVsZW1NYXRjaCBwcm9qZWN0aW9uLCB3ZSBhbHRlciB0aGUgcGF0aCBhbmQgd2hlcmUgY2xhdXNlXG4gICAgICAvLyBOT1RFOiBNb25nb0RCIG9ubHkgc3VwcG9ydHMgcHJvamVjdGVkICRlbGVtTWF0Y2ggb24gdG9wIGxldmVsIGFycmF5LlxuICAgICAgY29uc3QgcGF0aFNwbGl0ID0gZGF0YS5wYXRoLnNwbGl0KCcuJyk7XG4gICAgICBjb25zdCB0b3AgPSBwYXRoU3BsaXRbMF07XG4gICAgICBpZiAodGhpcy4kX18uc2VsZWN0ZWRbdG9wXSAmJiB0aGlzLiRfXy5zZWxlY3RlZFt0b3BdLiRlbGVtTWF0Y2gpIHtcbiAgICAgICAgLy8gSWYgdGhlIHNlbGVjdGVkIGFycmF5IGVudHJ5IHdhcyBtb2RpZmllZFxuICAgICAgICBpZiAocGF0aFNwbGl0Lmxlbmd0aCA+IDEgJiYgcGF0aFNwbGl0WzFdID09IDAgJiYgdHlwZW9mIHdoZXJlW3RvcF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgd2hlcmVbdG9wXSA9IHRoaXMuJF9fLnNlbGVjdGVkW3RvcF07XG4gICAgICAgICAgcGF0aFNwbGl0WzFdID0gJyQnO1xuICAgICAgICAgIGRhdGEucGF0aCA9IHBhdGhTcGxpdC5qb2luKCcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIHNlbGVjdGVkIGFycmF5IHdhcyBtb2RpZmllZCBpbiBhbnkgb3RoZXIgd2F5IHRocm93IGFuIGVycm9yXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRpdmVyZ2VudC5wdXNoKGRhdGEucGF0aCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGlzIHBhdGggaXMgc2V0IHRvIGRlZmF1bHQsIGFuZCBlaXRoZXIgdGhpcyBwYXRoIG9yIG9uZSBvZlxuICAgIC8vIGl0cyBwYXJlbnRzIGlzIGV4Y2x1ZGVkLCBkb24ndCB0cmVhdCB0aGlzIHBhdGggYXMgZGlydHkuXG4gICAgaWYgKHRoaXMuJGlzRGVmYXVsdChkYXRhLnBhdGgpICYmIHRoaXMuJF9fLnNlbGVjdGVkKSB7XG4gICAgICBpZiAoZGF0YS5wYXRoLmluZGV4T2YoJy4nKSA9PT0gLTEgJiYgaXNQYXRoRXhjbHVkZWQodGhpcy4kX18uc2VsZWN0ZWQsIGRhdGEucGF0aCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhdGhzVG9DaGVjayA9IHBhcmVudFBhdGhzKGRhdGEucGF0aCk7XG4gICAgICBpZiAocGF0aHNUb0NoZWNrLmZpbmQocGF0aCA9PiBpc1BhdGhFeGNsdWRlZCh0aGlzLiRfXy5pc1NlbGVjdGVkLCBwYXRoKSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpdmVyZ2VudC5sZW5ndGgpIGNvbnRpbnVlO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcGVyYW5kKHRoaXMsIHdoZXJlLCBkZWx0YSwgZGF0YSwgMSwgJyR1bnNldCcpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIG9wZXJhbmQodGhpcywgd2hlcmUsIGRlbHRhLCBkYXRhLCBudWxsKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzTW9uZ29vc2VBcnJheSh2YWx1ZSkgJiYgdmFsdWUuJHBhdGgoKSAmJiB2YWx1ZVthcnJheUF0b21pY3NTeW1ib2xdKSB7XG4gICAgICAvLyBhcnJheXMgYW5kIG90aGVyIGN1c3RvbSB0eXBlcyAoc3VwcG9ydCBwbHVnaW5zIGV0YylcbiAgICAgIGhhbmRsZUF0b21pY3ModGhpcywgd2hlcmUsIGRlbHRhLCBkYXRhLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZVtNb25nb29zZUJ1ZmZlci5wYXRoU3ltYm9sXSAmJiBCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAvLyBNb25nb29zZUJ1ZmZlclxuICAgICAgdmFsdWUgPSB2YWx1ZS50b09iamVjdCgpO1xuICAgICAgb3BlcmFuZCh0aGlzLCB3aGVyZSwgZGVsdGEsIGRhdGEsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuJF9fLnByaW1pdGl2ZUF0b21pY3MgJiYgdGhpcy4kX18ucHJpbWl0aXZlQXRvbWljc1tkYXRhLnBhdGhdICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgdmFsID0gdGhpcy4kX18ucHJpbWl0aXZlQXRvbWljc1tkYXRhLnBhdGhdO1xuICAgICAgICBjb25zdCBvcCA9IGZpcnN0S2V5KHZhbCk7XG4gICAgICAgIG9wZXJhbmQodGhpcywgd2hlcmUsIGRlbHRhLCBkYXRhLCB2YWxbb3BdLCBvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGNsb25lKHZhbHVlLCB7XG4gICAgICAgICAgZGVwb3B1bGF0ZTogdHJ1ZSxcbiAgICAgICAgICB0cmFuc2Zvcm06IGZhbHNlLFxuICAgICAgICAgIHZpcnR1YWxzOiBmYWxzZSxcbiAgICAgICAgICBnZXR0ZXJzOiBmYWxzZSxcbiAgICAgICAgICBvbWl0VW5kZWZpbmVkOiB0cnVlLFxuICAgICAgICAgIF9pc05lc3RlZDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgb3BlcmFuZCh0aGlzLCB3aGVyZSwgZGVsdGEsIGRhdGEsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZGl2ZXJnZW50Lmxlbmd0aCkge1xuICAgIHJldHVybiBuZXcgRGl2ZXJnZW50QXJyYXlFcnJvcihkaXZlcmdlbnQpO1xuICB9XG5cbiAgaWYgKHRoaXMuJF9fLnZlcnNpb24pIHtcbiAgICB0aGlzLiRfX3ZlcnNpb24od2hlcmUsIGRlbHRhKTtcbiAgfVxuXG4gIGlmIChPYmplY3Qua2V5cyhkZWx0YSkubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFt3aGVyZSwgbnVsbF07XG4gIH1cblxuICByZXR1cm4gW3doZXJlLCBkZWx0YV07XG59O1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhcnJheSB3YXMgcG9wdWxhdGVkIHdpdGggc29tZSBmb3JtIG9mIGZpbHRlciBhbmQgaXMgbm93XG4gKiBiZWluZyB1cGRhdGVkIGluIGEgbWFubmVyIHdoaWNoIGNvdWxkIG92ZXJ3cml0ZSBkYXRhIHVuaW50ZW50aW9uYWxseS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL21vbmdvb3NlL2lzc3Vlcy8xMzM0XG4gKiBAcGFyYW0ge0RvY3VtZW50fSBkb2NcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge0FueX0gYXJyYXlcbiAqIEByZXR1cm4ge1N0cmluZ3x1bmRlZmluZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjaGVja0RpdmVyZ2VudEFycmF5KGRvYywgcGF0aCwgYXJyYXkpIHtcbiAgLy8gc2VlIGlmIHdlIHBvcHVsYXRlZCB0aGlzIHBhdGhcbiAgY29uc3QgcG9wID0gZG9jLiRwb3B1bGF0ZWQocGF0aCwgdHJ1ZSk7XG5cbiAgaWYgKCFwb3AgJiYgZG9jLiRfXy5zZWxlY3RlZCkge1xuICAgIC8vIElmIGFueSBhcnJheSB3YXMgc2VsZWN0ZWQgdXNpbmcgYW4gJGVsZW1NYXRjaCBwcm9qZWN0aW9uLCB3ZSBkZW55IHRoZSB1cGRhdGUuXG4gICAgLy8gTk9URTogTW9uZ29EQiBvbmx5IHN1cHBvcnRzIHByb2plY3RlZCAkZWxlbU1hdGNoIG9uIHRvcCBsZXZlbCBhcnJheS5cbiAgICBjb25zdCB0b3AgPSBwYXRoLnNwbGl0KCcuJylbMF07XG4gICAgaWYgKGRvYy4kX18uc2VsZWN0ZWRbdG9wICsgJy4kJ10pIHtcbiAgICAgIHJldHVybiB0b3A7XG4gICAgfVxuICB9XG5cbiAgaWYgKCEocG9wICYmIHV0aWxzLmlzTW9uZ29vc2VBcnJheShhcnJheSkpKSByZXR1cm47XG5cbiAgLy8gSWYgdGhlIGFycmF5IHdhcyBwb3B1bGF0ZWQgdXNpbmcgb3B0aW9ucyB0aGF0IHByZXZlbnRlZCBhbGxcbiAgLy8gZG9jdW1lbnRzIGZyb20gYmVpbmcgcmV0dXJuZWQgKG1hdGNoLCBza2lwLCBsaW1pdCkgb3IgdGhleVxuICAvLyBkZXNlbGVjdGVkIHRoZSBfaWQgZmllbGQsICRwb3AgYW5kICRzZXQgb2YgdGhlIGFycmF5IGFyZVxuICAvLyBub3Qgc2FmZSBvcGVyYXRpb25zLiBJZiBfaWQgd2FzIGRlc2VsZWN0ZWQsIHdlIGRvIG5vdCBrbm93XG4gIC8vIGhvdyB0byByZW1vdmUgZWxlbWVudHMuICRwb3Agd2lsbCBwb3Agb2ZmIHRoZSBfaWQgZnJvbSB0aGUgZW5kXG4gIC8vIG9mIHRoZSBhcnJheSBpbiB0aGUgZGIgd2hpY2ggaXMgbm90IGd1YXJhbnRlZWQgdG8gYmUgdGhlXG4gIC8vIHNhbWUgYXMgdGhlIGxhc3QgZWxlbWVudCB3ZSBoYXZlIGhlcmUuICRzZXQgb2YgdGhlIGVudGlyZSBhcnJheVxuICAvLyB3b3VsZCBiZSBzaW1pbGFybHkgZGVzdHJ1Y3RpdmUgYXMgd2UgbmV2ZXIgcmVjZWl2ZWQgYWxsXG4gIC8vIGVsZW1lbnRzIG9mIHRoZSBhcnJheSBhbmQgcG90ZW50aWFsbHkgd291bGQgb3ZlcndyaXRlIGRhdGEuXG4gIGNvbnN0IGNoZWNrID0gcG9wLm9wdGlvbnMubWF0Y2ggfHxcbiAgICAgIHBvcC5vcHRpb25zLm9wdGlvbnMgJiYgdXRpbHMub2JqZWN0Lmhhc093blByb3BlcnR5KHBvcC5vcHRpb25zLm9wdGlvbnMsICdsaW1pdCcpIHx8IC8vIDAgaXMgbm90IHBlcm1pdHRlZFxuICAgICAgcG9wLm9wdGlvbnMub3B0aW9ucyAmJiBwb3Aub3B0aW9ucy5vcHRpb25zLnNraXAgfHwgLy8gMCBpcyBwZXJtaXR0ZWRcbiAgICAgIHBvcC5vcHRpb25zLnNlbGVjdCAmJiAvLyBkZXNlbGVjdGVkIF9pZD9cbiAgICAgIChwb3Aub3B0aW9ucy5zZWxlY3QuX2lkID09PSAwIHx8XG4gICAgICAvXFxzPy1faWRcXHM/Ly50ZXN0KHBvcC5vcHRpb25zLnNlbGVjdCkpO1xuXG4gIGlmIChjaGVjaykge1xuICAgIGNvbnN0IGF0b21pY3MgPSBhcnJheVthcnJheUF0b21pY3NTeW1ib2xdO1xuICAgIGlmIChPYmplY3Qua2V5cyhhdG9taWNzKS5sZW5ndGggPT09IDAgfHwgYXRvbWljcy4kc2V0IHx8IGF0b21pY3MuJHBvcCkge1xuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQXBwZW5kcyB2ZXJzaW9uaW5nIHRvIHRoZSB3aGVyZSBhbmQgdXBkYXRlIGNsYXVzZXMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKiBAbWV0aG9kICRfX3ZlcnNpb25cbiAqIEBtZW1iZXJPZiBNb2RlbFxuICogQGluc3RhbmNlXG4gKi9cblxuTW9kZWwucHJvdG90eXBlLiRfX3ZlcnNpb24gPSBmdW5jdGlvbih3aGVyZSwgZGVsdGEpIHtcbiAgY29uc3Qga2V5ID0gdGhpcy4kX19zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5O1xuICBpZiAod2hlcmUgPT09IHRydWUpIHtcbiAgICAvLyB0aGlzIGlzIGFuIGluc2VydFxuICAgIGlmIChrZXkpIHtcbiAgICAgIHNldERvdHRlZFBhdGgoZGVsdGEsIGtleSwgMCk7XG4gICAgICB0aGlzLiRfX3NldFZhbHVlKGtleSwgMCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChrZXkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gdXBkYXRlc1xuXG4gIC8vIG9ubHkgYXBwbHkgdmVyc2lvbmluZyBpZiBvdXIgdmVyc2lvbktleSB3YXMgc2VsZWN0ZWQuIGVsc2VcbiAgLy8gdGhlcmUgaXMgbm8gd2F5IHRvIHNlbGVjdCB0aGUgY29ycmVjdCB2ZXJzaW9uLiB3ZSBjb3VsZCBmYWlsXG4gIC8vIGZhc3QgaGVyZSBhbmQgZm9yY2UgdGhlbSB0byBpbmNsdWRlIHRoZSB2ZXJzaW9uS2V5IGJ1dFxuICAvLyB0aGF0cyBhIGJpdCBpbnRydXNpdmUuIGNhbiB3ZSBkbyB0aGlzIGF1dG9tYXRpY2FsbHk/XG5cbiAgaWYgKCF0aGlzLiRfX2lzU2VsZWN0ZWQoa2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vICRwdXNoICRhZGRUb1NldCBkb24ndCBuZWVkIHRoZSB3aGVyZSBjbGF1c2Ugc2V0XG4gIGlmIChWRVJTSU9OX1dIRVJFID09PSAoVkVSU0lPTl9XSEVSRSAmIHRoaXMuJF9fLnZlcnNpb24pKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLiRfX2dldFZhbHVlKGtleSk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHdoZXJlW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIGlmIChWRVJTSU9OX0lOQyA9PT0gKFZFUlNJT05fSU5DICYgdGhpcy4kX18udmVyc2lvbikpIHtcbiAgICBpZiAoZ2V0KGRlbHRhLiRzZXQsIGtleSwgbnVsbCkgIT0gbnVsbCkge1xuICAgICAgLy8gVmVyc2lvbiBrZXkgaXMgZ2V0dGluZyBzZXQsIG1lYW5zIHdlJ2xsIGluY3JlbWVudCB0aGUgZG9jJ3MgdmVyc2lvblxuICAgICAgLy8gYWZ0ZXIgYSBzdWNjZXNzZnVsIHNhdmUsIHNvIHdlIHNob3VsZCBzZXQgdGhlIGluY3JlbWVudGVkIHZlcnNpb24gc29cbiAgICAgIC8vIGZ1dHVyZSBzYXZlcyBkb24ndCBmYWlsIChnaC01Nzc5KVxuICAgICAgKytkZWx0YS4kc2V0W2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbHRhLiRpbmMgPSBkZWx0YS4kaW5jIHx8IHt9O1xuICAgICAgZGVsdGEuJGluY1trZXldID0gMTtcbiAgICB9XG4gIH1cbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gaW5jcmVtZW50KCkge1xuICB0aGlzLiRfXy52ZXJzaW9uID0gVkVSU0lPTl9BTEw7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIFNpZ25hbCB0aGF0IHdlIGRlc2lyZSBhbiBpbmNyZW1lbnQgb2YgdGhpcyBkb2N1bWVudHMgdmVyc2lvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGRvYyA9IGF3YWl0IE1vZGVsLmZpbmRCeUlkKGlkKTtcbiAqICAgICBkb2MuaW5jcmVtZW50KCk7XG4gKiAgICAgYXdhaXQgZG9jLnNhdmUoKTtcbiAqXG4gKiBAc2VlIHZlcnNpb25LZXlzIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3ZlcnNpb25LZXlcbiAqIEBtZW1iZXJPZiBNb2RlbFxuICogQG1ldGhvZCBpbmNyZW1lbnRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwucHJvdG90eXBlLmluY3JlbWVudCA9IGluY3JlbWVudDtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcXVlcnkgb2JqZWN0XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKiBAbWV0aG9kICRfX3doZXJlXG4gKiBAbWVtYmVyT2YgTW9kZWxcbiAqIEBpbnN0YW5jZVxuICovXG5cbk1vZGVsLnByb3RvdHlwZS4kX193aGVyZSA9IGZ1bmN0aW9uIF93aGVyZSh3aGVyZSkge1xuICB3aGVyZSB8fCAod2hlcmUgPSB7fSk7XG5cbiAgaWYgKCF3aGVyZS5faWQpIHtcbiAgICB3aGVyZS5faWQgPSB0aGlzLl9kb2MuX2lkO1xuICB9XG5cbiAgaWYgKHRoaXMuX2RvYy5faWQgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBuZXcgTW9uZ29vc2VFcnJvcignTm8gX2lkIGZvdW5kIG9uIGRvY3VtZW50IScpO1xuICB9XG5cbiAgcmV0dXJuIHdoZXJlO1xufTtcblxuLyoqXG4gKiBEZWxldGUgdGhpcyBkb2N1bWVudCBmcm9tIHRoZSBkYi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGF3YWl0IHByb2R1Y3QuZGVsZXRlT25lKCk7XG4gKiAgICAgYXdhaXQgUHJvZHVjdC5maW5kQnlJZChwcm9kdWN0Ll9pZCk7IC8vIG51bGxcbiAqXG4gKiBAcmV0dXJuIHtRdWVyeX0gUXVlcnlcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwucHJvdG90eXBlLmRlbGV0ZU9uZSA9IGZ1bmN0aW9uIGRlbGV0ZU9uZShvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5wcm90b3R5cGUuZGVsZXRlT25lKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3Nlc3Npb24nKSkge1xuICAgIHRoaXMuJHNlc3Npb24ob3B0aW9ucy5zZXNzaW9uKTtcbiAgfVxuXG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuICBjb25zdCB3aGVyZSA9IHRoaXMuJF9fd2hlcmUoKTtcbiAgaWYgKHdoZXJlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICB0aHJvdyB3aGVyZTtcbiAgfVxuICBjb25zdCBxdWVyeSA9IHNlbGYuY29uc3RydWN0b3IuZGVsZXRlT25lKHdoZXJlLCBvcHRpb25zKTtcblxuICBpZiAodGhpcy4kc2Vzc2lvbigpICE9IG51bGwpIHtcbiAgICBpZiAoISgnc2Vzc2lvbicgaW4gcXVlcnkub3B0aW9ucykpIHtcbiAgICAgIHF1ZXJ5Lm9wdGlvbnMuc2Vzc2lvbiA9IHRoaXMuJHNlc3Npb24oKTtcbiAgICB9XG4gIH1cblxuICBxdWVyeS5wcmUoZnVuY3Rpb24gcXVlcnlQcmVEZWxldGVPbmUoY2IpIHtcbiAgICBzZWxmLmNvbnN0cnVjdG9yLl9taWRkbGV3YXJlLmV4ZWNQcmUoJ2RlbGV0ZU9uZScsIHNlbGYsIFtzZWxmXSwgY2IpO1xuICB9KTtcbiAgcXVlcnkucHJlKGZ1bmN0aW9uIGNhbGxTdWJkb2NQcmVIb29rcyhjYikge1xuICAgIGVhY2goc2VsZi4kZ2V0QWxsU3ViZG9jcygpLCAoc3ViZG9jLCBjYikgPT4ge1xuICAgICAgc3ViZG9jLmNvbnN0cnVjdG9yLl9taWRkbGV3YXJlLmV4ZWNQcmUoJ2RlbGV0ZU9uZScsIHN1YmRvYywgW3N1YmRvY10sIGNiKTtcbiAgICB9LCBjYik7XG4gIH0pO1xuICBxdWVyeS5wcmUoZnVuY3Rpb24gc2tpcElmQWxyZWFkeURlbGV0ZWQoY2IpIHtcbiAgICBpZiAoc2VsZi4kX18uaXNEZWxldGVkKSB7XG4gICAgICByZXR1cm4gY2IoS2FyZWVtLnNraXBXcmFwcGVkRnVuY3Rpb24oKSk7XG4gICAgfVxuICAgIHJldHVybiBjYigpO1xuICB9KTtcbiAgcXVlcnkucG9zdChmdW5jdGlvbiBjYWxsU3ViZG9jUG9zdEhvb2tzKGNiKSB7XG4gICAgZWFjaChzZWxmLiRnZXRBbGxTdWJkb2NzKCksIChzdWJkb2MsIGNiKSA9PiB7XG4gICAgICBzdWJkb2MuY29uc3RydWN0b3IuX21pZGRsZXdhcmUuZXhlY1Bvc3QoJ2RlbGV0ZU9uZScsIHN1YmRvYywgW3N1YmRvY10sIHt9LCBjYik7XG4gICAgfSwgY2IpO1xuICB9KTtcbiAgcXVlcnkucG9zdChmdW5jdGlvbiBxdWVyeVBvc3REZWxldGVPbmUoY2IpIHtcbiAgICBzZWxmLmNvbnN0cnVjdG9yLl9taWRkbGV3YXJlLmV4ZWNQb3N0KCdkZWxldGVPbmUnLCBzZWxmLCBbc2VsZl0sIHt9LCBjYik7XG4gIH0pO1xuXG4gIHJldHVybiBxdWVyeTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbW9kZWwgaW5zdGFuY2UgdXNlZCB0byBjcmVhdGUgdGhpcyBkb2N1bWVudCBpZiBubyBgbmFtZWAgc3BlY2lmaWVkLlxuICogSWYgYG5hbWVgIHNwZWNpZmllZCwgcmV0dXJucyB0aGUgbW9kZWwgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgZG9jID0gbmV3IFRhbmsoe30pO1xuICogICAgIGRvYy4kbW9kZWwoKSA9PT0gVGFuazsgLy8gdHJ1ZVxuICogICAgIGF3YWl0IGRvYy4kbW9kZWwoJ1VzZXInKS5maW5kQnlJZChpZCk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lXSBtb2RlbCBuYW1lXG4gKiBAbWV0aG9kICRtb2RlbFxuICogQGFwaSBwdWJsaWNcbiAqIEByZXR1cm4ge01vZGVsfVxuICovXG5cbk1vZGVsLnByb3RvdHlwZS4kbW9kZWwgPSBmdW5jdGlvbiAkbW9kZWwobmFtZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yO1xuICB9XG4gIHJldHVybiB0aGlzW21vZGVsRGJTeW1ib2xdLm1vZGVsKG5hbWUpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtb2RlbCBpbnN0YW5jZSB1c2VkIHRvIGNyZWF0ZSB0aGlzIGRvY3VtZW50IGlmIG5vIGBuYW1lYCBzcGVjaWZpZWQuXG4gKiBJZiBgbmFtZWAgc3BlY2lmaWVkLCByZXR1cm5zIHRoZSBtb2RlbCB3aXRoIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBkb2MgPSBuZXcgVGFuayh7fSk7XG4gKiAgICAgZG9jLiRtb2RlbCgpID09PSBUYW5rOyAvLyB0cnVlXG4gKiAgICAgYXdhaXQgZG9jLiRtb2RlbCgnVXNlcicpLmZpbmRCeUlkKGlkKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW25hbWVdIG1vZGVsIG5hbWVcbiAqIEBtZXRob2QgbW9kZWxcbiAqIEBhcGkgcHVibGljXG4gKiBAcmV0dXJuIHtNb2RlbH1cbiAqL1xuXG5Nb2RlbC5wcm90b3R5cGUubW9kZWwgPSBNb2RlbC5wcm90b3R5cGUuJG1vZGVsO1xuXG4vKipcbiAqIFJldHVybnMgYSBkb2N1bWVudCB3aXRoIGBfaWRgIG9ubHkgaWYgYXQgbGVhc3Qgb25lIGRvY3VtZW50IGV4aXN0cyBpbiB0aGUgZGF0YWJhc2UgdGhhdCBtYXRjaGVzXG4gKiB0aGUgZ2l2ZW4gYGZpbHRlcmAsIGFuZCBgbnVsbGAgb3RoZXJ3aXNlLlxuICpcbiAqIFVuZGVyIHRoZSBob29kLCBgTXlNb2RlbC5leGlzdHMoeyBhbnN3ZXI6IDQyIH0pYCBpcyBlcXVpdmFsZW50IHRvXG4gKiBgTXlNb2RlbC5maW5kT25lKHsgYW5zd2VyOiA0MiB9KS5zZWxlY3QoeyBfaWQ6IDEgfSkubGVhbigpYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYXdhaXQgQ2hhcmFjdGVyLmRlbGV0ZU1hbnkoe30pO1xuICogICAgIGF3YWl0IENoYXJhY3Rlci5jcmVhdGUoeyBuYW1lOiAnSmVhbi1MdWMgUGljYXJkJyB9KTtcbiAqXG4gKiAgICAgYXdhaXQgQ2hhcmFjdGVyLmV4aXN0cyh7IG5hbWU6IC9waWNhcmQvaSB9KTsgLy8geyBfaWQ6IC4uLiB9XG4gKiAgICAgYXdhaXQgQ2hhcmFjdGVyLmV4aXN0cyh7IG5hbWU6IC9yaWtlci9pIH0pOyAvLyBudWxsXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0cmlnZ2VycyB0aGUgZm9sbG93aW5nIG1pZGRsZXdhcmUuXG4gKlxuICogLSBgZmluZE9uZSgpYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaWx0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgc2VlIFtgUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpKVxuICogQHJldHVybiB7UXVlcnl9XG4gKi9cblxuTW9kZWwuZXhpc3RzID0gZnVuY3Rpb24gZXhpc3RzKGZpbHRlciwgb3B0aW9ucykge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdleGlzdHMnKTtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwuZXhpc3RzKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgY29uc3QgcXVlcnkgPSB0aGlzLmZpbmRPbmUoZmlsdGVyKS5cbiAgICBzZWxlY3QoeyBfaWQ6IDEgfSkuXG4gICAgbGVhbigpLlxuICAgIHNldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgcmV0dXJuIHF1ZXJ5O1xufTtcblxuLyoqXG4gKiBBZGRzIGEgZGlzY3JpbWluYXRvciB0eXBlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgZnVuY3Rpb24gQmFzZVNjaGVtYSgpIHtcbiAqICAgICAgIFNjaGVtYS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICpcbiAqICAgICAgIHRoaXMuYWRkKHtcbiAqICAgICAgICAgbmFtZTogU3RyaW5nLFxuICogICAgICAgICBjcmVhdGVkQXQ6IERhdGVcbiAqICAgICAgIH0pO1xuICogICAgIH1cbiAqICAgICB1dGlsLmluaGVyaXRzKEJhc2VTY2hlbWEsIFNjaGVtYSk7XG4gKlxuICogICAgIGNvbnN0IFBlcnNvblNjaGVtYSA9IG5ldyBCYXNlU2NoZW1hKCk7XG4gKiAgICAgY29uc3QgQm9zc1NjaGVtYSA9IG5ldyBCYXNlU2NoZW1hKHsgZGVwYXJ0bWVudDogU3RyaW5nIH0pO1xuICpcbiAqICAgICBjb25zdCBQZXJzb24gPSBtb25nb29zZS5tb2RlbCgnUGVyc29uJywgUGVyc29uU2NoZW1hKTtcbiAqICAgICBjb25zdCBCb3NzID0gUGVyc29uLmRpc2NyaW1pbmF0b3IoJ0Jvc3MnLCBCb3NzU2NoZW1hKTtcbiAqICAgICBuZXcgQm9zcygpLl9fdDsgLy8gXCJCb3NzXCIuIGBfX3RgIGlzIHRoZSBkZWZhdWx0IGBkaXNjcmltaW5hdG9yS2V5YFxuICpcbiAqICAgICBjb25zdCBlbXBsb3llZVNjaGVtYSA9IG5ldyBTY2hlbWEoeyBib3NzOiBPYmplY3RJZCB9KTtcbiAqICAgICBjb25zdCBFbXBsb3llZSA9IFBlcnNvbi5kaXNjcmltaW5hdG9yKCdFbXBsb3llZScsIGVtcGxveWVlU2NoZW1hLCAnc3RhZmYnKTtcbiAqICAgICBuZXcgRW1wbG95ZWUoKS5fX3Q7IC8vIFwic3RhZmZcIiBiZWNhdXNlIG9mIDNyZCBhcmd1bWVudCBhYm92ZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGRpc2NyaW1pbmF0b3IgbW9kZWwgbmFtZVxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYSBkaXNjcmltaW5hdG9yIG1vZGVsIHNjaGVtYVxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbb3B0aW9uc10gSWYgc3RyaW5nLCBzYW1lIGFzIGBvcHRpb25zLnZhbHVlYC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy52YWx1ZV0gdGhlIHN0cmluZyBzdG9yZWQgaW4gdGhlIGBkaXNjcmltaW5hdG9yS2V5YCBwcm9wZXJ0eS4gSWYgbm90IHNwZWNpZmllZCwgTW9uZ29vc2UgdXNlcyB0aGUgYG5hbWVgIHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2xvbmU9dHJ1ZV0gQnkgZGVmYXVsdCwgYGRpc2NyaW1pbmF0b3IoKWAgY2xvbmVzIHRoZSBnaXZlbiBgc2NoZW1hYC4gU2V0IHRvIGBmYWxzZWAgdG8gc2tpcCBjbG9uaW5nLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vdmVyd3JpdGVNb2RlbHM9ZmFsc2VdIGJ5IGRlZmF1bHQsIE1vbmdvb3NlIGRvZXMgbm90IGFsbG93IHlvdSB0byBkZWZpbmUgYSBkaXNjcmltaW5hdG9yIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBhbm90aGVyIGRpc2NyaW1pbmF0b3IuIFNldCB0aGlzIHRvIGFsbG93IG92ZXJ3cml0aW5nIGRpc2NyaW1pbmF0b3JzIHdpdGggdGhlIHNhbWUgbmFtZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWVyZ2VIb29rcz10cnVlXSBCeSBkZWZhdWx0LCBNb25nb29zZSBtZXJnZXMgdGhlIGJhc2Ugc2NoZW1hJ3MgaG9va3Mgd2l0aCB0aGUgZGlzY3JpbWluYXRvciBzY2hlbWEncyBob29rcy4gU2V0IHRoaXMgb3B0aW9uIHRvIGBmYWxzZWAgdG8gbWFrZSBNb25nb29zZSB1c2UgdGhlIGRpc2NyaW1pbmF0b3Igc2NoZW1hJ3MgaG9va3MgaW5zdGVhZC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWVyZ2VQbHVnaW5zPXRydWVdIEJ5IGRlZmF1bHQsIE1vbmdvb3NlIG1lcmdlcyB0aGUgYmFzZSBzY2hlbWEncyBwbHVnaW5zIHdpdGggdGhlIGRpc2NyaW1pbmF0b3Igc2NoZW1hJ3MgcGx1Z2lucy4gU2V0IHRoaXMgb3B0aW9uIHRvIGBmYWxzZWAgdG8gbWFrZSBNb25nb29zZSB1c2UgdGhlIGRpc2NyaW1pbmF0b3Igc2NoZW1hJ3MgcGx1Z2lucyBpbnN0ZWFkLlxuICogQHJldHVybiB7TW9kZWx9IFRoZSBuZXdseSBjcmVhdGVkIGRpc2NyaW1pbmF0b3IgbW9kZWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwuZGlzY3JpbWluYXRvciA9IGZ1bmN0aW9uKG5hbWUsIHNjaGVtYSwgb3B0aW9ucykge1xuICBsZXQgbW9kZWw7XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG1vZGVsID0gbmFtZTtcbiAgICBuYW1lID0gdXRpbHMuZ2V0RnVuY3Rpb25OYW1lKG1vZGVsKTtcbiAgICBpZiAoIShtb2RlbC5wcm90b3R5cGUgaW5zdGFuY2VvZiBNb2RlbCkpIHtcbiAgICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdUaGUgcHJvdmlkZWQgY2xhc3MgJyArIG5hbWUgKyAnIG11c3QgZXh0ZW5kIE1vZGVsJyk7XG4gICAgfVxuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHZhbHVlID0gdXRpbHMuaXNQT0pPKG9wdGlvbnMpID8gb3B0aW9ucy52YWx1ZSA6IG9wdGlvbnM7XG4gIGNvbnN0IGNsb25lID0gdHlwZW9mIG9wdGlvbnMuY2xvbmUgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuY2xvbmUgOiB0cnVlO1xuICBjb25zdCBtZXJnZVBsdWdpbnMgPSB0eXBlb2Ygb3B0aW9ucy5tZXJnZVBsdWdpbnMgPT09ICdib29sZWFuJyA/IG9wdGlvbnMubWVyZ2VQbHVnaW5zIDogdHJ1ZTtcblxuICBfY2hlY2tDb250ZXh0KHRoaXMsICdkaXNjcmltaW5hdG9yJyk7XG5cbiAgaWYgKHV0aWxzLmlzT2JqZWN0KHNjaGVtYSkgJiYgIXNjaGVtYS5pbnN0YW5jZU9mU2NoZW1hKSB7XG4gICAgc2NoZW1hID0gbmV3IFNjaGVtYShzY2hlbWEpO1xuICB9XG4gIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBTY2hlbWEgJiYgY2xvbmUpIHtcbiAgICBzY2hlbWEgPSBzY2hlbWEuY2xvbmUoKTtcbiAgfVxuXG4gIHNjaGVtYSA9IGRpc2NyaW1pbmF0b3IodGhpcywgbmFtZSwgc2NoZW1hLCB2YWx1ZSwgbWVyZ2VQbHVnaW5zLCBvcHRpb25zLm1lcmdlSG9va3MpO1xuICBpZiAodGhpcy5kYi5tb2RlbHNbbmFtZV0gJiYgIXNjaGVtYS5vcHRpb25zLm92ZXJ3cml0ZU1vZGVscykge1xuICAgIHRocm93IG5ldyBPdmVyd3JpdGVNb2RlbEVycm9yKG5hbWUpO1xuICB9XG5cbiAgc2NoZW1hLiRpc1Jvb3REaXNjcmltaW5hdG9yID0gdHJ1ZTtcbiAgc2NoZW1hLiRnbG9iYWxQbHVnaW5zQXBwbGllZCA9IHRydWU7XG5cbiAgbW9kZWwgPSB0aGlzLmRiLm1vZGVsKG1vZGVsIHx8IG5hbWUsIHNjaGVtYSwgdGhpcy4kX19jb2xsZWN0aW9uLm5hbWUpO1xuICB0aGlzLmRpc2NyaW1pbmF0b3JzW25hbWVdID0gbW9kZWw7XG4gIGNvbnN0IGQgPSB0aGlzLmRpc2NyaW1pbmF0b3JzW25hbWVdO1xuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZC5wcm90b3R5cGUsIHRoaXMucHJvdG90eXBlKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGQsICdiYXNlTW9kZWxOYW1lJywge1xuICAgIHZhbHVlOiB0aGlzLm1vZGVsTmFtZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuXG4gIC8vIGFwcGx5IG1ldGhvZHMgYW5kIHN0YXRpY3NcbiAgYXBwbHlNZXRob2RzKGQsIHNjaGVtYSk7XG4gIGFwcGx5U3RhdGljcyhkLCBzY2hlbWEpO1xuXG4gIGlmICh0aGlzW3N1YmNsYXNzZWRTeW1ib2xdICE9IG51bGwpIHtcbiAgICBmb3IgKGNvbnN0IHN1Ym1vZGVsIG9mIHRoaXNbc3ViY2xhc3NlZFN5bWJvbF0pIHtcbiAgICAgIHN1Ym1vZGVsLmRpc2NyaW1pbmF0b3JzID0gc3VibW9kZWwuZGlzY3JpbWluYXRvcnMgfHwge307XG4gICAgICBzdWJtb2RlbC5kaXNjcmltaW5hdG9yc1tuYW1lXSA9XG4gICAgICAgIG1vZGVsLl9fc3ViY2xhc3MobW9kZWwuZGIsIHNjaGVtYSwgc3VibW9kZWwuY29sbGVjdGlvbi5uYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZDtcbn07XG5cbi8qKlxuICogTWFrZSBzdXJlIGB0aGlzYCBpcyBhIG1vZGVsXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBfY2hlY2tDb250ZXh0KGN0eCwgZm5OYW1lKSB7XG4gIC8vIENoZWNrIGNvbnRleHQsIGJlY2F1c2UgaXQgaXMgZWFzeSB0byBtaXN0YWtlbmx5IHR5cGVcbiAgLy8gYG5ldyBNb2RlbC5kaXNjcmltaW5hdG9yKClgIGFuZCBnZXQgYW4gaW5jb21wcmVoZW5zaWJsZSBlcnJvclxuICBpZiAoY3R4ID09IG51bGwgfHwgY3R4ID09PSBnbG9iYWwpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignYE1vZGVsLicgKyBmbk5hbWUgKyAnKClgIGNhbm5vdCBydW4gd2l0aG91dCBhICcgK1xuICAgICAgJ21vZGVsIGFzIGB0aGlzYC4gTWFrZSBzdXJlIHlvdSBhcmUgY2FsbGluZyBgTXlNb2RlbC4nICsgZm5OYW1lICsgJygpYCAnICtcbiAgICAgICd3aGVyZSBgTXlNb2RlbGAgaXMgYSBNb25nb29zZSBtb2RlbC4nKTtcbiAgfSBlbHNlIGlmIChjdHhbbW9kZWxTeW1ib2xdID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignYE1vZGVsLicgKyBmbk5hbWUgKyAnKClgIGNhbm5vdCBydW4gd2l0aG91dCBhICcgK1xuICAgICAgJ21vZGVsIGFzIGB0aGlzYC4gTWFrZSBzdXJlIHlvdSBhcmUgbm90IGNhbGxpbmcgJyArXG4gICAgICAnYG5ldyBNb2RlbC4nICsgZm5OYW1lICsgJygpYCcpO1xuICB9XG59XG5cbi8vIE1vZGVsIChjbGFzcykgZmVhdHVyZXNcblxuLyohXG4gKiBHaXZlIHRoZSBjb25zdHJ1Y3RvciB0aGUgYWJpbGl0eSB0byBlbWl0IGV2ZW50cy5cbiAqL1xuXG5mb3IgKGNvbnN0IGkgaW4gRXZlbnRFbWl0dGVyLnByb3RvdHlwZSkge1xuICBNb2RlbFtpXSA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGVbaV07XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyByZXNwb25zaWJsZSBmb3IgaW5pdGlhbGl6aW5nIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb24gaW4gTW9uZ29EQiBiYXNlZCBvbiBzY2hlbWEgb3B0aW9ucy5cbiAqIFRoaXMgZnVuY3Rpb24gcGVyZm9ybXMgdGhlIGZvbGxvd2luZyBvcGVyYXRpb25zOlxuICpcbiAqIC0gYGNyZWF0ZUNvbGxlY3Rpb24oKWAgdW5sZXNzIFtgYXV0b0NyZWF0ZWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI2F1dG9DcmVhdGUpIG9wdGlvbiBpcyB0dXJuZWQgb2ZmXG4gKiAtIGBlbnN1cmVJbmRleGVzKClgIHVubGVzcyBbYGF1dG9JbmRleGBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI2F1dG9JbmRleCkgb3B0aW9uIGlzIHR1cm5lZCBvZmZcbiAqIC0gYGNyZWF0ZVNlYXJjaEluZGV4KClgIG9uIGFsbCBzY2hlbWEgc2VhcmNoIGluZGV4ZXMgaWYgYGF1dG9TZWFyY2hJbmRleGAgaXMgZW5hYmxlZC5cbiAqXG4gKiBNb25nb29zZSBjYWxscyB0aGlzIGZ1bmN0aW9uIGF1dG9tYXRpY2FsbHkgd2hlbiBhIG1vZGVsIGlzIGEgY3JlYXRlZCB1c2luZ1xuICogW2Btb25nb29zZS5tb2RlbCgpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb25nb29zZS5odG1sI01vbmdvb3NlLnByb3RvdHlwZS5tb2RlbCgpKSBvclxuICogW2Bjb25uZWN0aW9uLm1vZGVsKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2Nvbm5lY3Rpb24uaHRtbCNDb25uZWN0aW9uLnByb3RvdHlwZS5tb2RlbCgpKSwgc28geW91XG4gKiBkb24ndCBuZWVkIHRvIGNhbGwgYGluaXQoKWAgdG8gdHJpZ2dlciBpbmRleCBidWlsZHMuXG4gKlxuICogSG93ZXZlciwgeW91IF9tYXlfIG5lZWQgdG8gY2FsbCBgaW5pdCgpYCAgdG8gZ2V0IGJhY2sgYSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHdoZW4geW91ciBpbmRleGVzIGFyZSBmaW5pc2hlZC5cbiAqIENhbGxpbmcgYGF3YWl0IE1vZGVsLmluaXQoKWAgaXMgaGVscGZ1bCBpZiB5b3UgbmVlZCB0byB3YWl0IGZvciBpbmRleGVzIHRvIGJ1aWxkIGJlZm9yZSBjb250aW51aW5nLlxuICogRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHdhaXQgZm9yIHVuaXF1ZSBpbmRleGVzIHRvIGJ1aWxkIGJlZm9yZSBjb250aW51aW5nIHdpdGggYSB0ZXN0IGNhc2UuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBldmVudFNjaGVtYSA9IG5ldyBTY2hlbWEoeyB0aGluZzogeyB0eXBlOiAnc3RyaW5nJywgdW5pcXVlOiB0cnVlIH0gfSlcbiAqICAgICAvLyBUaGlzIGNhbGxzIGBFdmVudC5pbml0KClgIGltcGxpY2l0bHksIHNvIHlvdSBkb24ndCBuZWVkIHRvIGNhbGxcbiAqICAgICAvLyBgRXZlbnQuaW5pdCgpYCBvbiB5b3VyIG93bi5cbiAqICAgICBjb25zdCBFdmVudCA9IG1vbmdvb3NlLm1vZGVsKCdFdmVudCcsIGV2ZW50U2NoZW1hKTtcbiAqXG4gKiAgICAgYXdhaXQgRXZlbnQuaW5pdCgpO1xuICogICAgIGNvbnNvbGUubG9nKCdJbmRleGVzIGFyZSBkb25lIGJ1aWxkaW5nIScpO1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAqL1xuXG5Nb2RlbC5pbml0ID0gZnVuY3Rpb24gaW5pdCgpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnaW5pdCcpO1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5pbml0KCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgdGhpcy5zY2hlbWEuZW1pdCgnaW5pdCcsIHRoaXMpO1xuXG4gIGlmICh0aGlzLiRpbml0ICE9IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy4kaW5pdDtcbiAgfVxuXG4gIGNvbnN0IGNvbm4gPSB0aGlzLmRiO1xuICBjb25zdCBfZW5zdXJlSW5kZXhlcyA9IGFzeW5jKCkgPT4ge1xuICAgIGNvbnN0IGF1dG9JbmRleCA9IHV0aWxzLmdldE9wdGlvbihcbiAgICAgICdhdXRvSW5kZXgnLFxuICAgICAgdGhpcy5zY2hlbWEub3B0aW9ucyxcbiAgICAgIGNvbm4uY29uZmlnLFxuICAgICAgY29ubi5iYXNlLm9wdGlvbnNcbiAgICApO1xuICAgIGlmICghYXV0b0luZGV4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB0aGlzLmVuc3VyZUluZGV4ZXMoeyBfYXV0b21hdGljOiB0cnVlIH0pO1xuICB9O1xuICBjb25zdCBfY3JlYXRlU2VhcmNoSW5kZXhlcyA9IGFzeW5jKCkgPT4ge1xuICAgIGNvbnN0IGF1dG9TZWFyY2hJbmRleCA9IHV0aWxzLmdldE9wdGlvbihcbiAgICAgICdhdXRvU2VhcmNoSW5kZXgnLFxuICAgICAgdGhpcy5zY2hlbWEub3B0aW9ucyxcbiAgICAgIGNvbm4uY29uZmlnLFxuICAgICAgY29ubi5iYXNlLm9wdGlvbnNcbiAgICApO1xuICAgIGlmICghYXV0b1NlYXJjaEluZGV4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIGZvciAoY29uc3Qgc2VhcmNoSW5kZXggb2YgdGhpcy5zY2hlbWEuX3NlYXJjaEluZGV4ZXMpIHtcbiAgICAgIHJlc3VsdHMucHVzaChhd2FpdCB0aGlzLmNyZWF0ZVNlYXJjaEluZGV4KHNlYXJjaEluZGV4KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuICBjb25zdCBfY3JlYXRlQ29sbGVjdGlvbiA9IGFzeW5jKCkgPT4ge1xuICAgIGlmICgoY29ubi5yZWFkeVN0YXRlID09PSBTVEFURVMuY29ubmVjdGluZyB8fCBjb25uLnJlYWR5U3RhdGUgPT09IFNUQVRFUy5kaXNjb25uZWN0ZWQpICYmIGNvbm4uX3Nob3VsZEJ1ZmZlckNvbW1hbmRzKCkpIHtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBjb25uLl9xdWV1ZS5wdXNoKHsgZm46IHJlc29sdmUgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgYXV0b0NyZWF0ZSA9IHV0aWxzLmdldE9wdGlvbihcbiAgICAgICdhdXRvQ3JlYXRlJyxcbiAgICAgIHRoaXMuc2NoZW1hLm9wdGlvbnMsXG4gICAgICBjb25uLmNvbmZpZyxcbiAgICAgIGNvbm4uYmFzZS5vcHRpb25zXG4gICAgKTtcbiAgICBpZiAoIWF1dG9DcmVhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuY3JlYXRlQ29sbGVjdGlvbigpO1xuICB9O1xuXG4gIHRoaXMuJGluaXQgPSBfY3JlYXRlQ29sbGVjdGlvbigpLlxuICAgIHRoZW4oKCkgPT4gX2Vuc3VyZUluZGV4ZXMoKSkuXG4gICAgdGhlbigoKSA9PiBfY3JlYXRlU2VhcmNoSW5kZXhlcygpKTtcblxuICBjb25zdCBfY2F0Y2ggPSB0aGlzLiRpbml0LmNhdGNoO1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIHRoaXMuJGluaXQuY2F0Y2ggPSBmdW5jdGlvbigpIHtcbiAgICBfdGhpcy4kY2F1Z2h0ID0gdHJ1ZTtcbiAgICByZXR1cm4gX2NhdGNoLmFwcGx5KF90aGlzLiRpbml0LCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIHJldHVybiB0aGlzLiRpbml0O1xufTtcblxuXG4vKipcbiAqIENyZWF0ZSB0aGUgY29sbGVjdGlvbiBmb3IgdGhpcyBtb2RlbC4gQnkgZGVmYXVsdCwgaWYgbm8gaW5kZXhlcyBhcmUgc3BlY2lmaWVkLFxuICogbW9uZ29vc2Ugd2lsbCBub3QgY3JlYXRlIHRoZSBjb2xsZWN0aW9uIGZvciB0aGUgbW9kZWwgdW50aWwgYW55IGRvY3VtZW50cyBhcmVcbiAqIGNyZWF0ZWQuIFVzZSB0aGlzIG1ldGhvZCB0byBjcmVhdGUgdGhlIGNvbGxlY3Rpb24gZXhwbGljaXRseS5cbiAqXG4gKiBOb3RlIDE6IFlvdSBtYXkgbmVlZCB0byBjYWxsIHRoaXMgYmVmb3JlIHN0YXJ0aW5nIGEgdHJhbnNhY3Rpb25cbiAqIFNlZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9jb3JlL3RyYW5zYWN0aW9ucy8jdHJhbnNhY3Rpb25zLWFuZC1vcGVyYXRpb25zXG4gKlxuICogTm90ZSAyOiBZb3UgZG9uJ3QgaGF2ZSB0byBjYWxsIHRoaXMgaWYgeW91ciBzY2hlbWEgY29udGFpbnMgaW5kZXggb3IgdW5pcXVlIGZpZWxkLlxuICogSW4gdGhhdCBjYXNlLCBqdXN0IHVzZSBgTW9kZWwuaW5pdCgpYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgdXNlclNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSlcbiAqICAgICBjb25zdCBVc2VyID0gbW9uZ29vc2UubW9kZWwoJ1VzZXInLCB1c2VyU2NoZW1hKTtcbiAqXG4gKiAgICAgVXNlci5jcmVhdGVDb2xsZWN0aW9uKCkudGhlbihmdW5jdGlvbihjb2xsZWN0aW9uKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZygnQ29sbGVjdGlvbiBpcyBjcmVhdGVkIScpO1xuICogICAgIH0pO1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIHNlZSBbTW9uZ29EQiBkcml2ZXIgZG9jc10oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0RiLmh0bWwjY3JlYXRlQ29sbGVjdGlvbilcbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICovXG5cbk1vZGVsLmNyZWF0ZUNvbGxlY3Rpb24gPSBhc3luYyBmdW5jdGlvbiBjcmVhdGVDb2xsZWN0aW9uKG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnY3JlYXRlQ29sbGVjdGlvbicpO1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLmNyZWF0ZUNvbGxlY3Rpb24oKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBjb25zdCBzaG91bGRTa2lwID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHRoaXMuaG9va3MuZXhlY1ByZSgnY3JlYXRlQ29sbGVjdGlvbicsIHRoaXMsIFtvcHRpb25zXSwgKGVycikgPT4ge1xuICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBLYXJlZW0uc2tpcFdyYXBwZWRGdW5jdGlvbikge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgY29uc3QgY29sbGVjdGlvbk9wdGlvbnMgPSB0aGlzICYmXG4gICAgdGhpcy5zY2hlbWEgJiZcbiAgICB0aGlzLnNjaGVtYS5vcHRpb25zICYmXG4gICAgdGhpcy5zY2hlbWEub3B0aW9ucy5jb2xsZWN0aW9uT3B0aW9ucztcbiAgaWYgKGNvbGxlY3Rpb25PcHRpb25zICE9IG51bGwpIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgY29sbGVjdGlvbk9wdGlvbnMsIG9wdGlvbnMpO1xuICB9XG5cbiAgY29uc3Qgc2NoZW1hQ29sbGF0aW9uID0gdGhpcyAmJlxuICAgIHRoaXMuc2NoZW1hICYmXG4gICAgdGhpcy5zY2hlbWEub3B0aW9ucyAmJlxuICAgIHRoaXMuc2NoZW1hLm9wdGlvbnMuY29sbGF0aW9uO1xuICBpZiAoc2NoZW1hQ29sbGF0aW9uICE9IG51bGwpIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IGNvbGxhdGlvbjogc2NoZW1hQ29sbGF0aW9uIH0sIG9wdGlvbnMpO1xuICB9XG4gIGNvbnN0IGNhcHBlZCA9IHRoaXMgJiZcbiAgICB0aGlzLnNjaGVtYSAmJlxuICAgIHRoaXMuc2NoZW1hLm9wdGlvbnMgJiZcbiAgICB0aGlzLnNjaGVtYS5vcHRpb25zLmNhcHBlZDtcbiAgaWYgKGNhcHBlZCAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBjYXBwZWQgPT09ICdudW1iZXInKSB7XG4gICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IGNhcHBlZDogdHJ1ZSwgc2l6ZTogY2FwcGVkIH0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNhcHBlZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgY2FwcGVkOiB0cnVlIH0sIGNhcHBlZCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHRpbWVzZXJpZXMgPSB0aGlzICYmXG4gICAgdGhpcy5zY2hlbWEgJiZcbiAgICB0aGlzLnNjaGVtYS5vcHRpb25zICYmXG4gICAgdGhpcy5zY2hlbWEub3B0aW9ucy50aW1lc2VyaWVzO1xuICBpZiAodGltZXNlcmllcyAhPSBudWxsKSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyB0aW1lc2VyaWVzIH0sIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmV4cGlyZUFmdGVyU2Vjb25kcyAhPSBudWxsKSB7XG4gICAgICAvLyBkbyBub3RoaW5nXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmV4cGlyZXMgIT0gbnVsbCkge1xuICAgICAgdXRpbHMuZXhwaXJlcyhvcHRpb25zKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2NoZW1hLm9wdGlvbnMuZXhwaXJlQWZ0ZXJTZWNvbmRzICE9IG51bGwpIHtcbiAgICAgIG9wdGlvbnMuZXhwaXJlQWZ0ZXJTZWNvbmRzID0gdGhpcy5zY2hlbWEub3B0aW9ucy5leHBpcmVBZnRlclNlY29uZHM7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNjaGVtYS5vcHRpb25zLmV4cGlyZXMgIT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy5leHBpcmVzID0gdGhpcy5zY2hlbWEub3B0aW9ucy5leHBpcmVzO1xuICAgICAgdXRpbHMuZXhwaXJlcyhvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBjbHVzdGVyZWRJbmRleCA9IHRoaXMgJiZcbiAgICB0aGlzLnNjaGVtYSAmJlxuICAgIHRoaXMuc2NoZW1hLm9wdGlvbnMgJiZcbiAgICB0aGlzLnNjaGVtYS5vcHRpb25zLmNsdXN0ZXJlZEluZGV4O1xuICBpZiAoY2x1c3RlcmVkSW5kZXggIT0gbnVsbCkge1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgY2x1c3RlcmVkSW5kZXg6IHsgLi4uY2x1c3RlcmVkSW5kZXgsIHVuaXF1ZTogdHJ1ZSB9IH0sIG9wdGlvbnMpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAoIXNob3VsZFNraXApIHtcbiAgICAgIGF3YWl0IHRoaXMuZGIuY3JlYXRlQ29sbGVjdGlvbih0aGlzLiRfX2NvbGxlY3Rpb24uY29sbGVjdGlvbk5hbWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyciAhPSBudWxsICYmIChlcnIubmFtZSAhPT0gJ01vbmdvU2VydmVyRXJyb3InIHx8IGVyci5jb2RlICE9PSA0OCkpIHtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgX29wdHMgPSB7IGVycm9yOiBlcnIgfTtcbiAgICAgICAgdGhpcy5ob29rcy5leGVjUG9zdCgnY3JlYXRlQ29sbGVjdGlvbicsIHRoaXMsIFtudWxsXSwgX29wdHMsIChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB0aGlzLmhvb2tzLmV4ZWNQb3N0KCdjcmVhdGVDb2xsZWN0aW9uJywgdGhpcywgW3RoaXMuJF9fY29sbGVjdGlvbl0sIChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzLiRfX2NvbGxlY3Rpb247XG59O1xuXG4vKipcbiAqIE1ha2VzIHRoZSBpbmRleGVzIGluIE1vbmdvREIgbWF0Y2ggdGhlIGluZGV4ZXMgZGVmaW5lZCBpbiB0aGlzIG1vZGVsJ3NcbiAqIHNjaGVtYS4gVGhpcyBmdW5jdGlvbiB3aWxsIGRyb3AgYW55IGluZGV4ZXMgdGhhdCBhcmUgbm90IGRlZmluZWQgaW5cbiAqIHRoZSBtb2RlbCdzIHNjaGVtYSBleGNlcHQgdGhlIGBfaWRgIGluZGV4LCBhbmQgYnVpbGQgYW55IGluZGV4ZXMgdGhhdFxuICogYXJlIGluIHlvdXIgc2NoZW1hIGJ1dCBub3QgaW4gTW9uZ29EQi5cbiAqXG4gKiBTZWUgdGhlIFtpbnRyb2R1Y3RvcnkgYmxvZyBwb3N0XShodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tL3doYXRzLW5ldy1pbi1tb25nb29zZS01LTItc3luY2luZGV4ZXMpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiB7IHR5cGU6IFN0cmluZywgdW5pcXVlOiB0cnVlIH0gfSk7XG4gKiAgICAgY29uc3QgQ3VzdG9tZXIgPSBtb25nb29zZS5tb2RlbCgnQ3VzdG9tZXInLCBzY2hlbWEpO1xuICogICAgIGF3YWl0IEN1c3RvbWVyLmNvbGxlY3Rpb24uY3JlYXRlSW5kZXgoeyBhZ2U6IDEgfSk7IC8vIEluZGV4IGlzIG5vdCBpbiBzY2hlbWFcbiAqICAgICAvLyBXaWxsIGRyb3AgdGhlICdhZ2UnIGluZGV4IGFuZCBjcmVhdGUgYW4gaW5kZXggb24gYG5hbWVgXG4gKiAgICAgYXdhaXQgQ3VzdG9tZXIuc3luY0luZGV4ZXMoKTtcbiAqXG4gKiBZb3Ugc2hvdWxkIGJlIGNhcmVmdWwgYWJvdXQgcnVubmluZyBgc3luY0luZGV4ZXMoKWAgb24gcHJvZHVjdGlvbiBhcHBsaWNhdGlvbnMgdW5kZXIgaGVhdnkgbG9hZCxcbiAqIGJlY2F1c2UgaW5kZXggYnVpbGRzIGFyZSBleHBlbnNpdmUgb3BlcmF0aW9ucywgYW5kIHVuZXhwZWN0ZWQgaW5kZXggZHJvcHMgY2FuIGxlYWQgdG8gZGVncmFkZWRcbiAqIHBlcmZvcm1hbmNlLiBCZWZvcmUgcnVubmluZyBgc3luY0luZGV4ZXMoKWAsIHlvdSBjYW4gdXNlIHRoZSBbYGRpZmZJbmRleGVzKClgIGZ1bmN0aW9uXSgjTW9kZWwuZGlmZkluZGV4ZXMoKSlcbiAqIHRvIGNoZWNrIHdoYXQgaW5kZXhlcyBgc3luY0luZGV4ZXMoKWAgd2lsbCBkcm9wIGFuZCBjcmVhdGUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCB7IHRvRHJvcCwgdG9DcmVhdGUgfSA9IGF3YWl0IE1vZGVsLmRpZmZJbmRleGVzKCk7XG4gKiAgICAgdG9Ecm9wOyAvLyBBcnJheSBvZiBzdHJpbmdzIGNvbnRhaW5pbmcgbmFtZXMgb2YgaW5kZXhlcyB0aGF0IGBzeW5jSW5kZXhlcygpYCB3aWxsIGRyb3BcbiAqICAgICB0b0NyZWF0ZTsgLy8gQXJyYXkgb2Ygc3RyaW5ncyBjb250YWluaW5nIG5hbWVzIG9mIGluZGV4ZXMgdGhhdCBgc3luY0luZGV4ZXMoKWAgd2lsbCBjcmVhdGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbnMgdG8gcGFzcyB0byBgZW5zdXJlSW5kZXhlcygpYFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5iYWNrZ3JvdW5kPW51bGxdIGlmIHNwZWNpZmllZCwgb3ZlcnJpZGVzIGVhY2ggaW5kZXgncyBgYmFja2dyb3VuZGAgcHJvcGVydHlcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLnN5bmNJbmRleGVzID0gYXN5bmMgZnVuY3Rpb24gc3luY0luZGV4ZXMob3B0aW9ucykge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdzeW5jSW5kZXhlcycpO1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLnN5bmNJbmRleGVzKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgY29uc3QgbW9kZWwgPSB0aGlzO1xuXG4gIHRyeSB7XG4gICAgYXdhaXQgbW9kZWwuY3JlYXRlQ29sbGVjdGlvbigpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyICE9IG51bGwgJiYgKGVyci5uYW1lICE9PSAnTW9uZ29TZXJ2ZXJFcnJvcicgfHwgZXJyLmNvZGUgIT09IDQ4KSkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGRpZmZJbmRleGVzUmVzdWx0ID0gYXdhaXQgbW9kZWwuZGlmZkluZGV4ZXMoKTtcbiAgY29uc3QgZHJvcHBlZCA9IGF3YWl0IG1vZGVsLmNsZWFuSW5kZXhlcyh7IC4uLm9wdGlvbnMsIHRvRHJvcDogZGlmZkluZGV4ZXNSZXN1bHQudG9Ecm9wIH0pO1xuICBhd2FpdCBtb2RlbC5jcmVhdGVJbmRleGVzKHsgLi4ub3B0aW9ucywgdG9DcmVhdGU6IGRpZmZJbmRleGVzUmVzdWx0LnRvQ3JlYXRlIH0pO1xuXG4gIHJldHVybiBkcm9wcGVkO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gW0F0bGFzIHNlYXJjaCBpbmRleF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9hdGxhcy9hdGxhcy1zZWFyY2gvY3JlYXRlLWluZGV4LykuXG4gKiBUaGlzIGZ1bmN0aW9uIG9ubHkgd29ya3Mgd2hlbiBjb25uZWN0ZWQgdG8gTW9uZ29EQiBBdGxhcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiB7IHR5cGU6IFN0cmluZywgdW5pcXVlOiB0cnVlIH0gfSk7XG4gKiAgICAgY29uc3QgQ3VzdG9tZXIgPSBtb25nb29zZS5tb2RlbCgnQ3VzdG9tZXInLCBzY2hlbWEpO1xuICogICAgIGF3YWl0IEN1c3RvbWVyLmNyZWF0ZVNlYXJjaEluZGV4KHsgbmFtZTogJ3Rlc3QnLCBkZWZpbml0aW9uOiB7IG1hcHBpbmdzOiB7IGR5bmFtaWM6IHRydWUgfSB9IH0pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXNjcmlwdGlvbiBpbmRleCBvcHRpb25zLCBpbmNsdWRpbmcgYG5hbWVgIGFuZCBgZGVmaW5pdGlvbmBcbiAqIEBwYXJhbSB7U3RyaW5nfSBkZXNjcmlwdGlvbi5uYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzY3JpcHRpb24uZGVmaW5pdGlvblxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwuY3JlYXRlU2VhcmNoSW5kZXggPSBhc3luYyBmdW5jdGlvbiBjcmVhdGVTZWFyY2hJbmRleChkZXNjcmlwdGlvbikge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdjcmVhdGVTZWFyY2hJbmRleCcpO1xuXG4gIHJldHVybiBhd2FpdCB0aGlzLiRfX2NvbGxlY3Rpb24uY3JlYXRlU2VhcmNoSW5kZXgoZGVzY3JpcHRpb24pO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgYW4gZXhpc3RpbmcgW0F0bGFzIHNlYXJjaCBpbmRleF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9hdGxhcy9hdGxhcy1zZWFyY2gvY3JlYXRlLWluZGV4LykuXG4gKiBUaGlzIGZ1bmN0aW9uIG9ubHkgd29ya3Mgd2hlbiBjb25uZWN0ZWQgdG8gTW9uZ29EQiBBdGxhcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiB7IHR5cGU6IFN0cmluZywgdW5pcXVlOiB0cnVlIH0gfSk7XG4gKiAgICAgY29uc3QgQ3VzdG9tZXIgPSBtb25nb29zZS5tb2RlbCgnQ3VzdG9tZXInLCBzY2hlbWEpO1xuICogICAgIGF3YWl0IEN1c3RvbWVyLnVwZGF0ZVNlYXJjaEluZGV4KCd0ZXN0JywgeyBtYXBwaW5nczogeyBkeW5hbWljOiB0cnVlIH0gfSk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZpbml0aW9uXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC51cGRhdGVTZWFyY2hJbmRleCA9IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVNlYXJjaEluZGV4KG5hbWUsIGRlZmluaXRpb24pIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAndXBkYXRlU2VhcmNoSW5kZXgnKTtcblxuICByZXR1cm4gYXdhaXQgdGhpcy4kX19jb2xsZWN0aW9uLnVwZGF0ZVNlYXJjaEluZGV4KG5hbWUsIGRlZmluaXRpb24pO1xufTtcblxuLyoqXG4gKiBEZWxldGUgYW4gZXhpc3RpbmcgW0F0bGFzIHNlYXJjaCBpbmRleF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9hdGxhcy9hdGxhcy1zZWFyY2gvY3JlYXRlLWluZGV4LykgYnkgbmFtZS5cbiAqIFRoaXMgZnVuY3Rpb24gb25seSB3b3JrcyB3aGVuIGNvbm5lY3RlZCB0byBNb25nb0RCIEF0bGFzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IG5hbWU6IHsgdHlwZTogU3RyaW5nLCB1bmlxdWU6IHRydWUgfSB9KTtcbiAqICAgICBjb25zdCBDdXN0b21lciA9IG1vbmdvb3NlLm1vZGVsKCdDdXN0b21lcicsIHNjaGVtYSk7XG4gKiAgICAgYXdhaXQgQ3VzdG9tZXIuZHJvcFNlYXJjaEluZGV4KCd0ZXN0Jyk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmRyb3BTZWFyY2hJbmRleCA9IGFzeW5jIGZ1bmN0aW9uIGRyb3BTZWFyY2hJbmRleChuYW1lKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2Ryb3BTZWFyY2hJbmRleCcpO1xuXG4gIHJldHVybiBhd2FpdCB0aGlzLiRfX2NvbGxlY3Rpb24uZHJvcFNlYXJjaEluZGV4KG5hbWUpO1xufTtcblxuLyoqXG4gKiBEb2VzIGEgZHJ5LXJ1biBvZiBgTW9kZWwuc3luY0luZGV4ZXMoKWAsIHJldHVybmluZyB0aGUgaW5kZXhlcyB0aGF0IGBzeW5jSW5kZXhlcygpYCB3b3VsZCBkcm9wIGFuZCBjcmVhdGUgaWYgeW91IHdlcmUgdG8gcnVuIGBzeW5jSW5kZXhlcygpYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHsgdG9Ecm9wLCB0b0NyZWF0ZSB9ID0gYXdhaXQgTW9kZWwuZGlmZkluZGV4ZXMoKTtcbiAqICAgICB0b0Ryb3A7IC8vIEFycmF5IG9mIHN0cmluZ3MgY29udGFpbmluZyBuYW1lcyBvZiBpbmRleGVzIHRoYXQgYHN5bmNJbmRleGVzKClgIHdpbGwgZHJvcFxuICogICAgIHRvQ3JlYXRlOyAvLyBBcnJheSBvZiBzdHJpbmdzIGNvbnRhaW5pbmcgbmFtZXMgb2YgaW5kZXhlcyB0aGF0IGBzeW5jSW5kZXhlcygpYCB3aWxsIGNyZWF0ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0Pn0gY29udGFpbnMgdGhlIGluZGV4ZXMgdGhhdCB3b3VsZCBiZSBkcm9wcGVkIGluIE1vbmdvREIgYW5kIGluZGV4ZXMgdGhhdCB3b3VsZCBiZSBjcmVhdGVkIGluIE1vbmdvREIgYXMgYHsgdG9Ecm9wOiBzdHJpbmdbXSwgdG9DcmVhdGU6IHN0cmluZ1tdIH1gLlxuICovXG5cbk1vZGVsLmRpZmZJbmRleGVzID0gYXN5bmMgZnVuY3Rpb24gZGlmZkluZGV4ZXMoKSB7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwuc3luY0luZGV4ZXMoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBjb25zdCBtb2RlbCA9IHRoaXM7XG5cbiAgbGV0IGRiSW5kZXhlcyA9IGF3YWl0IG1vZGVsLmxpc3RJbmRleGVzKCkuY2F0Y2goZXJyID0+IHtcbiAgICBpZiAoZXJyLmNvZGVOYW1lID09ICdOYW1lc3BhY2VOb3RGb3VuZCcpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRocm93IGVycjtcbiAgfSk7XG4gIGlmIChkYkluZGV4ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgIGRiSW5kZXhlcyA9IFtdO1xuICB9XG4gIGRiSW5kZXhlcyA9IGdldFJlbGF0ZWREQkluZGV4ZXMobW9kZWwsIGRiSW5kZXhlcyk7XG5cbiAgY29uc3Qgc2NoZW1hID0gbW9kZWwuc2NoZW1hO1xuICBjb25zdCBzY2hlbWFJbmRleGVzID0gZ2V0UmVsYXRlZFNjaGVtYUluZGV4ZXMobW9kZWwsIHNjaGVtYS5pbmRleGVzKCkpO1xuXG4gIGNvbnN0IHRvRHJvcCA9IGdldEluZGV4ZXNUb0Ryb3Aoc2NoZW1hLCBzY2hlbWFJbmRleGVzLCBkYkluZGV4ZXMpO1xuICBjb25zdCB0b0NyZWF0ZSA9IGdldEluZGV4ZXNUb0NyZWF0ZShzY2hlbWEsIHNjaGVtYUluZGV4ZXMsIGRiSW5kZXhlcywgdG9Ecm9wKTtcblxuICByZXR1cm4geyB0b0Ryb3AsIHRvQ3JlYXRlIH07XG59O1xuXG5mdW5jdGlvbiBnZXRJbmRleGVzVG9DcmVhdGUoc2NoZW1hLCBzY2hlbWFJbmRleGVzLCBkYkluZGV4ZXMsIHRvRHJvcCkge1xuICBjb25zdCB0b0NyZWF0ZSA9IFtdO1xuXG4gIGZvciAoY29uc3QgW3NjaGVtYUluZGV4S2V5c09iamVjdCwgc2NoZW1hSW5kZXhPcHRpb25zXSBvZiBzY2hlbWFJbmRleGVzKSB7XG4gICAgbGV0IGZvdW5kID0gZmFsc2U7XG5cbiAgICBjb25zdCBvcHRpb25zID0gZGVjb3JhdGVEaXNjcmltaW5hdG9ySW5kZXhPcHRpb25zKHNjaGVtYSwgY2xvbmUoc2NoZW1hSW5kZXhPcHRpb25zKSk7XG5cbiAgICBmb3IgKGNvbnN0IGluZGV4IG9mIGRiSW5kZXhlcykge1xuICAgICAgaWYgKGlzRGVmYXVsdElkSW5kZXgoaW5kZXgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICBpc0luZGV4RXF1YWwoc2NoZW1hSW5kZXhLZXlzT2JqZWN0LCBvcHRpb25zLCBpbmRleCkgJiZcbiAgICAgICAgIXRvRHJvcC5pbmNsdWRlcyhpbmRleC5uYW1lKVxuICAgICAgKSB7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFmb3VuZCkge1xuICAgICAgdG9DcmVhdGUucHVzaChzY2hlbWFJbmRleEtleXNPYmplY3QpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0b0NyZWF0ZTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5kZXhlc1RvRHJvcChzY2hlbWEsIHNjaGVtYUluZGV4ZXMsIGRiSW5kZXhlcykge1xuICBjb25zdCB0b0Ryb3AgPSBbXTtcblxuICBmb3IgKGNvbnN0IGRiSW5kZXggb2YgZGJJbmRleGVzKSB7XG4gICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgLy8gTmV2ZXIgdHJ5IHRvIGRyb3AgYF9pZGAgaW5kZXgsIE1vbmdvREIgc2VydmVyIGRvZXNuJ3QgYWxsb3cgaXRcbiAgICBpZiAoaXNEZWZhdWx0SWRJbmRleChkYkluZGV4KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBbc2NoZW1hSW5kZXhLZXlzT2JqZWN0LCBzY2hlbWFJbmRleE9wdGlvbnNdIG9mIHNjaGVtYUluZGV4ZXMpIHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBkZWNvcmF0ZURpc2NyaW1pbmF0b3JJbmRleE9wdGlvbnMoc2NoZW1hLCBjbG9uZShzY2hlbWFJbmRleE9wdGlvbnMpKTtcbiAgICAgIGFwcGx5U2NoZW1hQ29sbGF0aW9uKHNjaGVtYUluZGV4S2V5c09iamVjdCwgb3B0aW9ucywgc2NoZW1hLm9wdGlvbnMpO1xuXG4gICAgICBpZiAoaXNJbmRleEVxdWFsKHNjaGVtYUluZGV4S2V5c09iamVjdCwgb3B0aW9ucywgZGJJbmRleCkpIHtcbiAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWZvdW5kKSB7XG4gICAgICB0b0Ryb3AucHVzaChkYkluZGV4Lm5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0b0Ryb3A7XG59XG4vKipcbiAqIERlbGV0ZXMgYWxsIGluZGV4ZXMgdGhhdCBhcmVuJ3QgZGVmaW5lZCBpbiB0aGlzIG1vZGVsJ3Mgc2NoZW1hLiBVc2VkIGJ5XG4gKiBgc3luY0luZGV4ZXMoKWAuXG4gKlxuICogVGhlIHJldHVybmVkIHByb21pc2UgcmVzb2x2ZXMgdG8gYSBsaXN0IG9mIHRoZSBkcm9wcGVkIGluZGV4ZXMnIG5hbWVzIGFzIGFuIGFycmF5XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBvcHRpb25hbCBjYWxsYmFja1xuICogQHJldHVybiB7UHJvbWlzZXx1bmRlZmluZWR9IFJldHVybnMgYHVuZGVmaW5lZGAgaWYgY2FsbGJhY2sgaXMgc3BlY2lmaWVkLCByZXR1cm5zIGEgcHJvbWlzZSBpZiBubyBjYWxsYmFjay5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwuY2xlYW5JbmRleGVzID0gYXN5bmMgZnVuY3Rpb24gY2xlYW5JbmRleGVzKG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnY2xlYW5JbmRleGVzJyk7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwuY2xlYW5JbmRleGVzKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG4gIGNvbnN0IG1vZGVsID0gdGhpcztcblxuICBjb25zdCBjb2xsZWN0aW9uID0gbW9kZWwuJF9fY29sbGVjdGlvbjtcblxuICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zICYmIG9wdGlvbnMudG9Ecm9wKSkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IF9kcm9wSW5kZXhlcyhvcHRpb25zLnRvRHJvcCwgY29sbGVjdGlvbik7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIGNvbnN0IHJlcyA9IGF3YWl0IG1vZGVsLmRpZmZJbmRleGVzKCk7XG4gIHJldHVybiBhd2FpdCBfZHJvcEluZGV4ZXMocmVzLnRvRHJvcCwgY29sbGVjdGlvbik7XG59O1xuXG5hc3luYyBmdW5jdGlvbiBfZHJvcEluZGV4ZXModG9Ecm9wLCBjb2xsZWN0aW9uKSB7XG4gIGlmICh0b0Ryb3AubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgYXdhaXQgUHJvbWlzZS5hbGwodG9Ecm9wLm1hcChpbmRleE5hbWUgPT4gY29sbGVjdGlvbi5kcm9wSW5kZXgoaW5kZXhOYW1lKSkpO1xuICByZXR1cm4gdG9Ecm9wO1xufVxuXG4vKipcbiAqIExpc3RzIHRoZSBpbmRleGVzIGN1cnJlbnRseSBkZWZpbmVkIGluIE1vbmdvREIuIFRoaXMgbWF5IG9yIG1heSBub3QgYmVcbiAqIHRoZSBzYW1lIGFzIHRoZSBpbmRleGVzIGRlZmluZWQgaW4geW91ciBzY2hlbWEgZGVwZW5kaW5nIG9uIHdoZXRoZXIgeW91XG4gKiB1c2UgdGhlIFtgYXV0b0luZGV4YCBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI2F1dG9JbmRleCkgYW5kIGlmIHlvdVxuICogYnVpbGQgaW5kZXhlcyBtYW51YWxseS5cbiAqXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5saXN0SW5kZXhlcyA9IGFzeW5jIGZ1bmN0aW9uIGxpc3RJbmRleGVzKCkge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdsaXN0SW5kZXhlcycpO1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5saXN0SW5kZXhlcygpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGlmICh0aGlzLiRfX2NvbGxlY3Rpb24uYnVmZmVyKSB7XG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLiRfX2NvbGxlY3Rpb24uYWRkUXVldWUocmVzb2x2ZSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGhpcy4kX19jb2xsZWN0aW9uLmxpc3RJbmRleGVzKCkudG9BcnJheSgpO1xufTtcblxuLyoqXG4gKiBTZW5kcyBgY3JlYXRlSW5kZXhgIGNvbW1hbmRzIHRvIG1vbmdvIGZvciBlYWNoIGluZGV4IGRlY2xhcmVkIGluIHRoZSBzY2hlbWEuXG4gKiBUaGUgYGNyZWF0ZUluZGV4YCBjb21tYW5kcyBhcmUgc2VudCBpbiBzZXJpZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhd2FpdCBFdmVudC5lbnN1cmVJbmRleGVzKCk7XG4gKlxuICogQWZ0ZXIgY29tcGxldGlvbiwgYW4gYGluZGV4YCBldmVudCBpcyBlbWl0dGVkIG9uIHRoaXMgYE1vZGVsYCBwYXNzaW5nIGFuIGVycm9yIGlmIG9uZSBvY2N1cnJlZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGV2ZW50U2NoZW1hID0gbmV3IFNjaGVtYSh7IHRoaW5nOiB7IHR5cGU6ICdzdHJpbmcnLCB1bmlxdWU6IHRydWUgfSB9KVxuICogICAgIGNvbnN0IEV2ZW50ID0gbW9uZ29vc2UubW9kZWwoJ0V2ZW50JywgZXZlbnRTY2hlbWEpO1xuICpcbiAqICAgICBFdmVudC5vbignaW5kZXgnLCBmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgICBpZiAoZXJyKSBjb25zb2xlLmVycm9yKGVycik7IC8vIGVycm9yIG9jY3VycmVkIGR1cmluZyBpbmRleCBjcmVhdGlvblxuICogICAgIH0pO1xuICpcbiAqIF9OT1RFOiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdGhhdCB5b3UgcnVuIHRoaXMgaW4gcHJvZHVjdGlvbi4gSW5kZXggY3JlYXRpb24gbWF5IGltcGFjdCBkYXRhYmFzZSBwZXJmb3JtYW5jZSBkZXBlbmRpbmcgb24geW91ciBsb2FkLiBVc2Ugd2l0aCBjYXV0aW9uLl9cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIGludGVybmFsIG9wdGlvbnNcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmVuc3VyZUluZGV4ZXMgPSBhc3luYyBmdW5jdGlvbiBlbnN1cmVJbmRleGVzKG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnZW5zdXJlSW5kZXhlcycpO1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLmVuc3VyZUluZGV4ZXMoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgX2Vuc3VyZUluZGV4ZXModGhpcywgb3B0aW9ucywgKGVycikgPT4ge1xuICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gYGVuc3VyZUluZGV4ZXMoKWAsIGV4Y2VwdCBmb3IgaXQgdXNlcyB0aGUgW2BjcmVhdGVJbmRleGBdKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9EYi5odG1sI2NyZWF0ZUluZGV4KVxuICogZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBpbnRlcm5hbCBvcHRpb25zXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5jcmVhdGVJbmRleGVzID0gYXN5bmMgZnVuY3Rpb24gY3JlYXRlSW5kZXhlcyhvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2NyZWF0ZUluZGV4ZXMnKTtcblxuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLmNyZWF0ZUluZGV4ZXMoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5lbnN1cmVJbmRleGVzKG9wdGlvbnMpO1xufTtcblxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9lbnN1cmVJbmRleGVzKG1vZGVsLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBjb25zdCBpbmRleGVzID0gbW9kZWwuc2NoZW1hLmluZGV4ZXMoKTtcbiAgbGV0IGluZGV4RXJyb3I7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IGRvbmUgPSBmdW5jdGlvbihlcnIpIHtcbiAgICBpZiAoZXJyICYmICFtb2RlbC4kY2F1Z2h0KSB7XG4gICAgICBtb2RlbC5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfVxuICAgIG1vZGVsLmVtaXQoJ2luZGV4JywgZXJyIHx8IGluZGV4RXJyb3IpO1xuICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVyciB8fCBpbmRleEVycm9yKTtcbiAgfTtcblxuICBmb3IgKGNvbnN0IGluZGV4IG9mIGluZGV4ZXMpIHtcbiAgICBpZiAoaXNEZWZhdWx0SWRJbmRleChpbmRleCkpIHtcbiAgICAgIHV0aWxzLndhcm4oJ21vbmdvb3NlOiBDYW5ub3Qgc3BlY2lmeSBhIGN1c3RvbSBpbmRleCBvbiBgX2lkYCBmb3IgJyArXG4gICAgICAgICdtb2RlbCBuYW1lIFwiJyArIG1vZGVsLm1vZGVsTmFtZSArICdcIiwgJyArXG4gICAgICAgICdNb25nb0RCIGRvZXMgbm90IGFsbG93IG92ZXJ3cml0aW5nIHRoZSBkZWZhdWx0IGBfaWRgIGluZGV4LiBTZWUgJyArXG4gICAgICAgICdodHRwczovL2JpdC5seS9tb25nb2RiLWlkLWluZGV4Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFpbmRleGVzLmxlbmd0aCkge1xuICAgIGltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgIGRvbmUoKTtcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gSW5kZXhlcyBhcmUgY3JlYXRlZCBvbmUtYnktb25lIHRvIHN1cHBvcnQgaG93IE1vbmdvREIgPCAyLjQgZGVhbHNcbiAgLy8gd2l0aCBiYWNrZ3JvdW5kIGluZGV4ZXMuXG5cbiAgY29uc3QgaW5kZXhTaW5nbGVEb25lID0gZnVuY3Rpb24oZXJyLCBmaWVsZHMsIG9wdGlvbnMsIG5hbWUpIHtcbiAgICBtb2RlbC5lbWl0KCdpbmRleC1zaW5nbGUtZG9uZScsIGVyciwgZmllbGRzLCBvcHRpb25zLCBuYW1lKTtcbiAgfTtcbiAgY29uc3QgaW5kZXhTaW5nbGVTdGFydCA9IGZ1bmN0aW9uKGZpZWxkcywgb3B0aW9ucykge1xuICAgIG1vZGVsLmVtaXQoJ2luZGV4LXNpbmdsZS1zdGFydCcsIGZpZWxkcywgb3B0aW9ucyk7XG4gIH07XG5cbiAgY29uc3QgYmFzZVNjaGVtYSA9IG1vZGVsLnNjaGVtYS5fYmFzZVNjaGVtYTtcbiAgY29uc3QgYmFzZVNjaGVtYUluZGV4ZXMgPSBiYXNlU2NoZW1hID8gYmFzZVNjaGVtYS5pbmRleGVzKCkgOiBbXTtcblxuICBpbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgLy8gSWYgYnVmZmVyaW5nIGlzIG9mZiwgZG8gdGhpcyBtYW51YWxseS5cbiAgICBpZiAob3B0aW9ucy5fYXV0b21hdGljICYmICFtb2RlbC5jb2xsZWN0aW9uLmNvbGxlY3Rpb24pIHtcbiAgICAgIG1vZGVsLmNvbGxlY3Rpb24uYWRkUXVldWUoY3JlYXRlLCBbXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyZWF0ZSgpO1xuICAgIH1cbiAgfSk7XG5cblxuICBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgaWYgKG9wdGlvbnMuX2F1dG9tYXRpYykge1xuICAgICAgaWYgKG1vZGVsLnNjaGVtYS5vcHRpb25zLmF1dG9JbmRleCA9PT0gZmFsc2UgfHxcbiAgICAgICAgICAobW9kZWwuc2NoZW1hLm9wdGlvbnMuYXV0b0luZGV4ID09IG51bGwgJiYgbW9kZWwuZGIuY29uZmlnLmF1dG9JbmRleCA9PT0gZmFsc2UpKSB7XG4gICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaW5kZXggPSBpbmRleGVzLnNoaWZ0KCk7XG4gICAgaWYgKCFpbmRleCkge1xuICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuX2F1dG9tYXRpYyAmJiBpbmRleFsxXS5fYXV0b0luZGV4ID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZSgpO1xuICAgIH1cblxuICAgIGlmIChiYXNlU2NoZW1hSW5kZXhlcy5maW5kKGkgPT4gdXRpbHMuZGVlcEVxdWFsKGksIGluZGV4KSkpIHtcbiAgICAgIHJldHVybiBjcmVhdGUoKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbmRleEZpZWxkcyA9IGNsb25lKGluZGV4WzBdKTtcbiAgICBjb25zdCBpbmRleE9wdGlvbnMgPSBjbG9uZShpbmRleFsxXSk7XG5cbiAgICBkZWxldGUgaW5kZXhPcHRpb25zLl9hdXRvSW5kZXg7XG4gICAgZGVjb3JhdGVEaXNjcmltaW5hdG9ySW5kZXhPcHRpb25zKG1vZGVsLnNjaGVtYSwgaW5kZXhPcHRpb25zKTtcbiAgICBhcHBseVdyaXRlQ29uY2Vybihtb2RlbC5zY2hlbWEsIGluZGV4T3B0aW9ucyk7XG4gICAgYXBwbHlTY2hlbWFDb2xsYXRpb24oaW5kZXhGaWVsZHMsIGluZGV4T3B0aW9ucywgbW9kZWwuc2NoZW1hLm9wdGlvbnMpO1xuXG4gICAgaW5kZXhTaW5nbGVTdGFydChpbmRleEZpZWxkcywgb3B0aW9ucyk7XG5cbiAgICBpZiAoJ2JhY2tncm91bmQnIGluIG9wdGlvbnMpIHtcbiAgICAgIGluZGV4T3B0aW9ucy5iYWNrZ3JvdW5kID0gb3B0aW9ucy5iYWNrZ3JvdW5kO1xuICAgIH1cblxuICAgIGlmICgndG9DcmVhdGUnIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zLnRvQ3JlYXRlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1vZGVsLmNvbGxlY3Rpb24uY3JlYXRlSW5kZXgoaW5kZXhGaWVsZHMsIGluZGV4T3B0aW9ucykudGhlbihcbiAgICAgIG5hbWUgPT4ge1xuICAgICAgICBpbmRleFNpbmdsZURvbmUobnVsbCwgaW5kZXhGaWVsZHMsIGluZGV4T3B0aW9ucywgbmFtZSk7XG4gICAgICAgIGNyZWF0ZSgpO1xuICAgICAgfSxcbiAgICAgIGVyciA9PiB7XG4gICAgICAgIGlmICghaW5kZXhFcnJvcikge1xuICAgICAgICAgIGluZGV4RXJyb3IgPSBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtb2RlbC4kY2F1Z2h0KSB7XG4gICAgICAgICAgbW9kZWwuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXhTaW5nbGVEb25lKGVyciwgaW5kZXhGaWVsZHMsIGluZGV4T3B0aW9ucyk7XG4gICAgICAgIGNyZWF0ZSgpO1xuICAgICAgfVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBTY2hlbWEgdGhlIG1vZGVsIHVzZXMuXG4gKlxuICogQHByb3BlcnR5IHNjaGVtYVxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBNb2RlbFxuICovXG5cbk1vZGVsLnNjaGVtYTtcblxuLyoqXG4gKiBDb25uZWN0aW9uIGluc3RhbmNlIHRoZSBtb2RlbCB1c2VzLlxuICpcbiAqIEBwcm9wZXJ0eSBkYlxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBNb2RlbFxuICovXG5cbk1vZGVsLmRiO1xuXG4vKipcbiAqIENvbGxlY3Rpb24gdGhlIG1vZGVsIHVzZXMuXG4gKlxuICogQHByb3BlcnR5IGNvbGxlY3Rpb25cbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgTW9kZWxcbiAqL1xuXG5Nb2RlbC5jb2xsZWN0aW9uO1xuXG4vKipcbiAqIEludGVybmFsIGNvbGxlY3Rpb24gdGhlIG1vZGVsIHVzZXMuXG4gKlxuICogQHByb3BlcnR5IGNvbGxlY3Rpb25cbiAqIEBhcGkgcHJpdmF0ZVxuICogQG1lbWJlck9mIE1vZGVsXG4gKi9cbk1vZGVsLiRfX2NvbGxlY3Rpb247XG5cbi8qKlxuICogQmFzZSBNb25nb29zZSBpbnN0YW5jZSB0aGUgbW9kZWwgdXNlcy5cbiAqXG4gKiBAcHJvcGVydHkgYmFzZVxuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBNb2RlbFxuICovXG5cbk1vZGVsLmJhc2U7XG5cbi8qKlxuICogUmVnaXN0ZXJlZCBkaXNjcmltaW5hdG9ycyBmb3IgdGhpcyBtb2RlbC5cbiAqXG4gKiBAcHJvcGVydHkgZGlzY3JpbWluYXRvcnNcbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgTW9kZWxcbiAqL1xuXG5Nb2RlbC5kaXNjcmltaW5hdG9ycztcblxuLyoqXG4gKiBUcmFuc2xhdGUgYW55IGFsaWFzZXMgZmllbGRzL2NvbmRpdGlvbnMgc28gdGhlIGZpbmFsIHF1ZXJ5IG9yIGRvY3VtZW50IG9iamVjdCBpcyBwdXJlXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhd2FpdCBDaGFyYWN0ZXIuZmluZChDaGFyYWN0ZXIudHJhbnNsYXRlQWxpYXNlcyh7XG4gKiAgICAgICAgJ+WQjSc6ICdFZGRhcmQgU3RhcmsnIC8vIEFsaWFzIGZvciAnbmFtZSdcbiAqICAgICB9KTtcbiAqXG4gKiBCeSBkZWZhdWx0LCBgdHJhbnNsYXRlQWxpYXNlcygpYCBvdmVyd3JpdGVzIHJhdyBmaWVsZHMgd2l0aCBhbGlhc2VkIGZpZWxkcy5cbiAqIFNvIGlmIGBuYCBpcyBhbiBhbGlhcyBmb3IgYG5hbWVgLCBgeyBuOiAnYWxpYXMnLCBuYW1lOiAncmF3JyB9YCB3aWxsIHJlc29sdmUgdG8gYHsgbmFtZTogJ2FsaWFzJyB9YC5cbiAqIEhvd2V2ZXIsIHlvdSBjYW4gc2V0IHRoZSBgZXJyb3JPbkR1cGxpY2F0ZXNgIG9wdGlvbiB0byB0aHJvdyBhbiBlcnJvciBpZiB0aGVyZSBhcmUgcG90ZW50aWFsbHkgY29uZmxpY3RpbmcgcGF0aHMuXG4gKiBUaGUgYHRyYW5zbGF0ZUFsaWFzZXNgIG9wdGlvbiBmb3IgcXVlcmllcyB1c2VzIGBlcnJvck9uRHVwbGljYXRlc2AuXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIE9ubHkgdHJhbnNsYXRlIGFyZ3VtZW50cyBvZiBvYmplY3QgdHlwZSBhbnl0aGluZyBlbHNlIGlzIHJldHVybmVkIHJhd1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaWVsZHMgZmllbGRzL2NvbmRpdGlvbnMgdGhhdCBtYXkgY29udGFpbiBhbGlhc2VkIGtleXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Vycm9yT25EdXBsaWNhdGVzXSBpZiB0cnVlLCB0aHJvdyBhbiBlcnJvciBpZiB0aGVyZSdzIGJvdGggYSBrZXkgYW5kIGFuIGFsaWFzIGZvciB0aGF0IGtleSBpbiBgZmllbGRzYFxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgdHJhbnNsYXRlZCAncHVyZScgZmllbGRzL2NvbmRpdGlvbnNcbiAqL1xuTW9kZWwudHJhbnNsYXRlQWxpYXNlcyA9IGZ1bmN0aW9uIHRyYW5zbGF0ZUFsaWFzZXMoZmllbGRzLCBlcnJvck9uRHVwbGljYXRlcykge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICd0cmFuc2xhdGVBbGlhc2VzJyk7XG5cbiAgY29uc3QgdHJhbnNsYXRlID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICBsZXQgYWxpYXM7XG4gICAgY29uc3QgdHJhbnNsYXRlZCA9IFtdO1xuICAgIGNvbnN0IGZpZWxkS2V5cyA9IGtleS5zcGxpdCgnLicpO1xuICAgIGxldCBjdXJyZW50U2NoZW1hID0gdGhpcy5zY2hlbWE7XG4gICAgZm9yIChjb25zdCBpIGluIGZpZWxkS2V5cykge1xuICAgICAgY29uc3QgbmFtZSA9IGZpZWxkS2V5c1tpXTtcbiAgICAgIGlmIChjdXJyZW50U2NoZW1hICYmIGN1cnJlbnRTY2hlbWEuYWxpYXNlc1tuYW1lXSkge1xuICAgICAgICBhbGlhcyA9IGN1cnJlbnRTY2hlbWEuYWxpYXNlc1tuYW1lXTtcbiAgICAgICAgaWYgKGVycm9yT25EdXBsaWNhdGVzICYmIGFsaWFzIGluIGZpZWxkcykge1xuICAgICAgICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKGBQcm92aWRlZCBvYmplY3QgaGFzIGJvdGggZmllbGQgXCIke25hbWV9XCIgYW5kIGl0cyBhbGlhcyBcIiR7YWxpYXN9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbGlhcyBmb3VuZCxcbiAgICAgICAgdHJhbnNsYXRlZC5wdXNoKGFsaWFzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsaWFzID0gbmFtZTtcbiAgICAgICAgLy8gQWxpYXMgbm90IGZvdW5kLCBzbyB0cmVhdCBhcyB1bi1hbGlhc2VkIGtleVxuICAgICAgICB0cmFuc2xhdGVkLnB1c2gobmFtZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIGFsaWFzZWQgcGF0aCBpcyBhIHNjaGVtYVxuICAgICAgaWYgKGN1cnJlbnRTY2hlbWEgJiYgY3VycmVudFNjaGVtYS5wYXRoc1thbGlhc10pIHtcbiAgICAgICAgY3VycmVudFNjaGVtYSA9IGN1cnJlbnRTY2hlbWEucGF0aHNbYWxpYXNdLnNjaGVtYTtcbiAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgICAgY3VycmVudFNjaGVtYSA9IG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgdHJhbnNsYXRlZEtleSA9IHRyYW5zbGF0ZWQuam9pbignLicpO1xuICAgIGlmIChmaWVsZHMgaW5zdGFuY2VvZiBNYXApXG4gICAgICBmaWVsZHMuc2V0KHRyYW5zbGF0ZWRLZXksIHZhbHVlKTtcbiAgICBlbHNlXG4gICAgICBmaWVsZHNbdHJhbnNsYXRlZEtleV0gPSB2YWx1ZTtcblxuICAgIGlmICh0cmFuc2xhdGVkS2V5ICE9PSBrZXkpIHtcbiAgICAgIC8vIFdlJ2xsIGJlIHVzaW5nIHRoZSB0cmFuc2xhdGVkIGtleSBpbnN0ZWFkXG4gICAgICBpZiAoZmllbGRzIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIC8vIERlbGV0ZSBmcm9tIG1hcFxuICAgICAgICBmaWVsZHMuZGVsZXRlKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBEZWxldGUgZnJvbSBvYmplY3RcbiAgICAgICAgZGVsZXRlIGZpZWxkc1trZXldOyAvLyBXZSdsbCBiZSB1c2luZyB0aGUgdHJhbnNsYXRlZCBrZXkgaW5zdGVhZFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmllbGRzO1xuICB9O1xuXG4gIGlmICh0eXBlb2YgZmllbGRzID09PSAnb2JqZWN0Jykge1xuICAgIC8vIEZpZWxkcyBpcyBhbiBvYmplY3QgKHF1ZXJ5IGNvbmRpdGlvbnMgb3IgZG9jdW1lbnQgZmllbGRzKVxuICAgIGlmIChmaWVsZHMgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgIC8vIEEgTWFwIHdhcyBzdXBwbGllZFxuICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBuZXcgTWFwKGZpZWxkcykpIHtcbiAgICAgICAgZmllbGRzID0gdHJhbnNsYXRlKGZpZWxkWzBdLCBmaWVsZFsxXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEluZmVyIGEgcmVndWxhciBvYmplY3Qgd2FzIHN1cHBsaWVkXG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhmaWVsZHMpKSB7XG4gICAgICAgIGZpZWxkcyA9IHRyYW5zbGF0ZShrZXksIGZpZWxkc1trZXldKTtcbiAgICAgICAgaWYgKGtleVswXSA9PT0gJyQnKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmllbGRzW2tleV0pKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGkgaW4gZmllbGRzW2tleV0pIHtcbiAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgdHJhbnNsYXRlIG5lc3RlZCBxdWVyaWVzXG4gICAgICAgICAgICAgIGZpZWxkc1trZXldW2ldID0gdGhpcy50cmFuc2xhdGVBbGlhc2VzKGZpZWxkc1trZXldW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50cmFuc2xhdGVBbGlhc2VzKGZpZWxkc1trZXldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGRzO1xuICB9IGVsc2Uge1xuICAgIC8vIERvbid0IGtub3cgdHlwZW9mIGZpZWxkc1xuICAgIHJldHVybiBmaWVsZHM7XG4gIH1cbn07XG5cbi8qKlxuICogRGVsZXRlcyB0aGUgZmlyc3QgZG9jdW1lbnQgdGhhdCBtYXRjaGVzIGBjb25kaXRpb25zYCBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICogSXQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydHkgYGRlbGV0ZWRDb3VudGAgaW5kaWNhdGluZyBob3cgbWFueSBkb2N1bWVudHMgd2VyZSBkZWxldGVkLlxuICogQmVoYXZlcyBsaWtlIGByZW1vdmUoKWAsIGJ1dCBkZWxldGVzIGF0IG1vc3Qgb25lIGRvY3VtZW50IHJlZ2FyZGxlc3Mgb2YgdGhlXG4gKiBgc2luZ2xlYCBvcHRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhd2FpdCBDaGFyYWN0ZXIuZGVsZXRlT25lKHsgbmFtZTogJ0VkZGFyZCBTdGFyaycgfSk7IC8vIHJldHVybnMge2RlbGV0ZWRDb3VudDogMX1cbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogVGhpcyBmdW5jdGlvbiB0cmlnZ2VycyBgZGVsZXRlT25lYCBxdWVyeSBob29rcy4gUmVhZCB0aGVcbiAqIFttaWRkbGV3YXJlIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9taWRkbGV3YXJlLmh0bWwjbmFtaW5nKSB0byBsZWFybiBtb3JlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25kaXRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKSlcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJhbnNsYXRlQWxpYXNlcz1udWxsXSBJZiBzZXQgdG8gYHRydWVgLCB0cmFuc2xhdGVzIGFueSBzY2hlbWEtZGVmaW5lZCBhbGlhc2VzIGluIGBmaWx0ZXJgLCBgcHJvamVjdGlvbmAsIGB1cGRhdGVgLCBhbmQgYGRpc3RpbmN0YC4gVGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGFyZSBhbnkgY29uZmxpY3RzIHdoZXJlIGJvdGggYWxpYXMgYW5kIHJhdyBwcm9wZXJ0eSBhcmUgZGVmaW5lZCBvbiB0aGUgc2FtZSBvYmplY3QuXG4gKiBAcmV0dXJuIHtRdWVyeX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwuZGVsZXRlT25lID0gZnVuY3Rpb24gZGVsZXRlT25lKGNvbmRpdGlvbnMsIG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnZGVsZXRlT25lJyk7XG5cbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLnByb3RvdHlwZS5kZWxldGVPbmUoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBjb25zdCBtcSA9IG5ldyB0aGlzLlF1ZXJ5KHt9LCB7fSwgdGhpcywgdGhpcy4kX19jb2xsZWN0aW9uKTtcbiAgbXEuc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICByZXR1cm4gbXEuZGVsZXRlT25lKGNvbmRpdGlvbnMpO1xufTtcblxuLyoqXG4gKiBEZWxldGVzIGFsbCBvZiB0aGUgZG9jdW1lbnRzIHRoYXQgbWF0Y2ggYGNvbmRpdGlvbnNgIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gKiBJdCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0eSBgZGVsZXRlZENvdW50YCBjb250YWluaW5nIHRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIGRlbGV0ZWQuXG4gKiBCZWhhdmVzIGxpa2UgYHJlbW92ZSgpYCwgYnV0IGRlbGV0ZXMgYWxsIGRvY3VtZW50cyB0aGF0IG1hdGNoIGBjb25kaXRpb25zYFxuICogcmVnYXJkbGVzcyBvZiB0aGUgYHNpbmdsZWAgb3B0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYXdhaXQgQ2hhcmFjdGVyLmRlbGV0ZU1hbnkoeyBuYW1lOiAvU3RhcmsvLCBhZ2U6IHsgJGd0ZTogMTggfSB9KTsgLy8gcmV0dXJucyB7ZGVsZXRlZENvdW50OiB4fSB3aGVyZSB4IGlzIHRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIGRlbGV0ZWQuXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgYGRlbGV0ZU1hbnlgIHF1ZXJ5IGhvb2tzLiBSZWFkIHRoZVxuICogW21pZGRsZXdhcmUgZG9jc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL21pZGRsZXdhcmUuaHRtbCNuYW1pbmcpIHRvIGxlYXJuIG1vcmUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmRpdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgc2VlIFtgUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cmFuc2xhdGVBbGlhc2VzPW51bGxdIElmIHNldCB0byBgdHJ1ZWAsIHRyYW5zbGF0ZXMgYW55IHNjaGVtYS1kZWZpbmVkIGFsaWFzZXMgaW4gYGZpbHRlcmAsIGBwcm9qZWN0aW9uYCwgYHVwZGF0ZWAsIGFuZCBgZGlzdGluY3RgLiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIGFueSBjb25mbGljdHMgd2hlcmUgYm90aCBhbGlhcyBhbmQgcmF3IHByb3BlcnR5IGFyZSBkZWZpbmVkIG9uIHRoZSBzYW1lIG9iamVjdC5cbiAqIEByZXR1cm4ge1F1ZXJ5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5kZWxldGVNYW55ID0gZnVuY3Rpb24gZGVsZXRlTWFueShjb25kaXRpb25zLCBvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2RlbGV0ZU1hbnknKTtcblxuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwuZGVsZXRlTWFueSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGNvbnN0IG1xID0gbmV3IHRoaXMuUXVlcnkoe30sIHt9LCB0aGlzLCB0aGlzLiRfX2NvbGxlY3Rpb24pO1xuICBtcS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gIHJldHVybiBtcS5kZWxldGVNYW55KGNvbmRpdGlvbnMpO1xufTtcblxuLyoqXG4gKiBGaW5kcyBkb2N1bWVudHMuXG4gKlxuICogTW9uZ29vc2UgY2FzdHMgdGhlIGBmaWx0ZXJgIHRvIG1hdGNoIHRoZSBtb2RlbCdzIHNjaGVtYSBiZWZvcmUgdGhlIGNvbW1hbmQgaXMgc2VudC5cbiAqIFNlZSBvdXIgW3F1ZXJ5IGNhc3RpbmcgdHV0b3JpYWxdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90dXRvcmlhbHMvcXVlcnlfY2FzdGluZy5odG1sKSBmb3JcbiAqIG1vcmUgaW5mb3JtYXRpb24gb24gaG93IE1vbmdvb3NlIGNhc3RzIGBmaWx0ZXJgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gZmluZCBhbGwgZG9jdW1lbnRzXG4gKiAgICAgYXdhaXQgTXlNb2RlbC5maW5kKHt9KTtcbiAqXG4gKiAgICAgLy8gZmluZCBhbGwgZG9jdW1lbnRzIG5hbWVkIGpvaG4gYW5kIGF0IGxlYXN0IDE4XG4gKiAgICAgYXdhaXQgTXlNb2RlbC5maW5kKHsgbmFtZTogJ2pvaG4nLCBhZ2U6IHsgJGd0ZTogMTggfSB9KS5leGVjKCk7XG4gKlxuICogICAgIC8vIGV4ZWN1dGVzLCBuYW1lIExJS0Ugam9obiBhbmQgb25seSBzZWxlY3RpbmcgdGhlIFwibmFtZVwiIGFuZCBcImZyaWVuZHNcIiBmaWVsZHNcbiAqICAgICBhd2FpdCBNeU1vZGVsLmZpbmQoeyBuYW1lOiAvam9obi9pIH0sICduYW1lIGZyaWVuZHMnKS5leGVjKCk7XG4gKlxuICogICAgIC8vIHBhc3Npbmcgb3B0aW9uc1xuICogICAgIGF3YWl0IE15TW9kZWwuZmluZCh7IG5hbWU6IC9qb2huL2kgfSwgbnVsbCwgeyBza2lwOiAxMCB9KS5leGVjKCk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R8T2JqZWN0SWR9IGZpbHRlclxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfFN0cmluZ1tdfSBbcHJvamVjdGlvbl0gb3B0aW9uYWwgZmllbGRzIHRvIHJldHVybiwgc2VlIFtgUXVlcnkucHJvdG90eXBlLnNlbGVjdCgpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZWxlY3QoKSlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgc2VlIFtgUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cmFuc2xhdGVBbGlhc2VzPW51bGxdIElmIHNldCB0byBgdHJ1ZWAsIHRyYW5zbGF0ZXMgYW55IHNjaGVtYS1kZWZpbmVkIGFsaWFzZXMgaW4gYGZpbHRlcmAsIGBwcm9qZWN0aW9uYCwgYHVwZGF0ZWAsIGFuZCBgZGlzdGluY3RgLiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIGFueSBjb25mbGljdHMgd2hlcmUgYm90aCBhbGlhcyBhbmQgcmF3IHByb3BlcnR5IGFyZSBkZWZpbmVkIG9uIHRoZSBzYW1lIG9iamVjdC5cbiAqIEByZXR1cm4ge1F1ZXJ5fVxuICogQHNlZSBmaWVsZCBzZWxlY3Rpb24gaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZWxlY3QoKVxuICogQHNlZSBxdWVyeSBjYXN0aW5nIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90dXRvcmlhbHMvcXVlcnlfY2FzdGluZy5odG1sXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmZpbmQgPSBmdW5jdGlvbiBmaW5kKGNvbmRpdGlvbnMsIHByb2plY3Rpb24sIG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnZmluZCcpO1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1szXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5maW5kKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgY29uc3QgbXEgPSBuZXcgdGhpcy5RdWVyeSh7fSwge30sIHRoaXMsIHRoaXMuJF9fY29sbGVjdGlvbik7XG4gIG1xLnNlbGVjdChwcm9qZWN0aW9uKTtcbiAgbXEuc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICByZXR1cm4gbXEuZmluZChjb25kaXRpb25zKTtcbn07XG5cbi8qKlxuICogRmluZHMgYSBzaW5nbGUgZG9jdW1lbnQgYnkgaXRzIF9pZCBmaWVsZC4gYGZpbmRCeUlkKGlkKWAgaXMgYWxtb3N0KlxuICogZXF1aXZhbGVudCB0byBgZmluZE9uZSh7IF9pZDogaWQgfSlgLiBJZiB5b3Ugd2FudCB0byBxdWVyeSBieSBhIGRvY3VtZW50J3NcbiAqIGBfaWRgLCB1c2UgYGZpbmRCeUlkKClgIGluc3RlYWQgb2YgYGZpbmRPbmUoKWAuXG4gKlxuICogVGhlIGBpZGAgaXMgY2FzdCBiYXNlZCBvbiB0aGUgU2NoZW1hIGJlZm9yZSBzZW5kaW5nIHRoZSBjb21tYW5kLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgdGhlIGZvbGxvd2luZyBtaWRkbGV3YXJlLlxuICpcbiAqIC0gYGZpbmRPbmUoKWBcbiAqXG4gKiBcXCogRXhjZXB0IGZvciBob3cgaXQgdHJlYXRzIGB1bmRlZmluZWRgLiBJZiB5b3UgdXNlIGBmaW5kT25lKClgLCB5b3UnbGwgc2VlXG4gKiB0aGF0IGBmaW5kT25lKHVuZGVmaW5lZClgIGFuZCBgZmluZE9uZSh7IF9pZDogdW5kZWZpbmVkIH0pYCBhcmUgZXF1aXZhbGVudFxuICogdG8gYGZpbmRPbmUoe30pYCBhbmQgcmV0dXJuIGFyYml0cmFyeSBkb2N1bWVudHMuIEhvd2V2ZXIsIG1vbmdvb3NlXG4gKiB0cmFuc2xhdGVzIGBmaW5kQnlJZCh1bmRlZmluZWQpYCBpbnRvIGBmaW5kT25lKHsgX2lkOiBudWxsIH0pYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIEZpbmQgdGhlIGFkdmVudHVyZSB3aXRoIHRoZSBnaXZlbiBgaWRgLCBvciBgbnVsbGAgaWYgbm90IGZvdW5kXG4gKiAgICAgYXdhaXQgQWR2ZW50dXJlLmZpbmRCeUlkKGlkKS5leGVjKCk7XG4gKlxuICogICAgIC8vIHNlbGVjdCBvbmx5IHRoZSBhZHZlbnR1cmVzIG5hbWUgYW5kIGxlbmd0aFxuICogICAgIGF3YWl0IEFkdmVudHVyZS5maW5kQnlJZChpZCwgJ25hbWUgbGVuZ3RoJykuZXhlYygpO1xuICpcbiAqIEBwYXJhbSB7QW55fSBpZCB2YWx1ZSBvZiBgX2lkYCB0byBxdWVyeSBieVxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfFN0cmluZ1tdfSBbcHJvamVjdGlvbl0gb3B0aW9uYWwgZmllbGRzIHRvIHJldHVybiwgc2VlIFtgUXVlcnkucHJvdG90eXBlLnNlbGVjdCgpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZWxlY3QoKSlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgc2VlIFtgUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpKVxuICogQHJldHVybiB7UXVlcnl9XG4gKiBAc2VlIGZpZWxkIHNlbGVjdGlvbiBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNlbGVjdCgpXG4gKiBAc2VlIGxlYW4gcXVlcmllcyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHV0b3JpYWxzL2xlYW4uaHRtbFxuICogQHNlZSBmaW5kQnlJZCBpbiBNb25nb29zZSBodHRwczovL21hc3RlcmluZ2pzLmlvL3R1dG9yaWFscy9tb25nb29zZS9maW5kLWJ5LWlkXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmZpbmRCeUlkID0gZnVuY3Rpb24gZmluZEJ5SWQoaWQsIHByb2plY3Rpb24sIG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnZmluZEJ5SWQnKTtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLmZpbmRCeUlkKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZCA9IG51bGw7XG4gIH1cblxuICByZXR1cm4gdGhpcy5maW5kT25lKHsgX2lkOiBpZCB9LCBwcm9qZWN0aW9uLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogRmluZHMgb25lIGRvY3VtZW50LlxuICpcbiAqIFRoZSBgY29uZGl0aW9uc2AgYXJlIGNhc3QgdG8gdGhlaXIgcmVzcGVjdGl2ZSBTY2hlbWFUeXBlcyBiZWZvcmUgdGhlIGNvbW1hbmQgaXMgc2VudC5cbiAqXG4gKiAqTm90ZToqIGBjb25kaXRpb25zYCBpcyBvcHRpb25hbCwgYW5kIGlmIGBjb25kaXRpb25zYCBpcyBudWxsIG9yIHVuZGVmaW5lZCxcbiAqIG1vbmdvb3NlIHdpbGwgc2VuZCBhbiBlbXB0eSBgZmluZE9uZWAgY29tbWFuZCB0byBNb25nb0RCLCB3aGljaCB3aWxsIHJldHVyblxuICogYW4gYXJiaXRyYXJ5IGRvY3VtZW50LiBJZiB5b3UncmUgcXVlcnlpbmcgYnkgYF9pZGAsIHVzZSBgZmluZEJ5SWQoKWAgaW5zdGVhZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIEZpbmQgb25lIGFkdmVudHVyZSB3aG9zZSBgY291bnRyeWAgaXMgJ0Nyb2F0aWEnLCBvdGhlcndpc2UgYG51bGxgXG4gKiAgICAgYXdhaXQgQWR2ZW50dXJlLmZpbmRPbmUoeyBjb3VudHJ5OiAnQ3JvYXRpYScgfSkuZXhlYygpO1xuICpcbiAqICAgICAvLyBNb2RlbC5maW5kT25lKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFja1xuICpcbiAqICAgICAvLyBTZWxlY3Qgb25seSB0aGUgYWR2ZW50dXJlcyBuYW1lIGFuZCBsZW5ndGhcbiAqICAgICBhd2FpdCBBZHZlbnR1cmUuZmluZE9uZSh7IGNvdW50cnk6ICdDcm9hdGlhJyB9LCAnbmFtZSBsZW5ndGgnKS5leGVjKCk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtjb25kaXRpb25zXVxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfFN0cmluZ1tdfSBbcHJvamVjdGlvbl0gb3B0aW9uYWwgZmllbGRzIHRvIHJldHVybiwgc2VlIFtgUXVlcnkucHJvdG90eXBlLnNlbGVjdCgpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZWxlY3QoKSlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgc2VlIFtgUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cmFuc2xhdGVBbGlhc2VzPW51bGxdIElmIHNldCB0byBgdHJ1ZWAsIHRyYW5zbGF0ZXMgYW55IHNjaGVtYS1kZWZpbmVkIGFsaWFzZXMgaW4gYGZpbHRlcmAsIGBwcm9qZWN0aW9uYCwgYHVwZGF0ZWAsIGFuZCBgZGlzdGluY3RgLiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIGFueSBjb25mbGljdHMgd2hlcmUgYm90aCBhbGlhcyBhbmQgcmF3IHByb3BlcnR5IGFyZSBkZWZpbmVkIG9uIHRoZSBzYW1lIG9iamVjdC5cbiAqIEByZXR1cm4ge1F1ZXJ5fVxuICogQHNlZSBmaWVsZCBzZWxlY3Rpb24gaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZWxlY3QoKVxuICogQHNlZSBsZWFuIHF1ZXJpZXMgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3R1dG9yaWFscy9sZWFuLmh0bWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwuZmluZE9uZSA9IGZ1bmN0aW9uIGZpbmRPbmUoY29uZGl0aW9ucywgcHJvamVjdGlvbiwgb3B0aW9ucykge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdmaW5kT25lJyk7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5maW5kT25lKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgY29uc3QgbXEgPSBuZXcgdGhpcy5RdWVyeSh7fSwge30sIHRoaXMsIHRoaXMuJF9fY29sbGVjdGlvbik7XG4gIG1xLnNlbGVjdChwcm9qZWN0aW9uKTtcbiAgbXEuc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICByZXR1cm4gbXEuZmluZE9uZShjb25kaXRpb25zKTtcbn07XG5cbi8qKlxuICogRXN0aW1hdGVzIHRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIGluIHRoZSBNb25nb0RCIGNvbGxlY3Rpb24uIEZhc3RlciB0aGFuXG4gKiB1c2luZyBgY291bnREb2N1bWVudHMoKWAgZm9yIGxhcmdlIGNvbGxlY3Rpb25zIGJlY2F1c2VcbiAqIGBlc3RpbWF0ZWREb2N1bWVudENvdW50KClgIHVzZXMgY29sbGVjdGlvbiBtZXRhZGF0YSByYXRoZXIgdGhhbiBzY2FubmluZ1xuICogdGhlIGVudGlyZSBjb2xsZWN0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgbnVtQWR2ZW50dXJlcyA9IGF3YWl0IEFkdmVudHVyZS5lc3RpbWF0ZWREb2N1bWVudENvdW50KCk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHJldHVybiB7UXVlcnl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmVzdGltYXRlZERvY3VtZW50Q291bnQgPSBmdW5jdGlvbiBlc3RpbWF0ZWREb2N1bWVudENvdW50KG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnZXN0aW1hdGVkRG9jdW1lbnRDb3VudCcpO1xuXG4gIGNvbnN0IG1xID0gbmV3IHRoaXMuUXVlcnkoe30sIHt9LCB0aGlzLCB0aGlzLiRfX2NvbGxlY3Rpb24pO1xuXG4gIHJldHVybiBtcS5lc3RpbWF0ZWREb2N1bWVudENvdW50KG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDb3VudHMgbnVtYmVyIG9mIGRvY3VtZW50cyBtYXRjaGluZyBgZmlsdGVyYCBpbiBhIGRhdGFiYXNlIGNvbGxlY3Rpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBBZHZlbnR1cmUuY291bnREb2N1bWVudHMoeyB0eXBlOiAnanVuZ2xlJyB9LCBmdW5jdGlvbiAoZXJyLCBjb3VudCkge1xuICogICAgICAgY29uc29sZS5sb2coJ3RoZXJlIGFyZSAlZCBqdW5nbGUgYWR2ZW50dXJlcycsIGNvdW50KTtcbiAqICAgICB9KTtcbiAqXG4gKiBJZiB5b3Ugd2FudCB0byBjb3VudCBhbGwgZG9jdW1lbnRzIGluIGEgbGFyZ2UgY29sbGVjdGlvbixcbiAqIHVzZSB0aGUgW2Blc3RpbWF0ZWREb2N1bWVudENvdW50KClgIGZ1bmN0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vZGVsLmh0bWwjTW9kZWwuZXN0aW1hdGVkRG9jdW1lbnRDb3VudCgpKVxuICogaW5zdGVhZC4gSWYgeW91IGNhbGwgYGNvdW50RG9jdW1lbnRzKHt9KWAsIE1vbmdvREIgd2lsbCBhbHdheXMgZXhlY3V0ZVxuICogYSBmdWxsIGNvbGxlY3Rpb24gc2NhbiBhbmQgKipub3QqKiB1c2UgYW55IGluZGV4ZXMuXG4gKlxuICogVGhlIGBjb3VudERvY3VtZW50cygpYCBmdW5jdGlvbiBpcyBzaW1pbGFyIHRvIGBjb3VudCgpYCwgYnV0IHRoZXJlIGFyZSBhXG4gKiBbZmV3IG9wZXJhdG9ycyB0aGF0IGBjb3VudERvY3VtZW50cygpYCBkb2VzIG5vdCBzdXBwb3J0XShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvQ29sbGVjdGlvbi5odG1sI2NvdW50RG9jdW1lbnRzKS5cbiAqIEJlbG93IGFyZSB0aGUgb3BlcmF0b3JzIHRoYXQgYGNvdW50KClgIHN1cHBvcnRzIGJ1dCBgY291bnREb2N1bWVudHMoKWAgZG9lcyBub3QsXG4gKiBhbmQgdGhlIHN1Z2dlc3RlZCByZXBsYWNlbWVudDpcbiAqXG4gKiAtIGAkd2hlcmVgOiBbYCRleHByYF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3F1ZXJ5L2V4cHIvKVxuICogLSBgJG5lYXJgOiBbYCRnZW9XaXRoaW5gXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvcXVlcnkvZ2VvV2l0aGluLykgd2l0aCBbYCRjZW50ZXJgXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvcXVlcnkvY2VudGVyLyNvcC5fU19jZW50ZXIpXG4gKiAtIGAkbmVhclNwaGVyZWA6IFtgJGdlb1dpdGhpbmBdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9xdWVyeS9nZW9XaXRoaW4vKSB3aXRoIFtgJGNlbnRlclNwaGVyZWBdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9xdWVyeS9jZW50ZXJTcGhlcmUvI29wLl9TX2NlbnRlclNwaGVyZSlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZmlsdGVyXG4gKiBAcmV0dXJuIHtRdWVyeX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwuY291bnREb2N1bWVudHMgPSBmdW5jdGlvbiBjb3VudERvY3VtZW50cyhjb25kaXRpb25zLCBvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2NvdW50RG9jdW1lbnRzJyk7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5jb3VudERvY3VtZW50cygpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGNvbnN0IG1xID0gbmV3IHRoaXMuUXVlcnkoe30sIHt9LCB0aGlzLCB0aGlzLiRfX2NvbGxlY3Rpb24pO1xuICBpZiAob3B0aW9ucyAhPSBudWxsKSB7XG4gICAgbXEuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiBtcS5jb3VudERvY3VtZW50cyhjb25kaXRpb25zKTtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgUXVlcnkgZm9yIGEgYGRpc3RpbmN0YCBvcGVyYXRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBxdWVyeSA9IExpbmsuZGlzdGluY3QoJ3VybCcpO1xuICogICAgIHF1ZXJ5LmV4ZWMoKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZGl0aW9uc10gb3B0aW9uYWxcbiAqIEByZXR1cm4ge1F1ZXJ5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5kaXN0aW5jdCA9IGZ1bmN0aW9uIGRpc3RpbmN0KGZpZWxkLCBjb25kaXRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2Rpc3RpbmN0Jyk7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwuZGlzdGluY3QoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBjb25zdCBtcSA9IG5ldyB0aGlzLlF1ZXJ5KHt9LCB7fSwgdGhpcywgdGhpcy4kX19jb2xsZWN0aW9uKTtcblxuICByZXR1cm4gbXEuZGlzdGluY3QoZmllbGQsIGNvbmRpdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgUXVlcnksIGFwcGxpZXMgdGhlIHBhc3NlZCBjb25kaXRpb25zLCBhbmQgcmV0dXJucyB0aGUgUXVlcnkuXG4gKlxuICogRm9yIGV4YW1wbGUsIGluc3RlYWQgb2Ygd3JpdGluZzpcbiAqXG4gKiAgICAgVXNlci5maW5kKHsgYWdlOiB7ICRndGU6IDIxLCAkbHRlOiA2NSB9IH0pO1xuICpcbiAqIHdlIGNhbiBpbnN0ZWFkIHdyaXRlOlxuICpcbiAqICAgICBVc2VyLndoZXJlKCdhZ2UnKS5ndGUoMjEpLmx0ZSg2NSkuZXhlYygpO1xuICpcbiAqIFNpbmNlIHRoZSBRdWVyeSBjbGFzcyBhbHNvIHN1cHBvcnRzIGB3aGVyZWAgeW91IGNhbiBjb250aW51ZSBjaGFpbmluZ1xuICpcbiAqICAgICBVc2VyXG4gKiAgICAgLndoZXJlKCdhZ2UnKS5ndGUoMjEpLmx0ZSg2NSlcbiAqICAgICAud2hlcmUoJ25hbWUnLCAvXmIvaSlcbiAqICAgICAuLi4gZXRjXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7T2JqZWN0fSBbdmFsXSBvcHRpb25hbCB2YWx1ZVxuICogQHJldHVybiB7UXVlcnl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLndoZXJlID0gZnVuY3Rpb24gd2hlcmUocGF0aCwgdmFsKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ3doZXJlJyk7XG5cbiAgdm9pZCB2YWw7IC8vIGVzbGludFxuICBjb25zdCBtcSA9IG5ldyB0aGlzLlF1ZXJ5KHt9LCB7fSwgdGhpcywgdGhpcy4kX19jb2xsZWN0aW9uKS5maW5kKHt9KTtcbiAgcmV0dXJuIG1xLndoZXJlLmFwcGx5KG1xLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYFF1ZXJ5YCBhbmQgc3BlY2lmaWVzIGEgYCR3aGVyZWAgY29uZGl0aW9uLlxuICpcbiAqIFNvbWV0aW1lcyB5b3UgbmVlZCB0byBxdWVyeSBmb3IgdGhpbmdzIGluIG1vbmdvZGIgdXNpbmcgYSBKYXZhU2NyaXB0IGV4cHJlc3Npb24uIFlvdSBjYW4gZG8gc28gdmlhIGBmaW5kKHsgJHdoZXJlOiBqYXZhc2NyaXB0IH0pYCwgb3IgeW91IGNhbiB1c2UgdGhlIG1vbmdvb3NlIHNob3J0Y3V0IG1ldGhvZCAkd2hlcmUgdmlhIGEgUXVlcnkgY2hhaW4gb3IgZnJvbSB5b3VyIG1vbmdvb3NlIE1vZGVsLlxuICpcbiAqICAgICBCbG9nLiR3aGVyZSgndGhpcy51c2VybmFtZS5pbmRleE9mKFwidmFsXCIpICE9PSAtMScpLmV4ZWMoZnVuY3Rpb24gKGVyciwgZG9jcykge30pO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBhcmd1bWVudCBpcyBhIGphdmFzY3JpcHQgc3RyaW5nIG9yIGFub255bW91cyBmdW5jdGlvblxuICogQG1ldGhvZCAkd2hlcmVcbiAqIEBtZW1iZXJPZiBNb2RlbFxuICogQHJldHVybiB7UXVlcnl9XG4gKiBAc2VlIFF1ZXJ5LiR3aGVyZSBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLiR3aGVyZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC4kd2hlcmUgPSBmdW5jdGlvbiAkd2hlcmUoKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJyR3aGVyZScpO1xuXG4gIGNvbnN0IG1xID0gbmV3IHRoaXMuUXVlcnkoe30sIHt9LCB0aGlzLCB0aGlzLiRfX2NvbGxlY3Rpb24pLmZpbmQoe30pO1xuICByZXR1cm4gbXEuJHdoZXJlLmFwcGx5KG1xLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBJc3N1ZXMgYSBtb25nb2RiIGZpbmRPbmVBbmRVcGRhdGUgY29tbWFuZC5cbiAqXG4gKiBGaW5kcyBhIG1hdGNoaW5nIGRvY3VtZW50LCB1cGRhdGVzIGl0IGFjY29yZGluZyB0byB0aGUgYHVwZGF0ZWAgYXJnLCBwYXNzaW5nIGFueSBgb3B0aW9uc2AsIGFuZCByZXR1cm5zIHRoZSBmb3VuZCBkb2N1bWVudCAoaWYgYW55KSB0byB0aGUgY2FsbGJhY2suIFRoZSBxdWVyeSBleGVjdXRlcyBpZiBgY2FsbGJhY2tgIGlzIHBhc3NlZCBlbHNlIGEgUXVlcnkgb2JqZWN0IGlzIHJldHVybmVkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgQS5maW5kT25lQW5kVXBkYXRlKGNvbmRpdGlvbnMsIHVwZGF0ZSwgb3B0aW9ucykgIC8vIHJldHVybnMgUXVlcnlcbiAqICAgICBBLmZpbmRPbmVBbmRVcGRhdGUoY29uZGl0aW9ucywgdXBkYXRlKSAgICAgICAgICAgLy8gcmV0dXJucyBRdWVyeVxuICogICAgIEEuZmluZE9uZUFuZFVwZGF0ZSgpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIFF1ZXJ5XG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIEFsbCB0b3AgbGV2ZWwgdXBkYXRlIGtleXMgd2hpY2ggYXJlIG5vdCBgYXRvbWljYCBvcGVyYXRpb24gbmFtZXMgYXJlIHRyZWF0ZWQgYXMgc2V0IG9wZXJhdGlvbnM6XG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBxdWVyeSA9IHsgbmFtZTogJ2Jvcm5lJyB9O1xuICogICAgIE1vZGVsLmZpbmRPbmVBbmRVcGRhdGUocXVlcnksIHsgbmFtZTogJ2phc29uIGJvdXJuZScgfSwgb3B0aW9ucylcbiAqXG4gKiAgICAgLy8gaXMgc2VudCBhc1xuICogICAgIE1vZGVsLmZpbmRPbmVBbmRVcGRhdGUocXVlcnksIHsgJHNldDogeyBuYW1lOiAnamFzb24gYm91cm5lJyB9fSwgb3B0aW9ucylcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogYGZpbmRPbmVBbmRYYCBhbmQgYGZpbmRCeUlkQW5kWGAgZnVuY3Rpb25zIHN1cHBvcnQgbGltaXRlZCB2YWxpZGF0aW9uIHRoYXRcbiAqIHlvdSBjYW4gZW5hYmxlIGJ5IHNldHRpbmcgdGhlIGBydW5WYWxpZGF0b3JzYCBvcHRpb24uXG4gKlxuICogSWYgeW91IG5lZWQgZnVsbC1mbGVkZ2VkIHZhbGlkYXRpb24sIHVzZSB0aGUgdHJhZGl0aW9uYWwgYXBwcm9hY2ggb2YgZmlyc3RcbiAqIHJldHJpZXZpbmcgdGhlIGRvY3VtZW50LlxuICpcbiAqICAgICBjb25zdCBkb2MgPSBhd2FpdCBNb2RlbC5maW5kQnlJZChpZCk7XG4gKiAgICAgZG9jLm5hbWUgPSAnamFzb24gYm91cm5lJztcbiAqICAgICBhd2FpdCBkb2Muc2F2ZSgpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZGl0aW9uc11cbiAqIEBwYXJhbSB7T2JqZWN0fSBbdXBkYXRlXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25hbCBzZWUgW2BRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKCkpXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucmV0dXJuRG9jdW1lbnQ9J2JlZm9yZSddIEhhcyB0d28gcG9zc2libGUgdmFsdWVzLCBgJ2JlZm9yZSdgIGFuZCBgJ2FmdGVyJ2AuIEJ5IGRlZmF1bHQsIGl0IHdpbGwgcmV0dXJuIHRoZSBkb2N1bWVudCBiZWZvcmUgdGhlIHVwZGF0ZSB3YXMgYXBwbGllZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5sZWFuXSBpZiB0cnV0aHksIG1vbmdvb3NlIHdpbGwgcmV0dXJuIHRoZSBkb2N1bWVudCBhcyBhIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0IHJhdGhlciB0aGFuIGEgbW9uZ29vc2UgZG9jdW1lbnQuIFNlZSBbYFF1ZXJ5LmxlYW4oKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUubGVhbigpKSBhbmQgW3RoZSBNb25nb29zZSBsZWFuIHR1dG9yaWFsXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHV0b3JpYWxzL2xlYW4uaHRtbCkuXG4gKiBAcGFyYW0ge0NsaWVudFNlc3Npb259IFtvcHRpb25zLnNlc3Npb249bnVsbF0gVGhlIHNlc3Npb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgcXVlcnkuIFNlZSBbdHJhbnNhY3Rpb25zIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90cmFuc2FjdGlvbnMuaHRtbCkuXG4gKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBbb3B0aW9ucy5zdHJpY3RdIG92ZXJ3cml0ZXMgdGhlIHNjaGVtYSdzIFtzdHJpY3QgbW9kZSBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdClcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudGltZXN0YW1wcz1udWxsXSBJZiBzZXQgdG8gYGZhbHNlYCBhbmQgW3NjaGVtYS1sZXZlbCB0aW1lc3RhbXBzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0aW1lc3RhbXBzKSBhcmUgZW5hYmxlZCwgc2tpcCB0aW1lc3RhbXBzIGZvciB0aGlzIHVwZGF0ZS4gTm90ZSB0aGF0IHRoaXMgYWxsb3dzIHlvdSB0byBvdmVyd3JpdGUgdGltZXN0YW1wcy4gRG9lcyBub3RoaW5nIGlmIHNjaGVtYS1sZXZlbCB0aW1lc3RhbXBzIGFyZSBub3Qgc2V0LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy51cHNlcnQ9ZmFsc2VdIGlmIHRydWUsIGFuZCBubyBkb2N1bWVudHMgZm91bmQsIGluc2VydCBhIG5ldyBkb2N1bWVudFxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfFN0cmluZ1tdfSBbb3B0aW9ucy5wcm9qZWN0aW9uPW51bGxdIG9wdGlvbmFsIGZpZWxkcyB0byByZXR1cm4sIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZWxlY3QoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2VsZWN0KCkpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm5ldz1mYWxzZV0gaWYgdHJ1ZSwgcmV0dXJuIHRoZSBtb2RpZmllZCBkb2N1bWVudCByYXRoZXIgdGhhbiB0aGUgb3JpZ2luYWxcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gW29wdGlvbnMuZmllbGRzXSBGaWVsZCBzZWxlY3Rpb24uIEVxdWl2YWxlbnQgdG8gYC5zZWxlY3QoZmllbGRzKS5maW5kT25lQW5kVXBkYXRlKClgXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4VGltZU1TXSBwdXRzIGEgdGltZSBsaW1pdCBvbiB0aGUgcXVlcnkgLSByZXF1aXJlcyBtb25nb2RiID49IDIuNi4wXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtvcHRpb25zLnNvcnRdIGlmIG11bHRpcGxlIGRvY3MgYXJlIGZvdW5kIGJ5IHRoZSBjb25kaXRpb25zLCBzZXRzIHRoZSBzb3J0IG9yZGVyIHRvIGNob29zZSB3aGljaCBkb2MgdG8gdXBkYXRlLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ydW5WYWxpZGF0b3JzXSBpZiB0cnVlLCBydW5zIFt1cGRhdGUgdmFsaWRhdG9yc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3ZhbGlkYXRpb24uaHRtbCN1cGRhdGUtdmFsaWRhdG9ycykgb24gdGhpcyBjb21tYW5kLiBVcGRhdGUgdmFsaWRhdG9ycyB2YWxpZGF0ZSB0aGUgdXBkYXRlIG9wZXJhdGlvbiBhZ2FpbnN0IHRoZSBtb2RlbCdzIHNjaGVtYVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zZXREZWZhdWx0c09uSW5zZXJ0PXRydWVdIElmIGBzZXREZWZhdWx0c09uSW5zZXJ0YCBhbmQgYHVwc2VydGAgYXJlIHRydWUsIG1vbmdvb3NlIHdpbGwgYXBwbHkgdGhlIFtkZWZhdWx0c10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2RlZmF1bHRzLmh0bWwpIHNwZWNpZmllZCBpbiB0aGUgbW9kZWwncyBzY2hlbWEgaWYgYSBuZXcgZG9jdW1lbnQgaXMgY3JlYXRlZFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pbmNsdWRlUmVzdWx0TWV0YWRhdGFdIGlmIHRydWUsIHJldHVybnMgdGhlIFtyYXcgcmVzdWx0IGZyb20gdGhlIE1vbmdvREIgZHJpdmVyXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvTW9kaWZ5UmVzdWx0Lmh0bWwpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRyYW5zbGF0ZUFsaWFzZXM9bnVsbF0gSWYgc2V0IHRvIGB0cnVlYCwgdHJhbnNsYXRlcyBhbnkgc2NoZW1hLWRlZmluZWQgYWxpYXNlcyBpbiBgZmlsdGVyYCwgYHByb2plY3Rpb25gLCBgdXBkYXRlYCwgYW5kIGBkaXN0aW5jdGAuIFRocm93cyBhbiBlcnJvciBpZiB0aGVyZSBhcmUgYW55IGNvbmZsaWN0cyB3aGVyZSBib3RoIGFsaWFzIGFuZCByYXcgcHJvcGVydHkgYXJlIGRlZmluZWQgb24gdGhlIHNhbWUgb2JqZWN0LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vdmVyd3JpdGVEaXNjcmltaW5hdG9yS2V5PWZhbHNlXSBNb25nb29zZSByZW1vdmVzIGRpc2NyaW1pbmF0b3Iga2V5IHVwZGF0ZXMgZnJvbSBgdXBkYXRlYCBieSBkZWZhdWx0LCBzZXQgYG92ZXJ3cml0ZURpc2NyaW1pbmF0b3JLZXlgIHRvIGB0cnVlYCB0byBhbGxvdyB1cGRhdGluZyB0aGUgZGlzY3JpbWluYXRvciBrZXlcbiAqIEByZXR1cm4ge1F1ZXJ5fVxuICogQHNlZSBUdXRvcmlhbCBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHV0b3JpYWxzL2ZpbmRvbmVhbmR1cGRhdGUuaHRtbFxuICogQHNlZSBtb25nb2RiIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9jb21tYW5kL2ZpbmRBbmRNb2RpZnkvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmZpbmRPbmVBbmRVcGRhdGUgPSBmdW5jdGlvbihjb25kaXRpb25zLCB1cGRhdGUsIG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnZmluZE9uZUFuZFVwZGF0ZScpO1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1szXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5maW5kT25lQW5kVXBkYXRlKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB1cGRhdGUgPSBjb25kaXRpb25zO1xuICAgIGNvbmRpdGlvbnMgPSBudWxsO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG5cbiAgbGV0IGZpZWxkcztcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBmaWVsZHMgPSBvcHRpb25zLmZpZWxkcyB8fCBvcHRpb25zLnByb2plY3Rpb247XG4gIH1cblxuICB1cGRhdGUgPSBjbG9uZSh1cGRhdGUsIHtcbiAgICBkZXBvcHVsYXRlOiB0cnVlLFxuICAgIF9pc05lc3RlZDogdHJ1ZVxuICB9KTtcblxuICBkZWNvcmF0ZVVwZGF0ZVdpdGhWZXJzaW9uS2V5KHVwZGF0ZSwgb3B0aW9ucywgdGhpcy5zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5KTtcblxuICBjb25zdCBtcSA9IG5ldyB0aGlzLlF1ZXJ5KHt9LCB7fSwgdGhpcywgdGhpcy4kX19jb2xsZWN0aW9uKTtcbiAgbXEuc2VsZWN0KGZpZWxkcyk7XG5cbiAgcmV0dXJuIG1xLmZpbmRPbmVBbmRVcGRhdGUoY29uZGl0aW9ucywgdXBkYXRlLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogSXNzdWVzIGEgbW9uZ29kYiBmaW5kT25lQW5kVXBkYXRlIGNvbW1hbmQgYnkgYSBkb2N1bWVudCdzIF9pZCBmaWVsZC5cbiAqIGBmaW5kQnlJZEFuZFVwZGF0ZShpZCwgLi4uKWAgaXMgZXF1aXZhbGVudCB0byBgZmluZE9uZUFuZFVwZGF0ZSh7IF9pZDogaWQgfSwgLi4uKWAuXG4gKlxuICogRmluZHMgYSBtYXRjaGluZyBkb2N1bWVudCwgdXBkYXRlcyBpdCBhY2NvcmRpbmcgdG8gdGhlIGB1cGRhdGVgIGFyZyxcbiAqIHBhc3NpbmcgYW55IGBvcHRpb25zYCwgYW5kIHJldHVybnMgdGhlIGZvdW5kIGRvY3VtZW50IChpZiBhbnkpLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgdGhlIGZvbGxvd2luZyBtaWRkbGV3YXJlLlxuICpcbiAqIC0gYGZpbmRPbmVBbmRVcGRhdGUoKWBcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIEEuZmluZEJ5SWRBbmRVcGRhdGUoaWQsIHVwZGF0ZSwgb3B0aW9ucykgIC8vIHJldHVybnMgUXVlcnlcbiAqICAgICBBLmZpbmRCeUlkQW5kVXBkYXRlKGlkLCB1cGRhdGUpICAgICAgICAgICAvLyByZXR1cm5zIFF1ZXJ5XG4gKiAgICAgQS5maW5kQnlJZEFuZFVwZGF0ZSgpICAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBRdWVyeVxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBBbGwgdG9wIGxldmVsIHVwZGF0ZSBrZXlzIHdoaWNoIGFyZSBub3QgYGF0b21pY2Agb3BlcmF0aW9uIG5hbWVzIGFyZSB0cmVhdGVkIGFzIHNldCBvcGVyYXRpb25zOlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgTW9kZWwuZmluZEJ5SWRBbmRVcGRhdGUoaWQsIHsgbmFtZTogJ2phc29uIGJvdXJuZScgfSwgb3B0aW9ucylcbiAqXG4gKiAgICAgLy8gaXMgc2VudCBhc1xuICogICAgIE1vZGVsLmZpbmRCeUlkQW5kVXBkYXRlKGlkLCB7ICRzZXQ6IHsgbmFtZTogJ2phc29uIGJvdXJuZScgfX0sIG9wdGlvbnMpXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIGBmaW5kT25lQW5kWGAgYW5kIGBmaW5kQnlJZEFuZFhgIGZ1bmN0aW9ucyBzdXBwb3J0IGxpbWl0ZWQgdmFsaWRhdGlvbi4gWW91IGNhblxuICogZW5hYmxlIHZhbGlkYXRpb24gYnkgc2V0dGluZyB0aGUgYHJ1blZhbGlkYXRvcnNgIG9wdGlvbi5cbiAqXG4gKiBJZiB5b3UgbmVlZCBmdWxsLWZsZWRnZWQgdmFsaWRhdGlvbiwgdXNlIHRoZSB0cmFkaXRpb25hbCBhcHByb2FjaCBvZiBmaXJzdFxuICogcmV0cmlldmluZyB0aGUgZG9jdW1lbnQuXG4gKlxuICogICAgIGNvbnN0IGRvYyA9IGF3YWl0IE1vZGVsLmZpbmRCeUlkKGlkKVxuICogICAgIGRvYy5uYW1lID0gJ2phc29uIGJvdXJuZSc7XG4gKiAgICAgYXdhaXQgZG9jLnNhdmUoKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxOdW1iZXJ8U3RyaW5nfSBpZCB2YWx1ZSBvZiBgX2lkYCB0byBxdWVyeSBieVxuICogQHBhcmFtIHtPYmplY3R9IFt1cGRhdGVdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKSlcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5yZXR1cm5Eb2N1bWVudD0nYmVmb3JlJ10gSGFzIHR3byBwb3NzaWJsZSB2YWx1ZXMsIGAnYmVmb3JlJ2AgYW5kIGAnYWZ0ZXInYC4gQnkgZGVmYXVsdCwgaXQgd2lsbCByZXR1cm4gdGhlIGRvY3VtZW50IGJlZm9yZSB0aGUgdXBkYXRlIHdhcyBhcHBsaWVkLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmxlYW5dIGlmIHRydXRoeSwgbW9uZ29vc2Ugd2lsbCByZXR1cm4gdGhlIGRvY3VtZW50IGFzIGEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3QgcmF0aGVyIHRoYW4gYSBtb25nb29zZSBkb2N1bWVudC4gU2VlIFtgUXVlcnkubGVhbigpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5sZWFuKCkpIGFuZCBbdGhlIE1vbmdvb3NlIGxlYW4gdHV0b3JpYWxdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90dXRvcmlhbHMvbGVhbi5odG1sKS5cbiAqIEBwYXJhbSB7Q2xpZW50U2Vzc2lvbn0gW29wdGlvbnMuc2Vzc2lvbj1udWxsXSBUaGUgc2Vzc2lvbiBhc3NvY2lhdGVkIHdpdGggdGhpcyBxdWVyeS4gU2VlIFt0cmFuc2FjdGlvbnMgZG9jc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3RyYW5zYWN0aW9ucy5odG1sKS5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxTdHJpbmd9IFtvcHRpb25zLnN0cmljdF0gb3ZlcndyaXRlcyB0aGUgc2NoZW1hJ3MgW3N0cmljdCBtb2RlIG9wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc3RyaWN0KVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50aW1lc3RhbXBzPW51bGxdIElmIHNldCB0byBgZmFsc2VgIGFuZCBbc2NoZW1hLWxldmVsIHRpbWVzdGFtcHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3RpbWVzdGFtcHMpIGFyZSBlbmFibGVkLCBza2lwIHRpbWVzdGFtcHMgZm9yIHRoaXMgdXBkYXRlLiBOb3RlIHRoYXQgdGhpcyBhbGxvd3MgeW91IHRvIG92ZXJ3cml0ZSB0aW1lc3RhbXBzLiBEb2VzIG5vdGhpbmcgaWYgc2NoZW1hLWxldmVsIHRpbWVzdGFtcHMgYXJlIG5vdCBzZXQuXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtvcHRpb25zLnNvcnRdIGlmIG11bHRpcGxlIGRvY3MgYXJlIGZvdW5kIGJ5IHRoZSBjb25kaXRpb25zLCBzZXRzIHRoZSBzb3J0IG9yZGVyIHRvIGNob29zZSB3aGljaCBkb2MgdG8gdXBkYXRlLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ydW5WYWxpZGF0b3JzXSBpZiB0cnVlLCBydW5zIFt1cGRhdGUgdmFsaWRhdG9yc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3ZhbGlkYXRpb24uaHRtbCN1cGRhdGUtdmFsaWRhdG9ycykgb24gdGhpcyBjb21tYW5kLiBVcGRhdGUgdmFsaWRhdG9ycyB2YWxpZGF0ZSB0aGUgdXBkYXRlIG9wZXJhdGlvbiBhZ2FpbnN0IHRoZSBtb2RlbCdzIHNjaGVtYVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zZXREZWZhdWx0c09uSW5zZXJ0PXRydWVdIElmIGBzZXREZWZhdWx0c09uSW5zZXJ0YCBhbmQgYHVwc2VydGAgYXJlIHRydWUsIG1vbmdvb3NlIHdpbGwgYXBwbHkgdGhlIFtkZWZhdWx0c10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2RlZmF1bHRzLmh0bWwpIHNwZWNpZmllZCBpbiB0aGUgbW9kZWwncyBzY2hlbWEgaWYgYSBuZXcgZG9jdW1lbnQgaXMgY3JlYXRlZFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pbmNsdWRlUmVzdWx0TWV0YWRhdGFdIGlmIHRydWUsIHJldHVybnMgdGhlIGZ1bGwgW01vZGlmeVJlc3VsdCBmcm9tIHRoZSBNb25nb0RCIGRyaXZlcl0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL01vZGlmeVJlc3VsdC5odG1sKSByYXRoZXIgdGhhbiBqdXN0IHRoZSBkb2N1bWVudFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy51cHNlcnQ9ZmFsc2VdIGlmIHRydWUsIGFuZCBubyBkb2N1bWVudHMgZm91bmQsIGluc2VydCBhIG5ldyBkb2N1bWVudFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5uZXc9ZmFsc2VdIGlmIHRydWUsIHJldHVybiB0aGUgbW9kaWZpZWQgZG9jdW1lbnQgcmF0aGVyIHRoYW4gdGhlIG9yaWdpbmFsXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtvcHRpb25zLnNlbGVjdF0gc2V0cyB0aGUgZG9jdW1lbnQgZmllbGRzIHRvIHJldHVybi5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJhbnNsYXRlQWxpYXNlcz1udWxsXSBJZiBzZXQgdG8gYHRydWVgLCB0cmFuc2xhdGVzIGFueSBzY2hlbWEtZGVmaW5lZCBhbGlhc2VzIGluIGBmaWx0ZXJgLCBgcHJvamVjdGlvbmAsIGB1cGRhdGVgLCBhbmQgYGRpc3RpbmN0YC4gVGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGFyZSBhbnkgY29uZmxpY3RzIHdoZXJlIGJvdGggYWxpYXMgYW5kIHJhdyBwcm9wZXJ0eSBhcmUgZGVmaW5lZCBvbiB0aGUgc2FtZSBvYmplY3QuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm92ZXJ3cml0ZURpc2NyaW1pbmF0b3JLZXk9ZmFsc2VdIE1vbmdvb3NlIHJlbW92ZXMgZGlzY3JpbWluYXRvciBrZXkgdXBkYXRlcyBmcm9tIGB1cGRhdGVgIGJ5IGRlZmF1bHQsIHNldCBgb3ZlcndyaXRlRGlzY3JpbWluYXRvcktleWAgdG8gYHRydWVgIHRvIGFsbG93IHVwZGF0aW5nIHRoZSBkaXNjcmltaW5hdG9yIGtleVxuICogQHJldHVybiB7UXVlcnl9XG4gKiBAc2VlIE1vZGVsLmZpbmRPbmVBbmRVcGRhdGUgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsLmZpbmRPbmVBbmRVcGRhdGUoKVxuICogQHNlZSBtb25nb2RiIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9jb21tYW5kL2ZpbmRBbmRNb2RpZnkvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmZpbmRCeUlkQW5kVXBkYXRlID0gZnVuY3Rpb24oaWQsIHVwZGF0ZSwgb3B0aW9ucykge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdmaW5kQnlJZEFuZFVwZGF0ZScpO1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1szXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5maW5kQnlJZEFuZFVwZGF0ZSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIC8vIGlmIGEgbW9kZWwgaXMgcGFzc2VkIGluIGluc3RlYWQgb2YgYW4gaWRcbiAgaWYgKGlkIGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICBpZCA9IGlkLl9pZDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmZpbmRPbmVBbmRVcGRhdGUuY2FsbCh0aGlzLCB7IF9pZDogaWQgfSwgdXBkYXRlLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogSXNzdWUgYSBNb25nb0RCIGBmaW5kT25lQW5kRGVsZXRlKClgIGNvbW1hbmQuXG4gKlxuICogRmluZHMgYSBtYXRjaGluZyBkb2N1bWVudCwgcmVtb3ZlcyBpdCwgYW5kIHJldHVybnMgdGhlIGZvdW5kIGRvY3VtZW50IChpZiBhbnkpLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgdGhlIGZvbGxvd2luZyBtaWRkbGV3YXJlLlxuICpcbiAqIC0gYGZpbmRPbmVBbmREZWxldGUoKWBcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIEEuZmluZE9uZUFuZERlbGV0ZShjb25kaXRpb25zLCBvcHRpb25zKSAgLy8gcmV0dXJuIFF1ZXJ5XG4gKiAgICAgQS5maW5kT25lQW5kRGVsZXRlKGNvbmRpdGlvbnMpIC8vIHJldHVybnMgUXVlcnlcbiAqICAgICBBLmZpbmRPbmVBbmREZWxldGUoKSAgICAgICAgICAgLy8gcmV0dXJucyBRdWVyeVxuICpcbiAqIGBmaW5kT25lQW5kWGAgYW5kIGBmaW5kQnlJZEFuZFhgIGZ1bmN0aW9ucyBzdXBwb3J0IGxpbWl0ZWQgdmFsaWRhdGlvbi4gWW91IGNhblxuICogZW5hYmxlIHZhbGlkYXRpb24gYnkgc2V0dGluZyB0aGUgYHJ1blZhbGlkYXRvcnNgIG9wdGlvbi5cbiAqXG4gKiBJZiB5b3UgbmVlZCBmdWxsLWZsZWRnZWQgdmFsaWRhdGlvbiwgdXNlIHRoZSB0cmFkaXRpb25hbCBhcHByb2FjaCBvZiBmaXJzdFxuICogcmV0cmlldmluZyB0aGUgZG9jdW1lbnQuXG4gKlxuICogICAgIGNvbnN0IGRvYyA9IGF3YWl0IE1vZGVsLmZpbmRCeUlkKGlkKVxuICogICAgIGRvYy5uYW1lID0gJ2phc29uIGJvdXJuZSc7XG4gKiAgICAgYXdhaXQgZG9jLnNhdmUoKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZGl0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25hbCBzZWUgW2BRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKCkpXG4gKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBbb3B0aW9ucy5zdHJpY3RdIG92ZXJ3cml0ZXMgdGhlIHNjaGVtYSdzIFtzdHJpY3QgbW9kZSBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdClcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xTdHJpbmdbXX0gW29wdGlvbnMucHJvamVjdGlvbj1udWxsXSBvcHRpb25hbCBmaWVsZHMgdG8gcmV0dXJuLCBzZWUgW2BRdWVyeS5wcm90b3R5cGUuc2VsZWN0KClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNlbGVjdCgpKVxuICogQHBhcmFtIHtDbGllbnRTZXNzaW9ufSBbb3B0aW9ucy5zZXNzaW9uPW51bGxdIFRoZSBzZXNzaW9uIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHF1ZXJ5LiBTZWUgW3RyYW5zYWN0aW9ucyBkb2NzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHJhbnNhY3Rpb25zLmh0bWwpLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pbmNsdWRlUmVzdWx0TWV0YWRhdGFdIGlmIHRydWUsIHJldHVybnMgdGhlIGZ1bGwgW01vZGlmeVJlc3VsdCBmcm9tIHRoZSBNb25nb0RCIGRyaXZlcl0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL01vZGlmeVJlc3VsdC5odG1sKSByYXRoZXIgdGhhbiBqdXN0IHRoZSBkb2N1bWVudFxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbb3B0aW9ucy5zb3J0XSBpZiBtdWx0aXBsZSBkb2NzIGFyZSBmb3VuZCBieSB0aGUgY29uZGl0aW9ucywgc2V0cyB0aGUgc29ydCBvcmRlciB0byBjaG9vc2Ugd2hpY2ggZG9jIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gW29wdGlvbnMuc2VsZWN0XSBzZXRzIHRoZSBkb2N1bWVudCBmaWVsZHMgdG8gcmV0dXJuLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFRpbWVNU10gcHV0cyBhIHRpbWUgbGltaXQgb24gdGhlIHF1ZXJ5IC0gcmVxdWlyZXMgbW9uZ29kYiA+PSAyLjYuMFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cmFuc2xhdGVBbGlhc2VzPW51bGxdIElmIHNldCB0byBgdHJ1ZWAsIHRyYW5zbGF0ZXMgYW55IHNjaGVtYS1kZWZpbmVkIGFsaWFzZXMgaW4gYGZpbHRlcmAsIGBwcm9qZWN0aW9uYCwgYHVwZGF0ZWAsIGFuZCBgZGlzdGluY3RgLiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIGFueSBjb25mbGljdHMgd2hlcmUgYm90aCBhbGlhcyBhbmQgcmF3IHByb3BlcnR5IGFyZSBkZWZpbmVkIG9uIHRoZSBzYW1lIG9iamVjdC5cbiAqIEByZXR1cm4ge1F1ZXJ5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5maW5kT25lQW5kRGVsZXRlID0gZnVuY3Rpb24oY29uZGl0aW9ucywgb3B0aW9ucykge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdmaW5kT25lQW5kRGVsZXRlJyk7XG5cbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLmZpbmRPbmVBbmREZWxldGUoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICBsZXQgZmllbGRzO1xuICBpZiAob3B0aW9ucykge1xuICAgIGZpZWxkcyA9IG9wdGlvbnMuc2VsZWN0O1xuICAgIG9wdGlvbnMuc2VsZWN0ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3QgbXEgPSBuZXcgdGhpcy5RdWVyeSh7fSwge30sIHRoaXMsIHRoaXMuJF9fY29sbGVjdGlvbik7XG4gIG1xLnNlbGVjdChmaWVsZHMpO1xuXG4gIHJldHVybiBtcS5maW5kT25lQW5kRGVsZXRlKGNvbmRpdGlvbnMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBJc3N1ZSBhIE1vbmdvREIgYGZpbmRPbmVBbmREZWxldGUoKWAgY29tbWFuZCBieSBhIGRvY3VtZW50J3MgX2lkIGZpZWxkLlxuICogSW4gb3RoZXIgd29yZHMsIGBmaW5kQnlJZEFuZERlbGV0ZShpZClgIGlzIGEgc2hvcnRoYW5kIGZvclxuICogYGZpbmRPbmVBbmREZWxldGUoeyBfaWQ6IGlkIH0pYC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIHRoZSBmb2xsb3dpbmcgbWlkZGxld2FyZS5cbiAqXG4gKiAtIGBmaW5kT25lQW5kRGVsZXRlKClgXG4gKlxuICogQHBhcmFtIHtPYmplY3R8TnVtYmVyfFN0cmluZ30gaWQgdmFsdWUgb2YgYF9pZGAgdG8gcXVlcnkgYnlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgc2VlIFtgUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpKVxuICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gW29wdGlvbnMuc3RyaWN0XSBvdmVyd3JpdGVzIHRoZSBzY2hlbWEncyBbc3RyaWN0IG1vZGUgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdHJpY3QpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRyYW5zbGF0ZUFsaWFzZXM9bnVsbF0gSWYgc2V0IHRvIGB0cnVlYCwgdHJhbnNsYXRlcyBhbnkgc2NoZW1hLWRlZmluZWQgYWxpYXNlcyBpbiBgZmlsdGVyYCwgYHByb2plY3Rpb25gLCBgdXBkYXRlYCwgYW5kIGBkaXN0aW5jdGAuIFRocm93cyBhbiBlcnJvciBpZiB0aGVyZSBhcmUgYW55IGNvbmZsaWN0cyB3aGVyZSBib3RoIGFsaWFzIGFuZCByYXcgcHJvcGVydHkgYXJlIGRlZmluZWQgb24gdGhlIHNhbWUgb2JqZWN0LlxuICogQHJldHVybiB7UXVlcnl9XG4gKiBAc2VlIE1vZGVsLmZpbmRPbmVBbmREZWxldGUgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsLmZpbmRPbmVBbmREZWxldGUoKVxuICogQHNlZSBtb25nb2RiIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9jb21tYW5kL2ZpbmRBbmRNb2RpZnkvXG4gKi9cblxuTW9kZWwuZmluZEJ5SWRBbmREZWxldGUgPSBmdW5jdGlvbihpZCwgb3B0aW9ucykge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdmaW5kQnlJZEFuZERlbGV0ZScpO1xuXG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb2RlbC5maW5kQnlJZEFuZERlbGV0ZSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmZpbmRPbmVBbmREZWxldGUoeyBfaWQ6IGlkIH0sIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBJc3N1ZSBhIE1vbmdvREIgYGZpbmRPbmVBbmRSZXBsYWNlKClgIGNvbW1hbmQuXG4gKlxuICogRmluZHMgYSBtYXRjaGluZyBkb2N1bWVudCwgcmVwbGFjZXMgaXQgd2l0aCB0aGUgcHJvdmlkZWQgZG9jLCBhbmQgcmV0dXJucyB0aGUgZG9jdW1lbnQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0cmlnZ2VycyB0aGUgZm9sbG93aW5nIHF1ZXJ5IG1pZGRsZXdhcmUuXG4gKlxuICogLSBgZmluZE9uZUFuZFJlcGxhY2UoKWBcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIEEuZmluZE9uZUFuZFJlcGxhY2UoZmlsdGVyLCByZXBsYWNlbWVudCwgb3B0aW9ucykgIC8vIHJldHVybiBRdWVyeVxuICogICAgIEEuZmluZE9uZUFuZFJlcGxhY2UoZmlsdGVyLCByZXBsYWNlbWVudCkgLy8gcmV0dXJucyBRdWVyeVxuICogICAgIEEuZmluZE9uZUFuZFJlcGxhY2UoKSAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyBRdWVyeVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaWx0ZXIgUmVwbGFjZSB0aGUgZmlyc3QgZG9jdW1lbnQgdGhhdCBtYXRjaGVzIHRoaXMgZmlsdGVyXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcGxhY2VtZW50XSBSZXBsYWNlIHdpdGggdGhpcyBkb2N1bWVudFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25hbCBzZWUgW2BRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKCkpXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucmV0dXJuRG9jdW1lbnQ9J2JlZm9yZSddIEhhcyB0d28gcG9zc2libGUgdmFsdWVzLCBgJ2JlZm9yZSdgIGFuZCBgJ2FmdGVyJ2AuIEJ5IGRlZmF1bHQsIGl0IHdpbGwgcmV0dXJuIHRoZSBkb2N1bWVudCBiZWZvcmUgdGhlIHVwZGF0ZSB3YXMgYXBwbGllZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5sZWFuXSBpZiB0cnV0aHksIG1vbmdvb3NlIHdpbGwgcmV0dXJuIHRoZSBkb2N1bWVudCBhcyBhIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0IHJhdGhlciB0aGFuIGEgbW9uZ29vc2UgZG9jdW1lbnQuIFNlZSBbYFF1ZXJ5LmxlYW4oKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUubGVhbigpKSBhbmQgW3RoZSBNb25nb29zZSBsZWFuIHR1dG9yaWFsXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHV0b3JpYWxzL2xlYW4uaHRtbCkuXG4gKiBAcGFyYW0ge0NsaWVudFNlc3Npb259IFtvcHRpb25zLnNlc3Npb249bnVsbF0gVGhlIHNlc3Npb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgcXVlcnkuIFNlZSBbdHJhbnNhY3Rpb25zIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90cmFuc2FjdGlvbnMuaHRtbCkuXG4gKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBbb3B0aW9ucy5zdHJpY3RdIG92ZXJ3cml0ZXMgdGhlIHNjaGVtYSdzIFtzdHJpY3QgbW9kZSBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdClcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudGltZXN0YW1wcz1udWxsXSBJZiBzZXQgdG8gYGZhbHNlYCBhbmQgW3NjaGVtYS1sZXZlbCB0aW1lc3RhbXBzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0aW1lc3RhbXBzKSBhcmUgZW5hYmxlZCwgc2tpcCB0aW1lc3RhbXBzIGZvciB0aGlzIHVwZGF0ZS4gTm90ZSB0aGF0IHRoaXMgYWxsb3dzIHlvdSB0byBvdmVyd3JpdGUgdGltZXN0YW1wcy4gRG9lcyBub3RoaW5nIGlmIHNjaGVtYS1sZXZlbCB0aW1lc3RhbXBzIGFyZSBub3Qgc2V0LlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfFN0cmluZ1tdfSBbb3B0aW9ucy5wcm9qZWN0aW9uPW51bGxdIG9wdGlvbmFsIGZpZWxkcyB0byByZXR1cm4sIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZWxlY3QoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2VsZWN0KCkpXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtvcHRpb25zLnNvcnRdIGlmIG11bHRpcGxlIGRvY3MgYXJlIGZvdW5kIGJ5IHRoZSBjb25kaXRpb25zLCBzZXRzIHRoZSBzb3J0IG9yZGVyIHRvIGNob29zZSB3aGljaCBkb2MgdG8gdXBkYXRlLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pbmNsdWRlUmVzdWx0TWV0YWRhdGFdIGlmIHRydWUsIHJldHVybnMgdGhlIGZ1bGwgW01vZGlmeVJlc3VsdCBmcm9tIHRoZSBNb25nb0RCIGRyaXZlcl0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL01vZGlmeVJlc3VsdC5odG1sKSByYXRoZXIgdGhhbiBqdXN0IHRoZSBkb2N1bWVudFxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBbb3B0aW9ucy5zZWxlY3RdIHNldHMgdGhlIGRvY3VtZW50IGZpZWxkcyB0byByZXR1cm4uXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4VGltZU1TXSBwdXRzIGEgdGltZSBsaW1pdCBvbiB0aGUgcXVlcnkgLSByZXF1aXJlcyBtb25nb2RiID49IDIuNi4wXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRyYW5zbGF0ZUFsaWFzZXM9bnVsbF0gSWYgc2V0IHRvIGB0cnVlYCwgdHJhbnNsYXRlcyBhbnkgc2NoZW1hLWRlZmluZWQgYWxpYXNlcyBpbiBgZmlsdGVyYCwgYHByb2plY3Rpb25gLCBgdXBkYXRlYCwgYW5kIGBkaXN0aW5jdGAuIFRocm93cyBhbiBlcnJvciBpZiB0aGVyZSBhcmUgYW55IGNvbmZsaWN0cyB3aGVyZSBib3RoIGFsaWFzIGFuZCByYXcgcHJvcGVydHkgYXJlIGRlZmluZWQgb24gdGhlIHNhbWUgb2JqZWN0LlxuICogQHJldHVybiB7UXVlcnl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmZpbmRPbmVBbmRSZXBsYWNlID0gZnVuY3Rpb24oZmlsdGVyLCByZXBsYWNlbWVudCwgb3B0aW9ucykge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdmaW5kT25lQW5kUmVwbGFjZScpO1xuXG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzNdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLmZpbmRPbmVBbmRSZXBsYWNlKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgbGV0IGZpZWxkcztcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBmaWVsZHMgPSBvcHRpb25zLnNlbGVjdDtcbiAgICBvcHRpb25zLnNlbGVjdCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IG1xID0gbmV3IHRoaXMuUXVlcnkoe30sIHt9LCB0aGlzLCB0aGlzLiRfX2NvbGxlY3Rpb24pO1xuICBtcS5zZWxlY3QoZmllbGRzKTtcblxuICByZXR1cm4gbXEuZmluZE9uZUFuZFJlcGxhY2UoZmlsdGVyLCByZXBsYWNlbWVudCwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFNob3J0Y3V0IGZvciBzYXZpbmcgb25lIG9yIG1vcmUgZG9jdW1lbnRzIHRvIHRoZSBkYXRhYmFzZS5cbiAqIGBNeU1vZGVsLmNyZWF0ZShkb2NzKWAgZG9lcyBgbmV3IE15TW9kZWwoZG9jKS5zYXZlKClgIGZvciBldmVyeSBkb2MgaW5cbiAqIGRvY3MuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0cmlnZ2VycyB0aGUgZm9sbG93aW5nIG1pZGRsZXdhcmUuXG4gKlxuICogLSBgc2F2ZSgpYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gSW5zZXJ0IG9uZSBuZXcgYENoYXJhY3RlcmAgZG9jdW1lbnRcbiAqICAgICBhd2FpdCBDaGFyYWN0ZXIuY3JlYXRlKHsgbmFtZTogJ0plYW4tTHVjIFBpY2FyZCcgfSk7XG4gKlxuICogICAgIC8vIEluc2VydCBtdWx0aXBsZSBuZXcgYENoYXJhY3RlcmAgZG9jdW1lbnRzXG4gKiAgICAgYXdhaXQgQ2hhcmFjdGVyLmNyZWF0ZShbeyBuYW1lOiAnV2lsbCBSaWtlcicgfSwgeyBuYW1lOiAnR2VvcmRpIExhRm9yZ2UnIH1dKTtcbiAqXG4gKiAgICAgLy8gQ3JlYXRlIGEgbmV3IGNoYXJhY3RlciB3aXRoaW4gYSB0cmFuc2FjdGlvbi4gTm90ZSB0aGF0IHlvdSAqKm11c3QqKlxuICogICAgIC8vIHBhc3MgYW4gYXJyYXkgYXMgdGhlIGZpcnN0IHBhcmFtZXRlciB0byBgY3JlYXRlKClgIGlmIHlvdSB3YW50IHRvXG4gKiAgICAgLy8gc3BlY2lmeSBvcHRpb25zLlxuICogICAgIGF3YWl0IENoYXJhY3Rlci5jcmVhdGUoW3sgbmFtZTogJ0plYW4tTHVjIFBpY2FyZCcgfV0sIHsgc2Vzc2lvbiB9KTtcbiAqXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gZG9jcyBEb2N1bWVudHMgdG8gaW5zZXJ0LCBhcyBhIHNwcmVhZCBvciBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIHBhc3NlZCBkb3duIHRvIGBzYXZlKClgLiBUbyBzcGVjaWZ5IGBvcHRpb25zYCwgYGRvY3NgICoqbXVzdCoqIGJlIGFuIGFycmF5LCBub3QgYSBzcHJlYWQuIFNlZSBbTW9kZWwuc2F2ZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsLnByb3RvdHlwZS5zYXZlKCkpIGZvciBhdmFpbGFibGUgb3B0aW9ucy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMub3JkZXJlZF0gc2F2ZXMgdGhlIGRvY3MgaW4gc2VyaWVzIHJhdGhlciB0aGFuIHBhcmFsbGVsLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hZ2dyZWdhdGVFcnJvcnNdIEFnZ3JlZ2F0ZSBFcnJvcnMgaW5zdGVhZCBvZiB0aHJvd2luZyB0aGUgZmlyc3Qgb25lIHRoYXQgb2NjdXJzLiBEZWZhdWx0OiBmYWxzZVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwuY3JlYXRlID0gYXN5bmMgZnVuY3Rpb24gY3JlYXRlKGRvYywgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwuY3JlYXRlKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnY3JlYXRlJyk7XG5cbiAgbGV0IGFyZ3M7XG4gIGNvbnN0IGRpc2NyaW1pbmF0b3JLZXkgPSB0aGlzLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoZG9jKSkge1xuICAgIGFyZ3MgPSBkb2M7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgIT0gbnVsbCAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgPyBvcHRpb25zIDoge307XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbGFzdCA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAgb3B0aW9ucyA9IHt9O1xuICAgIGNvbnN0IGhhc0NhbGxiYWNrID0gdHlwZW9mIGxhc3QgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nO1xuICAgIGlmIChoYXNDYWxsYmFjaykge1xuICAgICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLmNyZWF0ZSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXJncyA9IFsuLi5hcmd1bWVudHNdO1xuICAgICAgLy8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggNi54LCBiZWNhdXNlIG9mIGdoLTUwNjEgTW9uZ29vc2UgNi54IGFuZFxuICAgICAgLy8gb2xkZXIgd291bGQgdHJlYXQgYSBmYWxzeSBsYXN0IGFyZyBhcyBhIGNhbGxiYWNrLiBXZSBkb24ndCB3YW50IHRvIHRocm93XG4gICAgICAvLyBhbiBlcnJvciBoZXJlLCBiZWNhdXNlIGl0IHdvdWxkIGxvb2sgc3RyYW5nZSBpZiBgVGVzdC5jcmVhdGUoe30sIHZvaWQgMClgXG4gICAgICAvLyB0aHJldyBhIGNhbGxiYWNrIGVycm9yLiBCdXQgd2UgYWxzbyBkb24ndCB3YW50IHRvIGNyZWF0ZSBhbiB1bm5lY2Vzc2FyeSBkb2N1bWVudC5cbiAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDEgJiYgIWxhc3QpIHtcbiAgICAgICAgYXJncy5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgYXJnc1swXSAhPSBudWxsICYmXG4gICAgICAgIGFyZ3NbMV0gIT0gbnVsbCAmJlxuICAgICAgICBhcmdzWzBdLnNlc3Npb24gPT0gbnVsbCAmJlxuICAgICAgICBsYXN0ICYmXG4gICAgICAgIGdldENvbnN0cnVjdG9yTmFtZShsYXN0LnNlc3Npb24pID09PSAnQ2xpZW50U2Vzc2lvbicgJiZcbiAgICAgICAgIXRoaXMuc2NoZW1hLnBhdGgoJ3Nlc3Npb24nKSkge1xuICAgICAgLy8gUHJvYmFibHkgbWVhbnMgdGhlIHVzZXIgaXMgcnVubmluZyBpbnRvIHRoZSBjb21tb24gbWlzdGFrZSBvZiB0cnlpbmdcbiAgICAgIC8vIHRvIHVzZSBhIHNwcmVhZCB0byBzcGVjaWZ5IG9wdGlvbnMsIHNlZSBnaC03NTM1XG4gICAgICB1dGlscy53YXJuKCdXQVJOSU5HOiB0byBwYXNzIGEgYHNlc3Npb25gIHRvIGBNb2RlbC5jcmVhdGUoKWAgaW4gJyArXG4gICAgICAgICdNb25nb29zZSwgeW91ICoqbXVzdCoqIHBhc3MgYW4gYXJyYXkgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LiBTZWU6ICcgK1xuICAgICAgICAnaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsLmNyZWF0ZSgpJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZG9jKSA/IFtdIDogbnVsbDtcbiAgfVxuICBsZXQgcmVzID0gW107XG4gIGNvbnN0IGltbWVkaWF0ZUVycm9yID0gdHlwZW9mIG9wdGlvbnMuYWdncmVnYXRlRXJyb3JzID09PSAnYm9vbGVhbicgPyAhb3B0aW9ucy5hZ2dyZWdhdGVFcnJvcnMgOiB0cnVlO1xuXG4gIGRlbGV0ZSBvcHRpb25zLmFnZ3JlZ2F0ZUVycm9yczsgLy8gZG9udCBwYXNzIG9uIHRoZSBvcHRpb24gdG8gXCIkc2F2ZVwiXG5cbiAgaWYgKG9wdGlvbnMub3JkZXJlZCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZG9jID0gYXJnc1tpXTtcbiAgICAgICAgY29uc3QgTW9kZWwgPSB0aGlzLmRpc2NyaW1pbmF0b3JzICYmIGRvY1tkaXNjcmltaW5hdG9yS2V5XSAhPSBudWxsID9cbiAgICAgICAgICB0aGlzLmRpc2NyaW1pbmF0b3JzW2RvY1tkaXNjcmltaW5hdG9yS2V5XV0gfHwgZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUodGhpcy5kaXNjcmltaW5hdG9ycywgZG9jW2Rpc2NyaW1pbmF0b3JLZXldKSA6XG4gICAgICAgICAgdGhpcztcbiAgICAgICAgaWYgKE1vZGVsID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcihgRGlzY3JpbWluYXRvciBcIiR7ZG9jW2Rpc2NyaW1pbmF0b3JLZXldfVwiIG5vdCBgICtcbiAgICAgICAgICBgZm91bmQgZm9yIG1vZGVsIFwiJHt0aGlzLm1vZGVsTmFtZX1cImApO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b1NhdmUgPSBkb2M7XG4gICAgICAgIGlmICghKHRvU2F2ZSBpbnN0YW5jZW9mIE1vZGVsKSkge1xuICAgICAgICAgIHRvU2F2ZSA9IG5ldyBNb2RlbCh0b1NhdmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgdG9TYXZlLiRzYXZlKG9wdGlvbnMpO1xuICAgICAgICByZXMucHVzaCh0b1NhdmUpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmICghaW1tZWRpYXRlRXJyb3IpIHtcbiAgICAgICAgICByZXMucHVzaChlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9IGVsc2UgaWYgKCFpbW1lZGlhdGVFcnJvcikge1xuICAgIHJlcyA9IGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChhcmdzLm1hcChhc3luYyBkb2MgPT4ge1xuICAgICAgY29uc3QgTW9kZWwgPSB0aGlzLmRpc2NyaW1pbmF0b3JzICYmIGRvY1tkaXNjcmltaW5hdG9yS2V5XSAhPSBudWxsID9cbiAgICAgICAgdGhpcy5kaXNjcmltaW5hdG9yc1tkb2NbZGlzY3JpbWluYXRvcktleV1dIHx8IGdldERpc2NyaW1pbmF0b3JCeVZhbHVlKHRoaXMuZGlzY3JpbWluYXRvcnMsIGRvY1tkaXNjcmltaW5hdG9yS2V5XSkgOlxuICAgICAgICB0aGlzO1xuICAgICAgaWYgKE1vZGVsID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoYERpc2NyaW1pbmF0b3IgXCIke2RvY1tkaXNjcmltaW5hdG9yS2V5XX1cIiBub3QgYCArXG4gICAgICAgICAgICBgZm91bmQgZm9yIG1vZGVsIFwiJHt0aGlzLm1vZGVsTmFtZX1cImApO1xuICAgICAgfVxuICAgICAgbGV0IHRvU2F2ZSA9IGRvYztcblxuICAgICAgaWYgKCEodG9TYXZlIGluc3RhbmNlb2YgTW9kZWwpKSB7XG4gICAgICAgIHRvU2F2ZSA9IG5ldyBNb2RlbCh0b1NhdmUpO1xuICAgICAgfVxuXG4gICAgICBhd2FpdCB0b1NhdmUuJHNhdmUob3B0aW9ucyk7XG5cbiAgICAgIHJldHVybiB0b1NhdmU7XG4gICAgfSkpO1xuICAgIHJlcyA9IHJlcy5tYXAocmVzdWx0ID0+IHJlc3VsdC5zdGF0dXMgPT09ICdmdWxmaWxsZWQnID8gcmVzdWx0LnZhbHVlIDogcmVzdWx0LnJlYXNvbik7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGZpcnN0RXJyb3IgPSBudWxsO1xuICAgIHJlcyA9IGF3YWl0IFByb21pc2UuYWxsKGFyZ3MubWFwKGFzeW5jIGRvYyA9PiB7XG4gICAgICBjb25zdCBNb2RlbCA9IHRoaXMuZGlzY3JpbWluYXRvcnMgJiYgZG9jW2Rpc2NyaW1pbmF0b3JLZXldICE9IG51bGwgP1xuICAgICAgICB0aGlzLmRpc2NyaW1pbmF0b3JzW2RvY1tkaXNjcmltaW5hdG9yS2V5XV0gfHwgZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUodGhpcy5kaXNjcmltaW5hdG9ycywgZG9jW2Rpc2NyaW1pbmF0b3JLZXldKSA6XG4gICAgICAgIHRoaXM7XG4gICAgICBpZiAoTW9kZWwgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcihgRGlzY3JpbWluYXRvciBcIiR7ZG9jW2Rpc2NyaW1pbmF0b3JLZXldfVwiIG5vdCBgICtcbiAgICAgICAgICAgIGBmb3VuZCBmb3IgbW9kZWwgXCIke3RoaXMubW9kZWxOYW1lfVwiYCk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgdG9TYXZlID0gZG9jO1xuXG4gICAgICAgIGlmICghKHRvU2F2ZSBpbnN0YW5jZW9mIE1vZGVsKSkge1xuICAgICAgICAgIHRvU2F2ZSA9IG5ldyBNb2RlbCh0b1NhdmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgdG9TYXZlLiRzYXZlKG9wdGlvbnMpO1xuXG4gICAgICAgIHJldHVybiB0b1NhdmU7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKCFmaXJzdEVycm9yKSB7XG4gICAgICAgICAgZmlyc3RFcnJvciA9IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKTtcbiAgICBpZiAoZmlyc3RFcnJvcikge1xuICAgICAgdGhyb3cgZmlyc3RFcnJvcjtcbiAgICB9XG4gIH1cblxuXG4gIGlmICghQXJyYXkuaXNBcnJheShkb2MpICYmIGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHJlc1swXTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG4vKipcbiAqIF9SZXF1aXJlcyBhIHJlcGxpY2Egc2V0IHJ1bm5pbmcgTW9uZ29EQiA+PSAzLjYuMC5fIFdhdGNoZXMgdGhlXG4gKiB1bmRlcmx5aW5nIGNvbGxlY3Rpb24gZm9yIGNoYW5nZXMgdXNpbmdcbiAqIFtNb25nb0RCIGNoYW5nZSBzdHJlYW1zXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9jaGFuZ2VTdHJlYW1zLykuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBkb2VzICoqbm90KiogdHJpZ2dlciBhbnkgbWlkZGxld2FyZS4gSW4gcGFydGljdWxhciwgaXRcbiAqIGRvZXMgKipub3QqKiB0cmlnZ2VyIGFnZ3JlZ2F0ZSBtaWRkbGV3YXJlLlxuICpcbiAqIFRoZSBDaGFuZ2VTdHJlYW0gb2JqZWN0IGlzIGFuIGV2ZW50IGVtaXR0ZXIgdGhhdCBlbWl0cyB0aGUgZm9sbG93aW5nIGV2ZW50czpcbiAqXG4gKiAtICdjaGFuZ2UnOiBBIGNoYW5nZSBvY2N1cnJlZCwgc2VlIGJlbG93IGV4YW1wbGVcbiAqIC0gJ2Vycm9yJzogQW4gdW5yZWNvdmVyYWJsZSBlcnJvciBvY2N1cnJlZC4gSW4gcGFydGljdWxhciwgY2hhbmdlIHN0cmVhbXMgY3VycmVudGx5IGVycm9yIG91dCBpZiB0aGV5IGxvc2UgY29ubmVjdGlvbiB0byB0aGUgcmVwbGljYSBzZXQgcHJpbWFyeS4gRm9sbG93IFt0aGlzIEdpdEh1YiBpc3N1ZV0oaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvbW9uZ29vc2UvaXNzdWVzLzY3OTkpIGZvciB1cGRhdGVzLlxuICogLSAnZW5kJzogRW1pdHRlZCBpZiB0aGUgdW5kZXJseWluZyBzdHJlYW0gaXMgY2xvc2VkXG4gKiAtICdjbG9zZSc6IEVtaXR0ZWQgaWYgdGhlIHVuZGVybHlpbmcgc3RyZWFtIGlzIGNsb3NlZFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgZG9jID0gYXdhaXQgUGVyc29uLmNyZWF0ZSh7IG5hbWU6ICdOZWQgU3RhcmsnIH0pO1xuICogICAgIGNvbnN0IGNoYW5nZVN0cmVhbSA9IFBlcnNvbi53YXRjaCgpLm9uKCdjaGFuZ2UnLCBjaGFuZ2UgPT4gY29uc29sZS5sb2coY2hhbmdlKSk7XG4gKiAgICAgLy8gV2lsbCBwcmludCBmcm9tIHRoZSBhYm92ZSBgY29uc29sZS5sb2coKWA6XG4gKiAgICAgLy8geyBfaWQ6IHsgX2RhdGE6IC4uLiB9LFxuICogICAgIC8vICAgb3BlcmF0aW9uVHlwZTogJ2RlbGV0ZScsXG4gKiAgICAgLy8gICBuczogeyBkYjogJ215ZGInLCBjb2xsOiAnUGVyc29uJyB9LFxuICogICAgIC8vICAgZG9jdW1lbnRLZXk6IHsgX2lkOiA1YTUxYjEyNWM1NTAwZjVhYTA5NGM3YmQgfSB9XG4gKiAgICAgYXdhaXQgZG9jLnJlbW92ZSgpO1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IFtwaXBlbGluZV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gc2VlIHRoZSBbbW9uZ29kYiBkcml2ZXIgb3B0aW9uc10oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0NvbGxlY3Rpb24uaHRtbCN3YXRjaClcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaHlkcmF0ZT1mYWxzZV0gaWYgdHJ1ZSBhbmQgYGZ1bGxEb2N1bWVudDogJ3VwZGF0ZUxvb2t1cCdgIGlzIHNldCwgTW9uZ29vc2Ugd2lsbCBhdXRvbWF0aWNhbGx5IGh5ZHJhdGUgYGZ1bGxEb2N1bWVudGAgaW50byBhIGZ1bGx5IGZsZWRnZWQgTW9uZ29vc2UgZG9jdW1lbnRcbiAqIEByZXR1cm4ge0NoYW5nZVN0cmVhbX0gbW9uZ29vc2Utc3BlY2lmaWMgY2hhbmdlIHN0cmVhbSB3cmFwcGVyLCBpbmhlcml0cyBmcm9tIEV2ZW50RW1pdHRlclxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC53YXRjaCA9IGZ1bmN0aW9uKHBpcGVsaW5lLCBvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ3dhdGNoJyk7XG5cbiAgY29uc3QgY2hhbmdlU3RyZWFtVGh1bmsgPSBjYiA9PiB7XG4gICAgcGlwZWxpbmUgPSBwaXBlbGluZSB8fCBbXTtcbiAgICBwcmVwYXJlRGlzY3JpbWluYXRvclBpcGVsaW5lKHBpcGVsaW5lLCB0aGlzLnNjaGVtYSwgJ2Z1bGxEb2N1bWVudCcpO1xuICAgIGlmICh0aGlzLiRfX2NvbGxlY3Rpb24uYnVmZmVyKSB7XG4gICAgICB0aGlzLiRfX2NvbGxlY3Rpb24uYWRkUXVldWUoKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZHJpdmVyQ2hhbmdlU3RyZWFtID0gdGhpcy4kX19jb2xsZWN0aW9uLndhdGNoKHBpcGVsaW5lLCBvcHRpb25zKTtcbiAgICAgICAgY2IobnVsbCwgZHJpdmVyQ2hhbmdlU3RyZWFtKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkcml2ZXJDaGFuZ2VTdHJlYW0gPSB0aGlzLiRfX2NvbGxlY3Rpb24ud2F0Y2gocGlwZWxpbmUsIG9wdGlvbnMpO1xuICAgICAgY2IobnVsbCwgZHJpdmVyQ2hhbmdlU3RyZWFtKTtcbiAgICB9XG4gIH07XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMubW9kZWwgPSB0aGlzO1xuXG4gIHJldHVybiBuZXcgQ2hhbmdlU3RyZWFtKGNoYW5nZVN0cmVhbVRodW5rLCBwaXBlbGluZSwgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIF9SZXF1aXJlcyBNb25nb0RCID49IDMuNi4wLl8gU3RhcnRzIGEgW01vbmdvREIgc2Vzc2lvbl0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVsZWFzZS1ub3Rlcy8zLjYvI2NsaWVudC1zZXNzaW9ucylcbiAqIGZvciBiZW5lZml0cyBsaWtlIGNhdXNhbCBjb25zaXN0ZW5jeSwgW3JldHJ5YWJsZSB3cml0ZXNdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL2NvcmUvcmV0cnlhYmxlLXdyaXRlcy8pLFxuICogYW5kIFt0cmFuc2FjdGlvbnNdKGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vYS1ub2RlLWpzLXBlcnNwZWN0aXZlLW9uLW1vbmdvZGItNC10cmFuc2FjdGlvbnMuaHRtbCkuXG4gKlxuICogQ2FsbGluZyBgTXlNb2RlbC5zdGFydFNlc3Npb24oKWAgaXMgZXF1aXZhbGVudCB0byBjYWxsaW5nIGBNeU1vZGVsLmRiLnN0YXJ0U2Vzc2lvbigpYC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHRyaWdnZXIgYW55IG1pZGRsZXdhcmUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgUGVyc29uLnN0YXJ0U2Vzc2lvbigpO1xuICogICAgIGxldCBkb2MgPSBhd2FpdCBQZXJzb24uZmluZE9uZSh7IG5hbWU6ICdOZWQgU3RhcmsnIH0sIG51bGwsIHsgc2Vzc2lvbiB9KTtcbiAqICAgICBhd2FpdCBkb2MucmVtb3ZlKCk7XG4gKiAgICAgLy8gYGRvY2Agd2lsbCBhbHdheXMgYmUgbnVsbCwgZXZlbiBpZiByZWFkaW5nIGZyb20gYSByZXBsaWNhIHNldFxuICogICAgIC8vIHNlY29uZGFyeS4gV2l0aG91dCBjYXVzYWwgY29uc2lzdGVuY3ksIGl0IGlzIHBvc3NpYmxlIHRvXG4gKiAgICAgLy8gZ2V0IGEgZG9jIGJhY2sgZnJvbSB0aGUgYmVsb3cgcXVlcnkgaWYgdGhlIHF1ZXJ5IHJlYWRzIGZyb20gYVxuICogICAgIC8vIHNlY29uZGFyeSB0aGF0IGlzIGV4cGVyaWVuY2luZyByZXBsaWNhdGlvbiBsYWcuXG4gKiAgICAgZG9jID0gYXdhaXQgUGVyc29uLmZpbmRPbmUoeyBuYW1lOiAnTmVkIFN0YXJrJyB9LCBudWxsLCB7IHNlc3Npb24sIHJlYWRQcmVmZXJlbmNlOiAnc2Vjb25kYXJ5JyB9KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIHNlZSB0aGUgW21vbmdvZGIgZHJpdmVyIG9wdGlvbnNdKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9Nb25nb0NsaWVudC5odG1sI3N0YXJ0U2Vzc2lvbilcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2F1c2FsQ29uc2lzdGVuY3k9dHJ1ZV0gc2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgY2F1c2FsIGNvbnNpc3RlbmN5XG4gKiBAcmV0dXJuIHtQcm9taXNlPENsaWVudFNlc3Npb24+fSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBNb25nb0RCIGRyaXZlciBgQ2xpZW50U2Vzc2lvbmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwuc3RhcnRTZXNzaW9uID0gZnVuY3Rpb24oKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ3N0YXJ0U2Vzc2lvbicpO1xuXG4gIHJldHVybiB0aGlzLmRiLnN0YXJ0U2Vzc2lvbi5hcHBseSh0aGlzLmRiLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBTaG9ydGN1dCBmb3IgdmFsaWRhdGluZyBhbiBhcnJheSBvZiBkb2N1bWVudHMgYW5kIGluc2VydGluZyB0aGVtIGludG9cbiAqIE1vbmdvREIgaWYgdGhleSdyZSBhbGwgdmFsaWQuIFRoaXMgZnVuY3Rpb24gaXMgZmFzdGVyIHRoYW4gYC5jcmVhdGUoKWBcbiAqIGJlY2F1c2UgaXQgb25seSBzZW5kcyBvbmUgb3BlcmF0aW9uIHRvIHRoZSBzZXJ2ZXIsIHJhdGhlciB0aGFuIG9uZSBmb3IgZWFjaFxuICogZG9jdW1lbnQuXG4gKlxuICogTW9uZ29vc2UgYWx3YXlzIHZhbGlkYXRlcyBlYWNoIGRvY3VtZW50ICoqYmVmb3JlKiogc2VuZGluZyBgaW5zZXJ0TWFueWBcbiAqIHRvIE1vbmdvREIuIFNvIGlmIG9uZSBkb2N1bWVudCBoYXMgYSB2YWxpZGF0aW9uIGVycm9yLCBubyBkb2N1bWVudHMgd2lsbFxuICogYmUgc2F2ZWQsIHVubGVzcyB5b3Ugc2V0XG4gKiBbdGhlIGBvcmRlcmVkYCBvcHRpb24gdG8gZmFsc2VdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvZGIuY29sbGVjdGlvbi5pbnNlcnRNYW55LyNlcnJvci1oYW5kbGluZykuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBkb2VzICoqbm90KiogdHJpZ2dlciBzYXZlIG1pZGRsZXdhcmUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0cmlnZ2VycyB0aGUgZm9sbG93aW5nIG1pZGRsZXdhcmUuXG4gKlxuICogLSBgaW5zZXJ0TWFueSgpYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYXdhaXQgTW92aWVzLmluc2VydE1hbnkoW1xuICogICAgICAgeyBuYW1lOiAnU3RhciBXYXJzJyB9LFxuICogICAgICAgeyBuYW1lOiAnVGhlIEVtcGlyZSBTdHJpa2VzIEJhY2snIH1cbiAqICAgICBdKTtcbiAqXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdHwqfSBkb2MocylcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gc2VlIHRoZSBbbW9uZ29kYiBkcml2ZXIgb3B0aW9uc10oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0NvbGxlY3Rpb24uaHRtbCNpbnNlcnRNYW55KVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vcmRlcmVkPXRydWVdIGlmIHRydWUsIHdpbGwgZmFpbCBmYXN0IG9uIHRoZSBmaXJzdCBlcnJvciBlbmNvdW50ZXJlZC4gSWYgZmFsc2UsIHdpbGwgaW5zZXJ0IGFsbCB0aGUgZG9jdW1lbnRzIGl0IGNhbiBhbmQgcmVwb3J0IGVycm9ycyBsYXRlci4gQW4gYGluc2VydE1hbnkoKWAgd2l0aCBgb3JkZXJlZCA9IGZhbHNlYCBpcyBjYWxsZWQgYW4gXCJ1bm9yZGVyZWRcIiBgaW5zZXJ0TWFueSgpYC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmF3UmVzdWx0PWZhbHNlXSBpZiBmYWxzZSwgdGhlIHJldHVybmVkIHByb21pc2UgcmVzb2x2ZXMgdG8gdGhlIGRvY3VtZW50cyB0aGF0IHBhc3NlZCBtb25nb29zZSBkb2N1bWVudCB2YWxpZGF0aW9uLiBJZiBgdHJ1ZWAsIHdpbGwgcmV0dXJuIHRoZSBbcmF3IHJlc3VsdCBmcm9tIHRoZSBNb25nb0RCIGRyaXZlcl0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL0luc2VydE1hbnlSZXN1bHQuaHRtbCkgd2l0aCBhIGBtb25nb29zZWAgcHJvcGVydHkgdGhhdCBjb250YWlucyBgdmFsaWRhdGlvbkVycm9yc2AgYW5kIGByZXN1bHRzYCBpZiB0aGlzIGlzIGFuIHVub3JkZXJlZCBgaW5zZXJ0TWFueWAuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmxlYW49ZmFsc2VdIGlmIGB0cnVlYCwgc2tpcHMgaHlkcmF0aW5nIHRoZSBkb2N1bWVudHMuIFRoaXMgbWVhbnMgTW9uZ29vc2Ugd2lsbCAqKm5vdCoqIGNhc3Qgb3IgdmFsaWRhdGUgYW55IG9mIHRoZSBkb2N1bWVudHMgcGFzc2VkIHRvIGBpbnNlcnRNYW55KClgLiBUaGlzIG9wdGlvbiBpcyB1c2VmdWwgaWYgeW91IG5lZWQgdGhlIGV4dHJhIHBlcmZvcm1hbmNlLCBidXQgY29tZXMgd2l0aCBkYXRhIGludGVncml0eSByaXNrLiBDb25zaWRlciB1c2luZyB3aXRoIFtgY2FzdE9iamVjdCgpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsLmNhc3RPYmplY3QoKSkuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubGltaXQ9bnVsbF0gdGhpcyBsaW1pdHMgdGhlIG51bWJlciBvZiBkb2N1bWVudHMgYmVpbmcgcHJvY2Vzc2VkICh2YWxpZGF0aW9uL2Nhc3RpbmcpIGJ5IG1vbmdvb3NlIGluIHBhcmFsbGVsLCB0aGlzIGRvZXMgKipOT1QqKiBzZW5kIHRoZSBkb2N1bWVudHMgaW4gYmF0Y2hlcyB0byBNb25nb0RCLiBVc2UgdGhpcyBvcHRpb24gaWYgeW91J3JlIHByb2Nlc3NpbmcgYSBsYXJnZSBudW1iZXIgb2YgZG9jdW1lbnRzIGFuZCB5b3VyIGFwcCBpcyBydW5uaW5nIG91dCBvZiBtZW1vcnkuXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8QXJyYXl9IFtvcHRpb25zLnBvcHVsYXRlPW51bGxdIHBvcHVsYXRlcyB0aGUgcmVzdWx0IGRvY3VtZW50cy4gVGhpcyBvcHRpb24gaXMgYSBuby1vcCBpZiBgcmF3UmVzdWx0YCBpcyBzZXQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRocm93T25WYWxpZGF0aW9uRXJyb3I9ZmFsc2VdIElmIHRydWUgYW5kIGBvcmRlcmVkOiBmYWxzZWAsIHRocm93IGFuIGVycm9yIGlmIG9uZSBvZiB0aGUgb3BlcmF0aW9ucyBmYWlsZWQgdmFsaWRhdGlvbiwgYnV0IGFsbCB2YWxpZCBvcGVyYXRpb25zIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuXG4gKiBAcmV0dXJuIHtQcm9taXNlfSByZXNvbHZpbmcgdG8gdGhlIHJhdyByZXN1bHQgZnJvbSB0aGUgTW9uZ29EQiBkcml2ZXIgaWYgYG9wdGlvbnMucmF3UmVzdWx0YCB3YXMgYHRydWVgLCBvciB0aGUgZG9jdW1lbnRzIHRoYXQgcGFzc2VkIHZhbGlkYXRpb24sIG90aGVyd2lzZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5pbnNlcnRNYW55ID0gYXN5bmMgZnVuY3Rpb24gaW5zZXJ0TWFueShhcnIsIG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnaW5zZXJ0TWFueScpO1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgfHxcbiAgICB0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLmluc2VydE1hbnkoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHRoaXMuJF9faW5zZXJ0TWFueShhcnIsIG9wdGlvbnMsIChlcnIsIHJlcykgPT4ge1xuICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUocmVzKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIGlnbm9yZVxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHByaXZhdGVcbiAqIEBtZW1iZXJPZiBNb2RlbFxuICogQG1ldGhvZCAkX19pbnNlcnRNYW55XG4gKiBAc3RhdGljXG4gKi9cblxuTW9kZWwuJF9faW5zZXJ0TWFueSA9IGZ1bmN0aW9uKGFyciwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cblxuICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IHV0aWxzLm5vb3A7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBsaW1pdCA9IG9wdGlvbnMubGltaXQgfHwgMTAwMDtcbiAgY29uc3QgcmF3UmVzdWx0ID0gISFvcHRpb25zLnJhd1Jlc3VsdDtcbiAgY29uc3Qgb3JkZXJlZCA9IHR5cGVvZiBvcHRpb25zLm9yZGVyZWQgPT09ICdib29sZWFuJyA/IG9wdGlvbnMub3JkZXJlZCA6IHRydWU7XG4gIGNvbnN0IHRocm93T25WYWxpZGF0aW9uRXJyb3IgPSB0eXBlb2Ygb3B0aW9ucy50aHJvd09uVmFsaWRhdGlvbkVycm9yID09PSAnYm9vbGVhbicgPyBvcHRpb25zLnRocm93T25WYWxpZGF0aW9uRXJyb3IgOiBmYWxzZTtcbiAgY29uc3QgbGVhbiA9ICEhb3B0aW9ucy5sZWFuO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgYXJyID0gW2Fycl07XG4gIH1cblxuICBjb25zdCB2YWxpZGF0aW9uRXJyb3JzID0gW107XG4gIGNvbnN0IHZhbGlkYXRpb25FcnJvcnNUb09yaWdpbmFsT3JkZXIgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IHJlc3VsdHMgPSBvcmRlcmVkID8gbnVsbCA6IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgY29uc3QgdG9FeGVjdXRlID0gYXJyLm1hcCgoZG9jLCBpbmRleCkgPT5cbiAgICBjYWxsYmFjayA9PiB7XG4gICAgICAvLyBJZiBvcHRpb24gYGxlYW5gIGlzIHNldCB0byB0cnVlIGJ5cGFzcyB2YWxpZGF0aW9uIGFuZCBoeWRyYXRpb25cbiAgICAgIGlmIChsZWFuKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgdG8gZXhlY3V0ZSBjYWxsYmFjayBhdCB0aGUgbmV4dFRpY2sgdG8gYmUgY29tcGF0aWJsZVxuICAgICAgICAvLyB3aXRoIHBhcmFsbGVsTGltaXQsIGFzIGByZXN1bHRzYCB2YXJpYWJsZSBoYXMgVERaIGlzc3VlIGlmIHdlXG4gICAgICAgIC8vIGV4ZWN1dGUgdGhlIGNhbGxiYWNrIHN5bmNocm9ub3VzbHlcbiAgICAgICAgcmV0dXJuIGltbWVkaWF0ZSgoKSA9PiBjYWxsYmFjayhudWxsLCBkb2MpKTtcbiAgICAgIH1cbiAgICAgIGlmICghKGRvYyBpbnN0YW5jZW9mIF90aGlzKSkge1xuICAgICAgICBpZiAoZG9jICE9IG51bGwgJiYgdHlwZW9mIGRvYyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IE9iamVjdFBhcmFtZXRlckVycm9yKGRvYywgJ2Fyci4nICsgaW5kZXgsICdpbnNlcnRNYW55JykpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZG9jID0gbmV3IF90aGlzKGRvYyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5zZXNzaW9uICE9IG51bGwpIHtcbiAgICAgICAgZG9jLiRzZXNzaW9uKG9wdGlvbnMuc2Vzc2lvbik7XG4gICAgICB9XG4gICAgICAvLyBJZiBvcHRpb24gYGxlYW5gIGlzIHNldCB0byB0cnVlIGJ5cGFzcyB2YWxpZGF0aW9uXG4gICAgICBpZiAobGVhbikge1xuICAgICAgICAvLyB3ZSBoYXZlIHRvIGV4ZWN1dGUgY2FsbGJhY2sgYXQgdGhlIG5leHRUaWNrIHRvIGJlIGNvbXBhdGlibGVcbiAgICAgICAgLy8gd2l0aCBwYXJhbGxlbExpbWl0LCBhcyBgcmVzdWx0c2AgdmFyaWFibGUgaGFzIFREWiBpc3N1ZSBpZiB3ZVxuICAgICAgICAvLyBleGVjdXRlIHRoZSBjYWxsYmFjayBzeW5jaHJvbm91c2x5XG4gICAgICAgIHJldHVybiBpbW1lZGlhdGUoKCkgPT4gY2FsbGJhY2sobnVsbCwgZG9jKSk7XG4gICAgICB9XG4gICAgICBkb2MuJHZhbGlkYXRlKCkudGhlbihcbiAgICAgICAgKCkgPT4geyBjYWxsYmFjayhudWxsLCBkb2MpOyB9LFxuICAgICAgICBlcnJvciA9PiB7XG4gICAgICAgICAgaWYgKG9yZGVyZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uRXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgICAgICAgdmFsaWRhdGlvbkVycm9yc1RvT3JpZ2luYWxPcmRlci5zZXQoZXJyb3IsIGluZGV4KTtcbiAgICAgICAgICAgIHJlc3VsdHNbaW5kZXhdID0gZXJyb3I7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcblxuICBwYXJhbGxlbExpbWl0KHRvRXhlY3V0ZSwgbGltaXQsIGZ1bmN0aW9uKGVycm9yLCBkb2NzKSB7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjYWxsYmFjayhlcnJvciwgbnVsbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgb3JpZ2luYWxEb2NJbmRleCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCB2YWxpZERvY0luZGV4VG9PcmlnaW5hbEluZGV4ID0gbmV3IE1hcCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZG9jcy5sZW5ndGg7ICsraSkge1xuICAgICAgb3JpZ2luYWxEb2NJbmRleC5zZXQoZG9jc1tpXSwgaSk7XG4gICAgfVxuXG4gICAgLy8gV2UgZmlsdGVyIGFsbCBmYWlsZWQgcHJlLXZhbGlkYXRpb25zIGJ5IHJlbW92aW5nIG51bGxzXG4gICAgY29uc3QgZG9jQXR0cmlidXRlcyA9IGRvY3MuZmlsdGVyKGZ1bmN0aW9uKGRvYykge1xuICAgICAgcmV0dXJuIGRvYyAhPSBudWxsO1xuICAgIH0pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZG9jQXR0cmlidXRlcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFsaWREb2NJbmRleFRvT3JpZ2luYWxJbmRleC5zZXQoaSwgb3JpZ2luYWxEb2NJbmRleC5nZXQoZG9jQXR0cmlidXRlc1tpXSkpO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB2YWxpZGF0aW9uIGVycm9ycyBhcmUgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4gICAgLy8gb3JpZ2luYWwgZG9jdW1lbnRzLCBzbyBpZiBib3RoIGRvYzEgYW5kIGRvYzIgYm90aCBmYWlsIHZhbGlkYXRpb24sXG4gICAgLy8gYE1vZGVsLmluc2VydE1hbnkoW2RvYzEsIGRvYzJdKWAgd2lsbCBhbHdheXMgaGF2ZSBkb2MxJ3MgdmFsaWRhdGlvblxuICAgIC8vIGVycm9yIGJlZm9yZSBkb2MyJ3MuIFJlOiBnaC0xMjc5MS5cbiAgICBpZiAodmFsaWRhdGlvbkVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICB2YWxpZGF0aW9uRXJyb3JzLnNvcnQoKGVycjEsIGVycjIpID0+IHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRpb25FcnJvcnNUb09yaWdpbmFsT3JkZXIuZ2V0KGVycjEpIC0gdmFsaWRhdGlvbkVycm9yc1RvT3JpZ2luYWxPcmRlci5nZXQoZXJyMik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBRdWlja2x5IGVzY2FwZSB3aGlsZSB0aGVyZSBhcmVuJ3QgYW55IHZhbGlkIGRvY0F0dHJpYnV0ZXNcbiAgICBpZiAoZG9jQXR0cmlidXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChyYXdSZXN1bHQpIHtcbiAgICAgICAgY29uc3QgcmVzID0ge1xuICAgICAgICAgIGFja25vd2xlZGdlZDogdHJ1ZSxcbiAgICAgICAgICBpbnNlcnRlZENvdW50OiAwLFxuICAgICAgICAgIGluc2VydGVkSWRzOiB7fSxcbiAgICAgICAgICBtb25nb29zZToge1xuICAgICAgICAgICAgdmFsaWRhdGlvbkVycm9yczogdmFsaWRhdGlvbkVycm9yc1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlcyk7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhudWxsLCBbXSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRvY09iamVjdHMgPSBsZWFuID8gZG9jQXR0cmlidXRlcyA6IGRvY0F0dHJpYnV0ZXMubWFwKGZ1bmN0aW9uKGRvYykge1xuICAgICAgaWYgKGRvYy4kX19zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5KSB7XG4gICAgICAgIGRvY1tkb2MuJF9fc2NoZW1hLm9wdGlvbnMudmVyc2lvbktleV0gPSAwO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2hvdWxkU2V0VGltZXN0YW1wcyA9ICghb3B0aW9ucyB8fCBvcHRpb25zLnRpbWVzdGFtcHMgIT09IGZhbHNlKSAmJiBkb2MuaW5pdGlhbGl6ZVRpbWVzdGFtcHMgJiYgKCFkb2MuJF9fIHx8IGRvYy4kX18udGltZXN0YW1wcyAhPT0gZmFsc2UpO1xuICAgICAgaWYgKHNob3VsZFNldFRpbWVzdGFtcHMpIHtcbiAgICAgICAgcmV0dXJuIGRvYy5pbml0aWFsaXplVGltZXN0YW1wcygpLnRvT2JqZWN0KGludGVybmFsVG9PYmplY3RPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkb2MudG9PYmplY3QoaW50ZXJuYWxUb09iamVjdE9wdGlvbnMpO1xuICAgIH0pO1xuXG4gICAgX3RoaXMuJF9fY29sbGVjdGlvbi5pbnNlcnRNYW55KGRvY09iamVjdHMsIG9wdGlvbnMpLnRoZW4oXG4gICAgICByZXMgPT4ge1xuICAgICAgICBpZiAoIWxlYW4pIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBkb2NBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGUuJF9fcmVzZXQoKTtcbiAgICAgICAgICAgIF9zZXRJc05ldyhhdHRyaWJ1dGUsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3JkZXJlZCA9PT0gZmFsc2UgJiYgdGhyb3dPblZhbGlkYXRpb25FcnJvciAmJiB2YWxpZGF0aW9uRXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHRzW2ldID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgcmVzdWx0c1tpXSA9IGRvY3NbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgTW9uZ29vc2VCdWxrV3JpdGVFcnJvcihcbiAgICAgICAgICAgIHZhbGlkYXRpb25FcnJvcnMsXG4gICAgICAgICAgICByZXN1bHRzLFxuICAgICAgICAgICAgcmVzLFxuICAgICAgICAgICAgJ2luc2VydE1hbnknXG4gICAgICAgICAgKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmF3UmVzdWx0KSB7XG4gICAgICAgICAgaWYgKG9yZGVyZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdHNbaV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHNbaV0gPSBkb2NzW2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERlY29yYXRlIHdpdGggbW9uZ29vc2UgdmFsaWRhdGlvbiBlcnJvcnMgaW4gY2FzZSBvZiB1bm9yZGVyZWQsXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHRoZW4gc3RpbGwgZG8gYGluc2VydE1hbnkoKWBcbiAgICAgICAgICAgIHJlcy5tb25nb29zZSA9IHtcbiAgICAgICAgICAgICAgdmFsaWRhdGlvbkVycm9yczogdmFsaWRhdGlvbkVycm9ycyxcbiAgICAgICAgICAgICAgcmVzdWx0czogcmVzdWx0c1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5wb3B1bGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnBvcHVsYXRlKGRvY0F0dHJpYnV0ZXMsIG9wdGlvbnMucG9wdWxhdGUpLnRoZW4oXG4gICAgICAgICAgICBkb2NzID0+IHsgY2FsbGJhY2sobnVsbCwgZG9jcyk7IH0sXG4gICAgICAgICAgICBlcnIgPT4ge1xuICAgICAgICAgICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBlcnIuaW5zZXJ0ZWREb2NzID0gZG9jQXR0cmlidXRlcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGRvY0F0dHJpYnV0ZXMpO1xuICAgICAgfSxcbiAgICAgIGVycm9yID0+IHtcbiAgICAgICAgLy8gYHdyaXRlRXJyb3JzYCBpcyBhIHByb3BlcnR5IHJlcG9ydGVkIGJ5IHRoZSBNb25nb0RCIGRyaXZlcixcbiAgICAgICAgLy8ganVzdCBub3QgaWYgdGhlcmUncyBvbmx5IDEgZXJyb3IuXG4gICAgICAgIGlmIChlcnJvci53cml0ZUVycm9ycyA9PSBudWxsICYmXG4gICAgICAgICAgICAoZXJyb3IucmVzdWx0ICYmIGVycm9yLnJlc3VsdC5yZXN1bHQgJiYgZXJyb3IucmVzdWx0LnJlc3VsdC53cml0ZUVycm9ycykgIT0gbnVsbCkge1xuICAgICAgICAgIGVycm9yLndyaXRlRXJyb3JzID0gZXJyb3IucmVzdWx0LnJlc3VsdC53cml0ZUVycm9ycztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGBpbnNlcnRlZERvY3NgIGlzIGEgTW9uZ29vc2Utc3BlY2lmaWMgcHJvcGVydHlcbiAgICAgICAgY29uc3QgaGFzV3JpdGVFcnJvcnMgPSBlcnJvciAmJiBlcnJvci53cml0ZUVycm9ycztcbiAgICAgICAgY29uc3QgZXJyb3JlZEluZGV4ZXMgPSBuZXcgU2V0KChlcnJvciAmJiBlcnJvci53cml0ZUVycm9ycyB8fCBbXSkubWFwKGVyciA9PiBlcnIuaW5kZXgpKTtcblxuICAgICAgICBpZiAoZXJyb3Iud3JpdGVFcnJvcnMgIT0gbnVsbCkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXJyb3Iud3JpdGVFcnJvcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsSW5kZXggPSB2YWxpZERvY0luZGV4VG9PcmlnaW5hbEluZGV4LmdldChlcnJvci53cml0ZUVycm9yc1tpXS5pbmRleCk7XG4gICAgICAgICAgICBlcnJvci53cml0ZUVycm9yc1tpXSA9IHtcbiAgICAgICAgICAgICAgLi4uZXJyb3Iud3JpdGVFcnJvcnNbaV0sXG4gICAgICAgICAgICAgIGluZGV4OiBvcmlnaW5hbEluZGV4XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCFvcmRlcmVkKSB7XG4gICAgICAgICAgICAgIHJlc3VsdHNbb3JpZ2luYWxJbmRleF0gPSBlcnJvci53cml0ZUVycm9yc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9yZGVyZWQpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHRzW2ldID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgcmVzdWx0c1tpXSA9IGRvY3NbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IucmVzdWx0cyA9IHJlc3VsdHM7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZmlyc3RFcnJvcmVkSW5kZXggPSAtMTtcbiAgICAgICAgZXJyb3IuaW5zZXJ0ZWREb2NzID0gZG9jQXR0cmlidXRlcy5cbiAgICAgICAgICBmaWx0ZXIoKGRvYywgaSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXNFcnJvcmVkID0gIWhhc1dyaXRlRXJyb3JzIHx8IGVycm9yZWRJbmRleGVzLmhhcyhpKTtcblxuICAgICAgICAgICAgaWYgKG9yZGVyZWQpIHtcbiAgICAgICAgICAgICAgaWYgKGZpcnN0RXJyb3JlZEluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaSA8IGZpcnN0RXJyb3JlZEluZGV4O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGlzRXJyb3JlZCkge1xuICAgICAgICAgICAgICAgIGZpcnN0RXJyb3JlZEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gIWlzRXJyb3JlZDtcbiAgICAgICAgICB9KS5cbiAgICAgICAgICBtYXAoZnVuY3Rpb24gc2V0SXNOZXdGb3JJbnNlcnRlZERvYyhkb2MpIHtcbiAgICAgICAgICAgIGlmIChsZWFuKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkb2M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb2MuJF9fcmVzZXQoKTtcbiAgICAgICAgICAgIF9zZXRJc05ldyhkb2MsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiBkb2M7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJhd1Jlc3VsdCAmJiBvcmRlcmVkID09PSBmYWxzZSkge1xuICAgICAgICAgIGVycm9yLm1vbmdvb3NlID0ge1xuICAgICAgICAgICAgdmFsaWRhdGlvbkVycm9yczogdmFsaWRhdGlvbkVycm9ycyxcbiAgICAgICAgICAgIHJlc3VsdHM6IHJlc3VsdHNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2soZXJyb3IsIG51bGwpO1xuICAgICAgfVxuICAgICk7XG4gIH0pO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfc2V0SXNOZXcoZG9jLCB2YWwpIHtcbiAgZG9jLiRpc05ldyA9IHZhbDtcbiAgZG9jLiRlbWl0KCdpc05ldycsIHZhbCk7XG4gIGRvYy5jb25zdHJ1Y3Rvci5lbWl0KCdpc05ldycsIHZhbCk7XG5cbiAgY29uc3Qgc3ViZG9jcyA9IGRvYy4kZ2V0QWxsU3ViZG9jcygpO1xuICBmb3IgKGNvbnN0IHN1YmRvYyBvZiBzdWJkb2NzKSB7XG4gICAgc3ViZG9jLiRpc05ldyA9IHZhbDtcbiAgICBzdWJkb2MuJGVtaXQoJ2lzTmV3JywgdmFsKTtcbiAgfVxufVxuXG4vKipcbiAqIFNlbmRzIG11bHRpcGxlIGBpbnNlcnRPbmVgLCBgdXBkYXRlT25lYCwgYHVwZGF0ZU1hbnlgLCBgcmVwbGFjZU9uZWAsXG4gKiBgZGVsZXRlT25lYCwgYW5kL29yIGBkZWxldGVNYW55YCBvcGVyYXRpb25zIHRvIHRoZSBNb25nb0RCIHNlcnZlciBpbiBvbmVcbiAqIGNvbW1hbmQuIFRoaXMgaXMgZmFzdGVyIHRoYW4gc2VuZGluZyBtdWx0aXBsZSBpbmRlcGVuZGVudCBvcGVyYXRpb25zIChlLmcuXG4gKiBpZiB5b3UgdXNlIGBjcmVhdGUoKWApIGJlY2F1c2Ugd2l0aCBgYnVsa1dyaXRlKClgIHRoZXJlIGlzIG9ubHkgb25lIHJvdW5kXG4gKiB0cmlwIHRvIE1vbmdvREIuXG4gKlxuICogTW9uZ29vc2Ugd2lsbCBwZXJmb3JtIGNhc3Rpbmcgb24gYWxsIG9wZXJhdGlvbnMgeW91IHByb3ZpZGUuXG4gKiBUaGUgb25seSBleGNlcHRpb24gaXMgW3NldHRpbmcgdGhlIGB1cGRhdGVgIG9wZXJhdG9yIGZvciBgdXBkYXRlT25lYCBvciBgdXBkYXRlTWFueWAgdG8gYSBwaXBlbGluZV0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9kYi5jb2xsZWN0aW9uLmJ1bGtXcml0ZS8jdXBkYXRlb25lLWFuZC11cGRhdGVtYW55KTogTW9uZ29vc2UgZG9lcyAqKm5vdCoqIGNhc3QgdXBkYXRlIHBpcGVsaW5lcy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgKipub3QqKiB0cmlnZ2VyIGFueSBtaWRkbGV3YXJlLCBuZWl0aGVyIGBzYXZlKClgLCBub3IgYHVwZGF0ZSgpYC5cbiAqIElmIHlvdSBuZWVkIHRvIHRyaWdnZXJcbiAqIGBzYXZlKClgIG1pZGRsZXdhcmUgZm9yIGV2ZXJ5IGRvY3VtZW50IHVzZSBbYGNyZWF0ZSgpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsLmNyZWF0ZSgpKSBpbnN0ZWFkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgQ2hhcmFjdGVyLmJ1bGtXcml0ZShbXG4gKiAgICAgICB7XG4gKiAgICAgICAgIGluc2VydE9uZToge1xuICogICAgICAgICAgIGRvY3VtZW50OiB7XG4gKiAgICAgICAgICAgICBuYW1lOiAnRWRkYXJkIFN0YXJrJyxcbiAqICAgICAgICAgICAgIHRpdGxlOiAnV2FyZGVuIG9mIHRoZSBOb3J0aCdcbiAqICAgICAgICAgICB9XG4gKiAgICAgICAgIH1cbiAqICAgICAgIH0sXG4gKiAgICAgICB7XG4gKiAgICAgICAgIHVwZGF0ZU9uZToge1xuICogICAgICAgICAgIGZpbHRlcjogeyBuYW1lOiAnRWRkYXJkIFN0YXJrJyB9LFxuICogICAgICAgICAgIC8vIElmIHlvdSB3ZXJlIHVzaW5nIHRoZSBNb25nb0RCIGRyaXZlciBkaXJlY3RseSwgeW91J2QgbmVlZCB0byBkb1xuICogICAgICAgICAgIC8vIGB1cGRhdGU6IHsgJHNldDogeyB0aXRsZTogLi4uIH0gfWAgYnV0IG1vbmdvb3NlIGFkZHMgJHNldCBmb3JcbiAqICAgICAgICAgICAvLyB5b3UuXG4gKiAgICAgICAgICAgdXBkYXRlOiB7IHRpdGxlOiAnSGFuZCBvZiB0aGUgS2luZycgfVxuICogICAgICAgICB9XG4gKiAgICAgICB9LFxuICogICAgICAge1xuICogICAgICAgICBkZWxldGVPbmU6IHtcbiAqICAgICAgICAgICBmaWx0ZXI6IHsgbmFtZTogJ0VkZGFyZCBTdGFyaycgfVxuICogICAgICAgICB9XG4gKiAgICAgICB9XG4gKiAgICAgXSkudGhlbihyZXMgPT4ge1xuICogICAgICAvLyBQcmludHMgXCIxIDEgMVwiXG4gKiAgICAgIGNvbnNvbGUubG9nKHJlcy5pbnNlcnRlZENvdW50LCByZXMubW9kaWZpZWRDb3VudCwgcmVzLmRlbGV0ZWRDb3VudCk7XG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vIE1vbmdvb3NlIGRvZXMgKipub3QqKiBjYXN0IHVwZGF0ZSBwaXBlbGluZXMsIHNvIG5vIGNhc3RpbmcgZm9yIHRoZSBgdXBkYXRlYCBvcHRpb24gYmVsb3cuXG4gKiAgICAgLy8gTW9uZ29vc2UgZG9lcyBzdGlsbCBjYXN0IGBmaWx0ZXJgXG4gKiAgICAgYXdhaXQgQ2hhcmFjdGVyLmJ1bGtXcml0ZShbe1xuICogICAgICAgdXBkYXRlT25lOiB7XG4gKiAgICAgICAgIGZpbHRlcjogeyBuYW1lOiAnQW5uaWthIEhhbnNlbicgfSxcbiAqICAgICAgICAgdXBkYXRlOiBbeyAkc2V0OiB7IG5hbWU6IDcgfSB9XSAvLyBBcnJheSBtZWFucyB1cGRhdGUgcGlwZWxpbmUsIHNvIE1vbmdvb3NlIHNraXBzIGNhc3RpbmdcbiAqICAgICAgIH1cbiAqICAgICB9XSk7XG4gKlxuICogVGhlIFtzdXBwb3J0ZWQgb3BlcmF0aW9uc10oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9kYi5jb2xsZWN0aW9uLmJ1bGtXcml0ZS8jZGIuY29sbGVjdGlvbi5idWxrV3JpdGUpIGFyZTpcbiAqXG4gKiAtIGBpbnNlcnRPbmVgXG4gKiAtIGB1cGRhdGVPbmVgXG4gKiAtIGB1cGRhdGVNYW55YFxuICogLSBgZGVsZXRlT25lYFxuICogLSBgZGVsZXRlTWFueWBcbiAqIC0gYHJlcGxhY2VPbmVgXG4gKlxuICogQHBhcmFtIHtBcnJheX0gb3BzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wcy5pbnNlcnRPbmUuZG9jdW1lbnRdIFRoZSBkb2N1bWVudCB0byBpbnNlcnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3BzLnVwZGF0ZU9uZS5maWx0ZXJdIFVwZGF0ZSB0aGUgZmlyc3QgZG9jdW1lbnQgdGhhdCBtYXRjaGVzIHRoaXMgZmlsdGVyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wcy51cGRhdGVPbmUudXBkYXRlXSBBbiBvYmplY3QgY29udGFpbmluZyBbdXBkYXRlIG9wZXJhdG9yc10oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3VwZGF0ZS8pXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHMudXBkYXRlT25lLnVwc2VydD1mYWxzZV0gSWYgdHJ1ZSwgaW5zZXJ0IGEgZG9jIGlmIG5vbmUgbWF0Y2hcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wcy51cGRhdGVPbmUudGltZXN0YW1wcz10cnVlXSBJZiBmYWxzZSwgZG8gbm90IGFwcGx5IFt0aW1lc3RhbXBzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0aW1lc3RhbXBzKSB0byB0aGUgb3BlcmF0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wcy51cGRhdGVPbmUuY29sbGF0aW9uXSBUaGUgW01vbmdvREIgY29sbGF0aW9uXShodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tL2Etbm9kZWpzLXBlcnNwZWN0aXZlLW9uLW1vbmdvZGItMzQtY29sbGF0aW9ucykgdG8gdXNlXG4gKiBAcGFyYW0ge0FycmF5fSBbb3BzLnVwZGF0ZU9uZS5hcnJheUZpbHRlcnNdIFRoZSBbYXJyYXkgZmlsdGVyc10oaHR0cHM6Ly90aGVjb2RlYmFyYmFyaWFuLmNvbS9hLW5vZGVqcy1wZXJzcGVjdGl2ZS1vbi1tb25nb2RiLTM2LWFycmF5LWZpbHRlcnMuaHRtbCkgdXNlZCBpbiBgdXBkYXRlYFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHMudXBkYXRlTWFueS5maWx0ZXJdIFVwZGF0ZSBhbGwgdGhlIGRvY3VtZW50cyB0aGF0IG1hdGNoIHRoaXMgZmlsdGVyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wcy51cGRhdGVNYW55LnVwZGF0ZV0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgW3VwZGF0ZSBvcGVyYXRvcnNdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci91cGRhdGUvKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3BzLnVwZGF0ZU1hbnkudXBzZXJ0PWZhbHNlXSBJZiB0cnVlLCBpbnNlcnQgYSBkb2MgaWYgbm8gZG9jdW1lbnRzIG1hdGNoIGBmaWx0ZXJgXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHMudXBkYXRlTWFueS50aW1lc3RhbXBzPXRydWVdIElmIGZhbHNlLCBkbyBub3QgYXBwbHkgW3RpbWVzdGFtcHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3RpbWVzdGFtcHMpIHRvIHRoZSBvcGVyYXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3BzLnVwZGF0ZU1hbnkuY29sbGF0aW9uXSBUaGUgW01vbmdvREIgY29sbGF0aW9uXShodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tL2Etbm9kZWpzLXBlcnNwZWN0aXZlLW9uLW1vbmdvZGItMzQtY29sbGF0aW9ucykgdG8gdXNlXG4gKiBAcGFyYW0ge0FycmF5fSBbb3BzLnVwZGF0ZU1hbnkuYXJyYXlGaWx0ZXJzXSBUaGUgW2FycmF5IGZpbHRlcnNdKGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vYS1ub2RlanMtcGVyc3BlY3RpdmUtb24tbW9uZ29kYi0zNi1hcnJheS1maWx0ZXJzLmh0bWwpIHVzZWQgaW4gYHVwZGF0ZWBcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3BzLmRlbGV0ZU9uZS5maWx0ZXJdIERlbGV0ZSB0aGUgZmlyc3QgZG9jdW1lbnQgdGhhdCBtYXRjaGVzIHRoaXMgZmlsdGVyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wcy5kZWxldGVNYW55LmZpbHRlcl0gRGVsZXRlIGFsbCBkb2N1bWVudHMgdGhhdCBtYXRjaCB0aGlzIGZpbHRlclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHMucmVwbGFjZU9uZS5maWx0ZXJdIFJlcGxhY2UgdGhlIGZpcnN0IGRvY3VtZW50IHRoYXQgbWF0Y2hlcyB0aGlzIGZpbHRlclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHMucmVwbGFjZU9uZS5yZXBsYWNlbWVudF0gVGhlIHJlcGxhY2VtZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHMucmVwbGFjZU9uZS51cHNlcnQ9ZmFsc2VdIElmIHRydWUsIGluc2VydCBhIGRvYyBpZiBubyBkb2N1bWVudHMgbWF0Y2ggYGZpbHRlcmBcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMub3JkZXJlZD10cnVlXSBJZiB0cnVlLCBleGVjdXRlIHdyaXRlcyBpbiBvcmRlciBhbmQgc3RvcCBhdCB0aGUgZmlyc3QgZXJyb3IuIElmIGZhbHNlLCBleGVjdXRlIHdyaXRlcyBpbiBwYXJhbGxlbCBhbmQgY29udGludWUgdW50aWwgYWxsIHdyaXRlcyBoYXZlIGVpdGhlciBzdWNjZWVkZWQgb3IgZXJyb3JlZC5cbiAqIEBwYXJhbSB7Q2xpZW50U2Vzc2lvbn0gW29wdGlvbnMuc2Vzc2lvbj1udWxsXSBUaGUgc2Vzc2lvbiBhc3NvY2lhdGVkIHdpdGggdGhpcyBidWxrIHdyaXRlLiBTZWUgW3RyYW5zYWN0aW9ucyBkb2NzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHJhbnNhY3Rpb25zLmh0bWwpLlxuICogQHBhcmFtIHtTdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy53PTFdIFRoZSBbd3JpdGUgY29uY2Vybl0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vKS4gU2VlIFtgUXVlcnkjdygpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS53KCkpIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnd0aW1lb3V0PW51bGxdIFRoZSBbd3JpdGUgY29uY2VybiB0aW1lb3V0XShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvd3JpdGUtY29uY2Vybi8jd3RpbWVvdXQpLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5qPXRydWVdIElmIGZhbHNlLCBkaXNhYmxlIFtqb3VybmFsIGFja25vd2xlZGdlbWVudF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vI2otb3B0aW9uKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwVmFsaWRhdGlvbj1mYWxzZV0gU2V0IHRvIHRydWUgdG8gc2tpcCBNb25nb29zZSBzY2hlbWEgdmFsaWRhdGlvbiBvbiBidWxrIHdyaXRlIG9wZXJhdGlvbnMuIE1vbmdvb3NlIGN1cnJlbnRseSBydW5zIHZhbGlkYXRpb24gb24gYGluc2VydE9uZWAgYW5kIGByZXBsYWNlT25lYCBvcGVyYXRpb25zIGJ5IGRlZmF1bHQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJ5cGFzc0RvY3VtZW50VmFsaWRhdGlvbj1mYWxzZV0gSWYgdHJ1ZSwgZGlzYWJsZSBbTW9uZ29EQiBzZXJ2ZXItc2lkZSBzY2hlbWEgdmFsaWRhdGlvbl0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvY29yZS9zY2hlbWEtdmFsaWRhdGlvbi8pIGZvciBhbGwgd3JpdGVzIGluIHRoaXMgYnVsay5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudGhyb3dPblZhbGlkYXRpb25FcnJvcj1mYWxzZV0gSWYgdHJ1ZSBhbmQgYG9yZGVyZWQ6IGZhbHNlYCwgdGhyb3cgYW4gZXJyb3IgaWYgb25lIG9mIHRoZSBvcGVyYXRpb25zIGZhaWxlZCB2YWxpZGF0aW9uLCBidXQgYWxsIHZhbGlkIG9wZXJhdGlvbnMgY29tcGxldGVkIHN1Y2Nlc3NmdWxseS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3RyaWN0PW51bGxdIE92ZXJ3cml0ZXMgdGhlIFtgc3RyaWN0YCBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdCkgb24gc2NoZW1hLiBJZiBmYWxzZSwgYWxsb3dzIGZpbHRlcmluZyBhbmQgd3JpdGluZyBmaWVsZHMgbm90IGRlZmluZWQgaW4gdGhlIHNjaGVtYSBmb3IgYWxsIHdyaXRlcyBpbiB0aGlzIGJ1bGsuXG4gKiBAcmV0dXJuIHtQcm9taXNlfSByZXNvbHZlcyB0byBhIFtgQnVsa1dyaXRlT3BSZXN1bHRgXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvQnVsa1dyaXRlUmVzdWx0Lmh0bWwpIGlmIHRoZSBvcGVyYXRpb24gc3VjY2VlZHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwuYnVsa1dyaXRlID0gYXN5bmMgZnVuY3Rpb24gYnVsa1dyaXRlKG9wcywgb3B0aW9ucykge1xuICBfY2hlY2tDb250ZXh0KHRoaXMsICdidWxrV3JpdGUnKTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwuYnVsa1dyaXRlKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGNvbnN0IHNob3VsZFNraXAgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdGhpcy5ob29rcy5leGVjUHJlKCdidWxrV3JpdGUnLCB0aGlzLCBbb3BzLCBvcHRpb25zXSwgKGVycikgPT4ge1xuICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBLYXJlZW0uc2tpcFdyYXBwZWRGdW5jdGlvbikge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9KTtcblxuICBpZiAoc2hvdWxkU2tpcCkge1xuICAgIHJldHVybiBzaG91bGRTa2lwLmFyZ3NbMF07XG4gIH1cblxuICBjb25zdCBvcmRlcmVkID0gb3B0aW9ucy5vcmRlcmVkID09IG51bGwgPyB0cnVlIDogb3B0aW9ucy5vcmRlcmVkO1xuXG4gIGlmIChvcHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGdldERlZmF1bHRCdWxrd3JpdGVSZXN1bHQoKTtcbiAgfVxuXG4gIGNvbnN0IHZhbGlkYXRpb25zID0gb3BzLm1hcChvcCA9PiBjYXN0QnVsa1dyaXRlKHRoaXMsIG9wLCBvcHRpb25zKSk7XG5cbiAgbGV0IHJlcyA9IG51bGw7XG4gIGlmIChvcmRlcmVkKSB7XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgZWFjaCh2YWxpZGF0aW9ucywgKGZuLCBjYikgPT4gZm4oY2IpLCBlcnJvciA9PiB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0cnkge1xuICAgICAgcmVzID0gYXdhaXQgdGhpcy4kX19jb2xsZWN0aW9uLmJ1bGtXcml0ZShvcHMsIG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IF9vcHRzID0geyBlcnJvcjogZXJyb3IgfTtcbiAgICAgICAgdGhpcy5ob29rcy5leGVjUG9zdCgnYnVsa1dyaXRlJywgdGhpcywgW251bGxdLCBfb3B0cywgKGVycikgPT4ge1xuICAgICAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxldCByZW1haW5pbmcgPSB2YWxpZGF0aW9ucy5sZW5ndGg7XG4gICAgbGV0IHZhbGlkT3BzID0gW107XG4gICAgbGV0IHZhbGlkYXRpb25FcnJvcnMgPSBbXTtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsaWRhdGlvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFsaWRhdGlvbnNbaV0oKGVycikgPT4ge1xuICAgICAgICAgIGlmIChlcnIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFsaWRPcHMucHVzaChpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsaWRhdGlvbkVycm9ycy5wdXNoKHsgaW5kZXg6IGksIGVycm9yOiBlcnIgfSk7XG4gICAgICAgICAgICByZXN1bHRzW2ldID0gZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoLS1yZW1haW5pbmcgPD0gMCkge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YWxpZGF0aW9uRXJyb3JzID0gdmFsaWRhdGlvbkVycm9ycy5cbiAgICAgIHNvcnQoKHYxLCB2MikgPT4gdjEuaW5kZXggLSB2Mi5pbmRleCkuXG4gICAgICBtYXAodiA9PiB2LmVycm9yKTtcblxuICAgIGNvbnN0IHZhbGlkT3BJbmRleGVzID0gdmFsaWRPcHM7XG4gICAgdmFsaWRPcHMgPSB2YWxpZE9wcy5zb3J0KCkubWFwKGluZGV4ID0+IG9wc1tpbmRleF0pO1xuXG4gICAgaWYgKHZhbGlkT3BzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGdldERlZmF1bHRCdWxrd3JpdGVSZXN1bHQoKTtcbiAgICB9XG5cbiAgICBsZXQgZXJyb3I7XG4gICAgW3JlcywgZXJyb3JdID0gYXdhaXQgdGhpcy4kX19jb2xsZWN0aW9uLmJ1bGtXcml0ZSh2YWxpZE9wcywgb3B0aW9ucykuXG4gICAgICB0aGVuKHJlcyA9PiAoW3JlcywgbnVsbF0pKS5cbiAgICAgIGNhdGNoKGVyciA9PiAoW251bGwsIGVycl0pKTtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgaWYgKHZhbGlkYXRpb25FcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBlcnJvci5tb25nb29zZSA9IGVycm9yLm1vbmdvb3NlIHx8IHt9O1xuICAgICAgICBlcnJvci5tb25nb29zZS52YWxpZGF0aW9uRXJyb3JzID0gdmFsaWRhdGlvbkVycm9ycztcbiAgICAgIH1cblxuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBfb3B0cyA9IHsgZXJyb3I6IGVycm9yIH07XG4gICAgICAgIHRoaXMuaG9va3MuZXhlY1Bvc3QoJ2J1bGtXcml0ZScsIHRoaXMsIFtudWxsXSwgX29wdHMsIChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsaWRPcEluZGV4ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHJlc3VsdHNbdmFsaWRPcEluZGV4ZXNbaV1dID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHZhbGlkYXRpb25FcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKG9wdGlvbnMudGhyb3dPblZhbGlkYXRpb25FcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgTW9uZ29vc2VCdWxrV3JpdGVFcnJvcihcbiAgICAgICAgICB2YWxpZGF0aW9uRXJyb3JzLFxuICAgICAgICAgIHJlc3VsdHMsXG4gICAgICAgICAgcmVzLFxuICAgICAgICAgICdidWxrV3JpdGUnXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXMubW9uZ29vc2UgPSByZXMubW9uZ29vc2UgfHwge307XG4gICAgICAgIHJlcy5tb25nb29zZS52YWxpZGF0aW9uRXJyb3JzID0gdmFsaWRhdGlvbkVycm9ycztcbiAgICAgICAgcmVzLm1vbmdvb3NlLnJlc3VsdHMgPSByZXN1bHRzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB0aGlzLmhvb2tzLmV4ZWNQb3N0KCdidWxrV3JpdGUnLCB0aGlzLCBbcmVzXSwgKGVycikgPT4ge1xuICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbi8qKlxuICogIHRha2VzIGFuIGFycmF5IG9mIGRvY3VtZW50cywgZ2V0cyB0aGUgY2hhbmdlcyBhbmQgaW5zZXJ0cy91cGRhdGVzIGRvY3VtZW50cyBpbiB0aGUgZGF0YWJhc2VcbiAqICBhY2NvcmRpbmcgdG8gd2hldGhlciBvciBub3QgdGhlIGRvY3VtZW50IGlzIG5ldywgb3Igd2hldGhlciBpdCBoYXMgY2hhbmdlcyBvciBub3QuXG4gKlxuICogYGJ1bGtTYXZlYCB1c2VzIGBidWxrV3JpdGVgIHVuZGVyIHRoZSBob29kLCBzbyBpdCdzIG1vc3RseSB1c2VmdWwgd2hlbiBkZWFsaW5nIHdpdGggbWFueSBkb2N1bWVudHMgKDEwSyspXG4gKlxuICogQHBhcmFtIHtBcnJheTxEb2N1bWVudD59IGRvY3VtZW50c1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25zIHBhc3NlZCB0byB0aGUgdW5kZXJseWluZyBgYnVsa1dyaXRlKClgXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRpbWVzdGFtcHNdIGRlZmF1bHRzIHRvIGBudWxsYCwgd2hlbiBzZXQgdG8gZmFsc2UsIG1vbmdvb3NlIHdpbGwgbm90IGFkZC91cGRhdGUgdGltZXN0YW1wcyB0byB0aGUgZG9jdW1lbnRzLlxuICogQHBhcmFtIHtDbGllbnRTZXNzaW9ufSBbb3B0aW9ucy5zZXNzaW9uPW51bGxdIFRoZSBzZXNzaW9uIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGJ1bGsgd3JpdGUuIFNlZSBbdHJhbnNhY3Rpb25zIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90cmFuc2FjdGlvbnMuaHRtbCkuXG4gKiBAcGFyYW0ge1N0cmluZ3xudW1iZXJ9IFtvcHRpb25zLnc9MV0gVGhlIFt3cml0ZSBjb25jZXJuXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvd3JpdGUtY29uY2Vybi8pLiBTZWUgW2BRdWVyeSN3KClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLncoKSkgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMud3RpbWVvdXQ9bnVsbF0gVGhlIFt3cml0ZSBjb25jZXJuIHRpbWVvdXRdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLyN3dGltZW91dCkuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmo9dHJ1ZV0gSWYgZmFsc2UsIGRpc2FibGUgW2pvdXJuYWwgYWNrbm93bGVkZ2VtZW50XShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvd3JpdGUtY29uY2Vybi8jai1vcHRpb24pXG4gKlxuICovXG5Nb2RlbC5idWxrU2F2ZSA9IGFzeW5jIGZ1bmN0aW9uIGJ1bGtTYXZlKGRvY3VtZW50cywgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAob3B0aW9ucy50aW1lc3RhbXBzICE9IG51bGwpIHtcbiAgICBmb3IgKGNvbnN0IGRvY3VtZW50IG9mIGRvY3VtZW50cykge1xuICAgICAgZG9jdW1lbnQuJF9fLnNhdmVPcHRpb25zID0gZG9jdW1lbnQuJF9fLnNhdmVPcHRpb25zIHx8IHt9O1xuICAgICAgZG9jdW1lbnQuJF9fLnNhdmVPcHRpb25zLnRpbWVzdGFtcHMgPSBvcHRpb25zLnRpbWVzdGFtcHM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoY29uc3QgZG9jdW1lbnQgb2YgZG9jdW1lbnRzKSB7XG4gICAgICBpZiAoZG9jdW1lbnQuJF9fLnRpbWVzdGFtcHMgIT0gbnVsbCkge1xuICAgICAgICBkb2N1bWVudC4kX18uc2F2ZU9wdGlvbnMgPSBkb2N1bWVudC4kX18uc2F2ZU9wdGlvbnMgfHwge307XG4gICAgICAgIGRvY3VtZW50LiRfXy5zYXZlT3B0aW9ucy50aW1lc3RhbXBzID0gZG9jdW1lbnQuJF9fLnRpbWVzdGFtcHM7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXdhaXQgUHJvbWlzZS5hbGwoZG9jdW1lbnRzLm1hcChidWlsZFByZVNhdmVQcm9taXNlKSk7XG5cbiAgY29uc3Qgd3JpdGVPcGVyYXRpb25zID0gdGhpcy5idWlsZEJ1bGtXcml0ZU9wZXJhdGlvbnMoZG9jdW1lbnRzLCB7IHNraXBWYWxpZGF0aW9uOiB0cnVlLCB0aW1lc3RhbXBzOiBvcHRpb25zLnRpbWVzdGFtcHMgfSk7XG5cbiAgY29uc3QgeyBidWxrV3JpdGVSZXN1bHQsIGJ1bGtXcml0ZUVycm9yIH0gPSBhd2FpdCB0aGlzLmJ1bGtXcml0ZSh3cml0ZU9wZXJhdGlvbnMsIG9wdGlvbnMpLnRoZW4oXG4gICAgKHJlcykgPT4gKHsgYnVsa1dyaXRlUmVzdWx0OiByZXMsIGJ1bGtXcml0ZUVycm9yOiBudWxsIH0pLFxuICAgIChlcnIpID0+ICh7IGJ1bGtXcml0ZVJlc3VsdDogbnVsbCwgYnVsa1dyaXRlRXJyb3I6IGVyciB9KVxuICApO1xuXG4gIGF3YWl0IFByb21pc2UuYWxsKFxuICAgIGRvY3VtZW50cy5tYXAoYXN5bmMoZG9jdW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IGRvY3VtZW50RXJyb3IgPSBidWxrV3JpdGVFcnJvciAmJiBidWxrV3JpdGVFcnJvci53cml0ZUVycm9ycy5maW5kKHdyaXRlRXJyb3IgPT4ge1xuICAgICAgICBjb25zdCB3cml0ZUVycm9yRG9jdW1lbnRJZCA9IHdyaXRlRXJyb3IuZXJyLm9wLl9pZCB8fCB3cml0ZUVycm9yLmVyci5vcC5xLl9pZDtcbiAgICAgICAgcmV0dXJuIHdyaXRlRXJyb3JEb2N1bWVudElkLnRvU3RyaW5nKCkgPT09IGRvY3VtZW50Ll9pZC50b1N0cmluZygpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChkb2N1bWVudEVycm9yID09IG51bGwpIHtcbiAgICAgICAgYXdhaXQgaGFuZGxlU3VjY2Vzc2Z1bFdyaXRlKGRvY3VtZW50KTtcbiAgICAgIH1cbiAgICB9KVxuICApO1xuXG4gIGlmIChidWxrV3JpdGVFcnJvciAmJiBidWxrV3JpdGVFcnJvci53cml0ZUVycm9ycyAmJiBidWxrV3JpdGVFcnJvci53cml0ZUVycm9ycy5sZW5ndGgpIHtcbiAgICB0aHJvdyBidWxrV3JpdGVFcnJvcjtcbiAgfVxuXG4gIHJldHVybiBidWxrV3JpdGVSZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiBidWlsZFByZVNhdmVQcm9taXNlKGRvY3VtZW50KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZG9jdW1lbnQuc2NoZW1hLnMuaG9va3MuZXhlY1ByZSgnc2F2ZScsIGRvY3VtZW50LCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVTdWNjZXNzZnVsV3JpdGUoZG9jdW1lbnQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBpZiAoZG9jdW1lbnQuJGlzTmV3KSB7XG4gICAgICBfc2V0SXNOZXcoZG9jdW1lbnQsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBkb2N1bWVudC4kX19yZXNldCgpO1xuICAgIGRvY3VtZW50LnNjaGVtYS5zLmhvb2tzLmV4ZWNQb3N0KCdzYXZlJywgZG9jdW1lbnQsIFtkb2N1bWVudF0sIHt9LCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSk7XG5cbiAgfSk7XG59XG5cbi8qKlxuICogQXBwbHkgZGVmYXVsdHMgdG8gdGhlIGdpdmVuIGRvY3VtZW50IG9yIFBPSk8uXG4gKlxuICogQHBhcmFtIHtPYmplY3R8RG9jdW1lbnR9IG9iaiBvYmplY3Qgb3IgZG9jdW1lbnQgdG8gYXBwbHkgZGVmYXVsdHMgb25cbiAqIEByZXR1cm5zIHtPYmplY3R8RG9jdW1lbnR9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLmFwcGx5RGVmYXVsdHMgPSBmdW5jdGlvbiBhcHBseURlZmF1bHRzKGRvYykge1xuICBpZiAoZG9jLiRfXyAhPSBudWxsKSB7XG4gICAgYXBwbHlEZWZhdWx0c0hlbHBlcihkb2MsIGRvYy4kX18uZmllbGRzLCBkb2MuJF9fLmV4Y2x1ZGUpO1xuXG4gICAgZm9yIChjb25zdCBzdWJkb2Mgb2YgZG9jLiRnZXRBbGxTdWJkb2NzKCkpIHtcbiAgICAgIGFwcGx5RGVmYXVsdHMoc3ViZG9jLCBzdWJkb2MuJF9fLmZpZWxkcywgc3ViZG9jLiRfXy5leGNsdWRlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9jO1xuICB9XG5cbiAgYXBwbHlEZWZhdWx0c1RvUE9KTyhkb2MsIHRoaXMuc2NoZW1hKTtcblxuICByZXR1cm4gZG9jO1xufTtcblxuLyoqXG4gKiBDYXN0IHRoZSBnaXZlbiBQT0pPIHRvIHRoZSBtb2RlbCdzIHNjaGVtYVxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgVGVzdCA9IG1vbmdvb3NlLm1vZGVsKCdUZXN0JywgU2NoZW1hKHsgbnVtOiBOdW1iZXIgfSkpO1xuICpcbiAqICAgICBjb25zdCBvYmogPSBUZXN0LmNhc3RPYmplY3QoeyBudW06ICc0MicgfSk7XG4gKiAgICAgb2JqLm51bTsgLy8gNDIgYXMgYSBudW1iZXJcbiAqXG4gKiAgICAgVGVzdC5jYXN0T2JqZWN0KHsgbnVtOiAnbm90IGEgbnVtYmVyJyB9KTsgLy8gVGhyb3dzIGEgVmFsaWRhdGlvbkVycm9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBvYmplY3Qgb3IgZG9jdW1lbnQgdG8gY2FzdFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgb3B0aW9ucyBwYXNzZWQgdG8gY2FzdE9iamVjdFxuICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmlnbm9yZUNhc3RFcnJvcnMgSWYgc2V0IHRvIGB0cnVlYCB3aWxsIG5vdCB0aHJvdyBhIFZhbGlkYXRpb25FcnJvciBhbmQgb25seSByZXR1cm4gdmFsdWVzIHRoYXQgd2VyZSBzdWNjZXNzZnVsbHkgY2FzdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFBPSk8gY2FzdGVkIHRvIHRoZSBtb2RlbCdzIHNjaGVtYVxuICogQHRocm93cyB7VmFsaWRhdGlvbkVycm9yfSBpZiBjYXN0aW5nIGZhaWxlZCBmb3IgYXQgbGVhc3Qgb25lIHBhdGhcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwuY2FzdE9iamVjdCA9IGZ1bmN0aW9uIGNhc3RPYmplY3Qob2JqLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCByZXQgPSB7fTtcblxuICBjb25zdCBzY2hlbWEgPSB0aGlzLnNjaGVtYTtcbiAgY29uc3QgcGF0aHMgPSBPYmplY3Qua2V5cyhzY2hlbWEucGF0aHMpO1xuXG4gIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgIGNvbnN0IHNjaGVtYVR5cGUgPSBzY2hlbWEucGF0aChwYXRoKTtcbiAgICBpZiAoIXNjaGVtYVR5cGUgfHwgIXNjaGVtYVR5cGUuJGlzTW9uZ29vc2VBcnJheSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsID0gZ2V0KG9iaiwgcGF0aCk7XG4gICAgcHVzaE5lc3RlZEFycmF5UGF0aHMocGF0aHMsIHZhbCwgcGF0aCk7XG4gIH1cblxuICBsZXQgZXJyb3IgPSBudWxsO1xuXG4gIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgIGNvbnN0IHNjaGVtYVR5cGUgPSBzY2hlbWEucGF0aChwYXRoKTtcbiAgICBpZiAoc2NoZW1hVHlwZSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBsZXQgdmFsID0gZ2V0KG9iaiwgcGF0aCwgdm9pZCAwKTtcblxuICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgcGllY2VzID0gcGF0aC5pbmRleE9mKCcuJykgPT09IC0xID8gW3BhdGhdIDogcGF0aC5zcGxpdCgnLicpO1xuICAgIGxldCBjdXIgPSByZXQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwaWVjZXMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICBpZiAoY3VyW3BpZWNlc1tpXV0gPT0gbnVsbCkge1xuICAgICAgICBjdXJbcGllY2VzW2ldXSA9IGlzTmFOKHBpZWNlc1tpICsgMV0pID8ge30gOiBbXTtcbiAgICAgIH1cbiAgICAgIGN1ciA9IGN1cltwaWVjZXNbaV1dO1xuICAgIH1cblxuICAgIGlmIChzY2hlbWFUeXBlLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChzY2hlbWFUeXBlLiRpc1NpbmdsZU5lc3RlZCB8fCBzY2hlbWFUeXBlLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheUVsZW1lbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhbCA9IE1vZGVsLmNhc3RPYmplY3QuY2FsbChzY2hlbWFUeXBlLmNhc3RlciwgdmFsKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoIW9wdGlvbnMuaWdub3JlQ2FzdEVycm9ycykge1xuICAgICAgICAgIGVycm9yID0gZXJyb3IgfHwgbmV3IFZhbGlkYXRpb25FcnJvcigpO1xuICAgICAgICAgIGVycm9yLmFkZEVycm9yKHBhdGgsIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGN1cltwaWVjZXNbcGllY2VzLmxlbmd0aCAtIDFdXSA9IHZhbDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB2YWwgPSBzY2hlbWFUeXBlLmNhc3QodmFsKTtcbiAgICAgIGN1cltwaWVjZXNbcGllY2VzLmxlbmd0aCAtIDFdXSA9IHZhbDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICghb3B0aW9ucy5pZ25vcmVDYXN0RXJyb3JzKSB7XG4gICAgICAgIGVycm9yID0gZXJyb3IgfHwgbmV3IFZhbGlkYXRpb25FcnJvcigpO1xuICAgICAgICBlcnJvci5hZGRFcnJvcihwYXRoLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoZXJyb3IgIT0gbnVsbCkge1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogQnVpbGQgYnVsayB3cml0ZSBvcGVyYXRpb25zIGZvciBgYnVsa1NhdmUoKWAuXG4gKlxuICogQHBhcmFtIHtBcnJheTxEb2N1bWVudD59IGRvY3VtZW50cyBUaGUgYXJyYXkgb2YgZG9jdW1lbnRzIHRvIGJ1aWxkIHdyaXRlIG9wZXJhdGlvbnMgb2ZcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMuc2tpcFZhbGlkYXRpb24gZGVmYXVsdHMgdG8gYGZhbHNlYCwgd2hlbiBzZXQgdG8gdHJ1ZSwgYnVpbGRpbmcgdGhlIHdyaXRlIG9wZXJhdGlvbnMgd2lsbCBieXBhc3MgdmFsaWRhdGluZyB0aGUgZG9jdW1lbnRzLlxuICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLnRpbWVzdGFtcHMgZGVmYXVsdHMgdG8gYG51bGxgLCB3aGVuIHNldCB0byBmYWxzZSwgbW9uZ29vc2Ugd2lsbCBub3QgYWRkL3VwZGF0ZSB0aW1lc3RhbXBzIHRvIHRoZSBkb2N1bWVudHMuXG4gKiBAcmV0dXJuIHtBcnJheTxQcm9taXNlPn0gUmV0dXJucyBhIGFycmF5IG9mIGFsbCBQcm9taXNlcyB0aGUgZnVuY3Rpb24gZXhlY3V0ZXMgdG8gYmUgYXdhaXRlZC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1vZGVsLmJ1aWxkQnVsa1dyaXRlT3BlcmF0aW9ucyA9IGZ1bmN0aW9uIGJ1aWxkQnVsa1dyaXRlT3BlcmF0aW9ucyhkb2N1bWVudHMsIG9wdGlvbnMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGRvY3VtZW50cykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGJ1bGtTYXZlIGV4cGVjdHMgYW4gYXJyYXkgb2YgZG9jdW1lbnRzIHRvIGJlIHBhc3NlZCwgcmVjZWl2ZWQgXFxgJHtkb2N1bWVudHN9XFxgIGluc3RlYWRgKTtcbiAgfVxuXG4gIHNldERlZmF1bHRPcHRpb25zKCk7XG4gIGNvbnN0IGRpc2NyaW1pbmF0b3JLZXkgPSB0aGlzLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXk7XG5cbiAgY29uc3Qgd3JpdGVPcGVyYXRpb25zID0gZG9jdW1lbnRzLnJlZHVjZSgoYWNjdW11bGF0b3IsIGRvY3VtZW50LCBpKSA9PiB7XG4gICAgaWYgKCFvcHRpb25zLnNraXBWYWxpZGF0aW9uKSB7XG4gICAgICBpZiAoIShkb2N1bWVudCBpbnN0YW5jZW9mIERvY3VtZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRvY3VtZW50cy4ke2l9IHdhcyBub3QgYSBtb25nb29zZSBkb2N1bWVudCwgZG9jdW1lbnRzIG11c3QgYmUgYW4gYXJyYXkgb2YgbW9uZ29vc2UgZG9jdW1lbnRzIChpbnN0YW5jZW9mIG1vbmdvb3NlLkRvY3VtZW50KS5gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbGlkYXRpb25FcnJvciA9IGRvY3VtZW50LnZhbGlkYXRlU3luYygpO1xuICAgICAgaWYgKHZhbGlkYXRpb25FcnJvcikge1xuICAgICAgICB0aHJvdyB2YWxpZGF0aW9uRXJyb3I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaXNBTmV3RG9jdW1lbnQgPSBkb2N1bWVudC5pc05ldztcbiAgICBpZiAoaXNBTmV3RG9jdW1lbnQpIHtcbiAgICAgIGNvbnN0IHdyaXRlT3BlcmF0aW9uID0geyBpbnNlcnRPbmU6IHsgZG9jdW1lbnQgfSB9O1xuICAgICAgdXRpbHMuaW5qZWN0VGltZXN0YW1wc09wdGlvbih3cml0ZU9wZXJhdGlvbi5pbnNlcnRPbmUsIG9wdGlvbnMudGltZXN0YW1wcyk7XG4gICAgICBhY2N1bXVsYXRvci5wdXNoKHdyaXRlT3BlcmF0aW9uKTtcblxuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIGNvbnN0IGRlbHRhID0gZG9jdW1lbnQuJF9fZGVsdGEoKTtcbiAgICBjb25zdCBpc0RvY3VtZW50V2l0aENoYW5nZXMgPSBkZWx0YSAhPSBudWxsICYmICF1dGlscy5pc0VtcHR5T2JqZWN0KGRlbHRhWzBdKTtcblxuICAgIGlmIChpc0RvY3VtZW50V2l0aENoYW5nZXMpIHtcbiAgICAgIGNvbnN0IHdoZXJlID0gZG9jdW1lbnQuJF9fd2hlcmUoZGVsdGFbMF0pO1xuICAgICAgY29uc3QgY2hhbmdlcyA9IGRlbHRhWzFdO1xuXG4gICAgICBfYXBwbHlDdXN0b21XaGVyZShkb2N1bWVudCwgd2hlcmUpO1xuXG4gICAgICAvLyBTZXQgdGhlIGRpc2NyaW1pbmF0b3Iga2V5LCBzbyBidWxrIHdyaXRlIGNhc3Rpbmcga25vd3Mgd2hpY2hcbiAgICAgIC8vIHNjaGVtYSB0byB1c2UgcmU6IGdoLTEzOTA3XG4gICAgICBpZiAoZG9jdW1lbnRbZGlzY3JpbWluYXRvcktleV0gIT0gbnVsbCAmJiAhKGRpc2NyaW1pbmF0b3JLZXkgaW4gd2hlcmUpKSB7XG4gICAgICAgIHdoZXJlW2Rpc2NyaW1pbmF0b3JLZXldID0gZG9jdW1lbnRbZGlzY3JpbWluYXRvcktleV07XG4gICAgICB9XG5cbiAgICAgIGRvY3VtZW50LiRfX3ZlcnNpb24od2hlcmUsIGRlbHRhKTtcbiAgICAgIGNvbnN0IHdyaXRlT3BlcmF0aW9uID0geyB1cGRhdGVPbmU6IHsgZmlsdGVyOiB3aGVyZSwgdXBkYXRlOiBjaGFuZ2VzIH0gfTtcbiAgICAgIHV0aWxzLmluamVjdFRpbWVzdGFtcHNPcHRpb24od3JpdGVPcGVyYXRpb24udXBkYXRlT25lLCBvcHRpb25zLnRpbWVzdGFtcHMpO1xuICAgICAgYWNjdW11bGF0b3IucHVzaCh3cml0ZU9wZXJhdGlvbik7XG5cbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH0sIFtdKTtcblxuICByZXR1cm4gd3JpdGVPcGVyYXRpb25zO1xuXG5cbiAgZnVuY3Rpb24gc2V0RGVmYXVsdE9wdGlvbnMoKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKG9wdGlvbnMuc2tpcFZhbGlkYXRpb24gPT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy5za2lwVmFsaWRhdGlvbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIFNob3J0Y3V0IGZvciBjcmVhdGluZyBhIG5ldyBEb2N1bWVudCBmcm9tIGV4aXN0aW5nIHJhdyBkYXRhLCBwcmUtc2F2ZWQgaW4gdGhlIERCLlxuICogVGhlIGRvY3VtZW50IHJldHVybmVkIGhhcyBubyBwYXRocyBtYXJrZWQgYXMgbW9kaWZpZWQgaW5pdGlhbGx5LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gaHlkcmF0ZSBwcmV2aW91cyBkYXRhIGludG8gYSBNb25nb29zZSBkb2N1bWVudFxuICogICAgIGNvbnN0IG1vbmdvb3NlQ2FuZHkgPSBDYW5keS5oeWRyYXRlKHsgX2lkOiAnNTQxMDgzMzcyMTJmZmI2ZDQ1OWY4NTRjJywgdHlwZTogJ2plbGx5IGJlYW4nIH0pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xTdHJpbmdbXX0gW3Byb2plY3Rpb25dIG9wdGlvbmFsIHByb2plY3Rpb24gY29udGFpbmluZyB3aGljaCBmaWVsZHMgc2hvdWxkIGJlIHNlbGVjdGVkIGZvciB0aGlzIGRvY3VtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsIG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2V0dGVycz1mYWxzZV0gaWYgdHJ1ZSwgYXBwbHkgc2NoZW1hIHNldHRlcnMgd2hlbiBoeWRyYXRpbmdcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaHlkcmF0ZWRQb3B1bGF0ZWREb2NzPWZhbHNlXSBpZiB0cnVlLCBwb3B1bGF0ZXMgdGhlIGRvY3MgaWYgcGFzc2luZyBwcmUtcG9wdWxhdGVkIGRhdGFcbiAqIEByZXR1cm4ge0RvY3VtZW50fSBkb2N1bWVudCBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5oeWRyYXRlID0gZnVuY3Rpb24ob2JqLCBwcm9qZWN0aW9uLCBvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ2h5ZHJhdGUnKTtcblxuICBpZiAocHJvamVjdGlvbiAhPSBudWxsKSB7XG4gICAgaWYgKG9iaiAhPSBudWxsICYmIG9iai4kX18gIT0gbnVsbCkge1xuICAgICAgb2JqID0gb2JqLnRvT2JqZWN0KGludGVybmFsVG9PYmplY3RPcHRpb25zKTtcbiAgICB9XG4gICAgb2JqID0gYXBwbHlQcm9qZWN0aW9uKG9iaiwgcHJvamVjdGlvbik7XG4gIH1cbiAgY29uc3QgZG9jdW1lbnQgPSByZXF1aXJlKCcuL3F1ZXJ5SGVscGVycycpLmNyZWF0ZU1vZGVsKHRoaXMsIG9iaiwgcHJvamVjdGlvbik7XG4gIGRvY3VtZW50LiRpbml0KG9iaiwgb3B0aW9ucyk7XG4gIHJldHVybiBkb2N1bWVudDtcbn07XG5cbi8qKlxuICogU2FtZSBhcyBgdXBkYXRlT25lKClgLCBleGNlcHQgTW9uZ29EQiB3aWxsIHVwZGF0ZSBfYWxsXyBkb2N1bWVudHMgdGhhdCBtYXRjaFxuICogYGZpbHRlcmAgKGFzIG9wcG9zZWQgdG8ganVzdCB0aGUgZmlyc3Qgb25lKSByZWdhcmRsZXNzIG9mIHRoZSB2YWx1ZSBvZlxuICogdGhlIGBtdWx0aWAgb3B0aW9uLlxuICpcbiAqICoqTm90ZSoqIHVwZGF0ZU1hbnkgd2lsbCBfbm90XyBmaXJlIHVwZGF0ZSBtaWRkbGV3YXJlLiBVc2UgYHByZSgndXBkYXRlTWFueScpYFxuICogYW5kIGBwb3N0KCd1cGRhdGVNYW55JylgIGluc3RlYWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCByZXMgPSBhd2FpdCBQZXJzb24udXBkYXRlTWFueSh7IG5hbWU6IC9TdGFyayQvIH0sIHsgaXNEZWxldGVkOiB0cnVlIH0pO1xuICogICAgIHJlcy5tYXRjaGVkQ291bnQ7IC8vIE51bWJlciBvZiBkb2N1bWVudHMgbWF0Y2hlZFxuICogICAgIHJlcy5tb2RpZmllZENvdW50OyAvLyBOdW1iZXIgb2YgZG9jdW1lbnRzIG1vZGlmaWVkXG4gKiAgICAgcmVzLmFja25vd2xlZGdlZDsgLy8gQm9vbGVhbiBpbmRpY2F0aW5nIGV2ZXJ5dGhpbmcgd2VudCBzbW9vdGhseS5cbiAqICAgICByZXMudXBzZXJ0ZWRJZDsgLy8gbnVsbCBvciBhbiBpZCBjb250YWluaW5nIGEgZG9jdW1lbnQgdGhhdCBoYWQgdG8gYmUgdXBzZXJ0ZWQuXG4gKiAgICAgcmVzLnVwc2VydGVkQ291bnQ7IC8vIE51bWJlciBpbmRpY2F0aW5nIGhvdyBtYW55IGRvY3VtZW50cyBoYWQgdG8gYmUgdXBzZXJ0ZWQuIFdpbGwgZWl0aGVyIGJlIDAgb3IgMS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIHRoZSBmb2xsb3dpbmcgbWlkZGxld2FyZS5cbiAqXG4gKiAtIGB1cGRhdGVNYW55KClgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGZpbHRlclxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IHVwZGF0ZS4gSWYgYXJyYXksIHRoaXMgdXBkYXRlIHdpbGwgYmUgdHJlYXRlZCBhcyBhbiB1cGRhdGUgcGlwZWxpbmUgYW5kIG5vdCBjYXN0ZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKSlcbiAqIEBwYXJhbSB7Qm9vbGVhbnxTdHJpbmd9IFtvcHRpb25zLnN0cmljdF0gb3ZlcndyaXRlcyB0aGUgc2NoZW1hJ3MgW3N0cmljdCBtb2RlIG9wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc3RyaWN0KVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy51cHNlcnQ9ZmFsc2VdIGlmIHRydWUsIGFuZCBubyBkb2N1bWVudHMgZm91bmQsIGluc2VydCBhIG5ldyBkb2N1bWVudFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLndyaXRlQ29uY2Vybj1udWxsXSBzZXRzIHRoZSBbd3JpdGUgY29uY2Vybl0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vKSBmb3IgcmVwbGljYSBzZXRzLiBPdmVycmlkZXMgdGhlIFtzY2hlbWEtbGV2ZWwgd3JpdGUgY29uY2Vybl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjd3JpdGVDb25jZXJuKVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50aW1lc3RhbXBzPW51bGxdIElmIHNldCB0byBgZmFsc2VgIGFuZCBbc2NoZW1hLWxldmVsIHRpbWVzdGFtcHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3RpbWVzdGFtcHMpIGFyZSBlbmFibGVkLCBza2lwIHRpbWVzdGFtcHMgZm9yIHRoaXMgdXBkYXRlLiBEb2VzIG5vdGhpbmcgaWYgc2NoZW1hLWxldmVsIHRpbWVzdGFtcHMgYXJlIG5vdCBzZXQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRyYW5zbGF0ZUFsaWFzZXM9bnVsbF0gSWYgc2V0IHRvIGB0cnVlYCwgdHJhbnNsYXRlcyBhbnkgc2NoZW1hLWRlZmluZWQgYWxpYXNlcyBpbiBgZmlsdGVyYCwgYHByb2plY3Rpb25gLCBgdXBkYXRlYCwgYW5kIGBkaXN0aW5jdGAuIFRocm93cyBhbiBlcnJvciBpZiB0aGVyZSBhcmUgYW55IGNvbmZsaWN0cyB3aGVyZSBib3RoIGFsaWFzIGFuZCByYXcgcHJvcGVydHkgYXJlIGRlZmluZWQgb24gdGhlIHNhbWUgb2JqZWN0LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vdmVyd3JpdGVEaXNjcmltaW5hdG9yS2V5PWZhbHNlXSBNb25nb29zZSByZW1vdmVzIGRpc2NyaW1pbmF0b3Iga2V5IHVwZGF0ZXMgZnJvbSBgdXBkYXRlYCBieSBkZWZhdWx0LCBzZXQgYG92ZXJ3cml0ZURpc2NyaW1pbmF0b3JLZXlgIHRvIGB0cnVlYCB0byBhbGxvdyB1cGRhdGluZyB0aGUgZGlzY3JpbWluYXRvciBrZXlcbiAqIEByZXR1cm4ge1F1ZXJ5fVxuICogQHNlZSBRdWVyeSBkb2NzIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9xdWVyaWVzLmh0bWxcbiAqIEBzZWUgTW9uZ29EQiBkb2NzIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9jb21tYW5kL3VwZGF0ZS8jdXBkYXRlLWNvbW1hbmQtb3V0cHV0XG4gKiBAc2VlIFVwZGF0ZVJlc3VsdCBodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvVXBkYXRlUmVzdWx0Lmh0bWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9kZWwudXBkYXRlTWFueSA9IGZ1bmN0aW9uIHVwZGF0ZU1hbnkoY29uZGl0aW9ucywgZG9jLCBvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ3VwZGF0ZU1hbnknKTtcblxuICByZXR1cm4gX3VwZGF0ZSh0aGlzLCAndXBkYXRlTWFueScsIGNvbmRpdGlvbnMsIGRvYywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBfb25seV8gdGhlIGZpcnN0IGRvY3VtZW50IHRoYXQgbWF0Y2hlcyBgZmlsdGVyYC5cbiAqXG4gKiAtIFVzZSBgcmVwbGFjZU9uZSgpYCBpZiB5b3Ugd2FudCB0byBvdmVyd3JpdGUgYW4gZW50aXJlIGRvY3VtZW50IHJhdGhlciB0aGFuIHVzaW5nIGF0b21pYyBvcGVyYXRvcnMgbGlrZSBgJHNldGAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCByZXMgPSBhd2FpdCBQZXJzb24udXBkYXRlT25lKHsgbmFtZTogJ0plYW4tTHVjIFBpY2FyZCcgfSwgeyBzaGlwOiAnVVNTIEVudGVycHJpc2UnIH0pO1xuICogICAgIHJlcy5tYXRjaGVkQ291bnQ7IC8vIE51bWJlciBvZiBkb2N1bWVudHMgbWF0Y2hlZFxuICogICAgIHJlcy5tb2RpZmllZENvdW50OyAvLyBOdW1iZXIgb2YgZG9jdW1lbnRzIG1vZGlmaWVkXG4gKiAgICAgcmVzLmFja25vd2xlZGdlZDsgLy8gQm9vbGVhbiBpbmRpY2F0aW5nIGV2ZXJ5dGhpbmcgd2VudCBzbW9vdGhseS5cbiAqICAgICByZXMudXBzZXJ0ZWRJZDsgLy8gbnVsbCBvciBhbiBpZCBjb250YWluaW5nIGEgZG9jdW1lbnQgdGhhdCBoYWQgdG8gYmUgdXBzZXJ0ZWQuXG4gKiAgICAgcmVzLnVwc2VydGVkQ291bnQ7IC8vIE51bWJlciBpbmRpY2F0aW5nIGhvdyBtYW55IGRvY3VtZW50cyBoYWQgdG8gYmUgdXBzZXJ0ZWQuIFdpbGwgZWl0aGVyIGJlIDAgb3IgMS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIHRoZSBmb2xsb3dpbmcgbWlkZGxld2FyZS5cbiAqXG4gKiAtIGB1cGRhdGVPbmUoKWBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZmlsdGVyXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gdXBkYXRlLiBJZiBhcnJheSwgdGhpcyB1cGRhdGUgd2lsbCBiZSB0cmVhdGVkIGFzIGFuIHVwZGF0ZSBwaXBlbGluZSBhbmQgbm90IGNhc3RlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgc2VlIFtgUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpKVxuICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gW29wdGlvbnMuc3RyaWN0XSBvdmVyd3JpdGVzIHRoZSBzY2hlbWEncyBbc3RyaWN0IG1vZGUgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdHJpY3QpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnVwc2VydD1mYWxzZV0gaWYgdHJ1ZSwgYW5kIG5vIGRvY3VtZW50cyBmb3VuZCwgaW5zZXJ0IGEgbmV3IGRvY3VtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMud3JpdGVDb25jZXJuPW51bGxdIHNldHMgdGhlIFt3cml0ZSBjb25jZXJuXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvd3JpdGUtY29uY2Vybi8pIGZvciByZXBsaWNhIHNldHMuIE92ZXJyaWRlcyB0aGUgW3NjaGVtYS1sZXZlbCB3cml0ZSBjb25jZXJuXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN3cml0ZUNvbmNlcm4pXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRpbWVzdGFtcHM9bnVsbF0gSWYgc2V0IHRvIGBmYWxzZWAgYW5kIFtzY2hlbWEtbGV2ZWwgdGltZXN0YW1wc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdGltZXN0YW1wcykgYXJlIGVuYWJsZWQsIHNraXAgdGltZXN0YW1wcyBmb3IgdGhpcyB1cGRhdGUuIE5vdGUgdGhhdCB0aGlzIGFsbG93cyB5b3UgdG8gb3ZlcndyaXRlIHRpbWVzdGFtcHMuIERvZXMgbm90aGluZyBpZiBzY2hlbWEtbGV2ZWwgdGltZXN0YW1wcyBhcmUgbm90IHNldC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJhbnNsYXRlQWxpYXNlcz1udWxsXSBJZiBzZXQgdG8gYHRydWVgLCB0cmFuc2xhdGVzIGFueSBzY2hlbWEtZGVmaW5lZCBhbGlhc2VzIGluIGBmaWx0ZXJgLCBgcHJvamVjdGlvbmAsIGB1cGRhdGVgLCBhbmQgYGRpc3RpbmN0YC4gVGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGFyZSBhbnkgY29uZmxpY3RzIHdoZXJlIGJvdGggYWxpYXMgYW5kIHJhdyBwcm9wZXJ0eSBhcmUgZGVmaW5lZCBvbiB0aGUgc2FtZSBvYmplY3QuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm92ZXJ3cml0ZURpc2NyaW1pbmF0b3JLZXk9ZmFsc2VdIE1vbmdvb3NlIHJlbW92ZXMgZGlzY3JpbWluYXRvciBrZXkgdXBkYXRlcyBmcm9tIGB1cGRhdGVgIGJ5IGRlZmF1bHQsIHNldCBgb3ZlcndyaXRlRGlzY3JpbWluYXRvcktleWAgdG8gYHRydWVgIHRvIGFsbG93IHVwZGF0aW5nIHRoZSBkaXNjcmltaW5hdG9yIGtleVxuICogQHJldHVybiB7UXVlcnl9XG4gKiBAc2VlIFF1ZXJ5IGRvY3MgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3F1ZXJpZXMuaHRtbFxuICogQHNlZSBNb25nb0RCIGRvY3MgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2NvbW1hbmQvdXBkYXRlLyN1cGRhdGUtY29tbWFuZC1vdXRwdXRcbiAqIEBzZWUgVXBkYXRlUmVzdWx0IGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvaW50ZXJmYWNlcy9VcGRhdGVSZXN1bHQuaHRtbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC51cGRhdGVPbmUgPSBmdW5jdGlvbiB1cGRhdGVPbmUoY29uZGl0aW9ucywgZG9jLCBvcHRpb25zKSB7XG4gIF9jaGVja0NvbnRleHQodGhpcywgJ3VwZGF0ZU9uZScpO1xuXG4gIHJldHVybiBfdXBkYXRlKHRoaXMsICd1cGRhdGVPbmUnLCBjb25kaXRpb25zLCBkb2MsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBSZXBsYWNlIHRoZSBleGlzdGluZyBkb2N1bWVudCB3aXRoIHRoZSBnaXZlbiBkb2N1bWVudCAobm8gYXRvbWljIG9wZXJhdG9ycyBsaWtlIGAkc2V0YCkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCByZXMgPSBhd2FpdCBQZXJzb24ucmVwbGFjZU9uZSh7IF9pZDogMjQ2MDEgfSwgeyBuYW1lOiAnSmVhbiBWYWxqZWFuJyB9KTtcbiAqICAgICByZXMubWF0Y2hlZENvdW50OyAvLyBOdW1iZXIgb2YgZG9jdW1lbnRzIG1hdGNoZWRcbiAqICAgICByZXMubW9kaWZpZWRDb3VudDsgLy8gTnVtYmVyIG9mIGRvY3VtZW50cyBtb2RpZmllZFxuICogICAgIHJlcy5hY2tub3dsZWRnZWQ7IC8vIEJvb2xlYW4gaW5kaWNhdGluZyBldmVyeXRoaW5nIHdlbnQgc21vb3RobHkuXG4gKiAgICAgcmVzLnVwc2VydGVkSWQ7IC8vIG51bGwgb3IgYW4gaWQgY29udGFpbmluZyBhIGRvY3VtZW50IHRoYXQgaGFkIHRvIGJlIHVwc2VydGVkLlxuICogICAgIHJlcy51cHNlcnRlZENvdW50OyAvLyBOdW1iZXIgaW5kaWNhdGluZyBob3cgbWFueSBkb2N1bWVudHMgaGFkIHRvIGJlIHVwc2VydGVkLiBXaWxsIGVpdGhlciBiZSAwIG9yIDEuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0cmlnZ2VycyB0aGUgZm9sbG93aW5nIG1pZGRsZXdhcmUuXG4gKlxuICogLSBgcmVwbGFjZU9uZSgpYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaWx0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2NcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgc2VlIFtgUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucygpKVxuICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gW29wdGlvbnMuc3RyaWN0XSBvdmVyd3JpdGVzIHRoZSBzY2hlbWEncyBbc3RyaWN0IG1vZGUgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdHJpY3QpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnVwc2VydD1mYWxzZV0gaWYgdHJ1ZSwgYW5kIG5vIGRvY3VtZW50cyBmb3VuZCwgaW5zZXJ0IGEgbmV3IGRvY3VtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMud3JpdGVDb25jZXJuPW51bGxdIHNldHMgdGhlIFt3cml0ZSBjb25jZXJuXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvd3JpdGUtY29uY2Vybi8pIGZvciByZXBsaWNhIHNldHMuIE92ZXJyaWRlcyB0aGUgW3NjaGVtYS1sZXZlbCB3cml0ZSBjb25jZXJuXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN3cml0ZUNvbmNlcm4pXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRpbWVzdGFtcHM9bnVsbF0gSWYgc2V0IHRvIGBmYWxzZWAgYW5kIFtzY2hlbWEtbGV2ZWwgdGltZXN0YW1wc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdGltZXN0YW1wcykgYXJlIGVuYWJsZWQsIHNraXAgdGltZXN0YW1wcyBmb3IgdGhpcyB1cGRhdGUuIERvZXMgbm90aGluZyBpZiBzY2hlbWEtbGV2ZWwgdGltZXN0YW1wcyBhcmUgbm90IHNldC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJhbnNsYXRlQWxpYXNlcz1udWxsXSBJZiBzZXQgdG8gYHRydWVgLCB0cmFuc2xhdGVzIGFueSBzY2hlbWEtZGVmaW5lZCBhbGlhc2VzIGluIGBmaWx0ZXJgLCBgcHJvamVjdGlvbmAsIGB1cGRhdGVgLCBhbmQgYGRpc3RpbmN0YC4gVGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGFyZSBhbnkgY29uZmxpY3RzIHdoZXJlIGJvdGggYWxpYXMgYW5kIHJhdyBwcm9wZXJ0eSBhcmUgZGVmaW5lZCBvbiB0aGUgc2FtZSBvYmplY3QuXG4gKiBAcmV0dXJuIHtRdWVyeX1cbiAqIEBzZWUgUXVlcnkgZG9jcyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvcXVlcmllcy5odG1sXG4gKiBAc2VlIFVwZGF0ZVJlc3VsdCBodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvVXBkYXRlUmVzdWx0Lmh0bWxcbiAqIEByZXR1cm4ge1F1ZXJ5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5yZXBsYWNlT25lID0gZnVuY3Rpb24gcmVwbGFjZU9uZShjb25kaXRpb25zLCBkb2MsIG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAncmVwbGFjZU9uZScpO1xuXG4gIGNvbnN0IHZlcnNpb25LZXkgPSB0aGlzICYmIHRoaXMuc2NoZW1hICYmIHRoaXMuc2NoZW1hLm9wdGlvbnMgJiYgdGhpcy5zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5IHx8IG51bGw7XG4gIGlmICh2ZXJzaW9uS2V5ICYmICFkb2NbdmVyc2lvbktleV0pIHtcbiAgICBkb2NbdmVyc2lvbktleV0gPSAwO1xuICB9XG5cbiAgcmV0dXJuIF91cGRhdGUodGhpcywgJ3JlcGxhY2VPbmUnLCBjb25kaXRpb25zLCBkb2MsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDb21tb24gY29kZSBmb3IgYHVwZGF0ZU9uZSgpYCwgYHVwZGF0ZU1hbnkoKWAsIGByZXBsYWNlT25lKClgLCBhbmQgYHVwZGF0ZSgpYFxuICogYmVjYXVzZSB0aGV5IG5lZWQgdG8gZG8gdGhlIHNhbWUgdGhpbmdcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIF91cGRhdGUobW9kZWwsIG9wLCBjb25kaXRpb25zLCBkb2MsIG9wdGlvbnMpIHtcbiAgY29uc3QgbXEgPSBuZXcgbW9kZWwuUXVlcnkoe30sIHt9LCBtb2RlbCwgbW9kZWwuY29sbGVjdGlvbik7XG5cbiAgLy8gZ2gtMjQwNlxuICAvLyBtYWtlIGxvY2FsIGRlZXAgY29weSBvZiBjb25kaXRpb25zXG4gIGlmIChjb25kaXRpb25zIGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICBjb25kaXRpb25zID0gY29uZGl0aW9ucy50b09iamVjdCgpO1xuICB9IGVsc2Uge1xuICAgIGNvbmRpdGlvbnMgPSBjbG9uZShjb25kaXRpb25zKTtcbiAgfVxuICBvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zIDogY2xvbmUob3B0aW9ucyk7XG5cbiAgY29uc3QgdmVyc2lvbktleSA9IG1vZGVsICYmXG4gIG1vZGVsLnNjaGVtYSAmJlxuICBtb2RlbC5zY2hlbWEub3B0aW9ucyAmJlxuICBtb2RlbC5zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5IHx8IG51bGw7XG4gIGRlY29yYXRlVXBkYXRlV2l0aFZlcnNpb25LZXkoZG9jLCBvcHRpb25zLCB2ZXJzaW9uS2V5KTtcblxuICByZXR1cm4gbXFbb3BdKGNvbmRpdGlvbnMsIGRvYywgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgW2FnZ3JlZ2F0aW9uc10oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvYWdncmVnYXRpb24vKSBvbiB0aGUgbW9kZWxzIGNvbGxlY3Rpb24uXG4gKlxuICogSWYgYSBgY2FsbGJhY2tgIGlzIHBhc3NlZCwgdGhlIGBhZ2dyZWdhdGVgIGlzIGV4ZWN1dGVkIGFuZCBhIGBQcm9taXNlYCBpcyByZXR1cm5lZC4gSWYgYSBjYWxsYmFjayBpcyBub3QgcGFzc2VkLCB0aGUgYGFnZ3JlZ2F0ZWAgaXRzZWxmIGlzIHJldHVybmVkLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgdGhlIGZvbGxvd2luZyBtaWRkbGV3YXJlLlxuICpcbiAqIC0gYGFnZ3JlZ2F0ZSgpYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gRmluZCB0aGUgbWF4IGJhbGFuY2Ugb2YgYWxsIGFjY291bnRzXG4gKiAgICAgY29uc3QgcmVzID0gYXdhaXQgVXNlcnMuYWdncmVnYXRlKFtcbiAqICAgICAgIHsgJGdyb3VwOiB7IF9pZDogbnVsbCwgbWF4QmFsYW5jZTogeyAkbWF4OiAnJGJhbGFuY2UnIH19fSxcbiAqICAgICAgIHsgJHByb2plY3Q6IHsgX2lkOiAwLCBtYXhCYWxhbmNlOiAxIH19XG4gKiAgICAgXSk7XG4gKlxuICogICAgIGNvbnNvbGUubG9nKHJlcyk7IC8vIFsgeyBtYXhCYWxhbmNlOiA5ODAwMCB9IF1cbiAqXG4gKiAgICAgLy8gT3IgdXNlIHRoZSBhZ2dyZWdhdGlvbiBwaXBlbGluZSBidWlsZGVyLlxuICogICAgIGNvbnN0IHJlcyA9IGF3YWl0IFVzZXJzLmFnZ3JlZ2F0ZSgpLlxuICogICAgICAgZ3JvdXAoeyBfaWQ6IG51bGwsIG1heEJhbGFuY2U6IHsgJG1heDogJyRiYWxhbmNlJyB9IH0pLlxuICogICAgICAgcHJvamVjdCgnLWlkIG1heEJhbGFuY2UnKS5cbiAqICAgICAgIGV4ZWMoKTtcbiAqICAgICBjb25zb2xlLmxvZyhyZXMpOyAvLyBbIHsgbWF4QmFsYW5jZTogOTggfSBdXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIC0gTW9uZ29vc2UgZG9lcyAqKm5vdCoqIGNhc3QgYWdncmVnYXRpb24gcGlwZWxpbmVzIHRvIHRoZSBtb2RlbCdzIHNjaGVtYSBiZWNhdXNlIGAkcHJvamVjdGAgYW5kIGAkZ3JvdXBgIG9wZXJhdG9ycyBhbGxvdyByZWRlZmluaW5nIHRoZSBcInNoYXBlXCIgb2YgdGhlIGRvY3VtZW50cyBhdCBhbnkgc3RhZ2Ugb2YgdGhlIHBpcGVsaW5lLCB3aGljaCBtYXkgbGVhdmUgZG9jdW1lbnRzIGluIGFuIGluY29tcGF0aWJsZSBmb3JtYXQuIFlvdSBjYW4gdXNlIHRoZSBbbW9uZ29vc2UtY2FzdC1hZ2dyZWdhdGlvbiBwbHVnaW5dKGh0dHBzOi8vZ2l0aHViLmNvbS9BYmRlbHJhaG1hbkhhZmV6L21vbmdvb3NlLWNhc3QtYWdncmVnYXRpb24pIHRvIGVuYWJsZSBtaW5pbWFsIGNhc3RpbmcgZm9yIGFnZ3JlZ2F0aW9uIHBpcGVsaW5lcy5cbiAqIC0gVGhlIGRvY3VtZW50cyByZXR1cm5lZCBhcmUgcGxhaW4gamF2YXNjcmlwdCBvYmplY3RzLCBub3QgbW9uZ29vc2UgZG9jdW1lbnRzIChzaW5jZSBhbnkgc2hhcGUgb2YgZG9jdW1lbnQgY2FuIGJlIHJldHVybmVkKS5cbiAqXG4gKiAjIyMjIE1vcmUgQWJvdXQgQWdncmVnYXRpb25zOlxuICpcbiAqIC0gW01vbmdvb3NlIGBBZ2dyZWdhdGVgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2FnZ3JlZ2F0ZS5odG1sKVxuICogLSBbQW4gSW50cm9kdWN0aW9uIHRvIE1vbmdvb3NlIEFnZ3JlZ2F0ZV0oaHR0cHM6Ly9tYXN0ZXJpbmdqcy5pby90dXRvcmlhbHMvbW9uZ29vc2UvYWdncmVnYXRlKVxuICogLSBbTW9uZ29EQiBBZ2dyZWdhdGlvbiBkb2NzXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9hcHBsaWNhdGlvbnMvYWdncmVnYXRpb24vKVxuICpcbiAqIEBzZWUgQWdncmVnYXRlIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvYWdncmVnYXRlLmh0bWwjQWdncmVnYXRlKClcbiAqIEBzZWUgTW9uZ29EQiBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9hcHBsaWNhdGlvbnMvYWdncmVnYXRpb24vXG4gKiBAcGFyYW0ge0FycmF5fSBbcGlwZWxpbmVdIGFnZ3JlZ2F0aW9uIHBpcGVsaW5lIGFzIGFuIGFycmF5IG9mIG9iamVjdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gYWdncmVnYXRpb24gb3B0aW9uc1xuICogQHJldHVybiB7QWdncmVnYXRlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5hZ2dyZWdhdGUgPSBmdW5jdGlvbiBhZ2dyZWdhdGUocGlwZWxpbmUsIG9wdGlvbnMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAnYWdncmVnYXRlJyk7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignTW9kZWwuYWdncmVnYXRlKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgY29uc3QgYWdncmVnYXRlID0gbmV3IEFnZ3JlZ2F0ZShwaXBlbGluZSB8fCBbXSk7XG4gIGFnZ3JlZ2F0ZS5tb2RlbCh0aGlzKTtcbiAgaWYgKG9wdGlvbnMgIT0gbnVsbCkge1xuICAgIGFnZ3JlZ2F0ZS5vcHRpb24ob3B0aW9ucyk7XG4gIH1cblxuICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBhZ2dyZWdhdGU7XG4gIH1cblxuICByZXR1cm4gYWdncmVnYXRlO1xufTtcblxuLyoqXG4gKiBDYXN0cyBhbmQgdmFsaWRhdGVzIHRoZSBnaXZlbiBvYmplY3QgYWdhaW5zdCB0aGlzIG1vZGVsJ3Mgc2NoZW1hLCBwYXNzaW5nIHRoZVxuICogZ2l2ZW4gYGNvbnRleHRgIHRvIGN1c3RvbSB2YWxpZGF0b3JzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgTW9kZWwgPSBtb25nb29zZS5tb2RlbCgnVGVzdCcsIFNjaGVtYSh7XG4gKiAgICAgICBuYW1lOiB7IHR5cGU6IFN0cmluZywgcmVxdWlyZWQ6IHRydWUgfSxcbiAqICAgICAgIGFnZTogeyB0eXBlOiBOdW1iZXIsIHJlcXVpcmVkOiB0cnVlIH1cbiAqICAgICB9KTtcbiAqXG4gKiAgICAgdHJ5IHtcbiAqICAgICAgIGF3YWl0IE1vZGVsLnZhbGlkYXRlKHsgbmFtZTogbnVsbCB9LCBbJ25hbWUnXSlcbiAqICAgICB9IGNhdGNoIChlcnIpIHtcbiAqICAgICAgIGVyciBpbnN0YW5jZW9mIG1vbmdvb3NlLkVycm9yLlZhbGlkYXRpb25FcnJvcjsgLy8gdHJ1ZVxuICogICAgICAgT2JqZWN0LmtleXMoZXJyLmVycm9ycyk7IC8vIFsnbmFtZSddXG4gKiAgICAgfVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fFN0cmluZ30gcGF0aHNPck9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF1cbiAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0Pn0gY2FzdGVkIGFuZCB2YWxpZGF0ZWQgY29weSBvZiBgb2JqYCBpZiB2YWxpZGF0aW9uIHN1Y2NlZWRlZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC52YWxpZGF0ZSA9IGFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlKG9iaiwgcGF0aHNPck9wdGlvbnMsIGNvbnRleHQpIHtcbiAgaWYgKChhcmd1bWVudHMubGVuZ3RoIDwgMykgfHwgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgJiYgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAvLyBGb3IgY29udmVuaWVuY2UsIGlmIHdlJ3JlIHZhbGlkYXRpbmcgYSBkb2N1bWVudCBvciBhbiBvYmplY3QsIG1ha2UgYGNvbnRleHRgIGRlZmF1bHQgdG9cbiAgICAvLyB0aGUgbW9kZWwgc28gdXNlcnMgZG9uJ3QgaGF2ZSB0byBhbHdheXMgcGFzcyBgY29udGV4dGAsIHJlOiBnaC0xMDEzMiwgZ2gtMTAzNDZcbiAgICBjb250ZXh0ID0gb2JqO1xuICB9XG4gIGlmICh0eXBlb2YgY29udGV4dCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzNdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLnZhbGlkYXRlKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgbGV0IHNjaGVtYSA9IHRoaXMuc2NoZW1hO1xuICBjb25zdCBkaXNjcmltaW5hdG9yS2V5ID0gc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleTtcbiAgaWYgKHNjaGVtYS5kaXNjcmltaW5hdG9ycyAhPSBudWxsICYmIG9iaiAhPSBudWxsICYmIG9ialtkaXNjcmltaW5hdG9yS2V5XSAhPSBudWxsKSB7XG4gICAgc2NoZW1hID0gZ2V0U2NoZW1hRGlzY3JpbWluYXRvckJ5VmFsdWUoc2NoZW1hLCBvYmpbZGlzY3JpbWluYXRvcktleV0pIHx8IHNjaGVtYTtcbiAgfVxuICBsZXQgcGF0aHMgPSBPYmplY3Qua2V5cyhzY2hlbWEucGF0aHMpO1xuXG4gIGlmIChwYXRoc09yT3B0aW9ucyAhPSBudWxsKSB7XG4gICAgY29uc3QgX3BhdGhzVG9WYWxpZGF0ZSA9IHR5cGVvZiBwYXRoc09yT3B0aW9ucyA9PT0gJ3N0cmluZycgPyBuZXcgU2V0KHBhdGhzT3JPcHRpb25zLnNwbGl0KCcgJykpIDogQXJyYXkuaXNBcnJheShwYXRoc09yT3B0aW9ucykgPyBuZXcgU2V0KHBhdGhzT3JPcHRpb25zKSA6IG5ldyBTZXQocGF0aHMpO1xuICAgIHBhdGhzID0gcGF0aHMuZmlsdGVyKHAgPT4ge1xuICAgICAgaWYgKHBhdGhzT3JPcHRpb25zLnBhdGhzVG9Ta2lwKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhdGhzT3JPcHRpb25zLnBhdGhzVG9Ta2lwKSkge1xuICAgICAgICAgIGlmIChwYXRoc09yT3B0aW9ucy5wYXRoc1RvU2tpcC5maW5kKHggPT4geCA9PSBwKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGF0aHNPck9wdGlvbnMucGF0aHNUb1NraXAgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZiAocGF0aHNPck9wdGlvbnMucGF0aHNUb1NraXAuaW5jbHVkZXMocCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHBpZWNlcyA9IHAuc3BsaXQoJy4nKTtcbiAgICAgIGxldCBjdXIgPSBwaWVjZXNbMF07XG5cbiAgICAgIGZvciAoY29uc3QgcGllY2Ugb2YgcGllY2VzKSB7XG4gICAgICAgIGlmIChfcGF0aHNUb1ZhbGlkYXRlLmhhcyhjdXIpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY3VyICs9ICcuJyArIHBpZWNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3BhdGhzVG9WYWxpZGF0ZS5oYXMocCk7XG4gICAgfSk7XG4gIH1cblxuICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICBjb25zdCBzY2hlbWFUeXBlID0gc2NoZW1hLnBhdGgocGF0aCk7XG4gICAgaWYgKCFzY2hlbWFUeXBlIHx8ICFzY2hlbWFUeXBlLiRpc01vbmdvb3NlQXJyYXkgfHwgc2NoZW1hVHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbCA9IGdldChvYmosIHBhdGgpO1xuICAgIHB1c2hOZXN0ZWRBcnJheVBhdGhzKHBhdGhzLCB2YWwsIHBhdGgpO1xuICB9XG5cbiAgbGV0IGVycm9yID0gbnVsbDtcbiAgcGF0aHMgPSBuZXcgU2V0KHBhdGhzKTtcblxuICB0cnkge1xuICAgIG9iaiA9IHRoaXMuY2FzdE9iamVjdChvYmopO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnJvciA9IGVycjtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhlcnJvci5lcnJvcnMgfHwge30pKSB7XG4gICAgICBwYXRocy5kZWxldGUoa2V5KTtcbiAgICB9XG4gIH1cblxuICBsZXQgcmVtYWluaW5nID0gcGF0aHMuc2l6ZTtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgICAgY29uc3Qgc2NoZW1hVHlwZSA9IHNjaGVtYS5wYXRoKHBhdGgpO1xuICAgICAgaWYgKHNjaGVtYVR5cGUgPT0gbnVsbCkge1xuICAgICAgICBfY2hlY2tEb25lKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwaWVjZXMgPSBwYXRoLmluZGV4T2YoJy4nKSA9PT0gLTEgPyBbcGF0aF0gOiBwYXRoLnNwbGl0KCcuJyk7XG4gICAgICBsZXQgY3VyID0gb2JqO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwaWVjZXMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgIGN1ciA9IGN1cltwaWVjZXNbaV1dO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB2YWwgPSBnZXQob2JqLCBwYXRoLCB2b2lkIDApO1xuXG4gICAgICBzY2hlbWFUeXBlLmRvVmFsaWRhdGUodmFsLCBlcnIgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgZXJyb3IgPSBlcnJvciB8fCBuZXcgVmFsaWRhdGlvbkVycm9yKCk7XG4gICAgICAgICAgZXJyb3IuYWRkRXJyb3IocGF0aCwgZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBfY2hlY2tEb25lKCk7XG4gICAgICB9LCBjb250ZXh0LCB7IHBhdGg6IHBhdGggfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2NoZWNrRG9uZSgpIHtcbiAgICAgIGlmICgtLXJlbWFpbmluZyA8PSAwKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShvYmopO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogUG9wdWxhdGVzIGRvY3VtZW50IHJlZmVyZW5jZXMuXG4gKlxuICogQ2hhbmdlZCBpbiBNb25nb29zZSA2OiB0aGUgbW9kZWwgeW91IGNhbGwgYHBvcHVsYXRlKClgIG9uIHNob3VsZCBiZSB0aGVcbiAqIFwibG9jYWwgZmllbGRcIiBtb2RlbCwgKipub3QqKiB0aGUgXCJmb3JlaWduIGZpZWxkXCIgbW9kZWwuXG4gKlxuICogIyMjIyBBdmFpbGFibGUgdG9wLWxldmVsIG9wdGlvbnM6XG4gKlxuICogLSBwYXRoOiBzcGFjZSBkZWxpbWl0ZWQgcGF0aChzKSB0byBwb3B1bGF0ZVxuICogLSBzZWxlY3Q6IG9wdGlvbmFsIGZpZWxkcyB0byBzZWxlY3RcbiAqIC0gbWF0Y2g6IG9wdGlvbmFsIHF1ZXJ5IGNvbmRpdGlvbnMgdG8gbWF0Y2hcbiAqIC0gbW9kZWw6IG9wdGlvbmFsIG5hbWUgb2YgdGhlIG1vZGVsIHRvIHVzZSBmb3IgcG9wdWxhdGlvblxuICogLSBvcHRpb25zOiBvcHRpb25hbCBxdWVyeSBvcHRpb25zIGxpa2Ugc29ydCwgbGltaXQsIGV0Y1xuICogLSBqdXN0T25lOiBvcHRpb25hbCBib29sZWFuLCBpZiB0cnVlIE1vbmdvb3NlIHdpbGwgYWx3YXlzIHNldCBgcGF0aGAgdG8gYSBkb2N1bWVudCwgb3IgYG51bGxgIGlmIG5vIGRvY3VtZW50IHdhcyBmb3VuZC4gSWYgZmFsc2UsIE1vbmdvb3NlIHdpbGwgYWx3YXlzIHNldCBgcGF0aGAgdG8gYW4gYXJyYXksIHdoaWNoIHdpbGwgYmUgZW1wdHkgaWYgbm8gZG9jdW1lbnRzIGFyZSBmb3VuZC4gSW5mZXJyZWQgZnJvbSBzY2hlbWEgYnkgZGVmYXVsdC5cbiAqIC0gc3RyaWN0UG9wdWxhdGU6IG9wdGlvbmFsIGJvb2xlYW4sIHNldCB0byBgZmFsc2VgIHRvIGFsbG93IHBvcHVsYXRpbmcgcGF0aHMgdGhhdCBhcmVuJ3QgaW4gdGhlIHNjaGVtYS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IERvZyA9IG1vbmdvb3NlLm1vZGVsKCdEb2cnLCBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nLCBicmVlZDogU3RyaW5nIH0pKTtcbiAqICAgICBjb25zdCBQZXJzb24gPSBtb25nb29zZS5tb2RlbCgnUGVyc29uJywgbmV3IFNjaGVtYSh7XG4gKiAgICAgICBuYW1lOiBTdHJpbmcsXG4gKiAgICAgICBwZXQ6IHsgdHlwZTogbW9uZ29vc2UuT2JqZWN0SWQsIHJlZjogJ0RvZycgfVxuICogICAgIH0pKTtcbiAqXG4gKiAgICAgY29uc3QgcGV0cyA9IGF3YWl0IFBldC5jcmVhdGUoW1xuICogICAgICAgeyBuYW1lOiAnRGFpc3knLCBicmVlZDogJ0JlYWdsZScgfSxcbiAqICAgICAgIHsgbmFtZTogJ0VpbnN0ZWluJywgYnJlZWQ6ICdDYXRhbGFuIFNoZWVwZG9nJyB9XG4gKiAgICAgXSk7XG4gKlxuICogICAgIC8vIHBvcHVsYXRlIG1hbnkgcGxhaW4gb2JqZWN0c1xuICogICAgIGNvbnN0IHVzZXJzID0gW1xuICogICAgICAgeyBuYW1lOiAnSm9obiBXaWNrJywgZG9nOiBwZXRzWzBdLl9pZCB9LFxuICogICAgICAgeyBuYW1lOiAnRG9jIEJyb3duJywgZG9nOiBwZXRzWzFdLl9pZCB9XG4gKiAgICAgXTtcbiAqICAgICBhd2FpdCBVc2VyLnBvcHVsYXRlKHVzZXJzLCB7IHBhdGg6ICdkb2cnLCBzZWxlY3Q6ICduYW1lJyB9KTtcbiAqICAgICB1c2Vyc1swXS5kb2cubmFtZTsgLy8gJ0RhaXN5J1xuICogICAgIHVzZXJzWzBdLmRvZy5icmVlZDsgLy8gdW5kZWZpbmVkIGJlY2F1c2Ugb2YgYHNlbGVjdGBcbiAqXG4gKiBAcGFyYW0ge0RvY3VtZW50fEFycmF5fSBkb2NzIEVpdGhlciBhIHNpbmdsZSBkb2N1bWVudCBvciBhcnJheSBvZiBkb2N1bWVudHMgdG8gcG9wdWxhdGUuXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IG9wdGlvbnMgRWl0aGVyIHRoZSBwYXRocyB0byBwb3B1bGF0ZSBvciBhbiBvYmplY3Qgc3BlY2lmeWluZyBhbGwgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBhdGg9bnVsbF0gVGhlIHBhdGggdG8gcG9wdWxhdGUuXG4gKiBAcGFyYW0ge3N0cmluZ3xQb3B1bGF0ZU9wdGlvbnN9IFtvcHRpb25zLnBvcHVsYXRlPW51bGxdIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIHBhdGhzIGluIHRoZSBwb3B1bGF0ZWQgZG9jdW1lbnRzLiBTZWUgW2RlZXAgcG9wdWxhdGUgZG9jc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3BvcHVsYXRlLmh0bWwjZGVlcC1wb3B1bGF0ZSkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJldGFpbk51bGxWYWx1ZXM9ZmFsc2VdIEJ5IGRlZmF1bHQsIE1vbmdvb3NlIHJlbW92ZXMgbnVsbCBhbmQgdW5kZWZpbmVkIHZhbHVlcyBmcm9tIHBvcHVsYXRlZCBhcnJheXMuIFVzZSB0aGlzIG9wdGlvbiB0byBtYWtlIGBwb3B1bGF0ZSgpYCByZXRhaW4gYG51bGxgIGFuZCBgdW5kZWZpbmVkYCBhcnJheSBlbnRyaWVzLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5nZXR0ZXJzPWZhbHNlXSBJZiB0cnVlLCBNb25nb29zZSB3aWxsIGNhbGwgYW55IGdldHRlcnMgZGVmaW5lZCBvbiB0aGUgYGxvY2FsRmllbGRgLiBCeSBkZWZhdWx0LCBNb25nb29zZSBnZXRzIHRoZSByYXcgdmFsdWUgb2YgYGxvY2FsRmllbGRgLiBGb3IgZXhhbXBsZSwgeW91IHdvdWxkIG5lZWQgdG8gc2V0IHRoaXMgb3B0aW9uIHRvIGB0cnVlYCBpZiB5b3Ugd2FudGVkIHRvIFthZGQgYSBgbG93ZXJjYXNlYCBnZXR0ZXIgdG8geW91ciBgbG9jYWxGaWVsZGBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zY2hlbWF0eXBlcy5odG1sI3NjaGVtYXR5cGUtb3B0aW9ucykuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNsb25lPWZhbHNlXSBXaGVuIHlvdSBkbyBgQmxvZ1Bvc3QuZmluZCgpLnBvcHVsYXRlKCdhdXRob3InKWAsIGJsb2cgcG9zdHMgd2l0aCB0aGUgc2FtZSBhdXRob3Igd2lsbCBzaGFyZSAxIGNvcHkgb2YgYW4gYGF1dGhvcmAgZG9jLiBFbmFibGUgdGhpcyBvcHRpb24gdG8gbWFrZSBNb25nb29zZSBjbG9uZSBwb3B1bGF0ZWQgZG9jcyBiZWZvcmUgYXNzaWduaW5nIHRoZW0uXG4gKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gW29wdGlvbnMubWF0Y2g9bnVsbF0gQWRkIGFuIGFkZGl0aW9uYWwgZmlsdGVyIHRvIHRoZSBwb3B1bGF0ZSBxdWVyeS4gQ2FuIGJlIGEgZmlsdGVyIG9iamVjdCBjb250YWluaW5nIFtNb25nb0RCIHF1ZXJ5IHN5bnRheF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvdHV0b3JpYWwvcXVlcnktZG9jdW1lbnRzLyksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZmlsdGVyIG9iamVjdC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcEludmFsaWRJZHM9ZmFsc2VdIEJ5IGRlZmF1bHQsIE1vbmdvb3NlIHRocm93cyBhIGNhc3QgZXJyb3IgaWYgYGxvY2FsRmllbGRgIGFuZCBgZm9yZWlnbkZpZWxkYCBzY2hlbWFzIGRvbid0IGxpbmUgdXAuIElmIHlvdSBlbmFibGUgdGhpcyBvcHRpb24sIE1vbmdvb3NlIHdpbGwgaW5zdGVhZCBmaWx0ZXIgb3V0IGFueSBgbG9jYWxGaWVsZGAgcHJvcGVydGllcyB0aGF0IGNhbm5vdCBiZSBjYXN0ZWQgdG8gYGZvcmVpZ25GaWVsZGAncyBzY2hlbWEgdHlwZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wZXJEb2N1bWVudExpbWl0PW51bGxdIEZvciBsZWdhY3kgcmVhc29ucywgYGxpbWl0YCB3aXRoIGBwb3B1bGF0ZSgpYCBtYXkgZ2l2ZSBpbmNvcnJlY3QgcmVzdWx0cyBiZWNhdXNlIGl0IG9ubHkgZXhlY3V0ZXMgYSBzaW5nbGUgcXVlcnkgZm9yIGV2ZXJ5IGRvY3VtZW50IGJlaW5nIHBvcHVsYXRlZC4gSWYgeW91IHNldCBgcGVyRG9jdW1lbnRMaW1pdGAsIE1vbmdvb3NlIHdpbGwgZW5zdXJlIGNvcnJlY3QgYGxpbWl0YCBwZXIgZG9jdW1lbnQgYnkgZXhlY3V0aW5nIGEgc2VwYXJhdGUgcXVlcnkgZm9yIGVhY2ggZG9jdW1lbnQgdG8gYHBvcHVsYXRlKClgLiBGb3IgZXhhbXBsZSwgYC5maW5kKCkucG9wdWxhdGUoeyBwYXRoOiAndGVzdCcsIHBlckRvY3VtZW50TGltaXQ6IDIgfSlgIHdpbGwgZXhlY3V0ZSAyIGFkZGl0aW9uYWwgcXVlcmllcyBpZiBgLmZpbmQoKWAgcmV0dXJucyAyIGRvY3VtZW50cy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3RyaWN0UG9wdWxhdGU9dHJ1ZV0gU2V0IHRvIGZhbHNlIHRvIGFsbG93IHBvcHVsYXRpbmcgcGF0aHMgdGhhdCBhcmVuJ3QgZGVmaW5lZCBpbiB0aGUgZ2l2ZW4gbW9kZWwncyBzY2hlbWEuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMub3B0aW9ucz1udWxsXSBBZGRpdGlvbmFsIG9wdGlvbnMgbGlrZSBgbGltaXRgIGFuZCBgbGVhbmAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy50cmFuc2Zvcm09bnVsbF0gRnVuY3Rpb24gdGhhdCBNb25nb29zZSB3aWxsIGNhbGwgb24gZXZlcnkgcG9wdWxhdGVkIGRvY3VtZW50IHRoYXQgYWxsb3dzIHlvdSB0byB0cmFuc2Zvcm0gdGhlIHBvcHVsYXRlZCBkb2N1bWVudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjayhlcnIsZG9jKV0gT3B0aW9uYWwgY2FsbGJhY2ssIGV4ZWN1dGVkIHVwb24gY29tcGxldGlvbi4gUmVjZWl2ZXMgYGVycmAgYW5kIHRoZSBgZG9jKHMpYC5cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vZGVsLnBvcHVsYXRlID0gYXN5bmMgZnVuY3Rpb24gcG9wdWxhdGUoZG9jcywgcGF0aHMpIHtcbiAgX2NoZWNrQ29udGV4dCh0aGlzLCAncG9wdWxhdGUnKTtcbiAgaWYgKHR5cGVvZiBwYXRocyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ01vZGVsLnBvcHVsYXRlKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG4gIGNvbnN0IF90aGlzID0gdGhpcztcbiAgLy8gbm9ybWFsaXplZCBwYXRoc1xuICBwYXRocyA9IHV0aWxzLnBvcHVsYXRlKHBhdGhzKTtcbiAgLy8gZGF0YSB0aGF0IHNob3VsZCBwZXJzaXN0IGFjcm9zcyBzdWJQb3B1bGF0ZSBjYWxsc1xuICBjb25zdCBjYWNoZSA9IHt9O1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgX3BvcHVsYXRlKF90aGlzLCBkb2NzLCBwYXRocywgY2FjaGUsIChlcnIsIHJlcykgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKHJlcyk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBQb3B1bGF0ZSBoZWxwZXJcbiAqXG4gKiBAcGFyYW0ge01vZGVsfSBtb2RlbCB0aGUgbW9kZWwgdG8gdXNlXG4gKiBAcGFyYW0ge0RvY3VtZW50fEFycmF5fSBkb2NzIEVpdGhlciBhIHNpbmdsZSBkb2N1bWVudCBvciBhcnJheSBvZiBkb2N1bWVudHMgdG8gcG9wdWxhdGUuXG4gKiBAcGFyYW0ge09iamVjdH0gcGF0aHNcbiAqIEBwYXJhbSB7bmV2ZXJ9IGNhY2hlIFVudXNlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBPcHRpb25hbCBjYWxsYmFjaywgZXhlY3V0ZWQgdXBvbiBjb21wbGV0aW9uLiBSZWNlaXZlcyBgZXJyYCBhbmQgdGhlIGBkb2MocylgLlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBfcG9wdWxhdGUobW9kZWwsIGRvY3MsIHBhdGhzLCBjYWNoZSwgY2FsbGJhY2spIHtcbiAgbGV0IHBlbmRpbmcgPSBwYXRocy5sZW5ndGg7XG4gIGlmIChwYXRocy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZG9jcyk7XG4gIH1cbiAgLy8gZWFjaCBwYXRoIGhhcyBpdHMgb3duIHF1ZXJ5IG9wdGlvbnMgYW5kIG11c3QgYmUgZXhlY3V0ZWQgc2VwYXJhdGVseVxuICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICBwb3B1bGF0ZShtb2RlbCwgZG9jcywgcGF0aCwgbmV4dCk7XG4gIH1cblxuICBmdW5jdGlvbiBuZXh0KGVycikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIG51bGwpO1xuICAgIH1cbiAgICBpZiAoLS1wZW5kaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrKG51bGwsIGRvY3MpO1xuICB9XG59XG5cbi8qIVxuICogUG9wdWxhdGVzIGBkb2NzYFxuICovXG5jb25zdCBleGNsdWRlSWRSZWcgPSAvXFxzPy1faWRcXHM/LztcbmNvbnN0IGV4Y2x1ZGVJZFJlZ0dsb2JhbCA9IC9cXHM/LV9pZFxccz8vZztcblxuZnVuY3Rpb24gcG9wdWxhdGUobW9kZWwsIGRvY3MsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHBvcHVsYXRlT3B0aW9ucyA9IG9wdGlvbnM7XG4gIGlmIChvcHRpb25zLnN0cmljdFBvcHVsYXRlID09IG51bGwpIHtcbiAgICBpZiAob3B0aW9ucy5fbG9jYWxNb2RlbCAhPSBudWxsICYmIG9wdGlvbnMuX2xvY2FsTW9kZWwuc2NoZW1hLl91c2VyUHJvdmlkZWRPcHRpb25zLnN0cmljdFBvcHVsYXRlICE9IG51bGwpIHtcbiAgICAgIHBvcHVsYXRlT3B0aW9ucy5zdHJpY3RQb3B1bGF0ZSA9IG9wdGlvbnMuX2xvY2FsTW9kZWwuc2NoZW1hLl91c2VyUHJvdmlkZWRPcHRpb25zLnN0cmljdFBvcHVsYXRlO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5fbG9jYWxNb2RlbCAhPSBudWxsICYmIG1vZGVsLmJhc2Uub3B0aW9ucy5zdHJpY3RQb3B1bGF0ZSAhPSBudWxsKSB7XG4gICAgICBwb3B1bGF0ZU9wdGlvbnMuc3RyaWN0UG9wdWxhdGUgPSBtb2RlbC5iYXNlLm9wdGlvbnMuc3RyaWN0UG9wdWxhdGU7XG4gICAgfSBlbHNlIGlmIChtb2RlbC5iYXNlLm9wdGlvbnMuc3RyaWN0UG9wdWxhdGUgIT0gbnVsbCkge1xuICAgICAgcG9wdWxhdGVPcHRpb25zLnN0cmljdFBvcHVsYXRlID0gbW9kZWwuYmFzZS5vcHRpb25zLnN0cmljdFBvcHVsYXRlO1xuICAgIH1cbiAgfVxuXG4gIC8vIG5vcm1hbGl6ZSBzaW5nbGUgLyBtdWx0aXBsZSBkb2NzIHBhc3NlZFxuICBpZiAoIUFycmF5LmlzQXJyYXkoZG9jcykpIHtcbiAgICBkb2NzID0gW2RvY3NdO1xuICB9XG4gIGlmIChkb2NzLmxlbmd0aCA9PT0gMCB8fCBkb2NzLmV2ZXJ5KHV0aWxzLmlzTnVsbE9yVW5kZWZpbmVkKSkge1xuICAgIHJldHVybiBjYWxsYmFjaygpO1xuICB9XG5cbiAgY29uc3QgbW9kZWxzTWFwID0gZ2V0TW9kZWxzTWFwRm9yUG9wdWxhdGUobW9kZWwsIGRvY3MsIHBvcHVsYXRlT3B0aW9ucyk7XG5cbiAgaWYgKG1vZGVsc01hcCBpbnN0YW5jZW9mIE1vbmdvb3NlRXJyb3IpIHtcbiAgICByZXR1cm4gaW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgY2FsbGJhY2sobW9kZWxzTWFwKTtcbiAgICB9KTtcbiAgfVxuICBjb25zdCBsZW4gPSBtb2RlbHNNYXAubGVuZ3RoO1xuICBsZXQgdmFscyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGZsYXR0ZW4oaXRlbSkge1xuICAgIC8vIG5vIG5lZWQgdG8gaW5jbHVkZSB1bmRlZmluZWQgdmFsdWVzIGluIG91ciBxdWVyeVxuICAgIHJldHVybiB1bmRlZmluZWQgIT09IGl0ZW07XG4gIH1cblxuICBsZXQgX3JlbWFpbmluZyA9IGxlbjtcbiAgbGV0IGhhc09uZSA9IGZhbHNlO1xuICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGNvbnN0IG1vZCA9IG1vZGVsc01hcFtpXTtcbiAgICBsZXQgc2VsZWN0ID0gbW9kLm9wdGlvbnMuc2VsZWN0O1xuICAgIGxldCBpZHMgPSB1dGlscy5hcnJheS5mbGF0dGVuKG1vZC5pZHMsIGZsYXR0ZW4pO1xuICAgIGlkcyA9IHV0aWxzLmFycmF5LnVuaXF1ZShpZHMpO1xuXG4gICAgY29uc3QgYXNzaWdubWVudE9wdHMgPSB7fTtcbiAgICBhc3NpZ25tZW50T3B0cy5zb3J0ID0gbW9kICYmXG4gICAgICBtb2Qub3B0aW9ucyAmJlxuICAgICAgbW9kLm9wdGlvbnMub3B0aW9ucyAmJlxuICAgICAgbW9kLm9wdGlvbnMub3B0aW9ucy5zb3J0IHx8IHZvaWQgMDtcbiAgICBhc3NpZ25tZW50T3B0cy5leGNsdWRlSWQgPSBleGNsdWRlSWRSZWcudGVzdChzZWxlY3QpIHx8IChzZWxlY3QgJiYgc2VsZWN0Ll9pZCA9PT0gMCk7XG5cbiAgICAvLyBMZWFuIHRyYW5zZm9ybSBtYXkgZGVsZXRlIGBfaWRgLCB3aGljaCB3b3VsZCBjYXVzZSBhc3NpZ25tZW50XG4gICAgLy8gdG8gZmFpbC4gU28gZGVsYXkgcnVubmluZyBsZWFuIHRyYW5zZm9ybSB1bnRpbCBfYWZ0ZXJfXG4gICAgLy8gYF9hc3NpZ24oKWBcbiAgICBpZiAobW9kLm9wdGlvbnMgJiZcbiAgICAgICAgbW9kLm9wdGlvbnMub3B0aW9ucyAmJlxuICAgICAgICBtb2Qub3B0aW9ucy5vcHRpb25zLmxlYW4gJiZcbiAgICAgICAgbW9kLm9wdGlvbnMub3B0aW9ucy5sZWFuLnRyYW5zZm9ybSkge1xuICAgICAgbW9kLm9wdGlvbnMub3B0aW9ucy5fbGVhblRyYW5zZm9ybSA9IG1vZC5vcHRpb25zLm9wdGlvbnMubGVhbi50cmFuc2Zvcm07XG4gICAgICBtb2Qub3B0aW9ucy5vcHRpb25zLmxlYW4gPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpZHMubGVuZ3RoID09PSAwIHx8IGlkcy5ldmVyeSh1dGlscy5pc051bGxPclVuZGVmaW5lZCkpIHtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IHdlIHNldCB0byAwIG9yIGVtcHR5IGFycmF5IGV2ZW5cbiAgICAgIC8vIGlmIHdlIGRvbid0IGFjdHVhbGx5IGV4ZWN1dGUgYSBxdWVyeSB0byBtYWtlIHN1cmUgdGhlcmUncyBhIHZhbHVlXG4gICAgICAvLyBhbmQgd2Uga25vdyB0aGlzIHBhdGggd2FzIHBvcHVsYXRlZCBmb3IgZnV0dXJlIHNldHMuIFNlZSBnaC03NzMxLCBnaC04MjMwXG4gICAgICAtLV9yZW1haW5pbmc7XG4gICAgICBfYXNzaWduKG1vZGVsLCBbXSwgbW9kLCBhc3NpZ25tZW50T3B0cyk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBoYXNPbmUgPSB0cnVlO1xuICAgIGlmICh0eXBlb2YgcG9wdWxhdGVPcHRpb25zLmZvcmVpZ25GaWVsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG1vZC5mb3JlaWduRmllbGQuY2xlYXIoKTtcbiAgICAgIG1vZC5mb3JlaWduRmllbGQuYWRkKHBvcHVsYXRlT3B0aW9ucy5mb3JlaWduRmllbGQpO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaCA9IGNyZWF0ZVBvcHVsYXRlUXVlcnlGaWx0ZXIoaWRzLCBtb2QubWF0Y2gsIG1vZC5mb3JlaWduRmllbGQsIG1vZC5tb2RlbCwgbW9kLm9wdGlvbnMuc2tpcEludmFsaWRJZHMpO1xuICAgIGlmIChhc3NpZ25tZW50T3B0cy5leGNsdWRlSWQpIHtcbiAgICAgIC8vIG92ZXJyaWRlIHRoZSBleGNsdXNpb24gZnJvbSB0aGUgcXVlcnkgc28gd2UgY2FuIHVzZSB0aGUgX2lkXG4gICAgICAvLyBmb3IgZG9jdW1lbnQgbWF0Y2hpbmcgZHVyaW5nIGFzc2lnbm1lbnQuIHdlJ2xsIGRlbGV0ZSB0aGVcbiAgICAgIC8vIF9pZCBiYWNrIG9mZiBiZWZvcmUgcmV0dXJuaW5nIHRoZSByZXN1bHQuXG4gICAgICBpZiAodHlwZW9mIHNlbGVjdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgc2VsZWN0ID0gc2VsZWN0LnJlcGxhY2UoZXhjbHVkZUlkUmVnR2xvYmFsLCAnICcpO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNlbGVjdCkpIHtcbiAgICAgICAgc2VsZWN0ID0gc2VsZWN0LmZpbHRlcihmaWVsZCA9PiBmaWVsZCAhPT0gJy1faWQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHByZXNlcnZlIG9yaWdpbmFsIHNlbGVjdCBjb25kaXRpb25zIGJ5IGNvcHlpbmdcbiAgICAgICAgc2VsZWN0ID0geyAuLi5zZWxlY3QgfTtcbiAgICAgICAgZGVsZXRlIHNlbGVjdC5faWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1vZC5vcHRpb25zLm9wdGlvbnMgJiYgbW9kLm9wdGlvbnMub3B0aW9ucy5saW1pdCAhPSBudWxsKSB7XG4gICAgICBhc3NpZ25tZW50T3B0cy5vcmlnaW5hbExpbWl0ID0gbW9kLm9wdGlvbnMub3B0aW9ucy5saW1pdDtcbiAgICB9IGVsc2UgaWYgKG1vZC5vcHRpb25zLmxpbWl0ICE9IG51bGwpIHtcbiAgICAgIGFzc2lnbm1lbnRPcHRzLm9yaWdpbmFsTGltaXQgPSBtb2Qub3B0aW9ucy5saW1pdDtcbiAgICB9XG4gICAgcGFyYW1zLnB1c2goW21vZCwgbWF0Y2gsIHNlbGVjdCwgYXNzaWdubWVudE9wdHMsIF9uZXh0XSk7XG4gIH1cbiAgaWYgKCFoYXNPbmUpIHtcbiAgICAvLyBJZiBtb2RlbHMgYnV0IG5vIGRvY3MsIHNraXAgZnVydGhlciBkZWVwIHBvcHVsYXRlLlxuICAgIGlmIChtb2RlbHNNYXAubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG4gICAgLy8gSWYgbm8gbW9kZWxzIHRvIHBvcHVsYXRlIGJ1dCB3ZSBoYXZlIGEgbmVzdGVkIHBvcHVsYXRlLFxuICAgIC8vIGtlZXAgdHJ5aW5nLCByZTogZ2gtODk0NlxuICAgIGlmIChwb3B1bGF0ZU9wdGlvbnMucG9wdWxhdGUgIT0gbnVsbCkge1xuICAgICAgY29uc3Qgb3B0cyA9IHV0aWxzLnBvcHVsYXRlKHBvcHVsYXRlT3B0aW9ucy5wb3B1bGF0ZSkubWFwKHBvcCA9PiBPYmplY3QuYXNzaWduKHt9LCBwb3AsIHtcbiAgICAgICAgcGF0aDogcG9wdWxhdGVPcHRpb25zLnBhdGggKyAnLicgKyBwb3AucGF0aFxuICAgICAgfSkpO1xuICAgICAgbW9kZWwucG9wdWxhdGUoZG9jcywgb3B0cykudGhlbihyZXMgPT4geyBjYWxsYmFjayhudWxsLCByZXMpOyB9LCBlcnIgPT4geyBjYWxsYmFjayhlcnIpOyB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gIH1cblxuICBmb3IgKGNvbnN0IGFyciBvZiBwYXJhbXMpIHtcbiAgICBfZXhlY1BvcHVsYXRlUXVlcnkuYXBwbHkobnVsbCwgYXJyKTtcbiAgfVxuICBmdW5jdGlvbiBfbmV4dChlcnIsIHZhbHNGcm9tRGIpIHtcbiAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIG51bGwpO1xuICAgIH1cbiAgICB2YWxzID0gdmFscy5jb25jYXQodmFsc0Zyb21EYik7XG4gICAgaWYgKC0tX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgX2RvbmUoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfZG9uZSgpIHtcbiAgICBmb3IgKGNvbnN0IGFyciBvZiBwYXJhbXMpIHtcbiAgICAgIGNvbnN0IG1vZCA9IGFyclswXTtcbiAgICAgIGNvbnN0IGFzc2lnbm1lbnRPcHRzID0gYXJyWzNdO1xuICAgICAgZm9yIChjb25zdCB2YWwgb2YgdmFscykge1xuICAgICAgICBtb2Qub3B0aW9ucy5fY2hpbGREb2NzLnB1c2godmFsKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIF9hc3NpZ24obW9kZWwsIHZhbHMsIG1vZCwgYXNzaWdubWVudE9wdHMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgYXJyIG9mIHBhcmFtcykge1xuICAgICAgcmVtb3ZlRGVzZWxlY3RlZEZvcmVpZ25GaWVsZChhcnJbMF0uZm9yZWlnbkZpZWxkLCBhcnJbMF0ub3B0aW9ucywgdmFscyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgYXJyIG9mIHBhcmFtcykge1xuICAgICAgY29uc3QgbW9kID0gYXJyWzBdO1xuICAgICAgaWYgKG1vZC5vcHRpb25zICYmIG1vZC5vcHRpb25zLm9wdGlvbnMgJiYgbW9kLm9wdGlvbnMub3B0aW9ucy5fbGVhblRyYW5zZm9ybSkge1xuICAgICAgICBmb3IgKGNvbnN0IGRvYyBvZiB2YWxzKSB7XG4gICAgICAgICAgbW9kLm9wdGlvbnMub3B0aW9ucy5fbGVhblRyYW5zZm9ybShkb2MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfZXhlY1BvcHVsYXRlUXVlcnkobW9kLCBtYXRjaCwgc2VsZWN0LCBhc3NpZ25tZW50T3B0cywgY2FsbGJhY2spIHtcbiAgbGV0IHN1YlBvcHVsYXRlID0gY2xvbmUobW9kLm9wdGlvbnMucG9wdWxhdGUpO1xuICBjb25zdCBxdWVyeU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBza2lwOiBtb2Qub3B0aW9ucy5za2lwLFxuICAgIGxpbWl0OiBtb2Qub3B0aW9ucy5saW1pdCxcbiAgICBwZXJEb2N1bWVudExpbWl0OiBtb2Qub3B0aW9ucy5wZXJEb2N1bWVudExpbWl0XG4gIH0sIG1vZC5vcHRpb25zLm9wdGlvbnMpO1xuXG4gIGlmIChtb2QuY291bnQpIHtcbiAgICBkZWxldGUgcXVlcnlPcHRpb25zLnNraXA7XG4gIH1cblxuICBpZiAocXVlcnlPcHRpb25zLnBlckRvY3VtZW50TGltaXQgIT0gbnVsbCkge1xuICAgIHF1ZXJ5T3B0aW9ucy5saW1pdCA9IHF1ZXJ5T3B0aW9ucy5wZXJEb2N1bWVudExpbWl0O1xuICAgIGRlbGV0ZSBxdWVyeU9wdGlvbnMucGVyRG9jdW1lbnRMaW1pdDtcbiAgfSBlbHNlIGlmIChxdWVyeU9wdGlvbnMubGltaXQgIT0gbnVsbCkge1xuICAgIHF1ZXJ5T3B0aW9ucy5saW1pdCA9IHF1ZXJ5T3B0aW9ucy5saW1pdCAqIG1vZC5pZHMubGVuZ3RoO1xuICB9XG5cbiAgY29uc3QgcXVlcnkgPSBtb2QubW9kZWwuZmluZChtYXRjaCwgc2VsZWN0LCBxdWVyeU9wdGlvbnMpO1xuICAvLyBJZiB3ZSdyZSBkb2luZyB2aXJ0dWFsIHBvcHVsYXRlIGFuZCBwcm9qZWN0aW9uIGlzIGluY2x1c2l2ZSBhbmQgZm9yZWlnblxuICAvLyBmaWVsZCBpcyBub3Qgc2VsZWN0ZWQsIGF1dG9tYXRpY2FsbHkgc2VsZWN0IGl0IGJlY2F1c2UgbW9uZ29vc2UgbmVlZHMgaXQuXG4gIC8vIElmIHByb2plY3Rpb24gaXMgZXhjbHVzaXZlIGFuZCBjbGllbnQgZXhwbGljaXRseSB1bnNlbGVjdGVkIHRoZSBmb3JlaWduXG4gIC8vIGZpZWxkLCB0aGF0J3MgdGhlIGNsaWVudCdzIGZhdWx0LlxuICBmb3IgKGNvbnN0IGZvcmVpZ25GaWVsZCBvZiBtb2QuZm9yZWlnbkZpZWxkKSB7XG4gICAgaWYgKGZvcmVpZ25GaWVsZCAhPT0gJ19pZCcgJiZcbiAgICAgICAgcXVlcnkuc2VsZWN0ZWRJbmNsdXNpdmVseSgpICYmXG4gICAgICAgICFpc1BhdGhTZWxlY3RlZEluY2x1c2l2ZShxdWVyeS5fZmllbGRzLCBmb3JlaWduRmllbGQpKSB7XG4gICAgICBxdWVyeS5zZWxlY3QoZm9yZWlnbkZpZWxkKTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB1c2luZyBjb3VudCwgc3RpbGwgbmVlZCB0aGUgYGZvcmVpZ25GaWVsZGAgc28gd2UgY2FuIG1hdGNoIGNvdW50c1xuICAvLyB0byBkb2N1bWVudHMsIG90aGVyd2lzZSB3ZSB3b3VsZCBuZWVkIGEgc2VwYXJhdGUgYGNvdW50KClgIGZvciBldmVyeSBkb2MuXG4gIGlmIChtb2QuY291bnQpIHtcbiAgICBmb3IgKGNvbnN0IGZvcmVpZ25GaWVsZCBvZiBtb2QuZm9yZWlnbkZpZWxkKSB7XG4gICAgICBxdWVyeS5zZWxlY3QoZm9yZWlnbkZpZWxkKTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB3ZSBuZWVkIHRvIHN1Yi1wb3B1bGF0ZSwgY2FsbCBwb3B1bGF0ZSByZWN1cnNpdmVseVxuICBpZiAoc3ViUG9wdWxhdGUpIHtcbiAgICAvLyBJZiBzdWJwb3B1bGF0aW5nIG9uIGEgZGlzY3JpbWluYXRvciwgc2tpcCBjaGVjayBmb3Igbm9uLWV4aXN0ZW50XG4gICAgLy8gcGF0aHMuIEJlY2F1c2UgdGhlIGRpc2NyaW1pbmF0b3IgbWF5IG5vdCBoYXZlIHRoZSBwYXRoIGRlZmluZWQuXG4gICAgaWYgKG1vZC5tb2RlbC5iYXNlTW9kZWxOYW1lICE9IG51bGwpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHN1YlBvcHVsYXRlKSkge1xuICAgICAgICBzdWJQb3B1bGF0ZS5mb3JFYWNoKHBvcCA9PiB7IHBvcC5zdHJpY3RQb3B1bGF0ZSA9IGZhbHNlOyB9KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHN1YlBvcHVsYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICBzdWJQb3B1bGF0ZSA9IHsgcGF0aDogc3ViUG9wdWxhdGUsIHN0cmljdFBvcHVsYXRlOiBmYWxzZSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3ViUG9wdWxhdGUuc3RyaWN0UG9wdWxhdGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYmFzZVBhdGggPSBtb2Qub3B0aW9ucy5fZnVsbFBhdGggfHwgbW9kLm9wdGlvbnMucGF0aDtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHN1YlBvcHVsYXRlKSkge1xuICAgICAgZm9yIChjb25zdCBwb3Agb2Ygc3ViUG9wdWxhdGUpIHtcbiAgICAgICAgcG9wLl9mdWxsUGF0aCA9IGJhc2VQYXRoICsgJy4nICsgcG9wLnBhdGg7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc3ViUG9wdWxhdGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBzdWJQb3B1bGF0ZS5fZnVsbFBhdGggPSBiYXNlUGF0aCArICcuJyArIHN1YlBvcHVsYXRlLnBhdGg7XG4gICAgfVxuXG4gICAgcXVlcnkucG9wdWxhdGUoc3ViUG9wdWxhdGUpO1xuICB9XG5cbiAgcXVlcnkuZXhlYygpLnRoZW4oXG4gICAgZG9jcyA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHZhbCBvZiBkb2NzKSB7XG4gICAgICAgIGxlYW5Qb3B1bGF0ZU1hcC5zZXQodmFsLCBtb2QubW9kZWwpO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2sobnVsbCwgZG9jcyk7XG4gICAgfSxcbiAgICBlcnIgPT4ge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gICk7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2Fzc2lnbihtb2RlbCwgdmFscywgbW9kLCBhc3NpZ25tZW50T3B0cykge1xuICBjb25zdCBvcHRpb25zID0gbW9kLm9wdGlvbnM7XG4gIGNvbnN0IGlzVmlydHVhbCA9IG1vZC5pc1ZpcnR1YWw7XG4gIGNvbnN0IGp1c3RPbmUgPSBtb2QuanVzdE9uZTtcbiAgbGV0IF92YWw7XG4gIGNvbnN0IGxlYW4gPSBvcHRpb25zICYmXG4gICAgb3B0aW9ucy5vcHRpb25zICYmXG4gICAgb3B0aW9ucy5vcHRpb25zLmxlYW4gfHwgZmFsc2U7XG4gIGNvbnN0IGxlbiA9IHZhbHMubGVuZ3RoO1xuICBjb25zdCByYXdPcmRlciA9IHt9O1xuICBjb25zdCByYXdEb2NzID0ge307XG4gIGxldCBrZXk7XG4gIGxldCB2YWw7XG5cbiAgLy8gQ2xvbmUgYmVjYXVzZSBgYXNzaWduUmF3RG9jc1RvSWRTdHJ1Y3R1cmVgIHdpbGwgbXV0YXRlIHRoZSBhcnJheVxuICBjb25zdCBhbGxJZHMgPSBjbG9uZShtb2QuYWxsSWRzKTtcbiAgLy8gb3B0aW1pemF0aW9uOlxuICAvLyByZWNvcmQgdGhlIGRvY3VtZW50IHBvc2l0aW9ucyBhcyByZXR1cm5lZCBieVxuICAvLyB0aGUgcXVlcnkgcmVzdWx0LlxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFsID0gdmFsc1tpXTtcbiAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGZvcmVpZ25GaWVsZCBvZiBtb2QuZm9yZWlnbkZpZWxkKSB7XG4gICAgICBfdmFsID0gdXRpbHMuZ2V0VmFsdWUoZm9yZWlnbkZpZWxkLCB2YWwpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoX3ZhbCkpIHtcbiAgICAgICAgX3ZhbCA9IHV0aWxzLmFycmF5LnVuaXF1ZSh1dGlscy5hcnJheS5mbGF0dGVuKF92YWwpKTtcblxuICAgICAgICBmb3IgKGxldCBfX3ZhbCBvZiBfdmFsKSB7XG4gICAgICAgICAgaWYgKF9fdmFsIGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICAgICAgICAgIF9fdmFsID0gX192YWwuX2lkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrZXkgPSBTdHJpbmcoX192YWwpO1xuICAgICAgICAgIGlmIChyYXdEb2NzW2tleV0pIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJhd0RvY3Nba2V5XSkpIHtcbiAgICAgICAgICAgICAgcmF3RG9jc1trZXldLnB1c2godmFsKTtcbiAgICAgICAgICAgICAgcmF3T3JkZXJba2V5XS5wdXNoKGkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmF3RG9jc1trZXldID0gW3Jhd0RvY3Nba2V5XSwgdmFsXTtcbiAgICAgICAgICAgICAgcmF3T3JkZXJba2V5XSA9IFtyYXdPcmRlcltrZXldLCBpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzVmlydHVhbCAmJiAhanVzdE9uZSkge1xuICAgICAgICAgICAgICByYXdEb2NzW2tleV0gPSBbdmFsXTtcbiAgICAgICAgICAgICAgcmF3T3JkZXJba2V5XSA9IFtpXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJhd0RvY3Nba2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgcmF3T3JkZXJba2V5XSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoX3ZhbCBpbnN0YW5jZW9mIERvY3VtZW50KSB7XG4gICAgICAgICAgX3ZhbCA9IF92YWwuX2lkO1xuICAgICAgICB9XG4gICAgICAgIGtleSA9IFN0cmluZyhfdmFsKTtcbiAgICAgICAgaWYgKHJhd0RvY3Nba2V5XSkge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJhd0RvY3Nba2V5XSkpIHtcbiAgICAgICAgICAgIHJhd0RvY3Nba2V5XS5wdXNoKHZhbCk7XG4gICAgICAgICAgICByYXdPcmRlcltrZXldLnB1c2goaSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc1ZpcnR1YWwgfHxcbiAgICAgICAgICAgIHJhd0RvY3Nba2V5XS5jb25zdHJ1Y3RvciAhPT0gdmFsLmNvbnN0cnVjdG9yIHx8XG4gICAgICAgICAgICBTdHJpbmcocmF3RG9jc1trZXldLl9pZCkgIT09IFN0cmluZyh2YWwuX2lkKSkge1xuICAgICAgICAgICAgLy8gTWF5IG5lZWQgdG8gc3RvcmUgbXVsdGlwbGUgZG9jcyB3aXRoIHRoZSBzYW1lIGlkIGlmIHRoZXJlJ3MgbXVsdGlwbGUgbW9kZWxzXG4gICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGRpc2NyaW1pbmF0b3JzIG9yIGEgcmVmIGZ1bmN0aW9uLiBCdXQgYXZvaWQgY29udmVydGluZyB0byBhbiBhcnJheVxuICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBtdWx0aXBsZSBxdWVyaWVzIG9uIHRoZSBzYW1lIG1vZGVsIGJlY2F1c2Ugb2YgYHBlckRvY3VtZW50TGltaXRgIHJlOiBnaC05OTA2XG4gICAgICAgICAgICByYXdEb2NzW2tleV0gPSBbcmF3RG9jc1trZXldLCB2YWxdO1xuICAgICAgICAgICAgcmF3T3JkZXJba2V5XSA9IFtyYXdPcmRlcltrZXldLCBpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmF3RG9jc1trZXldID0gdmFsO1xuICAgICAgICAgIHJhd09yZGVyW2tleV0gPSBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBmbGFnIGVhY2ggYXMgcmVzdWx0IG9mIHBvcHVsYXRpb25cbiAgICAgIGlmICghbGVhbikge1xuICAgICAgICB2YWwuJF9fLndhc1BvcHVsYXRlZCA9IHZhbC4kX18ud2FzUG9wdWxhdGVkIHx8IHsgdmFsdWU6IF92YWwgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3NpZ25WYWxzKHtcbiAgICBvcmlnaW5hbE1vZGVsOiBtb2RlbCxcbiAgICAvLyBJZiB2aXJ0dWFsLCBtYWtlIHN1cmUgdG8gbm90IG11dGF0ZSBvcmlnaW5hbCBmaWVsZFxuICAgIHJhd0lkczogbW9kLmlzVmlydHVhbCA/IGFsbElkcyA6IG1vZC5hbGxJZHMsXG4gICAgYWxsSWRzOiBhbGxJZHMsXG4gICAgdW5wb3B1bGF0ZWRWYWx1ZXM6IG1vZC51bnBvcHVsYXRlZFZhbHVlcyxcbiAgICBmb3JlaWduRmllbGQ6IG1vZC5mb3JlaWduRmllbGQsXG4gICAgcmF3RG9jczogcmF3RG9jcyxcbiAgICByYXdPcmRlcjogcmF3T3JkZXIsXG4gICAgZG9jczogbW9kLmRvY3MsXG4gICAgcGF0aDogb3B0aW9ucy5wYXRoLFxuICAgIG9wdGlvbnM6IGFzc2lnbm1lbnRPcHRzLFxuICAgIGp1c3RPbmU6IG1vZC5qdXN0T25lLFxuICAgIGlzVmlydHVhbDogbW9kLmlzVmlydHVhbCxcbiAgICBhbGxPcHRpb25zOiBtb2QsXG4gICAgcG9wdWxhdGVkTW9kZWw6IG1vZC5tb2RlbCxcbiAgICBsZWFuOiBsZWFuLFxuICAgIHZpcnR1YWw6IG1vZC52aXJ0dWFsLFxuICAgIGNvdW50OiBtb2QuY291bnQsXG4gICAgbWF0Y2g6IG1vZC5tYXRjaFxuICB9KTtcbn1cblxuLyoqXG4gKiBDb21waWxlciB1dGlsaXR5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBuYW1lIG1vZGVsIG5hbWUgb3IgY2xhc3MgZXh0ZW5kaW5nIE1vZGVsXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAcGFyYW0ge1N0cmluZ30gY29sbGVjdGlvbk5hbWVcbiAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubmVjdGlvblxuICogQHBhcmFtIHtNb25nb29zZX0gYmFzZSBtb25nb29zZSBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTW9kZWwuY29tcGlsZSA9IGZ1bmN0aW9uIGNvbXBpbGUobmFtZSwgc2NoZW1hLCBjb2xsZWN0aW9uTmFtZSwgY29ubmVjdGlvbiwgYmFzZSkge1xuICBjb25zdCB2ZXJzaW9uaW5nRW5hYmxlZCA9IHNjaGVtYS5vcHRpb25zLnZlcnNpb25LZXkgIT09IGZhbHNlO1xuXG4gIGlmICh2ZXJzaW9uaW5nRW5hYmxlZCAmJiAhc2NoZW1hLnBhdGhzW3NjaGVtYS5vcHRpb25zLnZlcnNpb25LZXldKSB7XG4gICAgLy8gYWRkIHZlcnNpb25pbmcgdG8gdG9wIGxldmVsIGRvY3VtZW50cyBvbmx5XG4gICAgY29uc3QgbyA9IHt9O1xuICAgIG9bc2NoZW1hLm9wdGlvbnMudmVyc2lvbktleV0gPSBOdW1iZXI7XG4gICAgc2NoZW1hLmFkZChvKTtcbiAgfVxuICBsZXQgbW9kZWw7XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gJ2Z1bmN0aW9uJyAmJiBuYW1lLnByb3RvdHlwZSBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgbW9kZWwgPSBuYW1lO1xuICAgIG5hbWUgPSBtb2RlbC5uYW1lO1xuICAgIHNjaGVtYS5sb2FkQ2xhc3MobW9kZWwsIGZhbHNlKTtcbiAgICBtb2RlbC5wcm90b3R5cGUuJGlzTW9uZ29vc2VNb2RlbFByb3RvdHlwZSA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgLy8gZ2VuZXJhdGUgbmV3IGNsYXNzXG4gICAgbW9kZWwgPSBmdW5jdGlvbiBtb2RlbChkb2MsIGZpZWxkcywgc2tpcElkKSB7XG4gICAgICBtb2RlbC5ob29rcy5leGVjUHJlU3luYygnY3JlYXRlTW9kZWwnLCBkb2MpO1xuICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIG1vZGVsKSkge1xuICAgICAgICByZXR1cm4gbmV3IG1vZGVsKGRvYywgZmllbGRzLCBza2lwSWQpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGlzY3JpbWluYXRvcktleSA9IG1vZGVsLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXk7XG5cbiAgICAgIGlmIChtb2RlbC5kaXNjcmltaW5hdG9ycyA9PSBudWxsIHx8IGRvYyA9PSBudWxsIHx8IGRvY1tkaXNjcmltaW5hdG9yS2V5XSA9PSBudWxsKSB7XG4gICAgICAgIE1vZGVsLmNhbGwodGhpcywgZG9jLCBmaWVsZHMsIHNraXBJZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgZGlzY3JpbWluYXRvciBrZXkgaXMgc2V0LCB1c2UgdGhlIGRpc2NyaW1pbmF0b3IgaW5zdGVhZCAoZ2gtNzU4NilcbiAgICAgIGNvbnN0IERpc2NyaW1pbmF0b3IgPSBtb2RlbC5kaXNjcmltaW5hdG9yc1tkb2NbZGlzY3JpbWluYXRvcktleV1dIHx8XG4gICAgICAgIGdldERpc2NyaW1pbmF0b3JCeVZhbHVlKG1vZGVsLmRpc2NyaW1pbmF0b3JzLCBkb2NbZGlzY3JpbWluYXRvcktleV0pO1xuICAgICAgaWYgKERpc2NyaW1pbmF0b3IgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbmV3IERpc2NyaW1pbmF0b3IoZG9jLCBmaWVsZHMsIHNraXBJZCk7XG4gICAgICB9XG5cbiAgICAgIC8vIE90aGVyd2lzZSwganVzdCB1c2UgdGhlIHRvcC1sZXZlbCBtb2RlbFxuICAgICAgTW9kZWwuY2FsbCh0aGlzLCBkb2MsIGZpZWxkcywgc2tpcElkKTtcbiAgICB9O1xuICB9XG5cbiAgbW9kZWwuaG9va3MgPSBzY2hlbWEucy5ob29rcy5jbG9uZSgpO1xuICBtb2RlbC5iYXNlID0gYmFzZTtcbiAgbW9kZWwubW9kZWxOYW1lID0gbmFtZTtcblxuICBpZiAoIShtb2RlbC5wcm90b3R5cGUgaW5zdGFuY2VvZiBNb2RlbCkpIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YobW9kZWwsIE1vZGVsKTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YobW9kZWwucHJvdG90eXBlLCBNb2RlbC5wcm90b3R5cGUpO1xuICB9XG4gIG1vZGVsLm1vZGVsID0gZnVuY3Rpb24gbW9kZWwobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmRiLm1vZGVsKG5hbWUpO1xuICB9O1xuXG4gIG1vZGVsLmRiID0gY29ubmVjdGlvbjtcbiAgbW9kZWwucHJvdG90eXBlLmRiID0gY29ubmVjdGlvbjtcbiAgbW9kZWwucHJvdG90eXBlW21vZGVsRGJTeW1ib2xdID0gY29ubmVjdGlvbjtcbiAgbW9kZWwuZGlzY3JpbWluYXRvcnMgPSBtb2RlbC5wcm90b3R5cGUuZGlzY3JpbWluYXRvcnMgPSB1bmRlZmluZWQ7XG4gIG1vZGVsW21vZGVsU3ltYm9sXSA9IHRydWU7XG4gIG1vZGVsLmV2ZW50cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICBzY2hlbWEuX3ByZUNvbXBpbGUoKTtcblxuICBjb25zdCBfdXNlclByb3ZpZGVkT3B0aW9ucyA9IHNjaGVtYS5fdXNlclByb3ZpZGVkT3B0aW9ucyB8fCB7fTtcblxuICBjb25zdCBjb2xsZWN0aW9uT3B0aW9ucyA9IHtcbiAgICBzY2hlbWFVc2VyUHJvdmlkZWRPcHRpb25zOiBfdXNlclByb3ZpZGVkT3B0aW9ucyxcbiAgICBjYXBwZWQ6IHNjaGVtYS5vcHRpb25zLmNhcHBlZCxcbiAgICBQcm9taXNlOiBtb2RlbC5iYXNlLlByb21pc2UsXG4gICAgbW9kZWxOYW1lOiBuYW1lXG4gIH07XG4gIGlmIChzY2hlbWEub3B0aW9ucy5hdXRvQ3JlYXRlICE9PSB2b2lkIDApIHtcbiAgICBjb2xsZWN0aW9uT3B0aW9ucy5hdXRvQ3JlYXRlID0gc2NoZW1hLm9wdGlvbnMuYXV0b0NyZWF0ZTtcbiAgfVxuXG4gIGNvbnN0IGNvbGxlY3Rpb24gPSBjb25uZWN0aW9uLmNvbGxlY3Rpb24oXG4gICAgY29sbGVjdGlvbk5hbWUsXG4gICAgY29sbGVjdGlvbk9wdGlvbnNcbiAgKTtcblxuICBtb2RlbC5wcm90b3R5cGUuY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gIG1vZGVsLnByb3RvdHlwZS4kY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gIG1vZGVsLnByb3RvdHlwZVttb2RlbENvbGxlY3Rpb25TeW1ib2xdID0gY29sbGVjdGlvbjtcblxuICBtb2RlbC5wcm90b3R5cGUuJF9fc2V0U2NoZW1hKHNjaGVtYSk7XG5cbiAgLy8gYXBwbHkgbWV0aG9kcyBhbmQgc3RhdGljc1xuICBhcHBseU1ldGhvZHMobW9kZWwsIHNjaGVtYSk7XG4gIGFwcGx5U3RhdGljcyhtb2RlbCwgc2NoZW1hKTtcbiAgYXBwbHlIb29rcyhtb2RlbCwgc2NoZW1hKTtcbiAgYXBwbHlTdGF0aWNIb29rcyhtb2RlbCwgc2NoZW1hLnMuaG9va3MsIHNjaGVtYS5zdGF0aWNzKTtcblxuICBtb2RlbC5zY2hlbWEgPSBtb2RlbC5wcm90b3R5cGUuJF9fc2NoZW1hO1xuICBtb2RlbC5jb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcbiAgbW9kZWwuJF9fY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG5cbiAgLy8gQ3JlYXRlIGN1c3RvbSBxdWVyeSBjb25zdHJ1Y3RvclxuICBtb2RlbC5RdWVyeSA9IGZ1bmN0aW9uKCkge1xuICAgIFF1ZXJ5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihtb2RlbC5RdWVyeS5wcm90b3R5cGUsIFF1ZXJ5LnByb3RvdHlwZSk7XG4gIG1vZGVsLlF1ZXJ5LmJhc2UgPSBRdWVyeS5iYXNlO1xuICBtb2RlbC5RdWVyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBRdWVyeTtcbiAgbW9kZWwuX2FwcGx5UXVlcnlNaWRkbGV3YXJlKCk7XG4gIGFwcGx5UXVlcnlNZXRob2RzKG1vZGVsLCBzY2hlbWEucXVlcnkpO1xuXG4gIHJldHVybiBtb2RlbDtcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoaXMgbW9kZWwgdG8gdXNlIHRoZSBuZXcgY29ubmVjdGlvbiwgaW5jbHVkaW5nIHVwZGF0aW5nIGFsbCBpbnRlcm5hbFxuICogcmVmZXJlbmNlcyBhbmQgY3JlYXRpbmcgYSBuZXcgYENvbGxlY3Rpb25gIGluc3RhbmNlIHVzaW5nIHRoZSBuZXcgY29ubmVjdGlvbi5cbiAqIE5vdCBmb3IgZXh0ZXJuYWwgdXNlLCBvbmx5IHVzZWQgYnkgYHNldERyaXZlcigpYCB0byBlbnN1cmUgdGhhdCB5b3UgY2FuIHN0aWxsXG4gKiBjYWxsIGBzZXREcml2ZXIoKWAgYWZ0ZXIgY3JlYXRpbmcgYSBtb2RlbCB1c2luZyBgbW9uZ29vc2UubW9kZWwoKWAuXG4gKlxuICogQHBhcmFtIHtDb25uZWN0aW9ufSBuZXdDb25uZWN0aW9uIHRoZSBuZXcgY29ubmVjdGlvbiB0byB1c2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1vZGVsLiRfX3VwZGF0ZUNvbm5lY3Rpb24gPSBmdW5jdGlvbiAkX191cGRhdGVDb25uZWN0aW9uKG5ld0Nvbm5lY3Rpb24pIHtcbiAgdGhpcy5kYiA9IG5ld0Nvbm5lY3Rpb247XG4gIHRoaXMucHJvdG90eXBlLmRiID0gbmV3Q29ubmVjdGlvbjtcbiAgdGhpcy5wcm90b3R5cGVbbW9kZWxEYlN5bWJvbF0gPSBuZXdDb25uZWN0aW9uO1xuXG4gIGNvbnN0IGNvbGxlY3Rpb24gPSBuZXdDb25uZWN0aW9uLmNvbGxlY3Rpb24oXG4gICAgdGhpcy5jb2xsZWN0aW9uLmNvbGxlY3Rpb25OYW1lLFxuICAgIHRoaXMuY29sbGVjdGlvbi5vcHRzXG4gICk7XG5cbiAgdGhpcy5wcm90b3R5cGUuY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gIHRoaXMucHJvdG90eXBlLiRjb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcbiAgdGhpcy5wcm90b3R5cGVbbW9kZWxDb2xsZWN0aW9uU3ltYm9sXSA9IGNvbGxlY3Rpb247XG5cbiAgdGhpcy5jb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcbiAgdGhpcy4kX19jb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgY3VzdG9tIHF1ZXJ5IG1ldGhvZHMgZm9yIHRoaXMgbW9kZWxcbiAqXG4gKiBAcGFyYW0ge01vZGVsfSBtb2RlbFxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gYXBwbHlRdWVyeU1ldGhvZHMobW9kZWwsIG1ldGhvZHMpIHtcbiAgZm9yIChjb25zdCBpIGluIG1ldGhvZHMpIHtcbiAgICBtb2RlbC5RdWVyeS5wcm90b3R5cGVbaV0gPSBtZXRob2RzW2ldO1xuICB9XG59XG5cbi8qKlxuICogU3ViY2xhc3MgdGhpcyBtb2RlbCB3aXRoIGBjb25uYCwgYHNjaGVtYWAsIGFuZCBgY29sbGVjdGlvbmAgc2V0dGluZ3MuXG4gKlxuICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uXG4gKiBAcGFyYW0ge1NjaGVtYX0gW3NjaGVtYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbY29sbGVjdGlvbl1cbiAqIEByZXR1cm4ge01vZGVsfVxuICogQGFwaSBwcml2YXRlXG4gKiBAbWVtYmVyT2YgTW9kZWxcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgX19zdWJjbGFzc1xuICovXG5cbk1vZGVsLl9fc3ViY2xhc3MgPSBmdW5jdGlvbiBzdWJjbGFzcyhjb25uLCBzY2hlbWEsIGNvbGxlY3Rpb24pIHtcbiAgLy8gc3ViY2xhc3MgbW9kZWwgdXNpbmcgdGhpcyBjb25uZWN0aW9uIGFuZCBjb2xsZWN0aW9uIG5hbWVcbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuXG4gIGNvbnN0IE1vZGVsID0gZnVuY3Rpb24gTW9kZWwoZG9jLCBmaWVsZHMsIHNraXBJZCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNb2RlbCkpIHtcbiAgICAgIHJldHVybiBuZXcgTW9kZWwoZG9jLCBmaWVsZHMsIHNraXBJZCk7XG4gICAgfVxuICAgIF90aGlzLmNhbGwodGhpcywgZG9jLCBmaWVsZHMsIHNraXBJZCk7XG4gIH07XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKE1vZGVsLCBfdGhpcyk7XG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihNb2RlbC5wcm90b3R5cGUsIF90aGlzLnByb3RvdHlwZSk7XG4gIE1vZGVsLmRiID0gY29ubjtcbiAgTW9kZWwucHJvdG90eXBlLmRiID0gY29ubjtcbiAgTW9kZWwucHJvdG90eXBlW21vZGVsRGJTeW1ib2xdID0gY29ubjtcblxuICBfdGhpc1tzdWJjbGFzc2VkU3ltYm9sXSA9IF90aGlzW3N1YmNsYXNzZWRTeW1ib2xdIHx8IFtdO1xuICBfdGhpc1tzdWJjbGFzc2VkU3ltYm9sXS5wdXNoKE1vZGVsKTtcbiAgaWYgKF90aGlzLmRpc2NyaW1pbmF0b3JzICE9IG51bGwpIHtcbiAgICBNb2RlbC5kaXNjcmltaW5hdG9ycyA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKF90aGlzLmRpc2NyaW1pbmF0b3JzKSkge1xuICAgICAgTW9kZWwuZGlzY3JpbWluYXRvcnNba2V5XSA9IF90aGlzLmRpc2NyaW1pbmF0b3JzW2tleV0uXG4gICAgICAgIF9fc3ViY2xhc3MoX3RoaXMuZGIsIF90aGlzLmRpc2NyaW1pbmF0b3JzW2tleV0uc2NoZW1hLCBjb2xsZWN0aW9uKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBzID0gc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgIT09ICdzdHJpbmcnXG4gICAgPyBzY2hlbWFcbiAgICA6IF90aGlzLnByb3RvdHlwZS4kX19zY2hlbWE7XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHMub3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgX3VzZXJQcm92aWRlZE9wdGlvbnMgPSBzLl91c2VyUHJvdmlkZWRPcHRpb25zIHx8IHt9O1xuXG4gIGlmICghY29sbGVjdGlvbikge1xuICAgIGNvbGxlY3Rpb24gPSBfdGhpcy5wcm90b3R5cGUuJF9fc2NoZW1hLmdldCgnY29sbGVjdGlvbicpIHx8XG4gICAgICB1dGlscy50b0NvbGxlY3Rpb25OYW1lKF90aGlzLm1vZGVsTmFtZSwgdGhpcy5iYXNlLnBsdXJhbGl6ZSgpKTtcbiAgfVxuXG4gIGNvbnN0IGNvbGxlY3Rpb25PcHRpb25zID0ge1xuICAgIHNjaGVtYVVzZXJQcm92aWRlZE9wdGlvbnM6IF91c2VyUHJvdmlkZWRPcHRpb25zLFxuICAgIGNhcHBlZDogcyAmJiBvcHRpb25zLmNhcHBlZFxuICB9O1xuXG4gIE1vZGVsLnByb3RvdHlwZS5jb2xsZWN0aW9uID0gY29ubi5jb2xsZWN0aW9uKGNvbGxlY3Rpb24sIGNvbGxlY3Rpb25PcHRpb25zKTtcbiAgTW9kZWwucHJvdG90eXBlLiRjb2xsZWN0aW9uID0gTW9kZWwucHJvdG90eXBlLmNvbGxlY3Rpb247XG4gIE1vZGVsLnByb3RvdHlwZVttb2RlbENvbGxlY3Rpb25TeW1ib2xdID0gTW9kZWwucHJvdG90eXBlLmNvbGxlY3Rpb247XG4gIE1vZGVsLmNvbGxlY3Rpb24gPSBNb2RlbC5wcm90b3R5cGUuY29sbGVjdGlvbjtcbiAgTW9kZWwuJF9fY29sbGVjdGlvbiA9IE1vZGVsLmNvbGxlY3Rpb247XG4gIC8vIEVycm9ycyBoYW5kbGVkIGludGVybmFsbHksIHNvIGlnbm9yZVxuICBNb2RlbC5pbml0KCkuY2F0Y2goKCkgPT4ge30pO1xuICByZXR1cm4gTW9kZWw7XG59O1xuXG4vKipcbiAqIEFwcGx5IGNoYW5nZXMgbWFkZSB0byB0aGlzIG1vZGVsJ3Mgc2NoZW1hIGFmdGVyIHRoaXMgbW9kZWwgd2FzIGNvbXBpbGVkLlxuICogQnkgZGVmYXVsdCwgYWRkaW5nIHZpcnR1YWxzIGFuZCBvdGhlciBwcm9wZXJ0aWVzIHRvIGEgc2NoZW1hIGFmdGVyIHRoZSBtb2RlbCBpcyBjb21waWxlZCBkb2VzIG5vdGhpbmcuXG4gKiBDYWxsIHRoaXMgZnVuY3Rpb24gdG8gYXBwbHkgdmlydHVhbHMgYW5kIHByb3BlcnRpZXMgdGhhdCB3ZXJlIGFkZGVkIGxhdGVyLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IG1vbmdvb3NlLlNjaGVtYSh7IGZpZWxkOiBTdHJpbmcgfSk7XG4gKiAgICAgY29uc3QgVGVzdE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBzY2hlbWEpO1xuICogICAgIFRlc3RNb2RlbC5zY2hlbWEudmlydHVhbCgnbXlWaXJ0dWFsJykuZ2V0KGZ1bmN0aW9uKCkge1xuICogICAgICAgcmV0dXJuIHRoaXMuZmllbGQgKyAnIGZyb20gbXlWaXJ0dWFsJztcbiAqICAgICB9KTtcbiAqICAgICBjb25zdCBkb2MgPSBuZXcgVGVzdE1vZGVsKHsgZmllbGQ6ICdIZWxsbycgfSk7XG4gKiAgICAgZG9jLm15VmlydHVhbDsgLy8gdW5kZWZpbmVkXG4gKlxuICogICAgIFRlc3RNb2RlbC5yZWNvbXBpbGVTY2hlbWEoKTtcbiAqICAgICBkb2MubXlWaXJ0dWFsOyAvLyAnSGVsbG8gZnJvbSBteVZpcnR1YWwnXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBNb2RlbFxuICogQHN0YXRpY1xuICogQG1ldGhvZCByZWNvbXBpbGVTY2hlbWFcbiAqL1xuXG5Nb2RlbC5yZWNvbXBpbGVTY2hlbWEgPSBmdW5jdGlvbiByZWNvbXBpbGVTY2hlbWEoKSB7XG4gIHRoaXMucHJvdG90eXBlLiRfX3NldFNjaGVtYSh0aGlzLnNjaGVtYSk7XG5cbiAgaWYgKHRoaXMuc2NoZW1hLl9hcHBseURpc2NyaW1pbmF0b3JzICE9IG51bGwpIHtcbiAgICBmb3IgKGNvbnN0IGRpc2Mgb2YgdGhpcy5zY2hlbWEuX2FwcGx5RGlzY3JpbWluYXRvcnMua2V5cygpKSB7XG4gICAgICB0aGlzLmRpc2NyaW1pbmF0b3IoZGlzYywgdGhpcy5zY2hlbWEuX2FwcGx5RGlzY3JpbWluYXRvcnMuZ2V0KGRpc2MpKTtcbiAgICB9XG4gIH1cblxuICBhcHBseUVtYmVkZGVkRGlzY3JpbWluYXRvcnModGhpcy5zY2hlbWEsIG5ldyBXZWFrU2V0KCksIHRydWUpO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgZm9yIGNvbnNvbGUubG9nLiBHaXZlbiBhIG1vZGVsIG5hbWVkICdNeU1vZGVsJywgcmV0dXJucyB0aGUgc3RyaW5nXG4gKiBgJ01vZGVsIHsgTXlNb2RlbCB9J2AuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBNeU1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSkpO1xuICogICAgIE15TW9kZWwuaW5zcGVjdCgpOyAvLyAnTW9kZWwgeyBUZXN0IH0nXG4gKiAgICAgY29uc29sZS5sb2coTXlNb2RlbCk7IC8vIFByaW50cyAnTW9kZWwgeyBUZXN0IH0nXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb2RlbC5pbnNwZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBgTW9kZWwgeyAke3RoaXMubW9kZWxOYW1lfSB9YDtcbn07XG5cbmlmICh1dGlsLmluc3BlY3QuY3VzdG9tKSB7XG4gIC8vIEF2b2lkIE5vZGUgZGVwcmVjYXRpb24gd2FybmluZyBERVAwMDc5XG4gIE1vZGVsW3V0aWwuaW5zcGVjdC5jdXN0b21dID0gTW9kZWwuaW5zcGVjdDtcbn1cblxuLyohXG4gKiBBcHBsaWVzIHF1ZXJ5IG1pZGRsZXdhcmUgZnJvbSB0aGlzIG1vZGVsJ3Mgc2NoZW1hIHRvIHRoaXMgbW9kZWwnc1xuICogUXVlcnkgY29uc3RydWN0b3IuXG4gKi9cblxuTW9kZWwuX2FwcGx5UXVlcnlNaWRkbGV3YXJlID0gZnVuY3Rpb24gX2FwcGx5UXVlcnlNaWRkbGV3YXJlKCkge1xuICBjb25zdCBRdWVyeSA9IHRoaXMuUXVlcnk7XG4gIGNvbnN0IHF1ZXJ5TWlkZGxld2FyZSA9IHRoaXMuc2NoZW1hLnMuaG9va3MuZmlsdGVyKGhvb2sgPT4ge1xuICAgIGNvbnN0IGNvbnRleHRzID0gX2dldENvbnRleHRzKGhvb2spO1xuICAgIGlmIChob29rLm5hbWUgPT09ICd2YWxpZGF0ZScpIHtcbiAgICAgIHJldHVybiAhIWNvbnRleHRzLnF1ZXJ5O1xuICAgIH1cbiAgICBpZiAoaG9vay5uYW1lID09PSAnZGVsZXRlT25lJyB8fCBob29rLm5hbWUgPT09ICd1cGRhdGVPbmUnKSB7XG4gICAgICByZXR1cm4gISFjb250ZXh0cy5xdWVyeSB8fCBPYmplY3Qua2V5cyhjb250ZXh0cykubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBpZiAoaG9vay5xdWVyeSAhPSBudWxsIHx8IGhvb2suZG9jdW1lbnQgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuICEhaG9vay5xdWVyeTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuXG4gIFF1ZXJ5LnByb3RvdHlwZS5fcXVlcnlNaWRkbGV3YXJlID0gcXVlcnlNaWRkbGV3YXJlO1xufTtcblxuZnVuY3Rpb24gX2dldENvbnRleHRzKGhvb2spIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGlmIChob29rLmhhc093blByb3BlcnR5KCdxdWVyeScpKSB7XG4gICAgcmV0LnF1ZXJ5ID0gaG9vay5xdWVyeTtcbiAgfVxuICBpZiAoaG9vay5oYXNPd25Qcm9wZXJ0eSgnZG9jdW1lbnQnKSkge1xuICAgIHJldC5kb2N1bWVudCA9IGhvb2suZG9jdW1lbnQ7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBNb2RlbDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/model.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/mongoose.js":
/*!********************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/mongoose.js ***!
  \********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst Document = __webpack_require__(/*! ./document */ \"../backend/node_modules/mongoose/lib/document.js\");\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Kareem = __webpack_require__(/*! kareem */ \"../backend/node_modules/kareem/index.js\");\nconst Schema = __webpack_require__(/*! ./schema */ \"../backend/node_modules/mongoose/lib/schema.js\");\nconst SchemaType = __webpack_require__(/*! ./schemaType */ \"../backend/node_modules/mongoose/lib/schemaType.js\");\nconst SchemaTypes = __webpack_require__(/*! ./schema/index */ \"../backend/node_modules/mongoose/lib/schema/index.js\");\nconst VirtualType = __webpack_require__(/*! ./virtualType */ \"../backend/node_modules/mongoose/lib/virtualType.js\");\nconst STATES = __webpack_require__(/*! ./connectionState */ \"../backend/node_modules/mongoose/lib/connectionState.js\");\nconst VALID_OPTIONS = __webpack_require__(/*! ./validOptions */ \"../backend/node_modules/mongoose/lib/validOptions.js\");\nconst Types = __webpack_require__(/*! ./types */ \"../backend/node_modules/mongoose/lib/types/index.js\");\nconst Query = __webpack_require__(/*! ./query */ \"../backend/node_modules/mongoose/lib/query.js\");\nconst Model = __webpack_require__(/*! ./model */ \"../backend/node_modules/mongoose/lib/model.js\");\nconst applyPlugins = __webpack_require__(/*! ./helpers/schema/applyPlugins */ \"../backend/node_modules/mongoose/lib/helpers/schema/applyPlugins.js\");\nconst builtinPlugins = __webpack_require__(/*! ./plugins */ \"../backend/node_modules/mongoose/lib/plugins/index.js\");\nconst driver = __webpack_require__(/*! ./driver */ \"../backend/node_modules/mongoose/lib/driver.js\");\nconst legacyPluralize = __webpack_require__(/*! ./helpers/pluralize */ \"../backend/node_modules/mongoose/lib/helpers/pluralize.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\nconst pkg = __webpack_require__(/*! ../package.json */ \"../backend/node_modules/mongoose/package.json\");\nconst cast = __webpack_require__(/*! ./cast */ \"../backend/node_modules/mongoose/lib/cast.js\");\n\nconst Aggregate = __webpack_require__(/*! ./aggregate */ \"../backend/node_modules/mongoose/lib/aggregate.js\");\nconst trusted = (__webpack_require__(/*! ./helpers/query/trusted */ \"../backend/node_modules/mongoose/lib/helpers/query/trusted.js\").trusted);\nconst sanitizeFilter = __webpack_require__(/*! ./helpers/query/sanitizeFilter */ \"../backend/node_modules/mongoose/lib/helpers/query/sanitizeFilter.js\");\nconst isBsonType = __webpack_require__(/*! ./helpers/isBsonType */ \"../backend/node_modules/mongoose/lib/helpers/isBsonType.js\");\nconst MongooseError = __webpack_require__(/*! ./error/mongooseError */ \"../backend/node_modules/mongoose/lib/error/mongooseError.js\");\nconst SetOptionError = __webpack_require__(/*! ./error/setOptionError */ \"../backend/node_modules/mongoose/lib/error/setOptionError.js\");\nconst applyEmbeddedDiscriminators = __webpack_require__(/*! ./helpers/discriminator/applyEmbeddedDiscriminators */ \"../backend/node_modules/mongoose/lib/helpers/discriminator/applyEmbeddedDiscriminators.js\");\n\nconst defaultMongooseSymbol = Symbol.for('mongoose:default');\n\n__webpack_require__(/*! ./helpers/printJestWarning */ \"../backend/node_modules/mongoose/lib/helpers/printJestWarning.js\");\n\nconst objectIdHexRegexp = /^[0-9A-Fa-f]{24}$/;\n\n/**\n * Mongoose constructor.\n *\n * The exports object of the `mongoose` module is an instance of this class.\n * Most apps will only use this one instance.\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     mongoose instanceof mongoose.Mongoose; // true\n *\n *     // Create a new Mongoose instance with its own `connect()`, `set()`, `model()`, etc.\n *     const m = new mongoose.Mongoose();\n *\n * @api public\n * @param {Object} options see [`Mongoose#set()` docs](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.set())\n */\nfunction Mongoose(options) {\n  this.connections = [];\n  this.nextConnectionId = 0;\n  this.models = {};\n  this.events = new EventEmitter();\n  this.__driver = driver.get();\n  // default global options\n  this.options = Object.assign({\n    pluralization: true,\n    autoIndex: true,\n    autoCreate: true,\n    autoSearchIndex: false\n  }, options);\n  const createInitialConnection = utils.getOption('createInitialConnection', this.options);\n  if (createInitialConnection == null || createInitialConnection) {\n    const conn = this.createConnection(); // default connection\n    conn.models = this.models;\n  }\n\n  if (this.options.pluralization) {\n    this._pluralize = legacyPluralize;\n  }\n\n  // If a user creates their own Mongoose instance, give them a separate copy\n  // of the `Schema` constructor so they get separate custom types. (gh-6933)\n  if (!options || !options[defaultMongooseSymbol]) {\n    const _this = this;\n    this.Schema = function() {\n      this.base = _this;\n      return Schema.apply(this, arguments);\n    };\n    this.Schema.prototype = Object.create(Schema.prototype);\n\n    Object.assign(this.Schema, Schema);\n    this.Schema.base = this;\n    this.Schema.Types = Object.assign({}, Schema.Types);\n  } else {\n    // Hack to work around babel's strange behavior with\n    // `import mongoose, { Schema } from 'mongoose'`. Because `Schema` is not\n    // an own property of a Mongoose global, Schema will be undefined. See gh-5648\n    for (const key of ['Schema', 'model']) {\n      this[key] = Mongoose.prototype[key];\n    }\n  }\n  this.Schema.prototype.base = this;\n\n  Object.defineProperty(this, 'plugins', {\n    configurable: false,\n    enumerable: true,\n    writable: false,\n    value: Object.values(builtinPlugins).map(plugin => ([plugin, { deduplicate: true }]))\n  });\n}\n\nMongoose.prototype.cast = cast;\n/**\n * Expose connection states for user-land\n *\n * @memberOf Mongoose\n * @property STATES\n * @api public\n */\nMongoose.prototype.STATES = STATES;\n\n/**\n * Expose connection states for user-land\n *\n * @memberOf Mongoose\n * @property ConnectionStates\n * @api public\n */\nMongoose.prototype.ConnectionStates = STATES;\n\n/**\n * Object with `get()` and `set()` containing the underlying driver this Mongoose instance\n * uses to communicate with the database. A driver is a Mongoose-specific interface that defines functions\n * like `find()`.\n *\n * @deprecated\n * @memberOf Mongoose\n * @property driver\n * @api public\n */\n\nMongoose.prototype.driver = driver;\n\n/**\n * Overwrites the current driver used by this Mongoose instance. A driver is a\n * Mongoose-specific interface that defines functions like `find()`.\n *\n * @memberOf Mongoose\n * @method setDriver\n * @api public\n */\n\nMongoose.prototype.setDriver = function setDriver(driver) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  if (_mongoose.__driver === driver) {\n    return _mongoose;\n  }\n\n  const openConnection = _mongoose.connections && _mongoose.connections.find(conn => conn.readyState !== STATES.disconnected);\n  if (openConnection) {\n    const msg = 'Cannot modify Mongoose driver if a connection is already open. ' +\n      'Call `mongoose.disconnect()` before modifying the driver';\n    throw new MongooseError(msg);\n  }\n  _mongoose.__driver = driver;\n\n  const Connection = driver.Connection;\n  const oldDefaultConnection = _mongoose.connections[0];\n  _mongoose.connections = [new Connection(_mongoose)];\n  _mongoose.connections[0].models = _mongoose.models;\n\n  // Update all models that pointed to the old default connection to\n  // the new default connection, including collections\n  for (const model of Object.values(_mongoose.models)) {\n    if (model.db !== oldDefaultConnection) {\n      continue;\n    }\n    model.$__updateConnection(_mongoose.connections[0]);\n  }\n\n  return _mongoose;\n};\n\n/**\n * Sets mongoose options\n *\n * `key` can be used a object to set multiple options at once.\n * If a error gets thrown for one option, other options will still be evaluated.\n *\n * #### Example:\n *\n *     mongoose.set('test', value) // sets the 'test' option to `value`\n *\n *     mongoose.set('debug', true) // enable logging collection methods + arguments to the console/file\n *\n *     mongoose.set('debug', function(collectionName, methodName, ...methodArgs) {}); // use custom function to log collection methods + arguments\n *\n *     mongoose.set({ debug: true, autoIndex: false }); // set multiple options at once\n *\n * Currently supported options are:\n * - `allowDiskUse`: Set to `true` to set `allowDiskUse` to true to all aggregation operations by default.\n * - `applyPluginsToChildSchemas`: `true` by default. Set to false to skip applying global plugins to child schemas\n * - `applyPluginsToDiscriminators`: `false` by default. Set to true to apply global plugins to discriminator schemas. This typically isn't necessary because plugins are applied to the base schema and discriminators copy all middleware, methods, statics, and properties from the base schema.\n * - `autoCreate`: Set to `true` to make Mongoose call [`Model.createCollection()`](https://mongoosejs.com/docs/api/model.html#Model.createCollection()) automatically when you create a model with `mongoose.model()` or `conn.model()`. This is useful for testing transactions, change streams, and other features that require the collection to exist.\n * - `autoIndex`: `true` by default. Set to false to disable automatic index creation for all models associated with this Mongoose instance.\n * - `bufferCommands`: enable/disable mongoose's buffering mechanism for all connections and models\n * - `bufferTimeoutMS`: If bufferCommands is on, this option sets the maximum amount of time Mongoose buffering will wait before throwing an error. If not specified, Mongoose will use 10000 (10 seconds).\n * - `cloneSchemas`: `false` by default. Set to `true` to `clone()` all schemas before compiling into a model.\n * - `debug`: If `true`, prints the operations mongoose sends to MongoDB to the console. If a writable stream is passed, it will log to that stream, without colorization. If a callback function is passed, it will receive the collection name, the method name, then all arguments passed to the method. For example, if you wanted to replicate the default logging, you could output from the callback `Mongoose: ${collectionName}.${methodName}(${methodArgs.join(', ')})`.\n * - `id`: If `true`, adds a `id` virtual to all schemas unless overwritten on a per-schema basis.\n * - `timestamps.createdAt.immutable`: `true` by default. If `false`, it will change the `createdAt` field to be [`immutable: false`](https://mongoosejs.com/docs/api/schematype.html#SchemaType.prototype.immutable) which means you can update the `createdAt`\n * - `maxTimeMS`: If set, attaches [maxTimeMS](https://www.mongodb.com/docs/manual/reference/operator/meta/maxTimeMS/) to every query\n * - `objectIdGetter`: `true` by default. Mongoose adds a getter to MongoDB ObjectId's called `_id` that returns `this` for convenience with populate. Set this to false to remove the getter.\n * - `overwriteModels`: Set to `true` to default to overwriting models with the same name when calling `mongoose.model()`, as opposed to throwing an `OverwriteModelError`.\n * - `returnOriginal`: If `false`, changes the default `returnOriginal` option to `findOneAndUpdate()`, `findByIdAndUpdate`, and `findOneAndReplace()` to false. This is equivalent to setting the `new` option to `true` for `findOneAndX()` calls by default. Read our [`findOneAndUpdate()` tutorial](https://mongoosejs.com/docs/tutorials/findoneandupdate.html) for more information.\n * - `runValidators`: `false` by default. Set to true to enable [update validators](https://mongoosejs.com/docs/validation.html#update-validators) for all validators by default.\n * - `sanitizeFilter`: `false` by default. Set to true to enable the [sanitization of the query filters](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.sanitizeFilter()) against query selector injection attacks by wrapping any nested objects that have a property whose name starts with `$` in a `$eq`.\n * - `selectPopulatedPaths`: `true` by default. Set to false to opt out of Mongoose adding all fields that you `populate()` to your `select()`. The schema-level option `selectPopulatedPaths` overwrites this one.\n * - `strict`: `true` by default, may be `false`, `true`, or `'throw'`. Sets the default strict mode for schemas.\n * - `strictQuery`: `false` by default. May be `false`, `true`, or `'throw'`. Sets the default [strictQuery](https://mongoosejs.com/docs/guide.html#strictQuery) mode for schemas.\n * - `toJSON`: `{ transform: true, flattenDecimals: true }` by default. Overwrites default objects to [`toJSON()`](https://mongoosejs.com/docs/api/document.html#Document.prototype.toJSON()), for determining how Mongoose documents get serialized by `JSON.stringify()`\n * - `toObject`: `{ transform: true, flattenDecimals: true }` by default. Overwrites default objects to [`toObject()`](https://mongoosejs.com/docs/api/document.html#Document.prototype.toObject())\n *\n * @param {String|Object} key The name of the option or a object of multiple key-value pairs\n * @param {String|Function|Boolean} value The value of the option, unused if \"key\" is a object\n * @returns {Mongoose} The used Mongoose instnace\n * @api public\n */\n\nMongoose.prototype.set = function(key, value) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  if (arguments.length === 1 && typeof key !== 'object') {\n    if (VALID_OPTIONS.indexOf(key) === -1) {\n      const error = new SetOptionError();\n      error.addError(key, new SetOptionError.SetOptionInnerError(key));\n      throw error;\n    }\n\n    return _mongoose.options[key];\n  }\n\n  let options = {};\n\n  if (arguments.length === 2) {\n    options = { [key]: value };\n  }\n\n  if (arguments.length === 1 && typeof key === 'object') {\n    options = key;\n  }\n\n  // array for errors to collect all errors for all key-value pairs, like \".validate\"\n  let error = undefined;\n\n  for (const [optionKey, optionValue] of Object.entries(options)) {\n    if (VALID_OPTIONS.indexOf(optionKey) === -1) {\n      if (!error) {\n        error = new SetOptionError();\n      }\n      error.addError(optionKey, new SetOptionError.SetOptionInnerError(optionKey));\n      continue;\n    }\n\n    _mongoose.options[optionKey] = optionValue;\n\n    if (optionKey === 'objectIdGetter') {\n      if (optionValue) {\n        Object.defineProperty(mongoose.Types.ObjectId.prototype, '_id', {\n          enumerable: false,\n          configurable: true,\n          get: function() {\n            return this;\n          }\n        });\n      } else {\n        delete mongoose.Types.ObjectId.prototype._id;\n      }\n    }\n  }\n\n  if (error) {\n    throw error;\n  }\n\n  return _mongoose;\n};\n\n/**\n * Gets mongoose options\n *\n * #### Example:\n *\n *     mongoose.get('test') // returns the 'test' value\n *\n * @param {String} key\n * @method get\n * @api public\n */\n\nMongoose.prototype.get = Mongoose.prototype.set;\n\n/**\n * Creates a Connection instance.\n *\n * Each `connection` instance maps to a single database. This method is helpful when managing multiple db connections.\n *\n *\n * _Options passed take precedence over options included in connection strings._\n *\n * #### Example:\n *\n *     // with mongodb:// URI\n *     db = mongoose.createConnection('mongodb://user:pass@127.0.0.1:port/database');\n *\n *     // and options\n *     const opts = { db: { native_parser: true }}\n *     db = mongoose.createConnection('mongodb://user:pass@127.0.0.1:port/database', opts);\n *\n *     // replica sets\n *     db = mongoose.createConnection('mongodb://user:pass@127.0.0.1:port,anotherhost:port,yetanother:port/database');\n *\n *     // and options\n *     const opts = { replset: { strategy: 'ping', rs_name: 'testSet' }}\n *     db = mongoose.createConnection('mongodb://user:pass@127.0.0.1:port,anotherhost:port,yetanother:port/database', opts);\n *\n *     // initialize now, connect later\n *     db = mongoose.createConnection();\n *     db.openUri('127.0.0.1', 'database', port, [opts]);\n *\n * @param {String} uri mongodb URI to connect to\n * @param {Object} [options] passed down to the [MongoDB driver's `connect()` function](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html), except for 4 mongoose-specific options explained below.\n * @param {Boolean} [options.bufferCommands=true] Mongoose specific option. Set to false to [disable buffering](https://mongoosejs.com/docs/faq.html#callback_never_executes) on all models associated with this connection.\n * @param {String} [options.dbName] The name of the database you want to use. If not provided, Mongoose uses the database name from connection string.\n * @param {String} [options.user] username for authentication, equivalent to `options.auth.user`. Maintained for backwards compatibility.\n * @param {String} [options.pass] password for authentication, equivalent to `options.auth.password`. Maintained for backwards compatibility.\n * @param {Boolean} [options.autoIndex=true] Mongoose-specific option. Set to false to disable automatic index creation for all models associated with this connection.\n * @param {Class} [options.promiseLibrary] Sets the [underlying driver's promise library](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html#promiseLibrary).\n * @param {Number} [options.maxPoolSize=5] The maximum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).\n * @param {Number} [options.minPoolSize=1] The minimum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).\n * @param {Number} [options.socketTimeoutMS=0] How long the MongoDB driver will wait before killing a socket due to inactivity _after initial connection_. Defaults to 0, which means Node.js will not time out the socket due to inactivity. A socket may be inactive because of either no activity or a long-running operation. This option is passed to [Node.js `socket#setTimeout()` function](https://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback) after the MongoDB driver successfully completes.\n * @param {Number} [options.family=0] Passed transparently to [Node.js' `dns.lookup()`](https://nodejs.org/api/dns.html#dns_dns_lookup_hostname_options_callback) function. May be either `0`, `4`, or `6`. `4` means use IPv4 only, `6` means use IPv6 only, `0` means try both.\n * @return {Connection} the created Connection object. Connections are not thenable, so you can't do `await mongoose.createConnection()`. To await use `mongoose.createConnection(uri).asPromise()` instead.\n * @api public\n */\n\nMongoose.prototype.createConnection = function(uri, options) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  const Connection = _mongoose.__driver.Connection;\n  const conn = new Connection(_mongoose);\n  _mongoose.connections.push(conn);\n  _mongoose.nextConnectionId++;\n  _mongoose.events.emit('createConnection', conn);\n\n  if (arguments.length > 0) {\n    conn.openUri(uri, { ...options, _fireAndForget: true });\n  }\n\n  return conn;\n};\n\n/**\n * Opens the default mongoose connection.\n *\n * #### Example:\n *\n *     mongoose.connect('mongodb://user:pass@127.0.0.1:port/database');\n *\n *     // replica sets\n *     const uri = 'mongodb://user:pass@127.0.0.1:port,anotherhost:port,yetanother:port/mydatabase';\n *     mongoose.connect(uri);\n *\n *     // with options\n *     mongoose.connect(uri, options);\n *\n *     // optional callback that gets fired when initial connection completed\n *     const uri = 'mongodb://nonexistent.domain:27000';\n *     mongoose.connect(uri, function(error) {\n *       // if error is truthy, the initial connection failed.\n *     })\n *\n * @param {String} uri mongodb URI to connect to\n * @param {Object} [options] passed down to the [MongoDB driver's `connect()` function](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html), except for 4 mongoose-specific options explained below.\n * @param {Boolean} [options.bufferCommands=true] Mongoose specific option. Set to false to [disable buffering](https://mongoosejs.com/docs/faq.html#callback_never_executes) on all models associated with this connection.\n * @param {Number} [options.bufferTimeoutMS=10000] Mongoose specific option. If `bufferCommands` is true, Mongoose will throw an error after `bufferTimeoutMS` if the operation is still buffered.\n * @param {String} [options.dbName] The name of the database we want to use. If not provided, use database name from connection string.\n * @param {String} [options.user] username for authentication, equivalent to `options.auth.user`. Maintained for backwards compatibility.\n * @param {String} [options.pass] password for authentication, equivalent to `options.auth.password`. Maintained for backwards compatibility.\n * @param {Number} [options.maxPoolSize=100] The maximum number of sockets the MongoDB driver will keep open for this connection. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See [Slow Trains in MongoDB and Node.js](https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs).\n * @param {Number} [options.minPoolSize=0] The minimum number of sockets the MongoDB driver will keep open for this connection.\n * @param {Number} [options.serverSelectionTimeoutMS] If `useUnifiedTopology = true`, the MongoDB driver will try to find a server to send any given operation to, and keep retrying for `serverSelectionTimeoutMS` milliseconds before erroring out. If not set, the MongoDB driver defaults to using `30000` (30 seconds).\n * @param {Number} [options.heartbeatFrequencyMS] If `useUnifiedTopology = true`, the MongoDB driver sends a heartbeat every `heartbeatFrequencyMS` to check on the status of the connection. A heartbeat is subject to `serverSelectionTimeoutMS`, so the MongoDB driver will retry failed heartbeats for up to 30 seconds by default. Mongoose only emits a `'disconnected'` event after a heartbeat has failed, so you may want to decrease this setting to reduce the time between when your server goes down and when Mongoose emits `'disconnected'`. We recommend you do **not** set this setting below 1000, too many heartbeats can lead to performance degradation.\n * @param {Boolean} [options.autoIndex=true] Mongoose-specific option. Set to false to disable automatic index creation for all models associated with this connection.\n * @param {Class} [options.promiseLibrary] Sets the [underlying driver's promise library](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/MongoClientOptions.html#promiseLibrary).\n * @param {Number} [options.socketTimeoutMS=0] How long the MongoDB driver will wait before killing a socket due to inactivity _after initial connection_. A socket may be inactive because of either no activity or a long-running operation. `socketTimeoutMS` defaults to 0, which means Node.js will not time out the socket due to inactivity. This option is passed to [Node.js `socket#setTimeout()` function](https://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback) after the MongoDB driver successfully completes.\n * @param {Number} [options.family=0] Passed transparently to [Node.js' `dns.lookup()`](https://nodejs.org/api/dns.html#dns_dns_lookup_hostname_options_callback) function. May be either `0`, `4`, or `6`. `4` means use IPv4 only, `6` means use IPv6 only, `0` means try both.\n * @param {Boolean} [options.autoCreate=false] Set to `true` to make Mongoose automatically call `createCollection()` on every model created on this connection.\n * @param {Function} [callback]\n * @see Mongoose#createConnection https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.createConnection()\n * @api public\n * @return {Promise} resolves to `this` if connection succeeded\n */\n\nMongoose.prototype.connect = async function connect(uri, options) {\n  if (typeof options === 'function' || (arguments.length >= 3 && typeof arguments[2] === 'function')) {\n    throw new MongooseError('Mongoose.prototype.connect() no longer accepts a callback');\n  }\n\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n  const conn = _mongoose.connection;\n\n  return conn.openUri(uri, options).then(() => _mongoose);\n};\n\n/**\n * Runs `.close()` on all connections in parallel.\n *\n * @return {Promise} resolves when all connections are closed, or rejects with the first error that occurred.\n * @api public\n */\n\nMongoose.prototype.disconnect = async function disconnect() {\n  if (arguments.length >= 1 && typeof arguments[0] === 'function') {\n    throw new MongooseError('Mongoose.prototype.disconnect() no longer accepts a callback');\n  }\n\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  const remaining = _mongoose.connections.length;\n  if (remaining <= 0) {\n    return;\n  }\n  await Promise.all(_mongoose.connections.map(conn => conn.close()));\n};\n\n/**\n * _Requires MongoDB >= 3.6.0._ Starts a [MongoDB session](https://www.mongodb.com/docs/manual/release-notes/3.6/#client-sessions)\n * for benefits like causal consistency, [retryable writes](https://www.mongodb.com/docs/manual/core/retryable-writes/),\n * and [transactions](https://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html).\n *\n * Calling `mongoose.startSession()` is equivalent to calling `mongoose.connection.startSession()`.\n * Sessions are scoped to a connection, so calling `mongoose.startSession()`\n * starts a session on the [default mongoose connection](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.connection).\n *\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#startSession)\n * @param {Boolean} [options.causalConsistency=true] set to false to disable causal consistency\n * @param {Function} [callback]\n * @return {Promise<ClientSession>} promise that resolves to a MongoDB driver `ClientSession`\n * @api public\n */\n\nMongoose.prototype.startSession = function() {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  return _mongoose.connection.startSession.apply(_mongoose.connection, arguments);\n};\n\n/**\n * Getter/setter around function for pluralizing collection names.\n *\n * @param {Function|null} [fn] overwrites the function used to pluralize collection names\n * @return {Function|null} the current function used to pluralize collection names, defaults to the legacy function from `mongoose-legacy-pluralize`.\n * @api public\n */\n\nMongoose.prototype.pluralize = function(fn) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  if (arguments.length > 0) {\n    _mongoose._pluralize = fn;\n  }\n  return _mongoose._pluralize;\n};\n\n/**\n * Defines a model or retrieves it.\n *\n * Models defined on the `mongoose` instance are available to all connection\n * created by the same `mongoose` instance.\n *\n * If you call `mongoose.model()` with twice the same name but a different schema,\n * you will get an `OverwriteModelError`. If you call `mongoose.model()` with\n * the same name and same schema, you'll get the same schema back.\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *\n *     // define an Actor model with this mongoose instance\n *     const schema = new Schema({ name: String });\n *     mongoose.model('Actor', schema);\n *\n *     // create a new connection\n *     const conn = mongoose.createConnection(..);\n *\n *     // create Actor model\n *     const Actor = conn.model('Actor', schema);\n *     conn.model('Actor') === Actor; // true\n *     conn.model('Actor', schema) === Actor; // true, same schema\n *     conn.model('Actor', schema, 'actors') === Actor; // true, same schema and collection name\n *\n *     // This throws an `OverwriteModelError` because the schema is different.\n *     conn.model('Actor', new Schema({ name: String }));\n *\n * _When no `collection` argument is passed, Mongoose uses the model name. If you don't like this behavior, either pass a collection name, use `mongoose.pluralize()`, or set your schemas collection name option._\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String }, { collection: 'actor' });\n *\n *     // or\n *\n *     schema.set('collection', 'actor');\n *\n *     // or\n *\n *     const collectionName = 'actor';\n *     const M = mongoose.model('Actor', schema, collectionName);\n *\n * @param {String|Function} name model name or class extending Model\n * @param {Schema} [schema] the schema to use.\n * @param {String} [collection] name (optional, inferred from model name)\n * @param {Object} [options]\n * @param {Boolean} [options.overwriteModels=false] If true, overwrite existing models with the same name to avoid `OverwriteModelError`\n * @return {Model} The model associated with `name`. Mongoose will create the model if it doesn't already exist.\n * @api public\n */\n\nMongoose.prototype.model = function(name, schema, collection, options) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  if (typeof schema === 'string') {\n    collection = schema;\n    schema = false;\n  }\n\n  if (arguments.length === 1) {\n    const model = _mongoose.models[name];\n    if (!model) {\n      throw new MongooseError.MissingSchemaError(name);\n    }\n    return model;\n  }\n\n  if (utils.isObject(schema) && !(schema instanceof Schema)) {\n    schema = new Schema(schema);\n  }\n  if (schema && !(schema instanceof Schema)) {\n    throw new Error('The 2nd parameter to `mongoose.model()` should be a ' +\n      'schema or a POJO');\n  }\n\n  // handle internal options from connection.model()\n  options = options || {};\n\n  const originalSchema = schema;\n  if (schema) {\n    if (_mongoose.get('cloneSchemas')) {\n      schema = schema.clone();\n    }\n    _mongoose._applyPlugins(schema);\n  }\n\n  // connection.model() may be passing a different schema for\n  // an existing model name. in this case don't read from cache.\n  const overwriteModels = _mongoose.options.hasOwnProperty('overwriteModels') ?\n    _mongoose.options.overwriteModels :\n    options.overwriteModels;\n  if (_mongoose.models.hasOwnProperty(name) && options.cache !== false && overwriteModels !== true) {\n    if (originalSchema &&\n        originalSchema.instanceOfSchema &&\n        originalSchema !== _mongoose.models[name].schema) {\n      throw new _mongoose.Error.OverwriteModelError(name);\n    }\n    if (collection && collection !== _mongoose.models[name].collection.name) {\n      // subclass current model with alternate collection\n      const model = _mongoose.models[name];\n      schema = model.prototype.schema;\n      const sub = model.__subclass(_mongoose.connection, schema, collection);\n      // do not cache the sub model\n      return sub;\n    }\n    return _mongoose.models[name];\n  }\n  if (schema == null) {\n    throw new _mongoose.Error.MissingSchemaError(name);\n  }\n\n  const model = _mongoose._model(name, schema, collection, options);\n  _mongoose.connection.models[name] = model;\n  _mongoose.models[name] = model;\n\n  return model;\n};\n\n/*!\n * ignore\n */\n\nMongoose.prototype._model = function(name, schema, collection, options) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  let model;\n  if (typeof name === 'function') {\n    model = name;\n    name = model.name;\n    if (!(model.prototype instanceof Model)) {\n      throw new _mongoose.Error('The provided class ' + name + ' must extend Model');\n    }\n  }\n\n  if (schema) {\n    if (_mongoose.get('cloneSchemas')) {\n      schema = schema.clone();\n    }\n    _mongoose._applyPlugins(schema);\n  }\n\n  // Apply relevant \"global\" options to the schema\n  if (schema == null || !('pluralization' in schema.options)) {\n    schema.options.pluralization = _mongoose.options.pluralization;\n  }\n\n  if (!collection) {\n    collection = schema.get('collection') ||\n      utils.toCollectionName(name, _mongoose.pluralize());\n  }\n\n  const connection = options.connection || _mongoose.connection;\n  model = _mongoose.Model.compile(model || name, schema, collection, connection, _mongoose);\n  // Errors handled internally, so safe to ignore error\n  model.init().catch(function $modelInitNoop() {});\n\n  connection.emit('model', model);\n\n  if (schema._applyDiscriminators != null) {\n    for (const disc of schema._applyDiscriminators.keys()) {\n      const {\n        schema: discriminatorSchema,\n        options\n      } = schema._applyDiscriminators.get(disc);\n      model.discriminator(disc, discriminatorSchema, options);\n    }\n  }\n\n  applyEmbeddedDiscriminators(schema);\n\n  return model;\n};\n\n/**\n * Removes the model named `name` from the default connection, if it exists.\n * You can use this function to clean up any models you created in your tests to\n * prevent OverwriteModelErrors.\n *\n * Equivalent to `mongoose.connection.deleteModel(name)`.\n *\n * #### Example:\n *\n *     mongoose.model('User', new Schema({ name: String }));\n *     console.log(mongoose.model('User')); // Model object\n *     mongoose.deleteModel('User');\n *     console.log(mongoose.model('User')); // undefined\n *\n *     // Usually useful in a Mocha `afterEach()` hook\n *     afterEach(function() {\n *       mongoose.deleteModel(/.+/); // Delete every model\n *     });\n *\n * @api public\n * @param {String|RegExp} name if string, the name of the model to remove. If regexp, removes all models whose name matches the regexp.\n * @return {Mongoose} this\n */\n\nMongoose.prototype.deleteModel = function(name) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  _mongoose.connection.deleteModel(name);\n  delete _mongoose.models[name];\n  return _mongoose;\n};\n\n/**\n * Returns an array of model names created on this instance of Mongoose.\n *\n * #### Note:\n *\n * _Does not include names of models created using `connection.model()`._\n *\n * @api public\n * @return {Array}\n */\n\nMongoose.prototype.modelNames = function() {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  const names = Object.keys(_mongoose.models);\n  return names;\n};\n\n/**\n * Applies global plugins to `schema`.\n *\n * @param {Schema} schema\n * @api private\n */\n\nMongoose.prototype._applyPlugins = function(schema, options) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  options = options || {};\n  options.applyPluginsToDiscriminators = _mongoose.options && _mongoose.options.applyPluginsToDiscriminators || false;\n  options.applyPluginsToChildSchemas = typeof (_mongoose.options && _mongoose.options.applyPluginsToChildSchemas) === 'boolean' ?\n    _mongoose.options.applyPluginsToChildSchemas :\n    true;\n  applyPlugins(schema, _mongoose.plugins, options, '$globalPluginsApplied');\n};\n\n/**\n * Declares a global plugin executed on all Schemas.\n *\n * Equivalent to calling `.plugin(fn)` on each Schema you create.\n *\n * @param {Function} fn plugin callback\n * @param {Object} [opts] optional options\n * @return {Mongoose} this\n * @see plugins https://mongoosejs.com/docs/plugins.html\n * @api public\n */\n\nMongoose.prototype.plugin = function(fn, opts) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n\n  _mongoose.plugins.push([fn, opts]);\n  return _mongoose;\n};\n\n/**\n * The Mongoose module's default connection. Equivalent to `mongoose.connections[0]`, see [`connections`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.connections).\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     mongoose.connect(...);\n *     mongoose.connection.on('error', cb);\n *\n * This is the connection used by default for every model created using [mongoose.model](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.model()).\n *\n * To create a new connection, use [`createConnection()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.createConnection()).\n *\n * @memberOf Mongoose\n * @instance\n * @property {Connection} connection\n * @api public\n */\n\nMongoose.prototype.__defineGetter__('connection', function() {\n  return this.connections[0];\n});\n\nMongoose.prototype.__defineSetter__('connection', function(v) {\n  if (v instanceof this.__driver.Connection) {\n    this.connections[0] = v;\n    this.models = v.models;\n  }\n});\n\n/**\n * An array containing all [connections](connection.html) associated with this\n * Mongoose instance. By default, there is 1 connection. Calling\n * [`createConnection()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.createConnection()) adds a connection\n * to this array.\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     mongoose.connections.length; // 1, just the default connection\n *     mongoose.connections[0] === mongoose.connection; // true\n *\n *     mongoose.createConnection('mongodb://127.0.0.1:27017/test');\n *     mongoose.connections.length; // 2\n *\n * @memberOf Mongoose\n * @instance\n * @property {Array} connections\n * @api public\n */\n\nMongoose.prototype.connections;\n\n/**\n * An integer containing the value of the next connection id. Calling\n * [`createConnection()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.createConnection()) increments\n * this value.\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     mongoose.createConnection(); // id `0`, `nextConnectionId` becomes `1`\n *     mongoose.createConnection(); // id `1`, `nextConnectionId` becomes `2`\n *     mongoose.connections[0].destroy() // Removes connection with id `0`\n *     mongoose.createConnection(); // id `2`, `nextConnectionId` becomes `3`\n *\n * @memberOf Mongoose\n * @instance\n * @property {Number} nextConnectionId\n * @api private\n */\n\nMongoose.prototype.nextConnectionId;\n\n/**\n * The Mongoose Aggregate constructor\n *\n * @method Aggregate\n * @api public\n */\n\nMongoose.prototype.Aggregate = Aggregate;\n\n/**\n * The Mongoose Collection constructor\n *\n * @memberOf Mongoose\n * @instance\n * @method Collection\n * @api public\n */\n\nObject.defineProperty(Mongoose.prototype, 'Collection', {\n  get: function() {\n    return this.__driver.Collection;\n  },\n  set: function(Collection) {\n    this.__driver.Collection = Collection;\n  }\n});\n\n/**\n * The Mongoose [Connection](https://mongoosejs.com/docs/api/connection.html#Connection()) constructor\n *\n * @memberOf Mongoose\n * @instance\n * @method Connection\n * @api public\n */\n\nObject.defineProperty(Mongoose.prototype, 'Connection', {\n  get: function() {\n    return this.__driver.Connection;\n  },\n  set: function(Connection) {\n    if (Connection === this.__driver.Connection) {\n      return;\n    }\n\n    this.__driver.Connection = Connection;\n  }\n});\n\n/**\n * The Mongoose version\n *\n * #### Example:\n *\n *     console.log(mongoose.version); // '5.x.x'\n *\n * @property version\n * @api public\n */\n\nMongoose.prototype.version = pkg.version;\n\n/**\n * The Mongoose constructor\n *\n * The exports of the mongoose module is an instance of this class.\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     const mongoose2 = new mongoose.Mongoose();\n *\n * @method Mongoose\n * @api public\n */\n\nMongoose.prototype.Mongoose = Mongoose;\n\n/**\n * The Mongoose [Schema](https://mongoosejs.com/docs/api/schema.html#Schema()) constructor\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     const Schema = mongoose.Schema;\n *     const CatSchema = new Schema(..);\n *\n * @method Schema\n * @api public\n */\n\nMongoose.prototype.Schema = Schema;\n\n/**\n * The Mongoose [SchemaType](https://mongoosejs.com/docs/api/schematype.html#SchemaType()) constructor\n *\n * @method SchemaType\n * @api public\n */\n\nMongoose.prototype.SchemaType = SchemaType;\n\n/**\n * The various Mongoose SchemaTypes.\n *\n * #### Note:\n *\n * _Alias of mongoose.Schema.Types for backwards compatibility._\n *\n * @property SchemaTypes\n * @see Schema.SchemaTypes https://mongoosejs.com/docs/schematypes.html\n * @api public\n */\n\nMongoose.prototype.SchemaTypes = Schema.Types;\n\n/**\n * The Mongoose [VirtualType](https://mongoosejs.com/docs/api/virtualtype.html#VirtualType()) constructor\n *\n * @method VirtualType\n * @api public\n */\n\nMongoose.prototype.VirtualType = VirtualType;\n\n/**\n * The various Mongoose Types.\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     const array = mongoose.Types.Array;\n *\n * #### Types:\n *\n * - [Array](https://mongoosejs.com/docs/schematypes.html#arrays)\n * - [Buffer](https://mongoosejs.com/docs/schematypes.html#buffers)\n * - [Embedded](https://mongoosejs.com/docs/schematypes.html#schemas)\n * - [DocumentArray](https://mongoosejs.com/docs/api/documentarraypath.html)\n * - [Decimal128](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.Decimal128)\n * - [ObjectId](https://mongoosejs.com/docs/schematypes.html#objectids)\n * - [Map](https://mongoosejs.com/docs/schematypes.html#maps)\n * - [Subdocument](https://mongoosejs.com/docs/schematypes.html#schemas)\n *\n * Using this exposed access to the `ObjectId` type, we can construct ids on demand.\n *\n *     const ObjectId = mongoose.Types.ObjectId;\n *     const id1 = new ObjectId;\n *\n * @property Types\n * @api public\n */\n\nMongoose.prototype.Types = Types;\n\n/**\n * The Mongoose [Query](https://mongoosejs.com/docs/api/query.html#Query()) constructor.\n *\n * @method Query\n * @api public\n */\n\nMongoose.prototype.Query = Query;\n\n/**\n * The Mongoose [Model](https://mongoosejs.com/docs/api/model.html#Model()) constructor.\n *\n * @method Model\n * @api public\n */\n\nMongoose.prototype.Model = Model;\n\n/**\n * The Mongoose [Document](https://mongoosejs.com/docs/api/document.html#Document()) constructor.\n *\n * @method Document\n * @api public\n */\n\nMongoose.prototype.Document = Document;\n\n/**\n * The Mongoose DocumentProvider constructor. Mongoose users should not have to\n * use this directly\n *\n * @method DocumentProvider\n * @api public\n */\n\nMongoose.prototype.DocumentProvider = __webpack_require__(/*! ./documentProvider */ \"../backend/node_modules/mongoose/lib/documentProvider.js\");\n\n/**\n * The Mongoose ObjectId [SchemaType](https://mongoosejs.com/docs/schematypes.html). Used for\n * declaring paths in your schema that should be\n * [MongoDB ObjectIds](https://www.mongodb.com/docs/manual/reference/method/ObjectId/).\n * Do not use this to create a new ObjectId instance, use `mongoose.Types.ObjectId`\n * instead.\n *\n * #### Example:\n *\n *     const childSchema = new Schema({ parentId: mongoose.ObjectId });\n *\n * @property ObjectId\n * @api public\n */\n\nMongoose.prototype.ObjectId = SchemaTypes.ObjectId;\n\n/**\n * Returns true if Mongoose can cast the given value to an ObjectId, or\n * false otherwise.\n *\n * #### Example:\n *\n *     mongoose.isValidObjectId(new mongoose.Types.ObjectId()); // true\n *     mongoose.isValidObjectId('0123456789ab'); // true\n *     mongoose.isValidObjectId(6); // true\n *     mongoose.isValidObjectId(new User({ name: 'test' })); // true\n *\n *     mongoose.isValidObjectId({ test: 42 }); // false\n *\n * @method isValidObjectId\n * @param {Any} v\n * @returns {boolean} true if `v` is something Mongoose can coerce to an ObjectId\n * @api public\n */\n\nMongoose.prototype.isValidObjectId = function(v) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n  return _mongoose.Types.ObjectId.isValid(v);\n};\n\n/**\n * Returns true if the given value is a Mongoose ObjectId (using `instanceof`) or if the\n * given value is a 24 character hex string, which is the most commonly used string representation\n * of an ObjectId.\n *\n * This function is similar to `isValidObjectId()`, but considerably more strict, because\n * `isValidObjectId()` will return `true` for _any_ value that Mongoose can convert to an\n * ObjectId. That includes Mongoose documents, any string of length 12, and any number.\n * `isObjectIdOrHexString()` returns true only for `ObjectId` instances or 24 character hex\n * strings, and will return false for numbers, documents, and strings of length 12.\n *\n * #### Example:\n *\n *     mongoose.isObjectIdOrHexString(new mongoose.Types.ObjectId()); // true\n *     mongoose.isObjectIdOrHexString('62261a65d66c6be0a63c051f'); // true\n *\n *     mongoose.isObjectIdOrHexString('0123456789ab'); // false\n *     mongoose.isObjectIdOrHexString(6); // false\n *     mongoose.isObjectIdOrHexString(new User({ name: 'test' })); // false\n *     mongoose.isObjectIdOrHexString({ test: 42 }); // false\n *\n * @method isObjectIdOrHexString\n * @param {Any} v\n * @returns {boolean} true if `v` is an ObjectId instance _or_ a 24 char hex string\n * @api public\n */\n\nMongoose.prototype.isObjectIdOrHexString = function(v) {\n  return isBsonType(v, 'ObjectId') || (typeof v === 'string' && objectIdHexRegexp.test(v));\n};\n\n/**\n *\n * Syncs all the indexes for the models registered with this connection.\n *\n * @param {Object} options\n * @param {Boolean} options.continueOnError `false` by default. If set to `true`, mongoose will not throw an error if one model syncing failed, and will return an object where the keys are the names of the models, and the values are the results/errors for each model.\n * @return {Promise} Returns a Promise, when the Promise resolves the value is a list of the dropped indexes.\n */\nMongoose.prototype.syncIndexes = function(options) {\n  const _mongoose = this instanceof Mongoose ? this : mongoose;\n  return _mongoose.connection.syncIndexes(options);\n};\n\n/**\n * The Mongoose Decimal128 [SchemaType](https://mongoosejs.com/docs/schematypes.html). Used for\n * declaring paths in your schema that should be\n * [128-bit decimal floating points](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-decimal.html).\n * Do not use this to create a new Decimal128 instance, use `mongoose.Types.Decimal128`\n * instead.\n *\n * #### Example:\n *\n *     const vehicleSchema = new Schema({ fuelLevel: mongoose.Decimal128 });\n *\n * @property Decimal128\n * @api public\n */\n\nMongoose.prototype.Decimal128 = SchemaTypes.Decimal128;\n\n/**\n * The Mongoose Mixed [SchemaType](https://mongoosejs.com/docs/schematypes.html). Used for\n * declaring paths in your schema that Mongoose's change tracking, casting,\n * and validation should ignore.\n *\n * #### Example:\n *\n *     const schema = new Schema({ arbitrary: mongoose.Mixed });\n *\n * @property Mixed\n * @api public\n */\n\nMongoose.prototype.Mixed = SchemaTypes.Mixed;\n\n/**\n * The Mongoose Date [SchemaType](https://mongoosejs.com/docs/schematypes.html).\n *\n * #### Example:\n *\n *     const schema = new Schema({ test: Date });\n *     schema.path('test') instanceof mongoose.Date; // true\n *\n * @property Date\n * @api public\n */\n\nMongoose.prototype.Date = SchemaTypes.Date;\n\n/**\n * The Mongoose Number [SchemaType](https://mongoosejs.com/docs/schematypes.html). Used for\n * declaring paths in your schema that Mongoose should cast to numbers.\n *\n * #### Example:\n *\n *     const schema = new Schema({ num: mongoose.Number });\n *     // Equivalent to:\n *     const schema = new Schema({ num: 'number' });\n *\n * @property Number\n * @api public\n */\n\nMongoose.prototype.Number = SchemaTypes.Number;\n\n/**\n * The [MongooseError](https://mongoosejs.com/docs/api/error.html#Error()) constructor.\n *\n * @method Error\n * @api public\n */\n\nMongoose.prototype.Error = __webpack_require__(/*! ./error/index */ \"../backend/node_modules/mongoose/lib/error/index.js\");\nMongoose.prototype.MongooseError = __webpack_require__(/*! ./error/mongooseError */ \"../backend/node_modules/mongoose/lib/error/mongooseError.js\");\n\n/**\n * Mongoose uses this function to get the current time when setting\n * [timestamps](https://mongoosejs.com/docs/guide.html#timestamps). You may stub out this function\n * using a tool like [Sinon](https://www.npmjs.com/package/sinon) for testing.\n *\n * @method now\n * @returns Date the current time\n * @api public\n */\n\nMongoose.prototype.now = function now() { return new Date(); };\n\n/**\n * The Mongoose CastError constructor\n *\n * @method CastError\n * @param {String} type The name of the type\n * @param {Any} value The value that failed to cast\n * @param {String} path The path `a.b.c` in the doc where this cast error occurred\n * @param {Error} [reason] The original error that was thrown\n * @api public\n */\n\nMongoose.prototype.CastError = __webpack_require__(/*! ./error/cast */ \"../backend/node_modules/mongoose/lib/error/cast.js\");\n\n/**\n * The constructor used for schematype options\n *\n * @method SchemaTypeOptions\n * @api public\n */\n\nMongoose.prototype.SchemaTypeOptions = __webpack_require__(/*! ./options/schemaTypeOptions */ \"../backend/node_modules/mongoose/lib/options/schemaTypeOptions.js\");\n\n/**\n * The [mquery](https://github.com/aheckmann/mquery) query builder Mongoose uses.\n *\n * @property mquery\n * @api public\n */\n\nMongoose.prototype.mquery = __webpack_require__(/*! mquery */ \"../backend/node_modules/mquery/lib/mquery.js\");\n\n/**\n * Sanitizes query filters against [query selector injection attacks](https://thecodebarbarian.com/2014/09/04/defending-against-query-selector-injection-attacks.html)\n * by wrapping any nested objects that have a property whose name starts with `$` in a `$eq`.\n *\n * ```javascript\n * const obj = { username: 'val', pwd: { $ne: null } };\n * sanitizeFilter(obj);\n * obj; // { username: 'val', pwd: { $eq: { $ne: null } } });\n * ```\n *\n * @method sanitizeFilter\n * @param {Object} filter\n * @returns Object the sanitized object\n * @api public\n */\n\nMongoose.prototype.sanitizeFilter = sanitizeFilter;\n\n/**\n * Tells `sanitizeFilter()` to skip the given object when filtering out potential [query selector injection attacks](https://thecodebarbarian.com/2014/09/04/defending-against-query-selector-injection-attacks.html).\n * Use this method when you have a known query selector that you want to use.\n *\n * ```javascript\n * const obj = { username: 'val', pwd: trusted({ $type: 'string', $eq: 'my secret' }) };\n * sanitizeFilter(obj);\n *\n * // Note that `sanitizeFilter()` did not add `$eq` around `$type`.\n * obj; // { username: 'val', pwd: { $type: 'string', $eq: 'my secret' } });\n * ```\n *\n * @method trusted\n * @param {Object} obj\n * @returns Object the passed in object\n * @api public\n */\n\nMongoose.prototype.trusted = trusted;\n\n/**\n * Use this function in `pre()` middleware to skip calling the wrapped function.\n *\n * #### Example:\n *\n *     schema.pre('save', function() {\n *       // Will skip executing `save()`, but will execute post hooks as if\n *       // `save()` had executed with the result `{ matchedCount: 0 }`\n *       return mongoose.skipMiddlewareFunction({ matchedCount: 0 });\n *     });\n *\n * @method skipMiddlewareFunction\n * @param {any} result\n * @api public\n */\n\nMongoose.prototype.skipMiddlewareFunction = Kareem.skipWrappedFunction;\n\n/**\n * Use this function in `post()` middleware to replace the result\n *\n * #### Example:\n *\n *     schema.post('find', function(res) {\n *       // Normally you have to modify `res` in place. But with\n *       // `overwriteMiddlewarResult()`, you can make `find()` return a\n *       // completely different value.\n *       return mongoose.overwriteMiddlewareResult(res.filter(doc => !doc.isDeleted));\n *     });\n *\n * @method overwriteMiddlewareResult\n * @param {any} result\n * @api public\n */\n\nMongoose.prototype.overwriteMiddlewareResult = Kareem.overwriteResult;\n\n/**\n * The exports object is an instance of Mongoose.\n *\n * @api private\n */\n\nconst mongoose = module.exports = exports = new Mongoose({\n  [defaultMongooseSymbol]: true\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL21vbmdvb3NlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsbUJBQU8sQ0FBQyxvRUFBWTtBQUNyQyxxQkFBcUIsMERBQThCO0FBQ25ELGVBQWUsbUJBQU8sQ0FBQyx1REFBUTtBQUMvQixlQUFlLG1CQUFPLENBQUMsZ0VBQVU7QUFDakMsbUJBQW1CLG1CQUFPLENBQUMsd0VBQWM7QUFDekMsb0JBQW9CLG1CQUFPLENBQUMsNEVBQWdCO0FBQzVDLG9CQUFvQixtQkFBTyxDQUFDLDBFQUFlO0FBQzNDLGVBQWUsbUJBQU8sQ0FBQyxrRkFBbUI7QUFDMUMsc0JBQXNCLG1CQUFPLENBQUMsNEVBQWdCO0FBQzlDLGNBQWMsbUJBQU8sQ0FBQyxvRUFBUztBQUMvQixjQUFjLG1CQUFPLENBQUMsOERBQVM7QUFDL0IsY0FBYyxtQkFBTyxDQUFDLDhEQUFTO0FBQy9CLHFCQUFxQixtQkFBTyxDQUFDLDBHQUErQjtBQUM1RCx1QkFBdUIsbUJBQU8sQ0FBQyx3RUFBVztBQUMxQyxlQUFlLG1CQUFPLENBQUMsZ0VBQVU7QUFDakMsd0JBQXdCLG1CQUFPLENBQUMsc0ZBQXFCO0FBQ3JELGNBQWMsbUJBQU8sQ0FBQyw4REFBUztBQUMvQixZQUFZLG1CQUFPLENBQUMsc0VBQWlCO0FBQ3JDLGFBQWEsbUJBQU8sQ0FBQyw0REFBUTs7QUFFN0Isa0JBQWtCLG1CQUFPLENBQUMsc0VBQWE7QUFDdkMsZ0JBQWdCLDZIQUEwQztBQUMxRCx1QkFBdUIsbUJBQU8sQ0FBQyw0R0FBZ0M7QUFDL0QsbUJBQW1CLG1CQUFPLENBQUMsd0ZBQXNCO0FBQ2pELHNCQUFzQixtQkFBTyxDQUFDLDBGQUF1QjtBQUNyRCx1QkFBdUIsbUJBQU8sQ0FBQyw0RkFBd0I7QUFDdkQsb0NBQW9DLG1CQUFPLENBQUMsc0pBQXFEOztBQUVqRzs7QUFFQSxtQkFBTyxDQUFDLG9HQUE0Qjs7QUFFcEMsd0NBQXdD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QUNwQyxvQ0FBb0M7QUFDcEM7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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LGtEQUFrRCxpQkFBaUI7QUFDbkUsUUFBUTtBQUNSO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9tb25nb29zZS5qcz84ZGY4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IERvY3VtZW50ID0gcmVxdWlyZSgnLi9kb2N1bWVudCcpO1xuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuY29uc3QgS2FyZWVtID0gcmVxdWlyZSgna2FyZWVtJyk7XG5jb25zdCBTY2hlbWEgPSByZXF1aXJlKCcuL3NjaGVtYScpO1xuY29uc3QgU2NoZW1hVHlwZSA9IHJlcXVpcmUoJy4vc2NoZW1hVHlwZScpO1xuY29uc3QgU2NoZW1hVHlwZXMgPSByZXF1aXJlKCcuL3NjaGVtYS9pbmRleCcpO1xuY29uc3QgVmlydHVhbFR5cGUgPSByZXF1aXJlKCcuL3ZpcnR1YWxUeXBlJyk7XG5jb25zdCBTVEFURVMgPSByZXF1aXJlKCcuL2Nvbm5lY3Rpb25TdGF0ZScpO1xuY29uc3QgVkFMSURfT1BUSU9OUyA9IHJlcXVpcmUoJy4vdmFsaWRPcHRpb25zJyk7XG5jb25zdCBUeXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcbmNvbnN0IFF1ZXJ5ID0gcmVxdWlyZSgnLi9xdWVyeScpO1xuY29uc3QgTW9kZWwgPSByZXF1aXJlKCcuL21vZGVsJyk7XG5jb25zdCBhcHBseVBsdWdpbnMgPSByZXF1aXJlKCcuL2hlbHBlcnMvc2NoZW1hL2FwcGx5UGx1Z2lucycpO1xuY29uc3QgYnVpbHRpblBsdWdpbnMgPSByZXF1aXJlKCcuL3BsdWdpbnMnKTtcbmNvbnN0IGRyaXZlciA9IHJlcXVpcmUoJy4vZHJpdmVyJyk7XG5jb25zdCBsZWdhY3lQbHVyYWxpemUgPSByZXF1aXJlKCcuL2hlbHBlcnMvcGx1cmFsaXplJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbmNvbnN0IHBrZyA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpO1xuY29uc3QgY2FzdCA9IHJlcXVpcmUoJy4vY2FzdCcpO1xuXG5jb25zdCBBZ2dyZWdhdGUgPSByZXF1aXJlKCcuL2FnZ3JlZ2F0ZScpO1xuY29uc3QgdHJ1c3RlZCA9IHJlcXVpcmUoJy4vaGVscGVycy9xdWVyeS90cnVzdGVkJykudHJ1c3RlZDtcbmNvbnN0IHNhbml0aXplRmlsdGVyID0gcmVxdWlyZSgnLi9oZWxwZXJzL3F1ZXJ5L3Nhbml0aXplRmlsdGVyJyk7XG5jb25zdCBpc0Jzb25UeXBlID0gcmVxdWlyZSgnLi9oZWxwZXJzL2lzQnNvblR5cGUnKTtcbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL21vbmdvb3NlRXJyb3InKTtcbmNvbnN0IFNldE9wdGlvbkVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9zZXRPcHRpb25FcnJvcicpO1xuY29uc3QgYXBwbHlFbWJlZGRlZERpc2NyaW1pbmF0b3JzID0gcmVxdWlyZSgnLi9oZWxwZXJzL2Rpc2NyaW1pbmF0b3IvYXBwbHlFbWJlZGRlZERpc2NyaW1pbmF0b3JzJyk7XG5cbmNvbnN0IGRlZmF1bHRNb25nb29zZVN5bWJvbCA9IFN5bWJvbC5mb3IoJ21vbmdvb3NlOmRlZmF1bHQnKTtcblxucmVxdWlyZSgnLi9oZWxwZXJzL3ByaW50SmVzdFdhcm5pbmcnKTtcblxuY29uc3Qgb2JqZWN0SWRIZXhSZWdleHAgPSAvXlswLTlBLUZhLWZdezI0fSQvO1xuXG4vKipcbiAqIE1vbmdvb3NlIGNvbnN0cnVjdG9yLlxuICpcbiAqIFRoZSBleHBvcnRzIG9iamVjdCBvZiB0aGUgYG1vbmdvb3NlYCBtb2R1bGUgaXMgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAqIE1vc3QgYXBwcyB3aWxsIG9ubHkgdXNlIHRoaXMgb25lIGluc3RhbmNlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgbW9uZ29vc2UgPSByZXF1aXJlKCdtb25nb29zZScpO1xuICogICAgIG1vbmdvb3NlIGluc3RhbmNlb2YgbW9uZ29vc2UuTW9uZ29vc2U7IC8vIHRydWVcbiAqXG4gKiAgICAgLy8gQ3JlYXRlIGEgbmV3IE1vbmdvb3NlIGluc3RhbmNlIHdpdGggaXRzIG93biBgY29ubmVjdCgpYCwgYHNldCgpYCwgYG1vZGVsKClgLCBldGMuXG4gKiAgICAgY29uc3QgbSA9IG5ldyBtb25nb29zZS5Nb25nb29zZSgpO1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBzZWUgW2BNb25nb29zZSNzZXQoKWAgZG9jc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb25nb29zZS5odG1sI01vbmdvb3NlLnByb3RvdHlwZS5zZXQoKSlcbiAqL1xuZnVuY3Rpb24gTW9uZ29vc2Uob3B0aW9ucykge1xuICB0aGlzLmNvbm5lY3Rpb25zID0gW107XG4gIHRoaXMubmV4dENvbm5lY3Rpb25JZCA9IDA7XG4gIHRoaXMubW9kZWxzID0ge307XG4gIHRoaXMuZXZlbnRzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICB0aGlzLl9fZHJpdmVyID0gZHJpdmVyLmdldCgpO1xuICAvLyBkZWZhdWx0IGdsb2JhbCBvcHRpb25zXG4gIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIHBsdXJhbGl6YXRpb246IHRydWUsXG4gICAgYXV0b0luZGV4OiB0cnVlLFxuICAgIGF1dG9DcmVhdGU6IHRydWUsXG4gICAgYXV0b1NlYXJjaEluZGV4OiBmYWxzZVxuICB9LCBvcHRpb25zKTtcbiAgY29uc3QgY3JlYXRlSW5pdGlhbENvbm5lY3Rpb24gPSB1dGlscy5nZXRPcHRpb24oJ2NyZWF0ZUluaXRpYWxDb25uZWN0aW9uJywgdGhpcy5vcHRpb25zKTtcbiAgaWYgKGNyZWF0ZUluaXRpYWxDb25uZWN0aW9uID09IG51bGwgfHwgY3JlYXRlSW5pdGlhbENvbm5lY3Rpb24pIHtcbiAgICBjb25zdCBjb25uID0gdGhpcy5jcmVhdGVDb25uZWN0aW9uKCk7IC8vIGRlZmF1bHQgY29ubmVjdGlvblxuICAgIGNvbm4ubW9kZWxzID0gdGhpcy5tb2RlbHM7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLnBsdXJhbGl6YXRpb24pIHtcbiAgICB0aGlzLl9wbHVyYWxpemUgPSBsZWdhY3lQbHVyYWxpemU7XG4gIH1cblxuICAvLyBJZiBhIHVzZXIgY3JlYXRlcyB0aGVpciBvd24gTW9uZ29vc2UgaW5zdGFuY2UsIGdpdmUgdGhlbSBhIHNlcGFyYXRlIGNvcHlcbiAgLy8gb2YgdGhlIGBTY2hlbWFgIGNvbnN0cnVjdG9yIHNvIHRoZXkgZ2V0IHNlcGFyYXRlIGN1c3RvbSB0eXBlcy4gKGdoLTY5MzMpXG4gIGlmICghb3B0aW9ucyB8fCAhb3B0aW9uc1tkZWZhdWx0TW9uZ29vc2VTeW1ib2xdKSB7XG4gICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuU2NoZW1hID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmJhc2UgPSBfdGhpcztcbiAgICAgIHJldHVybiBTY2hlbWEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIHRoaXMuU2NoZW1hLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU2NoZW1hLnByb3RvdHlwZSk7XG5cbiAgICBPYmplY3QuYXNzaWduKHRoaXMuU2NoZW1hLCBTY2hlbWEpO1xuICAgIHRoaXMuU2NoZW1hLmJhc2UgPSB0aGlzO1xuICAgIHRoaXMuU2NoZW1hLlR5cGVzID0gT2JqZWN0LmFzc2lnbih7fSwgU2NoZW1hLlR5cGVzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBIYWNrIHRvIHdvcmsgYXJvdW5kIGJhYmVsJ3Mgc3RyYW5nZSBiZWhhdmlvciB3aXRoXG4gICAgLy8gYGltcG9ydCBtb25nb29zZSwgeyBTY2hlbWEgfSBmcm9tICdtb25nb29zZSdgLiBCZWNhdXNlIGBTY2hlbWFgIGlzIG5vdFxuICAgIC8vIGFuIG93biBwcm9wZXJ0eSBvZiBhIE1vbmdvb3NlIGdsb2JhbCwgU2NoZW1hIHdpbGwgYmUgdW5kZWZpbmVkLiBTZWUgZ2gtNTY0OFxuICAgIGZvciAoY29uc3Qga2V5IG9mIFsnU2NoZW1hJywgJ21vZGVsJ10pIHtcbiAgICAgIHRoaXNba2V5XSA9IE1vbmdvb3NlLnByb3RvdHlwZVtrZXldO1xuICAgIH1cbiAgfVxuICB0aGlzLlNjaGVtYS5wcm90b3R5cGUuYmFzZSA9IHRoaXM7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdwbHVnaW5zJywge1xuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IE9iamVjdC52YWx1ZXMoYnVpbHRpblBsdWdpbnMpLm1hcChwbHVnaW4gPT4gKFtwbHVnaW4sIHsgZGVkdXBsaWNhdGU6IHRydWUgfV0pKVxuICB9KTtcbn1cblxuTW9uZ29vc2UucHJvdG90eXBlLmNhc3QgPSBjYXN0O1xuLyoqXG4gKiBFeHBvc2UgY29ubmVjdGlvbiBzdGF0ZXMgZm9yIHVzZXItbGFuZFxuICpcbiAqIEBtZW1iZXJPZiBNb25nb29zZVxuICogQHByb3BlcnR5IFNUQVRFU1xuICogQGFwaSBwdWJsaWNcbiAqL1xuTW9uZ29vc2UucHJvdG90eXBlLlNUQVRFUyA9IFNUQVRFUztcblxuLyoqXG4gKiBFeHBvc2UgY29ubmVjdGlvbiBzdGF0ZXMgZm9yIHVzZXItbGFuZFxuICpcbiAqIEBtZW1iZXJPZiBNb25nb29zZVxuICogQHByb3BlcnR5IENvbm5lY3Rpb25TdGF0ZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cbk1vbmdvb3NlLnByb3RvdHlwZS5Db25uZWN0aW9uU3RhdGVzID0gU1RBVEVTO1xuXG4vKipcbiAqIE9iamVjdCB3aXRoIGBnZXQoKWAgYW5kIGBzZXQoKWAgY29udGFpbmluZyB0aGUgdW5kZXJseWluZyBkcml2ZXIgdGhpcyBNb25nb29zZSBpbnN0YW5jZVxuICogdXNlcyB0byBjb21tdW5pY2F0ZSB3aXRoIHRoZSBkYXRhYmFzZS4gQSBkcml2ZXIgaXMgYSBNb25nb29zZS1zcGVjaWZpYyBpbnRlcmZhY2UgdGhhdCBkZWZpbmVzIGZ1bmN0aW9uc1xuICogbGlrZSBgZmluZCgpYC5cbiAqXG4gKiBAZGVwcmVjYXRlZFxuICogQG1lbWJlck9mIE1vbmdvb3NlXG4gKiBAcHJvcGVydHkgZHJpdmVyXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5kcml2ZXIgPSBkcml2ZXI7XG5cbi8qKlxuICogT3ZlcndyaXRlcyB0aGUgY3VycmVudCBkcml2ZXIgdXNlZCBieSB0aGlzIE1vbmdvb3NlIGluc3RhbmNlLiBBIGRyaXZlciBpcyBhXG4gKiBNb25nb29zZS1zcGVjaWZpYyBpbnRlcmZhY2UgdGhhdCBkZWZpbmVzIGZ1bmN0aW9ucyBsaWtlIGBmaW5kKClgLlxuICpcbiAqIEBtZW1iZXJPZiBNb25nb29zZVxuICogQG1ldGhvZCBzZXREcml2ZXJcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLnNldERyaXZlciA9IGZ1bmN0aW9uIHNldERyaXZlcihkcml2ZXIpIHtcbiAgY29uc3QgX21vbmdvb3NlID0gdGhpcyBpbnN0YW5jZW9mIE1vbmdvb3NlID8gdGhpcyA6IG1vbmdvb3NlO1xuXG4gIGlmIChfbW9uZ29vc2UuX19kcml2ZXIgPT09IGRyaXZlcikge1xuICAgIHJldHVybiBfbW9uZ29vc2U7XG4gIH1cblxuICBjb25zdCBvcGVuQ29ubmVjdGlvbiA9IF9tb25nb29zZS5jb25uZWN0aW9ucyAmJiBfbW9uZ29vc2UuY29ubmVjdGlvbnMuZmluZChjb25uID0+IGNvbm4ucmVhZHlTdGF0ZSAhPT0gU1RBVEVTLmRpc2Nvbm5lY3RlZCk7XG4gIGlmIChvcGVuQ29ubmVjdGlvbikge1xuICAgIGNvbnN0IG1zZyA9ICdDYW5ub3QgbW9kaWZ5IE1vbmdvb3NlIGRyaXZlciBpZiBhIGNvbm5lY3Rpb24gaXMgYWxyZWFkeSBvcGVuLiAnICtcbiAgICAgICdDYWxsIGBtb25nb29zZS5kaXNjb25uZWN0KClgIGJlZm9yZSBtb2RpZnlpbmcgdGhlIGRyaXZlcic7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IobXNnKTtcbiAgfVxuICBfbW9uZ29vc2UuX19kcml2ZXIgPSBkcml2ZXI7XG5cbiAgY29uc3QgQ29ubmVjdGlvbiA9IGRyaXZlci5Db25uZWN0aW9uO1xuICBjb25zdCBvbGREZWZhdWx0Q29ubmVjdGlvbiA9IF9tb25nb29zZS5jb25uZWN0aW9uc1swXTtcbiAgX21vbmdvb3NlLmNvbm5lY3Rpb25zID0gW25ldyBDb25uZWN0aW9uKF9tb25nb29zZSldO1xuICBfbW9uZ29vc2UuY29ubmVjdGlvbnNbMF0ubW9kZWxzID0gX21vbmdvb3NlLm1vZGVscztcblxuICAvLyBVcGRhdGUgYWxsIG1vZGVscyB0aGF0IHBvaW50ZWQgdG8gdGhlIG9sZCBkZWZhdWx0IGNvbm5lY3Rpb24gdG9cbiAgLy8gdGhlIG5ldyBkZWZhdWx0IGNvbm5lY3Rpb24sIGluY2x1ZGluZyBjb2xsZWN0aW9uc1xuICBmb3IgKGNvbnN0IG1vZGVsIG9mIE9iamVjdC52YWx1ZXMoX21vbmdvb3NlLm1vZGVscykpIHtcbiAgICBpZiAobW9kZWwuZGIgIT09IG9sZERlZmF1bHRDb25uZWN0aW9uKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbW9kZWwuJF9fdXBkYXRlQ29ubmVjdGlvbihfbW9uZ29vc2UuY29ubmVjdGlvbnNbMF0pO1xuICB9XG5cbiAgcmV0dXJuIF9tb25nb29zZTtcbn07XG5cbi8qKlxuICogU2V0cyBtb25nb29zZSBvcHRpb25zXG4gKlxuICogYGtleWAgY2FuIGJlIHVzZWQgYSBvYmplY3QgdG8gc2V0IG11bHRpcGxlIG9wdGlvbnMgYXQgb25jZS5cbiAqIElmIGEgZXJyb3IgZ2V0cyB0aHJvd24gZm9yIG9uZSBvcHRpb24sIG90aGVyIG9wdGlvbnMgd2lsbCBzdGlsbCBiZSBldmFsdWF0ZWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBtb25nb29zZS5zZXQoJ3Rlc3QnLCB2YWx1ZSkgLy8gc2V0cyB0aGUgJ3Rlc3QnIG9wdGlvbiB0byBgdmFsdWVgXG4gKlxuICogICAgIG1vbmdvb3NlLnNldCgnZGVidWcnLCB0cnVlKSAvLyBlbmFibGUgbG9nZ2luZyBjb2xsZWN0aW9uIG1ldGhvZHMgKyBhcmd1bWVudHMgdG8gdGhlIGNvbnNvbGUvZmlsZVxuICpcbiAqICAgICBtb25nb29zZS5zZXQoJ2RlYnVnJywgZnVuY3Rpb24oY29sbGVjdGlvbk5hbWUsIG1ldGhvZE5hbWUsIC4uLm1ldGhvZEFyZ3MpIHt9KTsgLy8gdXNlIGN1c3RvbSBmdW5jdGlvbiB0byBsb2cgY29sbGVjdGlvbiBtZXRob2RzICsgYXJndW1lbnRzXG4gKlxuICogICAgIG1vbmdvb3NlLnNldCh7IGRlYnVnOiB0cnVlLCBhdXRvSW5kZXg6IGZhbHNlIH0pOyAvLyBzZXQgbXVsdGlwbGUgb3B0aW9ucyBhdCBvbmNlXG4gKlxuICogQ3VycmVudGx5IHN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqIC0gYGFsbG93RGlza1VzZWA6IFNldCB0byBgdHJ1ZWAgdG8gc2V0IGBhbGxvd0Rpc2tVc2VgIHRvIHRydWUgdG8gYWxsIGFnZ3JlZ2F0aW9uIG9wZXJhdGlvbnMgYnkgZGVmYXVsdC5cbiAqIC0gYGFwcGx5UGx1Z2luc1RvQ2hpbGRTY2hlbWFzYDogYHRydWVgIGJ5IGRlZmF1bHQuIFNldCB0byBmYWxzZSB0byBza2lwIGFwcGx5aW5nIGdsb2JhbCBwbHVnaW5zIHRvIGNoaWxkIHNjaGVtYXNcbiAqIC0gYGFwcGx5UGx1Z2luc1RvRGlzY3JpbWluYXRvcnNgOiBgZmFsc2VgIGJ5IGRlZmF1bHQuIFNldCB0byB0cnVlIHRvIGFwcGx5IGdsb2JhbCBwbHVnaW5zIHRvIGRpc2NyaW1pbmF0b3Igc2NoZW1hcy4gVGhpcyB0eXBpY2FsbHkgaXNuJ3QgbmVjZXNzYXJ5IGJlY2F1c2UgcGx1Z2lucyBhcmUgYXBwbGllZCB0byB0aGUgYmFzZSBzY2hlbWEgYW5kIGRpc2NyaW1pbmF0b3JzIGNvcHkgYWxsIG1pZGRsZXdhcmUsIG1ldGhvZHMsIHN0YXRpY3MsIGFuZCBwcm9wZXJ0aWVzIGZyb20gdGhlIGJhc2Ugc2NoZW1hLlxuICogLSBgYXV0b0NyZWF0ZWA6IFNldCB0byBgdHJ1ZWAgdG8gbWFrZSBNb25nb29zZSBjYWxsIFtgTW9kZWwuY3JlYXRlQ29sbGVjdGlvbigpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsLmNyZWF0ZUNvbGxlY3Rpb24oKSkgYXV0b21hdGljYWxseSB3aGVuIHlvdSBjcmVhdGUgYSBtb2RlbCB3aXRoIGBtb25nb29zZS5tb2RlbCgpYCBvciBgY29ubi5tb2RlbCgpYC4gVGhpcyBpcyB1c2VmdWwgZm9yIHRlc3RpbmcgdHJhbnNhY3Rpb25zLCBjaGFuZ2Ugc3RyZWFtcywgYW5kIG90aGVyIGZlYXR1cmVzIHRoYXQgcmVxdWlyZSB0aGUgY29sbGVjdGlvbiB0byBleGlzdC5cbiAqIC0gYGF1dG9JbmRleGA6IGB0cnVlYCBieSBkZWZhdWx0LiBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBhdXRvbWF0aWMgaW5kZXggY3JlYXRpb24gZm9yIGFsbCBtb2RlbHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgTW9uZ29vc2UgaW5zdGFuY2UuXG4gKiAtIGBidWZmZXJDb21tYW5kc2A6IGVuYWJsZS9kaXNhYmxlIG1vbmdvb3NlJ3MgYnVmZmVyaW5nIG1lY2hhbmlzbSBmb3IgYWxsIGNvbm5lY3Rpb25zIGFuZCBtb2RlbHNcbiAqIC0gYGJ1ZmZlclRpbWVvdXRNU2A6IElmIGJ1ZmZlckNvbW1hbmRzIGlzIG9uLCB0aGlzIG9wdGlvbiBzZXRzIHRoZSBtYXhpbXVtIGFtb3VudCBvZiB0aW1lIE1vbmdvb3NlIGJ1ZmZlcmluZyB3aWxsIHdhaXQgYmVmb3JlIHRocm93aW5nIGFuIGVycm9yLiBJZiBub3Qgc3BlY2lmaWVkLCBNb25nb29zZSB3aWxsIHVzZSAxMDAwMCAoMTAgc2Vjb25kcykuXG4gKiAtIGBjbG9uZVNjaGVtYXNgOiBgZmFsc2VgIGJ5IGRlZmF1bHQuIFNldCB0byBgdHJ1ZWAgdG8gYGNsb25lKClgIGFsbCBzY2hlbWFzIGJlZm9yZSBjb21waWxpbmcgaW50byBhIG1vZGVsLlxuICogLSBgZGVidWdgOiBJZiBgdHJ1ZWAsIHByaW50cyB0aGUgb3BlcmF0aW9ucyBtb25nb29zZSBzZW5kcyB0byBNb25nb0RCIHRvIHRoZSBjb25zb2xlLiBJZiBhIHdyaXRhYmxlIHN0cmVhbSBpcyBwYXNzZWQsIGl0IHdpbGwgbG9nIHRvIHRoYXQgc3RyZWFtLCB3aXRob3V0IGNvbG9yaXphdGlvbi4gSWYgYSBjYWxsYmFjayBmdW5jdGlvbiBpcyBwYXNzZWQsIGl0IHdpbGwgcmVjZWl2ZSB0aGUgY29sbGVjdGlvbiBuYW1lLCB0aGUgbWV0aG9kIG5hbWUsIHRoZW4gYWxsIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIG1ldGhvZC4gRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50ZWQgdG8gcmVwbGljYXRlIHRoZSBkZWZhdWx0IGxvZ2dpbmcsIHlvdSBjb3VsZCBvdXRwdXQgZnJvbSB0aGUgY2FsbGJhY2sgYE1vbmdvb3NlOiAke2NvbGxlY3Rpb25OYW1lfS4ke21ldGhvZE5hbWV9KCR7bWV0aG9kQXJncy5qb2luKCcsICcpfSlgLlxuICogLSBgaWRgOiBJZiBgdHJ1ZWAsIGFkZHMgYSBgaWRgIHZpcnR1YWwgdG8gYWxsIHNjaGVtYXMgdW5sZXNzIG92ZXJ3cml0dGVuIG9uIGEgcGVyLXNjaGVtYSBiYXNpcy5cbiAqIC0gYHRpbWVzdGFtcHMuY3JlYXRlZEF0LmltbXV0YWJsZWA6IGB0cnVlYCBieSBkZWZhdWx0LiBJZiBgZmFsc2VgLCBpdCB3aWxsIGNoYW5nZSB0aGUgYGNyZWF0ZWRBdGAgZmllbGQgdG8gYmUgW2BpbW11dGFibGU6IGZhbHNlYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9zY2hlbWF0eXBlLmh0bWwjU2NoZW1hVHlwZS5wcm90b3R5cGUuaW1tdXRhYmxlKSB3aGljaCBtZWFucyB5b3UgY2FuIHVwZGF0ZSB0aGUgYGNyZWF0ZWRBdGBcbiAqIC0gYG1heFRpbWVNU2A6IElmIHNldCwgYXR0YWNoZXMgW21heFRpbWVNU10oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL21ldGEvbWF4VGltZU1TLykgdG8gZXZlcnkgcXVlcnlcbiAqIC0gYG9iamVjdElkR2V0dGVyYDogYHRydWVgIGJ5IGRlZmF1bHQuIE1vbmdvb3NlIGFkZHMgYSBnZXR0ZXIgdG8gTW9uZ29EQiBPYmplY3RJZCdzIGNhbGxlZCBgX2lkYCB0aGF0IHJldHVybnMgYHRoaXNgIGZvciBjb252ZW5pZW5jZSB3aXRoIHBvcHVsYXRlLiBTZXQgdGhpcyB0byBmYWxzZSB0byByZW1vdmUgdGhlIGdldHRlci5cbiAqIC0gYG92ZXJ3cml0ZU1vZGVsc2A6IFNldCB0byBgdHJ1ZWAgdG8gZGVmYXVsdCB0byBvdmVyd3JpdGluZyBtb2RlbHMgd2l0aCB0aGUgc2FtZSBuYW1lIHdoZW4gY2FsbGluZyBgbW9uZ29vc2UubW9kZWwoKWAsIGFzIG9wcG9zZWQgdG8gdGhyb3dpbmcgYW4gYE92ZXJ3cml0ZU1vZGVsRXJyb3JgLlxuICogLSBgcmV0dXJuT3JpZ2luYWxgOiBJZiBgZmFsc2VgLCBjaGFuZ2VzIHRoZSBkZWZhdWx0IGByZXR1cm5PcmlnaW5hbGAgb3B0aW9uIHRvIGBmaW5kT25lQW5kVXBkYXRlKClgLCBgZmluZEJ5SWRBbmRVcGRhdGVgLCBhbmQgYGZpbmRPbmVBbmRSZXBsYWNlKClgIHRvIGZhbHNlLiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gc2V0dGluZyB0aGUgYG5ld2Agb3B0aW9uIHRvIGB0cnVlYCBmb3IgYGZpbmRPbmVBbmRYKClgIGNhbGxzIGJ5IGRlZmF1bHQuIFJlYWQgb3VyIFtgZmluZE9uZUFuZFVwZGF0ZSgpYCB0dXRvcmlhbF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3R1dG9yaWFscy9maW5kb25lYW5kdXBkYXRlLmh0bWwpIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICogLSBgcnVuVmFsaWRhdG9yc2A6IGBmYWxzZWAgYnkgZGVmYXVsdC4gU2V0IHRvIHRydWUgdG8gZW5hYmxlIFt1cGRhdGUgdmFsaWRhdG9yc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3ZhbGlkYXRpb24uaHRtbCN1cGRhdGUtdmFsaWRhdG9ycykgZm9yIGFsbCB2YWxpZGF0b3JzIGJ5IGRlZmF1bHQuXG4gKiAtIGBzYW5pdGl6ZUZpbHRlcmA6IGBmYWxzZWAgYnkgZGVmYXVsdC4gU2V0IHRvIHRydWUgdG8gZW5hYmxlIHRoZSBbc2FuaXRpemF0aW9uIG9mIHRoZSBxdWVyeSBmaWx0ZXJzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vbmdvb3NlLmh0bWwjTW9uZ29vc2UucHJvdG90eXBlLnNhbml0aXplRmlsdGVyKCkpIGFnYWluc3QgcXVlcnkgc2VsZWN0b3IgaW5qZWN0aW9uIGF0dGFja3MgYnkgd3JhcHBpbmcgYW55IG5lc3RlZCBvYmplY3RzIHRoYXQgaGF2ZSBhIHByb3BlcnR5IHdob3NlIG5hbWUgc3RhcnRzIHdpdGggYCRgIGluIGEgYCRlcWAuXG4gKiAtIGBzZWxlY3RQb3B1bGF0ZWRQYXRoc2A6IGB0cnVlYCBieSBkZWZhdWx0LiBTZXQgdG8gZmFsc2UgdG8gb3B0IG91dCBvZiBNb25nb29zZSBhZGRpbmcgYWxsIGZpZWxkcyB0aGF0IHlvdSBgcG9wdWxhdGUoKWAgdG8geW91ciBgc2VsZWN0KClgLiBUaGUgc2NoZW1hLWxldmVsIG9wdGlvbiBgc2VsZWN0UG9wdWxhdGVkUGF0aHNgIG92ZXJ3cml0ZXMgdGhpcyBvbmUuXG4gKiAtIGBzdHJpY3RgOiBgdHJ1ZWAgYnkgZGVmYXVsdCwgbWF5IGJlIGBmYWxzZWAsIGB0cnVlYCwgb3IgYCd0aHJvdydgLiBTZXRzIHRoZSBkZWZhdWx0IHN0cmljdCBtb2RlIGZvciBzY2hlbWFzLlxuICogLSBgc3RyaWN0UXVlcnlgOiBgZmFsc2VgIGJ5IGRlZmF1bHQuIE1heSBiZSBgZmFsc2VgLCBgdHJ1ZWAsIG9yIGAndGhyb3cnYC4gU2V0cyB0aGUgZGVmYXVsdCBbc3RyaWN0UXVlcnldKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdFF1ZXJ5KSBtb2RlIGZvciBzY2hlbWFzLlxuICogLSBgdG9KU09OYDogYHsgdHJhbnNmb3JtOiB0cnVlLCBmbGF0dGVuRGVjaW1hbHM6IHRydWUgfWAgYnkgZGVmYXVsdC4gT3ZlcndyaXRlcyBkZWZhdWx0IG9iamVjdHMgdG8gW2B0b0pTT04oKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudC5wcm90b3R5cGUudG9KU09OKCkpLCBmb3IgZGV0ZXJtaW5pbmcgaG93IE1vbmdvb3NlIGRvY3VtZW50cyBnZXQgc2VyaWFsaXplZCBieSBgSlNPTi5zdHJpbmdpZnkoKWBcbiAqIC0gYHRvT2JqZWN0YDogYHsgdHJhbnNmb3JtOiB0cnVlLCBmbGF0dGVuRGVjaW1hbHM6IHRydWUgfWAgYnkgZGVmYXVsdC4gT3ZlcndyaXRlcyBkZWZhdWx0IG9iamVjdHMgdG8gW2B0b09iamVjdCgpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS50b09iamVjdCgpKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0ga2V5IFRoZSBuYW1lIG9mIHRoZSBvcHRpb24gb3IgYSBvYmplY3Qgb2YgbXVsdGlwbGUga2V5LXZhbHVlIHBhaXJzXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbnxCb29sZWFufSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIG9wdGlvbiwgdW51c2VkIGlmIFwia2V5XCIgaXMgYSBvYmplY3RcbiAqIEByZXR1cm5zIHtNb25nb29zZX0gVGhlIHVzZWQgTW9uZ29vc2UgaW5zdG5hY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgY29uc3QgX21vbmdvb3NlID0gdGhpcyBpbnN0YW5jZW9mIE1vbmdvb3NlID8gdGhpcyA6IG1vbmdvb3NlO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBrZXkgIT09ICdvYmplY3QnKSB7XG4gICAgaWYgKFZBTElEX09QVElPTlMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgU2V0T3B0aW9uRXJyb3IoKTtcbiAgICAgIGVycm9yLmFkZEVycm9yKGtleSwgbmV3IFNldE9wdGlvbkVycm9yLlNldE9wdGlvbklubmVyRXJyb3Ioa2V5KSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICByZXR1cm4gX21vbmdvb3NlLm9wdGlvbnNba2V5XTtcbiAgfVxuXG4gIGxldCBvcHRpb25zID0ge307XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBvcHRpb25zID0geyBba2V5XTogdmFsdWUgfTtcbiAgfVxuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgb3B0aW9ucyA9IGtleTtcbiAgfVxuXG4gIC8vIGFycmF5IGZvciBlcnJvcnMgdG8gY29sbGVjdCBhbGwgZXJyb3JzIGZvciBhbGwga2V5LXZhbHVlIHBhaXJzLCBsaWtlIFwiLnZhbGlkYXRlXCJcbiAgbGV0IGVycm9yID0gdW5kZWZpbmVkO1xuXG4gIGZvciAoY29uc3QgW29wdGlvbktleSwgb3B0aW9uVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMpKSB7XG4gICAgaWYgKFZBTElEX09QVElPTlMuaW5kZXhPZihvcHRpb25LZXkpID09PSAtMSkge1xuICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICBlcnJvciA9IG5ldyBTZXRPcHRpb25FcnJvcigpO1xuICAgICAgfVxuICAgICAgZXJyb3IuYWRkRXJyb3Iob3B0aW9uS2V5LCBuZXcgU2V0T3B0aW9uRXJyb3IuU2V0T3B0aW9uSW5uZXJFcnJvcihvcHRpb25LZXkpKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIF9tb25nb29zZS5vcHRpb25zW29wdGlvbktleV0gPSBvcHRpb25WYWx1ZTtcblxuICAgIGlmIChvcHRpb25LZXkgPT09ICdvYmplY3RJZEdldHRlcicpIHtcbiAgICAgIGlmIChvcHRpb25WYWx1ZSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobW9uZ29vc2UuVHlwZXMuT2JqZWN0SWQucHJvdG90eXBlLCAnX2lkJywge1xuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBtb25nb29zZS5UeXBlcy5PYmplY3RJZC5wcm90b3R5cGUuX2lkO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChlcnJvcikge1xuICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgcmV0dXJuIF9tb25nb29zZTtcbn07XG5cbi8qKlxuICogR2V0cyBtb25nb29zZSBvcHRpb25zXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBtb25nb29zZS5nZXQoJ3Rlc3QnKSAvLyByZXR1cm5zIHRoZSAndGVzdCcgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAbWV0aG9kIGdldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuZ2V0ID0gTW9uZ29vc2UucHJvdG90eXBlLnNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgQ29ubmVjdGlvbiBpbnN0YW5jZS5cbiAqXG4gKiBFYWNoIGBjb25uZWN0aW9uYCBpbnN0YW5jZSBtYXBzIHRvIGEgc2luZ2xlIGRhdGFiYXNlLiBUaGlzIG1ldGhvZCBpcyBoZWxwZnVsIHdoZW4gbWFuYWdpbmcgbXVsdGlwbGUgZGIgY29ubmVjdGlvbnMuXG4gKlxuICpcbiAqIF9PcHRpb25zIHBhc3NlZCB0YWtlIHByZWNlZGVuY2Ugb3ZlciBvcHRpb25zIGluY2x1ZGVkIGluIGNvbm5lY3Rpb24gc3RyaW5ncy5fXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyB3aXRoIG1vbmdvZGI6Ly8gVVJJXG4gKiAgICAgZGIgPSBtb25nb29zZS5jcmVhdGVDb25uZWN0aW9uKCdtb25nb2RiOi8vdXNlcjpwYXNzQDEyNy4wLjAuMTpwb3J0L2RhdGFiYXNlJyk7XG4gKlxuICogICAgIC8vIGFuZCBvcHRpb25zXG4gKiAgICAgY29uc3Qgb3B0cyA9IHsgZGI6IHsgbmF0aXZlX3BhcnNlcjogdHJ1ZSB9fVxuICogICAgIGRiID0gbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbignbW9uZ29kYjovL3VzZXI6cGFzc0AxMjcuMC4wLjE6cG9ydC9kYXRhYmFzZScsIG9wdHMpO1xuICpcbiAqICAgICAvLyByZXBsaWNhIHNldHNcbiAqICAgICBkYiA9IG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oJ21vbmdvZGI6Ly91c2VyOnBhc3NAMTI3LjAuMC4xOnBvcnQsYW5vdGhlcmhvc3Q6cG9ydCx5ZXRhbm90aGVyOnBvcnQvZGF0YWJhc2UnKTtcbiAqXG4gKiAgICAgLy8gYW5kIG9wdGlvbnNcbiAqICAgICBjb25zdCBvcHRzID0geyByZXBsc2V0OiB7IHN0cmF0ZWd5OiAncGluZycsIHJzX25hbWU6ICd0ZXN0U2V0JyB9fVxuICogICAgIGRiID0gbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbignbW9uZ29kYjovL3VzZXI6cGFzc0AxMjcuMC4wLjE6cG9ydCxhbm90aGVyaG9zdDpwb3J0LHlldGFub3RoZXI6cG9ydC9kYXRhYmFzZScsIG9wdHMpO1xuICpcbiAqICAgICAvLyBpbml0aWFsaXplIG5vdywgY29ubmVjdCBsYXRlclxuICogICAgIGRiID0gbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbigpO1xuICogICAgIGRiLm9wZW5VcmkoJzEyNy4wLjAuMScsICdkYXRhYmFzZScsIHBvcnQsIFtvcHRzXSk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVyaSBtb25nb2RiIFVSSSB0byBjb25uZWN0IHRvXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIHBhc3NlZCBkb3duIHRvIHRoZSBbTW9uZ29EQiBkcml2ZXIncyBgY29ubmVjdCgpYCBmdW5jdGlvbl0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL01vbmdvQ2xpZW50T3B0aW9ucy5odG1sKSwgZXhjZXB0IGZvciA0IG1vbmdvb3NlLXNwZWNpZmljIG9wdGlvbnMgZXhwbGFpbmVkIGJlbG93LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5idWZmZXJDb21tYW5kcz10cnVlXSBNb25nb29zZSBzcGVjaWZpYyBvcHRpb24uIFNldCB0byBmYWxzZSB0byBbZGlzYWJsZSBidWZmZXJpbmddKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9mYXEuaHRtbCNjYWxsYmFja19uZXZlcl9leGVjdXRlcykgb24gYWxsIG1vZGVscyBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb25uZWN0aW9uLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmRiTmFtZV0gVGhlIG5hbWUgb2YgdGhlIGRhdGFiYXNlIHlvdSB3YW50IHRvIHVzZS4gSWYgbm90IHByb3ZpZGVkLCBNb25nb29zZSB1c2VzIHRoZSBkYXRhYmFzZSBuYW1lIGZyb20gY29ubmVjdGlvbiBzdHJpbmcuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudXNlcl0gdXNlcm5hbWUgZm9yIGF1dGhlbnRpY2F0aW9uLCBlcXVpdmFsZW50IHRvIGBvcHRpb25zLmF1dGgudXNlcmAuIE1haW50YWluZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBhc3NdIHBhc3N3b3JkIGZvciBhdXRoZW50aWNhdGlvbiwgZXF1aXZhbGVudCB0byBgb3B0aW9ucy5hdXRoLnBhc3N3b3JkYC4gTWFpbnRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9JbmRleD10cnVlXSBNb25nb29zZS1zcGVjaWZpYyBvcHRpb24uIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIGF1dG9tYXRpYyBpbmRleCBjcmVhdGlvbiBmb3IgYWxsIG1vZGVscyBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb25uZWN0aW9uLlxuICogQHBhcmFtIHtDbGFzc30gW29wdGlvbnMucHJvbWlzZUxpYnJhcnldIFNldHMgdGhlIFt1bmRlcmx5aW5nIGRyaXZlcidzIHByb21pc2UgbGlicmFyeV0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL01vbmdvQ2xpZW50T3B0aW9ucy5odG1sI3Byb21pc2VMaWJyYXJ5KS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhQb29sU2l6ZT01XSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc29ja2V0cyB0aGUgTW9uZ29EQiBkcml2ZXIgd2lsbCBrZWVwIG9wZW4gZm9yIHRoaXMgY29ubmVjdGlvbi4gS2VlcCBpbiBtaW5kIHRoYXQgTW9uZ29EQiBvbmx5IGFsbG93cyBvbmUgb3BlcmF0aW9uIHBlciBzb2NrZXQgYXQgYSB0aW1lLCBzbyB5b3UgbWF5IHdhbnQgdG8gaW5jcmVhc2UgdGhpcyBpZiB5b3UgZmluZCB5b3UgaGF2ZSBhIGZldyBzbG93IHF1ZXJpZXMgdGhhdCBhcmUgYmxvY2tpbmcgZmFzdGVyIHF1ZXJpZXMgZnJvbSBwcm9jZWVkaW5nLiBTZWUgW1Nsb3cgVHJhaW5zIGluIE1vbmdvREIgYW5kIE5vZGUuanNdKGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vc2xvdy10cmFpbnMtaW4tbW9uZ29kYi1hbmQtbm9kZWpzKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5taW5Qb29sU2l6ZT0xXSBUaGUgbWluaW11bSBudW1iZXIgb2Ygc29ja2V0cyB0aGUgTW9uZ29EQiBkcml2ZXIgd2lsbCBrZWVwIG9wZW4gZm9yIHRoaXMgY29ubmVjdGlvbi4gS2VlcCBpbiBtaW5kIHRoYXQgTW9uZ29EQiBvbmx5IGFsbG93cyBvbmUgb3BlcmF0aW9uIHBlciBzb2NrZXQgYXQgYSB0aW1lLCBzbyB5b3UgbWF5IHdhbnQgdG8gaW5jcmVhc2UgdGhpcyBpZiB5b3UgZmluZCB5b3UgaGF2ZSBhIGZldyBzbG93IHF1ZXJpZXMgdGhhdCBhcmUgYmxvY2tpbmcgZmFzdGVyIHF1ZXJpZXMgZnJvbSBwcm9jZWVkaW5nLiBTZWUgW1Nsb3cgVHJhaW5zIGluIE1vbmdvREIgYW5kIE5vZGUuanNdKGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vc2xvdy10cmFpbnMtaW4tbW9uZ29kYi1hbmQtbm9kZWpzKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zb2NrZXRUaW1lb3V0TVM9MF0gSG93IGxvbmcgdGhlIE1vbmdvREIgZHJpdmVyIHdpbGwgd2FpdCBiZWZvcmUga2lsbGluZyBhIHNvY2tldCBkdWUgdG8gaW5hY3Rpdml0eSBfYWZ0ZXIgaW5pdGlhbCBjb25uZWN0aW9uXy4gRGVmYXVsdHMgdG8gMCwgd2hpY2ggbWVhbnMgTm9kZS5qcyB3aWxsIG5vdCB0aW1lIG91dCB0aGUgc29ja2V0IGR1ZSB0byBpbmFjdGl2aXR5LiBBIHNvY2tldCBtYXkgYmUgaW5hY3RpdmUgYmVjYXVzZSBvZiBlaXRoZXIgbm8gYWN0aXZpdHkgb3IgYSBsb25nLXJ1bm5pbmcgb3BlcmF0aW9uLiBUaGlzIG9wdGlvbiBpcyBwYXNzZWQgdG8gW05vZGUuanMgYHNvY2tldCNzZXRUaW1lb3V0KClgIGZ1bmN0aW9uXShodHRwczovL25vZGVqcy5vcmcvYXBpL25ldC5odG1sI25ldF9zb2NrZXRfc2V0dGltZW91dF90aW1lb3V0X2NhbGxiYWNrKSBhZnRlciB0aGUgTW9uZ29EQiBkcml2ZXIgc3VjY2Vzc2Z1bGx5IGNvbXBsZXRlcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5mYW1pbHk9MF0gUGFzc2VkIHRyYW5zcGFyZW50bHkgdG8gW05vZGUuanMnIGBkbnMubG9va3VwKClgXShodHRwczovL25vZGVqcy5vcmcvYXBpL2Rucy5odG1sI2Ruc19kbnNfbG9va3VwX2hvc3RuYW1lX29wdGlvbnNfY2FsbGJhY2spIGZ1bmN0aW9uLiBNYXkgYmUgZWl0aGVyIGAwYCwgYDRgLCBvciBgNmAuIGA0YCBtZWFucyB1c2UgSVB2NCBvbmx5LCBgNmAgbWVhbnMgdXNlIElQdjYgb25seSwgYDBgIG1lYW5zIHRyeSBib3RoLlxuICogQHJldHVybiB7Q29ubmVjdGlvbn0gdGhlIGNyZWF0ZWQgQ29ubmVjdGlvbiBvYmplY3QuIENvbm5lY3Rpb25zIGFyZSBub3QgdGhlbmFibGUsIHNvIHlvdSBjYW4ndCBkbyBgYXdhaXQgbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbigpYC4gVG8gYXdhaXQgdXNlIGBtb25nb29zZS5jcmVhdGVDb25uZWN0aW9uKHVyaSkuYXNQcm9taXNlKClgIGluc3RlYWQuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5jcmVhdGVDb25uZWN0aW9uID0gZnVuY3Rpb24odXJpLCBvcHRpb25zKSB7XG4gIGNvbnN0IF9tb25nb29zZSA9IHRoaXMgaW5zdGFuY2VvZiBNb25nb29zZSA/IHRoaXMgOiBtb25nb29zZTtcblxuICBjb25zdCBDb25uZWN0aW9uID0gX21vbmdvb3NlLl9fZHJpdmVyLkNvbm5lY3Rpb247XG4gIGNvbnN0IGNvbm4gPSBuZXcgQ29ubmVjdGlvbihfbW9uZ29vc2UpO1xuICBfbW9uZ29vc2UuY29ubmVjdGlvbnMucHVzaChjb25uKTtcbiAgX21vbmdvb3NlLm5leHRDb25uZWN0aW9uSWQrKztcbiAgX21vbmdvb3NlLmV2ZW50cy5lbWl0KCdjcmVhdGVDb25uZWN0aW9uJywgY29ubik7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgY29ubi5vcGVuVXJpKHVyaSwgeyAuLi5vcHRpb25zLCBfZmlyZUFuZEZvcmdldDogdHJ1ZSB9KTtcbiAgfVxuXG4gIHJldHVybiBjb25uO1xufTtcblxuLyoqXG4gKiBPcGVucyB0aGUgZGVmYXVsdCBtb25nb29zZSBjb25uZWN0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgbW9uZ29vc2UuY29ubmVjdCgnbW9uZ29kYjovL3VzZXI6cGFzc0AxMjcuMC4wLjE6cG9ydC9kYXRhYmFzZScpO1xuICpcbiAqICAgICAvLyByZXBsaWNhIHNldHNcbiAqICAgICBjb25zdCB1cmkgPSAnbW9uZ29kYjovL3VzZXI6cGFzc0AxMjcuMC4wLjE6cG9ydCxhbm90aGVyaG9zdDpwb3J0LHlldGFub3RoZXI6cG9ydC9teWRhdGFiYXNlJztcbiAqICAgICBtb25nb29zZS5jb25uZWN0KHVyaSk7XG4gKlxuICogICAgIC8vIHdpdGggb3B0aW9uc1xuICogICAgIG1vbmdvb3NlLmNvbm5lY3QodXJpLCBvcHRpb25zKTtcbiAqXG4gKiAgICAgLy8gb3B0aW9uYWwgY2FsbGJhY2sgdGhhdCBnZXRzIGZpcmVkIHdoZW4gaW5pdGlhbCBjb25uZWN0aW9uIGNvbXBsZXRlZFxuICogICAgIGNvbnN0IHVyaSA9ICdtb25nb2RiOi8vbm9uZXhpc3RlbnQuZG9tYWluOjI3MDAwJztcbiAqICAgICBtb25nb29zZS5jb25uZWN0KHVyaSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAqICAgICAgIC8vIGlmIGVycm9yIGlzIHRydXRoeSwgdGhlIGluaXRpYWwgY29ubmVjdGlvbiBmYWlsZWQuXG4gKiAgICAgfSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJpIG1vbmdvZGIgVVJJIHRvIGNvbm5lY3QgdG9cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gcGFzc2VkIGRvd24gdG8gdGhlIFtNb25nb0RCIGRyaXZlcidzIGBjb25uZWN0KClgIGZ1bmN0aW9uXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvTW9uZ29DbGllbnRPcHRpb25zLmh0bWwpLCBleGNlcHQgZm9yIDQgbW9uZ29vc2Utc3BlY2lmaWMgb3B0aW9ucyBleHBsYWluZWQgYmVsb3cuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJ1ZmZlckNvbW1hbmRzPXRydWVdIE1vbmdvb3NlIHNwZWNpZmljIG9wdGlvbi4gU2V0IHRvIGZhbHNlIHRvIFtkaXNhYmxlIGJ1ZmZlcmluZ10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2ZhcS5odG1sI2NhbGxiYWNrX25ldmVyX2V4ZWN1dGVzKSBvbiBhbGwgbW9kZWxzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbm5lY3Rpb24uXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYnVmZmVyVGltZW91dE1TPTEwMDAwXSBNb25nb29zZSBzcGVjaWZpYyBvcHRpb24uIElmIGBidWZmZXJDb21tYW5kc2AgaXMgdHJ1ZSwgTW9uZ29vc2Ugd2lsbCB0aHJvdyBhbiBlcnJvciBhZnRlciBgYnVmZmVyVGltZW91dE1TYCBpZiB0aGUgb3BlcmF0aW9uIGlzIHN0aWxsIGJ1ZmZlcmVkLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmRiTmFtZV0gVGhlIG5hbWUgb2YgdGhlIGRhdGFiYXNlIHdlIHdhbnQgdG8gdXNlLiBJZiBub3QgcHJvdmlkZWQsIHVzZSBkYXRhYmFzZSBuYW1lIGZyb20gY29ubmVjdGlvbiBzdHJpbmcuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudXNlcl0gdXNlcm5hbWUgZm9yIGF1dGhlbnRpY2F0aW9uLCBlcXVpdmFsZW50IHRvIGBvcHRpb25zLmF1dGgudXNlcmAuIE1haW50YWluZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBhc3NdIHBhc3N3b3JkIGZvciBhdXRoZW50aWNhdGlvbiwgZXF1aXZhbGVudCB0byBgb3B0aW9ucy5hdXRoLnBhc3N3b3JkYC4gTWFpbnRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UG9vbFNpemU9MTAwXSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc29ja2V0cyB0aGUgTW9uZ29EQiBkcml2ZXIgd2lsbCBrZWVwIG9wZW4gZm9yIHRoaXMgY29ubmVjdGlvbi4gS2VlcCBpbiBtaW5kIHRoYXQgTW9uZ29EQiBvbmx5IGFsbG93cyBvbmUgb3BlcmF0aW9uIHBlciBzb2NrZXQgYXQgYSB0aW1lLCBzbyB5b3UgbWF5IHdhbnQgdG8gaW5jcmVhc2UgdGhpcyBpZiB5b3UgZmluZCB5b3UgaGF2ZSBhIGZldyBzbG93IHF1ZXJpZXMgdGhhdCBhcmUgYmxvY2tpbmcgZmFzdGVyIHF1ZXJpZXMgZnJvbSBwcm9jZWVkaW5nLiBTZWUgW1Nsb3cgVHJhaW5zIGluIE1vbmdvREIgYW5kIE5vZGUuanNdKGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vc2xvdy10cmFpbnMtaW4tbW9uZ29kYi1hbmQtbm9kZWpzKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5taW5Qb29sU2l6ZT0wXSBUaGUgbWluaW11bSBudW1iZXIgb2Ygc29ja2V0cyB0aGUgTW9uZ29EQiBkcml2ZXIgd2lsbCBrZWVwIG9wZW4gZm9yIHRoaXMgY29ubmVjdGlvbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zZXJ2ZXJTZWxlY3Rpb25UaW1lb3V0TVNdIElmIGB1c2VVbmlmaWVkVG9wb2xvZ3kgPSB0cnVlYCwgdGhlIE1vbmdvREIgZHJpdmVyIHdpbGwgdHJ5IHRvIGZpbmQgYSBzZXJ2ZXIgdG8gc2VuZCBhbnkgZ2l2ZW4gb3BlcmF0aW9uIHRvLCBhbmQga2VlcCByZXRyeWluZyBmb3IgYHNlcnZlclNlbGVjdGlvblRpbWVvdXRNU2AgbWlsbGlzZWNvbmRzIGJlZm9yZSBlcnJvcmluZyBvdXQuIElmIG5vdCBzZXQsIHRoZSBNb25nb0RCIGRyaXZlciBkZWZhdWx0cyB0byB1c2luZyBgMzAwMDBgICgzMCBzZWNvbmRzKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWFydGJlYXRGcmVxdWVuY3lNU10gSWYgYHVzZVVuaWZpZWRUb3BvbG9neSA9IHRydWVgLCB0aGUgTW9uZ29EQiBkcml2ZXIgc2VuZHMgYSBoZWFydGJlYXQgZXZlcnkgYGhlYXJ0YmVhdEZyZXF1ZW5jeU1TYCB0byBjaGVjayBvbiB0aGUgc3RhdHVzIG9mIHRoZSBjb25uZWN0aW9uLiBBIGhlYXJ0YmVhdCBpcyBzdWJqZWN0IHRvIGBzZXJ2ZXJTZWxlY3Rpb25UaW1lb3V0TVNgLCBzbyB0aGUgTW9uZ29EQiBkcml2ZXIgd2lsbCByZXRyeSBmYWlsZWQgaGVhcnRiZWF0cyBmb3IgdXAgdG8gMzAgc2Vjb25kcyBieSBkZWZhdWx0LiBNb25nb29zZSBvbmx5IGVtaXRzIGEgYCdkaXNjb25uZWN0ZWQnYCBldmVudCBhZnRlciBhIGhlYXJ0YmVhdCBoYXMgZmFpbGVkLCBzbyB5b3UgbWF5IHdhbnQgdG8gZGVjcmVhc2UgdGhpcyBzZXR0aW5nIHRvIHJlZHVjZSB0aGUgdGltZSBiZXR3ZWVuIHdoZW4geW91ciBzZXJ2ZXIgZ29lcyBkb3duIGFuZCB3aGVuIE1vbmdvb3NlIGVtaXRzIGAnZGlzY29ubmVjdGVkJ2AuIFdlIHJlY29tbWVuZCB5b3UgZG8gKipub3QqKiBzZXQgdGhpcyBzZXR0aW5nIGJlbG93IDEwMDAsIHRvbyBtYW55IGhlYXJ0YmVhdHMgY2FuIGxlYWQgdG8gcGVyZm9ybWFuY2UgZGVncmFkYXRpb24uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9JbmRleD10cnVlXSBNb25nb29zZS1zcGVjaWZpYyBvcHRpb24uIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIGF1dG9tYXRpYyBpbmRleCBjcmVhdGlvbiBmb3IgYWxsIG1vZGVscyBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb25uZWN0aW9uLlxuICogQHBhcmFtIHtDbGFzc30gW29wdGlvbnMucHJvbWlzZUxpYnJhcnldIFNldHMgdGhlIFt1bmRlcmx5aW5nIGRyaXZlcidzIHByb21pc2UgbGlicmFyeV0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL01vbmdvQ2xpZW50T3B0aW9ucy5odG1sI3Byb21pc2VMaWJyYXJ5KS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zb2NrZXRUaW1lb3V0TVM9MF0gSG93IGxvbmcgdGhlIE1vbmdvREIgZHJpdmVyIHdpbGwgd2FpdCBiZWZvcmUga2lsbGluZyBhIHNvY2tldCBkdWUgdG8gaW5hY3Rpdml0eSBfYWZ0ZXIgaW5pdGlhbCBjb25uZWN0aW9uXy4gQSBzb2NrZXQgbWF5IGJlIGluYWN0aXZlIGJlY2F1c2Ugb2YgZWl0aGVyIG5vIGFjdGl2aXR5IG9yIGEgbG9uZy1ydW5uaW5nIG9wZXJhdGlvbi4gYHNvY2tldFRpbWVvdXRNU2AgZGVmYXVsdHMgdG8gMCwgd2hpY2ggbWVhbnMgTm9kZS5qcyB3aWxsIG5vdCB0aW1lIG91dCB0aGUgc29ja2V0IGR1ZSB0byBpbmFjdGl2aXR5LiBUaGlzIG9wdGlvbiBpcyBwYXNzZWQgdG8gW05vZGUuanMgYHNvY2tldCNzZXRUaW1lb3V0KClgIGZ1bmN0aW9uXShodHRwczovL25vZGVqcy5vcmcvYXBpL25ldC5odG1sI25ldF9zb2NrZXRfc2V0dGltZW91dF90aW1lb3V0X2NhbGxiYWNrKSBhZnRlciB0aGUgTW9uZ29EQiBkcml2ZXIgc3VjY2Vzc2Z1bGx5IGNvbXBsZXRlcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5mYW1pbHk9MF0gUGFzc2VkIHRyYW5zcGFyZW50bHkgdG8gW05vZGUuanMnIGBkbnMubG9va3VwKClgXShodHRwczovL25vZGVqcy5vcmcvYXBpL2Rucy5odG1sI2Ruc19kbnNfbG9va3VwX2hvc3RuYW1lX29wdGlvbnNfY2FsbGJhY2spIGZ1bmN0aW9uLiBNYXkgYmUgZWl0aGVyIGAwYCwgYDRgLCBvciBgNmAuIGA0YCBtZWFucyB1c2UgSVB2NCBvbmx5LCBgNmAgbWVhbnMgdXNlIElQdjYgb25seSwgYDBgIG1lYW5zIHRyeSBib3RoLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdXRvQ3JlYXRlPWZhbHNlXSBTZXQgdG8gYHRydWVgIHRvIG1ha2UgTW9uZ29vc2UgYXV0b21hdGljYWxseSBjYWxsIGBjcmVhdGVDb2xsZWN0aW9uKClgIG9uIGV2ZXJ5IG1vZGVsIGNyZWF0ZWQgb24gdGhpcyBjb25uZWN0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXVxuICogQHNlZSBNb25nb29zZSNjcmVhdGVDb25uZWN0aW9uIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9uZ29vc2UuaHRtbCNNb25nb29zZS5wcm90b3R5cGUuY3JlYXRlQ29ubmVjdGlvbigpXG4gKiBAYXBpIHB1YmxpY1xuICogQHJldHVybiB7UHJvbWlzZX0gcmVzb2x2ZXMgdG8gYHRoaXNgIGlmIGNvbm5lY3Rpb24gc3VjY2VlZGVkXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLmNvbm5lY3QgPSBhc3luYyBmdW5jdGlvbiBjb25uZWN0KHVyaSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgfHwgKGFyZ3VtZW50cy5sZW5ndGggPj0gMyAmJiB0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb25nb29zZS5wcm90b3R5cGUuY29ubmVjdCgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGNvbnN0IF9tb25nb29zZSA9IHRoaXMgaW5zdGFuY2VvZiBNb25nb29zZSA/IHRoaXMgOiBtb25nb29zZTtcbiAgY29uc3QgY29ubiA9IF9tb25nb29zZS5jb25uZWN0aW9uO1xuXG4gIHJldHVybiBjb25uLm9wZW5VcmkodXJpLCBvcHRpb25zKS50aGVuKCgpID0+IF9tb25nb29zZSk7XG59O1xuXG4vKipcbiAqIFJ1bnMgYC5jbG9zZSgpYCBvbiBhbGwgY29ubmVjdGlvbnMgaW4gcGFyYWxsZWwuXG4gKlxuICogQHJldHVybiB7UHJvbWlzZX0gcmVzb2x2ZXMgd2hlbiBhbGwgY29ubmVjdGlvbnMgYXJlIGNsb3NlZCwgb3IgcmVqZWN0cyB3aXRoIHRoZSBmaXJzdCBlcnJvciB0aGF0IG9jY3VycmVkLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGFzeW5jIGZ1bmN0aW9uIGRpc2Nvbm5lY3QoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDEgJiYgdHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNb25nb29zZS5wcm90b3R5cGUuZGlzY29ubmVjdCgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGNvbnN0IF9tb25nb29zZSA9IHRoaXMgaW5zdGFuY2VvZiBNb25nb29zZSA/IHRoaXMgOiBtb25nb29zZTtcblxuICBjb25zdCByZW1haW5pbmcgPSBfbW9uZ29vc2UuY29ubmVjdGlvbnMubGVuZ3RoO1xuICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYXdhaXQgUHJvbWlzZS5hbGwoX21vbmdvb3NlLmNvbm5lY3Rpb25zLm1hcChjb25uID0+IGNvbm4uY2xvc2UoKSkpO1xufTtcblxuLyoqXG4gKiBfUmVxdWlyZXMgTW9uZ29EQiA+PSAzLjYuMC5fIFN0YXJ0cyBhIFtNb25nb0RCIHNlc3Npb25dKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlbGVhc2Utbm90ZXMvMy42LyNjbGllbnQtc2Vzc2lvbnMpXG4gKiBmb3IgYmVuZWZpdHMgbGlrZSBjYXVzYWwgY29uc2lzdGVuY3ksIFtyZXRyeWFibGUgd3JpdGVzXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9jb3JlL3JldHJ5YWJsZS13cml0ZXMvKSxcbiAqIGFuZCBbdHJhbnNhY3Rpb25zXShodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tL2Etbm9kZS1qcy1wZXJzcGVjdGl2ZS1vbi1tb25nb2RiLTQtdHJhbnNhY3Rpb25zLmh0bWwpLlxuICpcbiAqIENhbGxpbmcgYG1vbmdvb3NlLnN0YXJ0U2Vzc2lvbigpYCBpcyBlcXVpdmFsZW50IHRvIGNhbGxpbmcgYG1vbmdvb3NlLmNvbm5lY3Rpb24uc3RhcnRTZXNzaW9uKClgLlxuICogU2Vzc2lvbnMgYXJlIHNjb3BlZCB0byBhIGNvbm5lY3Rpb24sIHNvIGNhbGxpbmcgYG1vbmdvb3NlLnN0YXJ0U2Vzc2lvbigpYFxuICogc3RhcnRzIGEgc2Vzc2lvbiBvbiB0aGUgW2RlZmF1bHQgbW9uZ29vc2UgY29ubmVjdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb25nb29zZS5odG1sI01vbmdvb3NlLnByb3RvdHlwZS5jb25uZWN0aW9uKS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIHNlZSB0aGUgW21vbmdvZGIgZHJpdmVyIG9wdGlvbnNdKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9Nb25nb0NsaWVudC5odG1sI3N0YXJ0U2Vzc2lvbilcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2F1c2FsQ29uc2lzdGVuY3k9dHJ1ZV0gc2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgY2F1c2FsIGNvbnNpc3RlbmN5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdXG4gKiBAcmV0dXJuIHtQcm9taXNlPENsaWVudFNlc3Npb24+fSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBNb25nb0RCIGRyaXZlciBgQ2xpZW50U2Vzc2lvbmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLnN0YXJ0U2Vzc2lvbiA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBfbW9uZ29vc2UgPSB0aGlzIGluc3RhbmNlb2YgTW9uZ29vc2UgPyB0aGlzIDogbW9uZ29vc2U7XG5cbiAgcmV0dXJuIF9tb25nb29zZS5jb25uZWN0aW9uLnN0YXJ0U2Vzc2lvbi5hcHBseShfbW9uZ29vc2UuY29ubmVjdGlvbiwgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogR2V0dGVyL3NldHRlciBhcm91bmQgZnVuY3Rpb24gZm9yIHBsdXJhbGl6aW5nIGNvbGxlY3Rpb24gbmFtZXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbnxudWxsfSBbZm5dIG92ZXJ3cml0ZXMgdGhlIGZ1bmN0aW9uIHVzZWQgdG8gcGx1cmFsaXplIGNvbGxlY3Rpb24gbmFtZXNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufG51bGx9IHRoZSBjdXJyZW50IGZ1bmN0aW9uIHVzZWQgdG8gcGx1cmFsaXplIGNvbGxlY3Rpb24gbmFtZXMsIGRlZmF1bHRzIHRvIHRoZSBsZWdhY3kgZnVuY3Rpb24gZnJvbSBgbW9uZ29vc2UtbGVnYWN5LXBsdXJhbGl6ZWAuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5wbHVyYWxpemUgPSBmdW5jdGlvbihmbikge1xuICBjb25zdCBfbW9uZ29vc2UgPSB0aGlzIGluc3RhbmNlb2YgTW9uZ29vc2UgPyB0aGlzIDogbW9uZ29vc2U7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgX21vbmdvb3NlLl9wbHVyYWxpemUgPSBmbjtcbiAgfVxuICByZXR1cm4gX21vbmdvb3NlLl9wbHVyYWxpemU7XG59O1xuXG4vKipcbiAqIERlZmluZXMgYSBtb2RlbCBvciByZXRyaWV2ZXMgaXQuXG4gKlxuICogTW9kZWxzIGRlZmluZWQgb24gdGhlIGBtb25nb29zZWAgaW5zdGFuY2UgYXJlIGF2YWlsYWJsZSB0byBhbGwgY29ubmVjdGlvblxuICogY3JlYXRlZCBieSB0aGUgc2FtZSBgbW9uZ29vc2VgIGluc3RhbmNlLlxuICpcbiAqIElmIHlvdSBjYWxsIGBtb25nb29zZS5tb2RlbCgpYCB3aXRoIHR3aWNlIHRoZSBzYW1lIG5hbWUgYnV0IGEgZGlmZmVyZW50IHNjaGVtYSxcbiAqIHlvdSB3aWxsIGdldCBhbiBgT3ZlcndyaXRlTW9kZWxFcnJvcmAuIElmIHlvdSBjYWxsIGBtb25nb29zZS5tb2RlbCgpYCB3aXRoXG4gKiB0aGUgc2FtZSBuYW1lIGFuZCBzYW1lIHNjaGVtYSwgeW91J2xsIGdldCB0aGUgc2FtZSBzY2hlbWEgYmFjay5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IG1vbmdvb3NlID0gcmVxdWlyZSgnbW9uZ29vc2UnKTtcbiAqXG4gKiAgICAgLy8gZGVmaW5lIGFuIEFjdG9yIG1vZGVsIHdpdGggdGhpcyBtb25nb29zZSBpbnN0YW5jZVxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSk7XG4gKiAgICAgbW9uZ29vc2UubW9kZWwoJ0FjdG9yJywgc2NoZW1hKTtcbiAqXG4gKiAgICAgLy8gY3JlYXRlIGEgbmV3IGNvbm5lY3Rpb25cbiAqICAgICBjb25zdCBjb25uID0gbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbiguLik7XG4gKlxuICogICAgIC8vIGNyZWF0ZSBBY3RvciBtb2RlbFxuICogICAgIGNvbnN0IEFjdG9yID0gY29ubi5tb2RlbCgnQWN0b3InLCBzY2hlbWEpO1xuICogICAgIGNvbm4ubW9kZWwoJ0FjdG9yJykgPT09IEFjdG9yOyAvLyB0cnVlXG4gKiAgICAgY29ubi5tb2RlbCgnQWN0b3InLCBzY2hlbWEpID09PSBBY3RvcjsgLy8gdHJ1ZSwgc2FtZSBzY2hlbWFcbiAqICAgICBjb25uLm1vZGVsKCdBY3RvcicsIHNjaGVtYSwgJ2FjdG9ycycpID09PSBBY3RvcjsgLy8gdHJ1ZSwgc2FtZSBzY2hlbWEgYW5kIGNvbGxlY3Rpb24gbmFtZVxuICpcbiAqICAgICAvLyBUaGlzIHRocm93cyBhbiBgT3ZlcndyaXRlTW9kZWxFcnJvcmAgYmVjYXVzZSB0aGUgc2NoZW1hIGlzIGRpZmZlcmVudC5cbiAqICAgICBjb25uLm1vZGVsKCdBY3RvcicsIG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSkpO1xuICpcbiAqIF9XaGVuIG5vIGBjb2xsZWN0aW9uYCBhcmd1bWVudCBpcyBwYXNzZWQsIE1vbmdvb3NlIHVzZXMgdGhlIG1vZGVsIG5hbWUuIElmIHlvdSBkb24ndCBsaWtlIHRoaXMgYmVoYXZpb3IsIGVpdGhlciBwYXNzIGEgY29sbGVjdGlvbiBuYW1lLCB1c2UgYG1vbmdvb3NlLnBsdXJhbGl6ZSgpYCwgb3Igc2V0IHlvdXIgc2NoZW1hcyBjb2xsZWN0aW9uIG5hbWUgb3B0aW9uLl9cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSwgeyBjb2xsZWN0aW9uOiAnYWN0b3InIH0pO1xuICpcbiAqICAgICAvLyBvclxuICpcbiAqICAgICBzY2hlbWEuc2V0KCdjb2xsZWN0aW9uJywgJ2FjdG9yJyk7XG4gKlxuICogICAgIC8vIG9yXG4gKlxuICogICAgIGNvbnN0IGNvbGxlY3Rpb25OYW1lID0gJ2FjdG9yJztcbiAqICAgICBjb25zdCBNID0gbW9uZ29vc2UubW9kZWwoJ0FjdG9yJywgc2NoZW1hLCBjb2xsZWN0aW9uTmFtZSk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IG5hbWUgbW9kZWwgbmFtZSBvciBjbGFzcyBleHRlbmRpbmcgTW9kZWxcbiAqIEBwYXJhbSB7U2NoZW1hfSBbc2NoZW1hXSB0aGUgc2NoZW1hIHRvIHVzZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbY29sbGVjdGlvbl0gbmFtZSAob3B0aW9uYWwsIGluZmVycmVkIGZyb20gbW9kZWwgbmFtZSlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMub3ZlcndyaXRlTW9kZWxzPWZhbHNlXSBJZiB0cnVlLCBvdmVyd3JpdGUgZXhpc3RpbmcgbW9kZWxzIHdpdGggdGhlIHNhbWUgbmFtZSB0byBhdm9pZCBgT3ZlcndyaXRlTW9kZWxFcnJvcmBcbiAqIEByZXR1cm4ge01vZGVsfSBUaGUgbW9kZWwgYXNzb2NpYXRlZCB3aXRoIGBuYW1lYC4gTW9uZ29vc2Ugd2lsbCBjcmVhdGUgdGhlIG1vZGVsIGlmIGl0IGRvZXNuJ3QgYWxyZWFkeSBleGlzdC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLm1vZGVsID0gZnVuY3Rpb24obmFtZSwgc2NoZW1hLCBjb2xsZWN0aW9uLCBvcHRpb25zKSB7XG4gIGNvbnN0IF9tb25nb29zZSA9IHRoaXMgaW5zdGFuY2VvZiBNb25nb29zZSA/IHRoaXMgOiBtb25nb29zZTtcblxuICBpZiAodHlwZW9mIHNjaGVtYSA9PT0gJ3N0cmluZycpIHtcbiAgICBjb2xsZWN0aW9uID0gc2NoZW1hO1xuICAgIHNjaGVtYSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCBtb2RlbCA9IF9tb25nb29zZS5tb2RlbHNbbmFtZV07XG4gICAgaWYgKCFtb2RlbCkge1xuICAgICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IuTWlzc2luZ1NjaGVtYUVycm9yKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cblxuICBpZiAodXRpbHMuaXNPYmplY3Qoc2NoZW1hKSAmJiAhKHNjaGVtYSBpbnN0YW5jZW9mIFNjaGVtYSkpIHtcbiAgICBzY2hlbWEgPSBuZXcgU2NoZW1hKHNjaGVtYSk7XG4gIH1cbiAgaWYgKHNjaGVtYSAmJiAhKHNjaGVtYSBpbnN0YW5jZW9mIFNjaGVtYSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSAybmQgcGFyYW1ldGVyIHRvIGBtb25nb29zZS5tb2RlbCgpYCBzaG91bGQgYmUgYSAnICtcbiAgICAgICdzY2hlbWEgb3IgYSBQT0pPJyk7XG4gIH1cblxuICAvLyBoYW5kbGUgaW50ZXJuYWwgb3B0aW9ucyBmcm9tIGNvbm5lY3Rpb24ubW9kZWwoKVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBjb25zdCBvcmlnaW5hbFNjaGVtYSA9IHNjaGVtYTtcbiAgaWYgKHNjaGVtYSkge1xuICAgIGlmIChfbW9uZ29vc2UuZ2V0KCdjbG9uZVNjaGVtYXMnKSkge1xuICAgICAgc2NoZW1hID0gc2NoZW1hLmNsb25lKCk7XG4gICAgfVxuICAgIF9tb25nb29zZS5fYXBwbHlQbHVnaW5zKHNjaGVtYSk7XG4gIH1cblxuICAvLyBjb25uZWN0aW9uLm1vZGVsKCkgbWF5IGJlIHBhc3NpbmcgYSBkaWZmZXJlbnQgc2NoZW1hIGZvclxuICAvLyBhbiBleGlzdGluZyBtb2RlbCBuYW1lLiBpbiB0aGlzIGNhc2UgZG9uJ3QgcmVhZCBmcm9tIGNhY2hlLlxuICBjb25zdCBvdmVyd3JpdGVNb2RlbHMgPSBfbW9uZ29vc2Uub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnb3ZlcndyaXRlTW9kZWxzJykgP1xuICAgIF9tb25nb29zZS5vcHRpb25zLm92ZXJ3cml0ZU1vZGVscyA6XG4gICAgb3B0aW9ucy5vdmVyd3JpdGVNb2RlbHM7XG4gIGlmIChfbW9uZ29vc2UubW9kZWxzLmhhc093blByb3BlcnR5KG5hbWUpICYmIG9wdGlvbnMuY2FjaGUgIT09IGZhbHNlICYmIG92ZXJ3cml0ZU1vZGVscyAhPT0gdHJ1ZSkge1xuICAgIGlmIChvcmlnaW5hbFNjaGVtYSAmJlxuICAgICAgICBvcmlnaW5hbFNjaGVtYS5pbnN0YW5jZU9mU2NoZW1hICYmXG4gICAgICAgIG9yaWdpbmFsU2NoZW1hICE9PSBfbW9uZ29vc2UubW9kZWxzW25hbWVdLnNjaGVtYSkge1xuICAgICAgdGhyb3cgbmV3IF9tb25nb29zZS5FcnJvci5PdmVyd3JpdGVNb2RlbEVycm9yKG5hbWUpO1xuICAgIH1cbiAgICBpZiAoY29sbGVjdGlvbiAmJiBjb2xsZWN0aW9uICE9PSBfbW9uZ29vc2UubW9kZWxzW25hbWVdLmNvbGxlY3Rpb24ubmFtZSkge1xuICAgICAgLy8gc3ViY2xhc3MgY3VycmVudCBtb2RlbCB3aXRoIGFsdGVybmF0ZSBjb2xsZWN0aW9uXG4gICAgICBjb25zdCBtb2RlbCA9IF9tb25nb29zZS5tb2RlbHNbbmFtZV07XG4gICAgICBzY2hlbWEgPSBtb2RlbC5wcm90b3R5cGUuc2NoZW1hO1xuICAgICAgY29uc3Qgc3ViID0gbW9kZWwuX19zdWJjbGFzcyhfbW9uZ29vc2UuY29ubmVjdGlvbiwgc2NoZW1hLCBjb2xsZWN0aW9uKTtcbiAgICAgIC8vIGRvIG5vdCBjYWNoZSB0aGUgc3ViIG1vZGVsXG4gICAgICByZXR1cm4gc3ViO1xuICAgIH1cbiAgICByZXR1cm4gX21vbmdvb3NlLm1vZGVsc1tuYW1lXTtcbiAgfVxuICBpZiAoc2NoZW1hID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgX21vbmdvb3NlLkVycm9yLk1pc3NpbmdTY2hlbWFFcnJvcihuYW1lKTtcbiAgfVxuXG4gIGNvbnN0IG1vZGVsID0gX21vbmdvb3NlLl9tb2RlbChuYW1lLCBzY2hlbWEsIGNvbGxlY3Rpb24sIG9wdGlvbnMpO1xuICBfbW9uZ29vc2UuY29ubmVjdGlvbi5tb2RlbHNbbmFtZV0gPSBtb2RlbDtcbiAgX21vbmdvb3NlLm1vZGVsc1tuYW1lXSA9IG1vZGVsO1xuXG4gIHJldHVybiBtb2RlbDtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLl9tb2RlbCA9IGZ1bmN0aW9uKG5hbWUsIHNjaGVtYSwgY29sbGVjdGlvbiwgb3B0aW9ucykge1xuICBjb25zdCBfbW9uZ29vc2UgPSB0aGlzIGluc3RhbmNlb2YgTW9uZ29vc2UgPyB0aGlzIDogbW9uZ29vc2U7XG5cbiAgbGV0IG1vZGVsO1xuICBpZiAodHlwZW9mIG5hbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBtb2RlbCA9IG5hbWU7XG4gICAgbmFtZSA9IG1vZGVsLm5hbWU7XG4gICAgaWYgKCEobW9kZWwucHJvdG90eXBlIGluc3RhbmNlb2YgTW9kZWwpKSB7XG4gICAgICB0aHJvdyBuZXcgX21vbmdvb3NlLkVycm9yKCdUaGUgcHJvdmlkZWQgY2xhc3MgJyArIG5hbWUgKyAnIG11c3QgZXh0ZW5kIE1vZGVsJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNjaGVtYSkge1xuICAgIGlmIChfbW9uZ29vc2UuZ2V0KCdjbG9uZVNjaGVtYXMnKSkge1xuICAgICAgc2NoZW1hID0gc2NoZW1hLmNsb25lKCk7XG4gICAgfVxuICAgIF9tb25nb29zZS5fYXBwbHlQbHVnaW5zKHNjaGVtYSk7XG4gIH1cblxuICAvLyBBcHBseSByZWxldmFudCBcImdsb2JhbFwiIG9wdGlvbnMgdG8gdGhlIHNjaGVtYVxuICBpZiAoc2NoZW1hID09IG51bGwgfHwgISgncGx1cmFsaXphdGlvbicgaW4gc2NoZW1hLm9wdGlvbnMpKSB7XG4gICAgc2NoZW1hLm9wdGlvbnMucGx1cmFsaXphdGlvbiA9IF9tb25nb29zZS5vcHRpb25zLnBsdXJhbGl6YXRpb247XG4gIH1cblxuICBpZiAoIWNvbGxlY3Rpb24pIHtcbiAgICBjb2xsZWN0aW9uID0gc2NoZW1hLmdldCgnY29sbGVjdGlvbicpIHx8XG4gICAgICB1dGlscy50b0NvbGxlY3Rpb25OYW1lKG5hbWUsIF9tb25nb29zZS5wbHVyYWxpemUoKSk7XG4gIH1cblxuICBjb25zdCBjb25uZWN0aW9uID0gb3B0aW9ucy5jb25uZWN0aW9uIHx8IF9tb25nb29zZS5jb25uZWN0aW9uO1xuICBtb2RlbCA9IF9tb25nb29zZS5Nb2RlbC5jb21waWxlKG1vZGVsIHx8IG5hbWUsIHNjaGVtYSwgY29sbGVjdGlvbiwgY29ubmVjdGlvbiwgX21vbmdvb3NlKTtcbiAgLy8gRXJyb3JzIGhhbmRsZWQgaW50ZXJuYWxseSwgc28gc2FmZSB0byBpZ25vcmUgZXJyb3JcbiAgbW9kZWwuaW5pdCgpLmNhdGNoKGZ1bmN0aW9uICRtb2RlbEluaXROb29wKCkge30pO1xuXG4gIGNvbm5lY3Rpb24uZW1pdCgnbW9kZWwnLCBtb2RlbCk7XG5cbiAgaWYgKHNjaGVtYS5fYXBwbHlEaXNjcmltaW5hdG9ycyAhPSBudWxsKSB7XG4gICAgZm9yIChjb25zdCBkaXNjIG9mIHNjaGVtYS5fYXBwbHlEaXNjcmltaW5hdG9ycy5rZXlzKCkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2NoZW1hOiBkaXNjcmltaW5hdG9yU2NoZW1hLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9ID0gc2NoZW1hLl9hcHBseURpc2NyaW1pbmF0b3JzLmdldChkaXNjKTtcbiAgICAgIG1vZGVsLmRpc2NyaW1pbmF0b3IoZGlzYywgZGlzY3JpbWluYXRvclNjaGVtYSwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgYXBwbHlFbWJlZGRlZERpc2NyaW1pbmF0b3JzKHNjaGVtYSk7XG5cbiAgcmV0dXJuIG1vZGVsO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBtb2RlbCBuYW1lZCBgbmFtZWAgZnJvbSB0aGUgZGVmYXVsdCBjb25uZWN0aW9uLCBpZiBpdCBleGlzdHMuXG4gKiBZb3UgY2FuIHVzZSB0aGlzIGZ1bmN0aW9uIHRvIGNsZWFuIHVwIGFueSBtb2RlbHMgeW91IGNyZWF0ZWQgaW4geW91ciB0ZXN0cyB0b1xuICogcHJldmVudCBPdmVyd3JpdGVNb2RlbEVycm9ycy5cbiAqXG4gKiBFcXVpdmFsZW50IHRvIGBtb25nb29zZS5jb25uZWN0aW9uLmRlbGV0ZU1vZGVsKG5hbWUpYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIG1vbmdvb3NlLm1vZGVsKCdVc2VyJywgbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZyB9KSk7XG4gKiAgICAgY29uc29sZS5sb2cobW9uZ29vc2UubW9kZWwoJ1VzZXInKSk7IC8vIE1vZGVsIG9iamVjdFxuICogICAgIG1vbmdvb3NlLmRlbGV0ZU1vZGVsKCdVc2VyJyk7XG4gKiAgICAgY29uc29sZS5sb2cobW9uZ29vc2UubW9kZWwoJ1VzZXInKSk7IC8vIHVuZGVmaW5lZFxuICpcbiAqICAgICAvLyBVc3VhbGx5IHVzZWZ1bCBpbiBhIE1vY2hhIGBhZnRlckVhY2goKWAgaG9va1xuICogICAgIGFmdGVyRWFjaChmdW5jdGlvbigpIHtcbiAqICAgICAgIG1vbmdvb3NlLmRlbGV0ZU1vZGVsKC8uKy8pOyAvLyBEZWxldGUgZXZlcnkgbW9kZWxcbiAqICAgICB9KTtcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBuYW1lIGlmIHN0cmluZywgdGhlIG5hbWUgb2YgdGhlIG1vZGVsIHRvIHJlbW92ZS4gSWYgcmVnZXhwLCByZW1vdmVzIGFsbCBtb2RlbHMgd2hvc2UgbmFtZSBtYXRjaGVzIHRoZSByZWdleHAuXG4gKiBAcmV0dXJuIHtNb25nb29zZX0gdGhpc1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5kZWxldGVNb2RlbCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgY29uc3QgX21vbmdvb3NlID0gdGhpcyBpbnN0YW5jZW9mIE1vbmdvb3NlID8gdGhpcyA6IG1vbmdvb3NlO1xuXG4gIF9tb25nb29zZS5jb25uZWN0aW9uLmRlbGV0ZU1vZGVsKG5hbWUpO1xuICBkZWxldGUgX21vbmdvb3NlLm1vZGVsc1tuYW1lXTtcbiAgcmV0dXJuIF9tb25nb29zZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBtb2RlbCBuYW1lcyBjcmVhdGVkIG9uIHRoaXMgaW5zdGFuY2Ugb2YgTW9uZ29vc2UuXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIF9Eb2VzIG5vdCBpbmNsdWRlIG5hbWVzIG9mIG1vZGVscyBjcmVhdGVkIHVzaW5nIGBjb25uZWN0aW9uLm1vZGVsKClgLl9cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLm1vZGVsTmFtZXMgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgX21vbmdvb3NlID0gdGhpcyBpbnN0YW5jZW9mIE1vbmdvb3NlID8gdGhpcyA6IG1vbmdvb3NlO1xuXG4gIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoX21vbmdvb3NlLm1vZGVscyk7XG4gIHJldHVybiBuYW1lcztcbn07XG5cbi8qKlxuICogQXBwbGllcyBnbG9iYWwgcGx1Z2lucyB0byBgc2NoZW1hYC5cbiAqXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuX2FwcGx5UGx1Z2lucyA9IGZ1bmN0aW9uKHNjaGVtYSwgb3B0aW9ucykge1xuICBjb25zdCBfbW9uZ29vc2UgPSB0aGlzIGluc3RhbmNlb2YgTW9uZ29vc2UgPyB0aGlzIDogbW9uZ29vc2U7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuYXBwbHlQbHVnaW5zVG9EaXNjcmltaW5hdG9ycyA9IF9tb25nb29zZS5vcHRpb25zICYmIF9tb25nb29zZS5vcHRpb25zLmFwcGx5UGx1Z2luc1RvRGlzY3JpbWluYXRvcnMgfHwgZmFsc2U7XG4gIG9wdGlvbnMuYXBwbHlQbHVnaW5zVG9DaGlsZFNjaGVtYXMgPSB0eXBlb2YgKF9tb25nb29zZS5vcHRpb25zICYmIF9tb25nb29zZS5vcHRpb25zLmFwcGx5UGx1Z2luc1RvQ2hpbGRTY2hlbWFzKSA9PT0gJ2Jvb2xlYW4nID9cbiAgICBfbW9uZ29vc2Uub3B0aW9ucy5hcHBseVBsdWdpbnNUb0NoaWxkU2NoZW1hcyA6XG4gICAgdHJ1ZTtcbiAgYXBwbHlQbHVnaW5zKHNjaGVtYSwgX21vbmdvb3NlLnBsdWdpbnMsIG9wdGlvbnMsICckZ2xvYmFsUGx1Z2luc0FwcGxpZWQnKTtcbn07XG5cbi8qKlxuICogRGVjbGFyZXMgYSBnbG9iYWwgcGx1Z2luIGV4ZWN1dGVkIG9uIGFsbCBTY2hlbWFzLlxuICpcbiAqIEVxdWl2YWxlbnQgdG8gY2FsbGluZyBgLnBsdWdpbihmbilgIG9uIGVhY2ggU2NoZW1hIHlvdSBjcmVhdGUuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gcGx1Z2luIGNhbGxiYWNrXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIG9wdGlvbmFsIG9wdGlvbnNcbiAqIEByZXR1cm4ge01vbmdvb3NlfSB0aGlzXG4gKiBAc2VlIHBsdWdpbnMgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3BsdWdpbnMuaHRtbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUucGx1Z2luID0gZnVuY3Rpb24oZm4sIG9wdHMpIHtcbiAgY29uc3QgX21vbmdvb3NlID0gdGhpcyBpbnN0YW5jZW9mIE1vbmdvb3NlID8gdGhpcyA6IG1vbmdvb3NlO1xuXG4gIF9tb25nb29zZS5wbHVnaW5zLnB1c2goW2ZuLCBvcHRzXSk7XG4gIHJldHVybiBfbW9uZ29vc2U7XG59O1xuXG4vKipcbiAqIFRoZSBNb25nb29zZSBtb2R1bGUncyBkZWZhdWx0IGNvbm5lY3Rpb24uIEVxdWl2YWxlbnQgdG8gYG1vbmdvb3NlLmNvbm5lY3Rpb25zWzBdYCwgc2VlIFtgY29ubmVjdGlvbnNgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vbmdvb3NlLmh0bWwjTW9uZ29vc2UucHJvdG90eXBlLmNvbm5lY3Rpb25zKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IG1vbmdvb3NlID0gcmVxdWlyZSgnbW9uZ29vc2UnKTtcbiAqICAgICBtb25nb29zZS5jb25uZWN0KC4uLik7XG4gKiAgICAgbW9uZ29vc2UuY29ubmVjdGlvbi5vbignZXJyb3InLCBjYik7XG4gKlxuICogVGhpcyBpcyB0aGUgY29ubmVjdGlvbiB1c2VkIGJ5IGRlZmF1bHQgZm9yIGV2ZXJ5IG1vZGVsIGNyZWF0ZWQgdXNpbmcgW21vbmdvb3NlLm1vZGVsXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vbmdvb3NlLmh0bWwjTW9uZ29vc2UucHJvdG90eXBlLm1vZGVsKCkpLlxuICpcbiAqIFRvIGNyZWF0ZSBhIG5ldyBjb25uZWN0aW9uLCB1c2UgW2BjcmVhdGVDb25uZWN0aW9uKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vbmdvb3NlLmh0bWwjTW9uZ29vc2UucHJvdG90eXBlLmNyZWF0ZUNvbm5lY3Rpb24oKSkuXG4gKlxuICogQG1lbWJlck9mIE1vbmdvb3NlXG4gKiBAaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7Q29ubmVjdGlvbn0gY29ubmVjdGlvblxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuX19kZWZpbmVHZXR0ZXJfXygnY29ubmVjdGlvbicsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5jb25uZWN0aW9uc1swXTtcbn0pO1xuXG5Nb25nb29zZS5wcm90b3R5cGUuX19kZWZpbmVTZXR0ZXJfXygnY29ubmVjdGlvbicsIGZ1bmN0aW9uKHYpIHtcbiAgaWYgKHYgaW5zdGFuY2VvZiB0aGlzLl9fZHJpdmVyLkNvbm5lY3Rpb24pIHtcbiAgICB0aGlzLmNvbm5lY3Rpb25zWzBdID0gdjtcbiAgICB0aGlzLm1vZGVscyA9IHYubW9kZWxzO1xuICB9XG59KTtcblxuLyoqXG4gKiBBbiBhcnJheSBjb250YWluaW5nIGFsbCBbY29ubmVjdGlvbnNdKGNvbm5lY3Rpb24uaHRtbCkgYXNzb2NpYXRlZCB3aXRoIHRoaXNcbiAqIE1vbmdvb3NlIGluc3RhbmNlLiBCeSBkZWZhdWx0LCB0aGVyZSBpcyAxIGNvbm5lY3Rpb24uIENhbGxpbmdcbiAqIFtgY3JlYXRlQ29ubmVjdGlvbigpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb25nb29zZS5odG1sI01vbmdvb3NlLnByb3RvdHlwZS5jcmVhdGVDb25uZWN0aW9uKCkpIGFkZHMgYSBjb25uZWN0aW9uXG4gKiB0byB0aGlzIGFycmF5LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgbW9uZ29vc2UgPSByZXF1aXJlKCdtb25nb29zZScpO1xuICogICAgIG1vbmdvb3NlLmNvbm5lY3Rpb25zLmxlbmd0aDsgLy8gMSwganVzdCB0aGUgZGVmYXVsdCBjb25uZWN0aW9uXG4gKiAgICAgbW9uZ29vc2UuY29ubmVjdGlvbnNbMF0gPT09IG1vbmdvb3NlLmNvbm5lY3Rpb247IC8vIHRydWVcbiAqXG4gKiAgICAgbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbignbW9uZ29kYjovLzEyNy4wLjAuMToyNzAxNy90ZXN0Jyk7XG4gKiAgICAgbW9uZ29vc2UuY29ubmVjdGlvbnMubGVuZ3RoOyAvLyAyXG4gKlxuICogQG1lbWJlck9mIE1vbmdvb3NlXG4gKiBAaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7QXJyYXl9IGNvbm5lY3Rpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5jb25uZWN0aW9ucztcblxuLyoqXG4gKiBBbiBpbnRlZ2VyIGNvbnRhaW5pbmcgdGhlIHZhbHVlIG9mIHRoZSBuZXh0IGNvbm5lY3Rpb24gaWQuIENhbGxpbmdcbiAqIFtgY3JlYXRlQ29ubmVjdGlvbigpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb25nb29zZS5odG1sI01vbmdvb3NlLnByb3RvdHlwZS5jcmVhdGVDb25uZWN0aW9uKCkpIGluY3JlbWVudHNcbiAqIHRoaXMgdmFsdWUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBtb25nb29zZSA9IHJlcXVpcmUoJ21vbmdvb3NlJyk7XG4gKiAgICAgbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbigpOyAvLyBpZCBgMGAsIGBuZXh0Q29ubmVjdGlvbklkYCBiZWNvbWVzIGAxYFxuICogICAgIG1vbmdvb3NlLmNyZWF0ZUNvbm5lY3Rpb24oKTsgLy8gaWQgYDFgLCBgbmV4dENvbm5lY3Rpb25JZGAgYmVjb21lcyBgMmBcbiAqICAgICBtb25nb29zZS5jb25uZWN0aW9uc1swXS5kZXN0cm95KCkgLy8gUmVtb3ZlcyBjb25uZWN0aW9uIHdpdGggaWQgYDBgXG4gKiAgICAgbW9uZ29vc2UuY3JlYXRlQ29ubmVjdGlvbigpOyAvLyBpZCBgMmAsIGBuZXh0Q29ubmVjdGlvbklkYCBiZWNvbWVzIGAzYFxuICpcbiAqIEBtZW1iZXJPZiBNb25nb29zZVxuICogQGluc3RhbmNlXG4gKiBAcHJvcGVydHkge051bWJlcn0gbmV4dENvbm5lY3Rpb25JZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLm5leHRDb25uZWN0aW9uSWQ7XG5cbi8qKlxuICogVGhlIE1vbmdvb3NlIEFnZ3JlZ2F0ZSBjb25zdHJ1Y3RvclxuICpcbiAqIEBtZXRob2QgQWdncmVnYXRlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5BZ2dyZWdhdGUgPSBBZ2dyZWdhdGU7XG5cbi8qKlxuICogVGhlIE1vbmdvb3NlIENvbGxlY3Rpb24gY29uc3RydWN0b3JcbiAqXG4gKiBAbWVtYmVyT2YgTW9uZ29vc2VcbiAqIEBpbnN0YW5jZVxuICogQG1ldGhvZCBDb2xsZWN0aW9uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb25nb29zZS5wcm90b3R5cGUsICdDb2xsZWN0aW9uJywge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9fZHJpdmVyLkNvbGxlY3Rpb247XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oQ29sbGVjdGlvbikge1xuICAgIHRoaXMuX19kcml2ZXIuQ29sbGVjdGlvbiA9IENvbGxlY3Rpb247XG4gIH1cbn0pO1xuXG4vKipcbiAqIFRoZSBNb25nb29zZSBbQ29ubmVjdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9jb25uZWN0aW9uLmh0bWwjQ29ubmVjdGlvbigpKSBjb25zdHJ1Y3RvclxuICpcbiAqIEBtZW1iZXJPZiBNb25nb29zZVxuICogQGluc3RhbmNlXG4gKiBAbWV0aG9kIENvbm5lY3Rpb25cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vbmdvb3NlLnByb3RvdHlwZSwgJ0Nvbm5lY3Rpb24nLCB7XG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX19kcml2ZXIuQ29ubmVjdGlvbjtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihDb25uZWN0aW9uKSB7XG4gICAgaWYgKENvbm5lY3Rpb24gPT09IHRoaXMuX19kcml2ZXIuQ29ubmVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX19kcml2ZXIuQ29ubmVjdGlvbiA9IENvbm5lY3Rpb247XG4gIH1cbn0pO1xuXG4vKipcbiAqIFRoZSBNb25nb29zZSB2ZXJzaW9uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zb2xlLmxvZyhtb25nb29zZS52ZXJzaW9uKTsgLy8gJzUueC54J1xuICpcbiAqIEBwcm9wZXJ0eSB2ZXJzaW9uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS52ZXJzaW9uID0gcGtnLnZlcnNpb247XG5cbi8qKlxuICogVGhlIE1vbmdvb3NlIGNvbnN0cnVjdG9yXG4gKlxuICogVGhlIGV4cG9ydHMgb2YgdGhlIG1vbmdvb3NlIG1vZHVsZSBpcyBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgbW9uZ29vc2UgPSByZXF1aXJlKCdtb25nb29zZScpO1xuICogICAgIGNvbnN0IG1vbmdvb3NlMiA9IG5ldyBtb25nb29zZS5Nb25nb29zZSgpO1xuICpcbiAqIEBtZXRob2QgTW9uZ29vc2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLk1vbmdvb3NlID0gTW9uZ29vc2U7XG5cbi8qKlxuICogVGhlIE1vbmdvb3NlIFtTY2hlbWFdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvc2NoZW1hLmh0bWwjU2NoZW1hKCkpIGNvbnN0cnVjdG9yXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBtb25nb29zZSA9IHJlcXVpcmUoJ21vbmdvb3NlJyk7XG4gKiAgICAgY29uc3QgU2NoZW1hID0gbW9uZ29vc2UuU2NoZW1hO1xuICogICAgIGNvbnN0IENhdFNjaGVtYSA9IG5ldyBTY2hlbWEoLi4pO1xuICpcbiAqIEBtZXRob2QgU2NoZW1hXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5TY2hlbWEgPSBTY2hlbWE7XG5cbi8qKlxuICogVGhlIE1vbmdvb3NlIFtTY2hlbWFUeXBlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3NjaGVtYXR5cGUuaHRtbCNTY2hlbWFUeXBlKCkpIGNvbnN0cnVjdG9yXG4gKlxuICogQG1ldGhvZCBTY2hlbWFUeXBlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5TY2hlbWFUeXBlID0gU2NoZW1hVHlwZTtcblxuLyoqXG4gKiBUaGUgdmFyaW91cyBNb25nb29zZSBTY2hlbWFUeXBlcy5cbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogX0FsaWFzIG9mIG1vbmdvb3NlLlNjaGVtYS5UeXBlcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuX1xuICpcbiAqIEBwcm9wZXJ0eSBTY2hlbWFUeXBlc1xuICogQHNlZSBTY2hlbWEuU2NoZW1hVHlwZXMgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLlNjaGVtYVR5cGVzID0gU2NoZW1hLlR5cGVzO1xuXG4vKipcbiAqIFRoZSBNb25nb29zZSBbVmlydHVhbFR5cGVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvdmlydHVhbHR5cGUuaHRtbCNWaXJ0dWFsVHlwZSgpKSBjb25zdHJ1Y3RvclxuICpcbiAqIEBtZXRob2QgVmlydHVhbFR5cGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLlZpcnR1YWxUeXBlID0gVmlydHVhbFR5cGU7XG5cbi8qKlxuICogVGhlIHZhcmlvdXMgTW9uZ29vc2UgVHlwZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBtb25nb29zZSA9IHJlcXVpcmUoJ21vbmdvb3NlJyk7XG4gKiAgICAgY29uc3QgYXJyYXkgPSBtb25nb29zZS5UeXBlcy5BcnJheTtcbiAqXG4gKiAjIyMjIFR5cGVzOlxuICpcbiAqIC0gW0FycmF5XShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3Mvc2NoZW1hdHlwZXMuaHRtbCNhcnJheXMpXG4gKiAtIFtCdWZmZXJdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zY2hlbWF0eXBlcy5odG1sI2J1ZmZlcnMpXG4gKiAtIFtFbWJlZGRlZF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWwjc2NoZW1hcylcbiAqIC0gW0RvY3VtZW50QXJyYXldKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnRhcnJheXBhdGguaHRtbClcbiAqIC0gW0RlY2ltYWwxMjhdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9uZ29vc2UuaHRtbCNNb25nb29zZS5wcm90b3R5cGUuRGVjaW1hbDEyOClcbiAqIC0gW09iamVjdElkXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3Mvc2NoZW1hdHlwZXMuaHRtbCNvYmplY3RpZHMpXG4gKiAtIFtNYXBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zY2hlbWF0eXBlcy5odG1sI21hcHMpXG4gKiAtIFtTdWJkb2N1bWVudF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWwjc2NoZW1hcylcbiAqXG4gKiBVc2luZyB0aGlzIGV4cG9zZWQgYWNjZXNzIHRvIHRoZSBgT2JqZWN0SWRgIHR5cGUsIHdlIGNhbiBjb25zdHJ1Y3QgaWRzIG9uIGRlbWFuZC5cbiAqXG4gKiAgICAgY29uc3QgT2JqZWN0SWQgPSBtb25nb29zZS5UeXBlcy5PYmplY3RJZDtcbiAqICAgICBjb25zdCBpZDEgPSBuZXcgT2JqZWN0SWQ7XG4gKlxuICogQHByb3BlcnR5IFR5cGVzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5UeXBlcyA9IFR5cGVzO1xuXG4vKipcbiAqIFRoZSBNb25nb29zZSBbUXVlcnldKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeSgpKSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAbWV0aG9kIFF1ZXJ5XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5RdWVyeSA9IFF1ZXJ5O1xuXG4vKipcbiAqIFRoZSBNb25nb29zZSBbTW9kZWxdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbCgpKSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAbWV0aG9kIE1vZGVsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5Nb2RlbCA9IE1vZGVsO1xuXG4vKipcbiAqIFRoZSBNb25nb29zZSBbRG9jdW1lbnRdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudCgpKSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAbWV0aG9kIERvY3VtZW50XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5Eb2N1bWVudCA9IERvY3VtZW50O1xuXG4vKipcbiAqIFRoZSBNb25nb29zZSBEb2N1bWVudFByb3ZpZGVyIGNvbnN0cnVjdG9yLiBNb25nb29zZSB1c2VycyBzaG91bGQgbm90IGhhdmUgdG9cbiAqIHVzZSB0aGlzIGRpcmVjdGx5XG4gKlxuICogQG1ldGhvZCBEb2N1bWVudFByb3ZpZGVyXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5Eb2N1bWVudFByb3ZpZGVyID0gcmVxdWlyZSgnLi9kb2N1bWVudFByb3ZpZGVyJyk7XG5cbi8qKlxuICogVGhlIE1vbmdvb3NlIE9iamVjdElkIFtTY2hlbWFUeXBlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3Mvc2NoZW1hdHlwZXMuaHRtbCkuIFVzZWQgZm9yXG4gKiBkZWNsYXJpbmcgcGF0aHMgaW4geW91ciBzY2hlbWEgdGhhdCBzaG91bGQgYmVcbiAqIFtNb25nb0RCIE9iamVjdElkc10oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9PYmplY3RJZC8pLlxuICogRG8gbm90IHVzZSB0aGlzIHRvIGNyZWF0ZSBhIG5ldyBPYmplY3RJZCBpbnN0YW5jZSwgdXNlIGBtb25nb29zZS5UeXBlcy5PYmplY3RJZGBcbiAqIGluc3RlYWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBjaGlsZFNjaGVtYSA9IG5ldyBTY2hlbWEoeyBwYXJlbnRJZDogbW9uZ29vc2UuT2JqZWN0SWQgfSk7XG4gKlxuICogQHByb3BlcnR5IE9iamVjdElkXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5PYmplY3RJZCA9IFNjaGVtYVR5cGVzLk9iamVjdElkO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBNb25nb29zZSBjYW4gY2FzdCB0aGUgZ2l2ZW4gdmFsdWUgdG8gYW4gT2JqZWN0SWQsIG9yXG4gKiBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBtb25nb29zZS5pc1ZhbGlkT2JqZWN0SWQobmV3IG1vbmdvb3NlLlR5cGVzLk9iamVjdElkKCkpOyAvLyB0cnVlXG4gKiAgICAgbW9uZ29vc2UuaXNWYWxpZE9iamVjdElkKCcwMTIzNDU2Nzg5YWInKTsgLy8gdHJ1ZVxuICogICAgIG1vbmdvb3NlLmlzVmFsaWRPYmplY3RJZCg2KTsgLy8gdHJ1ZVxuICogICAgIG1vbmdvb3NlLmlzVmFsaWRPYmplY3RJZChuZXcgVXNlcih7IG5hbWU6ICd0ZXN0JyB9KSk7IC8vIHRydWVcbiAqXG4gKiAgICAgbW9uZ29vc2UuaXNWYWxpZE9iamVjdElkKHsgdGVzdDogNDIgfSk7IC8vIGZhbHNlXG4gKlxuICogQG1ldGhvZCBpc1ZhbGlkT2JqZWN0SWRcbiAqIEBwYXJhbSB7QW55fSB2XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBgdmAgaXMgc29tZXRoaW5nIE1vbmdvb3NlIGNhbiBjb2VyY2UgdG8gYW4gT2JqZWN0SWRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLmlzVmFsaWRPYmplY3RJZCA9IGZ1bmN0aW9uKHYpIHtcbiAgY29uc3QgX21vbmdvb3NlID0gdGhpcyBpbnN0YW5jZW9mIE1vbmdvb3NlID8gdGhpcyA6IG1vbmdvb3NlO1xuICByZXR1cm4gX21vbmdvb3NlLlR5cGVzLk9iamVjdElkLmlzVmFsaWQodik7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBNb25nb29zZSBPYmplY3RJZCAodXNpbmcgYGluc3RhbmNlb2ZgKSBvciBpZiB0aGVcbiAqIGdpdmVuIHZhbHVlIGlzIGEgMjQgY2hhcmFjdGVyIGhleCBzdHJpbmcsIHdoaWNoIGlzIHRoZSBtb3N0IGNvbW1vbmx5IHVzZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gKiBvZiBhbiBPYmplY3RJZC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHNpbWlsYXIgdG8gYGlzVmFsaWRPYmplY3RJZCgpYCwgYnV0IGNvbnNpZGVyYWJseSBtb3JlIHN0cmljdCwgYmVjYXVzZVxuICogYGlzVmFsaWRPYmplY3RJZCgpYCB3aWxsIHJldHVybiBgdHJ1ZWAgZm9yIF9hbnlfIHZhbHVlIHRoYXQgTW9uZ29vc2UgY2FuIGNvbnZlcnQgdG8gYW5cbiAqIE9iamVjdElkLiBUaGF0IGluY2x1ZGVzIE1vbmdvb3NlIGRvY3VtZW50cywgYW55IHN0cmluZyBvZiBsZW5ndGggMTIsIGFuZCBhbnkgbnVtYmVyLlxuICogYGlzT2JqZWN0SWRPckhleFN0cmluZygpYCByZXR1cm5zIHRydWUgb25seSBmb3IgYE9iamVjdElkYCBpbnN0YW5jZXMgb3IgMjQgY2hhcmFjdGVyIGhleFxuICogc3RyaW5ncywgYW5kIHdpbGwgcmV0dXJuIGZhbHNlIGZvciBudW1iZXJzLCBkb2N1bWVudHMsIGFuZCBzdHJpbmdzIG9mIGxlbmd0aCAxMi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIG1vbmdvb3NlLmlzT2JqZWN0SWRPckhleFN0cmluZyhuZXcgbW9uZ29vc2UuVHlwZXMuT2JqZWN0SWQoKSk7IC8vIHRydWVcbiAqICAgICBtb25nb29zZS5pc09iamVjdElkT3JIZXhTdHJpbmcoJzYyMjYxYTY1ZDY2YzZiZTBhNjNjMDUxZicpOyAvLyB0cnVlXG4gKlxuICogICAgIG1vbmdvb3NlLmlzT2JqZWN0SWRPckhleFN0cmluZygnMDEyMzQ1Njc4OWFiJyk7IC8vIGZhbHNlXG4gKiAgICAgbW9uZ29vc2UuaXNPYmplY3RJZE9ySGV4U3RyaW5nKDYpOyAvLyBmYWxzZVxuICogICAgIG1vbmdvb3NlLmlzT2JqZWN0SWRPckhleFN0cmluZyhuZXcgVXNlcih7IG5hbWU6ICd0ZXN0JyB9KSk7IC8vIGZhbHNlXG4gKiAgICAgbW9uZ29vc2UuaXNPYmplY3RJZE9ySGV4U3RyaW5nKHsgdGVzdDogNDIgfSk7IC8vIGZhbHNlXG4gKlxuICogQG1ldGhvZCBpc09iamVjdElkT3JIZXhTdHJpbmdcbiAqIEBwYXJhbSB7QW55fSB2XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBgdmAgaXMgYW4gT2JqZWN0SWQgaW5zdGFuY2UgX29yXyBhIDI0IGNoYXIgaGV4IHN0cmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuaXNPYmplY3RJZE9ySGV4U3RyaW5nID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gaXNCc29uVHlwZSh2LCAnT2JqZWN0SWQnKSB8fCAodHlwZW9mIHYgPT09ICdzdHJpbmcnICYmIG9iamVjdElkSGV4UmVnZXhwLnRlc3QodikpO1xufTtcblxuLyoqXG4gKlxuICogU3luY3MgYWxsIHRoZSBpbmRleGVzIGZvciB0aGUgbW9kZWxzIHJlZ2lzdGVyZWQgd2l0aCB0aGlzIGNvbm5lY3Rpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5jb250aW51ZU9uRXJyb3IgYGZhbHNlYCBieSBkZWZhdWx0LiBJZiBzZXQgdG8gYHRydWVgLCBtb25nb29zZSB3aWxsIG5vdCB0aHJvdyBhbiBlcnJvciBpZiBvbmUgbW9kZWwgc3luY2luZyBmYWlsZWQsIGFuZCB3aWxsIHJldHVybiBhbiBvYmplY3Qgd2hlcmUgdGhlIGtleXMgYXJlIHRoZSBuYW1lcyBvZiB0aGUgbW9kZWxzLCBhbmQgdGhlIHZhbHVlcyBhcmUgdGhlIHJlc3VsdHMvZXJyb3JzIGZvciBlYWNoIG1vZGVsLlxuICogQHJldHVybiB7UHJvbWlzZX0gUmV0dXJucyBhIFByb21pc2UsIHdoZW4gdGhlIFByb21pc2UgcmVzb2x2ZXMgdGhlIHZhbHVlIGlzIGEgbGlzdCBvZiB0aGUgZHJvcHBlZCBpbmRleGVzLlxuICovXG5Nb25nb29zZS5wcm90b3R5cGUuc3luY0luZGV4ZXMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGNvbnN0IF9tb25nb29zZSA9IHRoaXMgaW5zdGFuY2VvZiBNb25nb29zZSA/IHRoaXMgOiBtb25nb29zZTtcbiAgcmV0dXJuIF9tb25nb29zZS5jb25uZWN0aW9uLnN5bmNJbmRleGVzKG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBUaGUgTW9uZ29vc2UgRGVjaW1hbDEyOCBbU2NoZW1hVHlwZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWwpLiBVc2VkIGZvclxuICogZGVjbGFyaW5nIHBhdGhzIGluIHlvdXIgc2NoZW1hIHRoYXQgc2hvdWxkIGJlXG4gKiBbMTI4LWJpdCBkZWNpbWFsIGZsb2F0aW5nIHBvaW50c10oaHR0cHM6Ly90aGVjb2RlYmFyYmFyaWFuLmNvbS9hLW5vZGVqcy1wZXJzcGVjdGl2ZS1vbi1tb25nb2RiLTM0LWRlY2ltYWwuaHRtbCkuXG4gKiBEbyBub3QgdXNlIHRoaXMgdG8gY3JlYXRlIGEgbmV3IERlY2ltYWwxMjggaW5zdGFuY2UsIHVzZSBgbW9uZ29vc2UuVHlwZXMuRGVjaW1hbDEyOGBcbiAqIGluc3RlYWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCB2ZWhpY2xlU2NoZW1hID0gbmV3IFNjaGVtYSh7IGZ1ZWxMZXZlbDogbW9uZ29vc2UuRGVjaW1hbDEyOCB9KTtcbiAqXG4gKiBAcHJvcGVydHkgRGVjaW1hbDEyOFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuRGVjaW1hbDEyOCA9IFNjaGVtYVR5cGVzLkRlY2ltYWwxMjg7XG5cbi8qKlxuICogVGhlIE1vbmdvb3NlIE1peGVkIFtTY2hlbWFUeXBlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3Mvc2NoZW1hdHlwZXMuaHRtbCkuIFVzZWQgZm9yXG4gKiBkZWNsYXJpbmcgcGF0aHMgaW4geW91ciBzY2hlbWEgdGhhdCBNb25nb29zZSdzIGNoYW5nZSB0cmFja2luZywgY2FzdGluZyxcbiAqIGFuZCB2YWxpZGF0aW9uIHNob3VsZCBpZ25vcmUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgYXJiaXRyYXJ5OiBtb25nb29zZS5NaXhlZCB9KTtcbiAqXG4gKiBAcHJvcGVydHkgTWl4ZWRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLk1peGVkID0gU2NoZW1hVHlwZXMuTWl4ZWQ7XG5cbi8qKlxuICogVGhlIE1vbmdvb3NlIERhdGUgW1NjaGVtYVR5cGVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zY2hlbWF0eXBlcy5odG1sKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyB0ZXN0OiBEYXRlIH0pO1xuICogICAgIHNjaGVtYS5wYXRoKCd0ZXN0JykgaW5zdGFuY2VvZiBtb25nb29zZS5EYXRlOyAvLyB0cnVlXG4gKlxuICogQHByb3BlcnR5IERhdGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLkRhdGUgPSBTY2hlbWFUeXBlcy5EYXRlO1xuXG4vKipcbiAqIFRoZSBNb25nb29zZSBOdW1iZXIgW1NjaGVtYVR5cGVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zY2hlbWF0eXBlcy5odG1sKS4gVXNlZCBmb3JcbiAqIGRlY2xhcmluZyBwYXRocyBpbiB5b3VyIHNjaGVtYSB0aGF0IE1vbmdvb3NlIHNob3VsZCBjYXN0IHRvIG51bWJlcnMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbnVtOiBtb25nb29zZS5OdW1iZXIgfSk7XG4gKiAgICAgLy8gRXF1aXZhbGVudCB0bzpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbnVtOiAnbnVtYmVyJyB9KTtcbiAqXG4gKiBAcHJvcGVydHkgTnVtYmVyXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5OdW1iZXIgPSBTY2hlbWFUeXBlcy5OdW1iZXI7XG5cbi8qKlxuICogVGhlIFtNb25nb29zZUVycm9yXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2Vycm9yLmh0bWwjRXJyb3IoKSkgY29uc3RydWN0b3IuXG4gKlxuICogQG1ldGhvZCBFcnJvclxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL2luZGV4Jyk7XG5Nb25nb29zZS5wcm90b3R5cGUuTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3IvbW9uZ29vc2VFcnJvcicpO1xuXG4vKipcbiAqIE1vbmdvb3NlIHVzZXMgdGhpcyBmdW5jdGlvbiB0byBnZXQgdGhlIGN1cnJlbnQgdGltZSB3aGVuIHNldHRpbmdcbiAqIFt0aW1lc3RhbXBzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0aW1lc3RhbXBzKS4gWW91IG1heSBzdHViIG91dCB0aGlzIGZ1bmN0aW9uXG4gKiB1c2luZyBhIHRvb2wgbGlrZSBbU2lub25dKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL3Npbm9uKSBmb3IgdGVzdGluZy5cbiAqXG4gKiBAbWV0aG9kIG5vd1xuICogQHJldHVybnMgRGF0ZSB0aGUgY3VycmVudCB0aW1lXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5ub3cgPSBmdW5jdGlvbiBub3coKSB7IHJldHVybiBuZXcgRGF0ZSgpOyB9O1xuXG4vKipcbiAqIFRoZSBNb25nb29zZSBDYXN0RXJyb3IgY29uc3RydWN0b3JcbiAqXG4gKiBAbWV0aG9kIENhc3RFcnJvclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIG5hbWUgb2YgdGhlIHR5cGVcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZSBUaGUgdmFsdWUgdGhhdCBmYWlsZWQgdG8gY2FzdFxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggVGhlIHBhdGggYGEuYi5jYCBpbiB0aGUgZG9jIHdoZXJlIHRoaXMgY2FzdCBlcnJvciBvY2N1cnJlZFxuICogQHBhcmFtIHtFcnJvcn0gW3JlYXNvbl0gVGhlIG9yaWdpbmFsIGVycm9yIHRoYXQgd2FzIHRocm93blxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuQ2FzdEVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9jYXN0Jyk7XG5cbi8qKlxuICogVGhlIGNvbnN0cnVjdG9yIHVzZWQgZm9yIHNjaGVtYXR5cGUgb3B0aW9uc1xuICpcbiAqIEBtZXRob2QgU2NoZW1hVHlwZU9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLlNjaGVtYVR5cGVPcHRpb25zID0gcmVxdWlyZSgnLi9vcHRpb25zL3NjaGVtYVR5cGVPcHRpb25zJyk7XG5cbi8qKlxuICogVGhlIFttcXVlcnldKGh0dHBzOi8vZ2l0aHViLmNvbS9haGVja21hbm4vbXF1ZXJ5KSBxdWVyeSBidWlsZGVyIE1vbmdvb3NlIHVzZXMuXG4gKlxuICogQHByb3BlcnR5IG1xdWVyeVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUubXF1ZXJ5ID0gcmVxdWlyZSgnbXF1ZXJ5Jyk7XG5cbi8qKlxuICogU2FuaXRpemVzIHF1ZXJ5IGZpbHRlcnMgYWdhaW5zdCBbcXVlcnkgc2VsZWN0b3IgaW5qZWN0aW9uIGF0dGFja3NdKGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vMjAxNC8wOS8wNC9kZWZlbmRpbmctYWdhaW5zdC1xdWVyeS1zZWxlY3Rvci1pbmplY3Rpb24tYXR0YWNrcy5odG1sKVxuICogYnkgd3JhcHBpbmcgYW55IG5lc3RlZCBvYmplY3RzIHRoYXQgaGF2ZSBhIHByb3BlcnR5IHdob3NlIG5hbWUgc3RhcnRzIHdpdGggYCRgIGluIGEgYCRlcWAuXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3Qgb2JqID0geyB1c2VybmFtZTogJ3ZhbCcsIHB3ZDogeyAkbmU6IG51bGwgfSB9O1xuICogc2FuaXRpemVGaWx0ZXIob2JqKTtcbiAqIG9iajsgLy8geyB1c2VybmFtZTogJ3ZhbCcsIHB3ZDogeyAkZXE6IHsgJG5lOiBudWxsIH0gfSB9KTtcbiAqIGBgYFxuICpcbiAqIEBtZXRob2Qgc2FuaXRpemVGaWx0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaWx0ZXJcbiAqIEByZXR1cm5zIE9iamVjdCB0aGUgc2FuaXRpemVkIG9iamVjdFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Nb25nb29zZS5wcm90b3R5cGUuc2FuaXRpemVGaWx0ZXIgPSBzYW5pdGl6ZUZpbHRlcjtcblxuLyoqXG4gKiBUZWxscyBgc2FuaXRpemVGaWx0ZXIoKWAgdG8gc2tpcCB0aGUgZ2l2ZW4gb2JqZWN0IHdoZW4gZmlsdGVyaW5nIG91dCBwb3RlbnRpYWwgW3F1ZXJ5IHNlbGVjdG9yIGluamVjdGlvbiBhdHRhY2tzXShodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tLzIwMTQvMDkvMDQvZGVmZW5kaW5nLWFnYWluc3QtcXVlcnktc2VsZWN0b3ItaW5qZWN0aW9uLWF0dGFja3MuaHRtbCkuXG4gKiBVc2UgdGhpcyBtZXRob2Qgd2hlbiB5b3UgaGF2ZSBhIGtub3duIHF1ZXJ5IHNlbGVjdG9yIHRoYXQgeW91IHdhbnQgdG8gdXNlLlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IG9iaiA9IHsgdXNlcm5hbWU6ICd2YWwnLCBwd2Q6IHRydXN0ZWQoeyAkdHlwZTogJ3N0cmluZycsICRlcTogJ215IHNlY3JldCcgfSkgfTtcbiAqIHNhbml0aXplRmlsdGVyKG9iaik7XG4gKlxuICogLy8gTm90ZSB0aGF0IGBzYW5pdGl6ZUZpbHRlcigpYCBkaWQgbm90IGFkZCBgJGVxYCBhcm91bmQgYCR0eXBlYC5cbiAqIG9iajsgLy8geyB1c2VybmFtZTogJ3ZhbCcsIHB3ZDogeyAkdHlwZTogJ3N0cmluZycsICRlcTogJ215IHNlY3JldCcgfSB9KTtcbiAqIGBgYFxuICpcbiAqIEBtZXRob2QgdHJ1c3RlZFxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybnMgT2JqZWN0IHRoZSBwYXNzZWQgaW4gb2JqZWN0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS50cnVzdGVkID0gdHJ1c3RlZDtcblxuLyoqXG4gKiBVc2UgdGhpcyBmdW5jdGlvbiBpbiBgcHJlKClgIG1pZGRsZXdhcmUgdG8gc2tpcCBjYWxsaW5nIHRoZSB3cmFwcGVkIGZ1bmN0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgc2NoZW1hLnByZSgnc2F2ZScsIGZ1bmN0aW9uKCkge1xuICogICAgICAgLy8gV2lsbCBza2lwIGV4ZWN1dGluZyBgc2F2ZSgpYCwgYnV0IHdpbGwgZXhlY3V0ZSBwb3N0IGhvb2tzIGFzIGlmXG4gKiAgICAgICAvLyBgc2F2ZSgpYCBoYWQgZXhlY3V0ZWQgd2l0aCB0aGUgcmVzdWx0IGB7IG1hdGNoZWRDb3VudDogMCB9YFxuICogICAgICAgcmV0dXJuIG1vbmdvb3NlLnNraXBNaWRkbGV3YXJlRnVuY3Rpb24oeyBtYXRjaGVkQ291bnQ6IDAgfSk7XG4gKiAgICAgfSk7XG4gKlxuICogQG1ldGhvZCBza2lwTWlkZGxld2FyZUZ1bmN0aW9uXG4gKiBAcGFyYW0ge2FueX0gcmVzdWx0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1vbmdvb3NlLnByb3RvdHlwZS5za2lwTWlkZGxld2FyZUZ1bmN0aW9uID0gS2FyZWVtLnNraXBXcmFwcGVkRnVuY3Rpb247XG5cbi8qKlxuICogVXNlIHRoaXMgZnVuY3Rpb24gaW4gYHBvc3QoKWAgbWlkZGxld2FyZSB0byByZXBsYWNlIHRoZSByZXN1bHRcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHNjaGVtYS5wb3N0KCdmaW5kJywgZnVuY3Rpb24ocmVzKSB7XG4gKiAgICAgICAvLyBOb3JtYWxseSB5b3UgaGF2ZSB0byBtb2RpZnkgYHJlc2AgaW4gcGxhY2UuIEJ1dCB3aXRoXG4gKiAgICAgICAvLyBgb3ZlcndyaXRlTWlkZGxld2FyUmVzdWx0KClgLCB5b3UgY2FuIG1ha2UgYGZpbmQoKWAgcmV0dXJuIGFcbiAqICAgICAgIC8vIGNvbXBsZXRlbHkgZGlmZmVyZW50IHZhbHVlLlxuICogICAgICAgcmV0dXJuIG1vbmdvb3NlLm92ZXJ3cml0ZU1pZGRsZXdhcmVSZXN1bHQocmVzLmZpbHRlcihkb2MgPT4gIWRvYy5pc0RlbGV0ZWQpKTtcbiAqICAgICB9KTtcbiAqXG4gKiBAbWV0aG9kIG92ZXJ3cml0ZU1pZGRsZXdhcmVSZXN1bHRcbiAqIEBwYXJhbSB7YW55fSByZXN1bHRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTW9uZ29vc2UucHJvdG90eXBlLm92ZXJ3cml0ZU1pZGRsZXdhcmVSZXN1bHQgPSBLYXJlZW0ub3ZlcndyaXRlUmVzdWx0O1xuXG4vKipcbiAqIFRoZSBleHBvcnRzIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiBNb25nb29zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5jb25zdCBtb25nb29zZSA9IG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IG5ldyBNb25nb29zZSh7XG4gIFtkZWZhdWx0TW9uZ29vc2VTeW1ib2xdOiB0cnVlXG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/mongoose.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/options.js":
/*!*******************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/options.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nexports.internalToObjectOptions = {\n  transform: false,\n  virtuals: false,\n  getters: false,\n  _skipDepopulateTopLevel: true,\n  depopulate: true,\n  flattenDecimals: false,\n  useProjection: false,\n  versionKey: true\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy5qcz9iOTk2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5leHBvcnRzLmludGVybmFsVG9PYmplY3RPcHRpb25zID0ge1xuICB0cmFuc2Zvcm06IGZhbHNlLFxuICB2aXJ0dWFsczogZmFsc2UsXG4gIGdldHRlcnM6IGZhbHNlLFxuICBfc2tpcERlcG9wdWxhdGVUb3BMZXZlbDogdHJ1ZSxcbiAgZGVwb3B1bGF0ZTogdHJ1ZSxcbiAgZmxhdHRlbkRlY2ltYWxzOiBmYWxzZSxcbiAgdXNlUHJvamVjdGlvbjogZmFsc2UsXG4gIHZlcnNpb25LZXk6IHRydWVcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/options.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/options/populateOptions.js":
/*!***********************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/options/populateOptions.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst clone = __webpack_require__(/*! ../helpers/clone */ \"../backend/node_modules/mongoose/lib/helpers/clone.js\");\n\nclass PopulateOptions {\n  constructor(obj) {\n    this._docs = {};\n    this._childDocs = [];\n\n    if (obj == null) {\n      return;\n    }\n    obj = clone(obj);\n    Object.assign(this, obj);\n    if (typeof obj.subPopulate === 'object') {\n      this.populate = obj.subPopulate;\n    }\n\n\n    if (obj.perDocumentLimit != null && obj.limit != null) {\n      throw new Error('Can not use `limit` and `perDocumentLimit` at the same time. Path: `' + obj.path + '`.');\n    }\n  }\n}\n\n/**\n * The connection used to look up models by name. If not specified, Mongoose\n * will default to using the connection associated with the model in\n * `PopulateOptions#model`.\n *\n * @memberOf PopulateOptions\n * @property {Connection} connection\n * @api public\n */\n\nmodule.exports = PopulateOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvcG9wdWxhdGVPcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsbUJBQU8sQ0FBQywrRUFBa0I7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9wb3B1bGF0ZU9wdGlvbnMuanM/YTMxMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGNsb25lID0gcmVxdWlyZSgnLi4vaGVscGVycy9jbG9uZScpO1xuXG5jbGFzcyBQb3B1bGF0ZU9wdGlvbnMge1xuICBjb25zdHJ1Y3RvcihvYmopIHtcbiAgICB0aGlzLl9kb2NzID0ge307XG4gICAgdGhpcy5fY2hpbGREb2NzID0gW107XG5cbiAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgb2JqID0gY2xvbmUob2JqKTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIG9iaik7XG4gICAgaWYgKHR5cGVvZiBvYmouc3ViUG9wdWxhdGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB0aGlzLnBvcHVsYXRlID0gb2JqLnN1YlBvcHVsYXRlO1xuICAgIH1cblxuXG4gICAgaWYgKG9iai5wZXJEb2N1bWVudExpbWl0ICE9IG51bGwgJiYgb2JqLmxpbWl0ICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCB1c2UgYGxpbWl0YCBhbmQgYHBlckRvY3VtZW50TGltaXRgIGF0IHRoZSBzYW1lIHRpbWUuIFBhdGg6IGAnICsgb2JqLnBhdGggKyAnYC4nKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgY29ubmVjdGlvbiB1c2VkIHRvIGxvb2sgdXAgbW9kZWxzIGJ5IG5hbWUuIElmIG5vdCBzcGVjaWZpZWQsIE1vbmdvb3NlXG4gKiB3aWxsIGRlZmF1bHQgdG8gdXNpbmcgdGhlIGNvbm5lY3Rpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBtb2RlbCBpblxuICogYFBvcHVsYXRlT3B0aW9ucyNtb2RlbGAuXG4gKlxuICogQG1lbWJlck9mIFBvcHVsYXRlT3B0aW9uc1xuICogQHByb3BlcnR5IHtDb25uZWN0aW9ufSBjb25uZWN0aW9uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gUG9wdWxhdGVPcHRpb25zO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/options/populateOptions.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/options/propertyOptions.js":
/*!***********************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/options/propertyOptions.js ***!
  \***********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = Object.freeze({\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: void 0\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvcHJvcGVydHlPcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvcHJvcGVydHlPcHRpb25zLmpzPzNkZDAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5mcmVlemUoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICB2YWx1ZTogdm9pZCAwXG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/options/propertyOptions.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/options/saveOptions.js":
/*!*******************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/options/saveOptions.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst clone = __webpack_require__(/*! ../helpers/clone */ \"../backend/node_modules/mongoose/lib/helpers/clone.js\");\n\nclass SaveOptions {\n  constructor(obj) {\n    if (obj == null) {\n      return;\n    }\n    Object.assign(this, clone(obj));\n  }\n}\n\nmodule.exports = SaveOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvc2F2ZU9wdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLCtFQUFrQjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9vcHRpb25zL3NhdmVPcHRpb25zLmpzP2MyNjAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjbG9uZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvY2xvbmUnKTtcblxuY2xhc3MgU2F2ZU9wdGlvbnMge1xuICBjb25zdHJ1Y3RvcihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjbG9uZShvYmopKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNhdmVPcHRpb25zO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/options/saveOptions.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/options/schemaArrayOptions.js":
/*!**************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/options/schemaArrayOptions.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SchemaTypeOptions = __webpack_require__(/*! ./schemaTypeOptions */ \"../backend/node_modules/mongoose/lib/options/schemaTypeOptions.js\");\n\n/**\n * The options defined on an Array schematype.\n *\n * #### Example:\n *\n *     const schema = new Schema({ tags: [String] });\n *     schema.path('tags').options; // SchemaArrayOptions instance\n *\n * @api public\n * @inherits SchemaTypeOptions\n * @constructor SchemaArrayOptions\n */\n\nclass SchemaArrayOptions extends SchemaTypeOptions {}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"../backend/node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * If this is an array of strings, an array of allowed values for this path.\n * Throws an error if this array isn't an array of strings.\n *\n * @api public\n * @property enum\n * @memberOf SchemaArrayOptions\n * @type {Array}\n * @instance\n */\n\nObject.defineProperty(SchemaArrayOptions.prototype, 'enum', opts);\n\n/**\n * If set, specifies the type of this array's values. Equivalent to setting\n * `type` to an array whose first element is `of`.\n *\n * #### Example:\n *\n *     // `arr` is an array of numbers.\n *     new Schema({ arr: [Number] });\n *     // Equivalent way to define `arr` as an array of numbers\n *     new Schema({ arr: { type: Array, of: Number } });\n *\n * @api public\n * @property of\n * @memberOf SchemaArrayOptions\n * @type {Function|String}\n * @instance\n */\n\nObject.defineProperty(SchemaArrayOptions.prototype, 'of', opts);\n\n/**\n * If set to `false`, will always deactivate casting non-array values to arrays.\n * If set to `true`, will cast non-array values to arrays if `init` and `SchemaArray.options.castNonArrays` are also `true`\n *\n * #### Example:\n *\n *     const Model = db.model('Test', new Schema({ x1: { castNonArrays: false, type: [String] } }));\n *     const doc = new Model({ x1: \"some non-array value\" });\n *     await doc.validate(); // Errors with \"CastError\"\n *\n * @api public\n * @property castNonArrays\n * @memberOf SchemaArrayOptions\n * @type {Boolean}\n * @instance\n */\n\nObject.defineProperty(SchemaArrayOptions.prototype, 'castNonArrays', opts);\n\n/*!\n * ignore\n */\n\nmodule.exports = SchemaArrayOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvc2NoZW1hQXJyYXlPcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDBCQUEwQixtQkFBTyxDQUFDLDhGQUFxQjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0I7QUFDbkQsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLDBGQUFtQjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0Esb0JBQW9CLE9BQU8sMkJBQTJCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE1BQU0sd0NBQXdDO0FBQ2pHLCtCQUErQiw0QkFBNEI7QUFDM0QsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvc2NoZW1hQXJyYXlPcHRpb25zLmpzPzc0ZDEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBTY2hlbWFUeXBlT3B0aW9ucyA9IHJlcXVpcmUoJy4vc2NoZW1hVHlwZU9wdGlvbnMnKTtcblxuLyoqXG4gKiBUaGUgb3B0aW9ucyBkZWZpbmVkIG9uIGFuIEFycmF5IHNjaGVtYXR5cGUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgdGFnczogW1N0cmluZ10gfSk7XG4gKiAgICAgc2NoZW1hLnBhdGgoJ3RhZ3MnKS5vcHRpb25zOyAvLyBTY2hlbWFBcnJheU9wdGlvbnMgaW5zdGFuY2VcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQGluaGVyaXRzIFNjaGVtYVR5cGVPcHRpb25zXG4gKiBAY29uc3RydWN0b3IgU2NoZW1hQXJyYXlPcHRpb25zXG4gKi9cblxuY2xhc3MgU2NoZW1hQXJyYXlPcHRpb25zIGV4dGVuZHMgU2NoZW1hVHlwZU9wdGlvbnMge31cblxuY29uc3Qgb3B0cyA9IHJlcXVpcmUoJy4vcHJvcGVydHlPcHRpb25zJyk7XG5cbi8qKlxuICogSWYgdGhpcyBpcyBhbiBhcnJheSBvZiBzdHJpbmdzLCBhbiBhcnJheSBvZiBhbGxvd2VkIHZhbHVlcyBmb3IgdGhpcyBwYXRoLlxuICogVGhyb3dzIGFuIGVycm9yIGlmIHRoaXMgYXJyYXkgaXNuJ3QgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IGVudW1cbiAqIEBtZW1iZXJPZiBTY2hlbWFBcnJheU9wdGlvbnNcbiAqIEB0eXBlIHtBcnJheX1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFBcnJheU9wdGlvbnMucHJvdG90eXBlLCAnZW51bScsIG9wdHMpO1xuXG4vKipcbiAqIElmIHNldCwgc3BlY2lmaWVzIHRoZSB0eXBlIG9mIHRoaXMgYXJyYXkncyB2YWx1ZXMuIEVxdWl2YWxlbnQgdG8gc2V0dGluZ1xuICogYHR5cGVgIHRvIGFuIGFycmF5IHdob3NlIGZpcnN0IGVsZW1lbnQgaXMgYG9mYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIGBhcnJgIGlzIGFuIGFycmF5IG9mIG51bWJlcnMuXG4gKiAgICAgbmV3IFNjaGVtYSh7IGFycjogW051bWJlcl0gfSk7XG4gKiAgICAgLy8gRXF1aXZhbGVudCB3YXkgdG8gZGVmaW5lIGBhcnJgIGFzIGFuIGFycmF5IG9mIG51bWJlcnNcbiAqICAgICBuZXcgU2NoZW1hKHsgYXJyOiB7IHR5cGU6IEFycmF5LCBvZjogTnVtYmVyIH0gfSk7XG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBvZlxuICogQG1lbWJlck9mIFNjaGVtYUFycmF5T3B0aW9uc1xuICogQHR5cGUge0Z1bmN0aW9ufFN0cmluZ31cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFBcnJheU9wdGlvbnMucHJvdG90eXBlLCAnb2YnLCBvcHRzKTtcblxuLyoqXG4gKiBJZiBzZXQgdG8gYGZhbHNlYCwgd2lsbCBhbHdheXMgZGVhY3RpdmF0ZSBjYXN0aW5nIG5vbi1hcnJheSB2YWx1ZXMgdG8gYXJyYXlzLlxuICogSWYgc2V0IHRvIGB0cnVlYCwgd2lsbCBjYXN0IG5vbi1hcnJheSB2YWx1ZXMgdG8gYXJyYXlzIGlmIGBpbml0YCBhbmQgYFNjaGVtYUFycmF5Lm9wdGlvbnMuY2FzdE5vbkFycmF5c2AgYXJlIGFsc28gYHRydWVgXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBNb2RlbCA9IGRiLm1vZGVsKCdUZXN0JywgbmV3IFNjaGVtYSh7IHgxOiB7IGNhc3ROb25BcnJheXM6IGZhbHNlLCB0eXBlOiBbU3RyaW5nXSB9IH0pKTtcbiAqICAgICBjb25zdCBkb2MgPSBuZXcgTW9kZWwoeyB4MTogXCJzb21lIG5vbi1hcnJheSB2YWx1ZVwiIH0pO1xuICogICAgIGF3YWl0IGRvYy52YWxpZGF0ZSgpOyAvLyBFcnJvcnMgd2l0aCBcIkNhc3RFcnJvclwiXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBjYXN0Tm9uQXJyYXlzXG4gKiBAbWVtYmVyT2YgU2NoZW1hQXJyYXlPcHRpb25zXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFBcnJheU9wdGlvbnMucHJvdG90eXBlLCAnY2FzdE5vbkFycmF5cycsIG9wdHMpO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hQXJyYXlPcHRpb25zO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/options/schemaArrayOptions.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/options/schemaBufferOptions.js":
/*!***************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/options/schemaBufferOptions.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SchemaTypeOptions = __webpack_require__(/*! ./schemaTypeOptions */ \"../backend/node_modules/mongoose/lib/options/schemaTypeOptions.js\");\n\n/**\n * The options defined on a Buffer schematype.\n *\n * #### Example:\n *\n *     const schema = new Schema({ bitmap: Buffer });\n *     schema.path('bitmap').options; // SchemaBufferOptions instance\n *\n * @api public\n * @inherits SchemaTypeOptions\n * @constructor SchemaBufferOptions\n */\n\nclass SchemaBufferOptions extends SchemaTypeOptions {}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"../backend/node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * Set the default subtype for this buffer.\n *\n * @api public\n * @property subtype\n * @memberOf SchemaBufferOptions\n * @type {Number}\n * @instance\n */\n\nObject.defineProperty(SchemaBufferOptions.prototype, 'subtype', opts);\n\n/*!\n * ignore\n */\n\nmodule.exports = SchemaBufferOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvc2NoZW1hQnVmZmVyT3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiwwQkFBMEIsbUJBQU8sQ0FBQyw4RkFBcUI7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCO0FBQ25ELHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQywwRkFBbUI7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9vcHRpb25zL3NjaGVtYUJ1ZmZlck9wdGlvbnMuanM/ZGI1NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFNjaGVtYVR5cGVPcHRpb25zID0gcmVxdWlyZSgnLi9zY2hlbWFUeXBlT3B0aW9ucycpO1xuXG4vKipcbiAqIFRoZSBvcHRpb25zIGRlZmluZWQgb24gYSBCdWZmZXIgc2NoZW1hdHlwZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBiaXRtYXA6IEJ1ZmZlciB9KTtcbiAqICAgICBzY2hlbWEucGF0aCgnYml0bWFwJykub3B0aW9uczsgLy8gU2NoZW1hQnVmZmVyT3B0aW9ucyBpbnN0YW5jZVxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAaW5oZXJpdHMgU2NoZW1hVHlwZU9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvciBTY2hlbWFCdWZmZXJPcHRpb25zXG4gKi9cblxuY2xhc3MgU2NoZW1hQnVmZmVyT3B0aW9ucyBleHRlbmRzIFNjaGVtYVR5cGVPcHRpb25zIHt9XG5cbmNvbnN0IG9wdHMgPSByZXF1aXJlKCcuL3Byb3BlcnR5T3B0aW9ucycpO1xuXG4vKipcbiAqIFNldCB0aGUgZGVmYXVsdCBzdWJ0eXBlIGZvciB0aGlzIGJ1ZmZlci5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IHN1YnR5cGVcbiAqIEBtZW1iZXJPZiBTY2hlbWFCdWZmZXJPcHRpb25zXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYUJ1ZmZlck9wdGlvbnMucHJvdG90eXBlLCAnc3VidHlwZScsIG9wdHMpO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hQnVmZmVyT3B0aW9ucztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/options/schemaBufferOptions.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/options/schemaDateOptions.js":
/*!*************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/options/schemaDateOptions.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SchemaTypeOptions = __webpack_require__(/*! ./schemaTypeOptions */ \"../backend/node_modules/mongoose/lib/options/schemaTypeOptions.js\");\n\n/**\n * The options defined on a Date schematype.\n *\n * #### Example:\n *\n *     const schema = new Schema({ startedAt: Date });\n *     schema.path('startedAt').options; // SchemaDateOptions instance\n *\n * @api public\n * @inherits SchemaTypeOptions\n * @constructor SchemaDateOptions\n */\n\nclass SchemaDateOptions extends SchemaTypeOptions {}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"../backend/node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * If set, Mongoose adds a validator that checks that this path is after the\n * given `min`.\n *\n * @api public\n * @property min\n * @memberOf SchemaDateOptions\n * @type {Date}\n * @instance\n */\n\nObject.defineProperty(SchemaDateOptions.prototype, 'min', opts);\n\n/**\n * If set, Mongoose adds a validator that checks that this path is before the\n * given `max`.\n *\n * @api public\n * @property max\n * @memberOf SchemaDateOptions\n * @type {Date}\n * @instance\n */\n\nObject.defineProperty(SchemaDateOptions.prototype, 'max', opts);\n\n/**\n * If set, Mongoose creates a TTL index on this path.\n *\n * mongo TTL index `expireAfterSeconds` value will take 'expires' value expressed in seconds.\n *\n * #### Example:\n *\n *     const schema = new Schema({ \"expireAt\": { type: Date,  expires: 11 } });\n *     // if 'expireAt' is set, then document expires at expireAt + 11 seconds\n *\n * @api public\n * @property expires\n * @memberOf SchemaDateOptions\n * @type {Date}\n * @instance\n */\n\nObject.defineProperty(SchemaDateOptions.prototype, 'expires', opts);\n\n/*!\n * ignore\n */\n\nmodule.exports = SchemaDateOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvc2NoZW1hRGF0ZU9wdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsMEJBQTBCLG1CQUFPLENBQUMsOEZBQXFCOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGlCQUFpQjtBQUNwRCx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsMEZBQW1COztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsY0FBYyw0QkFBNEI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9vcHRpb25zL3NjaGVtYURhdGVPcHRpb25zLmpzP2JkMjkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBTY2hlbWFUeXBlT3B0aW9ucyA9IHJlcXVpcmUoJy4vc2NoZW1hVHlwZU9wdGlvbnMnKTtcblxuLyoqXG4gKiBUaGUgb3B0aW9ucyBkZWZpbmVkIG9uIGEgRGF0ZSBzY2hlbWF0eXBlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IHN0YXJ0ZWRBdDogRGF0ZSB9KTtcbiAqICAgICBzY2hlbWEucGF0aCgnc3RhcnRlZEF0Jykub3B0aW9uczsgLy8gU2NoZW1hRGF0ZU9wdGlvbnMgaW5zdGFuY2VcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQGluaGVyaXRzIFNjaGVtYVR5cGVPcHRpb25zXG4gKiBAY29uc3RydWN0b3IgU2NoZW1hRGF0ZU9wdGlvbnNcbiAqL1xuXG5jbGFzcyBTY2hlbWFEYXRlT3B0aW9ucyBleHRlbmRzIFNjaGVtYVR5cGVPcHRpb25zIHt9XG5cbmNvbnN0IG9wdHMgPSByZXF1aXJlKCcuL3Byb3BlcnR5T3B0aW9ucycpO1xuXG4vKipcbiAqIElmIHNldCwgTW9uZ29vc2UgYWRkcyBhIHZhbGlkYXRvciB0aGF0IGNoZWNrcyB0aGF0IHRoaXMgcGF0aCBpcyBhZnRlciB0aGVcbiAqIGdpdmVuIGBtaW5gLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgbWluXG4gKiBAbWVtYmVyT2YgU2NoZW1hRGF0ZU9wdGlvbnNcbiAqIEB0eXBlIHtEYXRlfVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYURhdGVPcHRpb25zLnByb3RvdHlwZSwgJ21pbicsIG9wdHMpO1xuXG4vKipcbiAqIElmIHNldCwgTW9uZ29vc2UgYWRkcyBhIHZhbGlkYXRvciB0aGF0IGNoZWNrcyB0aGF0IHRoaXMgcGF0aCBpcyBiZWZvcmUgdGhlXG4gKiBnaXZlbiBgbWF4YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IG1heFxuICogQG1lbWJlck9mIFNjaGVtYURhdGVPcHRpb25zXG4gKiBAdHlwZSB7RGF0ZX1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFEYXRlT3B0aW9ucy5wcm90b3R5cGUsICdtYXgnLCBvcHRzKTtcblxuLyoqXG4gKiBJZiBzZXQsIE1vbmdvb3NlIGNyZWF0ZXMgYSBUVEwgaW5kZXggb24gdGhpcyBwYXRoLlxuICpcbiAqIG1vbmdvIFRUTCBpbmRleCBgZXhwaXJlQWZ0ZXJTZWNvbmRzYCB2YWx1ZSB3aWxsIHRha2UgJ2V4cGlyZXMnIHZhbHVlIGV4cHJlc3NlZCBpbiBzZWNvbmRzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IFwiZXhwaXJlQXRcIjogeyB0eXBlOiBEYXRlLCAgZXhwaXJlczogMTEgfSB9KTtcbiAqICAgICAvLyBpZiAnZXhwaXJlQXQnIGlzIHNldCwgdGhlbiBkb2N1bWVudCBleHBpcmVzIGF0IGV4cGlyZUF0ICsgMTEgc2Vjb25kc1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgZXhwaXJlc1xuICogQG1lbWJlck9mIFNjaGVtYURhdGVPcHRpb25zXG4gKiBAdHlwZSB7RGF0ZX1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFEYXRlT3B0aW9ucy5wcm90b3R5cGUsICdleHBpcmVzJywgb3B0cyk7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFEYXRlT3B0aW9ucztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/options/schemaDateOptions.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/options/schemaDocumentArrayOptions.js":
/*!**********************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/options/schemaDocumentArrayOptions.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SchemaTypeOptions = __webpack_require__(/*! ./schemaTypeOptions */ \"../backend/node_modules/mongoose/lib/options/schemaTypeOptions.js\");\n\n/**\n * The options defined on an Document Array schematype.\n *\n * #### Example:\n *\n *     const schema = new Schema({ users: [{ name: string }] });\n *     schema.path('users').options; // SchemaDocumentArrayOptions instance\n *\n * @api public\n * @inherits SchemaTypeOptions\n * @constructor SchemaDocumentOptions\n */\n\nclass SchemaDocumentArrayOptions extends SchemaTypeOptions {}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"../backend/node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * If `true`, Mongoose will skip building any indexes defined in this array's schema.\n * If not set, Mongoose will build all indexes defined in this array's schema.\n *\n * #### Example:\n *\n *     const childSchema = Schema({ name: { type: String, index: true } });\n *     // If `excludeIndexes` is `true`, Mongoose will skip building an index\n *     // on `arr.name`. Otherwise, Mongoose will build an index on `arr.name`.\n *     const parentSchema = Schema({\n *       arr: { type: [childSchema], excludeIndexes: true }\n *     });\n *\n * @api public\n * @property excludeIndexes\n * @memberOf SchemaDocumentArrayOptions\n * @type {Array}\n * @instance\n */\n\nObject.defineProperty(SchemaDocumentArrayOptions.prototype, 'excludeIndexes', opts);\n\n/**\n * If set, overwrites the child schema's `_id` option.\n *\n * #### Example:\n *\n *     const childSchema = Schema({ name: String });\n *     const parentSchema = Schema({\n *       child: { type: childSchema, _id: false }\n *     });\n *     parentSchema.path('child').schema.options._id; // false\n *\n * @api public\n * @property _id\n * @memberOf SchemaDocumentArrayOptions\n * @type {Array}\n * @instance\n */\n\nObject.defineProperty(SchemaDocumentArrayOptions.prototype, '_id', opts);\n\n/*!\n * ignore\n */\n\nmodule.exports = SchemaDocumentArrayOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvc2NoZW1hRG9jdW1lbnRBcnJheU9wdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsMEJBQTBCLG1CQUFPLENBQUMsOEZBQXFCOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFVBQVUsY0FBYyxHQUFHO0FBQzlELHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQywwRkFBbUI7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRLDZCQUE2QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0Esa0JBQWtCO0FBQ2xCLFFBQVE7QUFDUixzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9zY2hlbWFEb2N1bWVudEFycmF5T3B0aW9ucy5qcz80Zjc2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgU2NoZW1hVHlwZU9wdGlvbnMgPSByZXF1aXJlKCcuL3NjaGVtYVR5cGVPcHRpb25zJyk7XG5cbi8qKlxuICogVGhlIG9wdGlvbnMgZGVmaW5lZCBvbiBhbiBEb2N1bWVudCBBcnJheSBzY2hlbWF0eXBlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IHVzZXJzOiBbeyBuYW1lOiBzdHJpbmcgfV0gfSk7XG4gKiAgICAgc2NoZW1hLnBhdGgoJ3VzZXJzJykub3B0aW9uczsgLy8gU2NoZW1hRG9jdW1lbnRBcnJheU9wdGlvbnMgaW5zdGFuY2VcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQGluaGVyaXRzIFNjaGVtYVR5cGVPcHRpb25zXG4gKiBAY29uc3RydWN0b3IgU2NoZW1hRG9jdW1lbnRPcHRpb25zXG4gKi9cblxuY2xhc3MgU2NoZW1hRG9jdW1lbnRBcnJheU9wdGlvbnMgZXh0ZW5kcyBTY2hlbWFUeXBlT3B0aW9ucyB7fVxuXG5jb25zdCBvcHRzID0gcmVxdWlyZSgnLi9wcm9wZXJ0eU9wdGlvbnMnKTtcblxuLyoqXG4gKiBJZiBgdHJ1ZWAsIE1vbmdvb3NlIHdpbGwgc2tpcCBidWlsZGluZyBhbnkgaW5kZXhlcyBkZWZpbmVkIGluIHRoaXMgYXJyYXkncyBzY2hlbWEuXG4gKiBJZiBub3Qgc2V0LCBNb25nb29zZSB3aWxsIGJ1aWxkIGFsbCBpbmRleGVzIGRlZmluZWQgaW4gdGhpcyBhcnJheSdzIHNjaGVtYS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGNoaWxkU2NoZW1hID0gU2NoZW1hKHsgbmFtZTogeyB0eXBlOiBTdHJpbmcsIGluZGV4OiB0cnVlIH0gfSk7XG4gKiAgICAgLy8gSWYgYGV4Y2x1ZGVJbmRleGVzYCBpcyBgdHJ1ZWAsIE1vbmdvb3NlIHdpbGwgc2tpcCBidWlsZGluZyBhbiBpbmRleFxuICogICAgIC8vIG9uIGBhcnIubmFtZWAuIE90aGVyd2lzZSwgTW9uZ29vc2Ugd2lsbCBidWlsZCBhbiBpbmRleCBvbiBgYXJyLm5hbWVgLlxuICogICAgIGNvbnN0IHBhcmVudFNjaGVtYSA9IFNjaGVtYSh7XG4gKiAgICAgICBhcnI6IHsgdHlwZTogW2NoaWxkU2NoZW1hXSwgZXhjbHVkZUluZGV4ZXM6IHRydWUgfVxuICogICAgIH0pO1xuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgZXhjbHVkZUluZGV4ZXNcbiAqIEBtZW1iZXJPZiBTY2hlbWFEb2N1bWVudEFycmF5T3B0aW9uc1xuICogQHR5cGUge0FycmF5fVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYURvY3VtZW50QXJyYXlPcHRpb25zLnByb3RvdHlwZSwgJ2V4Y2x1ZGVJbmRleGVzJywgb3B0cyk7XG5cbi8qKlxuICogSWYgc2V0LCBvdmVyd3JpdGVzIHRoZSBjaGlsZCBzY2hlbWEncyBgX2lkYCBvcHRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBjaGlsZFNjaGVtYSA9IFNjaGVtYSh7IG5hbWU6IFN0cmluZyB9KTtcbiAqICAgICBjb25zdCBwYXJlbnRTY2hlbWEgPSBTY2hlbWEoe1xuICogICAgICAgY2hpbGQ6IHsgdHlwZTogY2hpbGRTY2hlbWEsIF9pZDogZmFsc2UgfVxuICogICAgIH0pO1xuICogICAgIHBhcmVudFNjaGVtYS5wYXRoKCdjaGlsZCcpLnNjaGVtYS5vcHRpb25zLl9pZDsgLy8gZmFsc2VcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IF9pZFxuICogQG1lbWJlck9mIFNjaGVtYURvY3VtZW50QXJyYXlPcHRpb25zXG4gKiBAdHlwZSB7QXJyYXl9XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hRG9jdW1lbnRBcnJheU9wdGlvbnMucHJvdG90eXBlLCAnX2lkJywgb3B0cyk7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFEb2N1bWVudEFycmF5T3B0aW9ucztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/options/schemaDocumentArrayOptions.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/options/schemaMapOptions.js":
/*!************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/options/schemaMapOptions.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SchemaTypeOptions = __webpack_require__(/*! ./schemaTypeOptions */ \"../backend/node_modules/mongoose/lib/options/schemaTypeOptions.js\");\n\n/**\n * The options defined on a Map schematype.\n *\n * #### Example:\n *\n *     const schema = new Schema({ socialMediaHandles: { type: Map, of: String } });\n *     schema.path('socialMediaHandles').options; // SchemaMapOptions instance\n *\n * @api public\n * @inherits SchemaTypeOptions\n * @constructor SchemaMapOptions\n */\n\nclass SchemaMapOptions extends SchemaTypeOptions {}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"../backend/node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * If set, specifies the type of this map's values. Mongoose will cast\n * this map's values to the given type.\n *\n * If not set, Mongoose will not cast the map's values.\n *\n * #### Example:\n *\n *     // Mongoose will cast `socialMediaHandles` values to strings\n *     const schema = new Schema({ socialMediaHandles: { type: Map, of: String } });\n *     schema.path('socialMediaHandles').options.of; // String\n *\n * @api public\n * @property of\n * @memberOf SchemaMapOptions\n * @type {Function|string}\n * @instance\n */\n\nObject.defineProperty(SchemaMapOptions.prototype, 'of', opts);\n\nmodule.exports = SchemaMapOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvc2NoZW1hTWFwT3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiwwQkFBMEIsbUJBQU8sQ0FBQyw4RkFBcUI7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsc0JBQXNCLHlCQUF5QjtBQUNsRixrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsMEZBQW1COztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsc0JBQXNCLHlCQUF5QjtBQUNsRixxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9vcHRpb25zL3NjaGVtYU1hcE9wdGlvbnMuanM/MTIxOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFNjaGVtYVR5cGVPcHRpb25zID0gcmVxdWlyZSgnLi9zY2hlbWFUeXBlT3B0aW9ucycpO1xuXG4vKipcbiAqIFRoZSBvcHRpb25zIGRlZmluZWQgb24gYSBNYXAgc2NoZW1hdHlwZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBzb2NpYWxNZWRpYUhhbmRsZXM6IHsgdHlwZTogTWFwLCBvZjogU3RyaW5nIH0gfSk7XG4gKiAgICAgc2NoZW1hLnBhdGgoJ3NvY2lhbE1lZGlhSGFuZGxlcycpLm9wdGlvbnM7IC8vIFNjaGVtYU1hcE9wdGlvbnMgaW5zdGFuY2VcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQGluaGVyaXRzIFNjaGVtYVR5cGVPcHRpb25zXG4gKiBAY29uc3RydWN0b3IgU2NoZW1hTWFwT3B0aW9uc1xuICovXG5cbmNsYXNzIFNjaGVtYU1hcE9wdGlvbnMgZXh0ZW5kcyBTY2hlbWFUeXBlT3B0aW9ucyB7fVxuXG5jb25zdCBvcHRzID0gcmVxdWlyZSgnLi9wcm9wZXJ0eU9wdGlvbnMnKTtcblxuLyoqXG4gKiBJZiBzZXQsIHNwZWNpZmllcyB0aGUgdHlwZSBvZiB0aGlzIG1hcCdzIHZhbHVlcy4gTW9uZ29vc2Ugd2lsbCBjYXN0XG4gKiB0aGlzIG1hcCdzIHZhbHVlcyB0byB0aGUgZ2l2ZW4gdHlwZS5cbiAqXG4gKiBJZiBub3Qgc2V0LCBNb25nb29zZSB3aWxsIG5vdCBjYXN0IHRoZSBtYXAncyB2YWx1ZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNb25nb29zZSB3aWxsIGNhc3QgYHNvY2lhbE1lZGlhSGFuZGxlc2AgdmFsdWVzIHRvIHN0cmluZ3NcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgc29jaWFsTWVkaWFIYW5kbGVzOiB7IHR5cGU6IE1hcCwgb2Y6IFN0cmluZyB9IH0pO1xuICogICAgIHNjaGVtYS5wYXRoKCdzb2NpYWxNZWRpYUhhbmRsZXMnKS5vcHRpb25zLm9mOyAvLyBTdHJpbmdcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IG9mXG4gKiBAbWVtYmVyT2YgU2NoZW1hTWFwT3B0aW9uc1xuICogQHR5cGUge0Z1bmN0aW9ufHN0cmluZ31cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFNYXBPcHRpb25zLnByb3RvdHlwZSwgJ29mJywgb3B0cyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hTWFwT3B0aW9ucztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/options/schemaMapOptions.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/options/schemaNumberOptions.js":
/*!***************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/options/schemaNumberOptions.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SchemaTypeOptions = __webpack_require__(/*! ./schemaTypeOptions */ \"../backend/node_modules/mongoose/lib/options/schemaTypeOptions.js\");\n\n/**\n * The options defined on a Number schematype.\n *\n * #### Example:\n *\n *     const schema = new Schema({ count: Number });\n *     schema.path('count').options; // SchemaNumberOptions instance\n *\n * @api public\n * @inherits SchemaTypeOptions\n * @constructor SchemaNumberOptions\n */\n\nclass SchemaNumberOptions extends SchemaTypeOptions {}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"../backend/node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * If set, Mongoose adds a validator that checks that this path is at least the\n * given `min`.\n *\n * @api public\n * @property min\n * @memberOf SchemaNumberOptions\n * @type {Number}\n * @instance\n */\n\nObject.defineProperty(SchemaNumberOptions.prototype, 'min', opts);\n\n/**\n * If set, Mongoose adds a validator that checks that this path is less than the\n * given `max`.\n *\n * @api public\n * @property max\n * @memberOf SchemaNumberOptions\n * @type {Number}\n * @instance\n */\n\nObject.defineProperty(SchemaNumberOptions.prototype, 'max', opts);\n\n/**\n * If set, Mongoose adds a validator that checks that this path is strictly\n * equal to one of the given values.\n *\n * #### Example:\n *\n *     const schema = new Schema({\n *       favoritePrime: {\n *         type: Number,\n *         enum: [3, 5, 7]\n *       }\n *     });\n *     schema.path('favoritePrime').options.enum; // [3, 5, 7]\n *\n * @api public\n * @property enum\n * @memberOf SchemaNumberOptions\n * @type {Array}\n * @instance\n */\n\nObject.defineProperty(SchemaNumberOptions.prototype, 'enum', opts);\n\n/**\n * Sets default [populate options](https://mongoosejs.com/docs/populate.html#query-conditions).\n *\n * #### Example:\n *\n *     const schema = new Schema({\n *       child: {\n *         type: Number,\n *         ref: 'Child',\n *         populate: { select: 'name' }\n *       }\n *     });\n *     const Parent = mongoose.model('Parent', schema);\n *\n *     // Automatically adds `.select('name')`\n *     Parent.findOne().populate('child');\n *\n * @api public\n * @property populate\n * @memberOf SchemaNumberOptions\n * @type {Object}\n * @instance\n */\n\nObject.defineProperty(SchemaNumberOptions.prototype, 'populate', opts);\n\n/*!\n * ignore\n */\n\nmodule.exports = SchemaNumberOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvc2NoZW1hTnVtYmVyT3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiwwQkFBMEIsbUJBQU8sQ0FBQyw4RkFBcUI7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZUFBZTtBQUNsRCxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsMEZBQW1COztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9vcHRpb25zL3NjaGVtYU51bWJlck9wdGlvbnMuanM/OTY3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFNjaGVtYVR5cGVPcHRpb25zID0gcmVxdWlyZSgnLi9zY2hlbWFUeXBlT3B0aW9ucycpO1xuXG4vKipcbiAqIFRoZSBvcHRpb25zIGRlZmluZWQgb24gYSBOdW1iZXIgc2NoZW1hdHlwZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBjb3VudDogTnVtYmVyIH0pO1xuICogICAgIHNjaGVtYS5wYXRoKCdjb3VudCcpLm9wdGlvbnM7IC8vIFNjaGVtYU51bWJlck9wdGlvbnMgaW5zdGFuY2VcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQGluaGVyaXRzIFNjaGVtYVR5cGVPcHRpb25zXG4gKiBAY29uc3RydWN0b3IgU2NoZW1hTnVtYmVyT3B0aW9uc1xuICovXG5cbmNsYXNzIFNjaGVtYU51bWJlck9wdGlvbnMgZXh0ZW5kcyBTY2hlbWFUeXBlT3B0aW9ucyB7fVxuXG5jb25zdCBvcHRzID0gcmVxdWlyZSgnLi9wcm9wZXJ0eU9wdGlvbnMnKTtcblxuLyoqXG4gKiBJZiBzZXQsIE1vbmdvb3NlIGFkZHMgYSB2YWxpZGF0b3IgdGhhdCBjaGVja3MgdGhhdCB0aGlzIHBhdGggaXMgYXQgbGVhc3QgdGhlXG4gKiBnaXZlbiBgbWluYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IG1pblxuICogQG1lbWJlck9mIFNjaGVtYU51bWJlck9wdGlvbnNcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hTnVtYmVyT3B0aW9ucy5wcm90b3R5cGUsICdtaW4nLCBvcHRzKTtcblxuLyoqXG4gKiBJZiBzZXQsIE1vbmdvb3NlIGFkZHMgYSB2YWxpZGF0b3IgdGhhdCBjaGVja3MgdGhhdCB0aGlzIHBhdGggaXMgbGVzcyB0aGFuIHRoZVxuICogZ2l2ZW4gYG1heGAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBtYXhcbiAqIEBtZW1iZXJPZiBTY2hlbWFOdW1iZXJPcHRpb25zXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYU51bWJlck9wdGlvbnMucHJvdG90eXBlLCAnbWF4Jywgb3B0cyk7XG5cbi8qKlxuICogSWYgc2V0LCBNb25nb29zZSBhZGRzIGEgdmFsaWRhdG9yIHRoYXQgY2hlY2tzIHRoYXQgdGhpcyBwYXRoIGlzIHN0cmljdGx5XG4gKiBlcXVhbCB0byBvbmUgb2YgdGhlIGdpdmVuIHZhbHVlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoe1xuICogICAgICAgZmF2b3JpdGVQcmltZToge1xuICogICAgICAgICB0eXBlOiBOdW1iZXIsXG4gKiAgICAgICAgIGVudW06IFszLCA1LCA3XVxuICogICAgICAgfVxuICogICAgIH0pO1xuICogICAgIHNjaGVtYS5wYXRoKCdmYXZvcml0ZVByaW1lJykub3B0aW9ucy5lbnVtOyAvLyBbMywgNSwgN11cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IGVudW1cbiAqIEBtZW1iZXJPZiBTY2hlbWFOdW1iZXJPcHRpb25zXG4gKiBAdHlwZSB7QXJyYXl9XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hTnVtYmVyT3B0aW9ucy5wcm90b3R5cGUsICdlbnVtJywgb3B0cyk7XG5cbi8qKlxuICogU2V0cyBkZWZhdWx0IFtwb3B1bGF0ZSBvcHRpb25zXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvcG9wdWxhdGUuaHRtbCNxdWVyeS1jb25kaXRpb25zKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoe1xuICogICAgICAgY2hpbGQ6IHtcbiAqICAgICAgICAgdHlwZTogTnVtYmVyLFxuICogICAgICAgICByZWY6ICdDaGlsZCcsXG4gKiAgICAgICAgIHBvcHVsYXRlOiB7IHNlbGVjdDogJ25hbWUnIH1cbiAqICAgICAgIH1cbiAqICAgICB9KTtcbiAqICAgICBjb25zdCBQYXJlbnQgPSBtb25nb29zZS5tb2RlbCgnUGFyZW50Jywgc2NoZW1hKTtcbiAqXG4gKiAgICAgLy8gQXV0b21hdGljYWxseSBhZGRzIGAuc2VsZWN0KCduYW1lJylgXG4gKiAgICAgUGFyZW50LmZpbmRPbmUoKS5wb3B1bGF0ZSgnY2hpbGQnKTtcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IHBvcHVsYXRlXG4gKiBAbWVtYmVyT2YgU2NoZW1hTnVtYmVyT3B0aW9uc1xuICogQHR5cGUge09iamVjdH1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFOdW1iZXJPcHRpb25zLnByb3RvdHlwZSwgJ3BvcHVsYXRlJywgb3B0cyk7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFOdW1iZXJPcHRpb25zO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/options/schemaNumberOptions.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/options/schemaObjectIdOptions.js":
/*!*****************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/options/schemaObjectIdOptions.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SchemaTypeOptions = __webpack_require__(/*! ./schemaTypeOptions */ \"../backend/node_modules/mongoose/lib/options/schemaTypeOptions.js\");\n\n/**\n * The options defined on an ObjectId schematype.\n *\n * #### Example:\n *\n *     const schema = new Schema({ testId: mongoose.ObjectId });\n *     schema.path('testId').options; // SchemaObjectIdOptions instance\n *\n * @api public\n * @inherits SchemaTypeOptions\n * @constructor SchemaObjectIdOptions\n */\n\nclass SchemaObjectIdOptions extends SchemaTypeOptions {}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"../backend/node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * If truthy, uses Mongoose's default built-in ObjectId path.\n *\n * @api public\n * @property auto\n * @memberOf SchemaObjectIdOptions\n * @type {Boolean}\n * @instance\n */\n\nObject.defineProperty(SchemaObjectIdOptions.prototype, 'auto', opts);\n\n/**\n * Sets default [populate options](https://mongoosejs.com/docs/populate.html#query-conditions).\n *\n * #### Example:\n *\n *     const schema = new Schema({\n *       child: {\n *         type: 'ObjectId',\n *         ref: 'Child',\n *         populate: { select: 'name' }\n *       }\n *     });\n *     const Parent = mongoose.model('Parent', schema);\n *\n *     // Automatically adds `.select('name')`\n *     Parent.findOne().populate('child');\n *\n * @api public\n * @property populate\n * @memberOf SchemaObjectIdOptions\n * @type {Object}\n * @instance\n */\n\nObject.defineProperty(SchemaObjectIdOptions.prototype, 'populate', opts);\n\n/*!\n * ignore\n */\n\nmodule.exports = SchemaObjectIdOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvc2NoZW1hT2JqZWN0SWRPcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDBCQUEwQixtQkFBTyxDQUFDLDhGQUFxQjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywyQkFBMkI7QUFDOUQsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLDBGQUFtQjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9zY2hlbWFPYmplY3RJZE9wdGlvbnMuanM/ZThmMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFNjaGVtYVR5cGVPcHRpb25zID0gcmVxdWlyZSgnLi9zY2hlbWFUeXBlT3B0aW9ucycpO1xuXG4vKipcbiAqIFRoZSBvcHRpb25zIGRlZmluZWQgb24gYW4gT2JqZWN0SWQgc2NoZW1hdHlwZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyB0ZXN0SWQ6IG1vbmdvb3NlLk9iamVjdElkIH0pO1xuICogICAgIHNjaGVtYS5wYXRoKCd0ZXN0SWQnKS5vcHRpb25zOyAvLyBTY2hlbWFPYmplY3RJZE9wdGlvbnMgaW5zdGFuY2VcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQGluaGVyaXRzIFNjaGVtYVR5cGVPcHRpb25zXG4gKiBAY29uc3RydWN0b3IgU2NoZW1hT2JqZWN0SWRPcHRpb25zXG4gKi9cblxuY2xhc3MgU2NoZW1hT2JqZWN0SWRPcHRpb25zIGV4dGVuZHMgU2NoZW1hVHlwZU9wdGlvbnMge31cblxuY29uc3Qgb3B0cyA9IHJlcXVpcmUoJy4vcHJvcGVydHlPcHRpb25zJyk7XG5cbi8qKlxuICogSWYgdHJ1dGh5LCB1c2VzIE1vbmdvb3NlJ3MgZGVmYXVsdCBidWlsdC1pbiBPYmplY3RJZCBwYXRoLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgYXV0b1xuICogQG1lbWJlck9mIFNjaGVtYU9iamVjdElkT3B0aW9uc1xuICogQHR5cGUge0Jvb2xlYW59XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hT2JqZWN0SWRPcHRpb25zLnByb3RvdHlwZSwgJ2F1dG8nLCBvcHRzKTtcblxuLyoqXG4gKiBTZXRzIGRlZmF1bHQgW3BvcHVsYXRlIG9wdGlvbnNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9wb3B1bGF0ZS5odG1sI3F1ZXJ5LWNvbmRpdGlvbnMpLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7XG4gKiAgICAgICBjaGlsZDoge1xuICogICAgICAgICB0eXBlOiAnT2JqZWN0SWQnLFxuICogICAgICAgICByZWY6ICdDaGlsZCcsXG4gKiAgICAgICAgIHBvcHVsYXRlOiB7IHNlbGVjdDogJ25hbWUnIH1cbiAqICAgICAgIH1cbiAqICAgICB9KTtcbiAqICAgICBjb25zdCBQYXJlbnQgPSBtb25nb29zZS5tb2RlbCgnUGFyZW50Jywgc2NoZW1hKTtcbiAqXG4gKiAgICAgLy8gQXV0b21hdGljYWxseSBhZGRzIGAuc2VsZWN0KCduYW1lJylgXG4gKiAgICAgUGFyZW50LmZpbmRPbmUoKS5wb3B1bGF0ZSgnY2hpbGQnKTtcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IHBvcHVsYXRlXG4gKiBAbWVtYmVyT2YgU2NoZW1hT2JqZWN0SWRPcHRpb25zXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYU9iamVjdElkT3B0aW9ucy5wcm90b3R5cGUsICdwb3B1bGF0ZScsIG9wdHMpO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hT2JqZWN0SWRPcHRpb25zO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/options/schemaObjectIdOptions.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/options/schemaStringOptions.js":
/*!***************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/options/schemaStringOptions.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SchemaTypeOptions = __webpack_require__(/*! ./schemaTypeOptions */ \"../backend/node_modules/mongoose/lib/options/schemaTypeOptions.js\");\n\n/**\n * The options defined on a string schematype.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String });\n *     schema.path('name').options; // SchemaStringOptions instance\n *\n * @api public\n * @inherits SchemaTypeOptions\n * @constructor SchemaStringOptions\n */\n\nclass SchemaStringOptions extends SchemaTypeOptions {}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"../backend/node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * Array of allowed values for this path\n *\n * @api public\n * @property enum\n * @memberOf SchemaStringOptions\n * @type {Array}\n * @instance\n */\n\nObject.defineProperty(SchemaStringOptions.prototype, 'enum', opts);\n\n/**\n * Attach a validator that succeeds if the data string matches the given regular\n * expression, and fails otherwise.\n *\n * @api public\n * @property match\n * @memberOf SchemaStringOptions\n * @type {RegExp}\n * @instance\n */\n\nObject.defineProperty(SchemaStringOptions.prototype, 'match', opts);\n\n/**\n * If truthy, Mongoose will add a custom setter that lowercases this string\n * using JavaScript's built-in `String#toLowerCase()`.\n *\n * @api public\n * @property lowercase\n * @memberOf SchemaStringOptions\n * @type {Boolean}\n * @instance\n */\n\nObject.defineProperty(SchemaStringOptions.prototype, 'lowercase', opts);\n\n/**\n * If truthy, Mongoose will add a custom setter that removes leading and trailing\n * whitespace using [JavaScript's built-in `String#trim()`](https://masteringjs.io/tutorials/fundamentals/trim-string).\n *\n * @api public\n * @property trim\n * @memberOf SchemaStringOptions\n * @type {Boolean}\n * @instance\n */\n\nObject.defineProperty(SchemaStringOptions.prototype, 'trim', opts);\n\n/**\n * If truthy, Mongoose will add a custom setter that uppercases this string\n * using JavaScript's built-in [`String#toUpperCase()`](https://masteringjs.io/tutorials/fundamentals/uppercase).\n *\n * @api public\n * @property uppercase\n * @memberOf SchemaStringOptions\n * @type {Boolean}\n * @instance\n */\n\nObject.defineProperty(SchemaStringOptions.prototype, 'uppercase', opts);\n\n/**\n * If set, Mongoose will add a custom validator that ensures the given\n * string's `length` is at least the given number.\n *\n * Mongoose supports two different spellings for this option: `minLength` and `minlength`.\n * `minLength` is the recommended way to specify this option, but Mongoose also supports\n * `minlength` (lowercase \"l\").\n *\n * @api public\n * @property minLength\n * @memberOf SchemaStringOptions\n * @type {Number}\n * @instance\n */\n\nObject.defineProperty(SchemaStringOptions.prototype, 'minLength', opts);\nObject.defineProperty(SchemaStringOptions.prototype, 'minlength', opts);\n\n/**\n * If set, Mongoose will add a custom validator that ensures the given\n * string's `length` is at most the given number.\n *\n * Mongoose supports two different spellings for this option: `maxLength` and `maxlength`.\n * `maxLength` is the recommended way to specify this option, but Mongoose also supports\n * `maxlength` (lowercase \"l\").\n *\n * @api public\n * @property maxLength\n * @memberOf SchemaStringOptions\n * @type {Number}\n * @instance\n */\n\nObject.defineProperty(SchemaStringOptions.prototype, 'maxLength', opts);\nObject.defineProperty(SchemaStringOptions.prototype, 'maxlength', opts);\n\n/**\n * Sets default [populate options](https://mongoosejs.com/docs/populate.html#query-conditions).\n *\n * @api public\n * @property populate\n * @memberOf SchemaStringOptions\n * @type {Object}\n * @instance\n */\n\nObject.defineProperty(SchemaStringOptions.prototype, 'populate', opts);\n\n/*!\n * ignore\n */\n\nmodule.exports = SchemaStringOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvc2NoZW1hU3RyaW5nT3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiwwQkFBMEIsbUJBQU8sQ0FBQyw4RkFBcUI7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsY0FBYztBQUNqRCxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsMEZBQW1COztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9vcHRpb25zL3NjaGVtYVN0cmluZ09wdGlvbnMuanM/YWMyYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFNjaGVtYVR5cGVPcHRpb25zID0gcmVxdWlyZSgnLi9zY2hlbWFUeXBlT3B0aW9ucycpO1xuXG4vKipcbiAqIFRoZSBvcHRpb25zIGRlZmluZWQgb24gYSBzdHJpbmcgc2NoZW1hdHlwZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSk7XG4gKiAgICAgc2NoZW1hLnBhdGgoJ25hbWUnKS5vcHRpb25zOyAvLyBTY2hlbWFTdHJpbmdPcHRpb25zIGluc3RhbmNlXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBpbmhlcml0cyBTY2hlbWFUeXBlT3B0aW9uc1xuICogQGNvbnN0cnVjdG9yIFNjaGVtYVN0cmluZ09wdGlvbnNcbiAqL1xuXG5jbGFzcyBTY2hlbWFTdHJpbmdPcHRpb25zIGV4dGVuZHMgU2NoZW1hVHlwZU9wdGlvbnMge31cblxuY29uc3Qgb3B0cyA9IHJlcXVpcmUoJy4vcHJvcGVydHlPcHRpb25zJyk7XG5cbi8qKlxuICogQXJyYXkgb2YgYWxsb3dlZCB2YWx1ZXMgZm9yIHRoaXMgcGF0aFxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgZW51bVxuICogQG1lbWJlck9mIFNjaGVtYVN0cmluZ09wdGlvbnNcbiAqIEB0eXBlIHtBcnJheX1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFTdHJpbmdPcHRpb25zLnByb3RvdHlwZSwgJ2VudW0nLCBvcHRzKTtcblxuLyoqXG4gKiBBdHRhY2ggYSB2YWxpZGF0b3IgdGhhdCBzdWNjZWVkcyBpZiB0aGUgZGF0YSBzdHJpbmcgbWF0Y2hlcyB0aGUgZ2l2ZW4gcmVndWxhclxuICogZXhwcmVzc2lvbiwgYW5kIGZhaWxzIG90aGVyd2lzZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IG1hdGNoXG4gKiBAbWVtYmVyT2YgU2NoZW1hU3RyaW5nT3B0aW9uc1xuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFTdHJpbmdPcHRpb25zLnByb3RvdHlwZSwgJ21hdGNoJywgb3B0cyk7XG5cbi8qKlxuICogSWYgdHJ1dGh5LCBNb25nb29zZSB3aWxsIGFkZCBhIGN1c3RvbSBzZXR0ZXIgdGhhdCBsb3dlcmNhc2VzIHRoaXMgc3RyaW5nXG4gKiB1c2luZyBKYXZhU2NyaXB0J3MgYnVpbHQtaW4gYFN0cmluZyN0b0xvd2VyQ2FzZSgpYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IGxvd2VyY2FzZVxuICogQG1lbWJlck9mIFNjaGVtYVN0cmluZ09wdGlvbnNcbiAqIEB0eXBlIHtCb29sZWFufVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVN0cmluZ09wdGlvbnMucHJvdG90eXBlLCAnbG93ZXJjYXNlJywgb3B0cyk7XG5cbi8qKlxuICogSWYgdHJ1dGh5LCBNb25nb29zZSB3aWxsIGFkZCBhIGN1c3RvbSBzZXR0ZXIgdGhhdCByZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG4gKiB3aGl0ZXNwYWNlIHVzaW5nIFtKYXZhU2NyaXB0J3MgYnVpbHQtaW4gYFN0cmluZyN0cmltKClgXShodHRwczovL21hc3RlcmluZ2pzLmlvL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvdHJpbS1zdHJpbmcpLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgdHJpbVxuICogQG1lbWJlck9mIFNjaGVtYVN0cmluZ09wdGlvbnNcbiAqIEB0eXBlIHtCb29sZWFufVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVN0cmluZ09wdGlvbnMucHJvdG90eXBlLCAndHJpbScsIG9wdHMpO1xuXG4vKipcbiAqIElmIHRydXRoeSwgTW9uZ29vc2Ugd2lsbCBhZGQgYSBjdXN0b20gc2V0dGVyIHRoYXQgdXBwZXJjYXNlcyB0aGlzIHN0cmluZ1xuICogdXNpbmcgSmF2YVNjcmlwdCdzIGJ1aWx0LWluIFtgU3RyaW5nI3RvVXBwZXJDYXNlKClgXShodHRwczovL21hc3RlcmluZ2pzLmlvL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvdXBwZXJjYXNlKS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IHVwcGVyY2FzZVxuICogQG1lbWJlck9mIFNjaGVtYVN0cmluZ09wdGlvbnNcbiAqIEB0eXBlIHtCb29sZWFufVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVN0cmluZ09wdGlvbnMucHJvdG90eXBlLCAndXBwZXJjYXNlJywgb3B0cyk7XG5cbi8qKlxuICogSWYgc2V0LCBNb25nb29zZSB3aWxsIGFkZCBhIGN1c3RvbSB2YWxpZGF0b3IgdGhhdCBlbnN1cmVzIHRoZSBnaXZlblxuICogc3RyaW5nJ3MgYGxlbmd0aGAgaXMgYXQgbGVhc3QgdGhlIGdpdmVuIG51bWJlci5cbiAqXG4gKiBNb25nb29zZSBzdXBwb3J0cyB0d28gZGlmZmVyZW50IHNwZWxsaW5ncyBmb3IgdGhpcyBvcHRpb246IGBtaW5MZW5ndGhgIGFuZCBgbWlubGVuZ3RoYC5cbiAqIGBtaW5MZW5ndGhgIGlzIHRoZSByZWNvbW1lbmRlZCB3YXkgdG8gc3BlY2lmeSB0aGlzIG9wdGlvbiwgYnV0IE1vbmdvb3NlIGFsc28gc3VwcG9ydHNcbiAqIGBtaW5sZW5ndGhgIChsb3dlcmNhc2UgXCJsXCIpLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgbWluTGVuZ3RoXG4gKiBAbWVtYmVyT2YgU2NoZW1hU3RyaW5nT3B0aW9uc1xuICogQHR5cGUge051bWJlcn1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFTdHJpbmdPcHRpb25zLnByb3RvdHlwZSwgJ21pbkxlbmd0aCcsIG9wdHMpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVN0cmluZ09wdGlvbnMucHJvdG90eXBlLCAnbWlubGVuZ3RoJywgb3B0cyk7XG5cbi8qKlxuICogSWYgc2V0LCBNb25nb29zZSB3aWxsIGFkZCBhIGN1c3RvbSB2YWxpZGF0b3IgdGhhdCBlbnN1cmVzIHRoZSBnaXZlblxuICogc3RyaW5nJ3MgYGxlbmd0aGAgaXMgYXQgbW9zdCB0aGUgZ2l2ZW4gbnVtYmVyLlxuICpcbiAqIE1vbmdvb3NlIHN1cHBvcnRzIHR3byBkaWZmZXJlbnQgc3BlbGxpbmdzIGZvciB0aGlzIG9wdGlvbjogYG1heExlbmd0aGAgYW5kIGBtYXhsZW5ndGhgLlxuICogYG1heExlbmd0aGAgaXMgdGhlIHJlY29tbWVuZGVkIHdheSB0byBzcGVjaWZ5IHRoaXMgb3B0aW9uLCBidXQgTW9uZ29vc2UgYWxzbyBzdXBwb3J0c1xuICogYG1heGxlbmd0aGAgKGxvd2VyY2FzZSBcImxcIikuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBtYXhMZW5ndGhcbiAqIEBtZW1iZXJPZiBTY2hlbWFTdHJpbmdPcHRpb25zXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVN0cmluZ09wdGlvbnMucHJvdG90eXBlLCAnbWF4TGVuZ3RoJywgb3B0cyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hU3RyaW5nT3B0aW9ucy5wcm90b3R5cGUsICdtYXhsZW5ndGgnLCBvcHRzKTtcblxuLyoqXG4gKiBTZXRzIGRlZmF1bHQgW3BvcHVsYXRlIG9wdGlvbnNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9wb3B1bGF0ZS5odG1sI3F1ZXJ5LWNvbmRpdGlvbnMpLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgcG9wdWxhdGVcbiAqIEBtZW1iZXJPZiBTY2hlbWFTdHJpbmdPcHRpb25zXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVN0cmluZ09wdGlvbnMucHJvdG90eXBlLCAncG9wdWxhdGUnLCBvcHRzKTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYVN0cmluZ09wdGlvbnM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/options/schemaStringOptions.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/options/schemaSubdocumentOptions.js":
/*!********************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/options/schemaSubdocumentOptions.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst SchemaTypeOptions = __webpack_require__(/*! ./schemaTypeOptions */ \"../backend/node_modules/mongoose/lib/options/schemaTypeOptions.js\");\n\n/**\n * The options defined on a single nested schematype.\n *\n * #### Example:\n *\n *     const schema = Schema({ child: Schema({ name: String }) });\n *     schema.path('child').options; // SchemaSubdocumentOptions instance\n *\n * @api public\n * @inherits SchemaTypeOptions\n * @constructor SchemaSubdocumentOptions\n */\n\nclass SchemaSubdocumentOptions extends SchemaTypeOptions {}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"../backend/node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * If set, overwrites the child schema's `_id` option.\n *\n * #### Example:\n *\n *     const childSchema = Schema({ name: String });\n *     const parentSchema = Schema({\n *       child: { type: childSchema, _id: false }\n *     });\n *     parentSchema.path('child').schema.options._id; // false\n *\n * @api public\n * @property of\n * @memberOf SchemaSubdocumentOptions\n * @type {Function|string}\n * @instance\n */\n\nObject.defineProperty(SchemaSubdocumentOptions.prototype, '_id', opts);\n\nmodule.exports = SchemaSubdocumentOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvc2NoZW1hU3ViZG9jdW1lbnRPcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDBCQUEwQixtQkFBTyxDQUFDLDhGQUFxQjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0IsY0FBYyxHQUFHO0FBQ2hFLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQywwRkFBbUI7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBLGtCQUFrQjtBQUNsQixRQUFRO0FBQ1Isc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy9zY2hlbWFTdWJkb2N1bWVudE9wdGlvbnMuanM/OTRlYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFNjaGVtYVR5cGVPcHRpb25zID0gcmVxdWlyZSgnLi9zY2hlbWFUeXBlT3B0aW9ucycpO1xuXG4vKipcbiAqIFRoZSBvcHRpb25zIGRlZmluZWQgb24gYSBzaW5nbGUgbmVzdGVkIHNjaGVtYXR5cGUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBTY2hlbWEoeyBjaGlsZDogU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0pIH0pO1xuICogICAgIHNjaGVtYS5wYXRoKCdjaGlsZCcpLm9wdGlvbnM7IC8vIFNjaGVtYVN1YmRvY3VtZW50T3B0aW9ucyBpbnN0YW5jZVxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAaW5oZXJpdHMgU2NoZW1hVHlwZU9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvciBTY2hlbWFTdWJkb2N1bWVudE9wdGlvbnNcbiAqL1xuXG5jbGFzcyBTY2hlbWFTdWJkb2N1bWVudE9wdGlvbnMgZXh0ZW5kcyBTY2hlbWFUeXBlT3B0aW9ucyB7fVxuXG5jb25zdCBvcHRzID0gcmVxdWlyZSgnLi9wcm9wZXJ0eU9wdGlvbnMnKTtcblxuLyoqXG4gKiBJZiBzZXQsIG92ZXJ3cml0ZXMgdGhlIGNoaWxkIHNjaGVtYSdzIGBfaWRgIG9wdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGNoaWxkU2NoZW1hID0gU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0pO1xuICogICAgIGNvbnN0IHBhcmVudFNjaGVtYSA9IFNjaGVtYSh7XG4gKiAgICAgICBjaGlsZDogeyB0eXBlOiBjaGlsZFNjaGVtYSwgX2lkOiBmYWxzZSB9XG4gKiAgICAgfSk7XG4gKiAgICAgcGFyZW50U2NoZW1hLnBhdGgoJ2NoaWxkJykuc2NoZW1hLm9wdGlvbnMuX2lkOyAvLyBmYWxzZVxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgb2ZcbiAqIEBtZW1iZXJPZiBTY2hlbWFTdWJkb2N1bWVudE9wdGlvbnNcbiAqIEB0eXBlIHtGdW5jdGlvbnxzdHJpbmd9XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hU3ViZG9jdW1lbnRPcHRpb25zLnByb3RvdHlwZSwgJ19pZCcsIG9wdHMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYVN1YmRvY3VtZW50T3B0aW9ucztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/options/schemaSubdocumentOptions.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/options/schemaTypeOptions.js":
/*!*************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/options/schemaTypeOptions.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst clone = __webpack_require__(/*! ../helpers/clone */ \"../backend/node_modules/mongoose/lib/helpers/clone.js\");\n\n/**\n * The options defined on a schematype.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String });\n *     schema.path('name').options instanceof mongoose.SchemaTypeOptions; // true\n *\n * @api public\n * @constructor SchemaTypeOptions\n */\n\nclass SchemaTypeOptions {\n  constructor(obj) {\n    if (obj == null) {\n      return this;\n    }\n    Object.assign(this, clone(obj));\n  }\n}\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"../backend/node_modules/mongoose/lib/options/propertyOptions.js\");\n\n/**\n * The type to cast this path to.\n *\n * @api public\n * @property type\n * @memberOf SchemaTypeOptions\n * @type {Function|String|Object}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'type', opts);\n\n/**\n * Function or object describing how to validate this schematype.\n *\n * @api public\n * @property validate\n * @memberOf SchemaTypeOptions\n * @type {Function|Object}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'validate', opts);\n\n/**\n * Allows overriding casting logic for this individual path. If a string, the\n * given string overwrites Mongoose's default cast error message.\n *\n * #### Example:\n *\n *     const schema = new Schema({\n *       num: {\n *         type: Number,\n *         cast: '{VALUE} is not a valid number'\n *       }\n *     });\n *\n *     // Throws 'CastError: \"bad\" is not a valid number'\n *     schema.path('num').cast('bad');\n *\n *     const Model = mongoose.model('Test', schema);\n *     const doc = new Model({ num: 'fail' });\n *     const err = doc.validateSync();\n *\n *     err.errors['num']; // 'CastError: \"fail\" is not a valid number'\n *\n * @api public\n * @property cast\n * @memberOf SchemaTypeOptions\n * @type {String}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'cast', opts);\n\n/**\n * If true, attach a required validator to this path, which ensures this path\n * cannot be set to a nullish value. If a function, Mongoose calls the\n * function and only checks for nullish values if the function returns a truthy value.\n *\n * @api public\n * @property required\n * @memberOf SchemaTypeOptions\n * @type {Function|Boolean}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'required', opts);\n\n/**\n * The default value for this path. If a function, Mongoose executes the function\n * and uses the return value as the default.\n *\n * @api public\n * @property default\n * @memberOf SchemaTypeOptions\n * @type {Function|Any}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'default', opts);\n\n/**\n * The model that `populate()` should use if populating this path.\n *\n * @api public\n * @property ref\n * @memberOf SchemaTypeOptions\n * @type {Function|String}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'ref', opts);\n\n/**\n * The path in the document that `populate()` should use to find the model\n * to use.\n *\n * @api public\n * @property ref\n * @memberOf SchemaTypeOptions\n * @type {Function|String}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'refPath', opts);\n\n/**\n * Whether to include or exclude this path by default when loading documents\n * using `find()`, `findOne()`, etc.\n *\n * @api public\n * @property select\n * @memberOf SchemaTypeOptions\n * @type {Boolean|Number}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'select', opts);\n\n/**\n * If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will\n * build an index on this path when the model is compiled.\n *\n * @api public\n * @property index\n * @memberOf SchemaTypeOptions\n * @type {Boolean|Number|Object}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'index', opts);\n\n/**\n * If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose\n * will build a unique index on this path when the\n * model is compiled. [The `unique` option is **not** a validator](https://mongoosejs.com/docs/validation.html#the-unique-option-is-not-a-validator).\n *\n * @api public\n * @property unique\n * @memberOf SchemaTypeOptions\n * @type {Boolean|Number}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'unique', opts);\n\n/**\n * If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will\n * disallow changes to this path once the document\n * is saved to the database for the first time. Read more about [immutability in Mongoose here](https://thecodebarbarian.com/whats-new-in-mongoose-5-6-immutable-properties.html).\n *\n * @api public\n * @property immutable\n * @memberOf SchemaTypeOptions\n * @type {Function|Boolean}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'immutable', opts);\n\n/**\n * If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose will\n * build a sparse index on this path.\n *\n * @api public\n * @property sparse\n * @memberOf SchemaTypeOptions\n * @type {Boolean|Number}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'sparse', opts);\n\n/**\n * If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), Mongoose\n * will build a text index on this path.\n *\n * @api public\n * @property text\n * @memberOf SchemaTypeOptions\n * @type {Boolean|Number|Object}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'text', opts);\n\n/**\n * Define a transform function for this individual schema type.\n * Only called when calling `toJSON()` or `toObject()`.\n *\n * #### Example:\n *\n *     const schema = Schema({\n *       myDate: {\n *         type: Date,\n *         transform: v => v.getFullYear()\n *       }\n *     });\n *     const Model = mongoose.model('Test', schema);\n *\n *     const doc = new Model({ myDate: new Date('2019/06/01') });\n *     doc.myDate instanceof Date; // true\n *\n *     const res = doc.toObject({ transform: true });\n *     res.myDate; // 2019\n *\n * @api public\n * @property transform\n * @memberOf SchemaTypeOptions\n * @type {Function}\n * @instance\n */\n\nObject.defineProperty(SchemaTypeOptions.prototype, 'transform', opts);\n\nmodule.exports = SchemaTypeOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvc2NoZW1hVHlwZU9wdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLCtFQUFrQjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxjQUFjO0FBQ2pELDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQywwRkFBbUI7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsYUFBYTtBQUM1QztBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsK0JBQStCLGdDQUFnQztBQUMvRCxtQ0FBbUM7QUFDbkM7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25ELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvc2NoZW1hVHlwZU9wdGlvbnMuanM/NDNmZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGNsb25lID0gcmVxdWlyZSgnLi4vaGVscGVycy9jbG9uZScpO1xuXG4vKipcbiAqIFRoZSBvcHRpb25zIGRlZmluZWQgb24gYSBzY2hlbWF0eXBlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZyB9KTtcbiAqICAgICBzY2hlbWEucGF0aCgnbmFtZScpLm9wdGlvbnMgaW5zdGFuY2VvZiBtb25nb29zZS5TY2hlbWFUeXBlT3B0aW9uczsgLy8gdHJ1ZVxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAY29uc3RydWN0b3IgU2NoZW1hVHlwZU9wdGlvbnNcbiAqL1xuXG5jbGFzcyBTY2hlbWFUeXBlT3B0aW9ucyB7XG4gIGNvbnN0cnVjdG9yKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2xvbmUob2JqKSk7XG4gIH1cbn1cblxuY29uc3Qgb3B0cyA9IHJlcXVpcmUoJy4vcHJvcGVydHlPcHRpb25zJyk7XG5cbi8qKlxuICogVGhlIHR5cGUgdG8gY2FzdCB0aGlzIHBhdGggdG8uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSB0eXBlXG4gKiBAbWVtYmVyT2YgU2NoZW1hVHlwZU9wdGlvbnNcbiAqIEB0eXBlIHtGdW5jdGlvbnxTdHJpbmd8T2JqZWN0fVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVR5cGVPcHRpb25zLnByb3RvdHlwZSwgJ3R5cGUnLCBvcHRzKTtcblxuLyoqXG4gKiBGdW5jdGlvbiBvciBvYmplY3QgZGVzY3JpYmluZyBob3cgdG8gdmFsaWRhdGUgdGhpcyBzY2hlbWF0eXBlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgdmFsaWRhdGVcbiAqIEBtZW1iZXJPZiBTY2hlbWFUeXBlT3B0aW9uc1xuICogQHR5cGUge0Z1bmN0aW9ufE9iamVjdH1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFUeXBlT3B0aW9ucy5wcm90b3R5cGUsICd2YWxpZGF0ZScsIG9wdHMpO1xuXG4vKipcbiAqIEFsbG93cyBvdmVycmlkaW5nIGNhc3RpbmcgbG9naWMgZm9yIHRoaXMgaW5kaXZpZHVhbCBwYXRoLiBJZiBhIHN0cmluZywgdGhlXG4gKiBnaXZlbiBzdHJpbmcgb3ZlcndyaXRlcyBNb25nb29zZSdzIGRlZmF1bHQgY2FzdCBlcnJvciBtZXNzYWdlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7XG4gKiAgICAgICBudW06IHtcbiAqICAgICAgICAgdHlwZTogTnVtYmVyLFxuICogICAgICAgICBjYXN0OiAne1ZBTFVFfSBpcyBub3QgYSB2YWxpZCBudW1iZXInXG4gKiAgICAgICB9XG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vIFRocm93cyAnQ2FzdEVycm9yOiBcImJhZFwiIGlzIG5vdCBhIHZhbGlkIG51bWJlcidcbiAqICAgICBzY2hlbWEucGF0aCgnbnVtJykuY2FzdCgnYmFkJyk7XG4gKlxuICogICAgIGNvbnN0IE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBzY2hlbWEpO1xuICogICAgIGNvbnN0IGRvYyA9IG5ldyBNb2RlbCh7IG51bTogJ2ZhaWwnIH0pO1xuICogICAgIGNvbnN0IGVyciA9IGRvYy52YWxpZGF0ZVN5bmMoKTtcbiAqXG4gKiAgICAgZXJyLmVycm9yc1snbnVtJ107IC8vICdDYXN0RXJyb3I6IFwiZmFpbFwiIGlzIG5vdCBhIHZhbGlkIG51bWJlcidcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IGNhc3RcbiAqIEBtZW1iZXJPZiBTY2hlbWFUeXBlT3B0aW9uc1xuICogQHR5cGUge1N0cmluZ31cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFUeXBlT3B0aW9ucy5wcm90b3R5cGUsICdjYXN0Jywgb3B0cyk7XG5cbi8qKlxuICogSWYgdHJ1ZSwgYXR0YWNoIGEgcmVxdWlyZWQgdmFsaWRhdG9yIHRvIHRoaXMgcGF0aCwgd2hpY2ggZW5zdXJlcyB0aGlzIHBhdGhcbiAqIGNhbm5vdCBiZSBzZXQgdG8gYSBudWxsaXNoIHZhbHVlLiBJZiBhIGZ1bmN0aW9uLCBNb25nb29zZSBjYWxscyB0aGVcbiAqIGZ1bmN0aW9uIGFuZCBvbmx5IGNoZWNrcyBmb3IgbnVsbGlzaCB2YWx1ZXMgaWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYSB0cnV0aHkgdmFsdWUuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSByZXF1aXJlZFxuICogQG1lbWJlck9mIFNjaGVtYVR5cGVPcHRpb25zXG4gKiBAdHlwZSB7RnVuY3Rpb258Qm9vbGVhbn1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFUeXBlT3B0aW9ucy5wcm90b3R5cGUsICdyZXF1aXJlZCcsIG9wdHMpO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGlzIHBhdGguIElmIGEgZnVuY3Rpb24sIE1vbmdvb3NlIGV4ZWN1dGVzIHRoZSBmdW5jdGlvblxuICogYW5kIHVzZXMgdGhlIHJldHVybiB2YWx1ZSBhcyB0aGUgZGVmYXVsdC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IGRlZmF1bHRcbiAqIEBtZW1iZXJPZiBTY2hlbWFUeXBlT3B0aW9uc1xuICogQHR5cGUge0Z1bmN0aW9ufEFueX1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFUeXBlT3B0aW9ucy5wcm90b3R5cGUsICdkZWZhdWx0Jywgb3B0cyk7XG5cbi8qKlxuICogVGhlIG1vZGVsIHRoYXQgYHBvcHVsYXRlKClgIHNob3VsZCB1c2UgaWYgcG9wdWxhdGluZyB0aGlzIHBhdGguXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSByZWZcbiAqIEBtZW1iZXJPZiBTY2hlbWFUeXBlT3B0aW9uc1xuICogQHR5cGUge0Z1bmN0aW9ufFN0cmluZ31cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFUeXBlT3B0aW9ucy5wcm90b3R5cGUsICdyZWYnLCBvcHRzKTtcblxuLyoqXG4gKiBUaGUgcGF0aCBpbiB0aGUgZG9jdW1lbnQgdGhhdCBgcG9wdWxhdGUoKWAgc2hvdWxkIHVzZSB0byBmaW5kIHRoZSBtb2RlbFxuICogdG8gdXNlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgcmVmXG4gKiBAbWVtYmVyT2YgU2NoZW1hVHlwZU9wdGlvbnNcbiAqIEB0eXBlIHtGdW5jdGlvbnxTdHJpbmd9XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hVHlwZU9wdGlvbnMucHJvdG90eXBlLCAncmVmUGF0aCcsIG9wdHMpO1xuXG4vKipcbiAqIFdoZXRoZXIgdG8gaW5jbHVkZSBvciBleGNsdWRlIHRoaXMgcGF0aCBieSBkZWZhdWx0IHdoZW4gbG9hZGluZyBkb2N1bWVudHNcbiAqIHVzaW5nIGBmaW5kKClgLCBgZmluZE9uZSgpYCwgZXRjLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgc2VsZWN0XG4gKiBAbWVtYmVyT2YgU2NoZW1hVHlwZU9wdGlvbnNcbiAqIEB0eXBlIHtCb29sZWFufE51bWJlcn1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFUeXBlT3B0aW9ucy5wcm90b3R5cGUsICdzZWxlY3QnLCBvcHRzKTtcblxuLyoqXG4gKiBJZiBbdHJ1dGh5XShodHRwczovL21hc3RlcmluZ2pzLmlvL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvdHJ1dGh5KSwgTW9uZ29vc2Ugd2lsbFxuICogYnVpbGQgYW4gaW5kZXggb24gdGhpcyBwYXRoIHdoZW4gdGhlIG1vZGVsIGlzIGNvbXBpbGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgaW5kZXhcbiAqIEBtZW1iZXJPZiBTY2hlbWFUeXBlT3B0aW9uc1xuICogQHR5cGUge0Jvb2xlYW58TnVtYmVyfE9iamVjdH1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFUeXBlT3B0aW9ucy5wcm90b3R5cGUsICdpbmRleCcsIG9wdHMpO1xuXG4vKipcbiAqIElmIFt0cnV0aHldKGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy90cnV0aHkpLCBNb25nb29zZVxuICogd2lsbCBidWlsZCBhIHVuaXF1ZSBpbmRleCBvbiB0aGlzIHBhdGggd2hlbiB0aGVcbiAqIG1vZGVsIGlzIGNvbXBpbGVkLiBbVGhlIGB1bmlxdWVgIG9wdGlvbiBpcyAqKm5vdCoqIGEgdmFsaWRhdG9yXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdmFsaWRhdGlvbi5odG1sI3RoZS11bmlxdWUtb3B0aW9uLWlzLW5vdC1hLXZhbGlkYXRvcikuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSB1bmlxdWVcbiAqIEBtZW1iZXJPZiBTY2hlbWFUeXBlT3B0aW9uc1xuICogQHR5cGUge0Jvb2xlYW58TnVtYmVyfVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVR5cGVPcHRpb25zLnByb3RvdHlwZSwgJ3VuaXF1ZScsIG9wdHMpO1xuXG4vKipcbiAqIElmIFt0cnV0aHldKGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy90cnV0aHkpLCBNb25nb29zZSB3aWxsXG4gKiBkaXNhbGxvdyBjaGFuZ2VzIHRvIHRoaXMgcGF0aCBvbmNlIHRoZSBkb2N1bWVudFxuICogaXMgc2F2ZWQgdG8gdGhlIGRhdGFiYXNlIGZvciB0aGUgZmlyc3QgdGltZS4gUmVhZCBtb3JlIGFib3V0IFtpbW11dGFiaWxpdHkgaW4gTW9uZ29vc2UgaGVyZV0oaHR0cHM6Ly90aGVjb2RlYmFyYmFyaWFuLmNvbS93aGF0cy1uZXctaW4tbW9uZ29vc2UtNS02LWltbXV0YWJsZS1wcm9wZXJ0aWVzLmh0bWwpLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgaW1tdXRhYmxlXG4gKiBAbWVtYmVyT2YgU2NoZW1hVHlwZU9wdGlvbnNcbiAqIEB0eXBlIHtGdW5jdGlvbnxCb29sZWFufVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVR5cGVPcHRpb25zLnByb3RvdHlwZSwgJ2ltbXV0YWJsZScsIG9wdHMpO1xuXG4vKipcbiAqIElmIFt0cnV0aHldKGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy90cnV0aHkpLCBNb25nb29zZSB3aWxsXG4gKiBidWlsZCBhIHNwYXJzZSBpbmRleCBvbiB0aGlzIHBhdGguXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBzcGFyc2VcbiAqIEBtZW1iZXJPZiBTY2hlbWFUeXBlT3B0aW9uc1xuICogQHR5cGUge0Jvb2xlYW58TnVtYmVyfVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVR5cGVPcHRpb25zLnByb3RvdHlwZSwgJ3NwYXJzZScsIG9wdHMpO1xuXG4vKipcbiAqIElmIFt0cnV0aHldKGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy90cnV0aHkpLCBNb25nb29zZVxuICogd2lsbCBidWlsZCBhIHRleHQgaW5kZXggb24gdGhpcyBwYXRoLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgdGV4dFxuICogQG1lbWJlck9mIFNjaGVtYVR5cGVPcHRpb25zXG4gKiBAdHlwZSB7Qm9vbGVhbnxOdW1iZXJ8T2JqZWN0fVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVR5cGVPcHRpb25zLnByb3RvdHlwZSwgJ3RleHQnLCBvcHRzKTtcblxuLyoqXG4gKiBEZWZpbmUgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gZm9yIHRoaXMgaW5kaXZpZHVhbCBzY2hlbWEgdHlwZS5cbiAqIE9ubHkgY2FsbGVkIHdoZW4gY2FsbGluZyBgdG9KU09OKClgIG9yIGB0b09iamVjdCgpYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IFNjaGVtYSh7XG4gKiAgICAgICBteURhdGU6IHtcbiAqICAgICAgICAgdHlwZTogRGF0ZSxcbiAqICAgICAgICAgdHJhbnNmb3JtOiB2ID0+IHYuZ2V0RnVsbFllYXIoKVxuICogICAgICAgfVxuICogICAgIH0pO1xuICogICAgIGNvbnN0IE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBzY2hlbWEpO1xuICpcbiAqICAgICBjb25zdCBkb2MgPSBuZXcgTW9kZWwoeyBteURhdGU6IG5ldyBEYXRlKCcyMDE5LzA2LzAxJykgfSk7XG4gKiAgICAgZG9jLm15RGF0ZSBpbnN0YW5jZW9mIERhdGU7IC8vIHRydWVcbiAqXG4gKiAgICAgY29uc3QgcmVzID0gZG9jLnRvT2JqZWN0KHsgdHJhbnNmb3JtOiB0cnVlIH0pO1xuICogICAgIHJlcy5teURhdGU7IC8vIDIwMTlcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IHRyYW5zZm9ybVxuICogQG1lbWJlck9mIFNjaGVtYVR5cGVPcHRpb25zXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hVHlwZU9wdGlvbnMucHJvdG90eXBlLCAndHJhbnNmb3JtJywgb3B0cyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hVHlwZU9wdGlvbnM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/options/schemaTypeOptions.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/options/virtualOptions.js":
/*!**********************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/options/virtualOptions.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst opts = __webpack_require__(/*! ./propertyOptions */ \"../backend/node_modules/mongoose/lib/options/propertyOptions.js\");\n\nclass VirtualOptions {\n  constructor(obj) {\n    Object.assign(this, obj);\n\n    if (obj != null && obj.options != null) {\n      this.options = Object.assign({}, obj.options);\n    }\n  }\n}\n\n/**\n * Marks this virtual as a populate virtual, and specifies the model to\n * use for populate.\n *\n * @api public\n * @property ref\n * @memberOf VirtualOptions\n * @type {String|Model|Function}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'ref', opts);\n\n/**\n * Marks this virtual as a populate virtual, and specifies the path that\n * contains the name of the model to populate\n *\n * @api public\n * @property refPath\n * @memberOf VirtualOptions\n * @type {String|Function}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'refPath', opts);\n\n/**\n * The name of the property in the local model to match to `foreignField`\n * in the foreign model.\n *\n * @api public\n * @property localField\n * @memberOf VirtualOptions\n * @type {String|Function}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'localField', opts);\n\n/**\n * The name of the property in the foreign model to match to `localField`\n * in the local model.\n *\n * @api public\n * @property foreignField\n * @memberOf VirtualOptions\n * @type {String|Function}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'foreignField', opts);\n\n/**\n * Whether to populate this virtual as a single document (true) or an\n * array of documents (false).\n *\n * @api public\n * @property justOne\n * @memberOf VirtualOptions\n * @type {Boolean}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'justOne', opts);\n\n/**\n * If true, populate just the number of documents where `localField`\n * matches `foreignField`, as opposed to the documents themselves.\n *\n * If `count` is set, it overrides `justOne`.\n *\n * @api public\n * @property count\n * @memberOf VirtualOptions\n * @type {Boolean}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'count', opts);\n\n/**\n * Add an additional filter to populate, in addition to `localField`\n * matches `foreignField`.\n *\n * @api public\n * @property match\n * @memberOf VirtualOptions\n * @type {Object|Function}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'match', opts);\n\n/**\n * Additional options to pass to the query used to `populate()`:\n *\n * - `sort`\n * - `skip`\n * - `limit`\n *\n * @api public\n * @property options\n * @memberOf VirtualOptions\n * @type {Object}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'options', opts);\n\n/**\n * If true, add a `skip` to the query used to `populate()`.\n *\n * @api public\n * @property skip\n * @memberOf VirtualOptions\n * @type {Number}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'skip', opts);\n\n/**\n * If true, add a `limit` to the query used to `populate()`.\n *\n * @api public\n * @property limit\n * @memberOf VirtualOptions\n * @type {Number}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'limit', opts);\n\n/**\n * The `limit` option for `populate()` has [some unfortunate edge cases](https://mongoosejs.com/docs/populate.html#query-conditions)\n * when working with multiple documents, like `.find().populate()`. The\n * `perDocumentLimit` option makes `populate()` execute a separate query\n * for each document returned from `find()` to ensure each document\n * gets up to `perDocumentLimit` populated docs if possible.\n *\n * @api public\n * @property perDocumentLimit\n * @memberOf VirtualOptions\n * @type {Number}\n * @instance\n */\n\nObject.defineProperty(VirtualOptions.prototype, 'perDocumentLimit', opts);\n\nmodule.exports = VirtualOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL29wdGlvbnMvdmlydHVhbE9wdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLDBGQUFtQjs7QUFFeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvb3B0aW9ucy92aXJ0dWFsT3B0aW9ucy5qcz81NWFmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3Qgb3B0cyA9IHJlcXVpcmUoJy4vcHJvcGVydHlPcHRpb25zJyk7XG5cbmNsYXNzIFZpcnR1YWxPcHRpb25zIHtcbiAgY29uc3RydWN0b3Iob2JqKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvYmopO1xuXG4gICAgaWYgKG9iaiAhPSBudWxsICYmIG9iai5vcHRpb25zICE9IG51bGwpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9iai5vcHRpb25zKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNYXJrcyB0aGlzIHZpcnR1YWwgYXMgYSBwb3B1bGF0ZSB2aXJ0dWFsLCBhbmQgc3BlY2lmaWVzIHRoZSBtb2RlbCB0b1xuICogdXNlIGZvciBwb3B1bGF0ZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IHJlZlxuICogQG1lbWJlck9mIFZpcnR1YWxPcHRpb25zXG4gKiBAdHlwZSB7U3RyaW5nfE1vZGVsfEZ1bmN0aW9ufVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpcnR1YWxPcHRpb25zLnByb3RvdHlwZSwgJ3JlZicsIG9wdHMpO1xuXG4vKipcbiAqIE1hcmtzIHRoaXMgdmlydHVhbCBhcyBhIHBvcHVsYXRlIHZpcnR1YWwsIGFuZCBzcGVjaWZpZXMgdGhlIHBhdGggdGhhdFxuICogY29udGFpbnMgdGhlIG5hbWUgb2YgdGhlIG1vZGVsIHRvIHBvcHVsYXRlXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSByZWZQYXRoXG4gKiBAbWVtYmVyT2YgVmlydHVhbE9wdGlvbnNcbiAqIEB0eXBlIHtTdHJpbmd8RnVuY3Rpb259XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVmlydHVhbE9wdGlvbnMucHJvdG90eXBlLCAncmVmUGF0aCcsIG9wdHMpO1xuXG4vKipcbiAqIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSBpbiB0aGUgbG9jYWwgbW9kZWwgdG8gbWF0Y2ggdG8gYGZvcmVpZ25GaWVsZGBcbiAqIGluIHRoZSBmb3JlaWduIG1vZGVsLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgbG9jYWxGaWVsZFxuICogQG1lbWJlck9mIFZpcnR1YWxPcHRpb25zXG4gKiBAdHlwZSB7U3RyaW5nfEZ1bmN0aW9ufVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpcnR1YWxPcHRpb25zLnByb3RvdHlwZSwgJ2xvY2FsRmllbGQnLCBvcHRzKTtcblxuLyoqXG4gKiBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgaW4gdGhlIGZvcmVpZ24gbW9kZWwgdG8gbWF0Y2ggdG8gYGxvY2FsRmllbGRgXG4gKiBpbiB0aGUgbG9jYWwgbW9kZWwuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBmb3JlaWduRmllbGRcbiAqIEBtZW1iZXJPZiBWaXJ0dWFsT3B0aW9uc1xuICogQHR5cGUge1N0cmluZ3xGdW5jdGlvbn1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaXJ0dWFsT3B0aW9ucy5wcm90b3R5cGUsICdmb3JlaWduRmllbGQnLCBvcHRzKTtcblxuLyoqXG4gKiBXaGV0aGVyIHRvIHBvcHVsYXRlIHRoaXMgdmlydHVhbCBhcyBhIHNpbmdsZSBkb2N1bWVudCAodHJ1ZSkgb3IgYW5cbiAqIGFycmF5IG9mIGRvY3VtZW50cyAoZmFsc2UpLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkganVzdE9uZVxuICogQG1lbWJlck9mIFZpcnR1YWxPcHRpb25zXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaXJ0dWFsT3B0aW9ucy5wcm90b3R5cGUsICdqdXN0T25lJywgb3B0cyk7XG5cbi8qKlxuICogSWYgdHJ1ZSwgcG9wdWxhdGUganVzdCB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyB3aGVyZSBgbG9jYWxGaWVsZGBcbiAqIG1hdGNoZXMgYGZvcmVpZ25GaWVsZGAsIGFzIG9wcG9zZWQgdG8gdGhlIGRvY3VtZW50cyB0aGVtc2VsdmVzLlxuICpcbiAqIElmIGBjb3VudGAgaXMgc2V0LCBpdCBvdmVycmlkZXMgYGp1c3RPbmVgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgY291bnRcbiAqIEBtZW1iZXJPZiBWaXJ0dWFsT3B0aW9uc1xuICogQHR5cGUge0Jvb2xlYW59XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVmlydHVhbE9wdGlvbnMucHJvdG90eXBlLCAnY291bnQnLCBvcHRzKTtcblxuLyoqXG4gKiBBZGQgYW4gYWRkaXRpb25hbCBmaWx0ZXIgdG8gcG9wdWxhdGUsIGluIGFkZGl0aW9uIHRvIGBsb2NhbEZpZWxkYFxuICogbWF0Y2hlcyBgZm9yZWlnbkZpZWxkYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IG1hdGNoXG4gKiBAbWVtYmVyT2YgVmlydHVhbE9wdGlvbnNcbiAqIEB0eXBlIHtPYmplY3R8RnVuY3Rpb259XG4gKiBAaW5zdGFuY2VcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVmlydHVhbE9wdGlvbnMucHJvdG90eXBlLCAnbWF0Y2gnLCBvcHRzKTtcblxuLyoqXG4gKiBBZGRpdGlvbmFsIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgcXVlcnkgdXNlZCB0byBgcG9wdWxhdGUoKWA6XG4gKlxuICogLSBgc29ydGBcbiAqIC0gYHNraXBgXG4gKiAtIGBsaW1pdGBcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IG9wdGlvbnNcbiAqIEBtZW1iZXJPZiBWaXJ0dWFsT3B0aW9uc1xuICogQHR5cGUge09iamVjdH1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaXJ0dWFsT3B0aW9ucy5wcm90b3R5cGUsICdvcHRpb25zJywgb3B0cyk7XG5cbi8qKlxuICogSWYgdHJ1ZSwgYWRkIGEgYHNraXBgIHRvIHRoZSBxdWVyeSB1c2VkIHRvIGBwb3B1bGF0ZSgpYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IHNraXBcbiAqIEBtZW1iZXJPZiBWaXJ0dWFsT3B0aW9uc1xuICogQHR5cGUge051bWJlcn1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaXJ0dWFsT3B0aW9ucy5wcm90b3R5cGUsICdza2lwJywgb3B0cyk7XG5cbi8qKlxuICogSWYgdHJ1ZSwgYWRkIGEgYGxpbWl0YCB0byB0aGUgcXVlcnkgdXNlZCB0byBgcG9wdWxhdGUoKWAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSBsaW1pdFxuICogQG1lbWJlck9mIFZpcnR1YWxPcHRpb25zXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpcnR1YWxPcHRpb25zLnByb3RvdHlwZSwgJ2xpbWl0Jywgb3B0cyk7XG5cbi8qKlxuICogVGhlIGBsaW1pdGAgb3B0aW9uIGZvciBgcG9wdWxhdGUoKWAgaGFzIFtzb21lIHVuZm9ydHVuYXRlIGVkZ2UgY2FzZXNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9wb3B1bGF0ZS5odG1sI3F1ZXJ5LWNvbmRpdGlvbnMpXG4gKiB3aGVuIHdvcmtpbmcgd2l0aCBtdWx0aXBsZSBkb2N1bWVudHMsIGxpa2UgYC5maW5kKCkucG9wdWxhdGUoKWAuIFRoZVxuICogYHBlckRvY3VtZW50TGltaXRgIG9wdGlvbiBtYWtlcyBgcG9wdWxhdGUoKWAgZXhlY3V0ZSBhIHNlcGFyYXRlIHF1ZXJ5XG4gKiBmb3IgZWFjaCBkb2N1bWVudCByZXR1cm5lZCBmcm9tIGBmaW5kKClgIHRvIGVuc3VyZSBlYWNoIGRvY3VtZW50XG4gKiBnZXRzIHVwIHRvIGBwZXJEb2N1bWVudExpbWl0YCBwb3B1bGF0ZWQgZG9jcyBpZiBwb3NzaWJsZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IHBlckRvY3VtZW50TGltaXRcbiAqIEBtZW1iZXJPZiBWaXJ0dWFsT3B0aW9uc1xuICogQHR5cGUge051bWJlcn1cbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaXJ0dWFsT3B0aW9ucy5wcm90b3R5cGUsICdwZXJEb2N1bWVudExpbWl0Jywgb3B0cyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVmlydHVhbE9wdGlvbnM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/options/virtualOptions.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/plugins/index.js":
/*!*************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/plugins/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.saveSubdocs = __webpack_require__(/*! ./saveSubdocs */ \"../backend/node_modules/mongoose/lib/plugins/saveSubdocs.js\");\nexports.sharding = __webpack_require__(/*! ./sharding */ \"../backend/node_modules/mongoose/lib/plugins/sharding.js\");\nexports.trackTransaction = __webpack_require__(/*! ./trackTransaction */ \"../backend/node_modules/mongoose/lib/plugins/trackTransaction.js\");\nexports.validateBeforeSave = __webpack_require__(/*! ./validateBeforeSave */ \"../backend/node_modules/mongoose/lib/plugins/validateBeforeSave.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3BsdWdpbnMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsNkhBQThDO0FBQzlDLG9IQUF3QztBQUN4Qyw0SUFBd0Q7QUFDeEQsa0pBQTREIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3BsdWdpbnMvaW5kZXguanM/NGYyMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuc2F2ZVN1YmRvY3MgPSByZXF1aXJlKCcuL3NhdmVTdWJkb2NzJyk7XG5leHBvcnRzLnNoYXJkaW5nID0gcmVxdWlyZSgnLi9zaGFyZGluZycpO1xuZXhwb3J0cy50cmFja1RyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi90cmFja1RyYW5zYWN0aW9uJyk7XG5leHBvcnRzLnZhbGlkYXRlQmVmb3JlU2F2ZSA9IHJlcXVpcmUoJy4vdmFsaWRhdGVCZWZvcmVTYXZlJyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/plugins/index.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/plugins/saveSubdocs.js":
/*!*******************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/plugins/saveSubdocs.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst each = __webpack_require__(/*! ../helpers/each */ \"../backend/node_modules/mongoose/lib/helpers/each.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = function saveSubdocs(schema) {\n  const unshift = true;\n  schema.s.hooks.pre('save', false, function saveSubdocsPreSave(next) {\n    if (this.$isSubdocument) {\n      next();\n      return;\n    }\n\n    const _this = this;\n    const subdocs = this.$getAllSubdocs();\n\n    if (!subdocs.length) {\n      next();\n      return;\n    }\n\n    each(subdocs, function(subdoc, cb) {\n      subdoc.$__schema.s.hooks.execPre('save', subdoc, function(err) {\n        cb(err);\n      });\n    }, function(error) {\n      if (error) {\n        return _this.$__schema.s.hooks.execPost('save:error', _this, [_this], { error: error }, function(error) {\n          next(error);\n        });\n      }\n      next();\n    });\n  }, null, unshift);\n\n  schema.s.hooks.post('save', function saveSubdocsPostSave(doc, next) {\n    if (this.$isSubdocument) {\n      next();\n      return;\n    }\n\n    const _this = this;\n    const subdocs = this.$getAllSubdocs();\n\n    if (!subdocs.length) {\n      next();\n      return;\n    }\n\n    each(subdocs, function(subdoc, cb) {\n      subdoc.$__schema.s.hooks.execPost('save', subdoc, [subdoc], function(err) {\n        cb(err);\n      });\n    }, function(error) {\n      if (error) {\n        return _this.$__schema.s.hooks.execPost('save:error', _this, [_this], { error: error }, function(error) {\n          next(error);\n        });\n      }\n      next();\n    });\n  }, null, unshift);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3BsdWdpbnMvc2F2ZVN1YmRvY3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLDZFQUFpQjs7QUFFdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixjQUFjO0FBQzlGO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLGdGQUFnRixjQUFjO0FBQzlGO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3BsdWdpbnMvc2F2ZVN1YmRvY3MuanM/Mjg0YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGVhY2ggPSByZXF1aXJlKCcuLi9oZWxwZXJzL2VhY2gnKTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNhdmVTdWJkb2NzKHNjaGVtYSkge1xuICBjb25zdCB1bnNoaWZ0ID0gdHJ1ZTtcbiAgc2NoZW1hLnMuaG9va3MucHJlKCdzYXZlJywgZmFsc2UsIGZ1bmN0aW9uIHNhdmVTdWJkb2NzUHJlU2F2ZShuZXh0KSB7XG4gICAgaWYgKHRoaXMuJGlzU3ViZG9jdW1lbnQpIHtcbiAgICAgIG5leHQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgY29uc3Qgc3ViZG9jcyA9IHRoaXMuJGdldEFsbFN1YmRvY3MoKTtcblxuICAgIGlmICghc3ViZG9jcy5sZW5ndGgpIHtcbiAgICAgIG5leHQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlYWNoKHN1YmRvY3MsIGZ1bmN0aW9uKHN1YmRvYywgY2IpIHtcbiAgICAgIHN1YmRvYy4kX19zY2hlbWEucy5ob29rcy5leGVjUHJlKCdzYXZlJywgc3ViZG9jLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgY2IoZXJyKTtcbiAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLiRfX3NjaGVtYS5zLmhvb2tzLmV4ZWNQb3N0KCdzYXZlOmVycm9yJywgX3RoaXMsIFtfdGhpc10sIHsgZXJyb3I6IGVycm9yIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgbmV4dChlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbmV4dCgpO1xuICAgIH0pO1xuICB9LCBudWxsLCB1bnNoaWZ0KTtcblxuICBzY2hlbWEucy5ob29rcy5wb3N0KCdzYXZlJywgZnVuY3Rpb24gc2F2ZVN1YmRvY3NQb3N0U2F2ZShkb2MsIG5leHQpIHtcbiAgICBpZiAodGhpcy4kaXNTdWJkb2N1bWVudCkge1xuICAgICAgbmV4dCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICBjb25zdCBzdWJkb2NzID0gdGhpcy4kZ2V0QWxsU3ViZG9jcygpO1xuXG4gICAgaWYgKCFzdWJkb2NzLmxlbmd0aCkge1xuICAgICAgbmV4dCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVhY2goc3ViZG9jcywgZnVuY3Rpb24oc3ViZG9jLCBjYikge1xuICAgICAgc3ViZG9jLiRfX3NjaGVtYS5zLmhvb2tzLmV4ZWNQb3N0KCdzYXZlJywgc3ViZG9jLCBbc3ViZG9jXSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGNiKGVycik7XG4gICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy4kX19zY2hlbWEucy5ob29rcy5leGVjUG9zdCgnc2F2ZTplcnJvcicsIF90aGlzLCBbX3RoaXNdLCB7IGVycm9yOiBlcnJvciB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIG5leHQoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIG5leHQoKTtcbiAgICB9KTtcbiAgfSwgbnVsbCwgdW5zaGlmdCk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/plugins/saveSubdocs.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/plugins/sharding.js":
/*!****************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/plugins/sharding.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst objectIdSymbol = (__webpack_require__(/*! ../helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").objectIdSymbol);\nconst utils = __webpack_require__(/*! ../utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = function shardingPlugin(schema) {\n  schema.post('init', function shardingPluginPostInit() {\n    storeShard.call(this);\n    return this;\n  });\n  schema.pre('save', function shardingPluginPreSave(next) {\n    applyWhere.call(this);\n    next();\n  });\n  schema.pre('remove', function shardingPluginPreRemove(next) {\n    applyWhere.call(this);\n    next();\n  });\n  schema.post('save', function shardingPluginPostSave() {\n    storeShard.call(this);\n  });\n};\n\n/*!\n * ignore\n */\n\nfunction applyWhere() {\n  let paths;\n  let len;\n\n  if (this.$__.shardval) {\n    paths = Object.keys(this.$__.shardval);\n    len = paths.length;\n\n    this.$where = this.$where || {};\n    for (let i = 0; i < len; ++i) {\n      this.$where[paths[i]] = this.$__.shardval[paths[i]];\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nmodule.exports.storeShard = storeShard;\n\n/*!\n * ignore\n */\n\nfunction storeShard() {\n  // backwards compat\n  const key = this.$__schema.options.shardKey || this.$__schema.options.shardkey;\n  if (!utils.isPOJO(key)) {\n    return;\n  }\n\n  const orig = this.$__.shardval = {};\n  const paths = Object.keys(key);\n  const len = paths.length;\n  let val;\n\n  for (let i = 0; i < len; ++i) {\n    val = this.$__getValue(paths[i]);\n    if (val == null) {\n      orig[paths[i]] = val;\n    } else if (utils.isMongooseObject(val)) {\n      orig[paths[i]] = val.toObject({ depopulate: true, _isNested: true });\n    } else if (val instanceof Date || val[objectIdSymbol]) {\n      orig[paths[i]] = val;\n    } else if (typeof val.valueOf === 'function') {\n      orig[paths[i]] = val.valueOf();\n    } else {\n      orig[paths[i]] = val;\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3BsdWdpbnMvc2hhcmRpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsdUJBQXVCLHlIQUE0QztBQUNuRSxjQUFjLG1CQUFPLENBQUMsK0RBQVU7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixzQ0FBc0MsbUNBQW1DO0FBQ3pFLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9wbHVnaW5zL3NoYXJkaW5nLmpzP2Q2ZWIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBvYmplY3RJZFN5bWJvbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvc3ltYm9scycpLm9iamVjdElkU3ltYm9sO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hhcmRpbmdQbHVnaW4oc2NoZW1hKSB7XG4gIHNjaGVtYS5wb3N0KCdpbml0JywgZnVuY3Rpb24gc2hhcmRpbmdQbHVnaW5Qb3N0SW5pdCgpIHtcbiAgICBzdG9yZVNoYXJkLmNhbGwodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuICBzY2hlbWEucHJlKCdzYXZlJywgZnVuY3Rpb24gc2hhcmRpbmdQbHVnaW5QcmVTYXZlKG5leHQpIHtcbiAgICBhcHBseVdoZXJlLmNhbGwodGhpcyk7XG4gICAgbmV4dCgpO1xuICB9KTtcbiAgc2NoZW1hLnByZSgncmVtb3ZlJywgZnVuY3Rpb24gc2hhcmRpbmdQbHVnaW5QcmVSZW1vdmUobmV4dCkge1xuICAgIGFwcGx5V2hlcmUuY2FsbCh0aGlzKTtcbiAgICBuZXh0KCk7XG4gIH0pO1xuICBzY2hlbWEucG9zdCgnc2F2ZScsIGZ1bmN0aW9uIHNoYXJkaW5nUGx1Z2luUG9zdFNhdmUoKSB7XG4gICAgc3RvcmVTaGFyZC5jYWxsKHRoaXMpO1xuICB9KTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gYXBwbHlXaGVyZSgpIHtcbiAgbGV0IHBhdGhzO1xuICBsZXQgbGVuO1xuXG4gIGlmICh0aGlzLiRfXy5zaGFyZHZhbCkge1xuICAgIHBhdGhzID0gT2JqZWN0LmtleXModGhpcy4kX18uc2hhcmR2YWwpO1xuICAgIGxlbiA9IHBhdGhzLmxlbmd0aDtcblxuICAgIHRoaXMuJHdoZXJlID0gdGhpcy4kd2hlcmUgfHwge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGhpcy4kd2hlcmVbcGF0aHNbaV1dID0gdGhpcy4kX18uc2hhcmR2YWxbcGF0aHNbaV1dO1xuICAgIH1cbiAgfVxufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzLnN0b3JlU2hhcmQgPSBzdG9yZVNoYXJkO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIHN0b3JlU2hhcmQoKSB7XG4gIC8vIGJhY2t3YXJkcyBjb21wYXRcbiAgY29uc3Qga2V5ID0gdGhpcy4kX19zY2hlbWEub3B0aW9ucy5zaGFyZEtleSB8fCB0aGlzLiRfX3NjaGVtYS5vcHRpb25zLnNoYXJka2V5O1xuICBpZiAoIXV0aWxzLmlzUE9KTyhrZXkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgb3JpZyA9IHRoaXMuJF9fLnNoYXJkdmFsID0ge307XG4gIGNvbnN0IHBhdGhzID0gT2JqZWN0LmtleXMoa2V5KTtcbiAgY29uc3QgbGVuID0gcGF0aHMubGVuZ3RoO1xuICBsZXQgdmFsO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YWwgPSB0aGlzLiRfX2dldFZhbHVlKHBhdGhzW2ldKTtcbiAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgIG9yaWdbcGF0aHNbaV1dID0gdmFsO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNNb25nb29zZU9iamVjdCh2YWwpKSB7XG4gICAgICBvcmlnW3BhdGhzW2ldXSA9IHZhbC50b09iamVjdCh7IGRlcG9wdWxhdGU6IHRydWUsIF9pc05lc3RlZDogdHJ1ZSB9KTtcbiAgICB9IGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIERhdGUgfHwgdmFsW29iamVjdElkU3ltYm9sXSkge1xuICAgICAgb3JpZ1twYXRoc1tpXV0gPSB2YWw7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsLnZhbHVlT2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9yaWdbcGF0aHNbaV1dID0gdmFsLnZhbHVlT2YoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3JpZ1twYXRoc1tpXV0gPSB2YWw7XG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/plugins/sharding.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/plugins/trackTransaction.js":
/*!************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/plugins/trackTransaction.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst arrayAtomicsSymbol = (__webpack_require__(/*! ../helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsSymbol);\nconst sessionNewDocuments = (__webpack_require__(/*! ../helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").sessionNewDocuments);\nconst utils = __webpack_require__(/*! ../utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\n\nmodule.exports = function trackTransaction(schema) {\n  schema.pre('save', function trackTransactionPreSave() {\n    const session = this.$session();\n    if (session == null) {\n      return;\n    }\n    if (session.transaction == null || session[sessionNewDocuments] == null) {\n      return;\n    }\n\n    if (!session[sessionNewDocuments].has(this)) {\n      const initialState = {};\n      if (this.isNew) {\n        initialState.isNew = true;\n      }\n      if (this.$__schema.options.versionKey) {\n        initialState.versionKey = this.get(this.$__schema.options.versionKey);\n      }\n\n      initialState.modifiedPaths = new Set(Object.keys(this.$__.activePaths.getStatePaths('modify')));\n      initialState.atomics = _getAtomics(this);\n\n      session[sessionNewDocuments].set(this, initialState);\n    } else {\n      const state = session[sessionNewDocuments].get(this);\n\n      for (const path of Object.keys(this.$__.activePaths.getStatePaths('modify'))) {\n        state.modifiedPaths.add(path);\n      }\n      state.atomics = _getAtomics(this, state.atomics);\n    }\n  });\n};\n\nfunction _getAtomics(doc, previous) {\n  const pathToAtomics = new Map();\n  previous = previous || new Map();\n\n  const pathsToCheck = Object.keys(doc.$__.activePaths.init).concat(Object.keys(doc.$__.activePaths.modify));\n\n  for (const path of pathsToCheck) {\n    const val = doc.$__getValue(path);\n    if (val != null &&\n        Array.isArray(val) &&\n        utils.isMongooseDocumentArray(val) &&\n        val.length &&\n        val[arrayAtomicsSymbol] != null &&\n        Object.keys(val[arrayAtomicsSymbol]).length !== 0) {\n      const existing = previous.get(path) || {};\n      pathToAtomics.set(path, mergeAtomics(existing, val[arrayAtomicsSymbol]));\n    }\n  }\n\n  const dirty = doc.$__dirty();\n  for (const dirt of dirty) {\n    const path = dirt.path;\n\n    const val = dirt.value;\n    if (val != null && val[arrayAtomicsSymbol] != null && Object.keys(val[arrayAtomicsSymbol]).length !== 0) {\n      const existing = previous.get(path) || {};\n      pathToAtomics.set(path, mergeAtomics(existing, val[arrayAtomicsSymbol]));\n    }\n  }\n\n  return pathToAtomics;\n}\n\nfunction mergeAtomics(destination, source) {\n  destination = destination || {};\n\n  if (source.$pullAll != null) {\n    destination.$pullAll = (destination.$pullAll || []).concat(source.$pullAll);\n  }\n  if (source.$push != null) {\n    destination.$push = destination.$push || {};\n    destination.$push.$each = (destination.$push.$each || []).concat(source.$push.$each);\n  }\n  if (source.$addToSet != null) {\n    destination.$addToSet = (destination.$addToSet || []).concat(source.$addToSet);\n  }\n  if (source.$set != null) {\n    destination.$set = Array.isArray(source.$set) ? [...source.$set] : Object.assign({}, source.$set);\n  }\n\n  return destination;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3BsdWdpbnMvdHJhY2tUcmFuc2FjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiwyQkFBMkIsNkhBQWdEO0FBQzNFLDRCQUE0Qiw4SEFBaUQ7QUFDN0UsY0FBYyxtQkFBTyxDQUFDLCtEQUFVOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGO0FBQ3ZGOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvcGx1Z2lucy90cmFja1RyYW5zYWN0aW9uLmpzPzA2NmQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBhcnJheUF0b21pY3NTeW1ib2wgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3N5bWJvbHMnKS5hcnJheUF0b21pY3NTeW1ib2w7XG5jb25zdCBzZXNzaW9uTmV3RG9jdW1lbnRzID0gcmVxdWlyZSgnLi4vaGVscGVycy9zeW1ib2xzJykuc2Vzc2lvbk5ld0RvY3VtZW50cztcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cmFja1RyYW5zYWN0aW9uKHNjaGVtYSkge1xuICBzY2hlbWEucHJlKCdzYXZlJywgZnVuY3Rpb24gdHJhY2tUcmFuc2FjdGlvblByZVNhdmUoKSB7XG4gICAgY29uc3Qgc2Vzc2lvbiA9IHRoaXMuJHNlc3Npb24oKTtcbiAgICBpZiAoc2Vzc2lvbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzZXNzaW9uLnRyYW5zYWN0aW9uID09IG51bGwgfHwgc2Vzc2lvbltzZXNzaW9uTmV3RG9jdW1lbnRzXSA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFzZXNzaW9uW3Nlc3Npb25OZXdEb2N1bWVudHNdLmhhcyh0aGlzKSkge1xuICAgICAgY29uc3QgaW5pdGlhbFN0YXRlID0ge307XG4gICAgICBpZiAodGhpcy5pc05ldykge1xuICAgICAgICBpbml0aWFsU3RhdGUuaXNOZXcgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuJF9fc2NoZW1hLm9wdGlvbnMudmVyc2lvbktleSkge1xuICAgICAgICBpbml0aWFsU3RhdGUudmVyc2lvbktleSA9IHRoaXMuZ2V0KHRoaXMuJF9fc2NoZW1hLm9wdGlvbnMudmVyc2lvbktleSk7XG4gICAgICB9XG5cbiAgICAgIGluaXRpYWxTdGF0ZS5tb2RpZmllZFBhdGhzID0gbmV3IFNldChPYmplY3Qua2V5cyh0aGlzLiRfXy5hY3RpdmVQYXRocy5nZXRTdGF0ZVBhdGhzKCdtb2RpZnknKSkpO1xuICAgICAgaW5pdGlhbFN0YXRlLmF0b21pY3MgPSBfZ2V0QXRvbWljcyh0aGlzKTtcblxuICAgICAgc2Vzc2lvbltzZXNzaW9uTmV3RG9jdW1lbnRzXS5zZXQodGhpcywgaW5pdGlhbFN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3RhdGUgPSBzZXNzaW9uW3Nlc3Npb25OZXdEb2N1bWVudHNdLmdldCh0aGlzKTtcblxuICAgICAgZm9yIChjb25zdCBwYXRoIG9mIE9iamVjdC5rZXlzKHRoaXMuJF9fLmFjdGl2ZVBhdGhzLmdldFN0YXRlUGF0aHMoJ21vZGlmeScpKSkge1xuICAgICAgICBzdGF0ZS5tb2RpZmllZFBhdGhzLmFkZChwYXRoKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmF0b21pY3MgPSBfZ2V0QXRvbWljcyh0aGlzLCBzdGF0ZS5hdG9taWNzKTtcbiAgICB9XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gX2dldEF0b21pY3MoZG9jLCBwcmV2aW91cykge1xuICBjb25zdCBwYXRoVG9BdG9taWNzID0gbmV3IE1hcCgpO1xuICBwcmV2aW91cyA9IHByZXZpb3VzIHx8IG5ldyBNYXAoKTtcblxuICBjb25zdCBwYXRoc1RvQ2hlY2sgPSBPYmplY3Qua2V5cyhkb2MuJF9fLmFjdGl2ZVBhdGhzLmluaXQpLmNvbmNhdChPYmplY3Qua2V5cyhkb2MuJF9fLmFjdGl2ZVBhdGhzLm1vZGlmeSkpO1xuXG4gIGZvciAoY29uc3QgcGF0aCBvZiBwYXRoc1RvQ2hlY2spIHtcbiAgICBjb25zdCB2YWwgPSBkb2MuJF9fZ2V0VmFsdWUocGF0aCk7XG4gICAgaWYgKHZhbCAhPSBudWxsICYmXG4gICAgICAgIEFycmF5LmlzQXJyYXkodmFsKSAmJlxuICAgICAgICB1dGlscy5pc01vbmdvb3NlRG9jdW1lbnRBcnJheSh2YWwpICYmXG4gICAgICAgIHZhbC5sZW5ndGggJiZcbiAgICAgICAgdmFsW2FycmF5QXRvbWljc1N5bWJvbF0gIT0gbnVsbCAmJlxuICAgICAgICBPYmplY3Qua2V5cyh2YWxbYXJyYXlBdG9taWNzU3ltYm9sXSkubGVuZ3RoICE9PSAwKSB7XG4gICAgICBjb25zdCBleGlzdGluZyA9IHByZXZpb3VzLmdldChwYXRoKSB8fCB7fTtcbiAgICAgIHBhdGhUb0F0b21pY3Muc2V0KHBhdGgsIG1lcmdlQXRvbWljcyhleGlzdGluZywgdmFsW2FycmF5QXRvbWljc1N5bWJvbF0pKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBkaXJ0eSA9IGRvYy4kX19kaXJ0eSgpO1xuICBmb3IgKGNvbnN0IGRpcnQgb2YgZGlydHkpIHtcbiAgICBjb25zdCBwYXRoID0gZGlydC5wYXRoO1xuXG4gICAgY29uc3QgdmFsID0gZGlydC52YWx1ZTtcbiAgICBpZiAodmFsICE9IG51bGwgJiYgdmFsW2FycmF5QXRvbWljc1N5bWJvbF0gIT0gbnVsbCAmJiBPYmplY3Qua2V5cyh2YWxbYXJyYXlBdG9taWNzU3ltYm9sXSkubGVuZ3RoICE9PSAwKSB7XG4gICAgICBjb25zdCBleGlzdGluZyA9IHByZXZpb3VzLmdldChwYXRoKSB8fCB7fTtcbiAgICAgIHBhdGhUb0F0b21pY3Muc2V0KHBhdGgsIG1lcmdlQXRvbWljcyhleGlzdGluZywgdmFsW2FycmF5QXRvbWljc1N5bWJvbF0pKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGF0aFRvQXRvbWljcztcbn1cblxuZnVuY3Rpb24gbWVyZ2VBdG9taWNzKGRlc3RpbmF0aW9uLCBzb3VyY2UpIHtcbiAgZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbiB8fCB7fTtcblxuICBpZiAoc291cmNlLiRwdWxsQWxsICE9IG51bGwpIHtcbiAgICBkZXN0aW5hdGlvbi4kcHVsbEFsbCA9IChkZXN0aW5hdGlvbi4kcHVsbEFsbCB8fCBbXSkuY29uY2F0KHNvdXJjZS4kcHVsbEFsbCk7XG4gIH1cbiAgaWYgKHNvdXJjZS4kcHVzaCAhPSBudWxsKSB7XG4gICAgZGVzdGluYXRpb24uJHB1c2ggPSBkZXN0aW5hdGlvbi4kcHVzaCB8fCB7fTtcbiAgICBkZXN0aW5hdGlvbi4kcHVzaC4kZWFjaCA9IChkZXN0aW5hdGlvbi4kcHVzaC4kZWFjaCB8fCBbXSkuY29uY2F0KHNvdXJjZS4kcHVzaC4kZWFjaCk7XG4gIH1cbiAgaWYgKHNvdXJjZS4kYWRkVG9TZXQgIT0gbnVsbCkge1xuICAgIGRlc3RpbmF0aW9uLiRhZGRUb1NldCA9IChkZXN0aW5hdGlvbi4kYWRkVG9TZXQgfHwgW10pLmNvbmNhdChzb3VyY2UuJGFkZFRvU2V0KTtcbiAgfVxuICBpZiAoc291cmNlLiRzZXQgIT0gbnVsbCkge1xuICAgIGRlc3RpbmF0aW9uLiRzZXQgPSBBcnJheS5pc0FycmF5KHNvdXJjZS4kc2V0KSA/IFsuLi5zb3VyY2UuJHNldF0gOiBPYmplY3QuYXNzaWduKHt9LCBzb3VyY2UuJHNldCk7XG4gIH1cblxuICByZXR1cm4gZGVzdGluYXRpb247XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/plugins/trackTransaction.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/plugins/validateBeforeSave.js":
/*!**************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/plugins/validateBeforeSave.js ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = function validateBeforeSave(schema) {\n  const unshift = true;\n  schema.pre('save', false, function validateBeforeSave(next, options) {\n    const _this = this;\n    // Nested docs have their own presave\n    if (this.$isSubdocument) {\n      return next();\n    }\n\n    const hasValidateBeforeSaveOption = options &&\n        (typeof options === 'object') &&\n        ('validateBeforeSave' in options);\n\n    let shouldValidate;\n    if (hasValidateBeforeSaveOption) {\n      shouldValidate = !!options.validateBeforeSave;\n    } else {\n      shouldValidate = this.$__schema.options.validateBeforeSave;\n    }\n\n    // Validate\n    if (shouldValidate) {\n      const hasValidateModifiedOnlyOption = options &&\n          (typeof options === 'object') &&\n          ('validateModifiedOnly' in options);\n      const validateOptions = hasValidateModifiedOnlyOption ?\n        { validateModifiedOnly: options.validateModifiedOnly } :\n        null;\n      this.$validate(validateOptions).then(\n        () => {\n          this.$op = 'save';\n          next();\n        },\n        error => {\n          _this.$__schema.s.hooks.execPost('save:error', _this, [_this], { error: error }, function(error) {\n            _this.$op = 'save';\n            next(error);\n          });\n        }\n      );\n    } else {\n      next();\n    }\n  }, null, unshift);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3BsdWdpbnMvdmFsaWRhdGVCZWZvcmVTYXZlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFEQUFxRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsMkVBQTJFLGNBQWM7QUFDekY7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvcGx1Z2lucy92YWxpZGF0ZUJlZm9yZVNhdmUuanM/NGQ0OCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB2YWxpZGF0ZUJlZm9yZVNhdmUoc2NoZW1hKSB7XG4gIGNvbnN0IHVuc2hpZnQgPSB0cnVlO1xuICBzY2hlbWEucHJlKCdzYXZlJywgZmFsc2UsIGZ1bmN0aW9uIHZhbGlkYXRlQmVmb3JlU2F2ZShuZXh0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgIC8vIE5lc3RlZCBkb2NzIGhhdmUgdGhlaXIgb3duIHByZXNhdmVcbiAgICBpZiAodGhpcy4kaXNTdWJkb2N1bWVudCkge1xuICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICB9XG5cbiAgICBjb25zdCBoYXNWYWxpZGF0ZUJlZm9yZVNhdmVPcHRpb24gPSBvcHRpb25zICYmXG4gICAgICAgICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpICYmXG4gICAgICAgICgndmFsaWRhdGVCZWZvcmVTYXZlJyBpbiBvcHRpb25zKTtcblxuICAgIGxldCBzaG91bGRWYWxpZGF0ZTtcbiAgICBpZiAoaGFzVmFsaWRhdGVCZWZvcmVTYXZlT3B0aW9uKSB7XG4gICAgICBzaG91bGRWYWxpZGF0ZSA9ICEhb3B0aW9ucy52YWxpZGF0ZUJlZm9yZVNhdmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3VsZFZhbGlkYXRlID0gdGhpcy4kX19zY2hlbWEub3B0aW9ucy52YWxpZGF0ZUJlZm9yZVNhdmU7XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGVcbiAgICBpZiAoc2hvdWxkVmFsaWRhdGUpIHtcbiAgICAgIGNvbnN0IGhhc1ZhbGlkYXRlTW9kaWZpZWRPbmx5T3B0aW9uID0gb3B0aW9ucyAmJlxuICAgICAgICAgICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpICYmXG4gICAgICAgICAgKCd2YWxpZGF0ZU1vZGlmaWVkT25seScgaW4gb3B0aW9ucyk7XG4gICAgICBjb25zdCB2YWxpZGF0ZU9wdGlvbnMgPSBoYXNWYWxpZGF0ZU1vZGlmaWVkT25seU9wdGlvbiA/XG4gICAgICAgIHsgdmFsaWRhdGVNb2RpZmllZE9ubHk6IG9wdGlvbnMudmFsaWRhdGVNb2RpZmllZE9ubHkgfSA6XG4gICAgICAgIG51bGw7XG4gICAgICB0aGlzLiR2YWxpZGF0ZSh2YWxpZGF0ZU9wdGlvbnMpLnRoZW4oXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICB0aGlzLiRvcCA9ICdzYXZlJztcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yID0+IHtcbiAgICAgICAgICBfdGhpcy4kX19zY2hlbWEucy5ob29rcy5leGVjUG9zdCgnc2F2ZTplcnJvcicsIF90aGlzLCBbX3RoaXNdLCB7IGVycm9yOiBlcnJvciB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgICAgX3RoaXMuJG9wID0gJ3NhdmUnO1xuICAgICAgICAgICAgbmV4dChlcnJvcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHQoKTtcbiAgICB9XG4gIH0sIG51bGwsIHVuc2hpZnQpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/plugins/validateBeforeSave.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/query.js":
/*!*****************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/query.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = __webpack_require__(/*! ./error/cast */ \"../backend/node_modules/mongoose/lib/error/cast.js\");\nconst DocumentNotFoundError = __webpack_require__(/*! ./error/notFound */ \"../backend/node_modules/mongoose/lib/error/notFound.js\");\nconst Kareem = __webpack_require__(/*! kareem */ \"../backend/node_modules/kareem/index.js\");\nconst MongooseError = __webpack_require__(/*! ./error/mongooseError */ \"../backend/node_modules/mongoose/lib/error/mongooseError.js\");\nconst ObjectParameterError = __webpack_require__(/*! ./error/objectParameter */ \"../backend/node_modules/mongoose/lib/error/objectParameter.js\");\nconst QueryCursor = __webpack_require__(/*! ./cursor/queryCursor */ \"../backend/node_modules/mongoose/lib/cursor/queryCursor.js\");\nconst ValidationError = __webpack_require__(/*! ./error/validation */ \"../backend/node_modules/mongoose/lib/error/validation.js\");\nconst { applyGlobalMaxTimeMS, applyGlobalDiskUse } = __webpack_require__(/*! ./helpers/query/applyGlobalOption */ \"../backend/node_modules/mongoose/lib/helpers/query/applyGlobalOption.js\");\nconst handleReadPreferenceAliases = __webpack_require__(/*! ./helpers/query/handleReadPreferenceAliases */ \"../backend/node_modules/mongoose/lib/helpers/query/handleReadPreferenceAliases.js\");\nconst applyWriteConcern = __webpack_require__(/*! ./helpers/schema/applyWriteConcern */ \"../backend/node_modules/mongoose/lib/helpers/schema/applyWriteConcern.js\");\nconst cast = __webpack_require__(/*! ./cast */ \"../backend/node_modules/mongoose/lib/cast.js\");\nconst castArrayFilters = __webpack_require__(/*! ./helpers/update/castArrayFilters */ \"../backend/node_modules/mongoose/lib/helpers/update/castArrayFilters.js\");\nconst castNumber = __webpack_require__(/*! ./cast/number */ \"../backend/node_modules/mongoose/lib/cast/number.js\");\nconst castUpdate = __webpack_require__(/*! ./helpers/query/castUpdate */ \"../backend/node_modules/mongoose/lib/helpers/query/castUpdate.js\");\nconst clone = __webpack_require__(/*! ./helpers/clone */ \"../backend/node_modules/mongoose/lib/helpers/clone.js\");\nconst getDiscriminatorByValue = __webpack_require__(/*! ./helpers/discriminator/getDiscriminatorByValue */ \"../backend/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\nconst helpers = __webpack_require__(/*! ./queryHelpers */ \"../backend/node_modules/mongoose/lib/queryHelpers.js\");\nconst immediate = __webpack_require__(/*! ./helpers/immediate */ \"../backend/node_modules/mongoose/lib/helpers/immediate.js\");\nconst internalToObjectOptions = (__webpack_require__(/*! ./options */ \"../backend/node_modules/mongoose/lib/options.js\").internalToObjectOptions);\nconst isExclusive = __webpack_require__(/*! ./helpers/projection/isExclusive */ \"../backend/node_modules/mongoose/lib/helpers/projection/isExclusive.js\");\nconst isInclusive = __webpack_require__(/*! ./helpers/projection/isInclusive */ \"../backend/node_modules/mongoose/lib/helpers/projection/isInclusive.js\");\nconst isPathSelectedInclusive = __webpack_require__(/*! ./helpers/projection/isPathSelectedInclusive */ \"../backend/node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js\");\nconst isSubpath = __webpack_require__(/*! ./helpers/projection/isSubpath */ \"../backend/node_modules/mongoose/lib/helpers/projection/isSubpath.js\");\nconst mpath = __webpack_require__(/*! mpath */ \"../backend/node_modules/mpath/index.js\");\nconst mquery = __webpack_require__(/*! mquery */ \"../backend/node_modules/mquery/lib/mquery.js\");\nconst parseProjection = __webpack_require__(/*! ./helpers/projection/parseProjection */ \"../backend/node_modules/mongoose/lib/helpers/projection/parseProjection.js\");\nconst removeUnusedArrayFilters = __webpack_require__(/*! ./helpers/update/removeUnusedArrayFilters */ \"../backend/node_modules/mongoose/lib/helpers/update/removeUnusedArrayFilters.js\");\nconst sanitizeFilter = __webpack_require__(/*! ./helpers/query/sanitizeFilter */ \"../backend/node_modules/mongoose/lib/helpers/query/sanitizeFilter.js\");\nconst sanitizeProjection = __webpack_require__(/*! ./helpers/query/sanitizeProjection */ \"../backend/node_modules/mongoose/lib/helpers/query/sanitizeProjection.js\");\nconst selectPopulatedFields = __webpack_require__(/*! ./helpers/query/selectPopulatedFields */ \"../backend/node_modules/mongoose/lib/helpers/query/selectPopulatedFields.js\");\nconst setDefaultsOnInsert = __webpack_require__(/*! ./helpers/setDefaultsOnInsert */ \"../backend/node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js\");\nconst specialProperties = __webpack_require__(/*! ./helpers/specialProperties */ \"../backend/node_modules/mongoose/lib/helpers/specialProperties.js\");\nconst updateValidators = __webpack_require__(/*! ./helpers/updateValidators */ \"../backend/node_modules/mongoose/lib/helpers/updateValidators.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst utils = __webpack_require__(/*! ./utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\nconst queryMiddlewareFunctions = (__webpack_require__(/*! ./constants */ \"../backend/node_modules/mongoose/lib/constants.js\").queryMiddlewareFunctions);\n\nconst queryOptionMethods = new Set([\n  'allowDiskUse',\n  'batchSize',\n  'collation',\n  'comment',\n  'explain',\n  'hint',\n  'j',\n  'lean',\n  'limit',\n  'maxTimeMS',\n  'populate',\n  'projection',\n  'read',\n  'select',\n  'skip',\n  'slice',\n  'sort',\n  'tailable',\n  'w',\n  'writeConcern',\n  'wtimeout'\n]);\n\n/**\n * Query constructor used for building queries. You do not need\n * to instantiate a `Query` directly. Instead use Model functions like\n * [`Model.find()`](https://mongoosejs.com/docs/api/model.html#Model.find()).\n *\n * #### Example:\n *\n *     const query = MyModel.find(); // `query` is an instance of `Query`\n *     query.setOptions({ lean : true });\n *     query.collection(MyModel.collection);\n *     query.where('age').gte(21).exec(callback);\n *\n *     // You can instantiate a query directly. There is no need to do\n *     // this unless you're an advanced user with a very good reason to.\n *     const query = new mongoose.Query();\n *\n * @param {Object} [options]\n * @param {Object} [model]\n * @param {Object} [conditions]\n * @param {Object} [collection] Mongoose collection\n * @api public\n */\n\nfunction Query(conditions, options, model, collection) {\n  // this stuff is for dealing with custom queries created by #toConstructor\n  if (!this._mongooseOptions) {\n    this._mongooseOptions = {};\n  }\n  options = options || {};\n\n  this._transforms = [];\n  this._hooks = new Kareem();\n  this._executionStack = null;\n\n  // this is the case where we have a CustomQuery, we need to check if we got\n  // options passed in, and if we did, merge them in\n  const keys = Object.keys(options);\n  for (const key of keys) {\n    this._mongooseOptions[key] = options[key];\n  }\n\n  if (collection) {\n    this.mongooseCollection = collection;\n  }\n\n  if (model) {\n    this.model = model;\n    this.schema = model.schema;\n  }\n\n  // this is needed because map reduce returns a model that can be queried, but\n  // all of the queries on said model should be lean\n  if (this.model && this.model._mapreduce) {\n    this.lean();\n  }\n\n  // inherit mquery\n  mquery.call(this, null, options);\n  if (collection) {\n    this.collection(collection);\n  }\n\n  if (conditions) {\n    this.find(conditions);\n  }\n\n  this.options = this.options || {};\n\n  // For gh-6880. mquery still needs to support `fields` by default for old\n  // versions of MongoDB\n  this.$useProjection = true;\n\n  const collation = this &&\n    this.schema &&\n    this.schema.options &&\n    this.schema.options.collation || null;\n  if (collation != null) {\n    this.options.collation = collation;\n  }\n}\n\n/*!\n * inherit mquery\n */\n\nQuery.prototype = new mquery();\nQuery.prototype.constructor = Query;\nQuery.base = mquery.prototype;\n\n/*!\n * Overwrite mquery's `_distinct`, because Mongoose uses that name\n * to store the field to apply distinct on.\n */\n\nObject.defineProperty(Query.prototype, '_distinct', {\n  configurable: true,\n  writable: true,\n  enumerable: true,\n  value: undefined\n});\n\n/**\n * Flag to opt out of using `$geoWithin`.\n *\n * ```javascript\n * mongoose.Query.use$geoWithin = false;\n * ```\n *\n * MongoDB 2.4 deprecated the use of `$within`, replacing it with `$geoWithin`. Mongoose uses `$geoWithin` by default (which is 100% backward compatible with `$within`). If you are running an older version of MongoDB, set this flag to `false` so your `within()` queries continue to work.\n *\n * @see geoWithin https://www.mongodb.com/docs/manual/reference/operator/geoWithin/\n * @default true\n * @property use$geoWithin\n * @memberOf Query\n * @static\n * @api public\n */\n\nQuery.use$geoWithin = mquery.use$geoWithin;\n\n/**\n * Converts this query to a customized, reusable query constructor with all arguments and options retained.\n *\n * #### Example:\n *\n *     // Create a query for adventure movies and read from the primary\n *     // node in the replica-set unless it is down, in which case we'll\n *     // read from a secondary node.\n *     const query = Movie.find({ tags: 'adventure' }).read('primaryPreferred');\n *\n *     // create a custom Query constructor based off these settings\n *     const Adventure = query.toConstructor();\n *\n *     // further narrow down our query results while still using the previous settings\n *     await Adventure().where({ name: /^Life/ }).exec();\n *\n *     // since Adventure is a stand-alone constructor we can also add our own\n *     // helper methods and getters without impacting global queries\n *     Adventure.prototype.startsWith = function (prefix) {\n *       this.where({ name: new RegExp('^' + prefix) })\n *       return this;\n *     }\n *     Object.defineProperty(Adventure.prototype, 'highlyRated', {\n *       get: function () {\n *         this.where({ rating: { $gt: 4.5 }});\n *         return this;\n *       }\n *     })\n *     await Adventure().highlyRated.startsWith('Life').exec();\n *\n * @return {Query} subclass-of-Query\n * @api public\n */\n\nQuery.prototype.toConstructor = function toConstructor() {\n  const model = this.model;\n  const coll = this.mongooseCollection;\n\n  const CustomQuery = function(criteria, options) {\n    if (!(this instanceof CustomQuery)) {\n      return new CustomQuery(criteria, options);\n    }\n    this._mongooseOptions = clone(p._mongooseOptions);\n    Query.call(this, criteria, options || null, model, coll);\n  };\n\n  util.inherits(CustomQuery, model.Query);\n\n  // set inherited defaults\n  const p = CustomQuery.prototype;\n\n  p.options = {};\n\n  // Need to handle `sort()` separately because entries-style `sort()` syntax\n  // `sort([['prop1', 1]])` confuses mquery into losing the outer nested array.\n  // See gh-8159\n  const options = Object.assign({}, this.options);\n  if (options.sort != null) {\n    p.sort(options.sort);\n    delete options.sort;\n  }\n  p.setOptions(options);\n\n  p.op = this.op;\n  p._validateOp();\n  p._conditions = clone(this._conditions);\n  p._fields = clone(this._fields);\n  p._update = clone(this._update, {\n    flattenDecimals: false\n  });\n  p._path = this._path;\n  p._distinct = this._distinct;\n  p._collection = this._collection;\n  p._mongooseOptions = this._mongooseOptions;\n\n  return CustomQuery;\n};\n\n/**\n * Make a copy of this query so you can re-execute it.\n *\n * #### Example:\n *\n *     const q = Book.findOne({ title: 'Casino Royale' });\n *     await q.exec();\n *     await q.exec(); // Throws an error because you can't execute a query twice\n *\n *     await q.clone().exec(); // Works\n *\n * @method clone\n * @return {Query} copy\n * @memberOf Query\n * @instance\n * @api public\n */\n\nQuery.prototype.clone = function() {\n  const model = this.model;\n  const collection = this.mongooseCollection;\n\n  const q = new this.model.Query({}, {}, model, collection);\n\n  // Need to handle `sort()` separately because entries-style `sort()` syntax\n  // `sort([['prop1', 1]])` confuses mquery into losing the outer nested array.\n  // See gh-8159\n  const options = Object.assign({}, this.options);\n  if (options.sort != null) {\n    q.sort(options.sort);\n    delete options.sort;\n  }\n  q.setOptions(options);\n\n  q.op = this.op;\n  q._validateOp();\n  q._conditions = clone(this._conditions);\n  q._fields = clone(this._fields);\n  q._update = clone(this._update, {\n    flattenDecimals: false\n  });\n  q._path = this._path;\n  q._distinct = this._distinct;\n  q._collection = this._collection;\n  q._mongooseOptions = this._mongooseOptions;\n\n  return q;\n};\n\n/**\n * Specifies a javascript function or expression to pass to MongoDBs query system.\n *\n * #### Example:\n *\n *     query.$where('this.comments.length === 10 || this.name.length === 5')\n *\n *     // or\n *\n *     query.$where(function () {\n *       return this.comments.length === 10 || this.name.length === 5;\n *     })\n *\n * #### Note:\n *\n * Only use `$where` when you have a condition that cannot be met using other MongoDB operators like `$lt`.\n * **Be sure to read about all of [its caveats](https://www.mongodb.com/docs/manual/reference/operator/where/) before using.**\n *\n * @see $where https://www.mongodb.com/docs/manual/reference/operator/where/\n * @method $where\n * @param {String|Function} js javascript string or function\n * @return {Query} this\n * @memberOf Query\n * @instance\n * @method $where\n * @api public\n */\n\n/**\n * Specifies a `path` for use with chaining.\n *\n * #### Example:\n *\n *     // instead of writing:\n *     User.find({age: {$gte: 21, $lte: 65}});\n *\n *     // we can instead write:\n *     User.where('age').gte(21).lte(65);\n *\n *     // passing query conditions is permitted\n *     User.find().where({ name: 'vonderful' })\n *\n *     // chaining\n *     User\n *     .where('age').gte(21).lte(65)\n *     .where('name', /^vonderful/i)\n *     .where('friends').slice(10)\n *     .exec()\n *\n * @method where\n * @memberOf Query\n * @instance\n * @param {String|Object} [path]\n * @param {any} [val]\n * @return {Query} this\n * @api public\n */\n\n/**\n * Specifies a `$slice` projection for an array.\n *\n * #### Example:\n *\n *     query.slice('comments', 5); // Returns the first 5 comments\n *     query.slice('comments', -5); // Returns the last 5 comments\n *     query.slice('comments', [10, 5]); // Returns the first 5 comments after the 10-th\n *     query.where('comments').slice(5); // Returns the first 5 comments\n *     query.where('comments').slice([-10, 5]); // Returns the first 5 comments after the 10-th to last\n *\n * **Note:** If the absolute value of the number of elements to be sliced is greater than the number of elements in the array, all array elements will be returned.\n *\n *      // Given `arr`: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n *      query.slice('arr', 20); // Returns [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n *      query.slice('arr', -20); // Returns [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n *\n * **Note:** If the number of elements to skip is positive and greater than the number of elements in the array, an empty array will be returned.\n *\n *      // Given `arr`: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n *      query.slice('arr', [20, 5]); // Returns []\n *\n * **Note:** If the number of elements to skip is negative and its absolute value is greater than the number of elements in the array, the starting position is the start of the array.\n *\n *      // Given `arr`: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n *      query.slice('arr', [-20, 5]); // Returns [1, 2, 3, 4, 5]\n *\n * @method slice\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number|Array} val number of elements to slice or array with number of elements to skip and number of elements to slice\n * @return {Query} this\n * @see mongodb https://www.mongodb.com/docs/manual/tutorial/query-documents/#projection\n * @see $slice https://www.mongodb.com/docs/manual/reference/projection/slice/#prj._S_slice\n * @api public\n */\n\nQuery.prototype.slice = function() {\n  if (arguments.length === 0) {\n    return this;\n  }\n\n  this._validate('slice');\n\n  let path;\n  let val;\n\n  if (arguments.length === 1) {\n    const arg = arguments[0];\n    if (typeof arg === 'object' && !Array.isArray(arg)) {\n      const keys = Object.keys(arg);\n      const numKeys = keys.length;\n      for (let i = 0; i < numKeys; ++i) {\n        this.slice(keys[i], arg[keys[i]]);\n      }\n      return this;\n    }\n    this._ensurePath('slice');\n    path = this._path;\n    val = arguments[0];\n  } else if (arguments.length === 2) {\n    if ('number' === typeof arguments[0]) {\n      this._ensurePath('slice');\n      path = this._path;\n      val = [arguments[0], arguments[1]];\n    } else {\n      path = arguments[0];\n      val = arguments[1];\n    }\n  } else if (arguments.length === 3) {\n    path = arguments[0];\n    val = [arguments[1], arguments[2]];\n  }\n\n  const p = {};\n  p[path] = { $slice: val };\n  this.select(p);\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nconst validOpsSet = new Set(queryMiddlewareFunctions);\n\nQuery.prototype._validateOp = function() {\n  if (this.op != null && !validOpsSet.has(this.op)) {\n    this.error(new Error('Query has invalid `op`: \"' + this.op + '\"'));\n  }\n};\n\n/**\n * Specifies the complementary comparison value for paths specified with `where()`\n *\n * #### Example:\n *\n *     User.where('age').equals(49);\n *\n *     // is the same as\n *\n *     User.where('age', 49);\n *\n * @method equals\n * @memberOf Query\n * @instance\n * @param {Object} val\n * @return {Query} this\n * @api public\n */\n\n/**\n * Specifies arguments for an `$or` condition.\n *\n * #### Example:\n *\n *     query.or([{ color: 'red' }, { status: 'emergency' }]);\n *\n * @see $or https://www.mongodb.com/docs/manual/reference/operator/or/\n * @method or\n * @memberOf Query\n * @instance\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */\n\n/**\n * Specifies arguments for a `$nor` condition.\n *\n * #### Example:\n *\n *     query.nor([{ color: 'green' }, { status: 'ok' }]);\n *\n * @see $nor https://www.mongodb.com/docs/manual/reference/operator/nor/\n * @method nor\n * @memberOf Query\n * @instance\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */\n\n/**\n * Specifies arguments for a `$and` condition.\n *\n * #### Example:\n *\n *     query.and([{ color: 'green' }, { status: 'ok' }])\n *\n * @method and\n * @memberOf Query\n * @instance\n * @see $and https://www.mongodb.com/docs/manual/reference/operator/and/\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */\n\n/**\n * Specifies a `$gt` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * #### Example:\n *\n *     Thing.find().where('age').gt(21);\n *\n *     // or\n *     Thing.find().gt('age', 21);\n *\n * @method gt\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number} val\n * @see $gt https://www.mongodb.com/docs/manual/reference/operator/gt/\n * @api public\n */\n\n/**\n * Specifies a `$gte` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method gte\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number} val\n * @see $gte https://www.mongodb.com/docs/manual/reference/operator/gte/\n * @api public\n */\n\n/**\n * Specifies a `$lt` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method lt\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number} val\n * @see $lt https://www.mongodb.com/docs/manual/reference/operator/lt/\n * @api public\n */\n\n/**\n * Specifies a `$lte` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method lte\n * @see $lte https://www.mongodb.com/docs/manual/reference/operator/lte/\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a `$ne` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @see $ne https://www.mongodb.com/docs/manual/reference/operator/ne/\n * @method ne\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {any} val\n * @api public\n */\n\n/**\n * Specifies an `$in` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @see $in https://www.mongodb.com/docs/manual/reference/operator/in/\n * @method in\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Array} val\n * @api public\n */\n\n/**\n * Specifies an `$nin` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @see $nin https://www.mongodb.com/docs/manual/reference/operator/nin/\n * @method nin\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Array} val\n * @api public\n */\n\n/**\n * Specifies an `$all` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * #### Example:\n *\n *     MyModel.find().where('pets').all(['dog', 'cat', 'ferret']);\n *     // Equivalent:\n *     MyModel.find().all('pets', ['dog', 'cat', 'ferret']);\n *\n * @see $all https://www.mongodb.com/docs/manual/reference/operator/all/\n * @method all\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Array} val\n * @api public\n */\n\n/**\n * Specifies a `$size` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * #### Example:\n *\n *     const docs = await MyModel.where('tags').size(0).exec();\n *     assert(Array.isArray(docs));\n *     console.log('documents with 0 tags', docs);\n *\n * @see $size https://www.mongodb.com/docs/manual/reference/operator/size/\n * @method size\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a `$regex` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @see $regex https://www.mongodb.com/docs/manual/reference/operator/regex/\n * @method regex\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {String|RegExp} val\n * @api public\n */\n\n/**\n * Specifies a `maxDistance` query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @see $maxDistance https://www.mongodb.com/docs/manual/reference/operator/maxDistance/\n * @method maxDistance\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a `$mod` condition, filters documents for documents whose\n * `path` property is a number that is equal to `remainder` modulo `divisor`.\n *\n * #### Example:\n *\n *     // All find products whose inventory is odd\n *     Product.find().mod('inventory', [2, 1]);\n *     Product.find().where('inventory').mod([2, 1]);\n *     // This syntax is a little strange, but supported.\n *     Product.find().where('inventory').mod(2, 1);\n *\n * @method mod\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Array} val must be of length 2, first element is `divisor`, 2nd element is `remainder`.\n * @return {Query} this\n * @see $mod https://www.mongodb.com/docs/manual/reference/operator/mod/\n * @api public\n */\n\nQuery.prototype.mod = function() {\n  let val;\n  let path;\n\n  if (arguments.length === 1) {\n    this._ensurePath('mod');\n    val = arguments[0];\n    path = this._path;\n  } else if (arguments.length === 2 && !Array.isArray(arguments[1])) {\n    this._ensurePath('mod');\n    val = [arguments[0], arguments[1]];\n    path = this._path;\n  } else if (arguments.length === 3) {\n    val = [arguments[1], arguments[2]];\n    path = arguments[0];\n  } else {\n    val = arguments[1];\n    path = arguments[0];\n  }\n\n  const conds = this._conditions[path] || (this._conditions[path] = {});\n  conds.$mod = val;\n  return this;\n};\n\n/**\n * Specifies an `$exists` condition\n *\n * #### Example:\n *\n *     // { name: { $exists: true }}\n *     Thing.where('name').exists()\n *     Thing.where('name').exists(true)\n *     Thing.find().exists('name')\n *\n *     // { name: { $exists: false }}\n *     Thing.where('name').exists(false);\n *     Thing.find().exists('name', false);\n *\n * @method exists\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Boolean} val\n * @return {Query} this\n * @see $exists https://www.mongodb.com/docs/manual/reference/operator/exists/\n * @api public\n */\n\n/**\n * Specifies an `$elemMatch` condition\n *\n * #### Example:\n *\n *     query.elemMatch('comment', { author: 'autobot', votes: {$gte: 5}})\n *\n *     query.where('comment').elemMatch({ author: 'autobot', votes: {$gte: 5}})\n *\n *     query.elemMatch('comment', function (elem) {\n *       elem.where('author').equals('autobot');\n *       elem.where('votes').gte(5);\n *     })\n *\n *     query.where('comment').elemMatch(function (elem) {\n *       elem.where({ author: 'autobot' });\n *       elem.where('votes').gte(5);\n *     })\n *\n * @method elemMatch\n * @memberOf Query\n * @instance\n * @param {String|Object|Function} path\n * @param {Object|Function} filter\n * @return {Query} this\n * @see $elemMatch https://www.mongodb.com/docs/manual/reference/operator/elemMatch/\n * @api public\n */\n\n/**\n * Defines a `$within` or `$geoWithin` argument for geo-spatial queries.\n *\n * #### Example:\n *\n *     query.where(path).within().box()\n *     query.where(path).within().circle()\n *     query.where(path).within().geometry()\n *\n *     query.where('loc').within({ center: [50,50], radius: 10, unique: true, spherical: true });\n *     query.where('loc').within({ box: [[40.73, -73.9], [40.7, -73.988]] });\n *     query.where('loc').within({ polygon: [[],[],[],[]] });\n *\n *     query.where('loc').within([], [], []) // polygon\n *     query.where('loc').within([], []) // box\n *     query.where('loc').within({ type: 'LineString', coordinates: [...] }); // geometry\n *\n * **MUST** be used after `where()`.\n *\n * #### Note:\n *\n * As of Mongoose 3.7, `$geoWithin` is always used for queries. To change this behavior, see [Query.use$geoWithin](https://mongoosejs.com/docs/api/query.html#Query.prototype.use$geoWithin).\n *\n * #### Note:\n *\n * In Mongoose 3.7, `within` changed from a getter to a function. If you need the old syntax, use [this](https://github.com/ebensing/mongoose-within).\n *\n * @method within\n * @see $polygon https://www.mongodb.com/docs/manual/reference/operator/polygon/\n * @see $box https://www.mongodb.com/docs/manual/reference/operator/box/\n * @see $geometry https://www.mongodb.com/docs/manual/reference/operator/geometry/\n * @see $center https://www.mongodb.com/docs/manual/reference/operator/center/\n * @see $centerSphere https://www.mongodb.com/docs/manual/reference/operator/centerSphere/\n * @memberOf Query\n * @instance\n * @return {Query} this\n * @api public\n */\n\n/**\n * Specifies the maximum number of documents the query will return.\n *\n * #### Example:\n *\n *     query.limit(20);\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method limit\n * @memberOf Query\n * @instance\n * @param {Number} val\n * @api public\n */\n\nQuery.prototype.limit = function limit(v) {\n  this._validate('limit');\n\n  if (typeof v === 'string') {\n    try {\n      v = castNumber(v);\n    } catch (err) {\n      throw new CastError('Number', v, 'limit');\n    }\n  }\n\n  this.options.limit = v;\n  return this;\n};\n\n/**\n * Specifies the number of documents to skip.\n *\n * #### Example:\n *\n *     query.skip(100).limit(20);\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method skip\n * @memberOf Query\n * @instance\n * @param {Number} val\n * @see cursor.skip https://www.mongodb.com/docs/manual/reference/method/cursor.skip/\n * @api public\n */\n\nQuery.prototype.skip = function skip(v) {\n  this._validate('skip');\n\n  if (typeof v === 'string') {\n    try {\n      v = castNumber(v);\n    } catch (err) {\n      throw new CastError('Number', v, 'skip');\n    }\n  }\n\n  this.options.skip = v;\n  return this;\n};\n\n/**\n * Specifies the batchSize option.\n *\n * #### Example:\n *\n *     query.batchSize(100)\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method batchSize\n * @memberOf Query\n * @instance\n * @param {Number} val\n * @see batchSize https://www.mongodb.com/docs/manual/reference/method/cursor.batchSize/\n * @api public\n */\n\n/**\n * Specifies the `comment` option.\n *\n * #### Example:\n *\n *     query.comment('login query')\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method comment\n * @memberOf Query\n * @instance\n * @param {String} val\n * @see comment https://www.mongodb.com/docs/manual/reference/operator/comment/\n * @api public\n */\n\n/**\n * Sets query hints.\n *\n * #### Example:\n *\n *     query.hint({ indexA: 1, indexB: -1 });\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @method hint\n * @memberOf Query\n * @instance\n * @param {Object} val a hint object\n * @return {Query} this\n * @see $hint https://www.mongodb.com/docs/manual/reference/operator/hint/\n * @api public\n */\n\n/**\n * Get/set the current projection (AKA fields). Pass `null` to remove the\n * current projection.\n *\n * Unlike `projection()`, the `select()` function modifies the current\n * projection in place. This function overwrites the existing projection.\n *\n * #### Example:\n *\n *     const q = Model.find();\n *     q.projection(); // null\n *\n *     q.select('a b');\n *     q.projection(); // { a: 1, b: 1 }\n *\n *     q.projection({ c: 1 });\n *     q.projection(); // { c: 1 }\n *\n *     q.projection(null);\n *     q.projection(); // null\n *\n *\n * @method projection\n * @memberOf Query\n * @instance\n * @param {Object|null} arg\n * @return {Object} the current projection\n * @api public\n */\n\nQuery.prototype.projection = function(arg) {\n  if (arguments.length === 0) {\n    return this._fields;\n  }\n\n  this._fields = {};\n  this._userProvidedFields = {};\n  this.select(arg);\n  return this._fields;\n};\n\n/**\n * Specifies which document fields to include or exclude (also known as the query \"projection\")\n *\n * When using string syntax, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included. Lastly, if a path is prefixed with `+`, it forces inclusion of the path, which is useful for paths excluded at the [schema level](https://mongoosejs.com/docs/api/schematype.html#SchemaType.prototype.select()).\n *\n * A projection _must_ be either inclusive or exclusive. In other words, you must\n * either list the fields to include (which excludes all others), or list the fields\n * to exclude (which implies all other fields are included). The [`_id` field is the only exception because MongoDB includes it by default](https://www.mongodb.com/docs/manual/tutorial/project-fields-from-query-results/#suppress-id-field).\n *\n * #### Example:\n *\n *     // include a and b, exclude other fields\n *     query.select('a b');\n *     // Equivalent syntaxes:\n *     query.select(['a', 'b']);\n *     query.select({ a: 1, b: 1 });\n *\n *     // exclude c and d, include other fields\n *     query.select('-c -d');\n *\n *     // Use `+` to override schema-level `select: false` without making the\n *     // projection inclusive.\n *     const schema = new Schema({\n *       foo: { type: String, select: false },\n *       bar: String\n *     });\n *     // ...\n *     query.select('+foo'); // Override foo's `select: false` without excluding `bar`\n *\n *     // or you may use object notation, useful when\n *     // you have keys already prefixed with a \"-\"\n *     query.select({ a: 1, b: 1 });\n *     query.select({ c: 0, d: 0 });\n *\n *     Additional calls to select can override the previous selection:\n *     query.select({ a: 1, b: 1 }).select({ b: 0 }); // selection is now { a: 1 }\n *     query.select({ a: 0, b: 0 }).select({ b: 1 }); // selection is now { a: 0 }\n *\n *\n * @method select\n * @memberOf Query\n * @instance\n * @param {Object|String|String[]} arg\n * @return {Query} this\n * @see SchemaType https://mongoosejs.com/docs/api/schematype.html\n * @api public\n */\n\nQuery.prototype.select = function select() {\n  let arg = arguments[0];\n  if (!arg) return this;\n\n  if (arguments.length !== 1) {\n    throw new Error('Invalid select: select only takes 1 argument');\n  }\n\n  this._validate('select');\n\n  const fields = this._fields || (this._fields = {});\n  const userProvidedFields = this._userProvidedFields || (this._userProvidedFields = {});\n  let sanitizeProjection = undefined;\n  if (this.model != null && utils.hasUserDefinedProperty(this.model.db.options, 'sanitizeProjection')) {\n    sanitizeProjection = this.model.db.options.sanitizeProjection;\n  } else if (this.model != null && utils.hasUserDefinedProperty(this.model.base.options, 'sanitizeProjection')) {\n    sanitizeProjection = this.model.base.options.sanitizeProjection;\n  } else {\n    sanitizeProjection = this._mongooseOptions.sanitizeProjection;\n  }\n\n  function sanitizeValue(value) {\n    return typeof value === 'string' && sanitizeProjection ? value = 1 : value;\n  }\n  arg = parseProjection(arg, true); // we want to keep the minus and pluses, so add boolean arg.\n  if (utils.isObject(arg)) {\n    if (this.selectedInclusively()) {\n      Object.entries(arg).forEach(([key, value]) => {\n        if (value) {\n          // Add the field to the projection\n          if (fields['-' + key] != null) {\n            delete fields['-' + key];\n          }\n          fields[key] = userProvidedFields[key] = sanitizeValue(value);\n        } else {\n          // Remove the field from the projection\n          Object.keys(userProvidedFields).forEach(field => {\n            if (isSubpath(key, field)) {\n              delete fields[field];\n              delete userProvidedFields[field];\n            }\n          });\n        }\n      });\n    } else if (this.selectedExclusively()) {\n      Object.entries(arg).forEach(([key, value]) => {\n        if (!value) {\n          // Add the field to the projection\n          if (fields['+' + key] != null) {\n            delete fields['+' + key];\n          }\n          fields[key] = userProvidedFields[key] = sanitizeValue(value);\n        } else {\n          // Remove the field from the projection\n          Object.keys(userProvidedFields).forEach(field => {\n            if (isSubpath(key, field)) {\n              delete fields[field];\n              delete userProvidedFields[field];\n            }\n          });\n        }\n      });\n    } else {\n      const keys = Object.keys(arg);\n      for (let i = 0; i < keys.length; ++i) {\n        const value = arg[keys[i]];\n        const key = keys[i];\n        fields[key] = sanitizeValue(value);\n        userProvidedFields[key] = sanitizeValue(value);\n      }\n    }\n\n    return this;\n  }\n\n  throw new TypeError('Invalid select() argument. Must be string or object.');\n};\n\n/**\n * Determines the MongoDB nodes from which to read.\n *\n * #### Preferences:\n *\n * ```\n * primary - (default) Read from primary only. Operations will produce an error if primary is unavailable. Cannot be combined with tags.\n * secondary            Read from secondary if available, otherwise error.\n * primaryPreferred     Read from primary if available, otherwise a secondary.\n * secondaryPreferred   Read from a secondary if available, otherwise read from the primary.\n * nearest              All operations read from among the nearest candidates, but unlike other modes, this option will include both the primary and all secondaries in the random selection.\n * ```\n *\n * Aliases\n *\n * ```\n * p   primary\n * pp  primaryPreferred\n * s   secondary\n * sp  secondaryPreferred\n * n   nearest\n * ```\n *\n * #### Example:\n *\n *     new Query().read('primary')\n *     new Query().read('p')  // same as primary\n *\n *     new Query().read('primaryPreferred')\n *     new Query().read('pp') // same as primaryPreferred\n *\n *     new Query().read('secondary')\n *     new Query().read('s')  // same as secondary\n *\n *     new Query().read('secondaryPreferred')\n *     new Query().read('sp') // same as secondaryPreferred\n *\n *     new Query().read('nearest')\n *     new Query().read('n')  // same as nearest\n *\n *     // read from secondaries with matching tags\n *     new Query().read('s', [{ dc:'sf', s: 1 },{ dc:'ma', s: 2 }])\n *\n * Read more about how to use read preferences [here](https://www.mongodb.com/docs/manual/applications/replication/#read-preference).\n *\n * @method read\n * @memberOf Query\n * @instance\n * @param {String} mode one of the listed preference options or aliases\n * @param {Array} [tags] optional tags for this query\n * @see mongodb https://www.mongodb.com/docs/manual/applications/replication/#read-preference\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.read = function read(mode, tags) {\n  if (typeof mode === 'string') {\n    mode = handleReadPreferenceAliases(mode);\n    this.options.readPreference = { mode, tags };\n  } else {\n    this.options.readPreference = mode;\n  }\n  return this;\n};\n\n/**\n * Overwrite default `.toString` to make logging more useful\n *\n * @memberOf Query\n * @instance\n * @method toString\n * @api private\n */\n\nQuery.prototype.toString = function toString() {\n  if (this.op === 'count' ||\n      this.op === 'countDocuments' ||\n      this.op === 'find' ||\n      this.op === 'findOne' ||\n      this.op === 'deleteMany' ||\n      this.op === 'deleteOne' ||\n      this.op === 'findOneAndDelete' ||\n      this.op === 'remove') {\n    return `${this.model.modelName}.${this.op}(${util.inspect(this._conditions)})`;\n  }\n  if (this.op === 'distinct') {\n    return `${this.model.modelName}.distinct('${this._distinct}', ${util.inspect(this._conditions)})`;\n  }\n  if (this.op === 'findOneAndReplace' ||\n      this.op === 'findOneAndUpdate' ||\n      this.op === 'replaceOne' ||\n      this.op === 'update' ||\n      this.op === 'updateMany' ||\n      this.op === 'updateOne') {\n    return `${this.model.modelName}.${this.op}(${util.inspect(this._conditions)}, ${util.inspect(this._update)})`;\n  }\n\n  // 'estimatedDocumentCount' or any others\n  return `${this.model.modelName}.${this.op}()`;\n};\n\n/**\n * Sets the [MongoDB session](https://www.mongodb.com/docs/manual/reference/server-sessions/)\n * associated with this query. Sessions are how you mark a query as part of a\n * [transaction](https://mongoosejs.com/docs/transactions.html).\n *\n * Calling `session(null)` removes the session from this query.\n *\n * #### Example:\n *\n *     const s = await mongoose.startSession();\n *     await mongoose.model('Person').findOne({ name: 'Axl Rose' }).session(s);\n *\n * @method session\n * @memberOf Query\n * @instance\n * @param {ClientSession} [session] from `await conn.startSession()`\n * @see Connection.prototype.startSession() https://mongoosejs.com/docs/api/connection.html#Connection.prototype.startSession()\n * @see mongoose.startSession() https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.startSession()\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.session = function session(v) {\n  if (v == null) {\n    delete this.options.session;\n  }\n  this.options.session = v;\n  return this;\n};\n\n/**\n * Sets the 3 write concern parameters for this query:\n *\n * - `w`: Sets the specified number of `mongod` servers, or tag set of `mongod` servers, that must acknowledge this write before this write is considered successful.\n * - `j`: Boolean, set to `true` to request acknowledgement that this operation has been persisted to MongoDB's on-disk journal.\n * - `wtimeout`: If [`w > 1`](https://mongoosejs.com/docs/api/query.html#Query.prototype.w()), the maximum amount of time to wait for this write to propagate through the replica set before this operation fails. The default is `0`, which means no timeout.\n *\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndReplace()`\n * - `findOneAndUpdate()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to the schema's [`writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n *\n * #### Example:\n *\n *     // The 'majority' option means the `deleteOne()` promise won't resolve\n *     // until the `deleteOne()` has propagated to the majority of the replica set\n *     await mongoose.model('Person').\n *       deleteOne({ name: 'Ned Stark' }).\n *       writeConcern({ w: 'majority' });\n *\n * @method writeConcern\n * @memberOf Query\n * @instance\n * @param {Object} writeConcern the write concern value to set\n * @see WriteConcernSettings https://mongodb.github.io/node-mongodb-native/4.9/interfaces/WriteConcernSettings.html\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.writeConcern = function writeConcern(val) {\n  if (val == null) {\n    delete this.options.writeConcern;\n    return this;\n  }\n  this.options.writeConcern = val;\n  return this;\n};\n\n/**\n * Sets the specified number of `mongod` servers, or tag set of `mongod` servers,\n * that must acknowledge this write before this write is considered successful.\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndReplace()`\n * - `findOneAndUpdate()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to the schema's [`writeConcern.w` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n *\n * #### Example:\n *\n *     // The 'majority' option means the `deleteOne()` promise won't resolve\n *     // until the `deleteOne()` has propagated to the majority of the replica set\n *     await mongoose.model('Person').\n *       deleteOne({ name: 'Ned Stark' }).\n *       w('majority');\n *\n * @method w\n * @memberOf Query\n * @instance\n * @param {String|number} val 0 for fire-and-forget, 1 for acknowledged by one server, 'majority' for majority of the replica set, or [any of the more advanced options](https://www.mongodb.com/docs/manual/reference/write-concern/#w-option).\n * @see mongodb https://www.mongodb.com/docs/manual/reference/write-concern/#w-option\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.w = function w(val) {\n  if (val == null) {\n    delete this.options.w;\n  }\n  if (this.options.writeConcern != null) {\n    this.options.writeConcern.w = val;\n  } else {\n    this.options.w = val;\n  }\n  return this;\n};\n\n/**\n * Requests acknowledgement that this operation has been persisted to MongoDB's\n * on-disk journal.\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndReplace()`\n * - `findOneAndUpdate()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to the schema's [`writeConcern.j` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n *\n * #### Example:\n *\n *     await mongoose.model('Person').deleteOne({ name: 'Ned Stark' }).j(true);\n *\n * @method j\n * @memberOf Query\n * @instance\n * @param {boolean} val\n * @see mongodb https://www.mongodb.com/docs/manual/reference/write-concern/#j-option\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.j = function j(val) {\n  if (val == null) {\n    delete this.options.j;\n  }\n  if (this.options.writeConcern != null) {\n    this.options.writeConcern.j = val;\n  } else {\n    this.options.j = val;\n  }\n  return this;\n};\n\n/**\n * If [`w > 1`](https://mongoosejs.com/docs/api/query.html#Query.prototype.w()), the maximum amount of time to\n * wait for this write to propagate through the replica set before this\n * operation fails. The default is `0`, which means no timeout.\n *\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndReplace()`\n * - `findOneAndUpdate()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to the schema's [`writeConcern.wtimeout` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n *\n * #### Example:\n *\n *     // The `deleteOne()` promise won't resolve until this `deleteOne()` has\n *     // propagated to at least `w = 2` members of the replica set. If it takes\n *     // longer than 1 second, this `deleteOne()` will fail.\n *     await mongoose.model('Person').\n *       deleteOne({ name: 'Ned Stark' }).\n *       w(2).\n *       wtimeout(1000);\n *\n * @method wtimeout\n * @memberOf Query\n * @instance\n * @param {number} ms number of milliseconds to wait\n * @see mongodb https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.wtimeout = function wtimeout(ms) {\n  if (ms == null) {\n    delete this.options.wtimeout;\n  }\n  if (this.options.writeConcern != null) {\n    this.options.writeConcern.wtimeout = ms;\n  } else {\n    this.options.wtimeout = ms;\n  }\n  return this;\n};\n\n/**\n * Sets the readConcern option for the query.\n *\n * #### Example:\n *\n *     new Query().readConcern('local')\n *     new Query().readConcern('l')  // same as local\n *\n *     new Query().readConcern('available')\n *     new Query().readConcern('a')  // same as available\n *\n *     new Query().readConcern('majority')\n *     new Query().readConcern('m')  // same as majority\n *\n *     new Query().readConcern('linearizable')\n *     new Query().readConcern('lz') // same as linearizable\n *\n *     new Query().readConcern('snapshot')\n *     new Query().readConcern('s')  // same as snapshot\n *\n *\n * #### Read Concern Level:\n *\n * ```\n * local         MongoDB 3.2+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.e. may be rolled back).\n * available     MongoDB 3.6+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.e. may be rolled back).\n * majority      MongoDB 3.2+ The query returns the data that has been acknowledged by a majority of the replica set members. The documents returned by the read operation are durable, even in the event of failure.\n * linearizable  MongoDB 3.4+ The query returns data that reflects all successful majority-acknowledged writes that completed prior to the start of the read operation. The query may wait for concurrently executing writes to propagate to a majority of replica set members before returning results.\n * snapshot      MongoDB 4.0+ Only available for operations within multi-document transactions. Upon transaction commit with write concern \"majority\", the transaction operations are guaranteed to have read from a snapshot of majority-committed data.\n * ```\n *\n * Aliases\n *\n * ```\n * l   local\n * a   available\n * m   majority\n * lz  linearizable\n * s   snapshot\n * ```\n *\n * Read more about how to use read concern [here](https://www.mongodb.com/docs/manual/reference/read-concern/).\n *\n * @memberOf Query\n * @method readConcern\n * @param {String} level one of the listed read concern level or their aliases\n * @see mongodb https://www.mongodb.com/docs/manual/reference/read-concern/\n * @return {Query} this\n * @api public\n */\n\n/**\n * Gets query options.\n *\n * #### Example:\n *\n *     const query = new Query();\n *     query.limit(10);\n *     query.setOptions({ maxTimeMS: 1000 });\n *     query.getOptions(); // { limit: 10, maxTimeMS: 1000 }\n *\n * @return {Object} the options\n * @api public\n */\n\nQuery.prototype.getOptions = function() {\n  return this.options;\n};\n\n/**\n * Sets query options. Some options only make sense for certain operations.\n *\n * #### Options:\n *\n * The following options are only for `find()`:\n *\n * - [tailable](https://www.mongodb.com/docs/manual/core/tailable-cursors/)\n * - [limit](https://www.mongodb.com/docs/manual/reference/method/cursor.limit/)\n * - [skip](https://www.mongodb.com/docs/manual/reference/method/cursor.skip/)\n * - [allowDiskUse](https://www.mongodb.com/docs/manual/reference/method/cursor.allowDiskUse/)\n * - [batchSize](https://www.mongodb.com/docs/manual/reference/method/cursor.batchSize/)\n * - [readPreference](https://www.mongodb.com/docs/manual/applications/replication/#read-preference)\n * - [hint](https://www.mongodb.com/docs/manual/reference/method/cursor.hint/)\n * - [comment](https://www.mongodb.com/docs/manual/reference/method/cursor.comment/)\n *\n * The following options are only for write operations: `updateOne()`, `updateMany()`, `replaceOne()`, `findOneAndUpdate()`, and `findByIdAndUpdate()`:\n *\n * - [upsert](https://www.mongodb.com/docs/manual/reference/method/db.collection.update/)\n * - [writeConcern](https://www.mongodb.com/docs/manual/reference/method/db.collection.update/)\n * - [timestamps](https://mongoosejs.com/docs/guide.html#timestamps): If `timestamps` is set in the schema, set this option to `false` to skip timestamps for that particular update. Has no effect if `timestamps` is not enabled in the schema options.\n * - overwriteDiscriminatorKey: allow setting the discriminator key in the update. Will use the correct discriminator schema if the update changes the discriminator key.\n *\n * The following options are only for `find()`, `findOne()`, `findById()`, `findOneAndUpdate()`, `findOneAndReplace()`, `findOneAndDelete()`, and `findByIdAndUpdate()`:\n *\n * - [lean](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean())\n * - [populate](https://mongoosejs.com/docs/populate.html)\n * - [projection](https://mongoosejs.com/docs/api/query.html#Query.prototype.projection())\n * - sanitizeProjection\n * - useBigInt64\n *\n * The following options are only for all operations **except** `updateOne()`, `updateMany()`, `deleteOne()`, and `deleteMany()`:\n *\n * - [maxTimeMS](https://www.mongodb.com/docs/manual/reference/operator/meta/maxTimeMS/)\n *\n * The following options are for `find()`, `findOne()`, `findOneAndUpdate()`, `findOneAndDelete()`, `updateOne()`, and `deleteOne()`:\n *\n * - [sort](https://www.mongodb.com/docs/manual/reference/method/cursor.sort/)\n *\n * The following options are for `findOneAndUpdate()` and `findOneAndDelete()`\n *\n * - includeResultMetadata\n *\n * The following options are for all operations:\n *\n * - [strict](https://mongoosejs.com/docs/guide.html#strict)\n * - [collation](https://www.mongodb.com/docs/manual/reference/collation/)\n * - [session](https://www.mongodb.com/docs/manual/reference/server-sessions/)\n * - [explain](https://www.mongodb.com/docs/manual/reference/method/cursor.explain/)\n *\n * @param {Object} options\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.setOptions = function(options, overwrite) {\n  // overwrite is only for internal use\n  if (overwrite) {\n    // ensure that _mongooseOptions & options are two different objects\n    this._mongooseOptions = (options && clone(options)) || {};\n    this.options = options || {};\n\n    if ('populate' in options) {\n      this.populate(this._mongooseOptions);\n    }\n    return this;\n  }\n  if (options == null) {\n    return this;\n  }\n  if (typeof options !== 'object') {\n    throw new Error('Options must be an object, got \"' + options + '\"');\n  }\n\n  options = Object.assign({}, options);\n\n  if (Array.isArray(options.populate)) {\n    const populate = options.populate;\n    delete options.populate;\n    const _numPopulate = populate.length;\n    for (let i = 0; i < _numPopulate; ++i) {\n      this.populate(populate[i]);\n    }\n  }\n\n  if ('setDefaultsOnInsert' in options) {\n    this._mongooseOptions.setDefaultsOnInsert = options.setDefaultsOnInsert;\n    delete options.setDefaultsOnInsert;\n  }\n  if ('overwriteDiscriminatorKey' in options) {\n    this._mongooseOptions.overwriteDiscriminatorKey = options.overwriteDiscriminatorKey;\n    delete options.overwriteDiscriminatorKey;\n  }\n  if ('sanitizeProjection' in options) {\n    if (options.sanitizeProjection && !this._mongooseOptions.sanitizeProjection) {\n      sanitizeProjection(this._fields);\n    }\n\n    this._mongooseOptions.sanitizeProjection = options.sanitizeProjection;\n    delete options.sanitizeProjection;\n  }\n  if ('sanitizeFilter' in options) {\n    this._mongooseOptions.sanitizeFilter = options.sanitizeFilter;\n    delete options.sanitizeFilter;\n  }\n  if ('timestamps' in options) {\n    this._mongooseOptions.timestamps = options.timestamps;\n    delete options.timestamps;\n  }\n  if ('defaults' in options) {\n    this._mongooseOptions.defaults = options.defaults;\n    // deleting options.defaults will cause 7287 to fail\n  }\n  if ('translateAliases' in options) {\n    this._mongooseOptions.translateAliases = options.translateAliases;\n    delete options.translateAliases;\n  }\n\n  if (options.lean == null && this.schema && 'lean' in this.schema.options) {\n    this._mongooseOptions.lean = this.schema.options.lean;\n  }\n\n  if (typeof options.limit === 'string') {\n    try {\n      options.limit = castNumber(options.limit);\n    } catch (err) {\n      throw new CastError('Number', options.limit, 'limit');\n    }\n  }\n  if (typeof options.skip === 'string') {\n    try {\n      options.skip = castNumber(options.skip);\n    } catch (err) {\n      throw new CastError('Number', options.skip, 'skip');\n    }\n  }\n\n  // set arbitrary options\n  for (const key of Object.keys(options)) {\n    if (queryOptionMethods.has(key)) {\n      const args = Array.isArray(options[key]) ?\n        options[key] :\n        [options[key]];\n      this[key].apply(this, args);\n    } else {\n      this.options[key] = options[key];\n    }\n  }\n\n  return this;\n};\n\n/**\n * Sets the [`explain` option](https://www.mongodb.com/docs/manual/reference/method/cursor.explain/),\n * which makes this query return detailed execution stats instead of the actual\n * query result. This method is useful for determining what index your queries\n * use.\n *\n * Calling `query.explain(v)` is equivalent to `query.setOptions({ explain: v })`\n *\n * #### Example:\n *\n *     const query = new Query();\n *     const res = await query.find({ a: 1 }).explain('queryPlanner');\n *     console.log(res);\n *\n * @param {String} [verbose] The verbosity mode. Either 'queryPlanner', 'executionStats', or 'allPlansExecution'. The default is 'queryPlanner'\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.explain = function explain(verbose) {\n  if (arguments.length === 0) {\n    this.options.explain = true;\n  } else if (verbose === false) {\n    delete this.options.explain;\n  } else {\n    this.options.explain = verbose;\n  }\n  return this;\n};\n\n/**\n * Sets the [`allowDiskUse` option](https://www.mongodb.com/docs/manual/reference/method/cursor.allowDiskUse/),\n * which allows the MongoDB server to use more than 100 MB for this query's `sort()`. This option can\n * let you work around `QueryExceededMemoryLimitNoDiskUseAllowed` errors from the MongoDB server.\n *\n * Note that this option requires MongoDB server >= 4.4. Setting this option is a no-op for MongoDB 4.2\n * and earlier.\n *\n * Calling `query.allowDiskUse(v)` is equivalent to `query.setOptions({ allowDiskUse: v })`\n *\n * #### Example:\n *\n *     await query.find().sort({ name: 1 }).allowDiskUse(true);\n *     // Equivalent:\n *     await query.find().sort({ name: 1 }).allowDiskUse();\n *\n * @param {Boolean} [v] Enable/disable `allowDiskUse`. If called with 0 arguments, sets `allowDiskUse: true`\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.allowDiskUse = function(v) {\n  if (arguments.length === 0) {\n    this.options.allowDiskUse = true;\n  } else if (v === false) {\n    delete this.options.allowDiskUse;\n  } else {\n    this.options.allowDiskUse = v;\n  }\n  return this;\n};\n\n/**\n * Sets the [maxTimeMS](https://www.mongodb.com/docs/manual/reference/method/cursor.maxTimeMS/)\n * option. This will tell the MongoDB server to abort if the query or write op\n * has been running for more than `ms` milliseconds.\n *\n * Calling `query.maxTimeMS(v)` is equivalent to `query.setOptions({ maxTimeMS: v })`\n *\n * #### Example:\n *\n *     const query = new Query();\n *     // Throws an error 'operation exceeded time limit' as long as there's\n *     // >= 1 doc in the queried collection\n *     const res = await query.find({ $where: 'sleep(1000) || true' }).maxTimeMS(100);\n *\n * @param {Number} [ms] The number of milliseconds\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.maxTimeMS = function(ms) {\n  this.options.maxTimeMS = ms;\n  return this;\n};\n\n/**\n * Returns the current query filter (also known as conditions) as a [POJO](https://masteringjs.io/tutorials/fundamentals/pojo).\n *\n * #### Example:\n *\n *     const query = new Query();\n *     query.find({ a: 1 }).where('b').gt(2);\n *     query.getFilter(); // { a: 1, b: { $gt: 2 } }\n *\n * @return {Object} current query filter\n * @api public\n */\n\nQuery.prototype.getFilter = function() {\n  return this._conditions;\n};\n\n/**\n * Returns the current query filter. Equivalent to `getFilter()`.\n *\n * You should use `getFilter()` instead of `getQuery()` where possible. `getQuery()`\n * will likely be deprecated in a future release.\n *\n * #### Example:\n *\n *     const query = new Query();\n *     query.find({ a: 1 }).where('b').gt(2);\n *     query.getQuery(); // { a: 1, b: { $gt: 2 } }\n *\n * @return {Object} current query filter\n * @api public\n */\n\nQuery.prototype.getQuery = function() {\n  return this._conditions;\n};\n\n/**\n * Sets the query conditions to the provided JSON object.\n *\n * #### Example:\n *\n *     const query = new Query();\n *     query.find({ a: 1 })\n *     query.setQuery({ a: 2 });\n *     query.getQuery(); // { a: 2 }\n *\n * @param {Object} new query conditions\n * @return {undefined}\n * @api public\n */\n\nQuery.prototype.setQuery = function(val) {\n  this._conditions = val;\n};\n\n/**\n * Returns the current update operations as a JSON object.\n *\n * #### Example:\n *\n *     const query = new Query();\n *     query.updateOne({}, { $set: { a: 5 } });\n *     query.getUpdate(); // { $set: { a: 5 } }\n *\n * @return {Object} current update operations\n * @api public\n */\n\nQuery.prototype.getUpdate = function() {\n  return this._update;\n};\n\n/**\n * Sets the current update operation to new value.\n *\n * #### Example:\n *\n *     const query = new Query();\n *     query.updateOne({}, { $set: { a: 5 } });\n *     query.setUpdate({ $set: { b: 6 } });\n *     query.getUpdate(); // { $set: { b: 6 } }\n *\n * @param {Object} new update operation\n * @return {undefined}\n * @api public\n */\n\nQuery.prototype.setUpdate = function(val) {\n  this._update = val;\n};\n\n/**\n * Returns fields selection for this query.\n *\n * @method _fieldsForExec\n * @return {Object}\n * @api private\n * @memberOf Query\n */\n\nQuery.prototype._fieldsForExec = function() {\n  if (this._fields == null) {\n    return null;\n  }\n  if (Object.keys(this._fields).length === 0) {\n    return null;\n  }\n  return clone(this._fields);\n};\n\n\n/**\n * Return an update document with corrected `$set` operations.\n *\n * @method _updateForExec\n * @return {Object}\n * @api private\n * @memberOf Query\n */\n\nQuery.prototype._updateForExec = function() {\n  const update = clone(this._update, {\n    transform: false,\n    depopulate: true\n  });\n  const ops = Object.keys(update);\n  let i = ops.length;\n  const ret = {};\n\n  while (i--) {\n    const op = ops[i];\n\n    if ('$' !== op[0]) {\n      // fix up $set sugar\n      if (!ret.$set) {\n        if (update.$set) {\n          ret.$set = update.$set;\n        } else {\n          ret.$set = {};\n        }\n      }\n      ret.$set[op] = update[op];\n      ops.splice(i, 1);\n      if (!~ops.indexOf('$set')) ops.push('$set');\n    } else if ('$set' === op) {\n      if (!ret.$set) {\n        ret[op] = update[op];\n      }\n    } else {\n      ret[op] = update[op];\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Makes sure _path is set.\n *\n * This method is inherited by `mquery`\n *\n * @method _ensurePath\n * @param {String} method\n * @api private\n * @memberOf Query\n */\n\n/**\n * Determines if `conds` can be merged using `mquery().merge()`\n *\n * @method canMerge\n * @memberOf Query\n * @instance\n * @param {Object} conds\n * @return {Boolean}\n * @api private\n */\n\n/**\n * Returns default options for this query.\n *\n * @param {Model} model\n * @api private\n */\n\nQuery.prototype._optionsForExec = function(model) {\n  const options = clone(this.options);\n  delete options.populate;\n  model = model || this.model;\n\n  if (!model) {\n    return options;\n  }\n  // Apply schema-level `writeConcern` option\n  applyWriteConcern(model.schema, options);\n\n  const readPreference = model &&\n  model.schema &&\n  model.schema.options &&\n  model.schema.options.read;\n  if (!('readPreference' in options) && readPreference) {\n    options.readPreference = readPreference;\n  }\n\n  if (options.upsert !== void 0) {\n    options.upsert = !!options.upsert;\n  }\n  if (options.writeConcern) {\n    if (options.j) {\n      options.writeConcern.j = options.j;\n      delete options.j;\n    }\n    if (options.w) {\n      options.writeConcern.w = options.w;\n      delete options.w;\n    }\n    if (options.wtimeout) {\n      options.writeConcern.wtimeout = options.wtimeout;\n      delete options.wtimeout;\n    }\n  }\n\n  this._applyPaths();\n  if (this._fields != null) {\n    this._fields = this._castFields(this._fields);\n    const projection = this._fieldsForExec();\n    if (projection != null) {\n      options.projection = projection;\n    }\n  }\n\n  return options;\n};\n\n/**\n * Sets the lean option.\n *\n * Documents returned from queries with the `lean` option enabled are plain\n * javascript objects, not [Mongoose Documents](https://mongoosejs.com/docs/api/document.html). They have no\n * `save` method, getters/setters, virtuals, or other Mongoose features.\n *\n * #### Example:\n *\n *     new Query().lean() // true\n *     new Query().lean(true)\n *     new Query().lean(false)\n *\n *     const docs = await Model.find().lean();\n *     docs[0] instanceof mongoose.Document; // false\n *\n * [Lean is great for high-performance, read-only cases](https://mongoosejs.com/docs/tutorials/lean.html),\n * especially when combined\n * with [cursors](https://mongoosejs.com/docs/queries.html#streaming).\n *\n * If you need virtuals, getters/setters, or defaults with `lean()`, you need\n * to use a plugin. See:\n *\n * - [mongoose-lean-virtuals](https://plugins.mongoosejs.io/plugins/lean-virtuals)\n * - [mongoose-lean-getters](https://plugins.mongoosejs.io/plugins/lean-getters)\n * - [mongoose-lean-defaults](https://www.npmjs.com/package/mongoose-lean-defaults)\n *\n * @param {Boolean|Object} bool defaults to true\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.lean = function(v) {\n  this._mongooseOptions.lean = arguments.length ? v : true;\n  return this;\n};\n\n/**\n * Adds a `$set` to this query's update without changing the operation.\n * This is useful for query middleware so you can add an update regardless\n * of whether you use `updateOne()`, `updateMany()`, `findOneAndUpdate()`, etc.\n *\n * #### Example:\n *\n *     // Updates `{ $set: { updatedAt: new Date() } }`\n *     new Query().updateOne({}, {}).set('updatedAt', new Date());\n *     new Query().updateMany({}, {}).set({ updatedAt: new Date() });\n *\n * @param {String|Object} path path or object of key/value pairs to set\n * @param {Any} [val] the value to set\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.set = function(path, val) {\n  if (typeof path === 'object') {\n    const keys = Object.keys(path);\n    for (const key of keys) {\n      this.set(key, path[key]);\n    }\n    return this;\n  }\n\n  this._update = this._update || {};\n  if (path in this._update) {\n    delete this._update[path];\n  }\n  this._update.$set = this._update.$set || {};\n  this._update.$set[path] = val;\n  return this;\n};\n\n/**\n * For update operations, returns the value of a path in the update's `$set`.\n * Useful for writing getters/setters that can work with both update operations\n * and `save()`.\n *\n * #### Example:\n *\n *     const query = Model.updateOne({}, { $set: { name: 'Jean-Luc Picard' } });\n *     query.get('name'); // 'Jean-Luc Picard'\n *\n * @param {String|Object} path path or object of key/value pairs to get\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.get = function get(path) {\n  const update = this._update;\n  if (update == null) {\n    return void 0;\n  }\n  const $set = update.$set;\n  if ($set == null) {\n    return update[path];\n  }\n\n  if (utils.hasUserDefinedProperty(update, path)) {\n    return update[path];\n  }\n  if (utils.hasUserDefinedProperty($set, path)) {\n    return $set[path];\n  }\n\n  return void 0;\n};\n\n/**\n * Gets/sets the error flag on this query. If this flag is not null or\n * undefined, the `exec()` promise will reject without executing.\n *\n * #### Example:\n *\n *     Query().error(); // Get current error value\n *     Query().error(null); // Unset the current error\n *     Query().error(new Error('test')); // `exec()` will resolve with test\n *     Schema.pre('find', function() {\n *       if (!this.getQuery().userId) {\n *         this.error(new Error('Not allowed to query without setting userId'));\n *       }\n *     });\n *\n * Note that query casting runs **after** hooks, so cast errors will override\n * custom errors.\n *\n * #### Example:\n *\n *     const TestSchema = new Schema({ num: Number });\n *     const TestModel = db.model('Test', TestSchema);\n *     TestModel.find({ num: 'not a number' }).error(new Error('woops')).exec(function(error) {\n *       // `error` will be a cast error because `num` failed to cast\n *     });\n *\n * @param {Error|null} err if set, `exec()` will fail fast before sending the query to MongoDB\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.error = function error(err) {\n  if (arguments.length === 0) {\n    return this._error;\n  }\n\n  this._error = err;\n  return this;\n};\n\n/**\n * ignore\n * @method _unsetCastError\n * @instance\n * @memberOf Query\n * @api private\n */\n\nQuery.prototype._unsetCastError = function _unsetCastError() {\n  if (this._error != null && !(this._error instanceof CastError)) {\n    return;\n  }\n  return this.error(null);\n};\n\n/**\n * Getter/setter around the current mongoose-specific options for this query\n * Below are the current Mongoose-specific options.\n *\n * - `populate`: an array representing what paths will be populated. Should have one entry for each call to [`Query.prototype.populate()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.populate())\n * - `lean`: if truthy, Mongoose will not [hydrate](https://mongoosejs.com/docs/api/model.html#Model.hydrate()) any documents that are returned from this query. See [`Query.prototype.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) for more information.\n * - `strict`: controls how Mongoose handles keys that aren't in the schema for updates. This option is `true` by default, which means Mongoose will silently strip any paths in the update that aren't in the schema. See the [`strict` mode docs](https://mongoosejs.com/docs/guide.html#strict) for more information.\n * - `strictQuery`: controls how Mongoose handles keys that aren't in the schema for the query `filter`. This option is `false` by default, which means Mongoose will allow `Model.find({ foo: 'bar' })` even if `foo` is not in the schema. See the [`strictQuery` docs](https://mongoosejs.com/docs/guide.html#strictQuery) for more information.\n * - `nearSphere`: use `$nearSphere` instead of `near()`. See the [`Query.prototype.nearSphere()` docs](https://mongoosejs.com/docs/api/query.html#Query.prototype.nearSphere())\n *\n * Mongoose maintains a separate object for internal options because\n * Mongoose sends `Query.prototype.options` to the MongoDB server, and the\n * above options are not relevant for the MongoDB server.\n *\n * @param {Object} options if specified, overwrites the current options\n * @return {Object} the options\n * @api public\n */\n\nQuery.prototype.mongooseOptions = function(v) {\n  if (arguments.length > 0) {\n    this._mongooseOptions = v;\n  }\n  return this._mongooseOptions;\n};\n\n/**\n * ignore\n * @method _castConditions\n * @memberOf Query\n * @api private\n * @instance\n */\n\nQuery.prototype._castConditions = function() {\n  let sanitizeFilterOpt = undefined;\n  if (this.model != null && utils.hasUserDefinedProperty(this.model.db.options, 'sanitizeFilter')) {\n    sanitizeFilterOpt = this.model.db.options.sanitizeFilter;\n  } else if (this.model != null && utils.hasUserDefinedProperty(this.model.base.options, 'sanitizeFilter')) {\n    sanitizeFilterOpt = this.model.base.options.sanitizeFilter;\n  } else {\n    sanitizeFilterOpt = this._mongooseOptions.sanitizeFilter;\n  }\n\n  if (sanitizeFilterOpt) {\n    sanitizeFilter(this._conditions);\n  }\n\n  try {\n    this.cast(this.model);\n    this._unsetCastError();\n  } catch (err) {\n    this.error(err);\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction _castArrayFilters(query) {\n  try {\n    castArrayFilters(query);\n  } catch (err) {\n    query.error(err);\n  }\n}\n\n/**\n * Execute a `find()`\n *\n * @return {Query} this\n * @api private\n */\nQuery.prototype._find = async function _find() {\n  this._castConditions();\n\n  if (this.error() != null) {\n    throw this.error();\n  }\n\n  const mongooseOptions = this._mongooseOptions;\n  const _this = this;\n  const userProvidedFields = _this._userProvidedFields || {};\n\n  applyGlobalMaxTimeMS(this.options, this.model.db.options, this.model.base.options);\n  applyGlobalDiskUse(this.options, this.model.db.options, this.model.base.options);\n\n  // Separate options to pass down to `completeMany()` in case we need to\n  // set a session on the document\n  const completeManyOptions = Object.assign({}, {\n    session: this && this.options && this.options.session || null,\n    lean: mongooseOptions.lean || null\n  });\n\n  const options = this._optionsForExec();\n\n  this._applyTranslateAliases(options);\n\n  const filter = this._conditions;\n  const fields = options.projection;\n\n  const cursor = await this.mongooseCollection.find(filter, options);\n  if (options.explain) {\n    return cursor.explain();\n  }\n\n  let docs = await cursor.toArray();\n  if (docs.length === 0) {\n    return docs;\n  }\n\n  if (!mongooseOptions.populate) {\n    const versionKey = _this.schema.options.versionKey;\n    if (mongooseOptions.lean && mongooseOptions.lean.versionKey === false && versionKey) {\n      docs.forEach((doc) => {\n        if (versionKey in doc) {\n          delete doc[versionKey];\n        }\n      });\n    }\n    return mongooseOptions.lean ?\n      _completeManyLean(_this.model.schema, docs, null, completeManyOptions) :\n      _this._completeMany(docs, fields, userProvidedFields, completeManyOptions);\n  }\n  const pop = helpers.preparePopulationOptionsMQ(_this, mongooseOptions);\n\n  if (mongooseOptions.lean) {\n    return _this.model.populate(docs, pop);\n  }\n\n  docs = await _this._completeMany(docs, fields, userProvidedFields, completeManyOptions);\n  await this.model.populate(docs, pop);\n\n  return docs;\n};\n\n/**\n * Find all documents that match `selector`. The result will be an array of documents.\n *\n * If there are too many documents in the result to fit in memory, use\n * [`Query.prototype.cursor()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.cursor())\n *\n * #### Example:\n *\n *     const arr = await Movie.find({ year: { $gte: 1980, $lte: 1989 } });\n *\n * @param {Object|ObjectId} [filter] mongodb filter. If not specified, returns all documents.\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.find = function(conditions) {\n  if (typeof conditions === 'function' ||\n      typeof arguments[1] === 'function') {\n    throw new MongooseError('Query.prototype.find() no longer accepts a callback');\n  }\n\n  this.op = 'find';\n\n  if (mquery.canMerge(conditions)) {\n    this.merge(conditions);\n\n    prepareDiscriminatorCriteria(this);\n  } else if (conditions != null) {\n    this.error(new ObjectParameterError(conditions, 'filter', 'find'));\n  }\n\n  return this;\n};\n\n/**\n * Merges another Query or conditions object into this one.\n *\n * When a Query is passed, conditions, field selection and options are merged.\n *\n * @param {Query|Object} source\n * @return {Query} this\n */\n\nQuery.prototype.merge = function(source) {\n  if (!source) {\n    return this;\n  }\n\n  const opts = { overwrite: true };\n\n  if (source instanceof Query) {\n    // if source has a feature, apply it to ourselves\n\n    if (source._conditions) {\n      opts.omit = {};\n      if (this._conditions && this._conditions.$and && source._conditions.$and) {\n        opts.omit['$and'] = true;\n        this._conditions.$and = this._conditions.$and.concat(source._conditions.$and);\n      }\n      if (this._conditions && this._conditions.$or && source._conditions.$or) {\n        opts.omit['$or'] = true;\n        this._conditions.$or = this._conditions.$or.concat(source._conditions.$or);\n      }\n      utils.merge(this._conditions, source._conditions, opts);\n    }\n\n    if (source._fields) {\n      this._fields || (this._fields = {});\n      utils.merge(this._fields, source._fields, opts);\n    }\n\n    if (source.options) {\n      this.options || (this.options = {});\n      utils.merge(this.options, source.options, opts);\n    }\n\n    if (source._update) {\n      this._update || (this._update = {});\n      utils.mergeClone(this._update, source._update);\n    }\n\n    if (source._distinct) {\n      this._distinct = source._distinct;\n    }\n\n    utils.merge(this._mongooseOptions, source._mongooseOptions);\n\n    return this;\n  } else if (this.model != null && source instanceof this.model.base.Types.ObjectId) {\n    utils.merge(this._conditions, { _id: source }, opts);\n\n    return this;\n  } else if (source && source.$__) {\n    source = source.toObject(internalToObjectOptions);\n  }\n\n  opts.omit = {};\n  if (this._conditions && this._conditions.$and && source.$and) {\n    opts.omit['$and'] = true;\n    this._conditions.$and = this._conditions.$and.concat(source.$and);\n  }\n  if (this._conditions && this._conditions.$or && source.$or) {\n    opts.omit['$or'] = true;\n    this._conditions.$or = this._conditions.$or.concat(source.$or);\n  }\n\n  // plain object\n  utils.merge(this._conditions, source, opts);\n\n  return this;\n};\n\n/**\n * Adds a collation to this op (MongoDB 3.4 and up)\n *\n * @param {Object} value\n * @return {Query} this\n * @see MongoDB docs https://www.mongodb.com/docs/manual/reference/method/cursor.collation/#cursor.collation\n * @api public\n */\n\nQuery.prototype.collation = function(value) {\n  if (this.options == null) {\n    this.options = {};\n  }\n  this.options.collation = value;\n  return this;\n};\n\n/**\n * Hydrate a single doc from `findOne()`, `findOneAndUpdate()`, etc.\n *\n * @api private\n */\n\nQuery.prototype._completeOne = function(doc, res, callback) {\n  if (!doc && !this.options.includeResultMetadata) {\n    return callback(null, null);\n  }\n\n  const model = this.model;\n  const projection = clone(this._fields);\n  const userProvidedFields = this._userProvidedFields || {};\n  // `populate`, `lean`\n  const mongooseOptions = this._mongooseOptions;\n\n  const options = this.options;\n  if (!options.lean && mongooseOptions.lean) {\n    options.lean = mongooseOptions.lean;\n  }\n\n  if (options.explain) {\n    return callback(null, doc);\n  }\n\n  if (!mongooseOptions.populate) {\n    const versionKey = this.schema.options.versionKey;\n    if (mongooseOptions.lean && mongooseOptions.lean.versionKey === false && versionKey) {\n      if (versionKey in doc) {\n        delete doc[versionKey];\n      }\n    }\n    return mongooseOptions.lean ?\n      _completeOneLean(model.schema, doc, null, res, options, callback) :\n      completeOne(model, doc, res, options, projection, userProvidedFields,\n        null, callback);\n  }\n\n  const pop = helpers.preparePopulationOptionsMQ(this, this._mongooseOptions);\n  if (mongooseOptions.lean) {\n    return model.populate(doc, pop).then(\n      doc => {\n        _completeOneLean(model.schema, doc, null, res, options, callback);\n      },\n      error => {\n        callback(error);\n      }\n    );\n  }\n\n  completeOne(model, doc, res, options, projection, userProvidedFields, [], (err, doc) => {\n    if (err != null) {\n      return callback(err);\n    }\n    model.populate(doc, pop).then(res => { callback(null, res); }, err => { callback(err); });\n  });\n};\n\n/**\n * Given a model and an array of docs, hydrates all the docs to be instances\n * of the model. Used to initialize docs returned from the db from `find()`\n *\n * @param {Array} docs\n * @param {Object} fields the projection used, including `select` from schemas\n * @param {Object} userProvidedFields the user-specified projection\n * @param {Object} [opts]\n * @param {Array} [opts.populated]\n * @param {ClientSession} [opts.session]\n * @api private\n */\n\nQuery.prototype._completeMany = async function _completeMany(docs, fields, userProvidedFields, opts) {\n  const model = this.model;\n  return Promise.all(docs.map(doc => new Promise((resolve, reject) => {\n    const rawDoc = doc;\n    doc = helpers.createModel(model, doc, fields, userProvidedFields);\n    if (opts.session != null) {\n      doc.$session(opts.session);\n    }\n    doc.$init(rawDoc, opts, (err) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve(doc);\n    });\n  })));\n};\n\n/**\n * Internal helper to execute a findOne() operation\n *\n * @see findOne https://www.mongodb.com/docs/manual/reference/method/db.collection.findOne/\n * @api private\n */\n\nQuery.prototype._findOne = async function _findOne() {\n  this._castConditions();\n\n  if (this.error()) {\n    const err = this.error();\n    throw err;\n  }\n\n  applyGlobalMaxTimeMS(this.options, this.model.db.options, this.model.base.options);\n  applyGlobalDiskUse(this.options, this.model.db.options, this.model.base.options);\n\n  const options = this._optionsForExec();\n\n  this._applyTranslateAliases(options);\n\n  // don't pass in the conditions because we already merged them in\n  const doc = await this.mongooseCollection.findOne(this._conditions, options);\n  return new Promise((resolve, reject) => {\n    this._completeOne(doc, null, (err, res) => {\n      if (err) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n};\n\n/**\n * Declares the query a findOne operation. When executed, the first found document is passed to the callback.\n *\n * The result of the query is a single document, or `null` if no document was found.\n *\n * * *Note:* `conditions` is optional, and if `conditions` is null or undefined,\n * mongoose will send an empty `findOne` command to MongoDB, which will return\n * an arbitrary document. If you're querying by `_id`, use `Model.findById()`\n * instead.\n *\n * This function triggers the following middleware.\n *\n * - `findOne()`\n *\n * #### Example:\n *\n *     const query = Kitten.where({ color: 'white' });\n *     const kitten = await query.findOne();\n *\n * @param {Object} [filter] mongodb selector\n * @param {Object} [projection] optional fields to return\n * @param {Object} [options] see [`setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query} this\n * @see findOne https://www.mongodb.com/docs/manual/reference/method/db.collection.findOne/\n * @see Query.select https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @api public\n */\n\nQuery.prototype.findOne = function(conditions, projection, options) {\n  if (typeof conditions === 'function' ||\n      typeof projection === 'function' ||\n      typeof options === 'function' ||\n      typeof arguments[3] === 'function') {\n    throw new MongooseError('Query.prototype.findOne() no longer accepts a callback');\n  }\n\n  this.op = 'findOne';\n  this._validateOp();\n\n  if (options) {\n    this.setOptions(options);\n  }\n\n  if (projection) {\n    this.select(projection);\n  }\n\n  if (mquery.canMerge(conditions)) {\n    this.merge(conditions);\n\n    prepareDiscriminatorCriteria(this);\n  } else if (conditions != null) {\n    this.error(new ObjectParameterError(conditions, 'filter', 'findOne'));\n  }\n\n  return this;\n};\n\n\n/**\n * Execute a countDocuments query\n *\n * @see countDocuments https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments\n * @api private\n */\n\nQuery.prototype._countDocuments = async function _countDocuments() {\n  try {\n    this.cast(this.model);\n  } catch (err) {\n    this.error(err);\n  }\n\n  if (this.error()) {\n    throw this.error();\n  }\n\n  applyGlobalMaxTimeMS(this.options, this.model.db.options, this.model.base.options);\n  applyGlobalDiskUse(this.options, this.model.db.options, this.model.base.options);\n\n  const options = this._optionsForExec();\n\n  this._applyTranslateAliases(options);\n\n  const conds = this._conditions;\n\n  return this.mongooseCollection.countDocuments(conds, options);\n};\n\n/*!\n * If `translateAliases` option is set, call `Model.translateAliases()`\n * on the following query properties: filter, projection, update, distinct.\n */\n\nQuery.prototype._applyTranslateAliases = function _applyTranslateAliases(options) {\n  let applyTranslateAliases = false;\n  if ('translateAliases' in this._mongooseOptions) {\n    applyTranslateAliases = this._mongooseOptions.translateAliases;\n  } else if (this.model?.schema?._userProvidedOptions?.translateAliases != null) {\n    applyTranslateAliases = this.model.schema._userProvidedOptions.translateAliases;\n  } else if (this.model?.base?.options?.translateAliases != null) {\n    applyTranslateAliases = this.model.base.options.translateAliases;\n  }\n  if (!applyTranslateAliases) {\n    return;\n  }\n\n  if (this.model?.schema?.aliases && Object.keys(this.model.schema.aliases).length > 0) {\n    this.model.translateAliases(this._conditions, true);\n    this.model.translateAliases(options.projection, true);\n    this.model.translateAliases(this._update, true);\n    if (this._distinct != null && this.model.schema.aliases[this._distinct] != null) {\n      this._distinct = this.model.schema.aliases[this._distinct];\n    }\n  }\n};\n\n/**\n * Execute a estimatedDocumentCount() query\n *\n * @see estimatedDocumentCount https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#estimatedDocumentCount\n * @api private\n */\n\nQuery.prototype._estimatedDocumentCount = async function _estimatedDocumentCount() {\n  if (this.error()) {\n    throw this.error();\n  }\n\n  const options = this._optionsForExec();\n\n  return this.mongooseCollection.estimatedDocumentCount(options);\n};\n\n/**\n * Specifies this query as a `estimatedDocumentCount()` query. Faster than\n * using `countDocuments()` for large collections because\n * `estimatedDocumentCount()` uses collection metadata rather than scanning\n * the entire collection.\n *\n * `estimatedDocumentCount()` does **not** accept a filter. `Model.find({ foo: bar }).estimatedDocumentCount()`\n * is equivalent to `Model.find().estimatedDocumentCount()`\n *\n * This function triggers the following middleware.\n *\n * - `estimatedDocumentCount()`\n *\n * #### Example:\n *\n *     await Model.find().estimatedDocumentCount();\n *\n * @param {Object} [options] passed transparently to the [MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/EstimatedDocumentCountOptions.html)\n * @return {Query} this\n * @see estimatedDocumentCount https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#estimatedDocumentCount\n * @api public\n */\n\nQuery.prototype.estimatedDocumentCount = function(options) {\n  if (typeof options === 'function' ||\n      typeof arguments[1] === 'function') {\n    throw new MongooseError('Query.prototype.estimatedDocumentCount() no longer accepts a callback');\n  }\n\n  this.op = 'estimatedDocumentCount';\n  this._validateOp();\n\n  if (typeof options === 'object' && options != null) {\n    this.setOptions(options);\n  }\n\n  return this;\n};\n\n/**\n * Specifies this query as a `countDocuments()` query. Behaves like `count()`,\n * except it always does a full collection scan when passed an empty filter `{}`.\n *\n * There are also minor differences in how `countDocuments()` handles\n * [`$where` and a couple geospatial operators](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments).\n * versus `count()`.\n *\n * This function triggers the following middleware.\n *\n * - `countDocuments()`\n *\n * #### Example:\n *\n *     const countQuery = model.where({ 'color': 'black' }).countDocuments();\n *\n *     query.countDocuments({ color: 'black' }).count().exec();\n *\n *     await query.countDocuments({ color: 'black' });\n *\n *     query.where('color', 'black').countDocuments().exec();\n *\n * The `countDocuments()` function is similar to `count()`, but there are a\n * [few operators that `countDocuments()` does not support](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments).\n * Below are the operators that `count()` supports but `countDocuments()` does not,\n * and the suggested replacement:\n *\n * - `$where`: [`$expr`](https://www.mongodb.com/docs/manual/reference/operator/query/expr/)\n * - `$near`: [`$geoWithin`](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/) with [`$center`](https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center)\n * - `$nearSphere`: [`$geoWithin`](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/) with [`$centerSphere`](https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere)\n *\n * @param {Object} [filter] mongodb selector\n * @param {Object} [options]\n * @return {Query} this\n * @see countDocuments https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments\n * @api public\n */\n\nQuery.prototype.countDocuments = function(conditions, options) {\n  if (typeof conditions === 'function' ||\n      typeof options === 'function' ||\n      typeof arguments[2] === 'function') {\n    throw new MongooseError('Query.prototype.countDocuments() no longer accepts a callback');\n  }\n\n  this.op = 'countDocuments';\n  this._validateOp();\n\n  if (mquery.canMerge(conditions)) {\n    this.merge(conditions);\n  }\n\n  if (typeof options === 'object' && options != null) {\n    this.setOptions(options);\n  }\n\n  return this;\n};\n\n/**\n * Execute a `distinct()` query\n *\n * @see distinct https://www.mongodb.com/docs/manual/reference/method/db.collection.distinct/\n * @api private\n */\n\nQuery.prototype.__distinct = async function __distinct() {\n  this._castConditions();\n\n  if (this.error()) {\n    throw this.error();\n  }\n\n  applyGlobalMaxTimeMS(this.options, this.model.db.options, this.model.base.options);\n  applyGlobalDiskUse(this.options, this.model.db.options, this.model.base.options);\n\n  const options = this._optionsForExec();\n  this._applyTranslateAliases(options);\n\n  return this.mongooseCollection.\n    distinct(this._distinct, this._conditions, options);\n};\n\n/**\n * Declares or executes a distinct() operation.\n *\n * This function does not trigger any middleware.\n *\n * #### Example:\n *\n *     distinct(field, conditions)\n *     distinct(field)\n *     distinct()\n *\n * @param {String} [field]\n * @param {Object|Query} [filter]\n * @return {Query} this\n * @see distinct https://www.mongodb.com/docs/manual/reference/method/db.collection.distinct/\n * @api public\n */\n\nQuery.prototype.distinct = function(field, conditions) {\n  if (typeof field === 'function' ||\n      typeof conditions === 'function' ||\n      typeof arguments[2] === 'function') {\n    throw new MongooseError('Query.prototype.distinct() no longer accepts a callback');\n  }\n\n  this.op = 'distinct';\n  this._validateOp();\n\n  if (mquery.canMerge(conditions)) {\n    this.merge(conditions);\n\n    prepareDiscriminatorCriteria(this);\n  } else if (conditions != null) {\n    this.error(new ObjectParameterError(conditions, 'filter', 'distinct'));\n  }\n\n  if (field != null) {\n    this._distinct = field;\n  }\n\n  return this;\n};\n\n/**\n * Sets the sort order\n *\n * If an object is passed, values allowed are `asc`, `desc`, `ascending`, `descending`, `1`, and `-1`.\n *\n * If a string is passed, it must be a space delimited list of path names. The\n * sort order of each path is ascending unless the path name is prefixed with `-`\n * which will be treated as descending.\n *\n * #### Example:\n *\n *     // sort by \"field\" ascending and \"test\" descending\n *     query.sort({ field: 'asc', test: -1 });\n *\n *     // equivalent\n *     query.sort('field -test');\n *\n *     // also possible is to use a array with array key-value pairs\n *     query.sort([['field', 'asc']]);\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @param {Object|String|Array<Array<(string | number)>>} arg\n * @param {Object} [options]\n * @param {Boolean} [options.override=false] If true, replace existing sort options with `arg`\n * @return {Query} this\n * @see cursor.sort https://www.mongodb.com/docs/manual/reference/method/cursor.sort/\n * @api public\n */\n\nQuery.prototype.sort = function(arg, options) {\n  if (arguments.length > 2) {\n    throw new Error('sort() takes at most 2 arguments');\n  }\n  if (options != null && typeof options !== 'object') {\n    throw new Error('sort() options argument must be an object or nullish');\n  }\n\n  if (this.options.sort == null) {\n    this.options.sort = {};\n  }\n  if (options && options.override) {\n    this.options.sort = {};\n  }\n  const sort = this.options.sort;\n  if (typeof arg === 'string') {\n    const properties = arg.indexOf(' ') === -1 ? [arg] : arg.split(' ');\n    for (let property of properties) {\n      const ascend = '-' == property[0] ? -1 : 1;\n      if (ascend === -1) {\n        property = property.slice(1);\n      }\n      if (specialProperties.has(property)) {\n        continue;\n      }\n      sort[property] = ascend;\n    }\n  } else if (Array.isArray(arg)) {\n    for (const pair of arg) {\n      if (!Array.isArray(pair)) {\n        throw new TypeError('Invalid sort() argument, must be array of arrays');\n      }\n      const key = '' + pair[0];\n      if (specialProperties.has(key)) {\n        continue;\n      }\n      sort[key] = _handleSortValue(pair[1], key);\n    }\n  } else if (typeof arg === 'object' && arg != null && !(arg instanceof Map)) {\n    for (const key of Object.keys(arg)) {\n      if (specialProperties.has(key)) {\n        continue;\n      }\n      sort[key] = _handleSortValue(arg[key], key);\n    }\n  } else if (arg instanceof Map) {\n    for (let key of arg.keys()) {\n      key = '' + key;\n      if (specialProperties.has(key)) {\n        continue;\n      }\n      sort[key] = _handleSortValue(arg.get(key), key);\n    }\n  } else if (arg != null) {\n    throw new TypeError('Invalid sort() argument. Must be a string, object, array, or map.');\n  }\n\n  return this;\n};\n\n/*!\n * Convert sort values\n */\n\nfunction _handleSortValue(val, key) {\n  if (val === 1 || val === 'asc' || val === 'ascending') {\n    return 1;\n  }\n  if (val === -1 || val === 'desc' || val === 'descending') {\n    return -1;\n  }\n  if (val?.$meta != null) {\n    return { $meta: val.$meta };\n  }\n  throw new TypeError('Invalid sort value: { ' + key + ': ' + val + ' }');\n}\n\n/**\n * Declare and/or execute this query as a `deleteOne()` operation. Works like\n * remove, except it deletes at most one document regardless of the `single`\n * option.\n *\n * This function triggers `deleteOne` middleware.\n *\n * #### Example:\n *\n *     await Character.deleteOne({ name: 'Eddard Stark' });\n *\n * This function calls the MongoDB driver's [`Collection#deleteOne()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#deleteOne).\n * The returned [promise](https://mongoosejs.com/docs/queries.html) resolves to an\n * object that contains 3 properties:\n *\n * - `ok`: `1` if no errors occurred\n * - `deletedCount`: the number of documents deleted\n * - `n`: the number of documents deleted. Equal to `deletedCount`.\n *\n * #### Example:\n *\n *     const res = await Character.deleteOne({ name: 'Eddard Stark' });\n *     // `1` if MongoDB deleted a doc, `0` if no docs matched the filter `{ name: ... }`\n *     res.deletedCount;\n *\n * @param {Object|Query} [filter] mongodb selector\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @return {Query} this\n * @see DeleteResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/DeleteResult.html\n * @see deleteOne https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#deleteOne\n * @api public\n */\n\nQuery.prototype.deleteOne = function deleteOne(filter, options) {\n  if (typeof filter === 'function' || typeof options === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Query.prototype.deleteOne() no longer accepts a callback');\n  }\n  this.op = 'deleteOne';\n  this.setOptions(options);\n\n  if (mquery.canMerge(filter)) {\n    this.merge(filter);\n\n    prepareDiscriminatorCriteria(this);\n  } else if (filter != null) {\n    this.error(new ObjectParameterError(filter, 'filter', 'deleteOne'));\n  }\n\n  return this;\n};\n\n/**\n * Internal thunk for `deleteOne()`\n *\n * @method _deleteOne\n * @instance\n * @memberOf Query\n * @api private\n */\n\nQuery.prototype._deleteOne = async function _deleteOne() {\n  this._castConditions();\n\n  if (this.error() != null) {\n    throw this.error();\n  }\n\n  const options = this._optionsForExec();\n  this._applyTranslateAliases(options);\n\n  return this.mongooseCollection.deleteOne(this._conditions, options);\n};\n\n/**\n * Declare and/or execute this query as a `deleteMany()` operation. Works like\n * remove, except it deletes _every_ document that matches `filter` in the\n * collection, regardless of the value of `single`.\n *\n * This function triggers `deleteMany` middleware.\n *\n * #### Example:\n *\n *     await Character.deleteMany({ name: /Stark/, age: { $gte: 18 } });\n *\n * This function calls the MongoDB driver's [`Collection#deleteMany()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#deleteMany).\n * The returned [promise](https://mongoosejs.com/docs/queries.html) resolves to an\n * object that contains 3 properties:\n *\n * - `ok`: `1` if no errors occurred\n * - `deletedCount`: the number of documents deleted\n * - `n`: the number of documents deleted. Equal to `deletedCount`.\n *\n * #### Example:\n *\n *     const res = await Character.deleteMany({ name: /Stark/, age: { $gte: 18 } });\n *     // `0` if no docs matched the filter, number of docs deleted otherwise\n *     res.deletedCount;\n *\n * @param {Object|Query} [filter] mongodb selector\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @return {Query} this\n * @see DeleteResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/DeleteResult.html\n * @see deleteMany https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#deleteMany\n * @api public\n */\n\nQuery.prototype.deleteMany = function(filter, options) {\n  if (typeof filter === 'function' || typeof options === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Query.prototype.deleteMany() no longer accepts a callback');\n  }\n  this.setOptions(options);\n  this.op = 'deleteMany';\n\n  if (mquery.canMerge(filter)) {\n    this.merge(filter);\n\n    prepareDiscriminatorCriteria(this);\n  } else if (filter != null) {\n    this.error(new ObjectParameterError(filter, 'filter', 'deleteMany'));\n  }\n\n  return this;\n};\n\n/**\n * Execute a `deleteMany()` query\n *\n * @param {Function} callback\n * @method _deleteMany\n * @instance\n * @memberOf Query\n * @api private\n */\n\nQuery.prototype._deleteMany = async function _deleteMany() {\n  this._castConditions();\n\n  if (this.error() != null) {\n    throw this.error();\n  }\n\n  const options = this._optionsForExec();\n  this._applyTranslateAliases(options);\n\n  return this.mongooseCollection.deleteMany(this._conditions, options);\n};\n\n/**\n * hydrates a document\n *\n * @param {Model} model\n * @param {Document} doc\n * @param {Object} res 3rd parameter to callback\n * @param {Object} fields\n * @param {Query} self\n * @param {Array} [pop] array of paths used in population\n * @param {Function} callback\n * @api private\n */\n\nfunction completeOne(model, doc, res, options, fields, userProvidedFields, pop, callback) {\n  if (options.includeResultMetadata && doc == null) {\n    _init(null);\n    return null;\n  }\n\n  helpers.createModelAndInit(model, doc, fields, userProvidedFields, options, pop, _init);\n\n  function _init(err, casted) {\n    if (err) {\n      return immediate(() => callback(err));\n    }\n\n\n    if (options.includeResultMetadata) {\n      if (doc && casted) {\n        if (options.session != null) {\n          casted.$session(options.session);\n        }\n        res.value = casted;\n      } else {\n        res.value = null;\n      }\n      return immediate(() => callback(null, res));\n    }\n    if (options.session != null) {\n      casted.$session(options.session);\n    }\n    immediate(() => callback(null, casted));\n  }\n}\n\n/**\n * If the model is a discriminator type and not root, then add the key & value to the criteria.\n * @param {Query} query\n * @api private\n */\n\nfunction prepareDiscriminatorCriteria(query) {\n  if (!query || !query.model || !query.model.schema) {\n    return;\n  }\n\n  const schema = query.model.schema;\n\n  if (schema && schema.discriminatorMapping && !schema.discriminatorMapping.isRoot) {\n    query._conditions[schema.discriminatorMapping.key] = schema.discriminatorMapping.value;\n  }\n}\n\n/**\n * Issues a mongodb `findOneAndUpdate()` command.\n *\n * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found\n * document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndUpdate()`\n *\n * #### Available options\n *\n * - `new`: bool - if true, return the modified document rather than the original. defaults to false (changed in 4.0)\n * - `upsert`: bool - creates the object if it doesn't exist. defaults to false.\n * - `fields`: {Object|String} - Field selection. Equivalent to `.select(fields).findOneAndUpdate()`\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n * - `maxTimeMS`: puts a time limit on the query - requires mongodb >= 2.6.0\n * - `runValidators`: if true, runs [update validators](https://mongoosejs.com/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema.\n * - `setDefaultsOnInsert`: `true` by default. If `setDefaultsOnInsert` and `upsert` are true, mongoose will apply the [defaults](https://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created.\n *\n * #### Example:\n *\n *     query.findOneAndUpdate(conditions, update, options)  // returns Query\n *     query.findOneAndUpdate(conditions, update)           // returns Query\n *     query.findOneAndUpdate(update)                       // returns Query\n *     query.findOneAndUpdate()                             // returns Query\n *\n * @method findOneAndUpdate\n * @memberOf Query\n * @instance\n * @param {Object|Query} [filter]\n * @param {Object} [doc]\n * @param {Object} [options]\n * @param {Boolean} [options.includeResultMetadata] if true, returns the full [ModifyResult from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html) rather than just the document\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean} [options.multipleCastError] by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.\n * @param {Boolean} [options.new=false] By default, `findOneAndUpdate()` returns the document as it was **before** `update` was applied. If you set `new: true`, `findOneAndUpdate()` will instead give you the object after `update` was applied.\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and [the Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.returnOriginal=null] An alias for the `new` option. `returnOriginal: false` is equivalent to `new: true`.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @param {Boolean} [options.overwriteDiscriminatorKey=false] Mongoose removes discriminator key updates from `update` by default, set `overwriteDiscriminatorKey` to `true` to allow updating the discriminator key\n * @see Tutorial https://mongoosejs.com/docs/tutorials/findoneandupdate.html\n * @see findAndModify command https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n * @see ModifyResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html\n * @see findOneAndUpdate https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#findOneAndUpdate\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.findOneAndUpdate = function(filter, doc, options) {\n  if (typeof filter === 'function' ||\n      typeof doc === 'function' ||\n      typeof options === 'function' ||\n      typeof arguments[3] === 'function') {\n    throw new MongooseError('Query.prototype.findOneAndUpdate() no longer accepts a callback');\n  }\n\n  this.op = 'findOneAndUpdate';\n  this._validateOp();\n  this._validate();\n\n  switch (arguments.length) {\n    case 2:\n      options = undefined;\n      break;\n    case 1:\n      doc = filter;\n      filter = options = undefined;\n      break;\n  }\n\n  if (mquery.canMerge(filter)) {\n    this.merge(filter);\n  } else if (filter != null) {\n    this.error(\n      new ObjectParameterError(filter, 'filter', 'findOneAndUpdate')\n    );\n  }\n\n  // apply doc\n  if (doc) {\n    this._mergeUpdate(doc);\n  }\n\n  options = options ? clone(options) : {};\n\n  if (options.projection) {\n    this.select(options.projection);\n    delete options.projection;\n  }\n  if (options.fields) {\n    this.select(options.fields);\n    delete options.fields;\n  }\n\n  const returnOriginal = this &&\n    this.model &&\n    this.model.base &&\n    this.model.base.options &&\n    this.model.base.options.returnOriginal;\n  if (options.new == null && options.returnDocument == null && options.returnOriginal == null && returnOriginal != null) {\n    options.returnOriginal = returnOriginal;\n  }\n\n  this.setOptions(options);\n\n  return this;\n};\n\n/**\n * Execute a findOneAndUpdate operation\n *\n * @method _findOneAndUpdate\n * @memberOf Query\n * @api private\n */\n\nQuery.prototype._findOneAndUpdate = async function _findOneAndUpdate() {\n  this._castConditions();\n\n  _castArrayFilters(this);\n\n  if (this.error()) {\n    throw this.error();\n  }\n\n  applyGlobalMaxTimeMS(this.options, this.model.db.options, this.model.base.options);\n  applyGlobalDiskUse(this.options, this.model.db.options, this.model.base.options);\n\n  if ('strict' in this.options) {\n    this._mongooseOptions.strict = this.options.strict;\n  }\n  const options = this._optionsForExec(this.model);\n  convertNewToReturnDocument(options);\n  this._applyTranslateAliases(options);\n\n  this._update = this._castUpdate(this._update);\n\n  const _opts = Object.assign({}, options, {\n    setDefaultsOnInsert: this._mongooseOptions.setDefaultsOnInsert\n  });\n  this._update = setDefaultsOnInsert(this._conditions, this.model.schema,\n    this._update, _opts);\n\n  if (!this._update || Object.keys(this._update).length === 0) {\n    if (options.upsert) {\n      // still need to do the upsert to empty doc\n      const doc = clone(this._update);\n      delete doc._id;\n      this._update = { $set: doc };\n    } else {\n      this._executionStack = null;\n      const res = await this._findOne();\n      return res;\n    }\n  } else if (this._update instanceof Error) {\n    throw this._update;\n  } else {\n    // In order to make MongoDB 2.6 happy (see\n    // https://jira.mongodb.org/browse/SERVER-12266 and related issues)\n    // if we have an actual update document but $set is empty, junk the $set.\n    if (this._update.$set && Object.keys(this._update.$set).length === 0) {\n      delete this._update.$set;\n    }\n  }\n\n  const runValidators = _getOption(this, 'runValidators', false);\n  if (runValidators) {\n    await this.validate(this._update, options, false);\n  }\n\n  if (this._update.toBSON) {\n    this._update = this._update.toBSON();\n  }\n\n  let res = await this.mongooseCollection.findOneAndUpdate(this._conditions, this._update, options);\n  for (const fn of this._transforms) {\n    res = fn(res);\n  }\n  const doc = !options.includeResultMetadata ? res : res.value;\n\n  return new Promise((resolve, reject) => {\n    this._completeOne(doc, res, (err, res) => {\n      if (err) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n};\n\n/**\n * Issues a MongoDB [findOneAndDelete](https://www.mongodb.com/docs/manual/reference/method/db.collection.findOneAndDelete/) command.\n *\n * Finds a matching document, removes it, and returns the found document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndDelete()`\n *\n * #### Available options\n *\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n * - `maxTimeMS`: puts a time limit on the query - requires mongodb >= 2.6.0\n *\n * #### Callback Signature\n *\n *     function(error, doc) {\n *       // error: any errors that occurred\n *       // doc: the document before updates are applied if `new: false`, or after updates if `new = true`\n *     }\n *\n * #### Example:\n *\n *     A.where().findOneAndDelete(conditions, options)  // return Query\n *     A.where().findOneAndDelete(conditions) // returns Query\n *     A.where().findOneAndDelete()           // returns Query\n *\n * @method findOneAndDelete\n * @memberOf Query\n * @param {Object} [filter]\n * @param {Object} [options]\n * @param {Boolean} [options.includeResultMetadata] if true, returns the full [ModifyResult from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html) rather than just the document\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @return {Query} this\n * @see findAndModify command https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n * @api public\n */\n\nQuery.prototype.findOneAndDelete = function(filter, options) {\n  if (typeof filter === 'function' ||\n      typeof options === 'function' ||\n      typeof arguments[2] === 'function') {\n    throw new MongooseError('Query.prototype.findOneAndDelete() no longer accepts a callback');\n  }\n\n  this.op = 'findOneAndDelete';\n  this._validateOp();\n  this._validate();\n\n  if (mquery.canMerge(filter)) {\n    this.merge(filter);\n  }\n\n  options && this.setOptions(options);\n\n  return this;\n};\n\n/**\n * Execute a `findOneAndDelete()` query\n *\n * @return {Query} this\n * @method _findOneAndDelete\n * @memberOf Query\n * @api private\n */\nQuery.prototype._findOneAndDelete = async function _findOneAndDelete() {\n  this._castConditions();\n\n  if (this.error() != null) {\n    throw this.error();\n  }\n\n  const includeResultMetadata = this.options.includeResultMetadata;\n\n  const filter = this._conditions;\n  const options = this._optionsForExec(this.model);\n  this._applyTranslateAliases(options);\n\n  let res = await this.mongooseCollection.findOneAndDelete(filter, options);\n  for (const fn of this._transforms) {\n    res = fn(res);\n  }\n  const doc = !includeResultMetadata ? res : res.value;\n\n  return new Promise((resolve, reject) => {\n    this._completeOne(doc, res, (err, res) => {\n      if (err) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n};\n\n/**\n * Issues a MongoDB [findOneAndReplace](https://www.mongodb.com/docs/manual/reference/method/db.collection.findOneAndReplace/) command.\n *\n * Finds a matching document, removes it, and returns the found document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndReplace()`\n *\n * #### Available options\n *\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n * - `maxTimeMS`: puts a time limit on the query - requires mongodb >= 2.6.0\n * - `includeResultMetadata`: if true, returns the full [ModifyResult from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html) rather than just the document\n *\n * #### Callback Signature\n *\n *     function(error, doc) {\n *       // error: any errors that occurred\n *       // doc: the document before updates are applied if `new: false`, or after updates if `new = true`\n *     }\n *\n * #### Example:\n *\n *     A.where().findOneAndReplace(filter, replacement, options); // return Query\n *     A.where().findOneAndReplace(filter); // returns Query\n *     A.where().findOneAndReplace(); // returns Query\n *\n * @method findOneAndReplace\n * @memberOf Query\n * @param {Object} [filter]\n * @param {Object} [replacement]\n * @param {Object} [options]\n * @param {Boolean} [options.includeResultMetadata] if true, returns the full [ModifyResult from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html) rather than just the document\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.new=false] By default, `findOneAndUpdate()` returns the document as it was **before** `update` was applied. If you set `new: true`, `findOneAndUpdate()` will instead give you the object after `update` was applied.\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and [the Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.returnOriginal=null] An alias for the `new` option. `returnOriginal: false` is equivalent to `new: true`.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.findOneAndReplace = function(filter, replacement, options) {\n  if (typeof filter === 'function' ||\n      typeof replacement === 'function' ||\n      typeof options === 'function' ||\n      typeof arguments[4] === 'function') {\n    throw new MongooseError('Query.prototype.findOneAndReplace() no longer accepts a callback');\n  }\n\n  this.op = 'findOneAndReplace';\n  this._validateOp();\n  this._validate();\n\n  if (mquery.canMerge(filter)) {\n    this.merge(filter);\n  } else if (filter != null) {\n    this.error(\n      new ObjectParameterError(filter, 'filter', 'findOneAndReplace')\n    );\n  }\n\n  if (replacement != null) {\n    this._mergeUpdate(replacement);\n  }\n\n  options = options || {};\n\n  const returnOriginal = this &&\n  this.model &&\n  this.model.base &&\n  this.model.base.options &&\n  this.model.base.options.returnOriginal;\n  if (options.new == null && options.returnDocument == null && options.returnOriginal == null && returnOriginal != null) {\n    options.returnOriginal = returnOriginal;\n  }\n  this.setOptions(options);\n\n  return this;\n};\n\n/**\n * Execute a findOneAndReplace() query\n *\n * @return {Query} this\n * @method _findOneAndReplace\n * @instance\n * @memberOf Query\n * @api private\n */\nQuery.prototype._findOneAndReplace = async function _findOneAndReplace() {\n  this._castConditions();\n  if (this.error() != null) {\n    throw this.error();\n  }\n\n  if ('strict' in this.options) {\n    this._mongooseOptions.strict = this.options.strict;\n    delete this.options.strict;\n  }\n\n  const filter = this._conditions;\n  const options = this._optionsForExec();\n  this._applyTranslateAliases(options);\n  convertNewToReturnDocument(options);\n\n  const includeResultMetadata = this.options.includeResultMetadata;\n\n  const modelOpts = { skipId: true };\n  if ('strict' in this._mongooseOptions) {\n    modelOpts.strict = this._mongooseOptions.strict;\n  }\n\n  const runValidators = _getOption(this, 'runValidators', false);\n\n  try {\n    const update = new this.model(this._update, null, modelOpts);\n    if (runValidators) {\n      await update.validate();\n    } else if (update.$__.validationError) {\n      throw update.$__.validationError;\n    }\n    this._update = update.toBSON();\n  } catch (err) {\n    if (err instanceof ValidationError) {\n      throw err;\n    }\n    const validationError = new ValidationError();\n    validationError.errors[err.path] = err;\n    throw validationError;\n  }\n\n  let res = await this.mongooseCollection.findOneAndReplace(filter, this._update, options);\n\n  for (const fn of this._transforms) {\n    res = fn(res);\n  }\n\n  const doc = !includeResultMetadata ? res : res.value;\n  return new Promise((resolve, reject) => {\n    this._completeOne(doc, res, (err, res) => {\n      if (err) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n};\n\n/**\n * Support the `new` option as an alternative to `returnOriginal` for backwards\n * compat.\n * @api private\n */\n\nfunction convertNewToReturnDocument(options) {\n  if ('new' in options) {\n    options.returnDocument = options['new'] ? 'after' : 'before';\n    delete options['new'];\n  }\n  if ('returnOriginal' in options) {\n    options.returnDocument = options['returnOriginal'] ? 'before' : 'after';\n    delete options['returnOriginal'];\n  }\n  // Temporary since driver 4.0.0-beta does not support `returnDocument`\n  if (typeof options.returnDocument === 'string') {\n    options.returnOriginal = options.returnDocument === 'before';\n  }\n}\n\n/**\n * Get options from query opts, falling back to the base mongoose object.\n * @param {Query} query\n * @param {Object} option\n * @param {Any} def\n * @api private\n */\n\nfunction _getOption(query, option, def) {\n  const opts = query._optionsForExec(query.model);\n\n  if (option in opts) {\n    return opts[option];\n  }\n  if (option in query.model.base.options) {\n    return query.model.base.options[option];\n  }\n  return def;\n}\n\n/*!\n * ignore\n */\n\nfunction _completeOneLean(schema, doc, path, res, opts, callback) {\n  if (opts.lean && typeof opts.lean.transform === 'function') {\n    opts.lean.transform(doc);\n\n    for (let i = 0; i < schema.childSchemas.length; i++) {\n      const childPath = path ? path + '.' + schema.childSchemas[i].model.path : schema.childSchemas[i].model.path;\n      const _schema = schema.childSchemas[i].schema;\n      const obj = mpath.get(childPath, doc);\n      if (obj == null) {\n        continue;\n      }\n      if (Array.isArray(obj)) {\n        for (let i = 0; i < obj.length; i++) {\n          opts.lean.transform(obj[i]);\n        }\n      } else {\n        opts.lean.transform(obj);\n      }\n      _completeOneLean(_schema, obj, childPath, res, opts);\n    }\n    if (callback) {\n      return callback(null, doc);\n    } else {\n      return;\n    }\n  }\n  if (opts.includeResultMetadata) {\n    return callback(null, res);\n  }\n  return callback(null, doc);\n}\n\n/*!\n * ignore\n */\n\nfunction _completeManyLean(schema, docs, path, opts) {\n  if (opts.lean && typeof opts.lean.transform === 'function') {\n    for (const doc of docs) {\n      opts.lean.transform(doc);\n    }\n\n    for (let i = 0; i < schema.childSchemas.length; i++) {\n      const childPath = path ? path + '.' + schema.childSchemas[i].model.path : schema.childSchemas[i].model.path;\n      const _schema = schema.childSchemas[i].schema;\n      let doc = mpath.get(childPath, docs);\n      if (doc == null) {\n        continue;\n      }\n      doc = doc.flat();\n      for (let i = 0; i < doc.length; i++) {\n        opts.lean.transform(doc[i]);\n      }\n      _completeManyLean(_schema, doc, childPath, opts);\n    }\n  }\n\n  return docs;\n}\n/**\n * Override mquery.prototype._mergeUpdate to handle mongoose objects in\n * updates.\n *\n * @param {Object} doc\n * @method _mergeUpdate\n * @memberOf Query\n * @instance\n * @api private\n */\n\nQuery.prototype._mergeUpdate = function(doc) {\n  if (!this._update) {\n    this._update = Array.isArray(doc) ? [] : {};\n  }\n\n  if (doc == null || (typeof doc === 'object' && Object.keys(doc).length === 0)) {\n    return;\n  }\n\n  if (doc instanceof Query) {\n    if (Array.isArray(this._update)) {\n      throw new Error('Cannot mix array and object updates');\n    }\n    if (doc._update) {\n      utils.mergeClone(this._update, doc._update);\n    }\n  } else if (Array.isArray(doc)) {\n    if (!Array.isArray(this._update)) {\n      throw new Error('Cannot mix array and object updates');\n    }\n    this._update = this._update.concat(doc);\n  } else {\n    if (Array.isArray(this._update)) {\n      throw new Error('Cannot mix array and object updates');\n    }\n    utils.mergeClone(this._update, doc);\n  }\n};\n\n/*!\n * ignore\n */\n\nasync function _updateThunk(op) {\n  this._castConditions();\n\n  _castArrayFilters(this);\n\n  if (this.error() != null) {\n    throw this.error();\n  }\n\n  const castedQuery = this._conditions;\n  const options = this._optionsForExec(this.model);\n  this._applyTranslateAliases(options);\n\n  this._update = clone(this._update, options);\n  const isOverwriting = op === 'replaceOne';\n  if (isOverwriting) {\n    this._update = new this.model(this._update, null, true);\n  } else {\n    this._update = this._castUpdate(this._update);\n\n    if (this._update == null || Object.keys(this._update).length === 0) {\n      return { acknowledged: false };\n    }\n\n    const _opts = Object.assign({}, options, {\n      setDefaultsOnInsert: this._mongooseOptions.setDefaultsOnInsert\n    });\n    this._update = setDefaultsOnInsert(this._conditions, this.model.schema,\n      this._update, _opts);\n  }\n\n  if (Array.isArray(options.arrayFilters)) {\n    options.arrayFilters = removeUnusedArrayFilters(this._update, options.arrayFilters);\n  }\n\n  const runValidators = _getOption(this, 'runValidators', false);\n  if (runValidators) {\n    await this.validate(this._update, options, isOverwriting);\n  }\n\n  if (this._update.toBSON) {\n    this._update = this._update.toBSON();\n  }\n\n  return this.mongooseCollection[op](castedQuery, this._update, options);\n}\n\n/**\n * Mongoose calls this function internally to validate the query if\n * `runValidators` is set\n *\n * @param {Object} castedDoc the update, after casting\n * @param {Object} options the options from `_optionsForExec()`\n * @param {Boolean} isOverwriting\n * @method validate\n * @memberOf Query\n * @instance\n * @api private\n */\n\nQuery.prototype.validate = async function validate(castedDoc, options, isOverwriting) {\n  if (typeof arguments[3] === 'function') {\n    throw new MongooseError('Query.prototype.validate() no longer accepts a callback');\n  }\n\n  await _executePreHooks(this, 'validate');\n\n  if (isOverwriting) {\n    await castedDoc.$validate();\n  } else {\n    await new Promise((resolve, reject) => {\n      updateValidators(this, this.model.schema, castedDoc, options, (err) => {\n        if (err != null) {\n          return reject(err);\n        }\n        resolve();\n      });\n    });\n  }\n\n  await _executePostHooks(this, null, null, 'validate');\n};\n\n/**\n * Execute an updateMany query\n *\n * @see Model.update https://mongoosejs.com/docs/api/model.html#Model.update()\n * @method _updateMany\n * @memberOf Query\n * @instance\n * @api private\n */\nQuery.prototype._updateMany = async function _updateMany() {\n  return _updateThunk.call(this, 'updateMany');\n};\n\n/**\n * Execute an updateOne query\n *\n * @see Model.update https://mongoosejs.com/docs/api/model.html#Model.update()\n * @method _updateOne\n * @memberOf Query\n * @instance\n * @api private\n */\nQuery.prototype._updateOne = async function _updateOne() {\n  return _updateThunk.call(this, 'updateOne');\n};\n\n/**\n * Execute a replaceOne query\n *\n * @see Model.replaceOne https://mongoosejs.com/docs/api/model.html#Model.replaceOne()\n * @method _replaceOne\n * @memberOf Query\n * @instance\n * @api private\n */\nQuery.prototype._replaceOne = async function _replaceOne() {\n  return _updateThunk.call(this, 'replaceOne');\n};\n\n/**\n * Declare and/or execute this query as an updateMany() operation.\n * MongoDB will update _all_ documents that match `filter` (as opposed to just the first one).\n *\n * **Note** updateMany will _not_ fire update middleware. Use `pre('updateMany')`\n * and `post('updateMany')` instead.\n *\n * #### Example:\n *\n *     const res = await Person.updateMany({ name: /Stark$/ }, { isDeleted: true });\n *     res.n; // Number of documents matched\n *     res.nModified; // Number of documents modified\n *\n * This function triggers the following middleware.\n *\n * - `updateMany()`\n *\n * @param {Object} [filter]\n * @param {Object|Array} [update] the update command. If array, this update will be treated as an update pipeline and not casted.\n * @param {Object} [options]\n * @param {Boolean} [options.multipleCastError] by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @param {Boolean} [options.overwriteDiscriminatorKey=false] Mongoose removes discriminator key updates from `update` by default, set `overwriteDiscriminatorKey` to `true` to allow updating the discriminator key\n * @param {Function} [callback] params are (error, writeOpResult)\n * @return {Query} this\n * @see Model.update https://mongoosejs.com/docs/api/model.html#Model.update()\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see update https://www.mongodb.com/docs/manual/reference/method/db.collection.update/\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @see MongoDB docs https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output\n * @api public\n */\n\nQuery.prototype.updateMany = function(conditions, doc, options, callback) {\n  if (typeof options === 'function') {\n    // .update(conditions, doc, callback)\n    callback = options;\n    options = null;\n  } else if (typeof doc === 'function') {\n    // .update(doc, callback);\n    callback = doc;\n    doc = conditions;\n    conditions = {};\n    options = null;\n  } else if (typeof conditions === 'function') {\n    // .update(callback)\n    callback = conditions;\n    conditions = undefined;\n    doc = undefined;\n    options = undefined;\n  } else if (typeof conditions === 'object' && !doc && !options && !callback) {\n    // .update(doc)\n    doc = conditions;\n    conditions = undefined;\n    options = undefined;\n    callback = undefined;\n  }\n\n  return _update(this, 'updateMany', conditions, doc, options, callback);\n};\n\n/**\n * Declare and/or execute this query as an updateOne() operation.\n * MongoDB will update _only_ the first document that matches `filter`.\n *\n * - Use `replaceOne()` if you want to overwrite an entire document rather than using [atomic operators](https://www.mongodb.com/docs/manual/tutorial/model-data-for-atomic-operations/#pattern) like `$set`.\n *\n * **Note** updateOne will _not_ fire update middleware. Use `pre('updateOne')`\n * and `post('updateOne')` instead.\n *\n * #### Example:\n *\n *     const res = await Person.updateOne({ name: 'Jean-Luc Picard' }, { ship: 'USS Enterprise' });\n *     res.acknowledged; // Indicates if this write result was acknowledged. If not, then all other members of this result will be undefined.\n *     res.matchedCount; // Number of documents that matched the filter\n *     res.modifiedCount; // Number of documents that were modified\n *     res.upsertedCount; // Number of documents that were upserted\n *     res.upsertedId; // Identifier of the inserted document (if an upsert took place)\n *\n * This function triggers the following middleware.\n *\n * - `updateOne()`\n *\n * @param {Object} [filter]\n * @param {Object|Array} [update] the update command. If array, this update will be treated as an update pipeline and not casted.\n * @param {Object} [options]\n * @param {Boolean} [options.multipleCastError] by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @param {Boolean} [options.overwriteDiscriminatorKey=false] Mongoose removes discriminator key updates from `update` by default, set `overwriteDiscriminatorKey` to `true` to allow updating the discriminator key\n * @param {Function} [callback] params are (error, writeOpResult)\n * @return {Query} this\n * @see Model.update https://mongoosejs.com/docs/api/model.html#Model.update()\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see update https://www.mongodb.com/docs/manual/reference/method/db.collection.update/\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @see MongoDB docs https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output\n * @api public\n */\n\nQuery.prototype.updateOne = function(conditions, doc, options, callback) {\n  if (typeof options === 'function') {\n    // .update(conditions, doc, callback)\n    callback = options;\n    options = null;\n  } else if (typeof doc === 'function') {\n    // .update(doc, callback);\n    callback = doc;\n    doc = conditions;\n    conditions = {};\n    options = null;\n  } else if (typeof conditions === 'function') {\n    // .update(callback)\n    callback = conditions;\n    conditions = undefined;\n    doc = undefined;\n    options = undefined;\n  } else if (typeof conditions === 'object' && !doc && !options && !callback) {\n    // .update(doc)\n    doc = conditions;\n    conditions = undefined;\n    options = undefined;\n    callback = undefined;\n  }\n\n  return _update(this, 'updateOne', conditions, doc, options, callback);\n};\n\n/**\n * Declare and/or execute this query as a replaceOne() operation.\n * MongoDB will replace the existing document and will not accept any [atomic operators](https://www.mongodb.com/docs/manual/tutorial/model-data-for-atomic-operations/#pattern) (`$set`, etc.)\n *\n * **Note** replaceOne will _not_ fire update middleware. Use `pre('replaceOne')`\n * and `post('replaceOne')` instead.\n *\n * #### Example:\n *\n *     const res = await Person.replaceOne({ _id: 24601 }, { name: 'Jean Valjean' });\n *     res.acknowledged; // Indicates if this write result was acknowledged. If not, then all other members of this result will be undefined.\n *     res.matchedCount; // Number of documents that matched the filter\n *     res.modifiedCount; // Number of documents that were modified\n *     res.upsertedCount; // Number of documents that were upserted\n *     res.upsertedId; // Identifier of the inserted document (if an upsert took place)\n *\n * This function triggers the following middleware.\n *\n * - `replaceOne()`\n *\n * @param {Object} [filter]\n * @param {Object} [doc] the update command\n * @param {Object} [options]\n * @param {Boolean} [options.multipleCastError] by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @param {Function} [callback] params are (error, writeOpResult)\n * @return {Query} this\n * @see Model.update https://mongoosejs.com/docs/api/model.html#Model.update()\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see update https://www.mongodb.com/docs/manual/reference/method/db.collection.update/\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @see MongoDB docs https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output\n * @api public\n */\n\nQuery.prototype.replaceOne = function(conditions, doc, options, callback) {\n  if (typeof options === 'function') {\n    // .update(conditions, doc, callback)\n    callback = options;\n    options = null;\n  } else if (typeof doc === 'function') {\n    // .update(doc, callback);\n    callback = doc;\n    doc = conditions;\n    conditions = {};\n    options = null;\n  } else if (typeof conditions === 'function') {\n    // .update(callback)\n    callback = conditions;\n    conditions = undefined;\n    doc = undefined;\n    options = undefined;\n  } else if (typeof conditions === 'object' && !doc && !options && !callback) {\n    // .update(doc)\n    doc = conditions;\n    conditions = undefined;\n    options = undefined;\n    callback = undefined;\n  }\n\n  return _update(this, 'replaceOne', conditions, doc, options, callback);\n};\n\n/**\n * Internal helper for update, updateMany, updateOne, replaceOne\n * @param {Query} query\n * @param {String} op\n * @param {Object} filter\n * @param {Document} [doc]\n * @param {Object} [options]\n * @param {Function} callback\n * @api private\n */\n\nfunction _update(query, op, filter, doc, options, callback) {\n  // make sure we don't send in the whole Document to merge()\n  query.op = op;\n  query._validateOp();\n  doc = doc || {};\n\n  // strict is an option used in the update checking, make sure it gets set\n  if (options != null) {\n    if ('strict' in options) {\n      query._mongooseOptions.strict = options.strict;\n    }\n  }\n\n  if (!(filter instanceof Query) &&\n      filter != null &&\n      filter.toString() !== '[object Object]') {\n    query.error(new ObjectParameterError(filter, 'filter', op));\n  } else {\n    query.merge(filter);\n  }\n\n  if (utils.isObject(options)) {\n    query.setOptions(options);\n  }\n\n  query._mergeUpdate(doc);\n\n  // Hooks\n  if (callback) {\n    query.exec(callback);\n\n    return query;\n  }\n\n  return query;\n}\n\n/**\n * Runs a function `fn` and treats the return value of `fn` as the new value\n * for the query to resolve to.\n *\n * Any functions you pass to `transform()` will run **after** any post hooks.\n *\n * #### Example:\n *\n *     const res = await MyModel.findOne().transform(res => {\n *       // Sets a `loadedAt` property on the doc that tells you the time the\n *       // document was loaded.\n *       return res == null ?\n *         res :\n *         Object.assign(res, { loadedAt: new Date() });\n *     });\n *\n * @method transform\n * @memberOf Query\n * @instance\n * @param {Function} fn function to run to transform the query result\n * @return {Query} this\n */\n\nQuery.prototype.transform = function(fn) {\n  this._transforms.push(fn);\n  return this;\n};\n\n/**\n * Make this query throw an error if no documents match the given `filter`.\n * This is handy for integrating with async/await, because `orFail()` saves you\n * an extra `if` statement to check if no document was found.\n *\n * #### Example:\n *\n *     // Throws if no doc returned\n *     await Model.findOne({ foo: 'bar' }).orFail();\n *\n *     // Throws if no document was updated. Note that `orFail()` will still\n *     // throw if the only document that matches is `{ foo: 'bar', name: 'test' }`,\n *     // because `orFail()` will throw if no document was _updated_, not\n *     // if no document was _found_.\n *     await Model.updateOne({ foo: 'bar' }, { name: 'test' }).orFail();\n *\n *     // Throws \"No docs found!\" error if no docs match `{ foo: 'bar' }`\n *     await Model.find({ foo: 'bar' }).orFail(new Error('No docs found!'));\n *\n *     // Throws \"Not found\" error if no document was found\n *     await Model.findOneAndUpdate({ foo: 'bar' }, { name: 'test' }).\n *       orFail(() => Error('Not found'));\n *\n * @method orFail\n * @memberOf Query\n * @instance\n * @param {Function|Error} [err] optional error to throw if no docs match `filter`. If not specified, `orFail()` will throw a `DocumentNotFoundError`\n * @return {Query} this\n */\n\nQuery.prototype.orFail = function(err) {\n  this.transform(res => {\n    switch (this.op) {\n      case 'find':\n        if (res.length === 0) {\n          throw _orFailError(err, this);\n        }\n        break;\n      case 'findOne':\n        if (res == null) {\n          throw _orFailError(err, this);\n        }\n        break;\n      case 'replaceOne':\n      case 'updateMany':\n      case 'updateOne':\n        if (res && res.matchedCount === 0) {\n          throw _orFailError(err, this);\n        }\n        break;\n      case 'findOneAndDelete':\n      case 'findOneAndUpdate':\n      case 'findOneAndReplace':\n        if (this.options.includeResultMetadata && res != null && res.value == null) {\n          throw _orFailError(err, this);\n        }\n        if (!this.options.includeResultMetadata && res == null) {\n          throw _orFailError(err, this);\n        }\n        break;\n      case 'deleteMany':\n      case 'deleteOne':\n        if (res.deletedCount === 0) {\n          throw _orFailError(err, this);\n        }\n        break;\n      default:\n        break;\n    }\n\n    return res;\n  });\n  return this;\n};\n\n/**\n * Get the error to throw for `orFail()`\n * @param {Error|undefined} err\n * @param {Query} query\n * @api private\n */\n\nfunction _orFailError(err, query) {\n  if (typeof err === 'function') {\n    err = err.call(query);\n  }\n\n  if (err == null) {\n    err = new DocumentNotFoundError(query.getQuery(), query.model.modelName);\n  }\n\n  return err;\n}\n\n/**\n * Wrapper function to call isPathSelectedInclusive on a query.\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nQuery.prototype.isPathSelectedInclusive = function(path) {\n  return isPathSelectedInclusive(this._fields, path);\n};\n\n/**\n * Executes the query\n *\n * #### Example:\n *\n *     const promise = query.exec();\n *     const promise = query.exec('update');\n *\n * @param {String|Function} [operation]\n * @return {Promise}\n * @api public\n */\n\nQuery.prototype.exec = async function exec(op) {\n  if (typeof op === 'function' || (arguments.length >= 2 && typeof arguments[1] === 'function')) {\n    throw new MongooseError('Query.prototype.exec() no longer accepts a callback');\n  }\n\n  if (typeof op === 'string') {\n    this.op = op;\n  }\n\n  if (this.op == null) {\n    throw new MongooseError('Query must have `op` before executing');\n  }\n  if (this.model == null) {\n    throw new MongooseError('Query must have an associated model before executing');\n  }\n  this._validateOp();\n\n  if (!this.op) {\n    return;\n  }\n\n  if (this.options && this.options.sort) {\n    const keys = Object.keys(this.options.sort);\n    if (keys.includes('')) {\n      throw new Error('Invalid field \"\" passed to sort()');\n    }\n  }\n\n  let thunk = '_' + this.op;\n  if (this.op === 'distinct') {\n    thunk = '__distinct';\n  }\n\n  if (this._executionStack != null) {\n    let str = this.toString();\n    if (str.length > 60) {\n      str = str.slice(0, 60) + '...';\n    }\n    const err = new MongooseError('Query was already executed: ' + str);\n    err.originalStack = this._executionStack.stack;\n    throw err;\n  } else {\n    this._executionStack = new Error();\n  }\n\n  let skipWrappedFunction = null;\n  try {\n    await _executePreExecHooks(this);\n  } catch (err) {\n    if (err instanceof Kareem.skipWrappedFunction) {\n      skipWrappedFunction = err;\n    } else {\n      throw err;\n    }\n  }\n\n  let res;\n\n  let error = null;\n  try {\n    await _executePreHooks(this);\n    res = skipWrappedFunction ? skipWrappedFunction.args[0] : await this[thunk]();\n\n    for (const fn of this._transforms) {\n      res = fn(res);\n    }\n  } catch (err) {\n    if (err instanceof Kareem.skipWrappedFunction) {\n      res = err.args[0];\n    } else {\n      error = err;\n    }\n  }\n\n  res = await _executePostHooks(this, res, error);\n\n  await _executePostExecHooks(this);\n\n  return res;\n};\n\n/*!\n * ignore\n */\n\nfunction _executePostExecHooks(query) {\n  return new Promise((resolve, reject) => {\n    query._hooks.execPost('exec', query, [], {}, (error) => {\n      if (error) {\n        return reject(error);\n      }\n\n      resolve();\n    });\n  });\n}\n\n/*!\n * ignore\n */\n\nfunction _executePostHooks(query, res, error, op) {\n  if (query._queryMiddleware == null) {\n    if (error != null) {\n      throw error;\n    }\n    return res;\n  }\n\n  return new Promise((resolve, reject) => {\n    const opts = error ? { error } : {};\n\n    query._queryMiddleware.execPost(op || query.op, query, [res], opts, (error, res) => {\n      if (error) {\n        return reject(error);\n      }\n\n      resolve(res);\n    });\n  });\n}\n\n/*!\n * ignore\n */\n\nfunction _executePreExecHooks(query) {\n  return new Promise((resolve, reject) => {\n    query._hooks.execPre('exec', query, [], (error) => {\n      if (error != null) {\n        return reject(error);\n      }\n      resolve();\n    });\n  });\n}\n\n/*!\n * ignore\n */\n\nfunction _executePreHooks(query, op) {\n  if (query._queryMiddleware == null) {\n    return;\n  }\n\n  return new Promise((resolve, reject) => {\n    query._queryMiddleware.execPre(op || query.op, query, [], (error) => {\n      if (error != null) {\n        return reject(error);\n      }\n      resolve();\n    });\n  });\n}\n\n/**\n * Executes the query returning a `Promise` which will be\n * resolved with either the doc(s) or rejected with the error.\n *\n * More about [`then()` in JavaScript](https://masteringjs.io/tutorials/fundamentals/then).\n *\n * @param {Function} [resolve]\n * @param {Function} [reject]\n * @return {Promise}\n * @api public\n */\n\nQuery.prototype.then = function(resolve, reject) {\n  return this.exec().then(resolve, reject);\n};\n\n/**\n * Executes the query returning a `Promise` which will be\n * resolved with either the doc(s) or rejected with the error.\n * Like `.then()`, but only takes a rejection handler.\n *\n * More about [Promise `catch()` in JavaScript](https://masteringjs.io/tutorials/fundamentals/catch).\n *\n * @param {Function} [reject]\n * @return {Promise}\n * @api public\n */\n\nQuery.prototype.catch = function(reject) {\n  return this.exec().then(null, reject);\n};\n\n/**\n * Executes the query returning a `Promise` which will be\n * resolved with `.finally()` chained.\n *\n * More about [Promise `finally()` in JavaScript](https://thecodebarbarian.com/using-promise-finally-in-node-js.html).\n *\n * @param {Function} [onFinally]\n * @return {Promise}\n * @api public\n */\n\nQuery.prototype.finally = function(onFinally) {\n  return this.exec().finally(onFinally);\n};\n\n/**\n * Returns a string representation of this query.\n *\n * More about [`toString()` in JavaScript](https://masteringjs.io/tutorials/fundamentals/tostring).\n *\n * #### Example:\n *     const q = Model.find();\n *     console.log(q); // Prints \"Query { find }\"\n *\n * @return {String}\n * @api public\n * @method [Symbol.toStringTag]\n * @memberOf Query\n */\n\nQuery.prototype[Symbol.toStringTag] = function toString() {\n  return `Query { ${this.op} }`;\n};\n\n/**\n * Add pre [middleware](https://mongoosejs.com/docs/middleware.html) to this query instance. Doesn't affect\n * other queries.\n *\n * #### Example:\n *\n *     const q1 = Question.find({ answer: 42 });\n *     q1.pre(function middleware() {\n *       console.log(this.getFilter());\n *     });\n *     await q1.exec(); // Prints \"{ answer: 42 }\"\n *\n *     // Doesn't print anything, because `middleware()` is only\n *     // registered on `q1`.\n *     await Question.find({ answer: 42 });\n *\n * @param {Function} fn\n * @return {Promise}\n * @api public\n */\n\nQuery.prototype.pre = function(fn) {\n  this._hooks.pre('exec', fn);\n  return this;\n};\n\n/**\n * Add post [middleware](https://mongoosejs.com/docs/middleware.html) to this query instance. Doesn't affect\n * other queries.\n *\n * #### Example:\n *\n *     const q1 = Question.find({ answer: 42 });\n *     q1.post(function middleware() {\n *       console.log(this.getFilter());\n *     });\n *     await q1.exec(); // Prints \"{ answer: 42 }\"\n *\n *     // Doesn't print anything, because `middleware()` is only\n *     // registered on `q1`.\n *     await Question.find({ answer: 42 });\n *\n * @param {Function} fn\n * @return {Promise}\n * @api public\n */\n\nQuery.prototype.post = function(fn) {\n  this._hooks.post('exec', fn);\n  return this;\n};\n\n/**\n * Casts obj for an update command.\n *\n * @param {Object} obj\n * @return {Object} obj after casting its values\n * @method _castUpdate\n * @memberOf Query\n * @instance\n * @api private\n */\n\nQuery.prototype._castUpdate = function _castUpdate(obj) {\n  let schema = this.schema;\n\n  const discriminatorKey = schema.options.discriminatorKey;\n  const baseSchema = schema._baseSchema ? schema._baseSchema : schema;\n  if (this._mongooseOptions.overwriteDiscriminatorKey &&\n      obj[discriminatorKey] != null &&\n      baseSchema.discriminators) {\n    const _schema = Object.values(baseSchema.discriminators).find(\n      discriminator => discriminator.discriminatorMapping.value === obj[discriminatorKey]\n    );\n    if (_schema != null) {\n      schema = _schema;\n    }\n  }\n\n  let upsert;\n  if ('upsert' in this.options) {\n    upsert = this.options.upsert;\n  }\n\n  const filter = this._conditions;\n  if (schema != null &&\n      utils.hasUserDefinedProperty(filter, schema.options.discriminatorKey) &&\n      typeof filter[schema.options.discriminatorKey] !== 'object' &&\n      schema.discriminators != null) {\n    const discriminatorValue = filter[schema.options.discriminatorKey];\n    const byValue = getDiscriminatorByValue(this.model.discriminators, discriminatorValue);\n    schema = schema.discriminators[discriminatorValue] ||\n      (byValue && byValue.schema) ||\n      schema;\n  }\n\n  return castUpdate(schema, obj, {\n    strict: this._mongooseOptions.strict,\n    upsert: upsert,\n    arrayFilters: this.options.arrayFilters,\n    overwriteDiscriminatorKey: this._mongooseOptions.overwriteDiscriminatorKey\n  }, this, this._conditions);\n};\n\n/**\n * Specifies paths which should be populated with other documents.\n *\n * #### Example:\n *\n *     let book = await Book.findOne().populate('authors');\n *     book.title; // 'Node.js in Action'\n *     book.authors[0].name; // 'TJ Holowaychuk'\n *     book.authors[1].name; // 'Nathan Rajlich'\n *\n *     let books = await Book.find().populate({\n *       path: 'authors',\n *       // `match` and `sort` apply to the Author model,\n *       // not the Book model. These options do not affect\n *       // which documents are in `books`, just the order and\n *       // contents of each book document's `authors`.\n *       match: { name: new RegExp('.*h.*', 'i') },\n *       sort: { name: -1 }\n *     });\n *     books[0].title; // 'Node.js in Action'\n *     // Each book's `authors` are sorted by name, descending.\n *     books[0].authors[0].name; // 'TJ Holowaychuk'\n *     books[0].authors[1].name; // 'Marc Harter'\n *\n *     books[1].title; // 'Professional AngularJS'\n *     // Empty array, no authors' name has the letter 'h'\n *     books[1].authors; // []\n *\n * Paths are populated after the query executes and a response is received. A\n * separate query is then executed for each path specified for population. After\n * a response for each query has also been returned, the results are passed to\n * the callback.\n *\n * @param {Object|String|String[]} path either the path(s) to populate or an object specifying all parameters\n * @param {Object|String} [select] Field selection for the population query\n * @param {Model} [model] The model you wish to use for population. If not specified, populate will look up the model by the name in the Schema's `ref` field.\n * @param {Object} [match] Conditions for the population query\n * @param {Object} [options] Options for the population query (sort, etc)\n * @param {String} [options.path=null] The path to populate.\n * @param {boolean} [options.retainNullValues=false] by default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.\n * @param {boolean} [options.getters=false] if true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](https://mongoosejs.com/docs/schematypes.html#schematype-options).\n * @param {boolean} [options.clone=false] When you do `BlogPost.find().populate('author')`, blog posts with the same author will share 1 copy of an `author` doc. Enable this option to make Mongoose clone populated docs before assigning them.\n * @param {Object|Function} [options.match=null] Add an additional filter to the populate query. Can be a filter object containing [MongoDB query syntax](https://www.mongodb.com/docs/manual/tutorial/query-documents/), or a function that returns a filter object.\n * @param {Function} [options.transform=null] Function that Mongoose will call on every populated document that allows you to transform the populated document.\n * @param {Object} [options.options=null] Additional options like `limit` and `lean`.\n * @see population https://mongoosejs.com/docs/populate.html\n * @see Query#select https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @see Model.populate https://mongoosejs.com/docs/api/model.html#Model.populate()\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.populate = function() {\n  // Bail when given no truthy arguments\n  if (!Array.from(arguments).some(Boolean)) {\n    return this;\n  }\n\n  const res = utils.populate.apply(null, arguments);\n\n  // Propagate readConcern and readPreference and lean from parent query,\n  // unless one already specified\n  if (this.options != null) {\n    const readConcern = this.options.readConcern;\n    const readPref = this.options.readPreference;\n\n    for (const populateOptions of res) {\n      if (readConcern != null && (populateOptions && populateOptions.options && populateOptions.options.readConcern) == null) {\n        populateOptions.options = populateOptions.options || {};\n        populateOptions.options.readConcern = readConcern;\n      }\n      if (readPref != null && (populateOptions && populateOptions.options && populateOptions.options.readPreference) == null) {\n        populateOptions.options = populateOptions.options || {};\n        populateOptions.options.readPreference = readPref;\n      }\n    }\n  }\n\n  const opts = this._mongooseOptions;\n\n  if (opts.lean != null) {\n    const lean = opts.lean;\n    for (const populateOptions of res) {\n      if ((populateOptions && populateOptions.options && populateOptions.options.lean) == null) {\n        populateOptions.options = populateOptions.options || {};\n        populateOptions.options.lean = lean;\n      }\n    }\n  }\n\n  if (!utils.isObject(opts.populate)) {\n    opts.populate = {};\n  }\n\n  const pop = opts.populate;\n\n  for (const populateOptions of res) {\n    const path = populateOptions.path;\n    if (pop[path] && pop[path].populate && populateOptions.populate) {\n      populateOptions.populate = pop[path].populate.concat(populateOptions.populate);\n    }\n\n    pop[populateOptions.path] = populateOptions;\n  }\n  return this;\n};\n\n/**\n * Gets a list of paths to be populated by this query\n *\n * #### Example:\n *\n *      bookSchema.pre('findOne', function() {\n *        let keys = this.getPopulatedPaths(); // ['author']\n *      });\n *      ...\n *      Book.findOne({}).populate('author');\n *\n * #### Example:\n *\n *      // Deep populate\n *      const q = L1.find().populate({\n *        path: 'level2',\n *        populate: { path: 'level3' }\n *      });\n *      q.getPopulatedPaths(); // ['level2', 'level2.level3']\n *\n * @return {Array} an array of strings representing populated paths\n * @api public\n */\n\nQuery.prototype.getPopulatedPaths = function getPopulatedPaths() {\n  const obj = this._mongooseOptions.populate || {};\n  const ret = Object.keys(obj);\n  for (const path of Object.keys(obj)) {\n    const pop = obj[path];\n    if (!Array.isArray(pop.populate)) {\n      continue;\n    }\n    _getPopulatedPaths(ret, pop.populate, path + '.');\n  }\n  return ret;\n};\n\n/*!\n * ignore\n */\n\nfunction _getPopulatedPaths(list, arr, prefix) {\n  for (const pop of arr) {\n    list.push(prefix + pop.path);\n    if (!Array.isArray(pop.populate)) {\n      continue;\n    }\n    _getPopulatedPaths(list, pop.populate, prefix + pop.path + '.');\n  }\n}\n\n/**\n * Casts this query to the schema of `model`\n *\n * #### Note:\n *\n * If `obj` is present, it is cast instead of this query.\n *\n * @param {Model} [model] the model to cast to. If not set, defaults to `this.model`\n * @param {Object} [obj]\n * @return {Object}\n * @api public\n */\n\nQuery.prototype.cast = function(model, obj) {\n  obj || (obj = this._conditions);\n  model = model || this.model;\n  const discriminatorKey = model.schema.options.discriminatorKey;\n  if (obj != null &&\n      obj.hasOwnProperty(discriminatorKey)) {\n    model = getDiscriminatorByValue(model.discriminators, obj[discriminatorKey]) || model;\n  }\n\n  const opts = { upsert: this.options && this.options.upsert };\n  if (this.options) {\n    if ('strict' in this.options) {\n      opts.strict = this.options.strict;\n    }\n    if ('strictQuery' in this.options) {\n      opts.strictQuery = this.options.strictQuery;\n    }\n  }\n\n  try {\n    return cast(model.schema, obj, opts, this);\n  } catch (err) {\n    // CastError, assign model\n    if (typeof err.setModel === 'function') {\n      err.setModel(model);\n    }\n    throw err;\n  }\n};\n\n/**\n * Casts selected field arguments for field selection with mongo 2.2\n *\n *     query.select({ ids: { $elemMatch: { $in: [hexString] }})\n *\n * @param {Object} fields\n * @see https://github.com/Automattic/mongoose/issues/1091\n * @see https://www.mongodb.com/docs/manual/reference/projection/elemMatch/\n * @api private\n */\n\nQuery.prototype._castFields = function _castFields(fields) {\n  let selected,\n      elemMatchKeys,\n      keys,\n      key,\n      out;\n\n  if (fields) {\n    keys = Object.keys(fields);\n    elemMatchKeys = [];\n\n    // collect $elemMatch args\n    for (let i = 0; i < keys.length; ++i) {\n      key = keys[i];\n      if (fields[key].$elemMatch) {\n        selected || (selected = {});\n        selected[key] = fields[key];\n        elemMatchKeys.push(key);\n      }\n    }\n  }\n\n  if (selected) {\n    // they passed $elemMatch, cast em\n    try {\n      out = this.cast(this.model, selected);\n    } catch (err) {\n      return err;\n    }\n\n    // apply the casted field args\n    for (let i = 0; i < elemMatchKeys.length; ++i) {\n      key = elemMatchKeys[i];\n      fields[key] = out[key];\n    }\n  }\n\n  return fields;\n};\n\n/**\n * Applies schematype selected options to this query.\n * @api private\n */\n\nQuery.prototype._applyPaths = function applyPaths() {\n  if (!this.model) {\n    return;\n  }\n  this._fields = this._fields || {};\n  helpers.applyPaths(this._fields, this.model.schema);\n\n  let _selectPopulatedPaths = true;\n\n  if ('selectPopulatedPaths' in this.model.base.options) {\n    _selectPopulatedPaths = this.model.base.options.selectPopulatedPaths;\n  }\n  if ('selectPopulatedPaths' in this.model.schema.options) {\n    _selectPopulatedPaths = this.model.schema.options.selectPopulatedPaths;\n  }\n\n  if (_selectPopulatedPaths) {\n    selectPopulatedFields(this._fields, this._userProvidedFields, this._mongooseOptions.populate);\n  }\n};\n\n/**\n * Returns a wrapper around a [mongodb driver cursor](https://mongodb.github.io/node-mongodb-native/4.9/classes/FindCursor.html).\n * A QueryCursor exposes a Streams3 interface, as well as a `.next()` function.\n *\n * The `.cursor()` function triggers pre find hooks, but **not** post find hooks.\n *\n * #### Example:\n *\n *     // There are 2 ways to use a cursor. First, as a stream:\n *     Thing.\n *       find({ name: /^hello/ }).\n *       cursor().\n *       on('data', function(doc) { console.log(doc); }).\n *       on('end', function() { console.log('Done!'); });\n *\n *     // Or you can use `.next()` to manually get the next doc in the stream.\n *     // `.next()` returns a promise, so you can use promises or callbacks.\n *     const cursor = Thing.find({ name: /^hello/ }).cursor();\n *     cursor.next(function(error, doc) {\n *       console.log(doc);\n *     });\n *\n *     // Because `.next()` returns a promise, you can use co\n *     // to easily iterate through all documents without loading them\n *     // all into memory.\n *     const cursor = Thing.find({ name: /^hello/ }).cursor();\n *     for (let doc = await cursor.next(); doc != null; doc = await cursor.next()) {\n *       console.log(doc);\n *     }\n *\n * #### Valid options\n *\n *   - `transform`: optional function which accepts a mongoose document. The return value of the function will be emitted on `data` and returned by `.next()`.\n *\n * @return {QueryCursor}\n * @param {Object} [options]\n * @see QueryCursor https://mongoosejs.com/docs/api/querycursor.html\n * @api public\n */\n\nQuery.prototype.cursor = function cursor(opts) {\n  if (opts) {\n    this.setOptions(opts);\n  }\n\n  try {\n    this.cast(this.model);\n  } catch (err) {\n    return (new QueryCursor(this))._markError(err);\n  }\n\n  return new QueryCursor(this);\n};\n\n// the rest of these are basically to support older Mongoose syntax with mquery\n\n/**\n * Sets the tailable option (for use with capped collections).\n *\n * #### Example:\n *\n *     query.tailable(); // true\n *     query.tailable(true);\n *     query.tailable(false);\n *\n *     // Set both `tailable` and `awaitData` options\n *     query.tailable({ awaitData: true });\n *\n * #### Note:\n *\n * Cannot be used with `distinct()`\n *\n * @param {Boolean} bool defaults to true\n * @param {Object} [opts] options to set\n * @param {Boolean} [opts.awaitData] false by default. Set to true to keep the cursor open even if there's no data.\n * @param {Number} [opts.maxAwaitTimeMS] the maximum amount of time for the server to wait on new documents to satisfy a tailable cursor query. Requires `tailable` and `awaitData` to be true\n * @see tailable https://www.mongodb.com/docs/manual/tutorial/create-tailable-cursor/\n * @api public\n */\n\nQuery.prototype.tailable = function(val, opts) {\n  // we need to support the tailable({ awaitData : true }) as well as the\n  // tailable(true, {awaitData :true}) syntax that mquery does not support\n  if (val != null && typeof val.constructor === 'function' && val.constructor.name === 'Object') {\n    opts = val;\n    val = true;\n  }\n\n  if (val === undefined) {\n    val = true;\n  }\n\n  if (opts && typeof opts === 'object') {\n    for (const key of Object.keys(opts)) {\n      if (key === 'awaitData' || key === 'awaitdata') { // backwards compat, see gh-10875\n        // For backwards compatibility\n        this.options['awaitData'] = !!opts[key];\n      } else {\n        this.options[key] = opts[key];\n      }\n    }\n  }\n\n  this.options.tailable = arguments.length ? !!val : true;\n\n  return this;\n};\n\n/**\n * Declares an intersects query for `geometry()`.\n *\n * #### Example:\n *\n *     query.where('path').intersects().geometry({\n *       type: 'LineString',\n *       coordinates: [[180.0, 11.0], [180, 9.0]]\n *     });\n *\n *     query.where('path').intersects({\n *       type: 'LineString',\n *       coordinates: [[180.0, 11.0], [180, 9.0]]\n *     });\n *\n * #### Note:\n *\n * **MUST** be used after `where()`.\n *\n * #### Note:\n *\n * In Mongoose 3.7, `intersects` changed from a getter to a function. If you need the old syntax, use [this](https://github.com/ebensing/mongoose-within).\n *\n * @method intersects\n * @memberOf Query\n * @instance\n * @param {Object} [arg]\n * @return {Query} this\n * @see $geometry https://www.mongodb.com/docs/manual/reference/operator/geometry/\n * @see geoIntersects https://www.mongodb.com/docs/manual/reference/operator/geoIntersects/\n * @api public\n */\n\n/**\n * Specifies a `$geometry` condition\n *\n * #### Example:\n *\n *     const polyA = [[[ 10, 20 ], [ 10, 40 ], [ 30, 40 ], [ 30, 20 ]]]\n *     query.where('loc').within().geometry({ type: 'Polygon', coordinates: polyA })\n *\n *     // or\n *     const polyB = [[ 0, 0 ], [ 1, 1 ]]\n *     query.where('loc').within().geometry({ type: 'LineString', coordinates: polyB })\n *\n *     // or\n *     const polyC = [ 0, 0 ]\n *     query.where('loc').within().geometry({ type: 'Point', coordinates: polyC })\n *\n *     // or\n *     query.where('loc').intersects().geometry({ type: 'Point', coordinates: polyC })\n *\n * The argument is assigned to the most recent path passed to `where()`.\n *\n * #### Note:\n *\n * `geometry()` **must** come after either `intersects()` or `within()`.\n *\n * The `object` argument must contain `type` and `coordinates` properties.\n * - type {String}\n * - coordinates {Array}\n *\n * @method geometry\n * @memberOf Query\n * @instance\n * @param {Object} object Must contain a `type` property which is a String and a `coordinates` property which is an Array. See the examples.\n * @return {Query} this\n * @see $geometry https://www.mongodb.com/docs/manual/reference/operator/geometry/\n * @see Geospatial Support Enhancements https://www.mongodb.com/docs/manual/release-notes/2.4/#geospatial-support-enhancements\n * @see MongoDB Geospatial Indexing https://www.mongodb.com/docs/manual/core/geospatial-indexes/\n * @api public\n */\n\n/**\n * Specifies a `$near` or `$nearSphere` condition\n *\n * These operators return documents sorted by distance.\n *\n * #### Example:\n *\n *     query.where('loc').near({ center: [10, 10] });\n *     query.where('loc').near({ center: [10, 10], maxDistance: 5 });\n *     query.where('loc').near({ center: [10, 10], maxDistance: 5, spherical: true });\n *     query.near('loc', { center: [10, 10], maxDistance: 5 });\n *\n * @method near\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Object} val\n * @return {Query} this\n * @see $near https://www.mongodb.com/docs/manual/reference/operator/near/\n * @see $nearSphere https://www.mongodb.com/docs/manual/reference/operator/nearSphere/\n * @see $maxDistance https://www.mongodb.com/docs/manual/reference/operator/maxDistance/\n * @see MongoDB Geospatial Indexing https://www.mongodb.com/docs/manual/core/geospatial-indexes/\n * @api public\n */\n\n/**\n * Overwriting mquery is needed to support a couple different near() forms found in older\n * versions of mongoose\n * near([1,1])\n * near(1,1)\n * near(field, [1,2])\n * near(field, 1, 2)\n * In addition to all of the normal forms supported by mquery\n *\n * @method near\n * @memberOf Query\n * @instance\n * @api private\n */\n\nQuery.prototype.near = function() {\n  const params = [];\n  const sphere = this._mongooseOptions.nearSphere;\n\n  // TODO refactor\n\n  if (arguments.length === 1) {\n    if (Array.isArray(arguments[0])) {\n      params.push({ center: arguments[0], spherical: sphere });\n    } else if (typeof arguments[0] === 'string') {\n      // just passing a path\n      params.push(arguments[0]);\n    } else if (utils.isObject(arguments[0])) {\n      if (typeof arguments[0].spherical !== 'boolean') {\n        arguments[0].spherical = sphere;\n      }\n      params.push(arguments[0]);\n    } else {\n      throw new TypeError('invalid argument');\n    }\n  } else if (arguments.length === 2) {\n    if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {\n      params.push({ center: [arguments[0], arguments[1]], spherical: sphere });\n    } else if (typeof arguments[0] === 'string' && Array.isArray(arguments[1])) {\n      params.push(arguments[0]);\n      params.push({ center: arguments[1], spherical: sphere });\n    } else if (typeof arguments[0] === 'string' && utils.isObject(arguments[1])) {\n      params.push(arguments[0]);\n      if (typeof arguments[1].spherical !== 'boolean') {\n        arguments[1].spherical = sphere;\n      }\n      params.push(arguments[1]);\n    } else {\n      throw new TypeError('invalid argument');\n    }\n  } else if (arguments.length === 3) {\n    if (typeof arguments[0] === 'string' && typeof arguments[1] === 'number'\n        && typeof arguments[2] === 'number') {\n      params.push(arguments[0]);\n      params.push({ center: [arguments[1], arguments[2]], spherical: sphere });\n    } else {\n      throw new TypeError('invalid argument');\n    }\n  } else {\n    throw new TypeError('invalid argument');\n  }\n\n  return Query.base.near.apply(this, params);\n};\n\n/**\n * _DEPRECATED_ Specifies a `$nearSphere` condition\n *\n * #### Example:\n *\n *     query.where('loc').nearSphere({ center: [10, 10], maxDistance: 5 });\n *\n * **Deprecated.** Use `query.near()` instead with the `spherical` option set to `true`.\n *\n * #### Example:\n *\n *     query.where('loc').near({ center: [10, 10], spherical: true });\n *\n * @deprecated\n * @see near() https://mongoosejs.com/docs/api/query.html#Query.prototype.near()\n * @see $near https://www.mongodb.com/docs/manual/reference/operator/near/\n * @see $nearSphere https://www.mongodb.com/docs/manual/reference/operator/nearSphere/\n * @see $maxDistance https://www.mongodb.com/docs/manual/reference/operator/maxDistance/\n */\n\nQuery.prototype.nearSphere = function() {\n  this._mongooseOptions.nearSphere = true;\n  this.near.apply(this, arguments);\n  return this;\n};\n\n/**\n * Returns an asyncIterator for use with [`for/await/of` loops](https://thecodebarbarian.com/getting-started-with-async-iterators-in-node-js)\n * This function *only* works for `find()` queries.\n * You do not need to call this function explicitly, the JavaScript runtime\n * will call it for you.\n *\n * #### Example:\n *\n *     for await (const doc of Model.aggregate([{ $sort: { name: 1 } }])) {\n *       console.log(doc.name);\n *     }\n *\n * Node.js 10.x supports async iterators natively without any flags. You can\n * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\n *\n * **Note:** This function is not if `Symbol.asyncIterator` is undefined. If\n * `Symbol.asyncIterator` is undefined, that means your Node.js version does not\n * support async iterators.\n *\n * @method [Symbol.asyncIterator]\n * @memberOf Query\n * @instance\n * @api public\n */\n\nif (Symbol.asyncIterator != null) {\n  Query.prototype[Symbol.asyncIterator] = function() {\n    return this.cursor().transformNull()._transformForAsyncIterator();\n  };\n}\n\n/**\n * Specifies a `$polygon` condition\n *\n * #### Example:\n *\n *     query.where('loc').within().polygon([10, 20], [13, 25], [7, 15]);\n *     query.polygon('loc', [10, 20], [13, 25], [7, 15]);\n *\n * @method polygon\n * @memberOf Query\n * @instance\n * @param {String|Array} [path]\n * @param {...Array|Object} [coordinatePairs]\n * @return {Query} this\n * @see $polygon https://www.mongodb.com/docs/manual/reference/operator/polygon/\n * @see MongoDB Geospatial Indexing https://www.mongodb.com/docs/manual/core/geospatial-indexes/\n * @api public\n */\n\n/**\n * Specifies a `$box` condition\n *\n * #### Example:\n *\n *     const lowerLeft = [40.73083, -73.99756]\n *     const upperRight= [40.741404,  -73.988135]\n *\n *     query.where('loc').within().box(lowerLeft, upperRight)\n *     query.box({ ll : lowerLeft, ur : upperRight })\n *\n * @method box\n * @memberOf Query\n * @instance\n * @see $box https://www.mongodb.com/docs/manual/reference/operator/box/\n * @see within() Query#within https://mongoosejs.com/docs/api/query.html#Query.prototype.within()\n * @see MongoDB Geospatial Indexing https://www.mongodb.com/docs/manual/core/geospatial-indexes/\n * @param {Object|Array<Number>} val1 Lower Left Coordinates OR a object of lower-left(ll) and upper-right(ur) Coordinates\n * @param {Array<Number>} [val2] Upper Right Coordinates\n * @return {Query} this\n * @api public\n */\n\n/**\n * this is needed to support the mongoose syntax of:\n * box(field, { ll : [x,y], ur : [x2,y2] })\n * box({ ll : [x,y], ur : [x2,y2] })\n *\n * @method box\n * @memberOf Query\n * @instance\n * @api private\n */\n\nQuery.prototype.box = function(ll, ur) {\n  if (!Array.isArray(ll) && utils.isObject(ll)) {\n    ur = ll.ur;\n    ll = ll.ll;\n  }\n  return Query.base.box.call(this, ll, ur);\n};\n\n/**\n * Specifies a `$center` or `$centerSphere` condition.\n *\n * #### Example:\n *\n *     const area = { center: [50, 50], radius: 10, unique: true }\n *     query.where('loc').within().circle(area)\n *     // alternatively\n *     query.circle('loc', area);\n *\n *     // spherical calculations\n *     const area = { center: [50, 50], radius: 10, unique: true, spherical: true }\n *     query.where('loc').within().circle(area)\n *     // alternatively\n *     query.circle('loc', area);\n *\n * @method circle\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Object} area\n * @return {Query} this\n * @see $center https://www.mongodb.com/docs/manual/reference/operator/center/\n * @see $centerSphere https://www.mongodb.com/docs/manual/reference/operator/centerSphere/\n * @see $geoWithin https://www.mongodb.com/docs/manual/reference/operator/geoWithin/\n * @see MongoDB Geospatial Indexing https://www.mongodb.com/docs/manual/core/geospatial-indexes/\n * @api public\n */\n\n/**\n * _DEPRECATED_ Alias for [circle](https://mongoosejs.com/docs/api/query.html#Query.prototype.circle())\n *\n * **Deprecated.** Use [circle](https://mongoosejs.com/docs/api/query.html#Query.prototype.circle()) instead.\n *\n * @deprecated\n * @method center\n * @memberOf Query\n * @instance\n * @api public\n */\n\nQuery.prototype.center = Query.base.circle;\n\n/**\n * _DEPRECATED_ Specifies a `$centerSphere` condition\n *\n * **Deprecated.** Use [circle](https://mongoosejs.com/docs/api/query.html#Query.prototype.circle()) instead.\n *\n * #### Example:\n *\n *     const area = { center: [50, 50], radius: 10 };\n *     query.where('loc').within().centerSphere(area);\n *\n * @deprecated\n * @param {String} [path]\n * @param {Object} val\n * @return {Query} this\n * @see MongoDB Geospatial Indexing https://www.mongodb.com/docs/manual/core/geospatial-indexes/\n * @see $centerSphere https://www.mongodb.com/docs/manual/reference/operator/centerSphere/\n * @api public\n */\n\nQuery.prototype.centerSphere = function() {\n  if (arguments[0] != null && typeof arguments[0].constructor === 'function' && arguments[0].constructor.name === 'Object') {\n    arguments[0].spherical = true;\n  }\n\n  if (arguments[1] != null && typeof arguments[1].constructor === 'function' && arguments[1].constructor.name === 'Object') {\n    arguments[1].spherical = true;\n  }\n\n  Query.base.circle.apply(this, arguments);\n};\n\n/**\n * Determines if field selection has been made.\n *\n * @method selected\n * @memberOf Query\n * @instance\n * @return {Boolean}\n * @api public\n */\n\n/**\n * Determines if inclusive field selection has been made.\n *\n *     query.selectedInclusively(); // false\n *     query.select('name');\n *     query.selectedInclusively(); // true\n *\n * @method selectedInclusively\n * @memberOf Query\n * @instance\n * @return {Boolean}\n * @api public\n */\n\nQuery.prototype.selectedInclusively = function selectedInclusively() {\n  return isInclusive(this._fields);\n};\n\n/**\n * Determines if exclusive field selection has been made.\n *\n *     query.selectedExclusively(); // false\n *     query.select('-name');\n *     query.selectedExclusively(); // true\n *     query.selectedInclusively(); // false\n *\n * @method selectedExclusively\n * @memberOf Query\n * @instance\n * @return {Boolean}\n * @api public\n */\n\nQuery.prototype.selectedExclusively = function selectedExclusively() {\n  return isExclusive(this._fields);\n};\n\n/**\n * The model this query is associated with.\n *\n * #### Example:\n *\n *     const q = MyModel.find();\n *     q.model === MyModel; // true\n *\n * @api public\n * @property model\n * @memberOf Query\n * @instance\n */\n\nQuery.prototype.model;\n\n/*!\n * Export\n */\n\nmodule.exports = Query;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3F1ZXJ5LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsbUJBQU8sQ0FBQyx3RUFBYztBQUN4Qyw4QkFBOEIsbUJBQU8sQ0FBQyxnRkFBa0I7QUFDeEQsZUFBZSxtQkFBTyxDQUFDLHVEQUFRO0FBQy9CLHNCQUFzQixtQkFBTyxDQUFDLDBGQUF1QjtBQUNyRCw2QkFBNkIsbUJBQU8sQ0FBQyw4RkFBeUI7QUFDOUQsb0JBQW9CLG1CQUFPLENBQUMsd0ZBQXNCO0FBQ2xELHdCQUF3QixtQkFBTyxDQUFDLG9GQUFvQjtBQUNwRCxRQUFRLDJDQUEyQyxFQUFFLG1CQUFPLENBQUMsa0hBQW1DO0FBQ2hHLG9DQUFvQyxtQkFBTyxDQUFDLHNJQUE2QztBQUN6RiwwQkFBMEIsbUJBQU8sQ0FBQyxvSEFBb0M7QUFDdEUsYUFBYSxtQkFBTyxDQUFDLDREQUFRO0FBQzdCLHlCQUF5QixtQkFBTyxDQUFDLGtIQUFtQztBQUNwRSxtQkFBbUIsbUJBQU8sQ0FBQywwRUFBZTtBQUMxQyxtQkFBbUIsbUJBQU8sQ0FBQyxvR0FBNEI7QUFDdkQsY0FBYyxtQkFBTyxDQUFDLDhFQUFpQjtBQUN2QyxnQ0FBZ0MsbUJBQU8sQ0FBQyw4SUFBaUQ7QUFDekYsZ0JBQWdCLG1CQUFPLENBQUMsNEVBQWdCO0FBQ3hDLGtCQUFrQixtQkFBTyxDQUFDLHNGQUFxQjtBQUMvQyxnQ0FBZ0MsaUhBQTRDO0FBQzVFLG9CQUFvQixtQkFBTyxDQUFDLGdIQUFrQztBQUM5RCxvQkFBb0IsbUJBQU8sQ0FBQyxnSEFBa0M7QUFDOUQsZ0NBQWdDLG1CQUFPLENBQUMsd0lBQThDO0FBQ3RGLGtCQUFrQixtQkFBTyxDQUFDLDRHQUFnQztBQUMxRCxjQUFjLG1CQUFPLENBQUMscURBQU87QUFDN0IsZUFBZSxtQkFBTyxDQUFDLDREQUFRO0FBQy9CLHdCQUF3QixtQkFBTyxDQUFDLHdIQUFzQztBQUN0RSxpQ0FB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0EsZUFBZTtBQUNmOztBQUVBLGtDQUFrQztBQUNsQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMs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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3F1ZXJ5LmpzPzFjNWQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgQ2FzdEVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9jYXN0Jyk7XG5jb25zdCBEb2N1bWVudE5vdEZvdW5kRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL25vdEZvdW5kJyk7XG5jb25zdCBLYXJlZW0gPSByZXF1aXJlKCdrYXJlZW0nKTtcbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yL21vbmdvb3NlRXJyb3InKTtcbmNvbnN0IE9iamVjdFBhcmFtZXRlckVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9vYmplY3RQYXJhbWV0ZXInKTtcbmNvbnN0IFF1ZXJ5Q3Vyc29yID0gcmVxdWlyZSgnLi9jdXJzb3IvcXVlcnlDdXJzb3InKTtcbmNvbnN0IFZhbGlkYXRpb25FcnJvciA9IHJlcXVpcmUoJy4vZXJyb3IvdmFsaWRhdGlvbicpO1xuY29uc3QgeyBhcHBseUdsb2JhbE1heFRpbWVNUywgYXBwbHlHbG9iYWxEaXNrVXNlIH0gPSByZXF1aXJlKCcuL2hlbHBlcnMvcXVlcnkvYXBwbHlHbG9iYWxPcHRpb24nKTtcbmNvbnN0IGhhbmRsZVJlYWRQcmVmZXJlbmNlQWxpYXNlcyA9IHJlcXVpcmUoJy4vaGVscGVycy9xdWVyeS9oYW5kbGVSZWFkUHJlZmVyZW5jZUFsaWFzZXMnKTtcbmNvbnN0IGFwcGx5V3JpdGVDb25jZXJuID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NjaGVtYS9hcHBseVdyaXRlQ29uY2VybicpO1xuY29uc3QgY2FzdCA9IHJlcXVpcmUoJy4vY2FzdCcpO1xuY29uc3QgY2FzdEFycmF5RmlsdGVycyA9IHJlcXVpcmUoJy4vaGVscGVycy91cGRhdGUvY2FzdEFycmF5RmlsdGVycycpO1xuY29uc3QgY2FzdE51bWJlciA9IHJlcXVpcmUoJy4vY2FzdC9udW1iZXInKTtcbmNvbnN0IGNhc3RVcGRhdGUgPSByZXF1aXJlKCcuL2hlbHBlcnMvcXVlcnkvY2FzdFVwZGF0ZScpO1xuY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuL2hlbHBlcnMvY2xvbmUnKTtcbmNvbnN0IGdldERpc2NyaW1pbmF0b3JCeVZhbHVlID0gcmVxdWlyZSgnLi9oZWxwZXJzL2Rpc2NyaW1pbmF0b3IvZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUnKTtcbmNvbnN0IGhlbHBlcnMgPSByZXF1aXJlKCcuL3F1ZXJ5SGVscGVycycpO1xuY29uc3QgaW1tZWRpYXRlID0gcmVxdWlyZSgnLi9oZWxwZXJzL2ltbWVkaWF0ZScpO1xuY29uc3QgaW50ZXJuYWxUb09iamVjdE9wdGlvbnMgPSByZXF1aXJlKCcuL29wdGlvbnMnKS5pbnRlcm5hbFRvT2JqZWN0T3B0aW9ucztcbmNvbnN0IGlzRXhjbHVzaXZlID0gcmVxdWlyZSgnLi9oZWxwZXJzL3Byb2plY3Rpb24vaXNFeGNsdXNpdmUnKTtcbmNvbnN0IGlzSW5jbHVzaXZlID0gcmVxdWlyZSgnLi9oZWxwZXJzL3Byb2plY3Rpb24vaXNJbmNsdXNpdmUnKTtcbmNvbnN0IGlzUGF0aFNlbGVjdGVkSW5jbHVzaXZlID0gcmVxdWlyZSgnLi9oZWxwZXJzL3Byb2plY3Rpb24vaXNQYXRoU2VsZWN0ZWRJbmNsdXNpdmUnKTtcbmNvbnN0IGlzU3VicGF0aCA9IHJlcXVpcmUoJy4vaGVscGVycy9wcm9qZWN0aW9uL2lzU3VicGF0aCcpO1xuY29uc3QgbXBhdGggPSByZXF1aXJlKCdtcGF0aCcpO1xuY29uc3QgbXF1ZXJ5ID0gcmVxdWlyZSgnbXF1ZXJ5Jyk7XG5jb25zdCBwYXJzZVByb2plY3Rpb24gPSByZXF1aXJlKCcuL2hlbHBlcnMvcHJvamVjdGlvbi9wYXJzZVByb2plY3Rpb24nKTtcbmNvbnN0IHJlbW92ZVVudXNlZEFycmF5RmlsdGVycyA9IHJlcXVpcmUoJy4vaGVscGVycy91cGRhdGUvcmVtb3ZlVW51c2VkQXJyYXlGaWx0ZXJzJyk7XG5jb25zdCBzYW5pdGl6ZUZpbHRlciA9IHJlcXVpcmUoJy4vaGVscGVycy9xdWVyeS9zYW5pdGl6ZUZpbHRlcicpO1xuY29uc3Qgc2FuaXRpemVQcm9qZWN0aW9uID0gcmVxdWlyZSgnLi9oZWxwZXJzL3F1ZXJ5L3Nhbml0aXplUHJvamVjdGlvbicpO1xuY29uc3Qgc2VsZWN0UG9wdWxhdGVkRmllbGRzID0gcmVxdWlyZSgnLi9oZWxwZXJzL3F1ZXJ5L3NlbGVjdFBvcHVsYXRlZEZpZWxkcycpO1xuY29uc3Qgc2V0RGVmYXVsdHNPbkluc2VydCA9IHJlcXVpcmUoJy4vaGVscGVycy9zZXREZWZhdWx0c09uSW5zZXJ0Jyk7XG5jb25zdCBzcGVjaWFsUHJvcGVydGllcyA9IHJlcXVpcmUoJy4vaGVscGVycy9zcGVjaWFsUHJvcGVydGllcycpO1xuY29uc3QgdXBkYXRlVmFsaWRhdG9ycyA9IHJlcXVpcmUoJy4vaGVscGVycy91cGRhdGVWYWxpZGF0b3JzJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCBxdWVyeU1pZGRsZXdhcmVGdW5jdGlvbnMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpLnF1ZXJ5TWlkZGxld2FyZUZ1bmN0aW9ucztcblxuY29uc3QgcXVlcnlPcHRpb25NZXRob2RzID0gbmV3IFNldChbXG4gICdhbGxvd0Rpc2tVc2UnLFxuICAnYmF0Y2hTaXplJyxcbiAgJ2NvbGxhdGlvbicsXG4gICdjb21tZW50JyxcbiAgJ2V4cGxhaW4nLFxuICAnaGludCcsXG4gICdqJyxcbiAgJ2xlYW4nLFxuICAnbGltaXQnLFxuICAnbWF4VGltZU1TJyxcbiAgJ3BvcHVsYXRlJyxcbiAgJ3Byb2plY3Rpb24nLFxuICAncmVhZCcsXG4gICdzZWxlY3QnLFxuICAnc2tpcCcsXG4gICdzbGljZScsXG4gICdzb3J0JyxcbiAgJ3RhaWxhYmxlJyxcbiAgJ3cnLFxuICAnd3JpdGVDb25jZXJuJyxcbiAgJ3d0aW1lb3V0J1xuXSk7XG5cbi8qKlxuICogUXVlcnkgY29uc3RydWN0b3IgdXNlZCBmb3IgYnVpbGRpbmcgcXVlcmllcy4gWW91IGRvIG5vdCBuZWVkXG4gKiB0byBpbnN0YW50aWF0ZSBhIGBRdWVyeWAgZGlyZWN0bHkuIEluc3RlYWQgdXNlIE1vZGVsIGZ1bmN0aW9ucyBsaWtlXG4gKiBbYE1vZGVsLmZpbmQoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbC5maW5kKCkpLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcXVlcnkgPSBNeU1vZGVsLmZpbmQoKTsgLy8gYHF1ZXJ5YCBpcyBhbiBpbnN0YW5jZSBvZiBgUXVlcnlgXG4gKiAgICAgcXVlcnkuc2V0T3B0aW9ucyh7IGxlYW4gOiB0cnVlIH0pO1xuICogICAgIHF1ZXJ5LmNvbGxlY3Rpb24oTXlNb2RlbC5jb2xsZWN0aW9uKTtcbiAqICAgICBxdWVyeS53aGVyZSgnYWdlJykuZ3RlKDIxKS5leGVjKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgLy8gWW91IGNhbiBpbnN0YW50aWF0ZSBhIHF1ZXJ5IGRpcmVjdGx5LiBUaGVyZSBpcyBubyBuZWVkIHRvIGRvXG4gKiAgICAgLy8gdGhpcyB1bmxlc3MgeW91J3JlIGFuIGFkdmFuY2VkIHVzZXIgd2l0aCBhIHZlcnkgZ29vZCByZWFzb24gdG8uXG4gKiAgICAgY29uc3QgcXVlcnkgPSBuZXcgbW9uZ29vc2UuUXVlcnkoKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge09iamVjdH0gW21vZGVsXVxuICogQHBhcmFtIHtPYmplY3R9IFtjb25kaXRpb25zXVxuICogQHBhcmFtIHtPYmplY3R9IFtjb2xsZWN0aW9uXSBNb25nb29zZSBjb2xsZWN0aW9uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFF1ZXJ5KGNvbmRpdGlvbnMsIG9wdGlvbnMsIG1vZGVsLCBjb2xsZWN0aW9uKSB7XG4gIC8vIHRoaXMgc3R1ZmYgaXMgZm9yIGRlYWxpbmcgd2l0aCBjdXN0b20gcXVlcmllcyBjcmVhdGVkIGJ5ICN0b0NvbnN0cnVjdG9yXG4gIGlmICghdGhpcy5fbW9uZ29vc2VPcHRpb25zKSB7XG4gICAgdGhpcy5fbW9uZ29vc2VPcHRpb25zID0ge307XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdGhpcy5fdHJhbnNmb3JtcyA9IFtdO1xuICB0aGlzLl9ob29rcyA9IG5ldyBLYXJlZW0oKTtcbiAgdGhpcy5fZXhlY3V0aW9uU3RhY2sgPSBudWxsO1xuXG4gIC8vIHRoaXMgaXMgdGhlIGNhc2Ugd2hlcmUgd2UgaGF2ZSBhIEN1c3RvbVF1ZXJ5LCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGdvdFxuICAvLyBvcHRpb25zIHBhc3NlZCBpbiwgYW5kIGlmIHdlIGRpZCwgbWVyZ2UgdGhlbSBpblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyk7XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICB0aGlzLl9tb25nb29zZU9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgfVxuXG4gIGlmIChjb2xsZWN0aW9uKSB7XG4gICAgdGhpcy5tb25nb29zZUNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuICB9XG5cbiAgaWYgKG1vZGVsKSB7XG4gICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgIHRoaXMuc2NoZW1hID0gbW9kZWwuc2NoZW1hO1xuICB9XG5cbiAgLy8gdGhpcyBpcyBuZWVkZWQgYmVjYXVzZSBtYXAgcmVkdWNlIHJldHVybnMgYSBtb2RlbCB0aGF0IGNhbiBiZSBxdWVyaWVkLCBidXRcbiAgLy8gYWxsIG9mIHRoZSBxdWVyaWVzIG9uIHNhaWQgbW9kZWwgc2hvdWxkIGJlIGxlYW5cbiAgaWYgKHRoaXMubW9kZWwgJiYgdGhpcy5tb2RlbC5fbWFwcmVkdWNlKSB7XG4gICAgdGhpcy5sZWFuKCk7XG4gIH1cblxuICAvLyBpbmhlcml0IG1xdWVyeVxuICBtcXVlcnkuY2FsbCh0aGlzLCBudWxsLCBvcHRpb25zKTtcbiAgaWYgKGNvbGxlY3Rpb24pIHtcbiAgICB0aGlzLmNvbGxlY3Rpb24oY29sbGVjdGlvbik7XG4gIH1cblxuICBpZiAoY29uZGl0aW9ucykge1xuICAgIHRoaXMuZmluZChjb25kaXRpb25zKTtcbiAgfVxuXG4gIHRoaXMub3B0aW9ucyA9IHRoaXMub3B0aW9ucyB8fCB7fTtcblxuICAvLyBGb3IgZ2gtNjg4MC4gbXF1ZXJ5IHN0aWxsIG5lZWRzIHRvIHN1cHBvcnQgYGZpZWxkc2AgYnkgZGVmYXVsdCBmb3Igb2xkXG4gIC8vIHZlcnNpb25zIG9mIE1vbmdvREJcbiAgdGhpcy4kdXNlUHJvamVjdGlvbiA9IHRydWU7XG5cbiAgY29uc3QgY29sbGF0aW9uID0gdGhpcyAmJlxuICAgIHRoaXMuc2NoZW1hICYmXG4gICAgdGhpcy5zY2hlbWEub3B0aW9ucyAmJlxuICAgIHRoaXMuc2NoZW1hLm9wdGlvbnMuY29sbGF0aW9uIHx8IG51bGw7XG4gIGlmIChjb2xsYXRpb24gIT0gbnVsbCkge1xuICAgIHRoaXMub3B0aW9ucy5jb2xsYXRpb24gPSBjb2xsYXRpb247XG4gIH1cbn1cblxuLyohXG4gKiBpbmhlcml0IG1xdWVyeVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZSA9IG5ldyBtcXVlcnkoKTtcblF1ZXJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFF1ZXJ5O1xuUXVlcnkuYmFzZSA9IG1xdWVyeS5wcm90b3R5cGU7XG5cbi8qIVxuICogT3ZlcndyaXRlIG1xdWVyeSdzIGBfZGlzdGluY3RgLCBiZWNhdXNlIE1vbmdvb3NlIHVzZXMgdGhhdCBuYW1lXG4gKiB0byBzdG9yZSB0aGUgZmllbGQgdG8gYXBwbHkgZGlzdGluY3Qgb24uXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFF1ZXJ5LnByb3RvdHlwZSwgJ19kaXN0aW5jdCcsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHVuZGVmaW5lZFxufSk7XG5cbi8qKlxuICogRmxhZyB0byBvcHQgb3V0IG9mIHVzaW5nIGAkZ2VvV2l0aGluYC5cbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBtb25nb29zZS5RdWVyeS51c2UkZ2VvV2l0aGluID0gZmFsc2U7XG4gKiBgYGBcbiAqXG4gKiBNb25nb0RCIDIuNCBkZXByZWNhdGVkIHRoZSB1c2Ugb2YgYCR3aXRoaW5gLCByZXBsYWNpbmcgaXQgd2l0aCBgJGdlb1dpdGhpbmAuIE1vbmdvb3NlIHVzZXMgYCRnZW9XaXRoaW5gIGJ5IGRlZmF1bHQgKHdoaWNoIGlzIDEwMCUgYmFja3dhcmQgY29tcGF0aWJsZSB3aXRoIGAkd2l0aGluYCkuIElmIHlvdSBhcmUgcnVubmluZyBhbiBvbGRlciB2ZXJzaW9uIG9mIE1vbmdvREIsIHNldCB0aGlzIGZsYWcgdG8gYGZhbHNlYCBzbyB5b3VyIGB3aXRoaW4oKWAgcXVlcmllcyBjb250aW51ZSB0byB3b3JrLlxuICpcbiAqIEBzZWUgZ2VvV2l0aGluIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9nZW9XaXRoaW4vXG4gKiBAZGVmYXVsdCB0cnVlXG4gKiBAcHJvcGVydHkgdXNlJGdlb1dpdGhpblxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnVzZSRnZW9XaXRoaW4gPSBtcXVlcnkudXNlJGdlb1dpdGhpbjtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIHF1ZXJ5IHRvIGEgY3VzdG9taXplZCwgcmV1c2FibGUgcXVlcnkgY29uc3RydWN0b3Igd2l0aCBhbGwgYXJndW1lbnRzIGFuZCBvcHRpb25zIHJldGFpbmVkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gQ3JlYXRlIGEgcXVlcnkgZm9yIGFkdmVudHVyZSBtb3ZpZXMgYW5kIHJlYWQgZnJvbSB0aGUgcHJpbWFyeVxuICogICAgIC8vIG5vZGUgaW4gdGhlIHJlcGxpY2Etc2V0IHVubGVzcyBpdCBpcyBkb3duLCBpbiB3aGljaCBjYXNlIHdlJ2xsXG4gKiAgICAgLy8gcmVhZCBmcm9tIGEgc2Vjb25kYXJ5IG5vZGUuXG4gKiAgICAgY29uc3QgcXVlcnkgPSBNb3ZpZS5maW5kKHsgdGFnczogJ2FkdmVudHVyZScgfSkucmVhZCgncHJpbWFyeVByZWZlcnJlZCcpO1xuICpcbiAqICAgICAvLyBjcmVhdGUgYSBjdXN0b20gUXVlcnkgY29uc3RydWN0b3IgYmFzZWQgb2ZmIHRoZXNlIHNldHRpbmdzXG4gKiAgICAgY29uc3QgQWR2ZW50dXJlID0gcXVlcnkudG9Db25zdHJ1Y3RvcigpO1xuICpcbiAqICAgICAvLyBmdXJ0aGVyIG5hcnJvdyBkb3duIG91ciBxdWVyeSByZXN1bHRzIHdoaWxlIHN0aWxsIHVzaW5nIHRoZSBwcmV2aW91cyBzZXR0aW5nc1xuICogICAgIGF3YWl0IEFkdmVudHVyZSgpLndoZXJlKHsgbmFtZTogL15MaWZlLyB9KS5leGVjKCk7XG4gKlxuICogICAgIC8vIHNpbmNlIEFkdmVudHVyZSBpcyBhIHN0YW5kLWFsb25lIGNvbnN0cnVjdG9yIHdlIGNhbiBhbHNvIGFkZCBvdXIgb3duXG4gKiAgICAgLy8gaGVscGVyIG1ldGhvZHMgYW5kIGdldHRlcnMgd2l0aG91dCBpbXBhY3RpbmcgZ2xvYmFsIHF1ZXJpZXNcbiAqICAgICBBZHZlbnR1cmUucHJvdG90eXBlLnN0YXJ0c1dpdGggPSBmdW5jdGlvbiAocHJlZml4KSB7XG4gKiAgICAgICB0aGlzLndoZXJlKHsgbmFtZTogbmV3IFJlZ0V4cCgnXicgKyBwcmVmaXgpIH0pXG4gKiAgICAgICByZXR1cm4gdGhpcztcbiAqICAgICB9XG4gKiAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFkdmVudHVyZS5wcm90b3R5cGUsICdoaWdobHlSYXRlZCcsIHtcbiAqICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICogICAgICAgICB0aGlzLndoZXJlKHsgcmF0aW5nOiB7ICRndDogNC41IH19KTtcbiAqICAgICAgICAgcmV0dXJuIHRoaXM7XG4gKiAgICAgICB9XG4gKiAgICAgfSlcbiAqICAgICBhd2FpdCBBZHZlbnR1cmUoKS5oaWdobHlSYXRlZC5zdGFydHNXaXRoKCdMaWZlJykuZXhlYygpO1xuICpcbiAqIEByZXR1cm4ge1F1ZXJ5fSBzdWJjbGFzcy1vZi1RdWVyeVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUudG9Db25zdHJ1Y3RvciA9IGZ1bmN0aW9uIHRvQ29uc3RydWN0b3IoKSB7XG4gIGNvbnN0IG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgY29uc3QgY29sbCA9IHRoaXMubW9uZ29vc2VDb2xsZWN0aW9uO1xuXG4gIGNvbnN0IEN1c3RvbVF1ZXJ5ID0gZnVuY3Rpb24oY3JpdGVyaWEsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ3VzdG9tUXVlcnkpKSB7XG4gICAgICByZXR1cm4gbmV3IEN1c3RvbVF1ZXJ5KGNyaXRlcmlhLCBvcHRpb25zKTtcbiAgICB9XG4gICAgdGhpcy5fbW9uZ29vc2VPcHRpb25zID0gY2xvbmUocC5fbW9uZ29vc2VPcHRpb25zKTtcbiAgICBRdWVyeS5jYWxsKHRoaXMsIGNyaXRlcmlhLCBvcHRpb25zIHx8IG51bGwsIG1vZGVsLCBjb2xsKTtcbiAgfTtcblxuICB1dGlsLmluaGVyaXRzKEN1c3RvbVF1ZXJ5LCBtb2RlbC5RdWVyeSk7XG5cbiAgLy8gc2V0IGluaGVyaXRlZCBkZWZhdWx0c1xuICBjb25zdCBwID0gQ3VzdG9tUXVlcnkucHJvdG90eXBlO1xuXG4gIHAub3B0aW9ucyA9IHt9O1xuXG4gIC8vIE5lZWQgdG8gaGFuZGxlIGBzb3J0KClgIHNlcGFyYXRlbHkgYmVjYXVzZSBlbnRyaWVzLXN0eWxlIGBzb3J0KClgIHN5bnRheFxuICAvLyBgc29ydChbWydwcm9wMScsIDFdXSlgIGNvbmZ1c2VzIG1xdWVyeSBpbnRvIGxvc2luZyB0aGUgb3V0ZXIgbmVzdGVkIGFycmF5LlxuICAvLyBTZWUgZ2gtODE1OVxuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zKTtcbiAgaWYgKG9wdGlvbnMuc29ydCAhPSBudWxsKSB7XG4gICAgcC5zb3J0KG9wdGlvbnMuc29ydCk7XG4gICAgZGVsZXRlIG9wdGlvbnMuc29ydDtcbiAgfVxuICBwLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgcC5vcCA9IHRoaXMub3A7XG4gIHAuX3ZhbGlkYXRlT3AoKTtcbiAgcC5fY29uZGl0aW9ucyA9IGNsb25lKHRoaXMuX2NvbmRpdGlvbnMpO1xuICBwLl9maWVsZHMgPSBjbG9uZSh0aGlzLl9maWVsZHMpO1xuICBwLl91cGRhdGUgPSBjbG9uZSh0aGlzLl91cGRhdGUsIHtcbiAgICBmbGF0dGVuRGVjaW1hbHM6IGZhbHNlXG4gIH0pO1xuICBwLl9wYXRoID0gdGhpcy5fcGF0aDtcbiAgcC5fZGlzdGluY3QgPSB0aGlzLl9kaXN0aW5jdDtcbiAgcC5fY29sbGVjdGlvbiA9IHRoaXMuX2NvbGxlY3Rpb247XG4gIHAuX21vbmdvb3NlT3B0aW9ucyA9IHRoaXMuX21vbmdvb3NlT3B0aW9ucztcblxuICByZXR1cm4gQ3VzdG9tUXVlcnk7XG59O1xuXG4vKipcbiAqIE1ha2UgYSBjb3B5IG9mIHRoaXMgcXVlcnkgc28geW91IGNhbiByZS1leGVjdXRlIGl0LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcSA9IEJvb2suZmluZE9uZSh7IHRpdGxlOiAnQ2FzaW5vIFJveWFsZScgfSk7XG4gKiAgICAgYXdhaXQgcS5leGVjKCk7XG4gKiAgICAgYXdhaXQgcS5leGVjKCk7IC8vIFRocm93cyBhbiBlcnJvciBiZWNhdXNlIHlvdSBjYW4ndCBleGVjdXRlIGEgcXVlcnkgdHdpY2VcbiAqXG4gKiAgICAgYXdhaXQgcS5jbG9uZSgpLmV4ZWMoKTsgLy8gV29ya3NcbiAqXG4gKiBAbWV0aG9kIGNsb25lXG4gKiBAcmV0dXJuIHtRdWVyeX0gY29weVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgY29uc3QgY29sbGVjdGlvbiA9IHRoaXMubW9uZ29vc2VDb2xsZWN0aW9uO1xuXG4gIGNvbnN0IHEgPSBuZXcgdGhpcy5tb2RlbC5RdWVyeSh7fSwge30sIG1vZGVsLCBjb2xsZWN0aW9uKTtcblxuICAvLyBOZWVkIHRvIGhhbmRsZSBgc29ydCgpYCBzZXBhcmF0ZWx5IGJlY2F1c2UgZW50cmllcy1zdHlsZSBgc29ydCgpYCBzeW50YXhcbiAgLy8gYHNvcnQoW1sncHJvcDEnLCAxXV0pYCBjb25mdXNlcyBtcXVlcnkgaW50byBsb3NpbmcgdGhlIG91dGVyIG5lc3RlZCBhcnJheS5cbiAgLy8gU2VlIGdoLTgxNTlcbiAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucyk7XG4gIGlmIChvcHRpb25zLnNvcnQgIT0gbnVsbCkge1xuICAgIHEuc29ydChvcHRpb25zLnNvcnQpO1xuICAgIGRlbGV0ZSBvcHRpb25zLnNvcnQ7XG4gIH1cbiAgcS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gIHEub3AgPSB0aGlzLm9wO1xuICBxLl92YWxpZGF0ZU9wKCk7XG4gIHEuX2NvbmRpdGlvbnMgPSBjbG9uZSh0aGlzLl9jb25kaXRpb25zKTtcbiAgcS5fZmllbGRzID0gY2xvbmUodGhpcy5fZmllbGRzKTtcbiAgcS5fdXBkYXRlID0gY2xvbmUodGhpcy5fdXBkYXRlLCB7XG4gICAgZmxhdHRlbkRlY2ltYWxzOiBmYWxzZVxuICB9KTtcbiAgcS5fcGF0aCA9IHRoaXMuX3BhdGg7XG4gIHEuX2Rpc3RpbmN0ID0gdGhpcy5fZGlzdGluY3Q7XG4gIHEuX2NvbGxlY3Rpb24gPSB0aGlzLl9jb2xsZWN0aW9uO1xuICBxLl9tb25nb29zZU9wdGlvbnMgPSB0aGlzLl9tb25nb29zZU9wdGlvbnM7XG5cbiAgcmV0dXJuIHE7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIGphdmFzY3JpcHQgZnVuY3Rpb24gb3IgZXhwcmVzc2lvbiB0byBwYXNzIHRvIE1vbmdvREJzIHF1ZXJ5IHN5c3RlbS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LiR3aGVyZSgndGhpcy5jb21tZW50cy5sZW5ndGggPT09IDEwIHx8IHRoaXMubmFtZS5sZW5ndGggPT09IDUnKVxuICpcbiAqICAgICAvLyBvclxuICpcbiAqICAgICBxdWVyeS4kd2hlcmUoZnVuY3Rpb24gKCkge1xuICogICAgICAgcmV0dXJuIHRoaXMuY29tbWVudHMubGVuZ3RoID09PSAxMCB8fCB0aGlzLm5hbWUubGVuZ3RoID09PSA1O1xuICogICAgIH0pXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIE9ubHkgdXNlIGAkd2hlcmVgIHdoZW4geW91IGhhdmUgYSBjb25kaXRpb24gdGhhdCBjYW5ub3QgYmUgbWV0IHVzaW5nIG90aGVyIE1vbmdvREIgb3BlcmF0b3JzIGxpa2UgYCRsdGAuXG4gKiAqKkJlIHN1cmUgdG8gcmVhZCBhYm91dCBhbGwgb2YgW2l0cyBjYXZlYXRzXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3Ivd2hlcmUvKSBiZWZvcmUgdXNpbmcuKipcbiAqXG4gKiBAc2VlICR3aGVyZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3Ivd2hlcmUvXG4gKiBAbWV0aG9kICR3aGVyZVxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IGpzIGphdmFzY3JpcHQgc3RyaW5nIG9yIGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBtZXRob2QgJHdoZXJlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGEgYHBhdGhgIGZvciB1c2Ugd2l0aCBjaGFpbmluZy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIGluc3RlYWQgb2Ygd3JpdGluZzpcbiAqICAgICBVc2VyLmZpbmQoe2FnZTogeyRndGU6IDIxLCAkbHRlOiA2NX19KTtcbiAqXG4gKiAgICAgLy8gd2UgY2FuIGluc3RlYWQgd3JpdGU6XG4gKiAgICAgVXNlci53aGVyZSgnYWdlJykuZ3RlKDIxKS5sdGUoNjUpO1xuICpcbiAqICAgICAvLyBwYXNzaW5nIHF1ZXJ5IGNvbmRpdGlvbnMgaXMgcGVybWl0dGVkXG4gKiAgICAgVXNlci5maW5kKCkud2hlcmUoeyBuYW1lOiAndm9uZGVyZnVsJyB9KVxuICpcbiAqICAgICAvLyBjaGFpbmluZ1xuICogICAgIFVzZXJcbiAqICAgICAud2hlcmUoJ2FnZScpLmd0ZSgyMSkubHRlKDY1KVxuICogICAgIC53aGVyZSgnbmFtZScsIC9edm9uZGVyZnVsL2kpXG4gKiAgICAgLndoZXJlKCdmcmllbmRzJykuc2xpY2UoMTApXG4gKiAgICAgLmV4ZWMoKVxuICpcbiAqIEBtZXRob2Qgd2hlcmVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IFtwYXRoXVxuICogQHBhcmFtIHthbnl9IFt2YWxdXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIGAkc2xpY2VgIHByb2plY3Rpb24gZm9yIGFuIGFycmF5LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuc2xpY2UoJ2NvbW1lbnRzJywgNSk7IC8vIFJldHVybnMgdGhlIGZpcnN0IDUgY29tbWVudHNcbiAqICAgICBxdWVyeS5zbGljZSgnY29tbWVudHMnLCAtNSk7IC8vIFJldHVybnMgdGhlIGxhc3QgNSBjb21tZW50c1xuICogICAgIHF1ZXJ5LnNsaWNlKCdjb21tZW50cycsIFsxMCwgNV0pOyAvLyBSZXR1cm5zIHRoZSBmaXJzdCA1IGNvbW1lbnRzIGFmdGVyIHRoZSAxMC10aFxuICogICAgIHF1ZXJ5LndoZXJlKCdjb21tZW50cycpLnNsaWNlKDUpOyAvLyBSZXR1cm5zIHRoZSBmaXJzdCA1IGNvbW1lbnRzXG4gKiAgICAgcXVlcnkud2hlcmUoJ2NvbW1lbnRzJykuc2xpY2UoWy0xMCwgNV0pOyAvLyBSZXR1cm5zIHRoZSBmaXJzdCA1IGNvbW1lbnRzIGFmdGVyIHRoZSAxMC10aCB0byBsYXN0XG4gKlxuICogKipOb3RlOioqIElmIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGJlIHNsaWNlZCBpcyBncmVhdGVyIHRoYW4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXksIGFsbCBhcnJheSBlbGVtZW50cyB3aWxsIGJlIHJldHVybmVkLlxuICpcbiAqICAgICAgLy8gR2l2ZW4gYGFycmA6IFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMF1cbiAqICAgICAgcXVlcnkuc2xpY2UoJ2FycicsIDIwKTsgLy8gUmV0dXJucyBbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTBdXG4gKiAgICAgIHF1ZXJ5LnNsaWNlKCdhcnInLCAtMjApOyAvLyBSZXR1cm5zIFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMF1cbiAqXG4gKiAqKk5vdGU6KiogSWYgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGlzIHBvc2l0aXZlIGFuZCBncmVhdGVyIHRoYW4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXksIGFuIGVtcHR5IGFycmF5IHdpbGwgYmUgcmV0dXJuZWQuXG4gKlxuICogICAgICAvLyBHaXZlbiBgYXJyYDogWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwXVxuICogICAgICBxdWVyeS5zbGljZSgnYXJyJywgWzIwLCA1XSk7IC8vIFJldHVybnMgW11cbiAqXG4gKiAqKk5vdGU6KiogSWYgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGlzIG5lZ2F0aXZlIGFuZCBpdHMgYWJzb2x1dGUgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5LCB0aGUgc3RhcnRpbmcgcG9zaXRpb24gaXMgdGhlIHN0YXJ0IG9mIHRoZSBhcnJheS5cbiAqXG4gKiAgICAgIC8vIEdpdmVuIGBhcnJgOiBbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTBdXG4gKiAgICAgIHF1ZXJ5LnNsaWNlKCdhcnInLCBbLTIwLCA1XSk7IC8vIFJldHVybnMgWzEsIDIsIDMsIDQsIDVdXG4gKlxuICogQG1ldGhvZCBzbGljZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfEFycmF5fSB2YWwgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNsaWNlIG9yIGFycmF5IHdpdGggbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYW5kIG51bWJlciBvZiBlbGVtZW50cyB0byBzbGljZVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgbW9uZ29kYiBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC90dXRvcmlhbC9xdWVyeS1kb2N1bWVudHMvI3Byb2plY3Rpb25cbiAqIEBzZWUgJHNsaWNlIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9wcm9qZWN0aW9uL3NsaWNlLyNwcmouX1Nfc2xpY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0aGlzLl92YWxpZGF0ZSgnc2xpY2UnKTtcblxuICBsZXQgcGF0aDtcbiAgbGV0IHZhbDtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IGFyZyA9IGFyZ3VtZW50c1swXTtcbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGFyZyk7XG4gICAgICBjb25zdCBudW1LZXlzID0ga2V5cy5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUtleXM7ICsraSkge1xuICAgICAgICB0aGlzLnNsaWNlKGtleXNbaV0sIGFyZ1trZXlzW2ldXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5fZW5zdXJlUGF0aCgnc2xpY2UnKTtcbiAgICBwYXRoID0gdGhpcy5fcGF0aDtcbiAgICB2YWwgPSBhcmd1bWVudHNbMF07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIGlmICgnbnVtYmVyJyA9PT0gdHlwZW9mIGFyZ3VtZW50c1swXSkge1xuICAgICAgdGhpcy5fZW5zdXJlUGF0aCgnc2xpY2UnKTtcbiAgICAgIHBhdGggPSB0aGlzLl9wYXRoO1xuICAgICAgdmFsID0gW2FyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhbCA9IGFyZ3VtZW50c1sxXTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgdmFsID0gW2FyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdXTtcbiAgfVxuXG4gIGNvbnN0IHAgPSB7fTtcbiAgcFtwYXRoXSA9IHsgJHNsaWNlOiB2YWwgfTtcbiAgdGhpcy5zZWxlY3QocCk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmNvbnN0IHZhbGlkT3BzU2V0ID0gbmV3IFNldChxdWVyeU1pZGRsZXdhcmVGdW5jdGlvbnMpO1xuXG5RdWVyeS5wcm90b3R5cGUuX3ZhbGlkYXRlT3AgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMub3AgIT0gbnVsbCAmJiAhdmFsaWRPcHNTZXQuaGFzKHRoaXMub3ApKSB7XG4gICAgdGhpcy5lcnJvcihuZXcgRXJyb3IoJ1F1ZXJ5IGhhcyBpbnZhbGlkIGBvcGA6IFwiJyArIHRoaXMub3AgKyAnXCInKSk7XG4gIH1cbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBjb21wbGVtZW50YXJ5IGNvbXBhcmlzb24gdmFsdWUgZm9yIHBhdGhzIHNwZWNpZmllZCB3aXRoIGB3aGVyZSgpYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgVXNlci53aGVyZSgnYWdlJykuZXF1YWxzKDQ5KTtcbiAqXG4gKiAgICAgLy8gaXMgdGhlIHNhbWUgYXNcbiAqXG4gKiAgICAgVXNlci53aGVyZSgnYWdlJywgNDkpO1xuICpcbiAqIEBtZXRob2QgZXF1YWxzXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R9IHZhbFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYXJndW1lbnRzIGZvciBhbiBgJG9yYCBjb25kaXRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5vcihbeyBjb2xvcjogJ3JlZCcgfSwgeyBzdGF0dXM6ICdlbWVyZ2VuY3knIH1dKTtcbiAqXG4gKiBAc2VlICRvciBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3Ivb3IvXG4gKiBAbWV0aG9kIG9yXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgYXJyYXkgb2YgY29uZGl0aW9uc1xuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYXJndW1lbnRzIGZvciBhIGAkbm9yYCBjb25kaXRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5ub3IoW3sgY29sb3I6ICdncmVlbicgfSwgeyBzdGF0dXM6ICdvaycgfV0pO1xuICpcbiAqIEBzZWUgJG5vciBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3Ivbm9yL1xuICogQG1ldGhvZCBub3JcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBhcnJheSBvZiBjb25kaXRpb25zXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhcmd1bWVudHMgZm9yIGEgYCRhbmRgIGNvbmRpdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LmFuZChbeyBjb2xvcjogJ2dyZWVuJyB9LCB7IHN0YXR1czogJ29rJyB9XSlcbiAqXG4gKiBAbWV0aG9kIGFuZFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBzZWUgJGFuZCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvYW5kL1xuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgYXJyYXkgb2YgY29uZGl0aW9uc1xuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBgJGd0YCBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIFRoaW5nLmZpbmQoKS53aGVyZSgnYWdlJykuZ3QoMjEpO1xuICpcbiAqICAgICAvLyBvclxuICogICAgIFRoaW5nLmZpbmQoKS5ndCgnYWdlJywgMjEpO1xuICpcbiAqIEBtZXRob2QgZ3RcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAc2VlICRndCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvZ3QvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGEgYCRndGVgIHF1ZXJ5IGNvbmRpdGlvbi5cbiAqXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgdGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYCBpcyB1c2VkLlxuICpcbiAqIEBtZXRob2QgZ3RlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQHNlZSAkZ3RlIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9ndGUvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGEgYCRsdGAgcXVlcnkgY29uZGl0aW9uLlxuICpcbiAqIFdoZW4gY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCB0aGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgIGlzIHVzZWQuXG4gKlxuICogQG1ldGhvZCBsdFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBzZWUgJGx0IGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9sdC9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBgJGx0ZWAgcXVlcnkgY29uZGl0aW9uLlxuICpcbiAqIFdoZW4gY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCB0aGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgIGlzIHVzZWQuXG4gKlxuICogQG1ldGhvZCBsdGVcbiAqIEBzZWUgJGx0ZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvbHRlL1xuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBgJG5lYCBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAc2VlICRuZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvbmUvXG4gKiBAbWV0aG9kIG5lXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHthbnl9IHZhbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhbiBgJGluYCBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAc2VlICRpbiBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvaW4vXG4gKiBAbWV0aG9kIGluXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtBcnJheX0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGFuIGAkbmluYCBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAc2VlICRuaW4gaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL25pbi9cbiAqIEBtZXRob2QgbmluXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtBcnJheX0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGFuIGAkYWxsYCBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIE15TW9kZWwuZmluZCgpLndoZXJlKCdwZXRzJykuYWxsKFsnZG9nJywgJ2NhdCcsICdmZXJyZXQnXSk7XG4gKiAgICAgLy8gRXF1aXZhbGVudDpcbiAqICAgICBNeU1vZGVsLmZpbmQoKS5hbGwoJ3BldHMnLCBbJ2RvZycsICdjYXQnLCAnZmVycmV0J10pO1xuICpcbiAqIEBzZWUgJGFsbCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvYWxsL1xuICogQG1ldGhvZCBhbGxcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge0FycmF5fSB2YWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBgJHNpemVgIHF1ZXJ5IGNvbmRpdGlvbi5cbiAqXG4gKiBXaGVuIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgdGhlIG1vc3QgcmVjZW50IHBhdGggcGFzc2VkIHRvIGB3aGVyZSgpYCBpcyB1c2VkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgZG9jcyA9IGF3YWl0IE15TW9kZWwud2hlcmUoJ3RhZ3MnKS5zaXplKDApLmV4ZWMoKTtcbiAqICAgICBhc3NlcnQoQXJyYXkuaXNBcnJheShkb2NzKSk7XG4gKiAgICAgY29uc29sZS5sb2coJ2RvY3VtZW50cyB3aXRoIDAgdGFncycsIGRvY3MpO1xuICpcbiAqIEBzZWUgJHNpemUgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3NpemUvXG4gKiBAbWV0aG9kIHNpemVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGEgYCRyZWdleGAgcXVlcnkgY29uZGl0aW9uLlxuICpcbiAqIFdoZW4gY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCB0aGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgIGlzIHVzZWQuXG4gKlxuICogQHNlZSAkcmVnZXggaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3JlZ2V4L1xuICogQG1ldGhvZCByZWdleFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGEgYG1heERpc3RhbmNlYCBxdWVyeSBjb25kaXRpb24uXG4gKlxuICogV2hlbiBjYWxsZWQgd2l0aCBvbmUgYXJndW1lbnQsIHRoZSBtb3N0IHJlY2VudCBwYXRoIHBhc3NlZCB0byBgd2hlcmUoKWAgaXMgdXNlZC5cbiAqXG4gKiBAc2VlICRtYXhEaXN0YW5jZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvbWF4RGlzdGFuY2UvXG4gKiBAbWV0aG9kIG1heERpc3RhbmNlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIGAkbW9kYCBjb25kaXRpb24sIGZpbHRlcnMgZG9jdW1lbnRzIGZvciBkb2N1bWVudHMgd2hvc2VcbiAqIGBwYXRoYCBwcm9wZXJ0eSBpcyBhIG51bWJlciB0aGF0IGlzIGVxdWFsIHRvIGByZW1haW5kZXJgIG1vZHVsbyBgZGl2aXNvcmAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBBbGwgZmluZCBwcm9kdWN0cyB3aG9zZSBpbnZlbnRvcnkgaXMgb2RkXG4gKiAgICAgUHJvZHVjdC5maW5kKCkubW9kKCdpbnZlbnRvcnknLCBbMiwgMV0pO1xuICogICAgIFByb2R1Y3QuZmluZCgpLndoZXJlKCdpbnZlbnRvcnknKS5tb2QoWzIsIDFdKTtcbiAqICAgICAvLyBUaGlzIHN5bnRheCBpcyBhIGxpdHRsZSBzdHJhbmdlLCBidXQgc3VwcG9ydGVkLlxuICogICAgIFByb2R1Y3QuZmluZCgpLndoZXJlKCdpbnZlbnRvcnknKS5tb2QoMiwgMSk7XG4gKlxuICogQG1ldGhvZCBtb2RcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge0FycmF5fSB2YWwgbXVzdCBiZSBvZiBsZW5ndGggMiwgZmlyc3QgZWxlbWVudCBpcyBgZGl2aXNvcmAsIDJuZCBlbGVtZW50IGlzIGByZW1haW5kZXJgLlxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgJG1vZCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvbW9kL1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUubW9kID0gZnVuY3Rpb24oKSB7XG4gIGxldCB2YWw7XG4gIGxldCBwYXRoO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdGhpcy5fZW5zdXJlUGF0aCgnbW9kJyk7XG4gICAgdmFsID0gYXJndW1lbnRzWzBdO1xuICAgIHBhdGggPSB0aGlzLl9wYXRoO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgIUFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzFdKSkge1xuICAgIHRoaXMuX2Vuc3VyZVBhdGgoJ21vZCcpO1xuICAgIHZhbCA9IFthcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXV07XG4gICAgcGF0aCA9IHRoaXMuX3BhdGg7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhbCA9IFthcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXV07XG4gICAgcGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBhcmd1bWVudHNbMV07XG4gICAgcGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgfVxuXG4gIGNvbnN0IGNvbmRzID0gdGhpcy5fY29uZGl0aW9uc1twYXRoXSB8fCAodGhpcy5fY29uZGl0aW9uc1twYXRoXSA9IHt9KTtcbiAgY29uZHMuJG1vZCA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyBhbiBgJGV4aXN0c2AgY29uZGl0aW9uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyB7IG5hbWU6IHsgJGV4aXN0czogdHJ1ZSB9fVxuICogICAgIFRoaW5nLndoZXJlKCduYW1lJykuZXhpc3RzKClcbiAqICAgICBUaGluZy53aGVyZSgnbmFtZScpLmV4aXN0cyh0cnVlKVxuICogICAgIFRoaW5nLmZpbmQoKS5leGlzdHMoJ25hbWUnKVxuICpcbiAqICAgICAvLyB7IG5hbWU6IHsgJGV4aXN0czogZmFsc2UgfX1cbiAqICAgICBUaGluZy53aGVyZSgnbmFtZScpLmV4aXN0cyhmYWxzZSk7XG4gKiAgICAgVGhpbmcuZmluZCgpLmV4aXN0cygnbmFtZScsIGZhbHNlKTtcbiAqXG4gKiBAbWV0aG9kIGV4aXN0c1xuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSAkZXhpc3RzIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9leGlzdHMvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGFuIGAkZWxlbU1hdGNoYCBjb25kaXRpb25cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LmVsZW1NYXRjaCgnY29tbWVudCcsIHsgYXV0aG9yOiAnYXV0b2JvdCcsIHZvdGVzOiB7JGd0ZTogNX19KVxuICpcbiAqICAgICBxdWVyeS53aGVyZSgnY29tbWVudCcpLmVsZW1NYXRjaCh7IGF1dGhvcjogJ2F1dG9ib3QnLCB2b3RlczogeyRndGU6IDV9fSlcbiAqXG4gKiAgICAgcXVlcnkuZWxlbU1hdGNoKCdjb21tZW50JywgZnVuY3Rpb24gKGVsZW0pIHtcbiAqICAgICAgIGVsZW0ud2hlcmUoJ2F1dGhvcicpLmVxdWFscygnYXV0b2JvdCcpO1xuICogICAgICAgZWxlbS53aGVyZSgndm90ZXMnKS5ndGUoNSk7XG4gKiAgICAgfSlcbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ2NvbW1lbnQnKS5lbGVtTWF0Y2goZnVuY3Rpb24gKGVsZW0pIHtcbiAqICAgICAgIGVsZW0ud2hlcmUoeyBhdXRob3I6ICdhdXRvYm90JyB9KTtcbiAqICAgICAgIGVsZW0ud2hlcmUoJ3ZvdGVzJykuZ3RlKDUpO1xuICogICAgIH0pXG4gKlxuICogQG1ldGhvZCBlbGVtTWF0Y2hcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8RnVuY3Rpb259IHBhdGhcbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBmaWx0ZXJcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlICRlbGVtTWF0Y2ggaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2VsZW1NYXRjaC9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBEZWZpbmVzIGEgYCR3aXRoaW5gIG9yIGAkZ2VvV2l0aGluYCBhcmd1bWVudCBmb3IgZ2VvLXNwYXRpYWwgcXVlcmllcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKHBhdGgpLndpdGhpbigpLmJveCgpXG4gKiAgICAgcXVlcnkud2hlcmUocGF0aCkud2l0aGluKCkuY2lyY2xlKClcbiAqICAgICBxdWVyeS53aGVyZShwYXRoKS53aXRoaW4oKS5nZW9tZXRyeSgpXG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oeyBjZW50ZXI6IFs1MCw1MF0sIHJhZGl1czogMTAsIHVuaXF1ZTogdHJ1ZSwgc3BoZXJpY2FsOiB0cnVlIH0pO1xuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oeyBib3g6IFtbNDAuNzMsIC03My45XSwgWzQwLjcsIC03My45ODhdXSB9KTtcbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykud2l0aGluKHsgcG9seWdvbjogW1tdLFtdLFtdLFtdXSB9KTtcbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbihbXSwgW10sIFtdKSAvLyBwb2x5Z29uXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbihbXSwgW10pIC8vIGJveFxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oeyB0eXBlOiAnTGluZVN0cmluZycsIGNvb3JkaW5hdGVzOiBbLi4uXSB9KTsgLy8gZ2VvbWV0cnlcbiAqXG4gKiAqKk1VU1QqKiBiZSB1c2VkIGFmdGVyIGB3aGVyZSgpYC5cbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogQXMgb2YgTW9uZ29vc2UgMy43LCBgJGdlb1dpdGhpbmAgaXMgYWx3YXlzIHVzZWQgZm9yIHF1ZXJpZXMuIFRvIGNoYW5nZSB0aGlzIGJlaGF2aW9yLCBzZWUgW1F1ZXJ5LnVzZSRnZW9XaXRoaW5dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUudXNlJGdlb1dpdGhpbikuXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIEluIE1vbmdvb3NlIDMuNywgYHdpdGhpbmAgY2hhbmdlZCBmcm9tIGEgZ2V0dGVyIHRvIGEgZnVuY3Rpb24uIElmIHlvdSBuZWVkIHRoZSBvbGQgc3ludGF4LCB1c2UgW3RoaXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9lYmVuc2luZy9tb25nb29zZS13aXRoaW4pLlxuICpcbiAqIEBtZXRob2Qgd2l0aGluXG4gKiBAc2VlICRwb2x5Z29uIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9wb2x5Z29uL1xuICogQHNlZSAkYm94IGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9ib3gvXG4gKiBAc2VlICRnZW9tZXRyeSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvZ2VvbWV0cnkvXG4gKiBAc2VlICRjZW50ZXIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2NlbnRlci9cbiAqIEBzZWUgJGNlbnRlclNwaGVyZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvY2VudGVyU3BoZXJlL1xuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBtYXhpbXVtIG51bWJlciBvZiBkb2N1bWVudHMgdGhlIHF1ZXJ5IHdpbGwgcmV0dXJuLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkubGltaXQoMjApO1xuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBDYW5ub3QgYmUgdXNlZCB3aXRoIGBkaXN0aW5jdCgpYFxuICpcbiAqIEBtZXRob2QgbGltaXRcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5saW1pdCA9IGZ1bmN0aW9uIGxpbWl0KHYpIHtcbiAgdGhpcy5fdmFsaWRhdGUoJ2xpbWl0Jyk7XG5cbiAgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICB2ID0gY2FzdE51bWJlcih2KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJ051bWJlcicsIHYsICdsaW1pdCcpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMub3B0aW9ucy5saW1pdCA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIG51bWJlciBvZiBkb2N1bWVudHMgdG8gc2tpcC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LnNraXAoMTAwKS5saW1pdCgyMCk7XG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIENhbm5vdCBiZSB1c2VkIHdpdGggYGRpc3RpbmN0KClgXG4gKlxuICogQG1ldGhvZCBza2lwXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbFxuICogQHNlZSBjdXJzb3Iuc2tpcCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL2N1cnNvci5za2lwL1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uIHNraXAodikge1xuICB0aGlzLl92YWxpZGF0ZSgnc2tpcCcpO1xuXG4gIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpIHtcbiAgICB0cnkge1xuICAgICAgdiA9IGNhc3ROdW1iZXIodik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdOdW1iZXInLCB2LCAnc2tpcCcpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMub3B0aW9ucy5za2lwID0gdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgYmF0Y2hTaXplIG9wdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LmJhdGNoU2l6ZSgxMDApXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIENhbm5vdCBiZSB1c2VkIHdpdGggYGRpc3RpbmN0KClgXG4gKlxuICogQG1ldGhvZCBiYXRjaFNpemVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsXG4gKiBAc2VlIGJhdGNoU2l6ZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL2N1cnNvci5iYXRjaFNpemUvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBgY29tbWVudGAgb3B0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuY29tbWVudCgnbG9naW4gcXVlcnknKVxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBDYW5ub3QgYmUgdXNlZCB3aXRoIGBkaXN0aW5jdCgpYFxuICpcbiAqIEBtZXRob2QgY29tbWVudFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWxcbiAqIEBzZWUgY29tbWVudCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvY29tbWVudC9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTZXRzIHF1ZXJ5IGhpbnRzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkuaGludCh7IGluZGV4QTogMSwgaW5kZXhCOiAtMSB9KTtcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogQ2Fubm90IGJlIHVzZWQgd2l0aCBgZGlzdGluY3QoKWBcbiAqXG4gKiBAbWV0aG9kIGhpbnRcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIGEgaGludCBvYmplY3RcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlICRoaW50IGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9oaW50L1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIEdldC9zZXQgdGhlIGN1cnJlbnQgcHJvamVjdGlvbiAoQUtBIGZpZWxkcykuIFBhc3MgYG51bGxgIHRvIHJlbW92ZSB0aGVcbiAqIGN1cnJlbnQgcHJvamVjdGlvbi5cbiAqXG4gKiBVbmxpa2UgYHByb2plY3Rpb24oKWAsIHRoZSBgc2VsZWN0KClgIGZ1bmN0aW9uIG1vZGlmaWVzIHRoZSBjdXJyZW50XG4gKiBwcm9qZWN0aW9uIGluIHBsYWNlLiBUaGlzIGZ1bmN0aW9uIG92ZXJ3cml0ZXMgdGhlIGV4aXN0aW5nIHByb2plY3Rpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBxID0gTW9kZWwuZmluZCgpO1xuICogICAgIHEucHJvamVjdGlvbigpOyAvLyBudWxsXG4gKlxuICogICAgIHEuc2VsZWN0KCdhIGInKTtcbiAqICAgICBxLnByb2plY3Rpb24oKTsgLy8geyBhOiAxLCBiOiAxIH1cbiAqXG4gKiAgICAgcS5wcm9qZWN0aW9uKHsgYzogMSB9KTtcbiAqICAgICBxLnByb2plY3Rpb24oKTsgLy8geyBjOiAxIH1cbiAqXG4gKiAgICAgcS5wcm9qZWN0aW9uKG51bGwpO1xuICogICAgIHEucHJvamVjdGlvbigpOyAvLyBudWxsXG4gKlxuICpcbiAqIEBtZXRob2QgcHJvamVjdGlvblxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fG51bGx9IGFyZ1xuICogQHJldHVybiB7T2JqZWN0fSB0aGUgY3VycmVudCBwcm9qZWN0aW9uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5wcm9qZWN0aW9uID0gZnVuY3Rpb24oYXJnKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpZWxkcztcbiAgfVxuXG4gIHRoaXMuX2ZpZWxkcyA9IHt9O1xuICB0aGlzLl91c2VyUHJvdmlkZWRGaWVsZHMgPSB7fTtcbiAgdGhpcy5zZWxlY3QoYXJnKTtcbiAgcmV0dXJuIHRoaXMuX2ZpZWxkcztcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIHdoaWNoIGRvY3VtZW50IGZpZWxkcyB0byBpbmNsdWRlIG9yIGV4Y2x1ZGUgKGFsc28ga25vd24gYXMgdGhlIHF1ZXJ5IFwicHJvamVjdGlvblwiKVxuICpcbiAqIFdoZW4gdXNpbmcgc3RyaW5nIHN5bnRheCwgcHJlZml4aW5nIGEgcGF0aCB3aXRoIGAtYCB3aWxsIGZsYWcgdGhhdCBwYXRoIGFzIGV4Y2x1ZGVkLiBXaGVuIGEgcGF0aCBkb2VzIG5vdCBoYXZlIHRoZSBgLWAgcHJlZml4LCBpdCBpcyBpbmNsdWRlZC4gTGFzdGx5LCBpZiBhIHBhdGggaXMgcHJlZml4ZWQgd2l0aCBgK2AsIGl0IGZvcmNlcyBpbmNsdXNpb24gb2YgdGhlIHBhdGgsIHdoaWNoIGlzIHVzZWZ1bCBmb3IgcGF0aHMgZXhjbHVkZWQgYXQgdGhlIFtzY2hlbWEgbGV2ZWxdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvc2NoZW1hdHlwZS5odG1sI1NjaGVtYVR5cGUucHJvdG90eXBlLnNlbGVjdCgpKS5cbiAqXG4gKiBBIHByb2plY3Rpb24gX211c3RfIGJlIGVpdGhlciBpbmNsdXNpdmUgb3IgZXhjbHVzaXZlLiBJbiBvdGhlciB3b3JkcywgeW91IG11c3RcbiAqIGVpdGhlciBsaXN0IHRoZSBmaWVsZHMgdG8gaW5jbHVkZSAod2hpY2ggZXhjbHVkZXMgYWxsIG90aGVycyksIG9yIGxpc3QgdGhlIGZpZWxkc1xuICogdG8gZXhjbHVkZSAod2hpY2ggaW1wbGllcyBhbGwgb3RoZXIgZmllbGRzIGFyZSBpbmNsdWRlZCkuIFRoZSBbYF9pZGAgZmllbGQgaXMgdGhlIG9ubHkgZXhjZXB0aW9uIGJlY2F1c2UgTW9uZ29EQiBpbmNsdWRlcyBpdCBieSBkZWZhdWx0XShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC90dXRvcmlhbC9wcm9qZWN0LWZpZWxkcy1mcm9tLXF1ZXJ5LXJlc3VsdHMvI3N1cHByZXNzLWlkLWZpZWxkKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIGluY2x1ZGUgYSBhbmQgYiwgZXhjbHVkZSBvdGhlciBmaWVsZHNcbiAqICAgICBxdWVyeS5zZWxlY3QoJ2EgYicpO1xuICogICAgIC8vIEVxdWl2YWxlbnQgc3ludGF4ZXM6XG4gKiAgICAgcXVlcnkuc2VsZWN0KFsnYScsICdiJ10pO1xuICogICAgIHF1ZXJ5LnNlbGVjdCh7IGE6IDEsIGI6IDEgfSk7XG4gKlxuICogICAgIC8vIGV4Y2x1ZGUgYyBhbmQgZCwgaW5jbHVkZSBvdGhlciBmaWVsZHNcbiAqICAgICBxdWVyeS5zZWxlY3QoJy1jIC1kJyk7XG4gKlxuICogICAgIC8vIFVzZSBgK2AgdG8gb3ZlcnJpZGUgc2NoZW1hLWxldmVsIGBzZWxlY3Q6IGZhbHNlYCB3aXRob3V0IG1ha2luZyB0aGVcbiAqICAgICAvLyBwcm9qZWN0aW9uIGluY2x1c2l2ZS5cbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHtcbiAqICAgICAgIGZvbzogeyB0eXBlOiBTdHJpbmcsIHNlbGVjdDogZmFsc2UgfSxcbiAqICAgICAgIGJhcjogU3RyaW5nXG4gKiAgICAgfSk7XG4gKiAgICAgLy8gLi4uXG4gKiAgICAgcXVlcnkuc2VsZWN0KCcrZm9vJyk7IC8vIE92ZXJyaWRlIGZvbydzIGBzZWxlY3Q6IGZhbHNlYCB3aXRob3V0IGV4Y2x1ZGluZyBgYmFyYFxuICpcbiAqICAgICAvLyBvciB5b3UgbWF5IHVzZSBvYmplY3Qgbm90YXRpb24sIHVzZWZ1bCB3aGVuXG4gKiAgICAgLy8geW91IGhhdmUga2V5cyBhbHJlYWR5IHByZWZpeGVkIHdpdGggYSBcIi1cIlxuICogICAgIHF1ZXJ5LnNlbGVjdCh7IGE6IDEsIGI6IDEgfSk7XG4gKiAgICAgcXVlcnkuc2VsZWN0KHsgYzogMCwgZDogMCB9KTtcbiAqXG4gKiAgICAgQWRkaXRpb25hbCBjYWxscyB0byBzZWxlY3QgY2FuIG92ZXJyaWRlIHRoZSBwcmV2aW91cyBzZWxlY3Rpb246XG4gKiAgICAgcXVlcnkuc2VsZWN0KHsgYTogMSwgYjogMSB9KS5zZWxlY3QoeyBiOiAwIH0pOyAvLyBzZWxlY3Rpb24gaXMgbm93IHsgYTogMSB9XG4gKiAgICAgcXVlcnkuc2VsZWN0KHsgYTogMCwgYjogMCB9KS5zZWxlY3QoeyBiOiAxIH0pOyAvLyBzZWxlY3Rpb24gaXMgbm93IHsgYTogMCB9XG4gKlxuICpcbiAqIEBtZXRob2Qgc2VsZWN0XG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfFN0cmluZ1tdfSBhcmdcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIFNjaGVtYVR5cGUgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9zY2hlbWF0eXBlLmh0bWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uIHNlbGVjdCgpIHtcbiAgbGV0IGFyZyA9IGFyZ3VtZW50c1swXTtcbiAgaWYgKCFhcmcpIHJldHVybiB0aGlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdDogc2VsZWN0IG9ubHkgdGFrZXMgMSBhcmd1bWVudCcpO1xuICB9XG5cbiAgdGhpcy5fdmFsaWRhdGUoJ3NlbGVjdCcpO1xuXG4gIGNvbnN0IGZpZWxkcyA9IHRoaXMuX2ZpZWxkcyB8fCAodGhpcy5fZmllbGRzID0ge30pO1xuICBjb25zdCB1c2VyUHJvdmlkZWRGaWVsZHMgPSB0aGlzLl91c2VyUHJvdmlkZWRGaWVsZHMgfHwgKHRoaXMuX3VzZXJQcm92aWRlZEZpZWxkcyA9IHt9KTtcbiAgbGV0IHNhbml0aXplUHJvamVjdGlvbiA9IHVuZGVmaW5lZDtcbiAgaWYgKHRoaXMubW9kZWwgIT0gbnVsbCAmJiB1dGlscy5oYXNVc2VyRGVmaW5lZFByb3BlcnR5KHRoaXMubW9kZWwuZGIub3B0aW9ucywgJ3Nhbml0aXplUHJvamVjdGlvbicpKSB7XG4gICAgc2FuaXRpemVQcm9qZWN0aW9uID0gdGhpcy5tb2RlbC5kYi5vcHRpb25zLnNhbml0aXplUHJvamVjdGlvbjtcbiAgfSBlbHNlIGlmICh0aGlzLm1vZGVsICE9IG51bGwgJiYgdXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eSh0aGlzLm1vZGVsLmJhc2Uub3B0aW9ucywgJ3Nhbml0aXplUHJvamVjdGlvbicpKSB7XG4gICAgc2FuaXRpemVQcm9qZWN0aW9uID0gdGhpcy5tb2RlbC5iYXNlLm9wdGlvbnMuc2FuaXRpemVQcm9qZWN0aW9uO1xuICB9IGVsc2Uge1xuICAgIHNhbml0aXplUHJvamVjdGlvbiA9IHRoaXMuX21vbmdvb3NlT3B0aW9ucy5zYW5pdGl6ZVByb2plY3Rpb247XG4gIH1cblxuICBmdW5jdGlvbiBzYW5pdGl6ZVZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgc2FuaXRpemVQcm9qZWN0aW9uID8gdmFsdWUgPSAxIDogdmFsdWU7XG4gIH1cbiAgYXJnID0gcGFyc2VQcm9qZWN0aW9uKGFyZywgdHJ1ZSk7IC8vIHdlIHdhbnQgdG8ga2VlcCB0aGUgbWludXMgYW5kIHBsdXNlcywgc28gYWRkIGJvb2xlYW4gYXJnLlxuICBpZiAodXRpbHMuaXNPYmplY3QoYXJnKSkge1xuICAgIGlmICh0aGlzLnNlbGVjdGVkSW5jbHVzaXZlbHkoKSkge1xuICAgICAgT2JqZWN0LmVudHJpZXMoYXJnKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgLy8gQWRkIHRoZSBmaWVsZCB0byB0aGUgcHJvamVjdGlvblxuICAgICAgICAgIGlmIChmaWVsZHNbJy0nICsga2V5XSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkZWxldGUgZmllbGRzWyctJyArIGtleV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZpZWxkc1trZXldID0gdXNlclByb3ZpZGVkRmllbGRzW2tleV0gPSBzYW5pdGl6ZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZW1vdmUgdGhlIGZpZWxkIGZyb20gdGhlIHByb2plY3Rpb25cbiAgICAgICAgICBPYmplY3Qua2V5cyh1c2VyUHJvdmlkZWRGaWVsZHMpLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgICAgICAgaWYgKGlzU3VicGF0aChrZXksIGZpZWxkKSkge1xuICAgICAgICAgICAgICBkZWxldGUgZmllbGRzW2ZpZWxkXTtcbiAgICAgICAgICAgICAgZGVsZXRlIHVzZXJQcm92aWRlZEZpZWxkc1tmaWVsZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zZWxlY3RlZEV4Y2x1c2l2ZWx5KCkpIHtcbiAgICAgIE9iamVjdC5lbnRyaWVzKGFyZykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAvLyBBZGQgdGhlIGZpZWxkIHRvIHRoZSBwcm9qZWN0aW9uXG4gICAgICAgICAgaWYgKGZpZWxkc1snKycgKyBrZXldICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBmaWVsZHNbJysnICsga2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmllbGRzW2tleV0gPSB1c2VyUHJvdmlkZWRGaWVsZHNba2V5XSA9IHNhbml0aXplVmFsdWUodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlbW92ZSB0aGUgZmllbGQgZnJvbSB0aGUgcHJvamVjdGlvblxuICAgICAgICAgIE9iamVjdC5rZXlzKHVzZXJQcm92aWRlZEZpZWxkcykuZm9yRWFjaChmaWVsZCA9PiB7XG4gICAgICAgICAgICBpZiAoaXNTdWJwYXRoKGtleSwgZmllbGQpKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBmaWVsZHNbZmllbGRdO1xuICAgICAgICAgICAgICBkZWxldGUgdXNlclByb3ZpZGVkRmllbGRzW2ZpZWxkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhhcmcpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXJnW2tleXNbaV1dO1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBmaWVsZHNba2V5XSA9IHNhbml0aXplVmFsdWUodmFsdWUpO1xuICAgICAgICB1c2VyUHJvdmlkZWRGaWVsZHNba2V5XSA9IHNhbml0aXplVmFsdWUodmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzZWxlY3QoKSBhcmd1bWVudC4gTXVzdCBiZSBzdHJpbmcgb3Igb2JqZWN0LicpO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBNb25nb0RCIG5vZGVzIGZyb20gd2hpY2ggdG8gcmVhZC5cbiAqXG4gKiAjIyMjIFByZWZlcmVuY2VzOlxuICpcbiAqIGBgYFxuICogcHJpbWFyeSAtIChkZWZhdWx0KSBSZWFkIGZyb20gcHJpbWFyeSBvbmx5LiBPcGVyYXRpb25zIHdpbGwgcHJvZHVjZSBhbiBlcnJvciBpZiBwcmltYXJ5IGlzIHVuYXZhaWxhYmxlLiBDYW5ub3QgYmUgY29tYmluZWQgd2l0aCB0YWdzLlxuICogc2Vjb25kYXJ5ICAgICAgICAgICAgUmVhZCBmcm9tIHNlY29uZGFyeSBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBlcnJvci5cbiAqIHByaW1hcnlQcmVmZXJyZWQgICAgIFJlYWQgZnJvbSBwcmltYXJ5IGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGEgc2Vjb25kYXJ5LlxuICogc2Vjb25kYXJ5UHJlZmVycmVkICAgUmVhZCBmcm9tIGEgc2Vjb25kYXJ5IGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHJlYWQgZnJvbSB0aGUgcHJpbWFyeS5cbiAqIG5lYXJlc3QgICAgICAgICAgICAgIEFsbCBvcGVyYXRpb25zIHJlYWQgZnJvbSBhbW9uZyB0aGUgbmVhcmVzdCBjYW5kaWRhdGVzLCBidXQgdW5saWtlIG90aGVyIG1vZGVzLCB0aGlzIG9wdGlvbiB3aWxsIGluY2x1ZGUgYm90aCB0aGUgcHJpbWFyeSBhbmQgYWxsIHNlY29uZGFyaWVzIGluIHRoZSByYW5kb20gc2VsZWN0aW9uLlxuICogYGBgXG4gKlxuICogQWxpYXNlc1xuICpcbiAqIGBgYFxuICogcCAgIHByaW1hcnlcbiAqIHBwICBwcmltYXJ5UHJlZmVycmVkXG4gKiBzICAgc2Vjb25kYXJ5XG4gKiBzcCAgc2Vjb25kYXJ5UHJlZmVycmVkXG4gKiBuICAgbmVhcmVzdFxuICogYGBgXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdwcmltYXJ5JylcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdwJykgIC8vIHNhbWUgYXMgcHJpbWFyeVxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdwcmltYXJ5UHJlZmVycmVkJylcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdwcCcpIC8vIHNhbWUgYXMgcHJpbWFyeVByZWZlcnJlZFxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdzZWNvbmRhcnknKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWQoJ3MnKSAgLy8gc2FtZSBhcyBzZWNvbmRhcnlcbiAqXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZCgnc2Vjb25kYXJ5UHJlZmVycmVkJylcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdzcCcpIC8vIHNhbWUgYXMgc2Vjb25kYXJ5UHJlZmVycmVkXG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnJlYWQoJ25lYXJlc3QnKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWQoJ24nKSAgLy8gc2FtZSBhcyBuZWFyZXN0XG4gKlxuICogICAgIC8vIHJlYWQgZnJvbSBzZWNvbmRhcmllcyB3aXRoIG1hdGNoaW5nIHRhZ3NcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkKCdzJywgW3sgZGM6J3NmJywgczogMSB9LHsgZGM6J21hJywgczogMiB9XSlcbiAqXG4gKiBSZWFkIG1vcmUgYWJvdXQgaG93IHRvIHVzZSByZWFkIHByZWZlcmVuY2VzIFtoZXJlXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9hcHBsaWNhdGlvbnMvcmVwbGljYXRpb24vI3JlYWQtcHJlZmVyZW5jZSkuXG4gKlxuICogQG1ldGhvZCByZWFkXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IG1vZGUgb25lIG9mIHRoZSBsaXN0ZWQgcHJlZmVyZW5jZSBvcHRpb25zIG9yIGFsaWFzZXNcbiAqIEBwYXJhbSB7QXJyYXl9IFt0YWdzXSBvcHRpb25hbCB0YWdzIGZvciB0aGlzIHF1ZXJ5XG4gKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvYXBwbGljYXRpb25zL3JlcGxpY2F0aW9uLyNyZWFkLXByZWZlcmVuY2VcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gcmVhZChtb2RlLCB0YWdzKSB7XG4gIGlmICh0eXBlb2YgbW9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICBtb2RlID0gaGFuZGxlUmVhZFByZWZlcmVuY2VBbGlhc2VzKG1vZGUpO1xuICAgIHRoaXMub3B0aW9ucy5yZWFkUHJlZmVyZW5jZSA9IHsgbW9kZSwgdGFncyB9O1xuICB9IGVsc2Uge1xuICAgIHRoaXMub3B0aW9ucy5yZWFkUHJlZmVyZW5jZSA9IG1vZGU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE92ZXJ3cml0ZSBkZWZhdWx0IGAudG9TdHJpbmdgIHRvIG1ha2UgbG9nZ2luZyBtb3JlIHVzZWZ1bFxuICpcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAbWV0aG9kIHRvU3RyaW5nXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgaWYgKHRoaXMub3AgPT09ICdjb3VudCcgfHxcbiAgICAgIHRoaXMub3AgPT09ICdjb3VudERvY3VtZW50cycgfHxcbiAgICAgIHRoaXMub3AgPT09ICdmaW5kJyB8fFxuICAgICAgdGhpcy5vcCA9PT0gJ2ZpbmRPbmUnIHx8XG4gICAgICB0aGlzLm9wID09PSAnZGVsZXRlTWFueScgfHxcbiAgICAgIHRoaXMub3AgPT09ICdkZWxldGVPbmUnIHx8XG4gICAgICB0aGlzLm9wID09PSAnZmluZE9uZUFuZERlbGV0ZScgfHxcbiAgICAgIHRoaXMub3AgPT09ICdyZW1vdmUnKSB7XG4gICAgcmV0dXJuIGAke3RoaXMubW9kZWwubW9kZWxOYW1lfS4ke3RoaXMub3B9KCR7dXRpbC5pbnNwZWN0KHRoaXMuX2NvbmRpdGlvbnMpfSlgO1xuICB9XG4gIGlmICh0aGlzLm9wID09PSAnZGlzdGluY3QnKSB7XG4gICAgcmV0dXJuIGAke3RoaXMubW9kZWwubW9kZWxOYW1lfS5kaXN0aW5jdCgnJHt0aGlzLl9kaXN0aW5jdH0nLCAke3V0aWwuaW5zcGVjdCh0aGlzLl9jb25kaXRpb25zKX0pYDtcbiAgfVxuICBpZiAodGhpcy5vcCA9PT0gJ2ZpbmRPbmVBbmRSZXBsYWNlJyB8fFxuICAgICAgdGhpcy5vcCA9PT0gJ2ZpbmRPbmVBbmRVcGRhdGUnIHx8XG4gICAgICB0aGlzLm9wID09PSAncmVwbGFjZU9uZScgfHxcbiAgICAgIHRoaXMub3AgPT09ICd1cGRhdGUnIHx8XG4gICAgICB0aGlzLm9wID09PSAndXBkYXRlTWFueScgfHxcbiAgICAgIHRoaXMub3AgPT09ICd1cGRhdGVPbmUnKSB7XG4gICAgcmV0dXJuIGAke3RoaXMubW9kZWwubW9kZWxOYW1lfS4ke3RoaXMub3B9KCR7dXRpbC5pbnNwZWN0KHRoaXMuX2NvbmRpdGlvbnMpfSwgJHt1dGlsLmluc3BlY3QodGhpcy5fdXBkYXRlKX0pYDtcbiAgfVxuXG4gIC8vICdlc3RpbWF0ZWREb2N1bWVudENvdW50JyBvciBhbnkgb3RoZXJzXG4gIHJldHVybiBgJHt0aGlzLm1vZGVsLm1vZGVsTmFtZX0uJHt0aGlzLm9wfSgpYDtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgW01vbmdvREIgc2Vzc2lvbl0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3NlcnZlci1zZXNzaW9ucy8pXG4gKiBhc3NvY2lhdGVkIHdpdGggdGhpcyBxdWVyeS4gU2Vzc2lvbnMgYXJlIGhvdyB5b3UgbWFyayBhIHF1ZXJ5IGFzIHBhcnQgb2YgYVxuICogW3RyYW5zYWN0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHJhbnNhY3Rpb25zLmh0bWwpLlxuICpcbiAqIENhbGxpbmcgYHNlc3Npb24obnVsbClgIHJlbW92ZXMgdGhlIHNlc3Npb24gZnJvbSB0aGlzIHF1ZXJ5LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcyA9IGF3YWl0IG1vbmdvb3NlLnN0YXJ0U2Vzc2lvbigpO1xuICogICAgIGF3YWl0IG1vbmdvb3NlLm1vZGVsKCdQZXJzb24nKS5maW5kT25lKHsgbmFtZTogJ0F4bCBSb3NlJyB9KS5zZXNzaW9uKHMpO1xuICpcbiAqIEBtZXRob2Qgc2Vzc2lvblxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7Q2xpZW50U2Vzc2lvbn0gW3Nlc3Npb25dIGZyb20gYGF3YWl0IGNvbm4uc3RhcnRTZXNzaW9uKClgXG4gKiBAc2VlIENvbm5lY3Rpb24ucHJvdG90eXBlLnN0YXJ0U2Vzc2lvbigpIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvY29ubmVjdGlvbi5odG1sI0Nvbm5lY3Rpb24ucHJvdG90eXBlLnN0YXJ0U2Vzc2lvbigpXG4gKiBAc2VlIG1vbmdvb3NlLnN0YXJ0U2Vzc2lvbigpIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9uZ29vc2UuaHRtbCNNb25nb29zZS5wcm90b3R5cGUuc3RhcnRTZXNzaW9uKClcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5zZXNzaW9uID0gZnVuY3Rpb24gc2Vzc2lvbih2KSB7XG4gIGlmICh2ID09IG51bGwpIHtcbiAgICBkZWxldGUgdGhpcy5vcHRpb25zLnNlc3Npb247XG4gIH1cbiAgdGhpcy5vcHRpb25zLnNlc3Npb24gPSB2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgMyB3cml0ZSBjb25jZXJuIHBhcmFtZXRlcnMgZm9yIHRoaXMgcXVlcnk6XG4gKlxuICogLSBgd2A6IFNldHMgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgYG1vbmdvZGAgc2VydmVycywgb3IgdGFnIHNldCBvZiBgbW9uZ29kYCBzZXJ2ZXJzLCB0aGF0IG11c3QgYWNrbm93bGVkZ2UgdGhpcyB3cml0ZSBiZWZvcmUgdGhpcyB3cml0ZSBpcyBjb25zaWRlcmVkIHN1Y2Nlc3NmdWwuXG4gKiAtIGBqYDogQm9vbGVhbiwgc2V0IHRvIGB0cnVlYCB0byByZXF1ZXN0IGFja25vd2xlZGdlbWVudCB0aGF0IHRoaXMgb3BlcmF0aW9uIGhhcyBiZWVuIHBlcnNpc3RlZCB0byBNb25nb0RCJ3Mgb24tZGlzayBqb3VybmFsLlxuICogLSBgd3RpbWVvdXRgOiBJZiBbYHcgPiAxYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS53KCkpLCB0aGUgbWF4aW11bSBhbW91bnQgb2YgdGltZSB0byB3YWl0IGZvciB0aGlzIHdyaXRlIHRvIHByb3BhZ2F0ZSB0aHJvdWdoIHRoZSByZXBsaWNhIHNldCBiZWZvcmUgdGhpcyBvcGVyYXRpb24gZmFpbHMuIFRoZSBkZWZhdWx0IGlzIGAwYCwgd2hpY2ggbWVhbnMgbm8gdGltZW91dC5cbiAqXG4gKiBUaGlzIG9wdGlvbiBpcyBvbmx5IHZhbGlkIGZvciBvcGVyYXRpb25zIHRoYXQgd3JpdGUgdG8gdGhlIGRhdGFiYXNlOlxuICpcbiAqIC0gYGRlbGV0ZU9uZSgpYFxuICogLSBgZGVsZXRlTWFueSgpYFxuICogLSBgZmluZE9uZUFuZERlbGV0ZSgpYFxuICogLSBgZmluZE9uZUFuZFJlcGxhY2UoKWBcbiAqIC0gYGZpbmRPbmVBbmRVcGRhdGUoKWBcbiAqIC0gYHVwZGF0ZU9uZSgpYFxuICogLSBgdXBkYXRlTWFueSgpYFxuICpcbiAqIERlZmF1bHRzIHRvIHRoZSBzY2hlbWEncyBbYHdyaXRlQ29uY2VybmAgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN3cml0ZUNvbmNlcm4pXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBUaGUgJ21ham9yaXR5JyBvcHRpb24gbWVhbnMgdGhlIGBkZWxldGVPbmUoKWAgcHJvbWlzZSB3b24ndCByZXNvbHZlXG4gKiAgICAgLy8gdW50aWwgdGhlIGBkZWxldGVPbmUoKWAgaGFzIHByb3BhZ2F0ZWQgdG8gdGhlIG1ham9yaXR5IG9mIHRoZSByZXBsaWNhIHNldFxuICogICAgIGF3YWl0IG1vbmdvb3NlLm1vZGVsKCdQZXJzb24nKS5cbiAqICAgICAgIGRlbGV0ZU9uZSh7IG5hbWU6ICdOZWQgU3RhcmsnIH0pLlxuICogICAgICAgd3JpdGVDb25jZXJuKHsgdzogJ21ham9yaXR5JyB9KTtcbiAqXG4gKiBAbWV0aG9kIHdyaXRlQ29uY2VyblxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSB3cml0ZUNvbmNlcm4gdGhlIHdyaXRlIGNvbmNlcm4gdmFsdWUgdG8gc2V0XG4gKiBAc2VlIFdyaXRlQ29uY2VyblNldHRpbmdzIGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvaW50ZXJmYWNlcy9Xcml0ZUNvbmNlcm5TZXR0aW5ncy5odG1sXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUud3JpdGVDb25jZXJuID0gZnVuY3Rpb24gd3JpdGVDb25jZXJuKHZhbCkge1xuICBpZiAodmFsID09IG51bGwpIHtcbiAgICBkZWxldGUgdGhpcy5vcHRpb25zLndyaXRlQ29uY2VybjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0aGlzLm9wdGlvbnMud3JpdGVDb25jZXJuID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBgbW9uZ29kYCBzZXJ2ZXJzLCBvciB0YWcgc2V0IG9mIGBtb25nb2RgIHNlcnZlcnMsXG4gKiB0aGF0IG11c3QgYWNrbm93bGVkZ2UgdGhpcyB3cml0ZSBiZWZvcmUgdGhpcyB3cml0ZSBpcyBjb25zaWRlcmVkIHN1Y2Nlc3NmdWwuXG4gKiBUaGlzIG9wdGlvbiBpcyBvbmx5IHZhbGlkIGZvciBvcGVyYXRpb25zIHRoYXQgd3JpdGUgdG8gdGhlIGRhdGFiYXNlOlxuICpcbiAqIC0gYGRlbGV0ZU9uZSgpYFxuICogLSBgZGVsZXRlTWFueSgpYFxuICogLSBgZmluZE9uZUFuZERlbGV0ZSgpYFxuICogLSBgZmluZE9uZUFuZFJlcGxhY2UoKWBcbiAqIC0gYGZpbmRPbmVBbmRVcGRhdGUoKWBcbiAqIC0gYHVwZGF0ZU9uZSgpYFxuICogLSBgdXBkYXRlTWFueSgpYFxuICpcbiAqIERlZmF1bHRzIHRvIHRoZSBzY2hlbWEncyBbYHdyaXRlQ29uY2Vybi53YCBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3dyaXRlQ29uY2VybilcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIFRoZSAnbWFqb3JpdHknIG9wdGlvbiBtZWFucyB0aGUgYGRlbGV0ZU9uZSgpYCBwcm9taXNlIHdvbid0IHJlc29sdmVcbiAqICAgICAvLyB1bnRpbCB0aGUgYGRlbGV0ZU9uZSgpYCBoYXMgcHJvcGFnYXRlZCB0byB0aGUgbWFqb3JpdHkgb2YgdGhlIHJlcGxpY2Egc2V0XG4gKiAgICAgYXdhaXQgbW9uZ29vc2UubW9kZWwoJ1BlcnNvbicpLlxuICogICAgICAgZGVsZXRlT25lKHsgbmFtZTogJ05lZCBTdGFyaycgfSkuXG4gKiAgICAgICB3KCdtYWpvcml0eScpO1xuICpcbiAqIEBtZXRob2Qgd1xuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfG51bWJlcn0gdmFsIDAgZm9yIGZpcmUtYW5kLWZvcmdldCwgMSBmb3IgYWNrbm93bGVkZ2VkIGJ5IG9uZSBzZXJ2ZXIsICdtYWpvcml0eScgZm9yIG1ham9yaXR5IG9mIHRoZSByZXBsaWNhIHNldCwgb3IgW2FueSBvZiB0aGUgbW9yZSBhZHZhbmNlZCBvcHRpb25zXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvd3JpdGUtY29uY2Vybi8jdy1vcHRpb24pLlxuICogQHNlZSBtb25nb2RiIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLyN3LW9wdGlvblxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLncgPSBmdW5jdGlvbiB3KHZhbCkge1xuICBpZiAodmFsID09IG51bGwpIHtcbiAgICBkZWxldGUgdGhpcy5vcHRpb25zLnc7XG4gIH1cbiAgaWYgKHRoaXMub3B0aW9ucy53cml0ZUNvbmNlcm4gIT0gbnVsbCkge1xuICAgIHRoaXMub3B0aW9ucy53cml0ZUNvbmNlcm4udyA9IHZhbDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9wdGlvbnMudyA9IHZhbDtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVxdWVzdHMgYWNrbm93bGVkZ2VtZW50IHRoYXQgdGhpcyBvcGVyYXRpb24gaGFzIGJlZW4gcGVyc2lzdGVkIHRvIE1vbmdvREInc1xuICogb24tZGlzayBqb3VybmFsLlxuICogVGhpcyBvcHRpb24gaXMgb25seSB2YWxpZCBmb3Igb3BlcmF0aW9ucyB0aGF0IHdyaXRlIHRvIHRoZSBkYXRhYmFzZTpcbiAqXG4gKiAtIGBkZWxldGVPbmUoKWBcbiAqIC0gYGRlbGV0ZU1hbnkoKWBcbiAqIC0gYGZpbmRPbmVBbmREZWxldGUoKWBcbiAqIC0gYGZpbmRPbmVBbmRSZXBsYWNlKClgXG4gKiAtIGBmaW5kT25lQW5kVXBkYXRlKClgXG4gKiAtIGB1cGRhdGVPbmUoKWBcbiAqIC0gYHVwZGF0ZU1hbnkoKWBcbiAqXG4gKiBEZWZhdWx0cyB0byB0aGUgc2NoZW1hJ3MgW2B3cml0ZUNvbmNlcm4uamAgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN3cml0ZUNvbmNlcm4pXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhd2FpdCBtb25nb29zZS5tb2RlbCgnUGVyc29uJykuZGVsZXRlT25lKHsgbmFtZTogJ05lZCBTdGFyaycgfSkuaih0cnVlKTtcbiAqXG4gKiBAbWV0aG9kIGpcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZhbFxuICogQHNlZSBtb25nb2RiIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLyNqLW9wdGlvblxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmogPSBmdW5jdGlvbiBqKHZhbCkge1xuICBpZiAodmFsID09IG51bGwpIHtcbiAgICBkZWxldGUgdGhpcy5vcHRpb25zLmo7XG4gIH1cbiAgaWYgKHRoaXMub3B0aW9ucy53cml0ZUNvbmNlcm4gIT0gbnVsbCkge1xuICAgIHRoaXMub3B0aW9ucy53cml0ZUNvbmNlcm4uaiA9IHZhbDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9wdGlvbnMuaiA9IHZhbDtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSWYgW2B3ID4gMWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUudygpKSwgdGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUgdG9cbiAqIHdhaXQgZm9yIHRoaXMgd3JpdGUgdG8gcHJvcGFnYXRlIHRocm91Z2ggdGhlIHJlcGxpY2Egc2V0IGJlZm9yZSB0aGlzXG4gKiBvcGVyYXRpb24gZmFpbHMuIFRoZSBkZWZhdWx0IGlzIGAwYCwgd2hpY2ggbWVhbnMgbm8gdGltZW91dC5cbiAqXG4gKiBUaGlzIG9wdGlvbiBpcyBvbmx5IHZhbGlkIGZvciBvcGVyYXRpb25zIHRoYXQgd3JpdGUgdG8gdGhlIGRhdGFiYXNlOlxuICpcbiAqIC0gYGRlbGV0ZU9uZSgpYFxuICogLSBgZGVsZXRlTWFueSgpYFxuICogLSBgZmluZE9uZUFuZERlbGV0ZSgpYFxuICogLSBgZmluZE9uZUFuZFJlcGxhY2UoKWBcbiAqIC0gYGZpbmRPbmVBbmRVcGRhdGUoKWBcbiAqIC0gYHVwZGF0ZU9uZSgpYFxuICogLSBgdXBkYXRlTWFueSgpYFxuICpcbiAqIERlZmF1bHRzIHRvIHRoZSBzY2hlbWEncyBbYHdyaXRlQ29uY2Vybi53dGltZW91dGAgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN3cml0ZUNvbmNlcm4pXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBUaGUgYGRlbGV0ZU9uZSgpYCBwcm9taXNlIHdvbid0IHJlc29sdmUgdW50aWwgdGhpcyBgZGVsZXRlT25lKClgIGhhc1xuICogICAgIC8vIHByb3BhZ2F0ZWQgdG8gYXQgbGVhc3QgYHcgPSAyYCBtZW1iZXJzIG9mIHRoZSByZXBsaWNhIHNldC4gSWYgaXQgdGFrZXNcbiAqICAgICAvLyBsb25nZXIgdGhhbiAxIHNlY29uZCwgdGhpcyBgZGVsZXRlT25lKClgIHdpbGwgZmFpbC5cbiAqICAgICBhd2FpdCBtb25nb29zZS5tb2RlbCgnUGVyc29uJykuXG4gKiAgICAgICBkZWxldGVPbmUoeyBuYW1lOiAnTmVkIFN0YXJrJyB9KS5cbiAqICAgICAgIHcoMikuXG4gKiAgICAgICB3dGltZW91dCgxMDAwKTtcbiAqXG4gKiBAbWV0aG9kIHd0aW1lb3V0XG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtudW1iZXJ9IG1zIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdFxuICogQHNlZSBtb25nb2RiIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLyN3dGltZW91dFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnd0aW1lb3V0ID0gZnVuY3Rpb24gd3RpbWVvdXQobXMpIHtcbiAgaWYgKG1zID09IG51bGwpIHtcbiAgICBkZWxldGUgdGhpcy5vcHRpb25zLnd0aW1lb3V0O1xuICB9XG4gIGlmICh0aGlzLm9wdGlvbnMud3JpdGVDb25jZXJuICE9IG51bGwpIHtcbiAgICB0aGlzLm9wdGlvbnMud3JpdGVDb25jZXJuLnd0aW1lb3V0ID0gbXM7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vcHRpb25zLnd0aW1lb3V0ID0gbXM7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHJlYWRDb25jZXJuIG9wdGlvbiBmb3IgdGhlIHF1ZXJ5LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZENvbmNlcm4oJ2xvY2FsJylcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkQ29uY2VybignbCcpICAvLyBzYW1lIGFzIGxvY2FsXG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnJlYWRDb25jZXJuKCdhdmFpbGFibGUnKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWRDb25jZXJuKCdhJykgIC8vIHNhbWUgYXMgYXZhaWxhYmxlXG4gKlxuICogICAgIG5ldyBRdWVyeSgpLnJlYWRDb25jZXJuKCdtYWpvcml0eScpXG4gKiAgICAgbmV3IFF1ZXJ5KCkucmVhZENvbmNlcm4oJ20nKSAgLy8gc2FtZSBhcyBtYWpvcml0eVxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkQ29uY2VybignbGluZWFyaXphYmxlJylcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkQ29uY2VybignbHonKSAvLyBzYW1lIGFzIGxpbmVhcml6YWJsZVxuICpcbiAqICAgICBuZXcgUXVlcnkoKS5yZWFkQ29uY2Vybignc25hcHNob3QnKVxuICogICAgIG5ldyBRdWVyeSgpLnJlYWRDb25jZXJuKCdzJykgIC8vIHNhbWUgYXMgc25hcHNob3RcbiAqXG4gKlxuICogIyMjIyBSZWFkIENvbmNlcm4gTGV2ZWw6XG4gKlxuICogYGBgXG4gKiBsb2NhbCAgICAgICAgIE1vbmdvREIgMy4yKyBUaGUgcXVlcnkgcmV0dXJucyBmcm9tIHRoZSBpbnN0YW5jZSB3aXRoIG5vIGd1YXJhbnRlZSBndWFyYW50ZWUgdGhhdCB0aGUgZGF0YSBoYXMgYmVlbiB3cml0dGVuIHRvIGEgbWFqb3JpdHkgb2YgdGhlIHJlcGxpY2Egc2V0IG1lbWJlcnMgKGkuZS4gbWF5IGJlIHJvbGxlZCBiYWNrKS5cbiAqIGF2YWlsYWJsZSAgICAgTW9uZ29EQiAzLjYrIFRoZSBxdWVyeSByZXR1cm5zIGZyb20gdGhlIGluc3RhbmNlIHdpdGggbm8gZ3VhcmFudGVlIGd1YXJhbnRlZSB0aGF0IHRoZSBkYXRhIGhhcyBiZWVuIHdyaXR0ZW4gdG8gYSBtYWpvcml0eSBvZiB0aGUgcmVwbGljYSBzZXQgbWVtYmVycyAoaS5lLiBtYXkgYmUgcm9sbGVkIGJhY2spLlxuICogbWFqb3JpdHkgICAgICBNb25nb0RCIDMuMisgVGhlIHF1ZXJ5IHJldHVybnMgdGhlIGRhdGEgdGhhdCBoYXMgYmVlbiBhY2tub3dsZWRnZWQgYnkgYSBtYWpvcml0eSBvZiB0aGUgcmVwbGljYSBzZXQgbWVtYmVycy4gVGhlIGRvY3VtZW50cyByZXR1cm5lZCBieSB0aGUgcmVhZCBvcGVyYXRpb24gYXJlIGR1cmFibGUsIGV2ZW4gaW4gdGhlIGV2ZW50IG9mIGZhaWx1cmUuXG4gKiBsaW5lYXJpemFibGUgIE1vbmdvREIgMy40KyBUaGUgcXVlcnkgcmV0dXJucyBkYXRhIHRoYXQgcmVmbGVjdHMgYWxsIHN1Y2Nlc3NmdWwgbWFqb3JpdHktYWNrbm93bGVkZ2VkIHdyaXRlcyB0aGF0IGNvbXBsZXRlZCBwcmlvciB0byB0aGUgc3RhcnQgb2YgdGhlIHJlYWQgb3BlcmF0aW9uLiBUaGUgcXVlcnkgbWF5IHdhaXQgZm9yIGNvbmN1cnJlbnRseSBleGVjdXRpbmcgd3JpdGVzIHRvIHByb3BhZ2F0ZSB0byBhIG1ham9yaXR5IG9mIHJlcGxpY2Egc2V0IG1lbWJlcnMgYmVmb3JlIHJldHVybmluZyByZXN1bHRzLlxuICogc25hcHNob3QgICAgICBNb25nb0RCIDQuMCsgT25seSBhdmFpbGFibGUgZm9yIG9wZXJhdGlvbnMgd2l0aGluIG11bHRpLWRvY3VtZW50IHRyYW5zYWN0aW9ucy4gVXBvbiB0cmFuc2FjdGlvbiBjb21taXQgd2l0aCB3cml0ZSBjb25jZXJuIFwibWFqb3JpdHlcIiwgdGhlIHRyYW5zYWN0aW9uIG9wZXJhdGlvbnMgYXJlIGd1YXJhbnRlZWQgdG8gaGF2ZSByZWFkIGZyb20gYSBzbmFwc2hvdCBvZiBtYWpvcml0eS1jb21taXR0ZWQgZGF0YS5cbiAqIGBgYFxuICpcbiAqIEFsaWFzZXNcbiAqXG4gKiBgYGBcbiAqIGwgICBsb2NhbFxuICogYSAgIGF2YWlsYWJsZVxuICogbSAgIG1ham9yaXR5XG4gKiBseiAgbGluZWFyaXphYmxlXG4gKiBzICAgc25hcHNob3RcbiAqIGBgYFxuICpcbiAqIFJlYWQgbW9yZSBhYm91dCBob3cgdG8gdXNlIHJlYWQgY29uY2VybiBbaGVyZV0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3JlYWQtY29uY2Vybi8pLlxuICpcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQG1ldGhvZCByZWFkQ29uY2VyblxuICogQHBhcmFtIHtTdHJpbmd9IGxldmVsIG9uZSBvZiB0aGUgbGlzdGVkIHJlYWQgY29uY2VybiBsZXZlbCBvciB0aGVpciBhbGlhc2VzXG4gKiBAc2VlIG1vbmdvZGIgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3JlYWQtY29uY2Vybi9cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogR2V0cyBxdWVyeSBvcHRpb25zLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcXVlcnkgPSBuZXcgUXVlcnkoKTtcbiAqICAgICBxdWVyeS5saW1pdCgxMCk7XG4gKiAgICAgcXVlcnkuc2V0T3B0aW9ucyh7IG1heFRpbWVNUzogMTAwMCB9KTtcbiAqICAgICBxdWVyeS5nZXRPcHRpb25zKCk7IC8vIHsgbGltaXQ6IDEwLCBtYXhUaW1lTVM6IDEwMDAgfVxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmdldE9wdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMub3B0aW9ucztcbn07XG5cbi8qKlxuICogU2V0cyBxdWVyeSBvcHRpb25zLiBTb21lIG9wdGlvbnMgb25seSBtYWtlIHNlbnNlIGZvciBjZXJ0YWluIG9wZXJhdGlvbnMuXG4gKlxuICogIyMjIyBPcHRpb25zOlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgb3B0aW9ucyBhcmUgb25seSBmb3IgYGZpbmQoKWA6XG4gKlxuICogLSBbdGFpbGFibGVdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL2NvcmUvdGFpbGFibGUtY3Vyc29ycy8pXG4gKiAtIFtsaW1pdF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9jdXJzb3IubGltaXQvKVxuICogLSBbc2tpcF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9jdXJzb3Iuc2tpcC8pXG4gKiAtIFthbGxvd0Rpc2tVc2VdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvY3Vyc29yLmFsbG93RGlza1VzZS8pXG4gKiAtIFtiYXRjaFNpemVdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvY3Vyc29yLmJhdGNoU2l6ZS8pXG4gKiAtIFtyZWFkUHJlZmVyZW5jZV0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvYXBwbGljYXRpb25zL3JlcGxpY2F0aW9uLyNyZWFkLXByZWZlcmVuY2UpXG4gKiAtIFtoaW50XShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL2N1cnNvci5oaW50LylcbiAqIC0gW2NvbW1lbnRdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvY3Vyc29yLmNvbW1lbnQvKVxuICpcbiAqIFRoZSBmb2xsb3dpbmcgb3B0aW9ucyBhcmUgb25seSBmb3Igd3JpdGUgb3BlcmF0aW9uczogYHVwZGF0ZU9uZSgpYCwgYHVwZGF0ZU1hbnkoKWAsIGByZXBsYWNlT25lKClgLCBgZmluZE9uZUFuZFVwZGF0ZSgpYCwgYW5kIGBmaW5kQnlJZEFuZFVwZGF0ZSgpYDpcbiAqXG4gKiAtIFt1cHNlcnRdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvZGIuY29sbGVjdGlvbi51cGRhdGUvKVxuICogLSBbd3JpdGVDb25jZXJuXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL2RiLmNvbGxlY3Rpb24udXBkYXRlLylcbiAqIC0gW3RpbWVzdGFtcHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3RpbWVzdGFtcHMpOiBJZiBgdGltZXN0YW1wc2AgaXMgc2V0IGluIHRoZSBzY2hlbWEsIHNldCB0aGlzIG9wdGlvbiB0byBgZmFsc2VgIHRvIHNraXAgdGltZXN0YW1wcyBmb3IgdGhhdCBwYXJ0aWN1bGFyIHVwZGF0ZS4gSGFzIG5vIGVmZmVjdCBpZiBgdGltZXN0YW1wc2AgaXMgbm90IGVuYWJsZWQgaW4gdGhlIHNjaGVtYSBvcHRpb25zLlxuICogLSBvdmVyd3JpdGVEaXNjcmltaW5hdG9yS2V5OiBhbGxvdyBzZXR0aW5nIHRoZSBkaXNjcmltaW5hdG9yIGtleSBpbiB0aGUgdXBkYXRlLiBXaWxsIHVzZSB0aGUgY29ycmVjdCBkaXNjcmltaW5hdG9yIHNjaGVtYSBpZiB0aGUgdXBkYXRlIGNoYW5nZXMgdGhlIGRpc2NyaW1pbmF0b3Iga2V5LlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgb3B0aW9ucyBhcmUgb25seSBmb3IgYGZpbmQoKWAsIGBmaW5kT25lKClgLCBgZmluZEJ5SWQoKWAsIGBmaW5kT25lQW5kVXBkYXRlKClgLCBgZmluZE9uZUFuZFJlcGxhY2UoKWAsIGBmaW5kT25lQW5kRGVsZXRlKClgLCBhbmQgYGZpbmRCeUlkQW5kVXBkYXRlKClgOlxuICpcbiAqIC0gW2xlYW5dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUubGVhbigpKVxuICogLSBbcG9wdWxhdGVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9wb3B1bGF0ZS5odG1sKVxuICogLSBbcHJvamVjdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5wcm9qZWN0aW9uKCkpXG4gKiAtIHNhbml0aXplUHJvamVjdGlvblxuICogLSB1c2VCaWdJbnQ2NFxuICpcbiAqIFRoZSBmb2xsb3dpbmcgb3B0aW9ucyBhcmUgb25seSBmb3IgYWxsIG9wZXJhdGlvbnMgKipleGNlcHQqKiBgdXBkYXRlT25lKClgLCBgdXBkYXRlTWFueSgpYCwgYGRlbGV0ZU9uZSgpYCwgYW5kIGBkZWxldGVNYW55KClgOlxuICpcbiAqIC0gW21heFRpbWVNU10oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL21ldGEvbWF4VGltZU1TLylcbiAqXG4gKiBUaGUgZm9sbG93aW5nIG9wdGlvbnMgYXJlIGZvciBgZmluZCgpYCwgYGZpbmRPbmUoKWAsIGBmaW5kT25lQW5kVXBkYXRlKClgLCBgZmluZE9uZUFuZERlbGV0ZSgpYCwgYHVwZGF0ZU9uZSgpYCwgYW5kIGBkZWxldGVPbmUoKWA6XG4gKlxuICogLSBbc29ydF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9jdXJzb3Iuc29ydC8pXG4gKlxuICogVGhlIGZvbGxvd2luZyBvcHRpb25zIGFyZSBmb3IgYGZpbmRPbmVBbmRVcGRhdGUoKWAgYW5kIGBmaW5kT25lQW5kRGVsZXRlKClgXG4gKlxuICogLSBpbmNsdWRlUmVzdWx0TWV0YWRhdGFcbiAqXG4gKiBUaGUgZm9sbG93aW5nIG9wdGlvbnMgYXJlIGZvciBhbGwgb3BlcmF0aW9uczpcbiAqXG4gKiAtIFtzdHJpY3RdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdClcbiAqIC0gW2NvbGxhdGlvbl0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2NvbGxhdGlvbi8pXG4gKiAtIFtzZXNzaW9uXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvc2VydmVyLXNlc3Npb25zLylcbiAqIC0gW2V4cGxhaW5dKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvY3Vyc29yLmV4cGxhaW4vKVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMsIG92ZXJ3cml0ZSkge1xuICAvLyBvdmVyd3JpdGUgaXMgb25seSBmb3IgaW50ZXJuYWwgdXNlXG4gIGlmIChvdmVyd3JpdGUpIHtcbiAgICAvLyBlbnN1cmUgdGhhdCBfbW9uZ29vc2VPcHRpb25zICYgb3B0aW9ucyBhcmUgdHdvIGRpZmZlcmVudCBvYmplY3RzXG4gICAgdGhpcy5fbW9uZ29vc2VPcHRpb25zID0gKG9wdGlvbnMgJiYgY2xvbmUob3B0aW9ucykpIHx8IHt9O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAoJ3BvcHVsYXRlJyBpbiBvcHRpb25zKSB7XG4gICAgICB0aGlzLnBvcHVsYXRlKHRoaXMuX21vbmdvb3NlT3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0LCBnb3QgXCInICsgb3B0aW9ucyArICdcIicpO1xuICB9XG5cbiAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMucG9wdWxhdGUpKSB7XG4gICAgY29uc3QgcG9wdWxhdGUgPSBvcHRpb25zLnBvcHVsYXRlO1xuICAgIGRlbGV0ZSBvcHRpb25zLnBvcHVsYXRlO1xuICAgIGNvbnN0IF9udW1Qb3B1bGF0ZSA9IHBvcHVsYXRlLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IF9udW1Qb3B1bGF0ZTsgKytpKSB7XG4gICAgICB0aGlzLnBvcHVsYXRlKHBvcHVsYXRlW2ldKTtcbiAgICB9XG4gIH1cblxuICBpZiAoJ3NldERlZmF1bHRzT25JbnNlcnQnIGluIG9wdGlvbnMpIHtcbiAgICB0aGlzLl9tb25nb29zZU9wdGlvbnMuc2V0RGVmYXVsdHNPbkluc2VydCA9IG9wdGlvbnMuc2V0RGVmYXVsdHNPbkluc2VydDtcbiAgICBkZWxldGUgb3B0aW9ucy5zZXREZWZhdWx0c09uSW5zZXJ0O1xuICB9XG4gIGlmICgnb3ZlcndyaXRlRGlzY3JpbWluYXRvcktleScgaW4gb3B0aW9ucykge1xuICAgIHRoaXMuX21vbmdvb3NlT3B0aW9ucy5vdmVyd3JpdGVEaXNjcmltaW5hdG9yS2V5ID0gb3B0aW9ucy5vdmVyd3JpdGVEaXNjcmltaW5hdG9yS2V5O1xuICAgIGRlbGV0ZSBvcHRpb25zLm92ZXJ3cml0ZURpc2NyaW1pbmF0b3JLZXk7XG4gIH1cbiAgaWYgKCdzYW5pdGl6ZVByb2plY3Rpb24nIGluIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5zYW5pdGl6ZVByb2plY3Rpb24gJiYgIXRoaXMuX21vbmdvb3NlT3B0aW9ucy5zYW5pdGl6ZVByb2plY3Rpb24pIHtcbiAgICAgIHNhbml0aXplUHJvamVjdGlvbih0aGlzLl9maWVsZHMpO1xuICAgIH1cblxuICAgIHRoaXMuX21vbmdvb3NlT3B0aW9ucy5zYW5pdGl6ZVByb2plY3Rpb24gPSBvcHRpb25zLnNhbml0aXplUHJvamVjdGlvbjtcbiAgICBkZWxldGUgb3B0aW9ucy5zYW5pdGl6ZVByb2plY3Rpb247XG4gIH1cbiAgaWYgKCdzYW5pdGl6ZUZpbHRlcicgaW4gb3B0aW9ucykge1xuICAgIHRoaXMuX21vbmdvb3NlT3B0aW9ucy5zYW5pdGl6ZUZpbHRlciA9IG9wdGlvbnMuc2FuaXRpemVGaWx0ZXI7XG4gICAgZGVsZXRlIG9wdGlvbnMuc2FuaXRpemVGaWx0ZXI7XG4gIH1cbiAgaWYgKCd0aW1lc3RhbXBzJyBpbiBvcHRpb25zKSB7XG4gICAgdGhpcy5fbW9uZ29vc2VPcHRpb25zLnRpbWVzdGFtcHMgPSBvcHRpb25zLnRpbWVzdGFtcHM7XG4gICAgZGVsZXRlIG9wdGlvbnMudGltZXN0YW1wcztcbiAgfVxuICBpZiAoJ2RlZmF1bHRzJyBpbiBvcHRpb25zKSB7XG4gICAgdGhpcy5fbW9uZ29vc2VPcHRpb25zLmRlZmF1bHRzID0gb3B0aW9ucy5kZWZhdWx0cztcbiAgICAvLyBkZWxldGluZyBvcHRpb25zLmRlZmF1bHRzIHdpbGwgY2F1c2UgNzI4NyB0byBmYWlsXG4gIH1cbiAgaWYgKCd0cmFuc2xhdGVBbGlhc2VzJyBpbiBvcHRpb25zKSB7XG4gICAgdGhpcy5fbW9uZ29vc2VPcHRpb25zLnRyYW5zbGF0ZUFsaWFzZXMgPSBvcHRpb25zLnRyYW5zbGF0ZUFsaWFzZXM7XG4gICAgZGVsZXRlIG9wdGlvbnMudHJhbnNsYXRlQWxpYXNlcztcbiAgfVxuXG4gIGlmIChvcHRpb25zLmxlYW4gPT0gbnVsbCAmJiB0aGlzLnNjaGVtYSAmJiAnbGVhbicgaW4gdGhpcy5zY2hlbWEub3B0aW9ucykge1xuICAgIHRoaXMuX21vbmdvb3NlT3B0aW9ucy5sZWFuID0gdGhpcy5zY2hlbWEub3B0aW9ucy5sZWFuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmxpbWl0ID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICBvcHRpb25zLmxpbWl0ID0gY2FzdE51bWJlcihvcHRpb25zLmxpbWl0KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJ051bWJlcicsIG9wdGlvbnMubGltaXQsICdsaW1pdCcpO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIG9wdGlvbnMuc2tpcCA9PT0gJ3N0cmluZycpIHtcbiAgICB0cnkge1xuICAgICAgb3B0aW9ucy5za2lwID0gY2FzdE51bWJlcihvcHRpb25zLnNraXApO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IENhc3RFcnJvcignTnVtYmVyJywgb3B0aW9ucy5za2lwLCAnc2tpcCcpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBhcmJpdHJhcnkgb3B0aW9uc1xuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvcHRpb25zKSkge1xuICAgIGlmIChxdWVyeU9wdGlvbk1ldGhvZHMuaGFzKGtleSkpIHtcbiAgICAgIGNvbnN0IGFyZ3MgPSBBcnJheS5pc0FycmF5KG9wdGlvbnNba2V5XSkgP1xuICAgICAgICBvcHRpb25zW2tleV0gOlxuICAgICAgICBbb3B0aW9uc1trZXldXTtcbiAgICAgIHRoaXNba2V5XS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIFtgZXhwbGFpbmAgb3B0aW9uXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL2N1cnNvci5leHBsYWluLyksXG4gKiB3aGljaCBtYWtlcyB0aGlzIHF1ZXJ5IHJldHVybiBkZXRhaWxlZCBleGVjdXRpb24gc3RhdHMgaW5zdGVhZCBvZiB0aGUgYWN0dWFsXG4gKiBxdWVyeSByZXN1bHQuIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bCBmb3IgZGV0ZXJtaW5pbmcgd2hhdCBpbmRleCB5b3VyIHF1ZXJpZXNcbiAqIHVzZS5cbiAqXG4gKiBDYWxsaW5nIGBxdWVyeS5leHBsYWluKHYpYCBpcyBlcXVpdmFsZW50IHRvIGBxdWVyeS5zZXRPcHRpb25zKHsgZXhwbGFpbjogdiB9KWBcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFF1ZXJ5KCk7XG4gKiAgICAgY29uc3QgcmVzID0gYXdhaXQgcXVlcnkuZmluZCh7IGE6IDEgfSkuZXhwbGFpbigncXVlcnlQbGFubmVyJyk7XG4gKiAgICAgY29uc29sZS5sb2cocmVzKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3ZlcmJvc2VdIFRoZSB2ZXJib3NpdHkgbW9kZS4gRWl0aGVyICdxdWVyeVBsYW5uZXInLCAnZXhlY3V0aW9uU3RhdHMnLCBvciAnYWxsUGxhbnNFeGVjdXRpb24nLiBUaGUgZGVmYXVsdCBpcyAncXVlcnlQbGFubmVyJ1xuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmV4cGxhaW4gPSBmdW5jdGlvbiBleHBsYWluKHZlcmJvc2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLm9wdGlvbnMuZXhwbGFpbiA9IHRydWU7XG4gIH0gZWxzZSBpZiAodmVyYm9zZSA9PT0gZmFsc2UpIHtcbiAgICBkZWxldGUgdGhpcy5vcHRpb25zLmV4cGxhaW47XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vcHRpb25zLmV4cGxhaW4gPSB2ZXJib3NlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBbYGFsbG93RGlza1VzZWAgb3B0aW9uXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL2N1cnNvci5hbGxvd0Rpc2tVc2UvKSxcbiAqIHdoaWNoIGFsbG93cyB0aGUgTW9uZ29EQiBzZXJ2ZXIgdG8gdXNlIG1vcmUgdGhhbiAxMDAgTUIgZm9yIHRoaXMgcXVlcnkncyBgc29ydCgpYC4gVGhpcyBvcHRpb24gY2FuXG4gKiBsZXQgeW91IHdvcmsgYXJvdW5kIGBRdWVyeUV4Y2VlZGVkTWVtb3J5TGltaXROb0Rpc2tVc2VBbGxvd2VkYCBlcnJvcnMgZnJvbSB0aGUgTW9uZ29EQiBzZXJ2ZXIuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgb3B0aW9uIHJlcXVpcmVzIE1vbmdvREIgc2VydmVyID49IDQuNC4gU2V0dGluZyB0aGlzIG9wdGlvbiBpcyBhIG5vLW9wIGZvciBNb25nb0RCIDQuMlxuICogYW5kIGVhcmxpZXIuXG4gKlxuICogQ2FsbGluZyBgcXVlcnkuYWxsb3dEaXNrVXNlKHYpYCBpcyBlcXVpdmFsZW50IHRvIGBxdWVyeS5zZXRPcHRpb25zKHsgYWxsb3dEaXNrVXNlOiB2IH0pYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYXdhaXQgcXVlcnkuZmluZCgpLnNvcnQoeyBuYW1lOiAxIH0pLmFsbG93RGlza1VzZSh0cnVlKTtcbiAqICAgICAvLyBFcXVpdmFsZW50OlxuICogICAgIGF3YWl0IHF1ZXJ5LmZpbmQoKS5zb3J0KHsgbmFtZTogMSB9KS5hbGxvd0Rpc2tVc2UoKTtcbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFt2XSBFbmFibGUvZGlzYWJsZSBgYWxsb3dEaXNrVXNlYC4gSWYgY2FsbGVkIHdpdGggMCBhcmd1bWVudHMsIHNldHMgYGFsbG93RGlza1VzZTogdHJ1ZWBcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5hbGxvd0Rpc2tVc2UgPSBmdW5jdGlvbih2KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5vcHRpb25zLmFsbG93RGlza1VzZSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodiA9PT0gZmFsc2UpIHtcbiAgICBkZWxldGUgdGhpcy5vcHRpb25zLmFsbG93RGlza1VzZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9wdGlvbnMuYWxsb3dEaXNrVXNlID0gdjtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgW21heFRpbWVNU10oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9jdXJzb3IubWF4VGltZU1TLylcbiAqIG9wdGlvbi4gVGhpcyB3aWxsIHRlbGwgdGhlIE1vbmdvREIgc2VydmVyIHRvIGFib3J0IGlmIHRoZSBxdWVyeSBvciB3cml0ZSBvcFxuICogaGFzIGJlZW4gcnVubmluZyBmb3IgbW9yZSB0aGFuIGBtc2AgbWlsbGlzZWNvbmRzLlxuICpcbiAqIENhbGxpbmcgYHF1ZXJ5Lm1heFRpbWVNUyh2KWAgaXMgZXF1aXZhbGVudCB0byBgcXVlcnkuc2V0T3B0aW9ucyh7IG1heFRpbWVNUzogdiB9KWBcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFF1ZXJ5KCk7XG4gKiAgICAgLy8gVGhyb3dzIGFuIGVycm9yICdvcGVyYXRpb24gZXhjZWVkZWQgdGltZSBsaW1pdCcgYXMgbG9uZyBhcyB0aGVyZSdzXG4gKiAgICAgLy8gPj0gMSBkb2MgaW4gdGhlIHF1ZXJpZWQgY29sbGVjdGlvblxuICogICAgIGNvbnN0IHJlcyA9IGF3YWl0IHF1ZXJ5LmZpbmQoeyAkd2hlcmU6ICdzbGVlcCgxMDAwKSB8fCB0cnVlJyB9KS5tYXhUaW1lTVMoMTAwKTtcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gW21zXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kc1xuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLm1heFRpbWVNUyA9IGZ1bmN0aW9uKG1zKSB7XG4gIHRoaXMub3B0aW9ucy5tYXhUaW1lTVMgPSBtcztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgcXVlcnkgZmlsdGVyIChhbHNvIGtub3duIGFzIGNvbmRpdGlvbnMpIGFzIGEgW1BPSk9dKGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy9wb2pvKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFF1ZXJ5KCk7XG4gKiAgICAgcXVlcnkuZmluZCh7IGE6IDEgfSkud2hlcmUoJ2InKS5ndCgyKTtcbiAqICAgICBxdWVyeS5nZXRGaWx0ZXIoKTsgLy8geyBhOiAxLCBiOiB7ICRndDogMiB9IH1cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGN1cnJlbnQgcXVlcnkgZmlsdGVyXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5nZXRGaWx0ZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2NvbmRpdGlvbnM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgcXVlcnkgZmlsdGVyLiBFcXVpdmFsZW50IHRvIGBnZXRGaWx0ZXIoKWAuXG4gKlxuICogWW91IHNob3VsZCB1c2UgYGdldEZpbHRlcigpYCBpbnN0ZWFkIG9mIGBnZXRRdWVyeSgpYCB3aGVyZSBwb3NzaWJsZS4gYGdldFF1ZXJ5KClgXG4gKiB3aWxsIGxpa2VseSBiZSBkZXByZWNhdGVkIGluIGEgZnV0dXJlIHJlbGVhc2UuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBxdWVyeSA9IG5ldyBRdWVyeSgpO1xuICogICAgIHF1ZXJ5LmZpbmQoeyBhOiAxIH0pLndoZXJlKCdiJykuZ3QoMik7XG4gKiAgICAgcXVlcnkuZ2V0UXVlcnkoKTsgLy8geyBhOiAxLCBiOiB7ICRndDogMiB9IH1cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGN1cnJlbnQgcXVlcnkgZmlsdGVyXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5nZXRRdWVyeSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY29uZGl0aW9ucztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgcXVlcnkgY29uZGl0aW9ucyB0byB0aGUgcHJvdmlkZWQgSlNPTiBvYmplY3QuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBxdWVyeSA9IG5ldyBRdWVyeSgpO1xuICogICAgIHF1ZXJ5LmZpbmQoeyBhOiAxIH0pXG4gKiAgICAgcXVlcnkuc2V0UXVlcnkoeyBhOiAyIH0pO1xuICogICAgIHF1ZXJ5LmdldFF1ZXJ5KCk7IC8vIHsgYTogMiB9XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG5ldyBxdWVyeSBjb25kaXRpb25zXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5zZXRRdWVyeSA9IGZ1bmN0aW9uKHZhbCkge1xuICB0aGlzLl9jb25kaXRpb25zID0gdmFsO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHVwZGF0ZSBvcGVyYXRpb25zIGFzIGEgSlNPTiBvYmplY3QuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBxdWVyeSA9IG5ldyBRdWVyeSgpO1xuICogICAgIHF1ZXJ5LnVwZGF0ZU9uZSh7fSwgeyAkc2V0OiB7IGE6IDUgfSB9KTtcbiAqICAgICBxdWVyeS5nZXRVcGRhdGUoKTsgLy8geyAkc2V0OiB7IGE6IDUgfSB9XG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBjdXJyZW50IHVwZGF0ZSBvcGVyYXRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5nZXRVcGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3VwZGF0ZTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY3VycmVudCB1cGRhdGUgb3BlcmF0aW9uIHRvIG5ldyB2YWx1ZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFF1ZXJ5KCk7XG4gKiAgICAgcXVlcnkudXBkYXRlT25lKHt9LCB7ICRzZXQ6IHsgYTogNSB9IH0pO1xuICogICAgIHF1ZXJ5LnNldFVwZGF0ZSh7ICRzZXQ6IHsgYjogNiB9IH0pO1xuICogICAgIHF1ZXJ5LmdldFVwZGF0ZSgpOyAvLyB7ICRzZXQ6IHsgYjogNiB9IH1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbmV3IHVwZGF0ZSBvcGVyYXRpb25cbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNldFVwZGF0ZSA9IGZ1bmN0aW9uKHZhbCkge1xuICB0aGlzLl91cGRhdGUgPSB2YWw7XG59O1xuXG4vKipcbiAqIFJldHVybnMgZmllbGRzIHNlbGVjdGlvbiBmb3IgdGhpcyBxdWVyeS5cbiAqXG4gKiBAbWV0aG9kIF9maWVsZHNGb3JFeGVjXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5fZmllbGRzRm9yRXhlYyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fZmllbGRzID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoT2JqZWN0LmtleXModGhpcy5fZmllbGRzKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY2xvbmUodGhpcy5fZmllbGRzKTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gYW4gdXBkYXRlIGRvY3VtZW50IHdpdGggY29ycmVjdGVkIGAkc2V0YCBvcGVyYXRpb25zLlxuICpcbiAqIEBtZXRob2QgX3VwZGF0ZUZvckV4ZWNcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl91cGRhdGVGb3JFeGVjID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IHVwZGF0ZSA9IGNsb25lKHRoaXMuX3VwZGF0ZSwge1xuICAgIHRyYW5zZm9ybTogZmFsc2UsXG4gICAgZGVwb3B1bGF0ZTogdHJ1ZVxuICB9KTtcbiAgY29uc3Qgb3BzID0gT2JqZWN0LmtleXModXBkYXRlKTtcbiAgbGV0IGkgPSBvcHMubGVuZ3RoO1xuICBjb25zdCByZXQgPSB7fTtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgY29uc3Qgb3AgPSBvcHNbaV07XG5cbiAgICBpZiAoJyQnICE9PSBvcFswXSkge1xuICAgICAgLy8gZml4IHVwICRzZXQgc3VnYXJcbiAgICAgIGlmICghcmV0LiRzZXQpIHtcbiAgICAgICAgaWYgKHVwZGF0ZS4kc2V0KSB7XG4gICAgICAgICAgcmV0LiRzZXQgPSB1cGRhdGUuJHNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQuJHNldCA9IHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXQuJHNldFtvcF0gPSB1cGRhdGVbb3BdO1xuICAgICAgb3BzLnNwbGljZShpLCAxKTtcbiAgICAgIGlmICghfm9wcy5pbmRleE9mKCckc2V0JykpIG9wcy5wdXNoKCckc2V0Jyk7XG4gICAgfSBlbHNlIGlmICgnJHNldCcgPT09IG9wKSB7XG4gICAgICBpZiAoIXJldC4kc2V0KSB7XG4gICAgICAgIHJldFtvcF0gPSB1cGRhdGVbb3BdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXRbb3BdID0gdXBkYXRlW29wXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBNYWtlcyBzdXJlIF9wYXRoIGlzIHNldC5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBpbmhlcml0ZWQgYnkgYG1xdWVyeWBcbiAqXG4gKiBAbWV0aG9kIF9lbnN1cmVQYXRoXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gKiBAYXBpIHByaXZhdGVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICovXG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBgY29uZHNgIGNhbiBiZSBtZXJnZWQgdXNpbmcgYG1xdWVyeSgpLm1lcmdlKClgXG4gKlxuICogQG1ldGhvZCBjYW5NZXJnZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25kc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbi8qKlxuICogUmV0dXJucyBkZWZhdWx0IG9wdGlvbnMgZm9yIHRoaXMgcXVlcnkuXG4gKlxuICogQHBhcmFtIHtNb2RlbH0gbW9kZWxcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5fb3B0aW9uc0ZvckV4ZWMgPSBmdW5jdGlvbihtb2RlbCkge1xuICBjb25zdCBvcHRpb25zID0gY2xvbmUodGhpcy5vcHRpb25zKTtcbiAgZGVsZXRlIG9wdGlvbnMucG9wdWxhdGU7XG4gIG1vZGVsID0gbW9kZWwgfHwgdGhpcy5tb2RlbDtcblxuICBpZiAoIW1vZGVsKSB7XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cbiAgLy8gQXBwbHkgc2NoZW1hLWxldmVsIGB3cml0ZUNvbmNlcm5gIG9wdGlvblxuICBhcHBseVdyaXRlQ29uY2Vybihtb2RlbC5zY2hlbWEsIG9wdGlvbnMpO1xuXG4gIGNvbnN0IHJlYWRQcmVmZXJlbmNlID0gbW9kZWwgJiZcbiAgbW9kZWwuc2NoZW1hICYmXG4gIG1vZGVsLnNjaGVtYS5vcHRpb25zICYmXG4gIG1vZGVsLnNjaGVtYS5vcHRpb25zLnJlYWQ7XG4gIGlmICghKCdyZWFkUHJlZmVyZW5jZScgaW4gb3B0aW9ucykgJiYgcmVhZFByZWZlcmVuY2UpIHtcbiAgICBvcHRpb25zLnJlYWRQcmVmZXJlbmNlID0gcmVhZFByZWZlcmVuY2U7XG4gIH1cblxuICBpZiAob3B0aW9ucy51cHNlcnQgIT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMudXBzZXJ0ID0gISFvcHRpb25zLnVwc2VydDtcbiAgfVxuICBpZiAob3B0aW9ucy53cml0ZUNvbmNlcm4pIHtcbiAgICBpZiAob3B0aW9ucy5qKSB7XG4gICAgICBvcHRpb25zLndyaXRlQ29uY2Vybi5qID0gb3B0aW9ucy5qO1xuICAgICAgZGVsZXRlIG9wdGlvbnMuajtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudykge1xuICAgICAgb3B0aW9ucy53cml0ZUNvbmNlcm4udyA9IG9wdGlvbnMudztcbiAgICAgIGRlbGV0ZSBvcHRpb25zLnc7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnd0aW1lb3V0KSB7XG4gICAgICBvcHRpb25zLndyaXRlQ29uY2Vybi53dGltZW91dCA9IG9wdGlvbnMud3RpbWVvdXQ7XG4gICAgICBkZWxldGUgb3B0aW9ucy53dGltZW91dDtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9hcHBseVBhdGhzKCk7XG4gIGlmICh0aGlzLl9maWVsZHMgIT0gbnVsbCkge1xuICAgIHRoaXMuX2ZpZWxkcyA9IHRoaXMuX2Nhc3RGaWVsZHModGhpcy5fZmllbGRzKTtcbiAgICBjb25zdCBwcm9qZWN0aW9uID0gdGhpcy5fZmllbGRzRm9yRXhlYygpO1xuICAgIGlmIChwcm9qZWN0aW9uICE9IG51bGwpIHtcbiAgICAgIG9wdGlvbnMucHJvamVjdGlvbiA9IHByb2plY3Rpb247XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGxlYW4gb3B0aW9uLlxuICpcbiAqIERvY3VtZW50cyByZXR1cm5lZCBmcm9tIHF1ZXJpZXMgd2l0aCB0aGUgYGxlYW5gIG9wdGlvbiBlbmFibGVkIGFyZSBwbGFpblxuICogamF2YXNjcmlwdCBvYmplY3RzLCBub3QgW01vbmdvb3NlIERvY3VtZW50c10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sKS4gVGhleSBoYXZlIG5vXG4gKiBgc2F2ZWAgbWV0aG9kLCBnZXR0ZXJzL3NldHRlcnMsIHZpcnR1YWxzLCBvciBvdGhlciBNb25nb29zZSBmZWF0dXJlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIG5ldyBRdWVyeSgpLmxlYW4oKSAvLyB0cnVlXG4gKiAgICAgbmV3IFF1ZXJ5KCkubGVhbih0cnVlKVxuICogICAgIG5ldyBRdWVyeSgpLmxlYW4oZmFsc2UpXG4gKlxuICogICAgIGNvbnN0IGRvY3MgPSBhd2FpdCBNb2RlbC5maW5kKCkubGVhbigpO1xuICogICAgIGRvY3NbMF0gaW5zdGFuY2VvZiBtb25nb29zZS5Eb2N1bWVudDsgLy8gZmFsc2VcbiAqXG4gKiBbTGVhbiBpcyBncmVhdCBmb3IgaGlnaC1wZXJmb3JtYW5jZSwgcmVhZC1vbmx5IGNhc2VzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHV0b3JpYWxzL2xlYW4uaHRtbCksXG4gKiBlc3BlY2lhbGx5IHdoZW4gY29tYmluZWRcbiAqIHdpdGggW2N1cnNvcnNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9xdWVyaWVzLmh0bWwjc3RyZWFtaW5nKS5cbiAqXG4gKiBJZiB5b3UgbmVlZCB2aXJ0dWFscywgZ2V0dGVycy9zZXR0ZXJzLCBvciBkZWZhdWx0cyB3aXRoIGBsZWFuKClgLCB5b3UgbmVlZFxuICogdG8gdXNlIGEgcGx1Z2luLiBTZWU6XG4gKlxuICogLSBbbW9uZ29vc2UtbGVhbi12aXJ0dWFsc10oaHR0cHM6Ly9wbHVnaW5zLm1vbmdvb3NlanMuaW8vcGx1Z2lucy9sZWFuLXZpcnR1YWxzKVxuICogLSBbbW9uZ29vc2UtbGVhbi1nZXR0ZXJzXShodHRwczovL3BsdWdpbnMubW9uZ29vc2Vqcy5pby9wbHVnaW5zL2xlYW4tZ2V0dGVycylcbiAqIC0gW21vbmdvb3NlLWxlYW4tZGVmYXVsdHNdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21vbmdvb3NlLWxlYW4tZGVmYXVsdHMpXG4gKlxuICogQHBhcmFtIHtCb29sZWFufE9iamVjdH0gYm9vbCBkZWZhdWx0cyB0byB0cnVlXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUubGVhbiA9IGZ1bmN0aW9uKHYpIHtcbiAgdGhpcy5fbW9uZ29vc2VPcHRpb25zLmxlYW4gPSBhcmd1bWVudHMubGVuZ3RoID8gdiA6IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgYCRzZXRgIHRvIHRoaXMgcXVlcnkncyB1cGRhdGUgd2l0aG91dCBjaGFuZ2luZyB0aGUgb3BlcmF0aW9uLlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIHF1ZXJ5IG1pZGRsZXdhcmUgc28geW91IGNhbiBhZGQgYW4gdXBkYXRlIHJlZ2FyZGxlc3NcbiAqIG9mIHdoZXRoZXIgeW91IHVzZSBgdXBkYXRlT25lKClgLCBgdXBkYXRlTWFueSgpYCwgYGZpbmRPbmVBbmRVcGRhdGUoKWAsIGV0Yy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIFVwZGF0ZXMgYHsgJHNldDogeyB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkgfSB9YFxuICogICAgIG5ldyBRdWVyeSgpLnVwZGF0ZU9uZSh7fSwge30pLnNldCgndXBkYXRlZEF0JywgbmV3IERhdGUoKSk7XG4gKiAgICAgbmV3IFF1ZXJ5KCkudXBkYXRlTWFueSh7fSwge30pLnNldCh7IHVwZGF0ZWRBdDogbmV3IERhdGUoKSB9KTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHBhdGggcGF0aCBvciBvYmplY3Qgb2Yga2V5L3ZhbHVlIHBhaXJzIHRvIHNldFxuICogQHBhcmFtIHtBbnl9IFt2YWxdIHRoZSB2YWx1ZSB0byBzZXRcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihwYXRoLCB2YWwpIHtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnb2JqZWN0Jykge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwYXRoKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICB0aGlzLnNldChrZXksIHBhdGhba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdGhpcy5fdXBkYXRlID0gdGhpcy5fdXBkYXRlIHx8IHt9O1xuICBpZiAocGF0aCBpbiB0aGlzLl91cGRhdGUpIHtcbiAgICBkZWxldGUgdGhpcy5fdXBkYXRlW3BhdGhdO1xuICB9XG4gIHRoaXMuX3VwZGF0ZS4kc2V0ID0gdGhpcy5fdXBkYXRlLiRzZXQgfHwge307XG4gIHRoaXMuX3VwZGF0ZS4kc2V0W3BhdGhdID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRm9yIHVwZGF0ZSBvcGVyYXRpb25zLCByZXR1cm5zIHRoZSB2YWx1ZSBvZiBhIHBhdGggaW4gdGhlIHVwZGF0ZSdzIGAkc2V0YC5cbiAqIFVzZWZ1bCBmb3Igd3JpdGluZyBnZXR0ZXJzL3NldHRlcnMgdGhhdCBjYW4gd29yayB3aXRoIGJvdGggdXBkYXRlIG9wZXJhdGlvbnNcbiAqIGFuZCBgc2F2ZSgpYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHF1ZXJ5ID0gTW9kZWwudXBkYXRlT25lKHt9LCB7ICRzZXQ6IHsgbmFtZTogJ0plYW4tTHVjIFBpY2FyZCcgfSB9KTtcbiAqICAgICBxdWVyeS5nZXQoJ25hbWUnKTsgLy8gJ0plYW4tTHVjIFBpY2FyZCdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHBhdGggcGF0aCBvciBvYmplY3Qgb2Yga2V5L3ZhbHVlIHBhaXJzIHRvIGdldFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldChwYXRoKSB7XG4gIGNvbnN0IHVwZGF0ZSA9IHRoaXMuX3VwZGF0ZTtcbiAgaWYgKHVwZGF0ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBjb25zdCAkc2V0ID0gdXBkYXRlLiRzZXQ7XG4gIGlmICgkc2V0ID09IG51bGwpIHtcbiAgICByZXR1cm4gdXBkYXRlW3BhdGhdO1xuICB9XG5cbiAgaWYgKHV0aWxzLmhhc1VzZXJEZWZpbmVkUHJvcGVydHkodXBkYXRlLCBwYXRoKSkge1xuICAgIHJldHVybiB1cGRhdGVbcGF0aF07XG4gIH1cbiAgaWYgKHV0aWxzLmhhc1VzZXJEZWZpbmVkUHJvcGVydHkoJHNldCwgcGF0aCkpIHtcbiAgICByZXR1cm4gJHNldFtwYXRoXTtcbiAgfVxuXG4gIHJldHVybiB2b2lkIDA7XG59O1xuXG4vKipcbiAqIEdldHMvc2V0cyB0aGUgZXJyb3IgZmxhZyBvbiB0aGlzIHF1ZXJ5LiBJZiB0aGlzIGZsYWcgaXMgbm90IG51bGwgb3JcbiAqIHVuZGVmaW5lZCwgdGhlIGBleGVjKClgIHByb21pc2Ugd2lsbCByZWplY3Qgd2l0aG91dCBleGVjdXRpbmcuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBRdWVyeSgpLmVycm9yKCk7IC8vIEdldCBjdXJyZW50IGVycm9yIHZhbHVlXG4gKiAgICAgUXVlcnkoKS5lcnJvcihudWxsKTsgLy8gVW5zZXQgdGhlIGN1cnJlbnQgZXJyb3JcbiAqICAgICBRdWVyeSgpLmVycm9yKG5ldyBFcnJvcigndGVzdCcpKTsgLy8gYGV4ZWMoKWAgd2lsbCByZXNvbHZlIHdpdGggdGVzdFxuICogICAgIFNjaGVtYS5wcmUoJ2ZpbmQnLCBmdW5jdGlvbigpIHtcbiAqICAgICAgIGlmICghdGhpcy5nZXRRdWVyeSgpLnVzZXJJZCkge1xuICogICAgICAgICB0aGlzLmVycm9yKG5ldyBFcnJvcignTm90IGFsbG93ZWQgdG8gcXVlcnkgd2l0aG91dCBzZXR0aW5nIHVzZXJJZCcpKTtcbiAqICAgICAgIH1cbiAqICAgICB9KTtcbiAqXG4gKiBOb3RlIHRoYXQgcXVlcnkgY2FzdGluZyBydW5zICoqYWZ0ZXIqKiBob29rcywgc28gY2FzdCBlcnJvcnMgd2lsbCBvdmVycmlkZVxuICogY3VzdG9tIGVycm9ycy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IFRlc3RTY2hlbWEgPSBuZXcgU2NoZW1hKHsgbnVtOiBOdW1iZXIgfSk7XG4gKiAgICAgY29uc3QgVGVzdE1vZGVsID0gZGIubW9kZWwoJ1Rlc3QnLCBUZXN0U2NoZW1hKTtcbiAqICAgICBUZXN0TW9kZWwuZmluZCh7IG51bTogJ25vdCBhIG51bWJlcicgfSkuZXJyb3IobmV3IEVycm9yKCd3b29wcycpKS5leGVjKGZ1bmN0aW9uKGVycm9yKSB7XG4gKiAgICAgICAvLyBgZXJyb3JgIHdpbGwgYmUgYSBjYXN0IGVycm9yIGJlY2F1c2UgYG51bWAgZmFpbGVkIHRvIGNhc3RcbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge0Vycm9yfG51bGx9IGVyciBpZiBzZXQsIGBleGVjKClgIHdpbGwgZmFpbCBmYXN0IGJlZm9yZSBzZW5kaW5nIHRoZSBxdWVyeSB0byBNb25nb0RCXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihlcnIpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gIH1cblxuICB0aGlzLl9lcnJvciA9IGVycjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIGlnbm9yZVxuICogQG1ldGhvZCBfdW5zZXRDYXN0RXJyb3JcbiAqIEBpbnN0YW5jZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuX3Vuc2V0Q2FzdEVycm9yID0gZnVuY3Rpb24gX3Vuc2V0Q2FzdEVycm9yKCkge1xuICBpZiAodGhpcy5fZXJyb3IgIT0gbnVsbCAmJiAhKHRoaXMuX2Vycm9yIGluc3RhbmNlb2YgQ2FzdEVycm9yKSkge1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4gdGhpcy5lcnJvcihudWxsKTtcbn07XG5cbi8qKlxuICogR2V0dGVyL3NldHRlciBhcm91bmQgdGhlIGN1cnJlbnQgbW9uZ29vc2Utc3BlY2lmaWMgb3B0aW9ucyBmb3IgdGhpcyBxdWVyeVxuICogQmVsb3cgYXJlIHRoZSBjdXJyZW50IE1vbmdvb3NlLXNwZWNpZmljIG9wdGlvbnMuXG4gKlxuICogLSBgcG9wdWxhdGVgOiBhbiBhcnJheSByZXByZXNlbnRpbmcgd2hhdCBwYXRocyB3aWxsIGJlIHBvcHVsYXRlZC4gU2hvdWxkIGhhdmUgb25lIGVudHJ5IGZvciBlYWNoIGNhbGwgdG8gW2BRdWVyeS5wcm90b3R5cGUucG9wdWxhdGUoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUucG9wdWxhdGUoKSlcbiAqIC0gYGxlYW5gOiBpZiB0cnV0aHksIE1vbmdvb3NlIHdpbGwgbm90IFtoeWRyYXRlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vZGVsLmh0bWwjTW9kZWwuaHlkcmF0ZSgpKSBhbnkgZG9jdW1lbnRzIHRoYXQgYXJlIHJldHVybmVkIGZyb20gdGhpcyBxdWVyeS4gU2VlIFtgUXVlcnkucHJvdG90eXBlLmxlYW4oKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUubGVhbigpKSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqIC0gYHN0cmljdGA6IGNvbnRyb2xzIGhvdyBNb25nb29zZSBoYW5kbGVzIGtleXMgdGhhdCBhcmVuJ3QgaW4gdGhlIHNjaGVtYSBmb3IgdXBkYXRlcy4gVGhpcyBvcHRpb24gaXMgYHRydWVgIGJ5IGRlZmF1bHQsIHdoaWNoIG1lYW5zIE1vbmdvb3NlIHdpbGwgc2lsZW50bHkgc3RyaXAgYW55IHBhdGhzIGluIHRoZSB1cGRhdGUgdGhhdCBhcmVuJ3QgaW4gdGhlIHNjaGVtYS4gU2VlIHRoZSBbYHN0cmljdGAgbW9kZSBkb2NzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdHJpY3QpIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICogLSBgc3RyaWN0UXVlcnlgOiBjb250cm9scyBob3cgTW9uZ29vc2UgaGFuZGxlcyBrZXlzIHRoYXQgYXJlbid0IGluIHRoZSBzY2hlbWEgZm9yIHRoZSBxdWVyeSBgZmlsdGVyYC4gVGhpcyBvcHRpb24gaXMgYGZhbHNlYCBieSBkZWZhdWx0LCB3aGljaCBtZWFucyBNb25nb29zZSB3aWxsIGFsbG93IGBNb2RlbC5maW5kKHsgZm9vOiAnYmFyJyB9KWAgZXZlbiBpZiBgZm9vYCBpcyBub3QgaW4gdGhlIHNjaGVtYS4gU2VlIHRoZSBbYHN0cmljdFF1ZXJ5YCBkb2NzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdHJpY3RRdWVyeSkgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKiAtIGBuZWFyU3BoZXJlYDogdXNlIGAkbmVhclNwaGVyZWAgaW5zdGVhZCBvZiBgbmVhcigpYC4gU2VlIHRoZSBbYFF1ZXJ5LnByb3RvdHlwZS5uZWFyU3BoZXJlKClgIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUubmVhclNwaGVyZSgpKVxuICpcbiAqIE1vbmdvb3NlIG1haW50YWlucyBhIHNlcGFyYXRlIG9iamVjdCBmb3IgaW50ZXJuYWwgb3B0aW9ucyBiZWNhdXNlXG4gKiBNb25nb29zZSBzZW5kcyBgUXVlcnkucHJvdG90eXBlLm9wdGlvbnNgIHRvIHRoZSBNb25nb0RCIHNlcnZlciwgYW5kIHRoZVxuICogYWJvdmUgb3B0aW9ucyBhcmUgbm90IHJlbGV2YW50IGZvciB0aGUgTW9uZ29EQiBzZXJ2ZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgaWYgc3BlY2lmaWVkLCBvdmVyd3JpdGVzIHRoZSBjdXJyZW50IG9wdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLm1vbmdvb3NlT3B0aW9ucyA9IGZ1bmN0aW9uKHYpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy5fbW9uZ29vc2VPcHRpb25zID0gdjtcbiAgfVxuICByZXR1cm4gdGhpcy5fbW9uZ29vc2VPcHRpb25zO1xufTtcblxuLyoqXG4gKiBpZ25vcmVcbiAqIEBtZXRob2QgX2Nhc3RDb25kaXRpb25zXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBhcGkgcHJpdmF0ZVxuICogQGluc3RhbmNlXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl9jYXN0Q29uZGl0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICBsZXQgc2FuaXRpemVGaWx0ZXJPcHQgPSB1bmRlZmluZWQ7XG4gIGlmICh0aGlzLm1vZGVsICE9IG51bGwgJiYgdXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eSh0aGlzLm1vZGVsLmRiLm9wdGlvbnMsICdzYW5pdGl6ZUZpbHRlcicpKSB7XG4gICAgc2FuaXRpemVGaWx0ZXJPcHQgPSB0aGlzLm1vZGVsLmRiLm9wdGlvbnMuc2FuaXRpemVGaWx0ZXI7XG4gIH0gZWxzZSBpZiAodGhpcy5tb2RlbCAhPSBudWxsICYmIHV0aWxzLmhhc1VzZXJEZWZpbmVkUHJvcGVydHkodGhpcy5tb2RlbC5iYXNlLm9wdGlvbnMsICdzYW5pdGl6ZUZpbHRlcicpKSB7XG4gICAgc2FuaXRpemVGaWx0ZXJPcHQgPSB0aGlzLm1vZGVsLmJhc2Uub3B0aW9ucy5zYW5pdGl6ZUZpbHRlcjtcbiAgfSBlbHNlIHtcbiAgICBzYW5pdGl6ZUZpbHRlck9wdCA9IHRoaXMuX21vbmdvb3NlT3B0aW9ucy5zYW5pdGl6ZUZpbHRlcjtcbiAgfVxuXG4gIGlmIChzYW5pdGl6ZUZpbHRlck9wdCkge1xuICAgIHNhbml0aXplRmlsdGVyKHRoaXMuX2NvbmRpdGlvbnMpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB0aGlzLmNhc3QodGhpcy5tb2RlbCk7XG4gICAgdGhpcy5fdW5zZXRDYXN0RXJyb3IoKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhpcy5lcnJvcihlcnIpO1xuICB9XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9jYXN0QXJyYXlGaWx0ZXJzKHF1ZXJ5KSB7XG4gIHRyeSB7XG4gICAgY2FzdEFycmF5RmlsdGVycyhxdWVyeSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHF1ZXJ5LmVycm9yKGVycik7XG4gIH1cbn1cblxuLyoqXG4gKiBFeGVjdXRlIGEgYGZpbmQoKWBcbiAqXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5fZmluZCA9IGFzeW5jIGZ1bmN0aW9uIF9maW5kKCkge1xuICB0aGlzLl9jYXN0Q29uZGl0aW9ucygpO1xuXG4gIGlmICh0aGlzLmVycm9yKCkgIT0gbnVsbCkge1xuICAgIHRocm93IHRoaXMuZXJyb3IoKTtcbiAgfVxuXG4gIGNvbnN0IG1vbmdvb3NlT3B0aW9ucyA9IHRoaXMuX21vbmdvb3NlT3B0aW9ucztcbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICBjb25zdCB1c2VyUHJvdmlkZWRGaWVsZHMgPSBfdGhpcy5fdXNlclByb3ZpZGVkRmllbGRzIHx8IHt9O1xuXG4gIGFwcGx5R2xvYmFsTWF4VGltZU1TKHRoaXMub3B0aW9ucywgdGhpcy5tb2RlbC5kYi5vcHRpb25zLCB0aGlzLm1vZGVsLmJhc2Uub3B0aW9ucyk7XG4gIGFwcGx5R2xvYmFsRGlza1VzZSh0aGlzLm9wdGlvbnMsIHRoaXMubW9kZWwuZGIub3B0aW9ucywgdGhpcy5tb2RlbC5iYXNlLm9wdGlvbnMpO1xuXG4gIC8vIFNlcGFyYXRlIG9wdGlvbnMgdG8gcGFzcyBkb3duIHRvIGBjb21wbGV0ZU1hbnkoKWAgaW4gY2FzZSB3ZSBuZWVkIHRvXG4gIC8vIHNldCBhIHNlc3Npb24gb24gdGhlIGRvY3VtZW50XG4gIGNvbnN0IGNvbXBsZXRlTWFueU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB7XG4gICAgc2Vzc2lvbjogdGhpcyAmJiB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnNlc3Npb24gfHwgbnVsbCxcbiAgICBsZWFuOiBtb25nb29zZU9wdGlvbnMubGVhbiB8fCBudWxsXG4gIH0pO1xuXG4gIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zRm9yRXhlYygpO1xuXG4gIHRoaXMuX2FwcGx5VHJhbnNsYXRlQWxpYXNlcyhvcHRpb25zKTtcblxuICBjb25zdCBmaWx0ZXIgPSB0aGlzLl9jb25kaXRpb25zO1xuICBjb25zdCBmaWVsZHMgPSBvcHRpb25zLnByb2plY3Rpb247XG5cbiAgY29uc3QgY3Vyc29yID0gYXdhaXQgdGhpcy5tb25nb29zZUNvbGxlY3Rpb24uZmluZChmaWx0ZXIsIG9wdGlvbnMpO1xuICBpZiAob3B0aW9ucy5leHBsYWluKSB7XG4gICAgcmV0dXJuIGN1cnNvci5leHBsYWluKCk7XG4gIH1cblxuICBsZXQgZG9jcyA9IGF3YWl0IGN1cnNvci50b0FycmF5KCk7XG4gIGlmIChkb2NzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBkb2NzO1xuICB9XG5cbiAgaWYgKCFtb25nb29zZU9wdGlvbnMucG9wdWxhdGUpIHtcbiAgICBjb25zdCB2ZXJzaW9uS2V5ID0gX3RoaXMuc2NoZW1hLm9wdGlvbnMudmVyc2lvbktleTtcbiAgICBpZiAobW9uZ29vc2VPcHRpb25zLmxlYW4gJiYgbW9uZ29vc2VPcHRpb25zLmxlYW4udmVyc2lvbktleSA9PT0gZmFsc2UgJiYgdmVyc2lvbktleSkge1xuICAgICAgZG9jcy5mb3JFYWNoKChkb2MpID0+IHtcbiAgICAgICAgaWYgKHZlcnNpb25LZXkgaW4gZG9jKSB7XG4gICAgICAgICAgZGVsZXRlIGRvY1t2ZXJzaW9uS2V5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBtb25nb29zZU9wdGlvbnMubGVhbiA/XG4gICAgICBfY29tcGxldGVNYW55TGVhbihfdGhpcy5tb2RlbC5zY2hlbWEsIGRvY3MsIG51bGwsIGNvbXBsZXRlTWFueU9wdGlvbnMpIDpcbiAgICAgIF90aGlzLl9jb21wbGV0ZU1hbnkoZG9jcywgZmllbGRzLCB1c2VyUHJvdmlkZWRGaWVsZHMsIGNvbXBsZXRlTWFueU9wdGlvbnMpO1xuICB9XG4gIGNvbnN0IHBvcCA9IGhlbHBlcnMucHJlcGFyZVBvcHVsYXRpb25PcHRpb25zTVEoX3RoaXMsIG1vbmdvb3NlT3B0aW9ucyk7XG5cbiAgaWYgKG1vbmdvb3NlT3B0aW9ucy5sZWFuKSB7XG4gICAgcmV0dXJuIF90aGlzLm1vZGVsLnBvcHVsYXRlKGRvY3MsIHBvcCk7XG4gIH1cblxuICBkb2NzID0gYXdhaXQgX3RoaXMuX2NvbXBsZXRlTWFueShkb2NzLCBmaWVsZHMsIHVzZXJQcm92aWRlZEZpZWxkcywgY29tcGxldGVNYW55T3B0aW9ucyk7XG4gIGF3YWl0IHRoaXMubW9kZWwucG9wdWxhdGUoZG9jcywgcG9wKTtcblxuICByZXR1cm4gZG9jcztcbn07XG5cbi8qKlxuICogRmluZCBhbGwgZG9jdW1lbnRzIHRoYXQgbWF0Y2ggYHNlbGVjdG9yYC4gVGhlIHJlc3VsdCB3aWxsIGJlIGFuIGFycmF5IG9mIGRvY3VtZW50cy5cbiAqXG4gKiBJZiB0aGVyZSBhcmUgdG9vIG1hbnkgZG9jdW1lbnRzIGluIHRoZSByZXN1bHQgdG8gZml0IGluIG1lbW9yeSwgdXNlXG4gKiBbYFF1ZXJ5LnByb3RvdHlwZS5jdXJzb3IoKWBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuY3Vyc29yKCkpXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBhcnIgPSBhd2FpdCBNb3ZpZS5maW5kKHsgeWVhcjogeyAkZ3RlOiAxOTgwLCAkbHRlOiAxOTg5IH0gfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R8T2JqZWN0SWR9IFtmaWx0ZXJdIG1vbmdvZGIgZmlsdGVyLiBJZiBub3Qgc3BlY2lmaWVkLCByZXR1cm5zIGFsbCBkb2N1bWVudHMuXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKGNvbmRpdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBjb25kaXRpb25zID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ1F1ZXJ5LnByb3RvdHlwZS5maW5kKCkgbm8gbG9uZ2VyIGFjY2VwdHMgYSBjYWxsYmFjaycpO1xuICB9XG5cbiAgdGhpcy5vcCA9ICdmaW5kJztcblxuICBpZiAobXF1ZXJ5LmNhbk1lcmdlKGNvbmRpdGlvbnMpKSB7XG4gICAgdGhpcy5tZXJnZShjb25kaXRpb25zKTtcblxuICAgIHByZXBhcmVEaXNjcmltaW5hdG9yQ3JpdGVyaWEodGhpcyk7XG4gIH0gZWxzZSBpZiAoY29uZGl0aW9ucyAhPSBudWxsKSB7XG4gICAgdGhpcy5lcnJvcihuZXcgT2JqZWN0UGFyYW1ldGVyRXJyb3IoY29uZGl0aW9ucywgJ2ZpbHRlcicsICdmaW5kJykpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE1lcmdlcyBhbm90aGVyIFF1ZXJ5IG9yIGNvbmRpdGlvbnMgb2JqZWN0IGludG8gdGhpcyBvbmUuXG4gKlxuICogV2hlbiBhIFF1ZXJ5IGlzIHBhc3NlZCwgY29uZGl0aW9ucywgZmllbGQgc2VsZWN0aW9uIGFuZCBvcHRpb25zIGFyZSBtZXJnZWQuXG4gKlxuICogQHBhcmFtIHtRdWVyeXxPYmplY3R9IHNvdXJjZVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbihzb3VyY2UpIHtcbiAgaWYgKCFzb3VyY2UpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGNvbnN0IG9wdHMgPSB7IG92ZXJ3cml0ZTogdHJ1ZSB9O1xuXG4gIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBRdWVyeSkge1xuICAgIC8vIGlmIHNvdXJjZSBoYXMgYSBmZWF0dXJlLCBhcHBseSBpdCB0byBvdXJzZWx2ZXNcblxuICAgIGlmIChzb3VyY2UuX2NvbmRpdGlvbnMpIHtcbiAgICAgIG9wdHMub21pdCA9IHt9O1xuICAgICAgaWYgKHRoaXMuX2NvbmRpdGlvbnMgJiYgdGhpcy5fY29uZGl0aW9ucy4kYW5kICYmIHNvdXJjZS5fY29uZGl0aW9ucy4kYW5kKSB7XG4gICAgICAgIG9wdHMub21pdFsnJGFuZCddID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fY29uZGl0aW9ucy4kYW5kID0gdGhpcy5fY29uZGl0aW9ucy4kYW5kLmNvbmNhdChzb3VyY2UuX2NvbmRpdGlvbnMuJGFuZCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fY29uZGl0aW9ucyAmJiB0aGlzLl9jb25kaXRpb25zLiRvciAmJiBzb3VyY2UuX2NvbmRpdGlvbnMuJG9yKSB7XG4gICAgICAgIG9wdHMub21pdFsnJG9yJ10gPSB0cnVlO1xuICAgICAgICB0aGlzLl9jb25kaXRpb25zLiRvciA9IHRoaXMuX2NvbmRpdGlvbnMuJG9yLmNvbmNhdChzb3VyY2UuX2NvbmRpdGlvbnMuJG9yKTtcbiAgICAgIH1cbiAgICAgIHV0aWxzLm1lcmdlKHRoaXMuX2NvbmRpdGlvbnMsIHNvdXJjZS5fY29uZGl0aW9ucywgb3B0cyk7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZS5fZmllbGRzKSB7XG4gICAgICB0aGlzLl9maWVsZHMgfHwgKHRoaXMuX2ZpZWxkcyA9IHt9KTtcbiAgICAgIHV0aWxzLm1lcmdlKHRoaXMuX2ZpZWxkcywgc291cmNlLl9maWVsZHMsIG9wdHMpO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2Uub3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zIHx8ICh0aGlzLm9wdGlvbnMgPSB7fSk7XG4gICAgICB1dGlscy5tZXJnZSh0aGlzLm9wdGlvbnMsIHNvdXJjZS5vcHRpb25zLCBvcHRzKTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlLl91cGRhdGUpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZSB8fCAodGhpcy5fdXBkYXRlID0ge30pO1xuICAgICAgdXRpbHMubWVyZ2VDbG9uZSh0aGlzLl91cGRhdGUsIHNvdXJjZS5fdXBkYXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlLl9kaXN0aW5jdCkge1xuICAgICAgdGhpcy5fZGlzdGluY3QgPSBzb3VyY2UuX2Rpc3RpbmN0O1xuICAgIH1cblxuICAgIHV0aWxzLm1lcmdlKHRoaXMuX21vbmdvb3NlT3B0aW9ucywgc291cmNlLl9tb25nb29zZU9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gZWxzZSBpZiAodGhpcy5tb2RlbCAhPSBudWxsICYmIHNvdXJjZSBpbnN0YW5jZW9mIHRoaXMubW9kZWwuYmFzZS5UeXBlcy5PYmplY3RJZCkge1xuICAgIHV0aWxzLm1lcmdlKHRoaXMuX2NvbmRpdGlvbnMsIHsgX2lkOiBzb3VyY2UgfSwgb3B0cyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIGlmIChzb3VyY2UgJiYgc291cmNlLiRfXykge1xuICAgIHNvdXJjZSA9IHNvdXJjZS50b09iamVjdChpbnRlcm5hbFRvT2JqZWN0T3B0aW9ucyk7XG4gIH1cblxuICBvcHRzLm9taXQgPSB7fTtcbiAgaWYgKHRoaXMuX2NvbmRpdGlvbnMgJiYgdGhpcy5fY29uZGl0aW9ucy4kYW5kICYmIHNvdXJjZS4kYW5kKSB7XG4gICAgb3B0cy5vbWl0WyckYW5kJ10gPSB0cnVlO1xuICAgIHRoaXMuX2NvbmRpdGlvbnMuJGFuZCA9IHRoaXMuX2NvbmRpdGlvbnMuJGFuZC5jb25jYXQoc291cmNlLiRhbmQpO1xuICB9XG4gIGlmICh0aGlzLl9jb25kaXRpb25zICYmIHRoaXMuX2NvbmRpdGlvbnMuJG9yICYmIHNvdXJjZS4kb3IpIHtcbiAgICBvcHRzLm9taXRbJyRvciddID0gdHJ1ZTtcbiAgICB0aGlzLl9jb25kaXRpb25zLiRvciA9IHRoaXMuX2NvbmRpdGlvbnMuJG9yLmNvbmNhdChzb3VyY2UuJG9yKTtcbiAgfVxuXG4gIC8vIHBsYWluIG9iamVjdFxuICB1dGlscy5tZXJnZSh0aGlzLl9jb25kaXRpb25zLCBzb3VyY2UsIG9wdHMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgY29sbGF0aW9uIHRvIHRoaXMgb3AgKE1vbmdvREIgMy40IGFuZCB1cClcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIE1vbmdvREIgZG9jcyBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL2N1cnNvci5jb2xsYXRpb24vI2N1cnNvci5jb2xsYXRpb25cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmNvbGxhdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMgPT0gbnVsbCkge1xuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICB9XG4gIHRoaXMub3B0aW9ucy5jb2xsYXRpb24gPSB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEh5ZHJhdGUgYSBzaW5nbGUgZG9jIGZyb20gYGZpbmRPbmUoKWAsIGBmaW5kT25lQW5kVXBkYXRlKClgLCBldGMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl9jb21wbGV0ZU9uZSA9IGZ1bmN0aW9uKGRvYywgcmVzLCBjYWxsYmFjaykge1xuICBpZiAoIWRvYyAmJiAhdGhpcy5vcHRpb25zLmluY2x1ZGVSZXN1bHRNZXRhZGF0YSkge1xuICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBudWxsKTtcbiAgfVxuXG4gIGNvbnN0IG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgY29uc3QgcHJvamVjdGlvbiA9IGNsb25lKHRoaXMuX2ZpZWxkcyk7XG4gIGNvbnN0IHVzZXJQcm92aWRlZEZpZWxkcyA9IHRoaXMuX3VzZXJQcm92aWRlZEZpZWxkcyB8fCB7fTtcbiAgLy8gYHBvcHVsYXRlYCwgYGxlYW5gXG4gIGNvbnN0IG1vbmdvb3NlT3B0aW9ucyA9IHRoaXMuX21vbmdvb3NlT3B0aW9ucztcblxuICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICBpZiAoIW9wdGlvbnMubGVhbiAmJiBtb25nb29zZU9wdGlvbnMubGVhbikge1xuICAgIG9wdGlvbnMubGVhbiA9IG1vbmdvb3NlT3B0aW9ucy5sZWFuO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuZXhwbGFpbikge1xuICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBkb2MpO1xuICB9XG5cbiAgaWYgKCFtb25nb29zZU9wdGlvbnMucG9wdWxhdGUpIHtcbiAgICBjb25zdCB2ZXJzaW9uS2V5ID0gdGhpcy5zY2hlbWEub3B0aW9ucy52ZXJzaW9uS2V5O1xuICAgIGlmIChtb25nb29zZU9wdGlvbnMubGVhbiAmJiBtb25nb29zZU9wdGlvbnMubGVhbi52ZXJzaW9uS2V5ID09PSBmYWxzZSAmJiB2ZXJzaW9uS2V5KSB7XG4gICAgICBpZiAodmVyc2lvbktleSBpbiBkb2MpIHtcbiAgICAgICAgZGVsZXRlIGRvY1t2ZXJzaW9uS2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1vbmdvb3NlT3B0aW9ucy5sZWFuID9cbiAgICAgIF9jb21wbGV0ZU9uZUxlYW4obW9kZWwuc2NoZW1hLCBkb2MsIG51bGwsIHJlcywgb3B0aW9ucywgY2FsbGJhY2spIDpcbiAgICAgIGNvbXBsZXRlT25lKG1vZGVsLCBkb2MsIHJlcywgb3B0aW9ucywgcHJvamVjdGlvbiwgdXNlclByb3ZpZGVkRmllbGRzLFxuICAgICAgICBudWxsLCBjYWxsYmFjayk7XG4gIH1cblxuICBjb25zdCBwb3AgPSBoZWxwZXJzLnByZXBhcmVQb3B1bGF0aW9uT3B0aW9uc01RKHRoaXMsIHRoaXMuX21vbmdvb3NlT3B0aW9ucyk7XG4gIGlmIChtb25nb29zZU9wdGlvbnMubGVhbikge1xuICAgIHJldHVybiBtb2RlbC5wb3B1bGF0ZShkb2MsIHBvcCkudGhlbihcbiAgICAgIGRvYyA9PiB7XG4gICAgICAgIF9jb21wbGV0ZU9uZUxlYW4obW9kZWwuc2NoZW1hLCBkb2MsIG51bGwsIHJlcywgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgfSxcbiAgICAgIGVycm9yID0+IHtcbiAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgfVxuICAgICk7XG4gIH1cblxuICBjb21wbGV0ZU9uZShtb2RlbCwgZG9jLCByZXMsIG9wdGlvbnMsIHByb2plY3Rpb24sIHVzZXJQcm92aWRlZEZpZWxkcywgW10sIChlcnIsIGRvYykgPT4ge1xuICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgfVxuICAgIG1vZGVsLnBvcHVsYXRlKGRvYywgcG9wKS50aGVuKHJlcyA9PiB7IGNhbGxiYWNrKG51bGwsIHJlcyk7IH0sIGVyciA9PiB7IGNhbGxiYWNrKGVycik7IH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogR2l2ZW4gYSBtb2RlbCBhbmQgYW4gYXJyYXkgb2YgZG9jcywgaHlkcmF0ZXMgYWxsIHRoZSBkb2NzIHRvIGJlIGluc3RhbmNlc1xuICogb2YgdGhlIG1vZGVsLiBVc2VkIHRvIGluaXRpYWxpemUgZG9jcyByZXR1cm5lZCBmcm9tIHRoZSBkYiBmcm9tIGBmaW5kKClgXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZG9jc1xuICogQHBhcmFtIHtPYmplY3R9IGZpZWxkcyB0aGUgcHJvamVjdGlvbiB1c2VkLCBpbmNsdWRpbmcgYHNlbGVjdGAgZnJvbSBzY2hlbWFzXG4gKiBAcGFyYW0ge09iamVjdH0gdXNlclByb3ZpZGVkRmllbGRzIHRoZSB1c2VyLXNwZWNpZmllZCBwcm9qZWN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0cy5wb3B1bGF0ZWRdXG4gKiBAcGFyYW0ge0NsaWVudFNlc3Npb259IFtvcHRzLnNlc3Npb25dXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuX2NvbXBsZXRlTWFueSA9IGFzeW5jIGZ1bmN0aW9uIF9jb21wbGV0ZU1hbnkoZG9jcywgZmllbGRzLCB1c2VyUHJvdmlkZWRGaWVsZHMsIG9wdHMpIHtcbiAgY29uc3QgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICByZXR1cm4gUHJvbWlzZS5hbGwoZG9jcy5tYXAoZG9jID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCByYXdEb2MgPSBkb2M7XG4gICAgZG9jID0gaGVscGVycy5jcmVhdGVNb2RlbChtb2RlbCwgZG9jLCBmaWVsZHMsIHVzZXJQcm92aWRlZEZpZWxkcyk7XG4gICAgaWYgKG9wdHMuc2Vzc2lvbiAhPSBudWxsKSB7XG4gICAgICBkb2MuJHNlc3Npb24ob3B0cy5zZXNzaW9uKTtcbiAgICB9XG4gICAgZG9jLiRpbml0KHJhd0RvYywgb3B0cywgKGVycikgPT4ge1xuICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoZG9jKTtcbiAgICB9KTtcbiAgfSkpKTtcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIHRvIGV4ZWN1dGUgYSBmaW5kT25lKCkgb3BlcmF0aW9uXG4gKlxuICogQHNlZSBmaW5kT25lIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvZGIuY29sbGVjdGlvbi5maW5kT25lL1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl9maW5kT25lID0gYXN5bmMgZnVuY3Rpb24gX2ZpbmRPbmUoKSB7XG4gIHRoaXMuX2Nhc3RDb25kaXRpb25zKCk7XG5cbiAgaWYgKHRoaXMuZXJyb3IoKSkge1xuICAgIGNvbnN0IGVyciA9IHRoaXMuZXJyb3IoKTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cblxuICBhcHBseUdsb2JhbE1heFRpbWVNUyh0aGlzLm9wdGlvbnMsIHRoaXMubW9kZWwuZGIub3B0aW9ucywgdGhpcy5tb2RlbC5iYXNlLm9wdGlvbnMpO1xuICBhcHBseUdsb2JhbERpc2tVc2UodGhpcy5vcHRpb25zLCB0aGlzLm1vZGVsLmRiLm9wdGlvbnMsIHRoaXMubW9kZWwuYmFzZS5vcHRpb25zKTtcblxuICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9uc0ZvckV4ZWMoKTtcblxuICB0aGlzLl9hcHBseVRyYW5zbGF0ZUFsaWFzZXMob3B0aW9ucyk7XG5cbiAgLy8gZG9uJ3QgcGFzcyBpbiB0aGUgY29uZGl0aW9ucyBiZWNhdXNlIHdlIGFscmVhZHkgbWVyZ2VkIHRoZW0gaW5cbiAgY29uc3QgZG9jID0gYXdhaXQgdGhpcy5tb25nb29zZUNvbGxlY3Rpb24uZmluZE9uZSh0aGlzLl9jb25kaXRpb25zLCBvcHRpb25zKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB0aGlzLl9jb21wbGV0ZU9uZShkb2MsIG51bGwsIChlcnIsIHJlcykgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKHJlcyk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBEZWNsYXJlcyB0aGUgcXVlcnkgYSBmaW5kT25lIG9wZXJhdGlvbi4gV2hlbiBleGVjdXRlZCwgdGhlIGZpcnN0IGZvdW5kIGRvY3VtZW50IGlzIHBhc3NlZCB0byB0aGUgY2FsbGJhY2suXG4gKlxuICogVGhlIHJlc3VsdCBvZiB0aGUgcXVlcnkgaXMgYSBzaW5nbGUgZG9jdW1lbnQsIG9yIGBudWxsYCBpZiBubyBkb2N1bWVudCB3YXMgZm91bmQuXG4gKlxuICogKiAqTm90ZToqIGBjb25kaXRpb25zYCBpcyBvcHRpb25hbCwgYW5kIGlmIGBjb25kaXRpb25zYCBpcyBudWxsIG9yIHVuZGVmaW5lZCxcbiAqIG1vbmdvb3NlIHdpbGwgc2VuZCBhbiBlbXB0eSBgZmluZE9uZWAgY29tbWFuZCB0byBNb25nb0RCLCB3aGljaCB3aWxsIHJldHVyblxuICogYW4gYXJiaXRyYXJ5IGRvY3VtZW50LiBJZiB5b3UncmUgcXVlcnlpbmcgYnkgYF9pZGAsIHVzZSBgTW9kZWwuZmluZEJ5SWQoKWBcbiAqIGluc3RlYWQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0cmlnZ2VycyB0aGUgZm9sbG93aW5nIG1pZGRsZXdhcmUuXG4gKlxuICogLSBgZmluZE9uZSgpYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcXVlcnkgPSBLaXR0ZW4ud2hlcmUoeyBjb2xvcjogJ3doaXRlJyB9KTtcbiAqICAgICBjb25zdCBraXR0ZW4gPSBhd2FpdCBxdWVyeS5maW5kT25lKCk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtmaWx0ZXJdIG1vbmdvZGIgc2VsZWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvamVjdGlvbl0gb3B0aW9uYWwgZmllbGRzIHRvIHJldHVyblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBzZWUgW2BzZXRPcHRpb25zKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKSlcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudHJhbnNsYXRlQWxpYXNlcz1udWxsXSBJZiBzZXQgdG8gYHRydWVgLCB0cmFuc2xhdGVzIGFueSBzY2hlbWEtZGVmaW5lZCBhbGlhc2VzIGluIGBmaWx0ZXJgLCBgcHJvamVjdGlvbmAsIGB1cGRhdGVgLCBhbmQgYGRpc3RpbmN0YC4gVGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGFyZSBhbnkgY29uZmxpY3RzIHdoZXJlIGJvdGggYWxpYXMgYW5kIHJhdyBwcm9wZXJ0eSBhcmUgZGVmaW5lZCBvbiB0aGUgc2FtZSBvYmplY3QuXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSBmaW5kT25lIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvZGIuY29sbGVjdGlvbi5maW5kT25lL1xuICogQHNlZSBRdWVyeS5zZWxlY3QgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5zZWxlY3QoKVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZmluZE9uZSA9IGZ1bmN0aW9uKGNvbmRpdGlvbnMsIHByb2plY3Rpb24sIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBjb25kaXRpb25zID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgcHJvamVjdGlvbiA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBhcmd1bWVudHNbM10gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignUXVlcnkucHJvdG90eXBlLmZpbmRPbmUoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICB0aGlzLm9wID0gJ2ZpbmRPbmUnO1xuICB0aGlzLl92YWxpZGF0ZU9wKCk7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH1cblxuICBpZiAocHJvamVjdGlvbikge1xuICAgIHRoaXMuc2VsZWN0KHByb2plY3Rpb24pO1xuICB9XG5cbiAgaWYgKG1xdWVyeS5jYW5NZXJnZShjb25kaXRpb25zKSkge1xuICAgIHRoaXMubWVyZ2UoY29uZGl0aW9ucyk7XG5cbiAgICBwcmVwYXJlRGlzY3JpbWluYXRvckNyaXRlcmlhKHRoaXMpO1xuICB9IGVsc2UgaWYgKGNvbmRpdGlvbnMgIT0gbnVsbCkge1xuICAgIHRoaXMuZXJyb3IobmV3IE9iamVjdFBhcmFtZXRlckVycm9yKGNvbmRpdGlvbnMsICdmaWx0ZXInLCAnZmluZE9uZScpKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIEV4ZWN1dGUgYSBjb3VudERvY3VtZW50cyBxdWVyeVxuICpcbiAqIEBzZWUgY291bnREb2N1bWVudHMgaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0NvbGxlY3Rpb24uaHRtbCNjb3VudERvY3VtZW50c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl9jb3VudERvY3VtZW50cyA9IGFzeW5jIGZ1bmN0aW9uIF9jb3VudERvY3VtZW50cygpIHtcbiAgdHJ5IHtcbiAgICB0aGlzLmNhc3QodGhpcy5tb2RlbCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRoaXMuZXJyb3IoZXJyKTtcbiAgfVxuXG4gIGlmICh0aGlzLmVycm9yKCkpIHtcbiAgICB0aHJvdyB0aGlzLmVycm9yKCk7XG4gIH1cblxuICBhcHBseUdsb2JhbE1heFRpbWVNUyh0aGlzLm9wdGlvbnMsIHRoaXMubW9kZWwuZGIub3B0aW9ucywgdGhpcy5tb2RlbC5iYXNlLm9wdGlvbnMpO1xuICBhcHBseUdsb2JhbERpc2tVc2UodGhpcy5vcHRpb25zLCB0aGlzLm1vZGVsLmRiLm9wdGlvbnMsIHRoaXMubW9kZWwuYmFzZS5vcHRpb25zKTtcblxuICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9uc0ZvckV4ZWMoKTtcblxuICB0aGlzLl9hcHBseVRyYW5zbGF0ZUFsaWFzZXMob3B0aW9ucyk7XG5cbiAgY29uc3QgY29uZHMgPSB0aGlzLl9jb25kaXRpb25zO1xuXG4gIHJldHVybiB0aGlzLm1vbmdvb3NlQ29sbGVjdGlvbi5jb3VudERvY3VtZW50cyhjb25kcywgb3B0aW9ucyk7XG59O1xuXG4vKiFcbiAqIElmIGB0cmFuc2xhdGVBbGlhc2VzYCBvcHRpb24gaXMgc2V0LCBjYWxsIGBNb2RlbC50cmFuc2xhdGVBbGlhc2VzKClgXG4gKiBvbiB0aGUgZm9sbG93aW5nIHF1ZXJ5IHByb3BlcnRpZXM6IGZpbHRlciwgcHJvamVjdGlvbiwgdXBkYXRlLCBkaXN0aW5jdC5cbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuX2FwcGx5VHJhbnNsYXRlQWxpYXNlcyA9IGZ1bmN0aW9uIF9hcHBseVRyYW5zbGF0ZUFsaWFzZXMob3B0aW9ucykge1xuICBsZXQgYXBwbHlUcmFuc2xhdGVBbGlhc2VzID0gZmFsc2U7XG4gIGlmICgndHJhbnNsYXRlQWxpYXNlcycgaW4gdGhpcy5fbW9uZ29vc2VPcHRpb25zKSB7XG4gICAgYXBwbHlUcmFuc2xhdGVBbGlhc2VzID0gdGhpcy5fbW9uZ29vc2VPcHRpb25zLnRyYW5zbGF0ZUFsaWFzZXM7XG4gIH0gZWxzZSBpZiAodGhpcy5tb2RlbD8uc2NoZW1hPy5fdXNlclByb3ZpZGVkT3B0aW9ucz8udHJhbnNsYXRlQWxpYXNlcyAhPSBudWxsKSB7XG4gICAgYXBwbHlUcmFuc2xhdGVBbGlhc2VzID0gdGhpcy5tb2RlbC5zY2hlbWEuX3VzZXJQcm92aWRlZE9wdGlvbnMudHJhbnNsYXRlQWxpYXNlcztcbiAgfSBlbHNlIGlmICh0aGlzLm1vZGVsPy5iYXNlPy5vcHRpb25zPy50cmFuc2xhdGVBbGlhc2VzICE9IG51bGwpIHtcbiAgICBhcHBseVRyYW5zbGF0ZUFsaWFzZXMgPSB0aGlzLm1vZGVsLmJhc2Uub3B0aW9ucy50cmFuc2xhdGVBbGlhc2VzO1xuICB9XG4gIGlmICghYXBwbHlUcmFuc2xhdGVBbGlhc2VzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHRoaXMubW9kZWw/LnNjaGVtYT8uYWxpYXNlcyAmJiBPYmplY3Qua2V5cyh0aGlzLm1vZGVsLnNjaGVtYS5hbGlhc2VzKS5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy5tb2RlbC50cmFuc2xhdGVBbGlhc2VzKHRoaXMuX2NvbmRpdGlvbnMsIHRydWUpO1xuICAgIHRoaXMubW9kZWwudHJhbnNsYXRlQWxpYXNlcyhvcHRpb25zLnByb2plY3Rpb24sIHRydWUpO1xuICAgIHRoaXMubW9kZWwudHJhbnNsYXRlQWxpYXNlcyh0aGlzLl91cGRhdGUsIHRydWUpO1xuICAgIGlmICh0aGlzLl9kaXN0aW5jdCAhPSBudWxsICYmIHRoaXMubW9kZWwuc2NoZW1hLmFsaWFzZXNbdGhpcy5fZGlzdGluY3RdICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX2Rpc3RpbmN0ID0gdGhpcy5tb2RlbC5zY2hlbWEuYWxpYXNlc1t0aGlzLl9kaXN0aW5jdF07XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgYSBlc3RpbWF0ZWREb2N1bWVudENvdW50KCkgcXVlcnlcbiAqXG4gKiBAc2VlIGVzdGltYXRlZERvY3VtZW50Q291bnQgaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0NvbGxlY3Rpb24uaHRtbCNlc3RpbWF0ZWREb2N1bWVudENvdW50XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuX2VzdGltYXRlZERvY3VtZW50Q291bnQgPSBhc3luYyBmdW5jdGlvbiBfZXN0aW1hdGVkRG9jdW1lbnRDb3VudCgpIHtcbiAgaWYgKHRoaXMuZXJyb3IoKSkge1xuICAgIHRocm93IHRoaXMuZXJyb3IoKTtcbiAgfVxuXG4gIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zRm9yRXhlYygpO1xuXG4gIHJldHVybiB0aGlzLm1vbmdvb3NlQ29sbGVjdGlvbi5lc3RpbWF0ZWREb2N1bWVudENvdW50KG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhpcyBxdWVyeSBhcyBhIGBlc3RpbWF0ZWREb2N1bWVudENvdW50KClgIHF1ZXJ5LiBGYXN0ZXIgdGhhblxuICogdXNpbmcgYGNvdW50RG9jdW1lbnRzKClgIGZvciBsYXJnZSBjb2xsZWN0aW9ucyBiZWNhdXNlXG4gKiBgZXN0aW1hdGVkRG9jdW1lbnRDb3VudCgpYCB1c2VzIGNvbGxlY3Rpb24gbWV0YWRhdGEgcmF0aGVyIHRoYW4gc2Nhbm5pbmdcbiAqIHRoZSBlbnRpcmUgY29sbGVjdGlvbi5cbiAqXG4gKiBgZXN0aW1hdGVkRG9jdW1lbnRDb3VudCgpYCBkb2VzICoqbm90KiogYWNjZXB0IGEgZmlsdGVyLiBgTW9kZWwuZmluZCh7IGZvbzogYmFyIH0pLmVzdGltYXRlZERvY3VtZW50Q291bnQoKWBcbiAqIGlzIGVxdWl2YWxlbnQgdG8gYE1vZGVsLmZpbmQoKS5lc3RpbWF0ZWREb2N1bWVudENvdW50KClgXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0cmlnZ2VycyB0aGUgZm9sbG93aW5nIG1pZGRsZXdhcmUuXG4gKlxuICogLSBgZXN0aW1hdGVkRG9jdW1lbnRDb3VudCgpYFxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYXdhaXQgTW9kZWwuZmluZCgpLmVzdGltYXRlZERvY3VtZW50Q291bnQoKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIHBhc3NlZCB0cmFuc3BhcmVudGx5IHRvIHRoZSBbTW9uZ29EQiBkcml2ZXJdKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvaW50ZXJmYWNlcy9Fc3RpbWF0ZWREb2N1bWVudENvdW50T3B0aW9ucy5odG1sKVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgZXN0aW1hdGVkRG9jdW1lbnRDb3VudCBodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvQ29sbGVjdGlvbi5odG1sI2VzdGltYXRlZERvY3VtZW50Q291bnRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmVzdGltYXRlZERvY3VtZW50Q291bnQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdRdWVyeS5wcm90b3R5cGUuZXN0aW1hdGVkRG9jdW1lbnRDb3VudCgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIHRoaXMub3AgPSAnZXN0aW1hdGVkRG9jdW1lbnRDb3VudCc7XG4gIHRoaXMuX3ZhbGlkYXRlT3AoKTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMgIT0gbnVsbCkge1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhpcyBxdWVyeSBhcyBhIGBjb3VudERvY3VtZW50cygpYCBxdWVyeS4gQmVoYXZlcyBsaWtlIGBjb3VudCgpYCxcbiAqIGV4Y2VwdCBpdCBhbHdheXMgZG9lcyBhIGZ1bGwgY29sbGVjdGlvbiBzY2FuIHdoZW4gcGFzc2VkIGFuIGVtcHR5IGZpbHRlciBge31gLlxuICpcbiAqIFRoZXJlIGFyZSBhbHNvIG1pbm9yIGRpZmZlcmVuY2VzIGluIGhvdyBgY291bnREb2N1bWVudHMoKWAgaGFuZGxlc1xuICogW2Akd2hlcmVgIGFuZCBhIGNvdXBsZSBnZW9zcGF0aWFsIG9wZXJhdG9yc10oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0NvbGxlY3Rpb24uaHRtbCNjb3VudERvY3VtZW50cykuXG4gKiB2ZXJzdXMgYGNvdW50KClgLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgdGhlIGZvbGxvd2luZyBtaWRkbGV3YXJlLlxuICpcbiAqIC0gYGNvdW50RG9jdW1lbnRzKClgXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBjb3VudFF1ZXJ5ID0gbW9kZWwud2hlcmUoeyAnY29sb3InOiAnYmxhY2snIH0pLmNvdW50RG9jdW1lbnRzKCk7XG4gKlxuICogICAgIHF1ZXJ5LmNvdW50RG9jdW1lbnRzKHsgY29sb3I6ICdibGFjaycgfSkuY291bnQoKS5leGVjKCk7XG4gKlxuICogICAgIGF3YWl0IHF1ZXJ5LmNvdW50RG9jdW1lbnRzKHsgY29sb3I6ICdibGFjaycgfSk7XG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKCdjb2xvcicsICdibGFjaycpLmNvdW50RG9jdW1lbnRzKCkuZXhlYygpO1xuICpcbiAqIFRoZSBgY291bnREb2N1bWVudHMoKWAgZnVuY3Rpb24gaXMgc2ltaWxhciB0byBgY291bnQoKWAsIGJ1dCB0aGVyZSBhcmUgYVxuICogW2ZldyBvcGVyYXRvcnMgdGhhdCBgY291bnREb2N1bWVudHMoKWAgZG9lcyBub3Qgc3VwcG9ydF0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0NvbGxlY3Rpb24uaHRtbCNjb3VudERvY3VtZW50cykuXG4gKiBCZWxvdyBhcmUgdGhlIG9wZXJhdG9ycyB0aGF0IGBjb3VudCgpYCBzdXBwb3J0cyBidXQgYGNvdW50RG9jdW1lbnRzKClgIGRvZXMgbm90LFxuICogYW5kIHRoZSBzdWdnZXN0ZWQgcmVwbGFjZW1lbnQ6XG4gKlxuICogLSBgJHdoZXJlYDogW2AkZXhwcmBdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9xdWVyeS9leHByLylcbiAqIC0gYCRuZWFyYDogW2AkZ2VvV2l0aGluYF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3F1ZXJ5L2dlb1dpdGhpbi8pIHdpdGggW2AkY2VudGVyYF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3F1ZXJ5L2NlbnRlci8jb3AuX1NfY2VudGVyKVxuICogLSBgJG5lYXJTcGhlcmVgOiBbYCRnZW9XaXRoaW5gXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvcXVlcnkvZ2VvV2l0aGluLykgd2l0aCBbYCRjZW50ZXJTcGhlcmVgXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvcXVlcnkvY2VudGVyU3BoZXJlLyNvcC5fU19jZW50ZXJTcGhlcmUpXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtmaWx0ZXJdIG1vbmdvZGIgc2VsZWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIGNvdW50RG9jdW1lbnRzIGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9Db2xsZWN0aW9uLmh0bWwjY291bnREb2N1bWVudHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmNvdW50RG9jdW1lbnRzID0gZnVuY3Rpb24oY29uZGl0aW9ucywgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGNvbmRpdGlvbnMgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgIHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ1F1ZXJ5LnByb3RvdHlwZS5jb3VudERvY3VtZW50cygpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIHRoaXMub3AgPSAnY291bnREb2N1bWVudHMnO1xuICB0aGlzLl92YWxpZGF0ZU9wKCk7XG5cbiAgaWYgKG1xdWVyeS5jYW5NZXJnZShjb25kaXRpb25zKSkge1xuICAgIHRoaXMubWVyZ2UoY29uZGl0aW9ucyk7XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMgIT0gbnVsbCkge1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIGEgYGRpc3RpbmN0KClgIHF1ZXJ5XG4gKlxuICogQHNlZSBkaXN0aW5jdCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL2RiLmNvbGxlY3Rpb24uZGlzdGluY3QvXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuX19kaXN0aW5jdCA9IGFzeW5jIGZ1bmN0aW9uIF9fZGlzdGluY3QoKSB7XG4gIHRoaXMuX2Nhc3RDb25kaXRpb25zKCk7XG5cbiAgaWYgKHRoaXMuZXJyb3IoKSkge1xuICAgIHRocm93IHRoaXMuZXJyb3IoKTtcbiAgfVxuXG4gIGFwcGx5R2xvYmFsTWF4VGltZU1TKHRoaXMub3B0aW9ucywgdGhpcy5tb2RlbC5kYi5vcHRpb25zLCB0aGlzLm1vZGVsLmJhc2Uub3B0aW9ucyk7XG4gIGFwcGx5R2xvYmFsRGlza1VzZSh0aGlzLm9wdGlvbnMsIHRoaXMubW9kZWwuZGIub3B0aW9ucywgdGhpcy5tb2RlbC5iYXNlLm9wdGlvbnMpO1xuXG4gIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zRm9yRXhlYygpO1xuICB0aGlzLl9hcHBseVRyYW5zbGF0ZUFsaWFzZXMob3B0aW9ucyk7XG5cbiAgcmV0dXJuIHRoaXMubW9uZ29vc2VDb2xsZWN0aW9uLlxuICAgIGRpc3RpbmN0KHRoaXMuX2Rpc3RpbmN0LCB0aGlzLl9jb25kaXRpb25zLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogRGVjbGFyZXMgb3IgZXhlY3V0ZXMgYSBkaXN0aW5jdCgpIG9wZXJhdGlvbi5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHRyaWdnZXIgYW55IG1pZGRsZXdhcmUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBkaXN0aW5jdChmaWVsZCwgY29uZGl0aW9ucylcbiAqICAgICBkaXN0aW5jdChmaWVsZClcbiAqICAgICBkaXN0aW5jdCgpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtmaWVsZF1cbiAqIEBwYXJhbSB7T2JqZWN0fFF1ZXJ5fSBbZmlsdGVyXVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgZGlzdGluY3QgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9kYi5jb2xsZWN0aW9uLmRpc3RpbmN0L1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZGlzdGluY3QgPSBmdW5jdGlvbihmaWVsZCwgY29uZGl0aW9ucykge1xuICBpZiAodHlwZW9mIGZpZWxkID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgY29uZGl0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdRdWVyeS5wcm90b3R5cGUuZGlzdGluY3QoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICB0aGlzLm9wID0gJ2Rpc3RpbmN0JztcbiAgdGhpcy5fdmFsaWRhdGVPcCgpO1xuXG4gIGlmIChtcXVlcnkuY2FuTWVyZ2UoY29uZGl0aW9ucykpIHtcbiAgICB0aGlzLm1lcmdlKGNvbmRpdGlvbnMpO1xuXG4gICAgcHJlcGFyZURpc2NyaW1pbmF0b3JDcml0ZXJpYSh0aGlzKTtcbiAgfSBlbHNlIGlmIChjb25kaXRpb25zICE9IG51bGwpIHtcbiAgICB0aGlzLmVycm9yKG5ldyBPYmplY3RQYXJhbWV0ZXJFcnJvcihjb25kaXRpb25zLCAnZmlsdGVyJywgJ2Rpc3RpbmN0JykpO1xuICB9XG5cbiAgaWYgKGZpZWxkICE9IG51bGwpIHtcbiAgICB0aGlzLl9kaXN0aW5jdCA9IGZpZWxkO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHNvcnQgb3JkZXJcbiAqXG4gKiBJZiBhbiBvYmplY3QgaXMgcGFzc2VkLCB2YWx1ZXMgYWxsb3dlZCBhcmUgYGFzY2AsIGBkZXNjYCwgYGFzY2VuZGluZ2AsIGBkZXNjZW5kaW5nYCwgYDFgLCBhbmQgYC0xYC5cbiAqXG4gKiBJZiBhIHN0cmluZyBpcyBwYXNzZWQsIGl0IG11c3QgYmUgYSBzcGFjZSBkZWxpbWl0ZWQgbGlzdCBvZiBwYXRoIG5hbWVzLiBUaGVcbiAqIHNvcnQgb3JkZXIgb2YgZWFjaCBwYXRoIGlzIGFzY2VuZGluZyB1bmxlc3MgdGhlIHBhdGggbmFtZSBpcyBwcmVmaXhlZCB3aXRoIGAtYFxuICogd2hpY2ggd2lsbCBiZSB0cmVhdGVkIGFzIGRlc2NlbmRpbmcuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBzb3J0IGJ5IFwiZmllbGRcIiBhc2NlbmRpbmcgYW5kIFwidGVzdFwiIGRlc2NlbmRpbmdcbiAqICAgICBxdWVyeS5zb3J0KHsgZmllbGQ6ICdhc2MnLCB0ZXN0OiAtMSB9KTtcbiAqXG4gKiAgICAgLy8gZXF1aXZhbGVudFxuICogICAgIHF1ZXJ5LnNvcnQoJ2ZpZWxkIC10ZXN0Jyk7XG4gKlxuICogICAgIC8vIGFsc28gcG9zc2libGUgaXMgdG8gdXNlIGEgYXJyYXkgd2l0aCBhcnJheSBrZXktdmFsdWUgcGFpcnNcbiAqICAgICBxdWVyeS5zb3J0KFtbJ2ZpZWxkJywgJ2FzYyddXSk7XG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIENhbm5vdCBiZSB1c2VkIHdpdGggYGRpc3RpbmN0KClgXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfEFycmF5PEFycmF5PChzdHJpbmcgfCBudW1iZXIpPj59IGFyZ1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vdmVycmlkZT1mYWxzZV0gSWYgdHJ1ZSwgcmVwbGFjZSBleGlzdGluZyBzb3J0IG9wdGlvbnMgd2l0aCBgYXJnYFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgY3Vyc29yLnNvcnQgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9jdXJzb3Iuc29ydC9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbihhcmcsIG9wdGlvbnMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzb3J0KCkgdGFrZXMgYXQgbW9zdCAyIGFyZ3VtZW50cycpO1xuICB9XG4gIGlmIChvcHRpb25zICE9IG51bGwgJiYgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzb3J0KCkgb3B0aW9ucyBhcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdCBvciBudWxsaXNoJyk7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLnNvcnQgPT0gbnVsbCkge1xuICAgIHRoaXMub3B0aW9ucy5zb3J0ID0ge307XG4gIH1cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5vdmVycmlkZSkge1xuICAgIHRoaXMub3B0aW9ucy5zb3J0ID0ge307XG4gIH1cbiAgY29uc3Qgc29ydCA9IHRoaXMub3B0aW9ucy5zb3J0O1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gYXJnLmluZGV4T2YoJyAnKSA9PT0gLTEgPyBbYXJnXSA6IGFyZy5zcGxpdCgnICcpO1xuICAgIGZvciAobGV0IHByb3BlcnR5IG9mIHByb3BlcnRpZXMpIHtcbiAgICAgIGNvbnN0IGFzY2VuZCA9ICctJyA9PSBwcm9wZXJ0eVswXSA/IC0xIDogMTtcbiAgICAgIGlmIChhc2NlbmQgPT09IC0xKSB7XG4gICAgICAgIHByb3BlcnR5ID0gcHJvcGVydHkuc2xpY2UoMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3BlY2lhbFByb3BlcnRpZXMuaGFzKHByb3BlcnR5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHNvcnRbcHJvcGVydHldID0gYXNjZW5kO1xuICAgIH1cbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICBmb3IgKGNvbnN0IHBhaXIgb2YgYXJnKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFpcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzb3J0KCkgYXJndW1lbnQsIG11c3QgYmUgYXJyYXkgb2YgYXJyYXlzJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBrZXkgPSAnJyArIHBhaXJbMF07XG4gICAgICBpZiAoc3BlY2lhbFByb3BlcnRpZXMuaGFzKGtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzb3J0W2tleV0gPSBfaGFuZGxlU29ydFZhbHVlKHBhaXJbMV0sIGtleSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPSBudWxsICYmICEoYXJnIGluc3RhbmNlb2YgTWFwKSkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGFyZykpIHtcbiAgICAgIGlmIChzcGVjaWFsUHJvcGVydGllcy5oYXMoa2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHNvcnRba2V5XSA9IF9oYW5kbGVTb3J0VmFsdWUoYXJnW2tleV0sIGtleSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIE1hcCkge1xuICAgIGZvciAobGV0IGtleSBvZiBhcmcua2V5cygpKSB7XG4gICAgICBrZXkgPSAnJyArIGtleTtcbiAgICAgIGlmIChzcGVjaWFsUHJvcGVydGllcy5oYXMoa2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHNvcnRba2V5XSA9IF9oYW5kbGVTb3J0VmFsdWUoYXJnLmdldChrZXkpLCBrZXkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmcgIT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc29ydCgpIGFyZ3VtZW50LiBNdXN0IGJlIGEgc3RyaW5nLCBvYmplY3QsIGFycmF5LCBvciBtYXAuJyk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qIVxuICogQ29udmVydCBzb3J0IHZhbHVlc1xuICovXG5cbmZ1bmN0aW9uIF9oYW5kbGVTb3J0VmFsdWUodmFsLCBrZXkpIHtcbiAgaWYgKHZhbCA9PT0gMSB8fCB2YWwgPT09ICdhc2MnIHx8IHZhbCA9PT0gJ2FzY2VuZGluZycpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBpZiAodmFsID09PSAtMSB8fCB2YWwgPT09ICdkZXNjJyB8fCB2YWwgPT09ICdkZXNjZW5kaW5nJykge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZiAodmFsPy4kbWV0YSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHsgJG1ldGE6IHZhbC4kbWV0YSB9O1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc29ydCB2YWx1ZTogeyAnICsga2V5ICsgJzogJyArIHZhbCArICcgfScpO1xufVxuXG4vKipcbiAqIERlY2xhcmUgYW5kL29yIGV4ZWN1dGUgdGhpcyBxdWVyeSBhcyBhIGBkZWxldGVPbmUoKWAgb3BlcmF0aW9uLiBXb3JrcyBsaWtlXG4gKiByZW1vdmUsIGV4Y2VwdCBpdCBkZWxldGVzIGF0IG1vc3Qgb25lIGRvY3VtZW50IHJlZ2FyZGxlc3Mgb2YgdGhlIGBzaW5nbGVgXG4gKiBvcHRpb24uXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0cmlnZ2VycyBgZGVsZXRlT25lYCBtaWRkbGV3YXJlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgYXdhaXQgQ2hhcmFjdGVyLmRlbGV0ZU9uZSh7IG5hbWU6ICdFZGRhcmQgU3RhcmsnIH0pO1xuICpcbiAqIFRoaXMgZnVuY3Rpb24gY2FsbHMgdGhlIE1vbmdvREIgZHJpdmVyJ3MgW2BDb2xsZWN0aW9uI2RlbGV0ZU9uZSgpYCBmdW5jdGlvbl0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0NvbGxlY3Rpb24uaHRtbCNkZWxldGVPbmUpLlxuICogVGhlIHJldHVybmVkIFtwcm9taXNlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvcXVlcmllcy5odG1sKSByZXNvbHZlcyB0byBhblxuICogb2JqZWN0IHRoYXQgY29udGFpbnMgMyBwcm9wZXJ0aWVzOlxuICpcbiAqIC0gYG9rYDogYDFgIGlmIG5vIGVycm9ycyBvY2N1cnJlZFxuICogLSBgZGVsZXRlZENvdW50YDogdGhlIG51bWJlciBvZiBkb2N1bWVudHMgZGVsZXRlZFxuICogLSBgbmA6IHRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIGRlbGV0ZWQuIEVxdWFsIHRvIGBkZWxldGVkQ291bnRgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcmVzID0gYXdhaXQgQ2hhcmFjdGVyLmRlbGV0ZU9uZSh7IG5hbWU6ICdFZGRhcmQgU3RhcmsnIH0pO1xuICogICAgIC8vIGAxYCBpZiBNb25nb0RCIGRlbGV0ZWQgYSBkb2MsIGAwYCBpZiBubyBkb2NzIG1hdGNoZWQgdGhlIGZpbHRlciBgeyBuYW1lOiAuLi4gfWBcbiAqICAgICByZXMuZGVsZXRlZENvdW50O1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFF1ZXJ5fSBbZmlsdGVyXSBtb25nb2RiIHNlbGVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKSlcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIERlbGV0ZVJlc3VsdCBodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvRGVsZXRlUmVzdWx0Lmh0bWxcbiAqIEBzZWUgZGVsZXRlT25lIGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9Db2xsZWN0aW9uLmh0bWwjZGVsZXRlT25lXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5kZWxldGVPbmUgPSBmdW5jdGlvbiBkZWxldGVPbmUoZmlsdGVyLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignUXVlcnkucHJvdG90eXBlLmRlbGV0ZU9uZSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuICB0aGlzLm9wID0gJ2RlbGV0ZU9uZSc7XG4gIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICBpZiAobXF1ZXJ5LmNhbk1lcmdlKGZpbHRlcikpIHtcbiAgICB0aGlzLm1lcmdlKGZpbHRlcik7XG5cbiAgICBwcmVwYXJlRGlzY3JpbWluYXRvckNyaXRlcmlhKHRoaXMpO1xuICB9IGVsc2UgaWYgKGZpbHRlciAhPSBudWxsKSB7XG4gICAgdGhpcy5lcnJvcihuZXcgT2JqZWN0UGFyYW1ldGVyRXJyb3IoZmlsdGVyLCAnZmlsdGVyJywgJ2RlbGV0ZU9uZScpKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCB0aHVuayBmb3IgYGRlbGV0ZU9uZSgpYFxuICpcbiAqIEBtZXRob2QgX2RlbGV0ZU9uZVxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5fZGVsZXRlT25lID0gYXN5bmMgZnVuY3Rpb24gX2RlbGV0ZU9uZSgpIHtcbiAgdGhpcy5fY2FzdENvbmRpdGlvbnMoKTtcblxuICBpZiAodGhpcy5lcnJvcigpICE9IG51bGwpIHtcbiAgICB0aHJvdyB0aGlzLmVycm9yKCk7XG4gIH1cblxuICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9uc0ZvckV4ZWMoKTtcbiAgdGhpcy5fYXBwbHlUcmFuc2xhdGVBbGlhc2VzKG9wdGlvbnMpO1xuXG4gIHJldHVybiB0aGlzLm1vbmdvb3NlQ29sbGVjdGlvbi5kZWxldGVPbmUodGhpcy5fY29uZGl0aW9ucywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIERlY2xhcmUgYW5kL29yIGV4ZWN1dGUgdGhpcyBxdWVyeSBhcyBhIGBkZWxldGVNYW55KClgIG9wZXJhdGlvbi4gV29ya3MgbGlrZVxuICogcmVtb3ZlLCBleGNlcHQgaXQgZGVsZXRlcyBfZXZlcnlfIGRvY3VtZW50IHRoYXQgbWF0Y2hlcyBgZmlsdGVyYCBpbiB0aGVcbiAqIGNvbGxlY3Rpb24sIHJlZ2FyZGxlc3Mgb2YgdGhlIHZhbHVlIG9mIGBzaW5nbGVgLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgYGRlbGV0ZU1hbnlgIG1pZGRsZXdhcmUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBhd2FpdCBDaGFyYWN0ZXIuZGVsZXRlTWFueSh7IG5hbWU6IC9TdGFyay8sIGFnZTogeyAkZ3RlOiAxOCB9IH0pO1xuICpcbiAqIFRoaXMgZnVuY3Rpb24gY2FsbHMgdGhlIE1vbmdvREIgZHJpdmVyJ3MgW2BDb2xsZWN0aW9uI2RlbGV0ZU1hbnkoKWAgZnVuY3Rpb25dKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvY2xhc3Nlcy9Db2xsZWN0aW9uLmh0bWwjZGVsZXRlTWFueSkuXG4gKiBUaGUgcmV0dXJuZWQgW3Byb21pc2VdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9xdWVyaWVzLmh0bWwpIHJlc29sdmVzIHRvIGFuXG4gKiBvYmplY3QgdGhhdCBjb250YWlucyAzIHByb3BlcnRpZXM6XG4gKlxuICogLSBgb2tgOiBgMWAgaWYgbm8gZXJyb3JzIG9jY3VycmVkXG4gKiAtIGBkZWxldGVkQ291bnRgOiB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyBkZWxldGVkXG4gKiAtIGBuYDogdGhlIG51bWJlciBvZiBkb2N1bWVudHMgZGVsZXRlZC4gRXF1YWwgdG8gYGRlbGV0ZWRDb3VudGAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCByZXMgPSBhd2FpdCBDaGFyYWN0ZXIuZGVsZXRlTWFueSh7IG5hbWU6IC9TdGFyay8sIGFnZTogeyAkZ3RlOiAxOCB9IH0pO1xuICogICAgIC8vIGAwYCBpZiBubyBkb2NzIG1hdGNoZWQgdGhlIGZpbHRlciwgbnVtYmVyIG9mIGRvY3MgZGVsZXRlZCBvdGhlcndpc2VcbiAqICAgICByZXMuZGVsZXRlZENvdW50O1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFF1ZXJ5fSBbZmlsdGVyXSBtb25nb2RiIHNlbGVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsIHNlZSBbYFF1ZXJ5LnByb3RvdHlwZS5zZXRPcHRpb25zKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMoKSlcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlIERlbGV0ZVJlc3VsdCBodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvRGVsZXRlUmVzdWx0Lmh0bWxcbiAqIEBzZWUgZGVsZXRlTWFueSBodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvQ29sbGVjdGlvbi5odG1sI2RlbGV0ZU1hbnlcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmRlbGV0ZU1hbnkgPSBmdW5jdGlvbihmaWx0ZXIsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdRdWVyeS5wcm90b3R5cGUuZGVsZXRlTWFueSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIHRoaXMub3AgPSAnZGVsZXRlTWFueSc7XG5cbiAgaWYgKG1xdWVyeS5jYW5NZXJnZShmaWx0ZXIpKSB7XG4gICAgdGhpcy5tZXJnZShmaWx0ZXIpO1xuXG4gICAgcHJlcGFyZURpc2NyaW1pbmF0b3JDcml0ZXJpYSh0aGlzKTtcbiAgfSBlbHNlIGlmIChmaWx0ZXIgIT0gbnVsbCkge1xuICAgIHRoaXMuZXJyb3IobmV3IE9iamVjdFBhcmFtZXRlckVycm9yKGZpbHRlciwgJ2ZpbHRlcicsICdkZWxldGVNYW55JykpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgYSBgZGVsZXRlTWFueSgpYCBxdWVyeVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAbWV0aG9kIF9kZWxldGVNYW55XG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl9kZWxldGVNYW55ID0gYXN5bmMgZnVuY3Rpb24gX2RlbGV0ZU1hbnkoKSB7XG4gIHRoaXMuX2Nhc3RDb25kaXRpb25zKCk7XG5cbiAgaWYgKHRoaXMuZXJyb3IoKSAhPSBudWxsKSB7XG4gICAgdGhyb3cgdGhpcy5lcnJvcigpO1xuICB9XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnNGb3JFeGVjKCk7XG4gIHRoaXMuX2FwcGx5VHJhbnNsYXRlQWxpYXNlcyhvcHRpb25zKTtcblxuICByZXR1cm4gdGhpcy5tb25nb29zZUNvbGxlY3Rpb24uZGVsZXRlTWFueSh0aGlzLl9jb25kaXRpb25zLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogaHlkcmF0ZXMgYSBkb2N1bWVudFxuICpcbiAqIEBwYXJhbSB7TW9kZWx9IG1vZGVsXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBkb2NcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXMgM3JkIHBhcmFtZXRlciB0byBjYWxsYmFja1xuICogQHBhcmFtIHtPYmplY3R9IGZpZWxkc1xuICogQHBhcmFtIHtRdWVyeX0gc2VsZlxuICogQHBhcmFtIHtBcnJheX0gW3BvcF0gYXJyYXkgb2YgcGF0aHMgdXNlZCBpbiBwb3B1bGF0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29tcGxldGVPbmUobW9kZWwsIGRvYywgcmVzLCBvcHRpb25zLCBmaWVsZHMsIHVzZXJQcm92aWRlZEZpZWxkcywgcG9wLCBjYWxsYmFjaykge1xuICBpZiAob3B0aW9ucy5pbmNsdWRlUmVzdWx0TWV0YWRhdGEgJiYgZG9jID09IG51bGwpIHtcbiAgICBfaW5pdChudWxsKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGhlbHBlcnMuY3JlYXRlTW9kZWxBbmRJbml0KG1vZGVsLCBkb2MsIGZpZWxkcywgdXNlclByb3ZpZGVkRmllbGRzLCBvcHRpb25zLCBwb3AsIF9pbml0KTtcblxuICBmdW5jdGlvbiBfaW5pdChlcnIsIGNhc3RlZCkge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBpbW1lZGlhdGUoKCkgPT4gY2FsbGJhY2soZXJyKSk7XG4gICAgfVxuXG5cbiAgICBpZiAob3B0aW9ucy5pbmNsdWRlUmVzdWx0TWV0YWRhdGEpIHtcbiAgICAgIGlmIChkb2MgJiYgY2FzdGVkKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnNlc3Npb24gIT0gbnVsbCkge1xuICAgICAgICAgIGNhc3RlZC4kc2Vzc2lvbihvcHRpb25zLnNlc3Npb24pO1xuICAgICAgICB9XG4gICAgICAgIHJlcy52YWx1ZSA9IGNhc3RlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcy52YWx1ZSA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW1tZWRpYXRlKCgpID0+IGNhbGxiYWNrKG51bGwsIHJlcykpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zZXNzaW9uICE9IG51bGwpIHtcbiAgICAgIGNhc3RlZC4kc2Vzc2lvbihvcHRpb25zLnNlc3Npb24pO1xuICAgIH1cbiAgICBpbW1lZGlhdGUoKCkgPT4gY2FsbGJhY2sobnVsbCwgY2FzdGVkKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBJZiB0aGUgbW9kZWwgaXMgYSBkaXNjcmltaW5hdG9yIHR5cGUgYW5kIG5vdCByb290LCB0aGVuIGFkZCB0aGUga2V5ICYgdmFsdWUgdG8gdGhlIGNyaXRlcmlhLlxuICogQHBhcmFtIHtRdWVyeX0gcXVlcnlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHByZXBhcmVEaXNjcmltaW5hdG9yQ3JpdGVyaWEocXVlcnkpIHtcbiAgaWYgKCFxdWVyeSB8fCAhcXVlcnkubW9kZWwgfHwgIXF1ZXJ5Lm1vZGVsLnNjaGVtYSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHNjaGVtYSA9IHF1ZXJ5Lm1vZGVsLnNjaGVtYTtcblxuICBpZiAoc2NoZW1hICYmIHNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZyAmJiAhc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nLmlzUm9vdCkge1xuICAgIHF1ZXJ5Ll9jb25kaXRpb25zW3NjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZy5rZXldID0gc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nLnZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogSXNzdWVzIGEgbW9uZ29kYiBgZmluZE9uZUFuZFVwZGF0ZSgpYCBjb21tYW5kLlxuICpcbiAqIEZpbmRzIGEgbWF0Y2hpbmcgZG9jdW1lbnQsIHVwZGF0ZXMgaXQgYWNjb3JkaW5nIHRvIHRoZSBgdXBkYXRlYCBhcmcsIHBhc3NpbmcgYW55IGBvcHRpb25zYCwgYW5kIHJldHVybnMgdGhlIGZvdW5kXG4gKiBkb2N1bWVudCAoaWYgYW55KS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIHRoZSBmb2xsb3dpbmcgbWlkZGxld2FyZS5cbiAqXG4gKiAtIGBmaW5kT25lQW5kVXBkYXRlKClgXG4gKlxuICogIyMjIyBBdmFpbGFibGUgb3B0aW9uc1xuICpcbiAqIC0gYG5ld2A6IGJvb2wgLSBpZiB0cnVlLCByZXR1cm4gdGhlIG1vZGlmaWVkIGRvY3VtZW50IHJhdGhlciB0aGFuIHRoZSBvcmlnaW5hbC4gZGVmYXVsdHMgdG8gZmFsc2UgKGNoYW5nZWQgaW4gNC4wKVxuICogLSBgdXBzZXJ0YDogYm9vbCAtIGNyZWF0ZXMgdGhlIG9iamVjdCBpZiBpdCBkb2Vzbid0IGV4aXN0LiBkZWZhdWx0cyB0byBmYWxzZS5cbiAqIC0gYGZpZWxkc2A6IHtPYmplY3R8U3RyaW5nfSAtIEZpZWxkIHNlbGVjdGlvbi4gRXF1aXZhbGVudCB0byBgLnNlbGVjdChmaWVsZHMpLmZpbmRPbmVBbmRVcGRhdGUoKWBcbiAqIC0gYHNvcnRgOiBpZiBtdWx0aXBsZSBkb2NzIGFyZSBmb3VuZCBieSB0aGUgY29uZGl0aW9ucywgc2V0cyB0aGUgc29ydCBvcmRlciB0byBjaG9vc2Ugd2hpY2ggZG9jIHRvIHVwZGF0ZVxuICogLSBgbWF4VGltZU1TYDogcHV0cyBhIHRpbWUgbGltaXQgb24gdGhlIHF1ZXJ5IC0gcmVxdWlyZXMgbW9uZ29kYiA+PSAyLjYuMFxuICogLSBgcnVuVmFsaWRhdG9yc2A6IGlmIHRydWUsIHJ1bnMgW3VwZGF0ZSB2YWxpZGF0b3JzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdmFsaWRhdGlvbi5odG1sI3VwZGF0ZS12YWxpZGF0b3JzKSBvbiB0aGlzIGNvbW1hbmQuIFVwZGF0ZSB2YWxpZGF0b3JzIHZhbGlkYXRlIHRoZSB1cGRhdGUgb3BlcmF0aW9uIGFnYWluc3QgdGhlIG1vZGVsJ3Mgc2NoZW1hLlxuICogLSBgc2V0RGVmYXVsdHNPbkluc2VydGA6IGB0cnVlYCBieSBkZWZhdWx0LiBJZiBgc2V0RGVmYXVsdHNPbkluc2VydGAgYW5kIGB1cHNlcnRgIGFyZSB0cnVlLCBtb25nb29zZSB3aWxsIGFwcGx5IHRoZSBbZGVmYXVsdHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9kZWZhdWx0cy5odG1sKSBzcGVjaWZpZWQgaW4gdGhlIG1vZGVsJ3Mgc2NoZW1hIGlmIGEgbmV3IGRvY3VtZW50IGlzIGNyZWF0ZWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS5maW5kT25lQW5kVXBkYXRlKGNvbmRpdGlvbnMsIHVwZGF0ZSwgb3B0aW9ucykgIC8vIHJldHVybnMgUXVlcnlcbiAqICAgICBxdWVyeS5maW5kT25lQW5kVXBkYXRlKGNvbmRpdGlvbnMsIHVwZGF0ZSkgICAgICAgICAgIC8vIHJldHVybnMgUXVlcnlcbiAqICAgICBxdWVyeS5maW5kT25lQW5kVXBkYXRlKHVwZGF0ZSkgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgUXVlcnlcbiAqICAgICBxdWVyeS5maW5kT25lQW5kVXBkYXRlKCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgUXVlcnlcbiAqXG4gKiBAbWV0aG9kIGZpbmRPbmVBbmRVcGRhdGVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge09iamVjdHxRdWVyeX0gW2ZpbHRlcl1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbZG9jXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pbmNsdWRlUmVzdWx0TWV0YWRhdGFdIGlmIHRydWUsIHJldHVybnMgdGhlIGZ1bGwgW01vZGlmeVJlc3VsdCBmcm9tIHRoZSBNb25nb0RCIGRyaXZlcl0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL01vZGlmeVJlc3VsdC5odG1sKSByYXRoZXIgdGhhbiBqdXN0IHRoZSBkb2N1bWVudFxuICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gW29wdGlvbnMuc3RyaWN0XSBvdmVyd3JpdGVzIHRoZSBzY2hlbWEncyBbc3RyaWN0IG1vZGUgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdHJpY3QpXG4gKiBAcGFyYW0ge0NsaWVudFNlc3Npb259IFtvcHRpb25zLnNlc3Npb249bnVsbF0gVGhlIHNlc3Npb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgcXVlcnkuIFNlZSBbdHJhbnNhY3Rpb25zIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90cmFuc2FjdGlvbnMuaHRtbCkuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm11bHRpcGxlQ2FzdEVycm9yXSBieSBkZWZhdWx0LCBtb25nb29zZSBvbmx5IHJldHVybnMgdGhlIGZpcnN0IGVycm9yIHRoYXQgb2NjdXJyZWQgaW4gY2FzdGluZyB0aGUgcXVlcnkuIFR1cm4gb24gdGhpcyBvcHRpb24gdG8gYWdncmVnYXRlIGFsbCB0aGUgY2FzdCBlcnJvcnMuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm5ldz1mYWxzZV0gQnkgZGVmYXVsdCwgYGZpbmRPbmVBbmRVcGRhdGUoKWAgcmV0dXJucyB0aGUgZG9jdW1lbnQgYXMgaXQgd2FzICoqYmVmb3JlKiogYHVwZGF0ZWAgd2FzIGFwcGxpZWQuIElmIHlvdSBzZXQgYG5ldzogdHJ1ZWAsIGBmaW5kT25lQW5kVXBkYXRlKClgIHdpbGwgaW5zdGVhZCBnaXZlIHlvdSB0aGUgb2JqZWN0IGFmdGVyIGB1cGRhdGVgIHdhcyBhcHBsaWVkLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmxlYW5dIGlmIHRydXRoeSwgbW9uZ29vc2Ugd2lsbCByZXR1cm4gdGhlIGRvY3VtZW50IGFzIGEgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3QgcmF0aGVyIHRoYW4gYSBtb25nb29zZSBkb2N1bWVudC4gU2VlIFtgUXVlcnkubGVhbigpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5sZWFuKCkpIGFuZCBbdGhlIE1vbmdvb3NlIGxlYW4gdHV0b3JpYWxdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90dXRvcmlhbHMvbGVhbi5odG1sKS5cbiAqIEBwYXJhbSB7Q2xpZW50U2Vzc2lvbn0gW29wdGlvbnMuc2Vzc2lvbj1udWxsXSBUaGUgc2Vzc2lvbiBhc3NvY2lhdGVkIHdpdGggdGhpcyBxdWVyeS4gU2VlIFt0cmFuc2FjdGlvbnMgZG9jc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3RyYW5zYWN0aW9ucy5odG1sKS5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxTdHJpbmd9IFtvcHRpb25zLnN0cmljdF0gb3ZlcndyaXRlcyB0aGUgc2NoZW1hJ3MgW3N0cmljdCBtb2RlIG9wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc3RyaWN0KVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50aW1lc3RhbXBzPW51bGxdIElmIHNldCB0byBgZmFsc2VgIGFuZCBbc2NoZW1hLWxldmVsIHRpbWVzdGFtcHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3RpbWVzdGFtcHMpIGFyZSBlbmFibGVkLCBza2lwIHRpbWVzdGFtcHMgZm9yIHRoaXMgdXBkYXRlLiBOb3RlIHRoYXQgdGhpcyBhbGxvd3MgeW91IHRvIG92ZXJ3cml0ZSB0aW1lc3RhbXBzLiBEb2VzIG5vdGhpbmcgaWYgc2NoZW1hLWxldmVsIHRpbWVzdGFtcHMgYXJlIG5vdCBzZXQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJldHVybk9yaWdpbmFsPW51bGxdIEFuIGFsaWFzIGZvciB0aGUgYG5ld2Agb3B0aW9uLiBgcmV0dXJuT3JpZ2luYWw6IGZhbHNlYCBpcyBlcXVpdmFsZW50IHRvIGBuZXc6IHRydWVgLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cmFuc2xhdGVBbGlhc2VzPW51bGxdIElmIHNldCB0byBgdHJ1ZWAsIHRyYW5zbGF0ZXMgYW55IHNjaGVtYS1kZWZpbmVkIGFsaWFzZXMgaW4gYGZpbHRlcmAsIGBwcm9qZWN0aW9uYCwgYHVwZGF0ZWAsIGFuZCBgZGlzdGluY3RgLiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIGFueSBjb25mbGljdHMgd2hlcmUgYm90aCBhbGlhcyBhbmQgcmF3IHByb3BlcnR5IGFyZSBkZWZpbmVkIG9uIHRoZSBzYW1lIG9iamVjdC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMub3ZlcndyaXRlRGlzY3JpbWluYXRvcktleT1mYWxzZV0gTW9uZ29vc2UgcmVtb3ZlcyBkaXNjcmltaW5hdG9yIGtleSB1cGRhdGVzIGZyb20gYHVwZGF0ZWAgYnkgZGVmYXVsdCwgc2V0IGBvdmVyd3JpdGVEaXNjcmltaW5hdG9yS2V5YCB0byBgdHJ1ZWAgdG8gYWxsb3cgdXBkYXRpbmcgdGhlIGRpc2NyaW1pbmF0b3Iga2V5XG4gKiBAc2VlIFR1dG9yaWFsIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90dXRvcmlhbHMvZmluZG9uZWFuZHVwZGF0ZS5odG1sXG4gKiBAc2VlIGZpbmRBbmRNb2RpZnkgY29tbWFuZCBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvY29tbWFuZC9maW5kQW5kTW9kaWZ5L1xuICogQHNlZSBNb2RpZnlSZXN1bHQgaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9pbnRlcmZhY2VzL01vZGlmeVJlc3VsdC5odG1sXG4gKiBAc2VlIGZpbmRPbmVBbmRVcGRhdGUgaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0NvbGxlY3Rpb24uaHRtbCNmaW5kT25lQW5kVXBkYXRlXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZmluZE9uZUFuZFVwZGF0ZSA9IGZ1bmN0aW9uKGZpbHRlciwgZG9jLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2YgZG9jID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIGFyZ3VtZW50c1szXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdRdWVyeS5wcm90b3R5cGUuZmluZE9uZUFuZFVwZGF0ZSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIHRoaXMub3AgPSAnZmluZE9uZUFuZFVwZGF0ZSc7XG4gIHRoaXMuX3ZhbGlkYXRlT3AoKTtcbiAgdGhpcy5fdmFsaWRhdGUoKTtcblxuICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBjYXNlIDI6XG4gICAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgZG9jID0gZmlsdGVyO1xuICAgICAgZmlsdGVyID0gb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgaWYgKG1xdWVyeS5jYW5NZXJnZShmaWx0ZXIpKSB7XG4gICAgdGhpcy5tZXJnZShmaWx0ZXIpO1xuICB9IGVsc2UgaWYgKGZpbHRlciAhPSBudWxsKSB7XG4gICAgdGhpcy5lcnJvcihcbiAgICAgIG5ldyBPYmplY3RQYXJhbWV0ZXJFcnJvcihmaWx0ZXIsICdmaWx0ZXInLCAnZmluZE9uZUFuZFVwZGF0ZScpXG4gICAgKTtcbiAgfVxuXG4gIC8vIGFwcGx5IGRvY1xuICBpZiAoZG9jKSB7XG4gICAgdGhpcy5fbWVyZ2VVcGRhdGUoZG9jKTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zID8gY2xvbmUob3B0aW9ucykgOiB7fTtcblxuICBpZiAob3B0aW9ucy5wcm9qZWN0aW9uKSB7XG4gICAgdGhpcy5zZWxlY3Qob3B0aW9ucy5wcm9qZWN0aW9uKTtcbiAgICBkZWxldGUgb3B0aW9ucy5wcm9qZWN0aW9uO1xuICB9XG4gIGlmIChvcHRpb25zLmZpZWxkcykge1xuICAgIHRoaXMuc2VsZWN0KG9wdGlvbnMuZmllbGRzKTtcbiAgICBkZWxldGUgb3B0aW9ucy5maWVsZHM7XG4gIH1cblxuICBjb25zdCByZXR1cm5PcmlnaW5hbCA9IHRoaXMgJiZcbiAgICB0aGlzLm1vZGVsICYmXG4gICAgdGhpcy5tb2RlbC5iYXNlICYmXG4gICAgdGhpcy5tb2RlbC5iYXNlLm9wdGlvbnMgJiZcbiAgICB0aGlzLm1vZGVsLmJhc2Uub3B0aW9ucy5yZXR1cm5PcmlnaW5hbDtcbiAgaWYgKG9wdGlvbnMubmV3ID09IG51bGwgJiYgb3B0aW9ucy5yZXR1cm5Eb2N1bWVudCA9PSBudWxsICYmIG9wdGlvbnMucmV0dXJuT3JpZ2luYWwgPT0gbnVsbCAmJiByZXR1cm5PcmlnaW5hbCAhPSBudWxsKSB7XG4gICAgb3B0aW9ucy5yZXR1cm5PcmlnaW5hbCA9IHJldHVybk9yaWdpbmFsO1xuICB9XG5cbiAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIGEgZmluZE9uZUFuZFVwZGF0ZSBvcGVyYXRpb25cbiAqXG4gKiBAbWV0aG9kIF9maW5kT25lQW5kVXBkYXRlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5fZmluZE9uZUFuZFVwZGF0ZSA9IGFzeW5jIGZ1bmN0aW9uIF9maW5kT25lQW5kVXBkYXRlKCkge1xuICB0aGlzLl9jYXN0Q29uZGl0aW9ucygpO1xuXG4gIF9jYXN0QXJyYXlGaWx0ZXJzKHRoaXMpO1xuXG4gIGlmICh0aGlzLmVycm9yKCkpIHtcbiAgICB0aHJvdyB0aGlzLmVycm9yKCk7XG4gIH1cblxuICBhcHBseUdsb2JhbE1heFRpbWVNUyh0aGlzLm9wdGlvbnMsIHRoaXMubW9kZWwuZGIub3B0aW9ucywgdGhpcy5tb2RlbC5iYXNlLm9wdGlvbnMpO1xuICBhcHBseUdsb2JhbERpc2tVc2UodGhpcy5vcHRpb25zLCB0aGlzLm1vZGVsLmRiLm9wdGlvbnMsIHRoaXMubW9kZWwuYmFzZS5vcHRpb25zKTtcblxuICBpZiAoJ3N0cmljdCcgaW4gdGhpcy5vcHRpb25zKSB7XG4gICAgdGhpcy5fbW9uZ29vc2VPcHRpb25zLnN0cmljdCA9IHRoaXMub3B0aW9ucy5zdHJpY3Q7XG4gIH1cbiAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnNGb3JFeGVjKHRoaXMubW9kZWwpO1xuICBjb252ZXJ0TmV3VG9SZXR1cm5Eb2N1bWVudChvcHRpb25zKTtcbiAgdGhpcy5fYXBwbHlUcmFuc2xhdGVBbGlhc2VzKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3VwZGF0ZSA9IHRoaXMuX2Nhc3RVcGRhdGUodGhpcy5fdXBkYXRlKTtcblxuICBjb25zdCBfb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICBzZXREZWZhdWx0c09uSW5zZXJ0OiB0aGlzLl9tb25nb29zZU9wdGlvbnMuc2V0RGVmYXVsdHNPbkluc2VydFxuICB9KTtcbiAgdGhpcy5fdXBkYXRlID0gc2V0RGVmYXVsdHNPbkluc2VydCh0aGlzLl9jb25kaXRpb25zLCB0aGlzLm1vZGVsLnNjaGVtYSxcbiAgICB0aGlzLl91cGRhdGUsIF9vcHRzKTtcblxuICBpZiAoIXRoaXMuX3VwZGF0ZSB8fCBPYmplY3Qua2V5cyh0aGlzLl91cGRhdGUpLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChvcHRpb25zLnVwc2VydCkge1xuICAgICAgLy8gc3RpbGwgbmVlZCB0byBkbyB0aGUgdXBzZXJ0IHRvIGVtcHR5IGRvY1xuICAgICAgY29uc3QgZG9jID0gY2xvbmUodGhpcy5fdXBkYXRlKTtcbiAgICAgIGRlbGV0ZSBkb2MuX2lkO1xuICAgICAgdGhpcy5fdXBkYXRlID0geyAkc2V0OiBkb2MgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZXhlY3V0aW9uU3RhY2sgPSBudWxsO1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmluZE9uZSgpO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gIH0gZWxzZSBpZiAodGhpcy5fdXBkYXRlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICB0aHJvdyB0aGlzLl91cGRhdGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gSW4gb3JkZXIgdG8gbWFrZSBNb25nb0RCIDIuNiBoYXBweSAoc2VlXG4gICAgLy8gaHR0cHM6Ly9qaXJhLm1vbmdvZGIub3JnL2Jyb3dzZS9TRVJWRVItMTIyNjYgYW5kIHJlbGF0ZWQgaXNzdWVzKVxuICAgIC8vIGlmIHdlIGhhdmUgYW4gYWN0dWFsIHVwZGF0ZSBkb2N1bWVudCBidXQgJHNldCBpcyBlbXB0eSwganVuayB0aGUgJHNldC5cbiAgICBpZiAodGhpcy5fdXBkYXRlLiRzZXQgJiYgT2JqZWN0LmtleXModGhpcy5fdXBkYXRlLiRzZXQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZGVsZXRlIHRoaXMuX3VwZGF0ZS4kc2V0O1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHJ1blZhbGlkYXRvcnMgPSBfZ2V0T3B0aW9uKHRoaXMsICdydW5WYWxpZGF0b3JzJywgZmFsc2UpO1xuICBpZiAocnVuVmFsaWRhdG9ycykge1xuICAgIGF3YWl0IHRoaXMudmFsaWRhdGUodGhpcy5fdXBkYXRlLCBvcHRpb25zLCBmYWxzZSk7XG4gIH1cblxuICBpZiAodGhpcy5fdXBkYXRlLnRvQlNPTikge1xuICAgIHRoaXMuX3VwZGF0ZSA9IHRoaXMuX3VwZGF0ZS50b0JTT04oKTtcbiAgfVxuXG4gIGxldCByZXMgPSBhd2FpdCB0aGlzLm1vbmdvb3NlQ29sbGVjdGlvbi5maW5kT25lQW5kVXBkYXRlKHRoaXMuX2NvbmRpdGlvbnMsIHRoaXMuX3VwZGF0ZSwgb3B0aW9ucyk7XG4gIGZvciAoY29uc3QgZm4gb2YgdGhpcy5fdHJhbnNmb3Jtcykge1xuICAgIHJlcyA9IGZuKHJlcyk7XG4gIH1cbiAgY29uc3QgZG9jID0gIW9wdGlvbnMuaW5jbHVkZVJlc3VsdE1ldGFkYXRhID8gcmVzIDogcmVzLnZhbHVlO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdGhpcy5fY29tcGxldGVPbmUoZG9jLCByZXMsIChlcnIsIHJlcykgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKHJlcyk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBJc3N1ZXMgYSBNb25nb0RCIFtmaW5kT25lQW5kRGVsZXRlXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2UvbWV0aG9kL2RiLmNvbGxlY3Rpb24uZmluZE9uZUFuZERlbGV0ZS8pIGNvbW1hbmQuXG4gKlxuICogRmluZHMgYSBtYXRjaGluZyBkb2N1bWVudCwgcmVtb3ZlcyBpdCwgYW5kIHJldHVybnMgdGhlIGZvdW5kIGRvY3VtZW50IChpZiBhbnkpLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgdGhlIGZvbGxvd2luZyBtaWRkbGV3YXJlLlxuICpcbiAqIC0gYGZpbmRPbmVBbmREZWxldGUoKWBcbiAqXG4gKiAjIyMjIEF2YWlsYWJsZSBvcHRpb25zXG4gKlxuICogLSBgc29ydGA6IGlmIG11bHRpcGxlIGRvY3MgYXJlIGZvdW5kIGJ5IHRoZSBjb25kaXRpb25zLCBzZXRzIHRoZSBzb3J0IG9yZGVyIHRvIGNob29zZSB3aGljaCBkb2MgdG8gdXBkYXRlXG4gKiAtIGBtYXhUaW1lTVNgOiBwdXRzIGEgdGltZSBsaW1pdCBvbiB0aGUgcXVlcnkgLSByZXF1aXJlcyBtb25nb2RiID49IDIuNi4wXG4gKlxuICogIyMjIyBDYWxsYmFjayBTaWduYXR1cmVcbiAqXG4gKiAgICAgZnVuY3Rpb24oZXJyb3IsIGRvYykge1xuICogICAgICAgLy8gZXJyb3I6IGFueSBlcnJvcnMgdGhhdCBvY2N1cnJlZFxuICogICAgICAgLy8gZG9jOiB0aGUgZG9jdW1lbnQgYmVmb3JlIHVwZGF0ZXMgYXJlIGFwcGxpZWQgaWYgYG5ldzogZmFsc2VgLCBvciBhZnRlciB1cGRhdGVzIGlmIGBuZXcgPSB0cnVlYFxuICogICAgIH1cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIEEud2hlcmUoKS5maW5kT25lQW5kRGVsZXRlKGNvbmRpdGlvbnMsIG9wdGlvbnMpICAvLyByZXR1cm4gUXVlcnlcbiAqICAgICBBLndoZXJlKCkuZmluZE9uZUFuZERlbGV0ZShjb25kaXRpb25zKSAvLyByZXR1cm5zIFF1ZXJ5XG4gKiAgICAgQS53aGVyZSgpLmZpbmRPbmVBbmREZWxldGUoKSAgICAgICAgICAgLy8gcmV0dXJucyBRdWVyeVxuICpcbiAqIEBtZXRob2QgZmluZE9uZUFuZERlbGV0ZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAcGFyYW0ge09iamVjdH0gW2ZpbHRlcl1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaW5jbHVkZVJlc3VsdE1ldGFkYXRhXSBpZiB0cnVlLCByZXR1cm5zIHRoZSBmdWxsIFtNb2RpZnlSZXN1bHQgZnJvbSB0aGUgTW9uZ29EQiBkcml2ZXJdKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvaW50ZXJmYWNlcy9Nb2RpZnlSZXN1bHQuaHRtbCkgcmF0aGVyIHRoYW4ganVzdCB0aGUgZG9jdW1lbnRcbiAqIEBwYXJhbSB7Q2xpZW50U2Vzc2lvbn0gW29wdGlvbnMuc2Vzc2lvbj1udWxsXSBUaGUgc2Vzc2lvbiBhc3NvY2lhdGVkIHdpdGggdGhpcyBxdWVyeS4gU2VlIFt0cmFuc2FjdGlvbnMgZG9jc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3RyYW5zYWN0aW9ucy5odG1sKS5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxTdHJpbmd9IFtvcHRpb25zLnN0cmljdF0gb3ZlcndyaXRlcyB0aGUgc2NoZW1hJ3MgW3N0cmljdCBtb2RlIG9wdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc3RyaWN0KVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgZmluZEFuZE1vZGlmeSBjb21tYW5kIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9jb21tYW5kL2ZpbmRBbmRNb2RpZnkvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5maW5kT25lQW5kRGVsZXRlID0gZnVuY3Rpb24oZmlsdGVyLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgZmlsdGVyID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdRdWVyeS5wcm90b3R5cGUuZmluZE9uZUFuZERlbGV0ZSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIHRoaXMub3AgPSAnZmluZE9uZUFuZERlbGV0ZSc7XG4gIHRoaXMuX3ZhbGlkYXRlT3AoKTtcbiAgdGhpcy5fdmFsaWRhdGUoKTtcblxuICBpZiAobXF1ZXJ5LmNhbk1lcmdlKGZpbHRlcikpIHtcbiAgICB0aGlzLm1lcmdlKGZpbHRlcik7XG4gIH1cblxuICBvcHRpb25zICYmIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRXhlY3V0ZSBhIGBmaW5kT25lQW5kRGVsZXRlKClgIHF1ZXJ5XG4gKlxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBtZXRob2QgX2ZpbmRPbmVBbmREZWxldGVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGFwaSBwcml2YXRlXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5fZmluZE9uZUFuZERlbGV0ZSA9IGFzeW5jIGZ1bmN0aW9uIF9maW5kT25lQW5kRGVsZXRlKCkge1xuICB0aGlzLl9jYXN0Q29uZGl0aW9ucygpO1xuXG4gIGlmICh0aGlzLmVycm9yKCkgIT0gbnVsbCkge1xuICAgIHRocm93IHRoaXMuZXJyb3IoKTtcbiAgfVxuXG4gIGNvbnN0IGluY2x1ZGVSZXN1bHRNZXRhZGF0YSA9IHRoaXMub3B0aW9ucy5pbmNsdWRlUmVzdWx0TWV0YWRhdGE7XG5cbiAgY29uc3QgZmlsdGVyID0gdGhpcy5fY29uZGl0aW9ucztcbiAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnNGb3JFeGVjKHRoaXMubW9kZWwpO1xuICB0aGlzLl9hcHBseVRyYW5zbGF0ZUFsaWFzZXMob3B0aW9ucyk7XG5cbiAgbGV0IHJlcyA9IGF3YWl0IHRoaXMubW9uZ29vc2VDb2xsZWN0aW9uLmZpbmRPbmVBbmREZWxldGUoZmlsdGVyLCBvcHRpb25zKTtcbiAgZm9yIChjb25zdCBmbiBvZiB0aGlzLl90cmFuc2Zvcm1zKSB7XG4gICAgcmVzID0gZm4ocmVzKTtcbiAgfVxuICBjb25zdCBkb2MgPSAhaW5jbHVkZVJlc3VsdE1ldGFkYXRhID8gcmVzIDogcmVzLnZhbHVlO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdGhpcy5fY29tcGxldGVPbmUoZG9jLCByZXMsIChlcnIsIHJlcykgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKHJlcyk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBJc3N1ZXMgYSBNb25nb0RCIFtmaW5kT25lQW5kUmVwbGFjZV0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9kYi5jb2xsZWN0aW9uLmZpbmRPbmVBbmRSZXBsYWNlLykgY29tbWFuZC5cbiAqXG4gKiBGaW5kcyBhIG1hdGNoaW5nIGRvY3VtZW50LCByZW1vdmVzIGl0LCBhbmQgcmV0dXJucyB0aGUgZm91bmQgZG9jdW1lbnQgKGlmIGFueSkuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0cmlnZ2VycyB0aGUgZm9sbG93aW5nIG1pZGRsZXdhcmUuXG4gKlxuICogLSBgZmluZE9uZUFuZFJlcGxhY2UoKWBcbiAqXG4gKiAjIyMjIEF2YWlsYWJsZSBvcHRpb25zXG4gKlxuICogLSBgc29ydGA6IGlmIG11bHRpcGxlIGRvY3MgYXJlIGZvdW5kIGJ5IHRoZSBjb25kaXRpb25zLCBzZXRzIHRoZSBzb3J0IG9yZGVyIHRvIGNob29zZSB3aGljaCBkb2MgdG8gdXBkYXRlXG4gKiAtIGBtYXhUaW1lTVNgOiBwdXRzIGEgdGltZSBsaW1pdCBvbiB0aGUgcXVlcnkgLSByZXF1aXJlcyBtb25nb2RiID49IDIuNi4wXG4gKiAtIGBpbmNsdWRlUmVzdWx0TWV0YWRhdGFgOiBpZiB0cnVlLCByZXR1cm5zIHRoZSBmdWxsIFtNb2RpZnlSZXN1bHQgZnJvbSB0aGUgTW9uZ29EQiBkcml2ZXJdKGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvaW50ZXJmYWNlcy9Nb2RpZnlSZXN1bHQuaHRtbCkgcmF0aGVyIHRoYW4ganVzdCB0aGUgZG9jdW1lbnRcbiAqXG4gKiAjIyMjIENhbGxiYWNrIFNpZ25hdHVyZVxuICpcbiAqICAgICBmdW5jdGlvbihlcnJvciwgZG9jKSB7XG4gKiAgICAgICAvLyBlcnJvcjogYW55IGVycm9ycyB0aGF0IG9jY3VycmVkXG4gKiAgICAgICAvLyBkb2M6IHRoZSBkb2N1bWVudCBiZWZvcmUgdXBkYXRlcyBhcmUgYXBwbGllZCBpZiBgbmV3OiBmYWxzZWAsIG9yIGFmdGVyIHVwZGF0ZXMgaWYgYG5ldyA9IHRydWVgXG4gKiAgICAgfVxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgQS53aGVyZSgpLmZpbmRPbmVBbmRSZXBsYWNlKGZpbHRlciwgcmVwbGFjZW1lbnQsIG9wdGlvbnMpOyAvLyByZXR1cm4gUXVlcnlcbiAqICAgICBBLndoZXJlKCkuZmluZE9uZUFuZFJlcGxhY2UoZmlsdGVyKTsgLy8gcmV0dXJucyBRdWVyeVxuICogICAgIEEud2hlcmUoKS5maW5kT25lQW5kUmVwbGFjZSgpOyAvLyByZXR1cm5zIFF1ZXJ5XG4gKlxuICogQG1ldGhvZCBmaW5kT25lQW5kUmVwbGFjZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAcGFyYW0ge09iamVjdH0gW2ZpbHRlcl1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVwbGFjZW1lbnRdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmluY2x1ZGVSZXN1bHRNZXRhZGF0YV0gaWYgdHJ1ZSwgcmV0dXJucyB0aGUgZnVsbCBbTW9kaWZ5UmVzdWx0IGZyb20gdGhlIE1vbmdvREIgZHJpdmVyXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvTW9kaWZ5UmVzdWx0Lmh0bWwpIHJhdGhlciB0aGFuIGp1c3QgdGhlIGRvY3VtZW50XG4gKiBAcGFyYW0ge0NsaWVudFNlc3Npb259IFtvcHRpb25zLnNlc3Npb249bnVsbF0gVGhlIHNlc3Npb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgcXVlcnkuIFNlZSBbdHJhbnNhY3Rpb25zIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy90cmFuc2FjdGlvbnMuaHRtbCkuXG4gKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBbb3B0aW9ucy5zdHJpY3RdIG92ZXJ3cml0ZXMgdGhlIHNjaGVtYSdzIFtzdHJpY3QgbW9kZSBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdClcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubmV3PWZhbHNlXSBCeSBkZWZhdWx0LCBgZmluZE9uZUFuZFVwZGF0ZSgpYCByZXR1cm5zIHRoZSBkb2N1bWVudCBhcyBpdCB3YXMgKipiZWZvcmUqKiBgdXBkYXRlYCB3YXMgYXBwbGllZC4gSWYgeW91IHNldCBgbmV3OiB0cnVlYCwgYGZpbmRPbmVBbmRVcGRhdGUoKWAgd2lsbCBpbnN0ZWFkIGdpdmUgeW91IHRoZSBvYmplY3QgYWZ0ZXIgYHVwZGF0ZWAgd2FzIGFwcGxpZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubGVhbl0gaWYgdHJ1dGh5LCBtb25nb29zZSB3aWxsIHJldHVybiB0aGUgZG9jdW1lbnQgYXMgYSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdCByYXRoZXIgdGhhbiBhIG1vbmdvb3NlIGRvY3VtZW50LiBTZWUgW2BRdWVyeS5sZWFuKClgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLmxlYW4oKSkgYW5kIFt0aGUgTW9uZ29vc2UgbGVhbiB0dXRvcmlhbF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3R1dG9yaWFscy9sZWFuLmh0bWwpLlxuICogQHBhcmFtIHtDbGllbnRTZXNzaW9ufSBbb3B0aW9ucy5zZXNzaW9uPW51bGxdIFRoZSBzZXNzaW9uIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHF1ZXJ5LiBTZWUgW3RyYW5zYWN0aW9ucyBkb2NzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHJhbnNhY3Rpb25zLmh0bWwpLlxuICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gW29wdGlvbnMuc3RyaWN0XSBvdmVyd3JpdGVzIHRoZSBzY2hlbWEncyBbc3RyaWN0IG1vZGUgb3B0aW9uXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdHJpY3QpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRpbWVzdGFtcHM9bnVsbF0gSWYgc2V0IHRvIGBmYWxzZWAgYW5kIFtzY2hlbWEtbGV2ZWwgdGltZXN0YW1wc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdGltZXN0YW1wcykgYXJlIGVuYWJsZWQsIHNraXAgdGltZXN0YW1wcyBmb3IgdGhpcyB1cGRhdGUuIE5vdGUgdGhhdCB0aGlzIGFsbG93cyB5b3UgdG8gb3ZlcndyaXRlIHRpbWVzdGFtcHMuIERvZXMgbm90aGluZyBpZiBzY2hlbWEtbGV2ZWwgdGltZXN0YW1wcyBhcmUgbm90IHNldC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmV0dXJuT3JpZ2luYWw9bnVsbF0gQW4gYWxpYXMgZm9yIHRoZSBgbmV3YCBvcHRpb24uIGByZXR1cm5PcmlnaW5hbDogZmFsc2VgIGlzIGVxdWl2YWxlbnQgdG8gYG5ldzogdHJ1ZWAuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnRyYW5zbGF0ZUFsaWFzZXM9bnVsbF0gSWYgc2V0IHRvIGB0cnVlYCwgdHJhbnNsYXRlcyBhbnkgc2NoZW1hLWRlZmluZWQgYWxpYXNlcyBpbiBgZmlsdGVyYCwgYHByb2plY3Rpb25gLCBgdXBkYXRlYCwgYW5kIGBkaXN0aW5jdGAuIFRocm93cyBhbiBlcnJvciBpZiB0aGVyZSBhcmUgYW55IGNvbmZsaWN0cyB3aGVyZSBib3RoIGFsaWFzIGFuZCByYXcgcHJvcGVydHkgYXJlIGRlZmluZWQgb24gdGhlIHNhbWUgb2JqZWN0LlxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmZpbmRPbmVBbmRSZXBsYWNlID0gZnVuY3Rpb24oZmlsdGVyLCByZXBsYWNlbWVudCwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIHJlcGxhY2VtZW50ID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIGFyZ3VtZW50c1s0XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdRdWVyeS5wcm90b3R5cGUuZmluZE9uZUFuZFJlcGxhY2UoKSBubyBsb25nZXIgYWNjZXB0cyBhIGNhbGxiYWNrJyk7XG4gIH1cblxuICB0aGlzLm9wID0gJ2ZpbmRPbmVBbmRSZXBsYWNlJztcbiAgdGhpcy5fdmFsaWRhdGVPcCgpO1xuICB0aGlzLl92YWxpZGF0ZSgpO1xuXG4gIGlmIChtcXVlcnkuY2FuTWVyZ2UoZmlsdGVyKSkge1xuICAgIHRoaXMubWVyZ2UoZmlsdGVyKTtcbiAgfSBlbHNlIGlmIChmaWx0ZXIgIT0gbnVsbCkge1xuICAgIHRoaXMuZXJyb3IoXG4gICAgICBuZXcgT2JqZWN0UGFyYW1ldGVyRXJyb3IoZmlsdGVyLCAnZmlsdGVyJywgJ2ZpbmRPbmVBbmRSZXBsYWNlJylcbiAgICApO1xuICB9XG5cbiAgaWYgKHJlcGxhY2VtZW50ICE9IG51bGwpIHtcbiAgICB0aGlzLl9tZXJnZVVwZGF0ZShyZXBsYWNlbWVudCk7XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBjb25zdCByZXR1cm5PcmlnaW5hbCA9IHRoaXMgJiZcbiAgdGhpcy5tb2RlbCAmJlxuICB0aGlzLm1vZGVsLmJhc2UgJiZcbiAgdGhpcy5tb2RlbC5iYXNlLm9wdGlvbnMgJiZcbiAgdGhpcy5tb2RlbC5iYXNlLm9wdGlvbnMucmV0dXJuT3JpZ2luYWw7XG4gIGlmIChvcHRpb25zLm5ldyA9PSBudWxsICYmIG9wdGlvbnMucmV0dXJuRG9jdW1lbnQgPT0gbnVsbCAmJiBvcHRpb25zLnJldHVybk9yaWdpbmFsID09IG51bGwgJiYgcmV0dXJuT3JpZ2luYWwgIT0gbnVsbCkge1xuICAgIG9wdGlvbnMucmV0dXJuT3JpZ2luYWwgPSByZXR1cm5PcmlnaW5hbDtcbiAgfVxuICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEV4ZWN1dGUgYSBmaW5kT25lQW5kUmVwbGFjZSgpIHF1ZXJ5XG4gKlxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBtZXRob2QgX2ZpbmRPbmVBbmRSZXBsYWNlXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGFwaSBwcml2YXRlXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5fZmluZE9uZUFuZFJlcGxhY2UgPSBhc3luYyBmdW5jdGlvbiBfZmluZE9uZUFuZFJlcGxhY2UoKSB7XG4gIHRoaXMuX2Nhc3RDb25kaXRpb25zKCk7XG4gIGlmICh0aGlzLmVycm9yKCkgIT0gbnVsbCkge1xuICAgIHRocm93IHRoaXMuZXJyb3IoKTtcbiAgfVxuXG4gIGlmICgnc3RyaWN0JyBpbiB0aGlzLm9wdGlvbnMpIHtcbiAgICB0aGlzLl9tb25nb29zZU9wdGlvbnMuc3RyaWN0ID0gdGhpcy5vcHRpb25zLnN0cmljdDtcbiAgICBkZWxldGUgdGhpcy5vcHRpb25zLnN0cmljdDtcbiAgfVxuXG4gIGNvbnN0IGZpbHRlciA9IHRoaXMuX2NvbmRpdGlvbnM7XG4gIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zRm9yRXhlYygpO1xuICB0aGlzLl9hcHBseVRyYW5zbGF0ZUFsaWFzZXMob3B0aW9ucyk7XG4gIGNvbnZlcnROZXdUb1JldHVybkRvY3VtZW50KG9wdGlvbnMpO1xuXG4gIGNvbnN0IGluY2x1ZGVSZXN1bHRNZXRhZGF0YSA9IHRoaXMub3B0aW9ucy5pbmNsdWRlUmVzdWx0TWV0YWRhdGE7XG5cbiAgY29uc3QgbW9kZWxPcHRzID0geyBza2lwSWQ6IHRydWUgfTtcbiAgaWYgKCdzdHJpY3QnIGluIHRoaXMuX21vbmdvb3NlT3B0aW9ucykge1xuICAgIG1vZGVsT3B0cy5zdHJpY3QgPSB0aGlzLl9tb25nb29zZU9wdGlvbnMuc3RyaWN0O1xuICB9XG5cbiAgY29uc3QgcnVuVmFsaWRhdG9ycyA9IF9nZXRPcHRpb24odGhpcywgJ3J1blZhbGlkYXRvcnMnLCBmYWxzZSk7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB1cGRhdGUgPSBuZXcgdGhpcy5tb2RlbCh0aGlzLl91cGRhdGUsIG51bGwsIG1vZGVsT3B0cyk7XG4gICAgaWYgKHJ1blZhbGlkYXRvcnMpIHtcbiAgICAgIGF3YWl0IHVwZGF0ZS52YWxpZGF0ZSgpO1xuICAgIH0gZWxzZSBpZiAodXBkYXRlLiRfXy52YWxpZGF0aW9uRXJyb3IpIHtcbiAgICAgIHRocm93IHVwZGF0ZS4kX18udmFsaWRhdGlvbkVycm9yO1xuICAgIH1cbiAgICB0aGlzLl91cGRhdGUgPSB1cGRhdGUudG9CU09OKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBWYWxpZGF0aW9uRXJyb3IpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgY29uc3QgdmFsaWRhdGlvbkVycm9yID0gbmV3IFZhbGlkYXRpb25FcnJvcigpO1xuICAgIHZhbGlkYXRpb25FcnJvci5lcnJvcnNbZXJyLnBhdGhdID0gZXJyO1xuICAgIHRocm93IHZhbGlkYXRpb25FcnJvcjtcbiAgfVxuXG4gIGxldCByZXMgPSBhd2FpdCB0aGlzLm1vbmdvb3NlQ29sbGVjdGlvbi5maW5kT25lQW5kUmVwbGFjZShmaWx0ZXIsIHRoaXMuX3VwZGF0ZSwgb3B0aW9ucyk7XG5cbiAgZm9yIChjb25zdCBmbiBvZiB0aGlzLl90cmFuc2Zvcm1zKSB7XG4gICAgcmVzID0gZm4ocmVzKTtcbiAgfVxuXG4gIGNvbnN0IGRvYyA9ICFpbmNsdWRlUmVzdWx0TWV0YWRhdGEgPyByZXMgOiByZXMudmFsdWU7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdGhpcy5fY29tcGxldGVPbmUoZG9jLCByZXMsIChlcnIsIHJlcykgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKHJlcyk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBTdXBwb3J0IHRoZSBgbmV3YCBvcHRpb24gYXMgYW4gYWx0ZXJuYXRpdmUgdG8gYHJldHVybk9yaWdpbmFsYCBmb3IgYmFja3dhcmRzXG4gKiBjb21wYXQuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb252ZXJ0TmV3VG9SZXR1cm5Eb2N1bWVudChvcHRpb25zKSB7XG4gIGlmICgnbmV3JyBpbiBvcHRpb25zKSB7XG4gICAgb3B0aW9ucy5yZXR1cm5Eb2N1bWVudCA9IG9wdGlvbnNbJ25ldyddID8gJ2FmdGVyJyA6ICdiZWZvcmUnO1xuICAgIGRlbGV0ZSBvcHRpb25zWyduZXcnXTtcbiAgfVxuICBpZiAoJ3JldHVybk9yaWdpbmFsJyBpbiBvcHRpb25zKSB7XG4gICAgb3B0aW9ucy5yZXR1cm5Eb2N1bWVudCA9IG9wdGlvbnNbJ3JldHVybk9yaWdpbmFsJ10gPyAnYmVmb3JlJyA6ICdhZnRlcic7XG4gICAgZGVsZXRlIG9wdGlvbnNbJ3JldHVybk9yaWdpbmFsJ107XG4gIH1cbiAgLy8gVGVtcG9yYXJ5IHNpbmNlIGRyaXZlciA0LjAuMC1iZXRhIGRvZXMgbm90IHN1cHBvcnQgYHJldHVybkRvY3VtZW50YFxuICBpZiAodHlwZW9mIG9wdGlvbnMucmV0dXJuRG9jdW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgb3B0aW9ucy5yZXR1cm5PcmlnaW5hbCA9IG9wdGlvbnMucmV0dXJuRG9jdW1lbnQgPT09ICdiZWZvcmUnO1xuICB9XG59XG5cbi8qKlxuICogR2V0IG9wdGlvbnMgZnJvbSBxdWVyeSBvcHRzLCBmYWxsaW5nIGJhY2sgdG8gdGhlIGJhc2UgbW9uZ29vc2Ugb2JqZWN0LlxuICogQHBhcmFtIHtRdWVyeX0gcXVlcnlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25cbiAqIEBwYXJhbSB7QW55fSBkZWZcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIF9nZXRPcHRpb24ocXVlcnksIG9wdGlvbiwgZGVmKSB7XG4gIGNvbnN0IG9wdHMgPSBxdWVyeS5fb3B0aW9uc0ZvckV4ZWMocXVlcnkubW9kZWwpO1xuXG4gIGlmIChvcHRpb24gaW4gb3B0cykge1xuICAgIHJldHVybiBvcHRzW29wdGlvbl07XG4gIH1cbiAgaWYgKG9wdGlvbiBpbiBxdWVyeS5tb2RlbC5iYXNlLm9wdGlvbnMpIHtcbiAgICByZXR1cm4gcXVlcnkubW9kZWwuYmFzZS5vcHRpb25zW29wdGlvbl07XG4gIH1cbiAgcmV0dXJuIGRlZjtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfY29tcGxldGVPbmVMZWFuKHNjaGVtYSwgZG9jLCBwYXRoLCByZXMsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmIChvcHRzLmxlYW4gJiYgdHlwZW9mIG9wdHMubGVhbi50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRzLmxlYW4udHJhbnNmb3JtKGRvYyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYS5jaGlsZFNjaGVtYXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkUGF0aCA9IHBhdGggPyBwYXRoICsgJy4nICsgc2NoZW1hLmNoaWxkU2NoZW1hc1tpXS5tb2RlbC5wYXRoIDogc2NoZW1hLmNoaWxkU2NoZW1hc1tpXS5tb2RlbC5wYXRoO1xuICAgICAgY29uc3QgX3NjaGVtYSA9IHNjaGVtYS5jaGlsZFNjaGVtYXNbaV0uc2NoZW1hO1xuICAgICAgY29uc3Qgb2JqID0gbXBhdGguZ2V0KGNoaWxkUGF0aCwgZG9jKTtcbiAgICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBvcHRzLmxlYW4udHJhbnNmb3JtKG9ialtpXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdHMubGVhbi50cmFuc2Zvcm0ob2JqKTtcbiAgICAgIH1cbiAgICAgIF9jb21wbGV0ZU9uZUxlYW4oX3NjaGVtYSwgb2JqLCBjaGlsZFBhdGgsIHJlcywgb3B0cyk7XG4gICAgfVxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGRvYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdHMuaW5jbHVkZVJlc3VsdE1ldGFkYXRhKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlcyk7XG4gIH1cbiAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGRvYyk7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2NvbXBsZXRlTWFueUxlYW4oc2NoZW1hLCBkb2NzLCBwYXRoLCBvcHRzKSB7XG4gIGlmIChvcHRzLmxlYW4gJiYgdHlwZW9mIG9wdHMubGVhbi50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHtcbiAgICBmb3IgKGNvbnN0IGRvYyBvZiBkb2NzKSB7XG4gICAgICBvcHRzLmxlYW4udHJhbnNmb3JtKGRvYyk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWEuY2hpbGRTY2hlbWFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZFBhdGggPSBwYXRoID8gcGF0aCArICcuJyArIHNjaGVtYS5jaGlsZFNjaGVtYXNbaV0ubW9kZWwucGF0aCA6IHNjaGVtYS5jaGlsZFNjaGVtYXNbaV0ubW9kZWwucGF0aDtcbiAgICAgIGNvbnN0IF9zY2hlbWEgPSBzY2hlbWEuY2hpbGRTY2hlbWFzW2ldLnNjaGVtYTtcbiAgICAgIGxldCBkb2MgPSBtcGF0aC5nZXQoY2hpbGRQYXRoLCBkb2NzKTtcbiAgICAgIGlmIChkb2MgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGRvYyA9IGRvYy5mbGF0KCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRvYy5sZW5ndGg7IGkrKykge1xuICAgICAgICBvcHRzLmxlYW4udHJhbnNmb3JtKGRvY1tpXSk7XG4gICAgICB9XG4gICAgICBfY29tcGxldGVNYW55TGVhbihfc2NoZW1hLCBkb2MsIGNoaWxkUGF0aCwgb3B0cyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRvY3M7XG59XG4vKipcbiAqIE92ZXJyaWRlIG1xdWVyeS5wcm90b3R5cGUuX21lcmdlVXBkYXRlIHRvIGhhbmRsZSBtb25nb29zZSBvYmplY3RzIGluXG4gKiB1cGRhdGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2NcbiAqIEBtZXRob2QgX21lcmdlVXBkYXRlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl9tZXJnZVVwZGF0ZSA9IGZ1bmN0aW9uKGRvYykge1xuICBpZiAoIXRoaXMuX3VwZGF0ZSkge1xuICAgIHRoaXMuX3VwZGF0ZSA9IEFycmF5LmlzQXJyYXkoZG9jKSA/IFtdIDoge307XG4gIH1cblxuICBpZiAoZG9jID09IG51bGwgfHwgKHR5cGVvZiBkb2MgPT09ICdvYmplY3QnICYmIE9iamVjdC5rZXlzKGRvYykubGVuZ3RoID09PSAwKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChkb2MgaW5zdGFuY2VvZiBRdWVyeSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuX3VwZGF0ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IG1peCBhcnJheSBhbmQgb2JqZWN0IHVwZGF0ZXMnKTtcbiAgICB9XG4gICAgaWYgKGRvYy5fdXBkYXRlKSB7XG4gICAgICB1dGlscy5tZXJnZUNsb25lKHRoaXMuX3VwZGF0ZSwgZG9jLl91cGRhdGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRvYykpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy5fdXBkYXRlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgbWl4IGFycmF5IGFuZCBvYmplY3QgdXBkYXRlcycpO1xuICAgIH1cbiAgICB0aGlzLl91cGRhdGUgPSB0aGlzLl91cGRhdGUuY29uY2F0KGRvYyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5fdXBkYXRlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgbWl4IGFycmF5IGFuZCBvYmplY3QgdXBkYXRlcycpO1xuICAgIH1cbiAgICB1dGlscy5tZXJnZUNsb25lKHRoaXMuX3VwZGF0ZSwgZG9jKTtcbiAgfVxufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5hc3luYyBmdW5jdGlvbiBfdXBkYXRlVGh1bmsob3ApIHtcbiAgdGhpcy5fY2FzdENvbmRpdGlvbnMoKTtcblxuICBfY2FzdEFycmF5RmlsdGVycyh0aGlzKTtcblxuICBpZiAodGhpcy5lcnJvcigpICE9IG51bGwpIHtcbiAgICB0aHJvdyB0aGlzLmVycm9yKCk7XG4gIH1cblxuICBjb25zdCBjYXN0ZWRRdWVyeSA9IHRoaXMuX2NvbmRpdGlvbnM7XG4gIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zRm9yRXhlYyh0aGlzLm1vZGVsKTtcbiAgdGhpcy5fYXBwbHlUcmFuc2xhdGVBbGlhc2VzKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3VwZGF0ZSA9IGNsb25lKHRoaXMuX3VwZGF0ZSwgb3B0aW9ucyk7XG4gIGNvbnN0IGlzT3ZlcndyaXRpbmcgPSBvcCA9PT0gJ3JlcGxhY2VPbmUnO1xuICBpZiAoaXNPdmVyd3JpdGluZykge1xuICAgIHRoaXMuX3VwZGF0ZSA9IG5ldyB0aGlzLm1vZGVsKHRoaXMuX3VwZGF0ZSwgbnVsbCwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fdXBkYXRlID0gdGhpcy5fY2FzdFVwZGF0ZSh0aGlzLl91cGRhdGUpO1xuXG4gICAgaWYgKHRoaXMuX3VwZGF0ZSA9PSBudWxsIHx8IE9iamVjdC5rZXlzKHRoaXMuX3VwZGF0ZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4geyBhY2tub3dsZWRnZWQ6IGZhbHNlIH07XG4gICAgfVxuXG4gICAgY29uc3QgX29wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICBzZXREZWZhdWx0c09uSW5zZXJ0OiB0aGlzLl9tb25nb29zZU9wdGlvbnMuc2V0RGVmYXVsdHNPbkluc2VydFxuICAgIH0pO1xuICAgIHRoaXMuX3VwZGF0ZSA9IHNldERlZmF1bHRzT25JbnNlcnQodGhpcy5fY29uZGl0aW9ucywgdGhpcy5tb2RlbC5zY2hlbWEsXG4gICAgICB0aGlzLl91cGRhdGUsIF9vcHRzKTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMuYXJyYXlGaWx0ZXJzKSkge1xuICAgIG9wdGlvbnMuYXJyYXlGaWx0ZXJzID0gcmVtb3ZlVW51c2VkQXJyYXlGaWx0ZXJzKHRoaXMuX3VwZGF0ZSwgb3B0aW9ucy5hcnJheUZpbHRlcnMpO1xuICB9XG5cbiAgY29uc3QgcnVuVmFsaWRhdG9ycyA9IF9nZXRPcHRpb24odGhpcywgJ3J1blZhbGlkYXRvcnMnLCBmYWxzZSk7XG4gIGlmIChydW5WYWxpZGF0b3JzKSB7XG4gICAgYXdhaXQgdGhpcy52YWxpZGF0ZSh0aGlzLl91cGRhdGUsIG9wdGlvbnMsIGlzT3ZlcndyaXRpbmcpO1xuICB9XG5cbiAgaWYgKHRoaXMuX3VwZGF0ZS50b0JTT04pIHtcbiAgICB0aGlzLl91cGRhdGUgPSB0aGlzLl91cGRhdGUudG9CU09OKCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5tb25nb29zZUNvbGxlY3Rpb25bb3BdKGNhc3RlZFF1ZXJ5LCB0aGlzLl91cGRhdGUsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIE1vbmdvb3NlIGNhbGxzIHRoaXMgZnVuY3Rpb24gaW50ZXJuYWxseSB0byB2YWxpZGF0ZSB0aGUgcXVlcnkgaWZcbiAqIGBydW5WYWxpZGF0b3JzYCBpcyBzZXRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY2FzdGVkRG9jIHRoZSB1cGRhdGUsIGFmdGVyIGNhc3RpbmdcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSBvcHRpb25zIGZyb20gYF9vcHRpb25zRm9yRXhlYygpYFxuICogQHBhcmFtIHtCb29sZWFufSBpc092ZXJ3cml0aW5nXG4gKiBAbWV0aG9kIHZhbGlkYXRlXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnZhbGlkYXRlID0gYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGUoY2FzdGVkRG9jLCBvcHRpb25zLCBpc092ZXJ3cml0aW5nKSB7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzNdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ1F1ZXJ5LnByb3RvdHlwZS52YWxpZGF0ZSgpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGF3YWl0IF9leGVjdXRlUHJlSG9va3ModGhpcywgJ3ZhbGlkYXRlJyk7XG5cbiAgaWYgKGlzT3ZlcndyaXRpbmcpIHtcbiAgICBhd2FpdCBjYXN0ZWREb2MuJHZhbGlkYXRlKCk7XG4gIH0gZWxzZSB7XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdXBkYXRlVmFsaWRhdG9ycyh0aGlzLCB0aGlzLm1vZGVsLnNjaGVtYSwgY2FzdGVkRG9jLCBvcHRpb25zLCAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGF3YWl0IF9leGVjdXRlUG9zdEhvb2tzKHRoaXMsIG51bGwsIG51bGwsICd2YWxpZGF0ZScpO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIGFuIHVwZGF0ZU1hbnkgcXVlcnlcbiAqXG4gKiBAc2VlIE1vZGVsLnVwZGF0ZSBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL21vZGVsLmh0bWwjTW9kZWwudXBkYXRlKClcbiAqIEBtZXRob2QgX3VwZGF0ZU1hbnlcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuUXVlcnkucHJvdG90eXBlLl91cGRhdGVNYW55ID0gYXN5bmMgZnVuY3Rpb24gX3VwZGF0ZU1hbnkoKSB7XG4gIHJldHVybiBfdXBkYXRlVGh1bmsuY2FsbCh0aGlzLCAndXBkYXRlTWFueScpO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlIGFuIHVwZGF0ZU9uZSBxdWVyeVxuICpcbiAqIEBzZWUgTW9kZWwudXBkYXRlIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbC51cGRhdGUoKVxuICogQG1ldGhvZCBfdXBkYXRlT25lXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5fdXBkYXRlT25lID0gYXN5bmMgZnVuY3Rpb24gX3VwZGF0ZU9uZSgpIHtcbiAgcmV0dXJuIF91cGRhdGVUaHVuay5jYWxsKHRoaXMsICd1cGRhdGVPbmUnKTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZSBhIHJlcGxhY2VPbmUgcXVlcnlcbiAqXG4gKiBAc2VlIE1vZGVsLnJlcGxhY2VPbmUgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsLnJlcGxhY2VPbmUoKVxuICogQG1ldGhvZCBfcmVwbGFjZU9uZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5RdWVyeS5wcm90b3R5cGUuX3JlcGxhY2VPbmUgPSBhc3luYyBmdW5jdGlvbiBfcmVwbGFjZU9uZSgpIHtcbiAgcmV0dXJuIF91cGRhdGVUaHVuay5jYWxsKHRoaXMsICdyZXBsYWNlT25lJyk7XG59O1xuXG4vKipcbiAqIERlY2xhcmUgYW5kL29yIGV4ZWN1dGUgdGhpcyBxdWVyeSBhcyBhbiB1cGRhdGVNYW55KCkgb3BlcmF0aW9uLlxuICogTW9uZ29EQiB3aWxsIHVwZGF0ZSBfYWxsXyBkb2N1bWVudHMgdGhhdCBtYXRjaCBgZmlsdGVyYCAoYXMgb3Bwb3NlZCB0byBqdXN0IHRoZSBmaXJzdCBvbmUpLlxuICpcbiAqICoqTm90ZSoqIHVwZGF0ZU1hbnkgd2lsbCBfbm90XyBmaXJlIHVwZGF0ZSBtaWRkbGV3YXJlLiBVc2UgYHByZSgndXBkYXRlTWFueScpYFxuICogYW5kIGBwb3N0KCd1cGRhdGVNYW55JylgIGluc3RlYWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCByZXMgPSBhd2FpdCBQZXJzb24udXBkYXRlTWFueSh7IG5hbWU6IC9TdGFyayQvIH0sIHsgaXNEZWxldGVkOiB0cnVlIH0pO1xuICogICAgIHJlcy5uOyAvLyBOdW1iZXIgb2YgZG9jdW1lbnRzIG1hdGNoZWRcbiAqICAgICByZXMubk1vZGlmaWVkOyAvLyBOdW1iZXIgb2YgZG9jdW1lbnRzIG1vZGlmaWVkXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0cmlnZ2VycyB0aGUgZm9sbG93aW5nIG1pZGRsZXdhcmUuXG4gKlxuICogLSBgdXBkYXRlTWFueSgpYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZmlsdGVyXVxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IFt1cGRhdGVdIHRoZSB1cGRhdGUgY29tbWFuZC4gSWYgYXJyYXksIHRoaXMgdXBkYXRlIHdpbGwgYmUgdHJlYXRlZCBhcyBhbiB1cGRhdGUgcGlwZWxpbmUgYW5kIG5vdCBjYXN0ZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm11bHRpcGxlQ2FzdEVycm9yXSBieSBkZWZhdWx0LCBtb25nb29zZSBvbmx5IHJldHVybnMgdGhlIGZpcnN0IGVycm9yIHRoYXQgb2NjdXJyZWQgaW4gY2FzdGluZyB0aGUgcXVlcnkuIFR1cm4gb24gdGhpcyBvcHRpb24gdG8gYWdncmVnYXRlIGFsbCB0aGUgY2FzdCBlcnJvcnMuXG4gKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBbb3B0aW9ucy5zdHJpY3RdIG92ZXJ3cml0ZXMgdGhlIHNjaGVtYSdzIFtzdHJpY3QgbW9kZSBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdClcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXBzZXJ0PWZhbHNlXSBpZiB0cnVlLCBhbmQgbm8gZG9jdW1lbnRzIGZvdW5kLCBpbnNlcnQgYSBuZXcgZG9jdW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy53cml0ZUNvbmNlcm49bnVsbF0gc2V0cyB0aGUgW3dyaXRlIGNvbmNlcm5dKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLykgZm9yIHJlcGxpY2Egc2V0cy4gT3ZlcnJpZGVzIHRoZSBbc2NoZW1hLWxldmVsIHdyaXRlIGNvbmNlcm5dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3dyaXRlQ29uY2VybilcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudGltZXN0YW1wcz1udWxsXSBJZiBzZXQgdG8gYGZhbHNlYCBhbmQgW3NjaGVtYS1sZXZlbCB0aW1lc3RhbXBzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0aW1lc3RhbXBzKSBhcmUgZW5hYmxlZCwgc2tpcCB0aW1lc3RhbXBzIGZvciB0aGlzIHVwZGF0ZS4gRG9lcyBub3RoaW5nIGlmIHNjaGVtYS1sZXZlbCB0aW1lc3RhbXBzIGFyZSBub3Qgc2V0LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cmFuc2xhdGVBbGlhc2VzPW51bGxdIElmIHNldCB0byBgdHJ1ZWAsIHRyYW5zbGF0ZXMgYW55IHNjaGVtYS1kZWZpbmVkIGFsaWFzZXMgaW4gYGZpbHRlcmAsIGBwcm9qZWN0aW9uYCwgYHVwZGF0ZWAsIGFuZCBgZGlzdGluY3RgLiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIGFueSBjb25mbGljdHMgd2hlcmUgYm90aCBhbGlhcyBhbmQgcmF3IHByb3BlcnR5IGFyZSBkZWZpbmVkIG9uIHRoZSBzYW1lIG9iamVjdC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMub3ZlcndyaXRlRGlzY3JpbWluYXRvcktleT1mYWxzZV0gTW9uZ29vc2UgcmVtb3ZlcyBkaXNjcmltaW5hdG9yIGtleSB1cGRhdGVzIGZyb20gYHVwZGF0ZWAgYnkgZGVmYXVsdCwgc2V0IGBvdmVyd3JpdGVEaXNjcmltaW5hdG9yS2V5YCB0byBgdHJ1ZWAgdG8gYWxsb3cgdXBkYXRpbmcgdGhlIGRpc2NyaW1pbmF0b3Iga2V5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIHBhcmFtcyBhcmUgKGVycm9yLCB3cml0ZU9wUmVzdWx0KVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgTW9kZWwudXBkYXRlIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbC51cGRhdGUoKVxuICogQHNlZSBRdWVyeSBkb2NzIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9xdWVyaWVzLmh0bWxcbiAqIEBzZWUgdXBkYXRlIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvZGIuY29sbGVjdGlvbi51cGRhdGUvXG4gKiBAc2VlIFVwZGF0ZVJlc3VsdCBodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvVXBkYXRlUmVzdWx0Lmh0bWxcbiAqIEBzZWUgTW9uZ29EQiBkb2NzIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9jb21tYW5kL3VwZGF0ZS8jdXBkYXRlLWNvbW1hbmQtb3V0cHV0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS51cGRhdGVNYW55ID0gZnVuY3Rpb24oY29uZGl0aW9ucywgZG9jLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAudXBkYXRlKGNvbmRpdGlvbnMsIGRvYywgY2FsbGJhY2spXG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkb2MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAudXBkYXRlKGRvYywgY2FsbGJhY2spO1xuICAgIGNhbGxiYWNrID0gZG9jO1xuICAgIGRvYyA9IGNvbmRpdGlvbnM7XG4gICAgY29uZGl0aW9ucyA9IHt9O1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjb25kaXRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gLnVwZGF0ZShjYWxsYmFjaylcbiAgICBjYWxsYmFjayA9IGNvbmRpdGlvbnM7XG4gICAgY29uZGl0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICBkb2MgPSB1bmRlZmluZWQ7XG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY29uZGl0aW9ucyA9PT0gJ29iamVjdCcgJiYgIWRvYyAmJiAhb3B0aW9ucyAmJiAhY2FsbGJhY2spIHtcbiAgICAvLyAudXBkYXRlKGRvYylcbiAgICBkb2MgPSBjb25kaXRpb25zO1xuICAgIGNvbmRpdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICBjYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiBfdXBkYXRlKHRoaXMsICd1cGRhdGVNYW55JywgY29uZGl0aW9ucywgZG9jLCBvcHRpb25zLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIERlY2xhcmUgYW5kL29yIGV4ZWN1dGUgdGhpcyBxdWVyeSBhcyBhbiB1cGRhdGVPbmUoKSBvcGVyYXRpb24uXG4gKiBNb25nb0RCIHdpbGwgdXBkYXRlIF9vbmx5XyB0aGUgZmlyc3QgZG9jdW1lbnQgdGhhdCBtYXRjaGVzIGBmaWx0ZXJgLlxuICpcbiAqIC0gVXNlIGByZXBsYWNlT25lKClgIGlmIHlvdSB3YW50IHRvIG92ZXJ3cml0ZSBhbiBlbnRpcmUgZG9jdW1lbnQgcmF0aGVyIHRoYW4gdXNpbmcgW2F0b21pYyBvcGVyYXRvcnNdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3R1dG9yaWFsL21vZGVsLWRhdGEtZm9yLWF0b21pYy1vcGVyYXRpb25zLyNwYXR0ZXJuKSBsaWtlIGAkc2V0YC5cbiAqXG4gKiAqKk5vdGUqKiB1cGRhdGVPbmUgd2lsbCBfbm90XyBmaXJlIHVwZGF0ZSBtaWRkbGV3YXJlLiBVc2UgYHByZSgndXBkYXRlT25lJylgXG4gKiBhbmQgYHBvc3QoJ3VwZGF0ZU9uZScpYCBpbnN0ZWFkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcmVzID0gYXdhaXQgUGVyc29uLnVwZGF0ZU9uZSh7IG5hbWU6ICdKZWFuLUx1YyBQaWNhcmQnIH0sIHsgc2hpcDogJ1VTUyBFbnRlcnByaXNlJyB9KTtcbiAqICAgICByZXMuYWNrbm93bGVkZ2VkOyAvLyBJbmRpY2F0ZXMgaWYgdGhpcyB3cml0ZSByZXN1bHQgd2FzIGFja25vd2xlZGdlZC4gSWYgbm90LCB0aGVuIGFsbCBvdGhlciBtZW1iZXJzIG9mIHRoaXMgcmVzdWx0IHdpbGwgYmUgdW5kZWZpbmVkLlxuICogICAgIHJlcy5tYXRjaGVkQ291bnQ7IC8vIE51bWJlciBvZiBkb2N1bWVudHMgdGhhdCBtYXRjaGVkIHRoZSBmaWx0ZXJcbiAqICAgICByZXMubW9kaWZpZWRDb3VudDsgLy8gTnVtYmVyIG9mIGRvY3VtZW50cyB0aGF0IHdlcmUgbW9kaWZpZWRcbiAqICAgICByZXMudXBzZXJ0ZWRDb3VudDsgLy8gTnVtYmVyIG9mIGRvY3VtZW50cyB0aGF0IHdlcmUgdXBzZXJ0ZWRcbiAqICAgICByZXMudXBzZXJ0ZWRJZDsgLy8gSWRlbnRpZmllciBvZiB0aGUgaW5zZXJ0ZWQgZG9jdW1lbnQgKGlmIGFuIHVwc2VydCB0b29rIHBsYWNlKVxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZ2dlcnMgdGhlIGZvbGxvd2luZyBtaWRkbGV3YXJlLlxuICpcbiAqIC0gYHVwZGF0ZU9uZSgpYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZmlsdGVyXVxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IFt1cGRhdGVdIHRoZSB1cGRhdGUgY29tbWFuZC4gSWYgYXJyYXksIHRoaXMgdXBkYXRlIHdpbGwgYmUgdHJlYXRlZCBhcyBhbiB1cGRhdGUgcGlwZWxpbmUgYW5kIG5vdCBjYXN0ZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm11bHRpcGxlQ2FzdEVycm9yXSBieSBkZWZhdWx0LCBtb25nb29zZSBvbmx5IHJldHVybnMgdGhlIGZpcnN0IGVycm9yIHRoYXQgb2NjdXJyZWQgaW4gY2FzdGluZyB0aGUgcXVlcnkuIFR1cm4gb24gdGhpcyBvcHRpb24gdG8gYWdncmVnYXRlIGFsbCB0aGUgY2FzdCBlcnJvcnMuXG4gKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBbb3B0aW9ucy5zdHJpY3RdIG92ZXJ3cml0ZXMgdGhlIHNjaGVtYSdzIFtzdHJpY3QgbW9kZSBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdClcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXBzZXJ0PWZhbHNlXSBpZiB0cnVlLCBhbmQgbm8gZG9jdW1lbnRzIGZvdW5kLCBpbnNlcnQgYSBuZXcgZG9jdW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy53cml0ZUNvbmNlcm49bnVsbF0gc2V0cyB0aGUgW3dyaXRlIGNvbmNlcm5dKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLykgZm9yIHJlcGxpY2Egc2V0cy4gT3ZlcnJpZGVzIHRoZSBbc2NoZW1hLWxldmVsIHdyaXRlIGNvbmNlcm5dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3dyaXRlQ29uY2VybilcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudGltZXN0YW1wcz1udWxsXSBJZiBzZXQgdG8gYGZhbHNlYCBhbmQgW3NjaGVtYS1sZXZlbCB0aW1lc3RhbXBzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0aW1lc3RhbXBzKSBhcmUgZW5hYmxlZCwgc2tpcCB0aW1lc3RhbXBzIGZvciB0aGlzIHVwZGF0ZS4gTm90ZSB0aGF0IHRoaXMgYWxsb3dzIHlvdSB0byBvdmVyd3JpdGUgdGltZXN0YW1wcy4gRG9lcyBub3RoaW5nIGlmIHNjaGVtYS1sZXZlbCB0aW1lc3RhbXBzIGFyZSBub3Qgc2V0LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cmFuc2xhdGVBbGlhc2VzPW51bGxdIElmIHNldCB0byBgdHJ1ZWAsIHRyYW5zbGF0ZXMgYW55IHNjaGVtYS1kZWZpbmVkIGFsaWFzZXMgaW4gYGZpbHRlcmAsIGBwcm9qZWN0aW9uYCwgYHVwZGF0ZWAsIGFuZCBgZGlzdGluY3RgLiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIGFueSBjb25mbGljdHMgd2hlcmUgYm90aCBhbGlhcyBhbmQgcmF3IHByb3BlcnR5IGFyZSBkZWZpbmVkIG9uIHRoZSBzYW1lIG9iamVjdC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMub3ZlcndyaXRlRGlzY3JpbWluYXRvcktleT1mYWxzZV0gTW9uZ29vc2UgcmVtb3ZlcyBkaXNjcmltaW5hdG9yIGtleSB1cGRhdGVzIGZyb20gYHVwZGF0ZWAgYnkgZGVmYXVsdCwgc2V0IGBvdmVyd3JpdGVEaXNjcmltaW5hdG9yS2V5YCB0byBgdHJ1ZWAgdG8gYWxsb3cgdXBkYXRpbmcgdGhlIGRpc2NyaW1pbmF0b3Iga2V5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIHBhcmFtcyBhcmUgKGVycm9yLCB3cml0ZU9wUmVzdWx0KVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgTW9kZWwudXBkYXRlIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvbW9kZWwuaHRtbCNNb2RlbC51cGRhdGUoKVxuICogQHNlZSBRdWVyeSBkb2NzIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9xdWVyaWVzLmh0bWxcbiAqIEBzZWUgdXBkYXRlIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvZGIuY29sbGVjdGlvbi51cGRhdGUvXG4gKiBAc2VlIFVwZGF0ZVJlc3VsdCBodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2ludGVyZmFjZXMvVXBkYXRlUmVzdWx0Lmh0bWxcbiAqIEBzZWUgTW9uZ29EQiBkb2NzIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9jb21tYW5kL3VwZGF0ZS8jdXBkYXRlLWNvbW1hbmQtb3V0cHV0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS51cGRhdGVPbmUgPSBmdW5jdGlvbihjb25kaXRpb25zLCBkb2MsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIC51cGRhdGUoY29uZGl0aW9ucywgZG9jLCBjYWxsYmFjaylcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRvYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIC51cGRhdGUoZG9jLCBjYWxsYmFjayk7XG4gICAgY2FsbGJhY2sgPSBkb2M7XG4gICAgZG9jID0gY29uZGl0aW9ucztcbiAgICBjb25kaXRpb25zID0ge307XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNvbmRpdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAudXBkYXRlKGNhbGxiYWNrKVxuICAgIGNhbGxiYWNrID0gY29uZGl0aW9ucztcbiAgICBjb25kaXRpb25zID0gdW5kZWZpbmVkO1xuICAgIGRvYyA9IHVuZGVmaW5lZDtcbiAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjb25kaXRpb25zID09PSAnb2JqZWN0JyAmJiAhZG9jICYmICFvcHRpb25zICYmICFjYWxsYmFjaykge1xuICAgIC8vIC51cGRhdGUoZG9jKVxuICAgIGRvYyA9IGNvbmRpdGlvbnM7XG4gICAgY29uZGl0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIGNhbGxiYWNrID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIF91cGRhdGUodGhpcywgJ3VwZGF0ZU9uZScsIGNvbmRpdGlvbnMsIGRvYywgb3B0aW9ucywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBEZWNsYXJlIGFuZC9vciBleGVjdXRlIHRoaXMgcXVlcnkgYXMgYSByZXBsYWNlT25lKCkgb3BlcmF0aW9uLlxuICogTW9uZ29EQiB3aWxsIHJlcGxhY2UgdGhlIGV4aXN0aW5nIGRvY3VtZW50IGFuZCB3aWxsIG5vdCBhY2NlcHQgYW55IFthdG9taWMgb3BlcmF0b3JzXShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC90dXRvcmlhbC9tb2RlbC1kYXRhLWZvci1hdG9taWMtb3BlcmF0aW9ucy8jcGF0dGVybikgKGAkc2V0YCwgZXRjLilcbiAqXG4gKiAqKk5vdGUqKiByZXBsYWNlT25lIHdpbGwgX25vdF8gZmlyZSB1cGRhdGUgbWlkZGxld2FyZS4gVXNlIGBwcmUoJ3JlcGxhY2VPbmUnKWBcbiAqIGFuZCBgcG9zdCgncmVwbGFjZU9uZScpYCBpbnN0ZWFkLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcmVzID0gYXdhaXQgUGVyc29uLnJlcGxhY2VPbmUoeyBfaWQ6IDI0NjAxIH0sIHsgbmFtZTogJ0plYW4gVmFsamVhbicgfSk7XG4gKiAgICAgcmVzLmFja25vd2xlZGdlZDsgLy8gSW5kaWNhdGVzIGlmIHRoaXMgd3JpdGUgcmVzdWx0IHdhcyBhY2tub3dsZWRnZWQuIElmIG5vdCwgdGhlbiBhbGwgb3RoZXIgbWVtYmVycyBvZiB0aGlzIHJlc3VsdCB3aWxsIGJlIHVuZGVmaW5lZC5cbiAqICAgICByZXMubWF0Y2hlZENvdW50OyAvLyBOdW1iZXIgb2YgZG9jdW1lbnRzIHRoYXQgbWF0Y2hlZCB0aGUgZmlsdGVyXG4gKiAgICAgcmVzLm1vZGlmaWVkQ291bnQ7IC8vIE51bWJlciBvZiBkb2N1bWVudHMgdGhhdCB3ZXJlIG1vZGlmaWVkXG4gKiAgICAgcmVzLnVwc2VydGVkQ291bnQ7IC8vIE51bWJlciBvZiBkb2N1bWVudHMgdGhhdCB3ZXJlIHVwc2VydGVkXG4gKiAgICAgcmVzLnVwc2VydGVkSWQ7IC8vIElkZW50aWZpZXIgb2YgdGhlIGluc2VydGVkIGRvY3VtZW50IChpZiBhbiB1cHNlcnQgdG9vayBwbGFjZSlcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHRyaWdnZXJzIHRoZSBmb2xsb3dpbmcgbWlkZGxld2FyZS5cbiAqXG4gKiAtIGByZXBsYWNlT25lKClgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtmaWx0ZXJdXG4gKiBAcGFyYW0ge09iamVjdH0gW2RvY10gdGhlIHVwZGF0ZSBjb21tYW5kXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm11bHRpcGxlQ2FzdEVycm9yXSBieSBkZWZhdWx0LCBtb25nb29zZSBvbmx5IHJldHVybnMgdGhlIGZpcnN0IGVycm9yIHRoYXQgb2NjdXJyZWQgaW4gY2FzdGluZyB0aGUgcXVlcnkuIFR1cm4gb24gdGhpcyBvcHRpb24gdG8gYWdncmVnYXRlIGFsbCB0aGUgY2FzdCBlcnJvcnMuXG4gKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBbb3B0aW9ucy5zdHJpY3RdIG92ZXJ3cml0ZXMgdGhlIHNjaGVtYSdzIFtzdHJpY3QgbW9kZSBvcHRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdClcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudXBzZXJ0PWZhbHNlXSBpZiB0cnVlLCBhbmQgbm8gZG9jdW1lbnRzIGZvdW5kLCBpbnNlcnQgYSBuZXcgZG9jdW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy53cml0ZUNvbmNlcm49bnVsbF0gc2V0cyB0aGUgW3dyaXRlIGNvbmNlcm5dKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS93cml0ZS1jb25jZXJuLykgZm9yIHJlcGxpY2Egc2V0cy4gT3ZlcnJpZGVzIHRoZSBbc2NoZW1hLWxldmVsIHdyaXRlIGNvbmNlcm5dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3dyaXRlQ29uY2VybilcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudGltZXN0YW1wcz1udWxsXSBJZiBzZXQgdG8gYGZhbHNlYCBhbmQgW3NjaGVtYS1sZXZlbCB0aW1lc3RhbXBzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0aW1lc3RhbXBzKSBhcmUgZW5hYmxlZCwgc2tpcCB0aW1lc3RhbXBzIGZvciB0aGlzIHVwZGF0ZS4gRG9lcyBub3RoaW5nIGlmIHNjaGVtYS1sZXZlbCB0aW1lc3RhbXBzIGFyZSBub3Qgc2V0LlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy50cmFuc2xhdGVBbGlhc2VzPW51bGxdIElmIHNldCB0byBgdHJ1ZWAsIHRyYW5zbGF0ZXMgYW55IHNjaGVtYS1kZWZpbmVkIGFsaWFzZXMgaW4gYGZpbHRlcmAsIGBwcm9qZWN0aW9uYCwgYHVwZGF0ZWAsIGFuZCBgZGlzdGluY3RgLiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIGFueSBjb25mbGljdHMgd2hlcmUgYm90aCBhbGlhcyBhbmQgcmF3IHByb3BlcnR5IGFyZSBkZWZpbmVkIG9uIHRoZSBzYW1lIG9iamVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gcGFyYW1zIGFyZSAoZXJyb3IsIHdyaXRlT3BSZXN1bHQpXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSBNb2RlbC51cGRhdGUgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsLnVwZGF0ZSgpXG4gKiBAc2VlIFF1ZXJ5IGRvY3MgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3F1ZXJpZXMuaHRtbFxuICogQHNlZSB1cGRhdGUgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9kYi5jb2xsZWN0aW9uLnVwZGF0ZS9cbiAqIEBzZWUgVXBkYXRlUmVzdWx0IGh0dHBzOi8vbW9uZ29kYi5naXRodWIuaW8vbm9kZS1tb25nb2RiLW5hdGl2ZS80LjkvaW50ZXJmYWNlcy9VcGRhdGVSZXN1bHQuaHRtbFxuICogQHNlZSBNb25nb0RCIGRvY3MgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL2NvbW1hbmQvdXBkYXRlLyN1cGRhdGUtY29tbWFuZC1vdXRwdXRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnJlcGxhY2VPbmUgPSBmdW5jdGlvbihjb25kaXRpb25zLCBkb2MsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIC51cGRhdGUoY29uZGl0aW9ucywgZG9jLCBjYWxsYmFjaylcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRvYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIC51cGRhdGUoZG9jLCBjYWxsYmFjayk7XG4gICAgY2FsbGJhY2sgPSBkb2M7XG4gICAgZG9jID0gY29uZGl0aW9ucztcbiAgICBjb25kaXRpb25zID0ge307XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNvbmRpdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAudXBkYXRlKGNhbGxiYWNrKVxuICAgIGNhbGxiYWNrID0gY29uZGl0aW9ucztcbiAgICBjb25kaXRpb25zID0gdW5kZWZpbmVkO1xuICAgIGRvYyA9IHVuZGVmaW5lZDtcbiAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjb25kaXRpb25zID09PSAnb2JqZWN0JyAmJiAhZG9jICYmICFvcHRpb25zICYmICFjYWxsYmFjaykge1xuICAgIC8vIC51cGRhdGUoZG9jKVxuICAgIGRvYyA9IGNvbmRpdGlvbnM7XG4gICAgY29uZGl0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIGNhbGxiYWNrID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIF91cGRhdGUodGhpcywgJ3JlcGxhY2VPbmUnLCBjb25kaXRpb25zLCBkb2MsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIGZvciB1cGRhdGUsIHVwZGF0ZU1hbnksIHVwZGF0ZU9uZSwgcmVwbGFjZU9uZVxuICogQHBhcmFtIHtRdWVyeX0gcXVlcnlcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcFxuICogQHBhcmFtIHtPYmplY3R9IGZpbHRlclxuICogQHBhcmFtIHtEb2N1bWVudH0gW2RvY11cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBfdXBkYXRlKHF1ZXJ5LCBvcCwgZmlsdGVyLCBkb2MsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIC8vIG1ha2Ugc3VyZSB3ZSBkb24ndCBzZW5kIGluIHRoZSB3aG9sZSBEb2N1bWVudCB0byBtZXJnZSgpXG4gIHF1ZXJ5Lm9wID0gb3A7XG4gIHF1ZXJ5Ll92YWxpZGF0ZU9wKCk7XG4gIGRvYyA9IGRvYyB8fCB7fTtcblxuICAvLyBzdHJpY3QgaXMgYW4gb3B0aW9uIHVzZWQgaW4gdGhlIHVwZGF0ZSBjaGVja2luZywgbWFrZSBzdXJlIGl0IGdldHMgc2V0XG4gIGlmIChvcHRpb25zICE9IG51bGwpIHtcbiAgICBpZiAoJ3N0cmljdCcgaW4gb3B0aW9ucykge1xuICAgICAgcXVlcnkuX21vbmdvb3NlT3B0aW9ucy5zdHJpY3QgPSBvcHRpb25zLnN0cmljdDtcbiAgICB9XG4gIH1cblxuICBpZiAoIShmaWx0ZXIgaW5zdGFuY2VvZiBRdWVyeSkgJiZcbiAgICAgIGZpbHRlciAhPSBudWxsICYmXG4gICAgICBmaWx0ZXIudG9TdHJpbmcoKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICBxdWVyeS5lcnJvcihuZXcgT2JqZWN0UGFyYW1ldGVyRXJyb3IoZmlsdGVyLCAnZmlsdGVyJywgb3ApKTtcbiAgfSBlbHNlIHtcbiAgICBxdWVyeS5tZXJnZShmaWx0ZXIpO1xuICB9XG5cbiAgaWYgKHV0aWxzLmlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgcXVlcnkuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIHF1ZXJ5Ll9tZXJnZVVwZGF0ZShkb2MpO1xuXG4gIC8vIEhvb2tzXG4gIGlmIChjYWxsYmFjaykge1xuICAgIHF1ZXJ5LmV4ZWMoY2FsbGJhY2spO1xuXG4gICAgcmV0dXJuIHF1ZXJ5O1xuICB9XG5cbiAgcmV0dXJuIHF1ZXJ5O1xufVxuXG4vKipcbiAqIFJ1bnMgYSBmdW5jdGlvbiBgZm5gIGFuZCB0cmVhdHMgdGhlIHJldHVybiB2YWx1ZSBvZiBgZm5gIGFzIHRoZSBuZXcgdmFsdWVcbiAqIGZvciB0aGUgcXVlcnkgdG8gcmVzb2x2ZSB0by5cbiAqXG4gKiBBbnkgZnVuY3Rpb25zIHlvdSBwYXNzIHRvIGB0cmFuc2Zvcm0oKWAgd2lsbCBydW4gKiphZnRlcioqIGFueSBwb3N0IGhvb2tzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcmVzID0gYXdhaXQgTXlNb2RlbC5maW5kT25lKCkudHJhbnNmb3JtKHJlcyA9PiB7XG4gKiAgICAgICAvLyBTZXRzIGEgYGxvYWRlZEF0YCBwcm9wZXJ0eSBvbiB0aGUgZG9jIHRoYXQgdGVsbHMgeW91IHRoZSB0aW1lIHRoZVxuICogICAgICAgLy8gZG9jdW1lbnQgd2FzIGxvYWRlZC5cbiAqICAgICAgIHJldHVybiByZXMgPT0gbnVsbCA/XG4gKiAgICAgICAgIHJlcyA6XG4gKiAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzLCB7IGxvYWRlZEF0OiBuZXcgRGF0ZSgpIH0pO1xuICogICAgIH0pO1xuICpcbiAqIEBtZXRob2QgdHJhbnNmb3JtXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gZnVuY3Rpb24gdG8gcnVuIHRvIHRyYW5zZm9ybSB0aGUgcXVlcnkgcmVzdWx0XG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbihmbikge1xuICB0aGlzLl90cmFuc2Zvcm1zLnB1c2goZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTWFrZSB0aGlzIHF1ZXJ5IHRocm93IGFuIGVycm9yIGlmIG5vIGRvY3VtZW50cyBtYXRjaCB0aGUgZ2l2ZW4gYGZpbHRlcmAuXG4gKiBUaGlzIGlzIGhhbmR5IGZvciBpbnRlZ3JhdGluZyB3aXRoIGFzeW5jL2F3YWl0LCBiZWNhdXNlIGBvckZhaWwoKWAgc2F2ZXMgeW91XG4gKiBhbiBleHRyYSBgaWZgIHN0YXRlbWVudCB0byBjaGVjayBpZiBubyBkb2N1bWVudCB3YXMgZm91bmQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBUaHJvd3MgaWYgbm8gZG9jIHJldHVybmVkXG4gKiAgICAgYXdhaXQgTW9kZWwuZmluZE9uZSh7IGZvbzogJ2JhcicgfSkub3JGYWlsKCk7XG4gKlxuICogICAgIC8vIFRocm93cyBpZiBubyBkb2N1bWVudCB3YXMgdXBkYXRlZC4gTm90ZSB0aGF0IGBvckZhaWwoKWAgd2lsbCBzdGlsbFxuICogICAgIC8vIHRocm93IGlmIHRoZSBvbmx5IGRvY3VtZW50IHRoYXQgbWF0Y2hlcyBpcyBgeyBmb286ICdiYXInLCBuYW1lOiAndGVzdCcgfWAsXG4gKiAgICAgLy8gYmVjYXVzZSBgb3JGYWlsKClgIHdpbGwgdGhyb3cgaWYgbm8gZG9jdW1lbnQgd2FzIF91cGRhdGVkXywgbm90XG4gKiAgICAgLy8gaWYgbm8gZG9jdW1lbnQgd2FzIF9mb3VuZF8uXG4gKiAgICAgYXdhaXQgTW9kZWwudXBkYXRlT25lKHsgZm9vOiAnYmFyJyB9LCB7IG5hbWU6ICd0ZXN0JyB9KS5vckZhaWwoKTtcbiAqXG4gKiAgICAgLy8gVGhyb3dzIFwiTm8gZG9jcyBmb3VuZCFcIiBlcnJvciBpZiBubyBkb2NzIG1hdGNoIGB7IGZvbzogJ2JhcicgfWBcbiAqICAgICBhd2FpdCBNb2RlbC5maW5kKHsgZm9vOiAnYmFyJyB9KS5vckZhaWwobmV3IEVycm9yKCdObyBkb2NzIGZvdW5kIScpKTtcbiAqXG4gKiAgICAgLy8gVGhyb3dzIFwiTm90IGZvdW5kXCIgZXJyb3IgaWYgbm8gZG9jdW1lbnQgd2FzIGZvdW5kXG4gKiAgICAgYXdhaXQgTW9kZWwuZmluZE9uZUFuZFVwZGF0ZSh7IGZvbzogJ2JhcicgfSwgeyBuYW1lOiAndGVzdCcgfSkuXG4gKiAgICAgICBvckZhaWwoKCkgPT4gRXJyb3IoJ05vdCBmb3VuZCcpKTtcbiAqXG4gKiBAbWV0aG9kIG9yRmFpbFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7RnVuY3Rpb258RXJyb3J9IFtlcnJdIG9wdGlvbmFsIGVycm9yIHRvIHRocm93IGlmIG5vIGRvY3MgbWF0Y2ggYGZpbHRlcmAuIElmIG5vdCBzcGVjaWZpZWQsIGBvckZhaWwoKWAgd2lsbCB0aHJvdyBhIGBEb2N1bWVudE5vdEZvdW5kRXJyb3JgXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5vckZhaWwgPSBmdW5jdGlvbihlcnIpIHtcbiAgdGhpcy50cmFuc2Zvcm0ocmVzID0+IHtcbiAgICBzd2l0Y2ggKHRoaXMub3ApIHtcbiAgICAgIGNhc2UgJ2ZpbmQnOlxuICAgICAgICBpZiAocmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IF9vckZhaWxFcnJvcihlcnIsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZmluZE9uZSc6XG4gICAgICAgIGlmIChyZXMgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IF9vckZhaWxFcnJvcihlcnIsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmVwbGFjZU9uZSc6XG4gICAgICBjYXNlICd1cGRhdGVNYW55JzpcbiAgICAgIGNhc2UgJ3VwZGF0ZU9uZSc6XG4gICAgICAgIGlmIChyZXMgJiYgcmVzLm1hdGNoZWRDb3VudCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IF9vckZhaWxFcnJvcihlcnIsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZmluZE9uZUFuZERlbGV0ZSc6XG4gICAgICBjYXNlICdmaW5kT25lQW5kVXBkYXRlJzpcbiAgICAgIGNhc2UgJ2ZpbmRPbmVBbmRSZXBsYWNlJzpcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbmNsdWRlUmVzdWx0TWV0YWRhdGEgJiYgcmVzICE9IG51bGwgJiYgcmVzLnZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBfb3JGYWlsRXJyb3IoZXJyLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5pbmNsdWRlUmVzdWx0TWV0YWRhdGEgJiYgcmVzID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBfb3JGYWlsRXJyb3IoZXJyLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2RlbGV0ZU1hbnknOlxuICAgICAgY2FzZSAnZGVsZXRlT25lJzpcbiAgICAgICAgaWYgKHJlcy5kZWxldGVkQ291bnQgPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBfb3JGYWlsRXJyb3IoZXJyLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBlcnJvciB0byB0aHJvdyBmb3IgYG9yRmFpbCgpYFxuICogQHBhcmFtIHtFcnJvcnx1bmRlZmluZWR9IGVyclxuICogQHBhcmFtIHtRdWVyeX0gcXVlcnlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIF9vckZhaWxFcnJvcihlcnIsIHF1ZXJ5KSB7XG4gIGlmICh0eXBlb2YgZXJyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXJyID0gZXJyLmNhbGwocXVlcnkpO1xuICB9XG5cbiAgaWYgKGVyciA9PSBudWxsKSB7XG4gICAgZXJyID0gbmV3IERvY3VtZW50Tm90Rm91bmRFcnJvcihxdWVyeS5nZXRRdWVyeSgpLCBxdWVyeS5tb2RlbC5tb2RlbE5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIGVycjtcbn1cblxuLyoqXG4gKiBXcmFwcGVyIGZ1bmN0aW9uIHRvIGNhbGwgaXNQYXRoU2VsZWN0ZWRJbmNsdXNpdmUgb24gYSBxdWVyeS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuaXNQYXRoU2VsZWN0ZWRJbmNsdXNpdmUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBpc1BhdGhTZWxlY3RlZEluY2x1c2l2ZSh0aGlzLl9maWVsZHMsIHBhdGgpO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyB0aGUgcXVlcnlcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHByb21pc2UgPSBxdWVyeS5leGVjKCk7XG4gKiAgICAgY29uc3QgcHJvbWlzZSA9IHF1ZXJ5LmV4ZWMoJ3VwZGF0ZScpO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBbb3BlcmF0aW9uXVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmV4ZWMgPSBhc3luYyBmdW5jdGlvbiBleGVjKG9wKSB7XG4gIGlmICh0eXBlb2Ygb3AgPT09ICdmdW5jdGlvbicgfHwgKGFyZ3VtZW50cy5sZW5ndGggPj0gMiAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdRdWVyeS5wcm90b3R5cGUuZXhlYygpIG5vIGxvbmdlciBhY2NlcHRzIGEgY2FsbGJhY2snKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy5vcCA9IG9wO1xuICB9XG5cbiAgaWYgKHRoaXMub3AgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdRdWVyeSBtdXN0IGhhdmUgYG9wYCBiZWZvcmUgZXhlY3V0aW5nJyk7XG4gIH1cbiAgaWYgKHRoaXMubW9kZWwgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdRdWVyeSBtdXN0IGhhdmUgYW4gYXNzb2NpYXRlZCBtb2RlbCBiZWZvcmUgZXhlY3V0aW5nJyk7XG4gIH1cbiAgdGhpcy5fdmFsaWRhdGVPcCgpO1xuXG4gIGlmICghdGhpcy5vcCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnNvcnQpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5vcHRpb25zLnNvcnQpO1xuICAgIGlmIChrZXlzLmluY2x1ZGVzKCcnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGZpZWxkIFwiXCIgcGFzc2VkIHRvIHNvcnQoKScpO1xuICAgIH1cbiAgfVxuXG4gIGxldCB0aHVuayA9ICdfJyArIHRoaXMub3A7XG4gIGlmICh0aGlzLm9wID09PSAnZGlzdGluY3QnKSB7XG4gICAgdGh1bmsgPSAnX19kaXN0aW5jdCc7XG4gIH1cblxuICBpZiAodGhpcy5fZXhlY3V0aW9uU3RhY2sgIT0gbnVsbCkge1xuICAgIGxldCBzdHIgPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgaWYgKHN0ci5sZW5ndGggPiA2MCkge1xuICAgICAgc3RyID0gc3RyLnNsaWNlKDAsIDYwKSArICcuLi4nO1xuICAgIH1cbiAgICBjb25zdCBlcnIgPSBuZXcgTW9uZ29vc2VFcnJvcignUXVlcnkgd2FzIGFscmVhZHkgZXhlY3V0ZWQ6ICcgKyBzdHIpO1xuICAgIGVyci5vcmlnaW5hbFN0YWNrID0gdGhpcy5fZXhlY3V0aW9uU3RhY2suc3RhY2s7XG4gICAgdGhyb3cgZXJyO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2V4ZWN1dGlvblN0YWNrID0gbmV3IEVycm9yKCk7XG4gIH1cblxuICBsZXQgc2tpcFdyYXBwZWRGdW5jdGlvbiA9IG51bGw7XG4gIHRyeSB7XG4gICAgYXdhaXQgX2V4ZWN1dGVQcmVFeGVjSG9va3ModGhpcyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBLYXJlZW0uc2tpcFdyYXBwZWRGdW5jdGlvbikge1xuICAgICAgc2tpcFdyYXBwZWRGdW5jdGlvbiA9IGVycjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuXG4gIGxldCByZXM7XG5cbiAgbGV0IGVycm9yID0gbnVsbDtcbiAgdHJ5IHtcbiAgICBhd2FpdCBfZXhlY3V0ZVByZUhvb2tzKHRoaXMpO1xuICAgIHJlcyA9IHNraXBXcmFwcGVkRnVuY3Rpb24gPyBza2lwV3JhcHBlZEZ1bmN0aW9uLmFyZ3NbMF0gOiBhd2FpdCB0aGlzW3RodW5rXSgpO1xuXG4gICAgZm9yIChjb25zdCBmbiBvZiB0aGlzLl90cmFuc2Zvcm1zKSB7XG4gICAgICByZXMgPSBmbihyZXMpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIEthcmVlbS5za2lwV3JhcHBlZEZ1bmN0aW9uKSB7XG4gICAgICByZXMgPSBlcnIuYXJnc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3IgPSBlcnI7XG4gICAgfVxuICB9XG5cbiAgcmVzID0gYXdhaXQgX2V4ZWN1dGVQb3N0SG9va3ModGhpcywgcmVzLCBlcnJvcik7XG5cbiAgYXdhaXQgX2V4ZWN1dGVQb3N0RXhlY0hvb2tzKHRoaXMpO1xuXG4gIHJldHVybiByZXM7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9leGVjdXRlUG9zdEV4ZWNIb29rcyhxdWVyeSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHF1ZXJ5Ll9ob29rcy5leGVjUG9zdCgnZXhlYycsIHF1ZXJ5LCBbXSwge30sIChlcnJvcikgPT4ge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICByZXNvbHZlKCk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9leGVjdXRlUG9zdEhvb2tzKHF1ZXJ5LCByZXMsIGVycm9yLCBvcCkge1xuICBpZiAocXVlcnkuX3F1ZXJ5TWlkZGxld2FyZSA9PSBudWxsKSB7XG4gICAgaWYgKGVycm9yICE9IG51bGwpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBvcHRzID0gZXJyb3IgPyB7IGVycm9yIH0gOiB7fTtcblxuICAgIHF1ZXJ5Ll9xdWVyeU1pZGRsZXdhcmUuZXhlY1Bvc3Qob3AgfHwgcXVlcnkub3AsIHF1ZXJ5LCBbcmVzXSwgb3B0cywgKGVycm9yLCByZXMpID0+IHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZShyZXMpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfZXhlY3V0ZVByZUV4ZWNIb29rcyhxdWVyeSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHF1ZXJ5Ll9ob29rcy5leGVjUHJlKCdleGVjJywgcXVlcnksIFtdLCAoZXJyb3IpID0+IHtcbiAgICAgIGlmIChlcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfZXhlY3V0ZVByZUhvb2tzKHF1ZXJ5LCBvcCkge1xuICBpZiAocXVlcnkuX3F1ZXJ5TWlkZGxld2FyZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBxdWVyeS5fcXVlcnlNaWRkbGV3YXJlLmV4ZWNQcmUob3AgfHwgcXVlcnkub3AsIHF1ZXJ5LCBbXSwgKGVycm9yKSA9PiB7XG4gICAgICBpZiAoZXJyb3IgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogRXhlY3V0ZXMgdGhlIHF1ZXJ5IHJldHVybmluZyBhIGBQcm9taXNlYCB3aGljaCB3aWxsIGJlXG4gKiByZXNvbHZlZCB3aXRoIGVpdGhlciB0aGUgZG9jKHMpIG9yIHJlamVjdGVkIHdpdGggdGhlIGVycm9yLlxuICpcbiAqIE1vcmUgYWJvdXQgW2B0aGVuKClgIGluIEphdmFTY3JpcHRdKGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy90aGVuKS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZWplY3RdXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICByZXR1cm4gdGhpcy5leGVjKCkudGhlbihyZXNvbHZlLCByZWplY3QpO1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyB0aGUgcXVlcnkgcmV0dXJuaW5nIGEgYFByb21pc2VgIHdoaWNoIHdpbGwgYmVcbiAqIHJlc29sdmVkIHdpdGggZWl0aGVyIHRoZSBkb2Mocykgb3IgcmVqZWN0ZWQgd2l0aCB0aGUgZXJyb3IuXG4gKiBMaWtlIGAudGhlbigpYCwgYnV0IG9ubHkgdGFrZXMgYSByZWplY3Rpb24gaGFuZGxlci5cbiAqXG4gKiBNb3JlIGFib3V0IFtQcm9taXNlIGBjYXRjaCgpYCBpbiBKYXZhU2NyaXB0XShodHRwczovL21hc3RlcmluZ2pzLmlvL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvY2F0Y2gpLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZWplY3RdXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuY2F0Y2ggPSBmdW5jdGlvbihyZWplY3QpIHtcbiAgcmV0dXJuIHRoaXMuZXhlYygpLnRoZW4obnVsbCwgcmVqZWN0KTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgdGhlIHF1ZXJ5IHJldHVybmluZyBhIGBQcm9taXNlYCB3aGljaCB3aWxsIGJlXG4gKiByZXNvbHZlZCB3aXRoIGAuZmluYWxseSgpYCBjaGFpbmVkLlxuICpcbiAqIE1vcmUgYWJvdXQgW1Byb21pc2UgYGZpbmFsbHkoKWAgaW4gSmF2YVNjcmlwdF0oaHR0cHM6Ly90aGVjb2RlYmFyYmFyaWFuLmNvbS91c2luZy1wcm9taXNlLWZpbmFsbHktaW4tbm9kZS1qcy5odG1sKS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25GaW5hbGx5XVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLmZpbmFsbHkgPSBmdW5jdGlvbihvbkZpbmFsbHkpIHtcbiAgcmV0dXJuIHRoaXMuZXhlYygpLmZpbmFsbHkob25GaW5hbGx5KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHF1ZXJ5LlxuICpcbiAqIE1vcmUgYWJvdXQgW2B0b1N0cmluZygpYCBpbiBKYXZhU2NyaXB0XShodHRwczovL21hc3RlcmluZ2pzLmlvL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvdG9zdHJpbmcpLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqICAgICBjb25zdCBxID0gTW9kZWwuZmluZCgpO1xuICogICAgIGNvbnNvbGUubG9nKHEpOyAvLyBQcmludHMgXCJRdWVyeSB7IGZpbmQgfVwiXG4gKlxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgW1N5bWJvbC50b1N0cmluZ1RhZ11cbiAqIEBtZW1iZXJPZiBRdWVyeVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZVtTeW1ib2wudG9TdHJpbmdUYWddID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiBgUXVlcnkgeyAke3RoaXMub3B9IH1gO1xufTtcblxuLyoqXG4gKiBBZGQgcHJlIFttaWRkbGV3YXJlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvbWlkZGxld2FyZS5odG1sKSB0byB0aGlzIHF1ZXJ5IGluc3RhbmNlLiBEb2Vzbid0IGFmZmVjdFxuICogb3RoZXIgcXVlcmllcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHExID0gUXVlc3Rpb24uZmluZCh7IGFuc3dlcjogNDIgfSk7XG4gKiAgICAgcTEucHJlKGZ1bmN0aW9uIG1pZGRsZXdhcmUoKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyh0aGlzLmdldEZpbHRlcigpKTtcbiAqICAgICB9KTtcbiAqICAgICBhd2FpdCBxMS5leGVjKCk7IC8vIFByaW50cyBcInsgYW5zd2VyOiA0MiB9XCJcbiAqXG4gKiAgICAgLy8gRG9lc24ndCBwcmludCBhbnl0aGluZywgYmVjYXVzZSBgbWlkZGxld2FyZSgpYCBpcyBvbmx5XG4gKiAgICAgLy8gcmVnaXN0ZXJlZCBvbiBgcTFgLlxuICogICAgIGF3YWl0IFF1ZXN0aW9uLmZpbmQoeyBhbnN3ZXI6IDQyIH0pO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUucHJlID0gZnVuY3Rpb24oZm4pIHtcbiAgdGhpcy5faG9va3MucHJlKCdleGVjJywgZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkIHBvc3QgW21pZGRsZXdhcmVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9taWRkbGV3YXJlLmh0bWwpIHRvIHRoaXMgcXVlcnkgaW5zdGFuY2UuIERvZXNuJ3QgYWZmZWN0XG4gKiBvdGhlciBxdWVyaWVzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcTEgPSBRdWVzdGlvbi5maW5kKHsgYW5zd2VyOiA0MiB9KTtcbiAqICAgICBxMS5wb3N0KGZ1bmN0aW9uIG1pZGRsZXdhcmUoKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyh0aGlzLmdldEZpbHRlcigpKTtcbiAqICAgICB9KTtcbiAqICAgICBhd2FpdCBxMS5leGVjKCk7IC8vIFByaW50cyBcInsgYW5zd2VyOiA0MiB9XCJcbiAqXG4gKiAgICAgLy8gRG9lc24ndCBwcmludCBhbnl0aGluZywgYmVjYXVzZSBgbWlkZGxld2FyZSgpYCBpcyBvbmx5XG4gKiAgICAgLy8gcmVnaXN0ZXJlZCBvbiBgcTFgLlxuICogICAgIGF3YWl0IFF1ZXN0aW9uLmZpbmQoeyBhbnN3ZXI6IDQyIH0pO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUucG9zdCA9IGZ1bmN0aW9uKGZuKSB7XG4gIHRoaXMuX2hvb2tzLnBvc3QoJ2V4ZWMnLCBmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYXN0cyBvYmogZm9yIGFuIHVwZGF0ZSBjb21tYW5kLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH0gb2JqIGFmdGVyIGNhc3RpbmcgaXRzIHZhbHVlc1xuICogQG1ldGhvZCBfY2FzdFVwZGF0ZVxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5fY2FzdFVwZGF0ZSA9IGZ1bmN0aW9uIF9jYXN0VXBkYXRlKG9iaikge1xuICBsZXQgc2NoZW1hID0gdGhpcy5zY2hlbWE7XG5cbiAgY29uc3QgZGlzY3JpbWluYXRvcktleSA9IHNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXk7XG4gIGNvbnN0IGJhc2VTY2hlbWEgPSBzY2hlbWEuX2Jhc2VTY2hlbWEgPyBzY2hlbWEuX2Jhc2VTY2hlbWEgOiBzY2hlbWE7XG4gIGlmICh0aGlzLl9tb25nb29zZU9wdGlvbnMub3ZlcndyaXRlRGlzY3JpbWluYXRvcktleSAmJlxuICAgICAgb2JqW2Rpc2NyaW1pbmF0b3JLZXldICE9IG51bGwgJiZcbiAgICAgIGJhc2VTY2hlbWEuZGlzY3JpbWluYXRvcnMpIHtcbiAgICBjb25zdCBfc2NoZW1hID0gT2JqZWN0LnZhbHVlcyhiYXNlU2NoZW1hLmRpc2NyaW1pbmF0b3JzKS5maW5kKFxuICAgICAgZGlzY3JpbWluYXRvciA9PiBkaXNjcmltaW5hdG9yLmRpc2NyaW1pbmF0b3JNYXBwaW5nLnZhbHVlID09PSBvYmpbZGlzY3JpbWluYXRvcktleV1cbiAgICApO1xuICAgIGlmIChfc2NoZW1hICE9IG51bGwpIHtcbiAgICAgIHNjaGVtYSA9IF9zY2hlbWE7XG4gICAgfVxuICB9XG5cbiAgbGV0IHVwc2VydDtcbiAgaWYgKCd1cHNlcnQnIGluIHRoaXMub3B0aW9ucykge1xuICAgIHVwc2VydCA9IHRoaXMub3B0aW9ucy51cHNlcnQ7XG4gIH1cblxuICBjb25zdCBmaWx0ZXIgPSB0aGlzLl9jb25kaXRpb25zO1xuICBpZiAoc2NoZW1hICE9IG51bGwgJiZcbiAgICAgIHV0aWxzLmhhc1VzZXJEZWZpbmVkUHJvcGVydHkoZmlsdGVyLCBzY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5KSAmJlxuICAgICAgdHlwZW9mIGZpbHRlcltzY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5XSAhPT0gJ29iamVjdCcgJiZcbiAgICAgIHNjaGVtYS5kaXNjcmltaW5hdG9ycyAhPSBudWxsKSB7XG4gICAgY29uc3QgZGlzY3JpbWluYXRvclZhbHVlID0gZmlsdGVyW3NjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXldO1xuICAgIGNvbnN0IGJ5VmFsdWUgPSBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZSh0aGlzLm1vZGVsLmRpc2NyaW1pbmF0b3JzLCBkaXNjcmltaW5hdG9yVmFsdWUpO1xuICAgIHNjaGVtYSA9IHNjaGVtYS5kaXNjcmltaW5hdG9yc1tkaXNjcmltaW5hdG9yVmFsdWVdIHx8XG4gICAgICAoYnlWYWx1ZSAmJiBieVZhbHVlLnNjaGVtYSkgfHxcbiAgICAgIHNjaGVtYTtcbiAgfVxuXG4gIHJldHVybiBjYXN0VXBkYXRlKHNjaGVtYSwgb2JqLCB7XG4gICAgc3RyaWN0OiB0aGlzLl9tb25nb29zZU9wdGlvbnMuc3RyaWN0LFxuICAgIHVwc2VydDogdXBzZXJ0LFxuICAgIGFycmF5RmlsdGVyczogdGhpcy5vcHRpb25zLmFycmF5RmlsdGVycyxcbiAgICBvdmVyd3JpdGVEaXNjcmltaW5hdG9yS2V5OiB0aGlzLl9tb25nb29zZU9wdGlvbnMub3ZlcndyaXRlRGlzY3JpbWluYXRvcktleVxuICB9LCB0aGlzLCB0aGlzLl9jb25kaXRpb25zKTtcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIHBhdGhzIHdoaWNoIHNob3VsZCBiZSBwb3B1bGF0ZWQgd2l0aCBvdGhlciBkb2N1bWVudHMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBsZXQgYm9vayA9IGF3YWl0IEJvb2suZmluZE9uZSgpLnBvcHVsYXRlKCdhdXRob3JzJyk7XG4gKiAgICAgYm9vay50aXRsZTsgLy8gJ05vZGUuanMgaW4gQWN0aW9uJ1xuICogICAgIGJvb2suYXV0aG9yc1swXS5uYW1lOyAvLyAnVEogSG9sb3dheWNodWsnXG4gKiAgICAgYm9vay5hdXRob3JzWzFdLm5hbWU7IC8vICdOYXRoYW4gUmFqbGljaCdcbiAqXG4gKiAgICAgbGV0IGJvb2tzID0gYXdhaXQgQm9vay5maW5kKCkucG9wdWxhdGUoe1xuICogICAgICAgcGF0aDogJ2F1dGhvcnMnLFxuICogICAgICAgLy8gYG1hdGNoYCBhbmQgYHNvcnRgIGFwcGx5IHRvIHRoZSBBdXRob3IgbW9kZWwsXG4gKiAgICAgICAvLyBub3QgdGhlIEJvb2sgbW9kZWwuIFRoZXNlIG9wdGlvbnMgZG8gbm90IGFmZmVjdFxuICogICAgICAgLy8gd2hpY2ggZG9jdW1lbnRzIGFyZSBpbiBgYm9va3NgLCBqdXN0IHRoZSBvcmRlciBhbmRcbiAqICAgICAgIC8vIGNvbnRlbnRzIG9mIGVhY2ggYm9vayBkb2N1bWVudCdzIGBhdXRob3JzYC5cbiAqICAgICAgIG1hdGNoOiB7IG5hbWU6IG5ldyBSZWdFeHAoJy4qaC4qJywgJ2knKSB9LFxuICogICAgICAgc29ydDogeyBuYW1lOiAtMSB9XG4gKiAgICAgfSk7XG4gKiAgICAgYm9va3NbMF0udGl0bGU7IC8vICdOb2RlLmpzIGluIEFjdGlvbidcbiAqICAgICAvLyBFYWNoIGJvb2sncyBgYXV0aG9yc2AgYXJlIHNvcnRlZCBieSBuYW1lLCBkZXNjZW5kaW5nLlxuICogICAgIGJvb2tzWzBdLmF1dGhvcnNbMF0ubmFtZTsgLy8gJ1RKIEhvbG93YXljaHVrJ1xuICogICAgIGJvb2tzWzBdLmF1dGhvcnNbMV0ubmFtZTsgLy8gJ01hcmMgSGFydGVyJ1xuICpcbiAqICAgICBib29rc1sxXS50aXRsZTsgLy8gJ1Byb2Zlc3Npb25hbCBBbmd1bGFySlMnXG4gKiAgICAgLy8gRW1wdHkgYXJyYXksIG5vIGF1dGhvcnMnIG5hbWUgaGFzIHRoZSBsZXR0ZXIgJ2gnXG4gKiAgICAgYm9va3NbMV0uYXV0aG9yczsgLy8gW11cbiAqXG4gKiBQYXRocyBhcmUgcG9wdWxhdGVkIGFmdGVyIHRoZSBxdWVyeSBleGVjdXRlcyBhbmQgYSByZXNwb25zZSBpcyByZWNlaXZlZC4gQVxuICogc2VwYXJhdGUgcXVlcnkgaXMgdGhlbiBleGVjdXRlZCBmb3IgZWFjaCBwYXRoIHNwZWNpZmllZCBmb3IgcG9wdWxhdGlvbi4gQWZ0ZXJcbiAqIGEgcmVzcG9uc2UgZm9yIGVhY2ggcXVlcnkgaGFzIGFsc28gYmVlbiByZXR1cm5lZCwgdGhlIHJlc3VsdHMgYXJlIHBhc3NlZCB0b1xuICogdGhlIGNhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xTdHJpbmdbXX0gcGF0aCBlaXRoZXIgdGhlIHBhdGgocykgdG8gcG9wdWxhdGUgb3IgYW4gb2JqZWN0IHNwZWNpZnlpbmcgYWxsIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gW3NlbGVjdF0gRmllbGQgc2VsZWN0aW9uIGZvciB0aGUgcG9wdWxhdGlvbiBxdWVyeVxuICogQHBhcmFtIHtNb2RlbH0gW21vZGVsXSBUaGUgbW9kZWwgeW91IHdpc2ggdG8gdXNlIGZvciBwb3B1bGF0aW9uLiBJZiBub3Qgc3BlY2lmaWVkLCBwb3B1bGF0ZSB3aWxsIGxvb2sgdXAgdGhlIG1vZGVsIGJ5IHRoZSBuYW1lIGluIHRoZSBTY2hlbWEncyBgcmVmYCBmaWVsZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbbWF0Y2hdIENvbmRpdGlvbnMgZm9yIHRoZSBwb3B1bGF0aW9uIHF1ZXJ5XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgZm9yIHRoZSBwb3B1bGF0aW9uIHF1ZXJ5IChzb3J0LCBldGMpXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGF0aD1udWxsXSBUaGUgcGF0aCB0byBwb3B1bGF0ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmV0YWluTnVsbFZhbHVlcz1mYWxzZV0gYnkgZGVmYXVsdCwgTW9uZ29vc2UgcmVtb3ZlcyBudWxsIGFuZCB1bmRlZmluZWQgdmFsdWVzIGZyb20gcG9wdWxhdGVkIGFycmF5cy4gVXNlIHRoaXMgb3B0aW9uIHRvIG1ha2UgYHBvcHVsYXRlKClgIHJldGFpbiBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIGFycmF5IGVudHJpZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmdldHRlcnM9ZmFsc2VdIGlmIHRydWUsIE1vbmdvb3NlIHdpbGwgY2FsbCBhbnkgZ2V0dGVycyBkZWZpbmVkIG9uIHRoZSBgbG9jYWxGaWVsZGAuIEJ5IGRlZmF1bHQsIE1vbmdvb3NlIGdldHMgdGhlIHJhdyB2YWx1ZSBvZiBgbG9jYWxGaWVsZGAuIEZvciBleGFtcGxlLCB5b3Ugd291bGQgbmVlZCB0byBzZXQgdGhpcyBvcHRpb24gdG8gYHRydWVgIGlmIHlvdSB3YW50ZWQgdG8gW2FkZCBhIGBsb3dlcmNhc2VgIGdldHRlciB0byB5b3VyIGBsb2NhbEZpZWxkYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWwjc2NoZW1hdHlwZS1vcHRpb25zKS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2xvbmU9ZmFsc2VdIFdoZW4geW91IGRvIGBCbG9nUG9zdC5maW5kKCkucG9wdWxhdGUoJ2F1dGhvcicpYCwgYmxvZyBwb3N0cyB3aXRoIHRoZSBzYW1lIGF1dGhvciB3aWxsIHNoYXJlIDEgY29weSBvZiBhbiBgYXV0aG9yYCBkb2MuIEVuYWJsZSB0aGlzIG9wdGlvbiB0byBtYWtlIE1vbmdvb3NlIGNsb25lIHBvcHVsYXRlZCBkb2NzIGJlZm9yZSBhc3NpZ25pbmcgdGhlbS5cbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBbb3B0aW9ucy5tYXRjaD1udWxsXSBBZGQgYW4gYWRkaXRpb25hbCBmaWx0ZXIgdG8gdGhlIHBvcHVsYXRlIHF1ZXJ5LiBDYW4gYmUgYSBmaWx0ZXIgb2JqZWN0IGNvbnRhaW5pbmcgW01vbmdvREIgcXVlcnkgc3ludGF4XShodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC90dXRvcmlhbC9xdWVyeS1kb2N1bWVudHMvKSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBmaWx0ZXIgb2JqZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMudHJhbnNmb3JtPW51bGxdIEZ1bmN0aW9uIHRoYXQgTW9uZ29vc2Ugd2lsbCBjYWxsIG9uIGV2ZXJ5IHBvcHVsYXRlZCBkb2N1bWVudCB0aGF0IGFsbG93cyB5b3UgdG8gdHJhbnNmb3JtIHRoZSBwb3B1bGF0ZWQgZG9jdW1lbnQuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMub3B0aW9ucz1udWxsXSBBZGRpdGlvbmFsIG9wdGlvbnMgbGlrZSBgbGltaXRgIGFuZCBgbGVhbmAuXG4gKiBAc2VlIHBvcHVsYXRpb24gaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3BvcHVsYXRlLmh0bWxcbiAqIEBzZWUgUXVlcnkjc2VsZWN0IGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuc2VsZWN0KClcbiAqIEBzZWUgTW9kZWwucG9wdWxhdGUgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9tb2RlbC5odG1sI01vZGVsLnBvcHVsYXRlKClcbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5wb3B1bGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBCYWlsIHdoZW4gZ2l2ZW4gbm8gdHJ1dGh5IGFyZ3VtZW50c1xuICBpZiAoIUFycmF5LmZyb20oYXJndW1lbnRzKS5zb21lKEJvb2xlYW4pKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjb25zdCByZXMgPSB1dGlscy5wb3B1bGF0ZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuXG4gIC8vIFByb3BhZ2F0ZSByZWFkQ29uY2VybiBhbmQgcmVhZFByZWZlcmVuY2UgYW5kIGxlYW4gZnJvbSBwYXJlbnQgcXVlcnksXG4gIC8vIHVubGVzcyBvbmUgYWxyZWFkeSBzcGVjaWZpZWRcbiAgaWYgKHRoaXMub3B0aW9ucyAhPSBudWxsKSB7XG4gICAgY29uc3QgcmVhZENvbmNlcm4gPSB0aGlzLm9wdGlvbnMucmVhZENvbmNlcm47XG4gICAgY29uc3QgcmVhZFByZWYgPSB0aGlzLm9wdGlvbnMucmVhZFByZWZlcmVuY2U7XG5cbiAgICBmb3IgKGNvbnN0IHBvcHVsYXRlT3B0aW9ucyBvZiByZXMpIHtcbiAgICAgIGlmIChyZWFkQ29uY2VybiAhPSBudWxsICYmIChwb3B1bGF0ZU9wdGlvbnMgJiYgcG9wdWxhdGVPcHRpb25zLm9wdGlvbnMgJiYgcG9wdWxhdGVPcHRpb25zLm9wdGlvbnMucmVhZENvbmNlcm4pID09IG51bGwpIHtcbiAgICAgICAgcG9wdWxhdGVPcHRpb25zLm9wdGlvbnMgPSBwb3B1bGF0ZU9wdGlvbnMub3B0aW9ucyB8fCB7fTtcbiAgICAgICAgcG9wdWxhdGVPcHRpb25zLm9wdGlvbnMucmVhZENvbmNlcm4gPSByZWFkQ29uY2VybjtcbiAgICAgIH1cbiAgICAgIGlmIChyZWFkUHJlZiAhPSBudWxsICYmIChwb3B1bGF0ZU9wdGlvbnMgJiYgcG9wdWxhdGVPcHRpb25zLm9wdGlvbnMgJiYgcG9wdWxhdGVPcHRpb25zLm9wdGlvbnMucmVhZFByZWZlcmVuY2UpID09IG51bGwpIHtcbiAgICAgICAgcG9wdWxhdGVPcHRpb25zLm9wdGlvbnMgPSBwb3B1bGF0ZU9wdGlvbnMub3B0aW9ucyB8fCB7fTtcbiAgICAgICAgcG9wdWxhdGVPcHRpb25zLm9wdGlvbnMucmVhZFByZWZlcmVuY2UgPSByZWFkUHJlZjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBvcHRzID0gdGhpcy5fbW9uZ29vc2VPcHRpb25zO1xuXG4gIGlmIChvcHRzLmxlYW4gIT0gbnVsbCkge1xuICAgIGNvbnN0IGxlYW4gPSBvcHRzLmxlYW47XG4gICAgZm9yIChjb25zdCBwb3B1bGF0ZU9wdGlvbnMgb2YgcmVzKSB7XG4gICAgICBpZiAoKHBvcHVsYXRlT3B0aW9ucyAmJiBwb3B1bGF0ZU9wdGlvbnMub3B0aW9ucyAmJiBwb3B1bGF0ZU9wdGlvbnMub3B0aW9ucy5sZWFuKSA9PSBudWxsKSB7XG4gICAgICAgIHBvcHVsYXRlT3B0aW9ucy5vcHRpb25zID0gcG9wdWxhdGVPcHRpb25zLm9wdGlvbnMgfHwge307XG4gICAgICAgIHBvcHVsYXRlT3B0aW9ucy5vcHRpb25zLmxlYW4gPSBsZWFuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghdXRpbHMuaXNPYmplY3Qob3B0cy5wb3B1bGF0ZSkpIHtcbiAgICBvcHRzLnBvcHVsYXRlID0ge307XG4gIH1cblxuICBjb25zdCBwb3AgPSBvcHRzLnBvcHVsYXRlO1xuXG4gIGZvciAoY29uc3QgcG9wdWxhdGVPcHRpb25zIG9mIHJlcykge1xuICAgIGNvbnN0IHBhdGggPSBwb3B1bGF0ZU9wdGlvbnMucGF0aDtcbiAgICBpZiAocG9wW3BhdGhdICYmIHBvcFtwYXRoXS5wb3B1bGF0ZSAmJiBwb3B1bGF0ZU9wdGlvbnMucG9wdWxhdGUpIHtcbiAgICAgIHBvcHVsYXRlT3B0aW9ucy5wb3B1bGF0ZSA9IHBvcFtwYXRoXS5wb3B1bGF0ZS5jb25jYXQocG9wdWxhdGVPcHRpb25zLnBvcHVsYXRlKTtcbiAgICB9XG5cbiAgICBwb3BbcG9wdWxhdGVPcHRpb25zLnBhdGhdID0gcG9wdWxhdGVPcHRpb25zO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXRzIGEgbGlzdCBvZiBwYXRocyB0byBiZSBwb3B1bGF0ZWQgYnkgdGhpcyBxdWVyeVxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgIGJvb2tTY2hlbWEucHJlKCdmaW5kT25lJywgZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgbGV0IGtleXMgPSB0aGlzLmdldFBvcHVsYXRlZFBhdGhzKCk7IC8vIFsnYXV0aG9yJ11cbiAqICAgICAgfSk7XG4gKiAgICAgIC4uLlxuICogICAgICBCb29rLmZpbmRPbmUoe30pLnBvcHVsYXRlKCdhdXRob3InKTtcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgICAvLyBEZWVwIHBvcHVsYXRlXG4gKiAgICAgIGNvbnN0IHEgPSBMMS5maW5kKCkucG9wdWxhdGUoe1xuICogICAgICAgIHBhdGg6ICdsZXZlbDInLFxuICogICAgICAgIHBvcHVsYXRlOiB7IHBhdGg6ICdsZXZlbDMnIH1cbiAqICAgICAgfSk7XG4gKiAgICAgIHEuZ2V0UG9wdWxhdGVkUGF0aHMoKTsgLy8gWydsZXZlbDInLCAnbGV2ZWwyLmxldmVsMyddXG4gKlxuICogQHJldHVybiB7QXJyYXl9IGFuIGFycmF5IG9mIHN0cmluZ3MgcmVwcmVzZW50aW5nIHBvcHVsYXRlZCBwYXRoc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuZ2V0UG9wdWxhdGVkUGF0aHMgPSBmdW5jdGlvbiBnZXRQb3B1bGF0ZWRQYXRocygpIHtcbiAgY29uc3Qgb2JqID0gdGhpcy5fbW9uZ29vc2VPcHRpb25zLnBvcHVsYXRlIHx8IHt9O1xuICBjb25zdCByZXQgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKGNvbnN0IHBhdGggb2YgT2JqZWN0LmtleXMob2JqKSkge1xuICAgIGNvbnN0IHBvcCA9IG9ialtwYXRoXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocG9wLnBvcHVsYXRlKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIF9nZXRQb3B1bGF0ZWRQYXRocyhyZXQsIHBvcC5wb3B1bGF0ZSwgcGF0aCArICcuJyk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2dldFBvcHVsYXRlZFBhdGhzKGxpc3QsIGFyciwgcHJlZml4KSB7XG4gIGZvciAoY29uc3QgcG9wIG9mIGFycikge1xuICAgIGxpc3QucHVzaChwcmVmaXggKyBwb3AucGF0aCk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHBvcC5wb3B1bGF0ZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBfZ2V0UG9wdWxhdGVkUGF0aHMobGlzdCwgcG9wLnBvcHVsYXRlLCBwcmVmaXggKyBwb3AucGF0aCArICcuJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBDYXN0cyB0aGlzIHF1ZXJ5IHRvIHRoZSBzY2hlbWEgb2YgYG1vZGVsYFxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBJZiBgb2JqYCBpcyBwcmVzZW50LCBpdCBpcyBjYXN0IGluc3RlYWQgb2YgdGhpcyBxdWVyeS5cbiAqXG4gKiBAcGFyYW0ge01vZGVsfSBbbW9kZWxdIHRoZSBtb2RlbCB0byBjYXN0IHRvLiBJZiBub3Qgc2V0LCBkZWZhdWx0cyB0byBgdGhpcy5tb2RlbGBcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqXVxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuY2FzdCA9IGZ1bmN0aW9uKG1vZGVsLCBvYmopIHtcbiAgb2JqIHx8IChvYmogPSB0aGlzLl9jb25kaXRpb25zKTtcbiAgbW9kZWwgPSBtb2RlbCB8fCB0aGlzLm1vZGVsO1xuICBjb25zdCBkaXNjcmltaW5hdG9yS2V5ID0gbW9kZWwuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleTtcbiAgaWYgKG9iaiAhPSBudWxsICYmXG4gICAgICBvYmouaGFzT3duUHJvcGVydHkoZGlzY3JpbWluYXRvcktleSkpIHtcbiAgICBtb2RlbCA9IGdldERpc2NyaW1pbmF0b3JCeVZhbHVlKG1vZGVsLmRpc2NyaW1pbmF0b3JzLCBvYmpbZGlzY3JpbWluYXRvcktleV0pIHx8IG1vZGVsO1xuICB9XG5cbiAgY29uc3Qgb3B0cyA9IHsgdXBzZXJ0OiB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnVwc2VydCB9O1xuICBpZiAodGhpcy5vcHRpb25zKSB7XG4gICAgaWYgKCdzdHJpY3QnIGluIHRoaXMub3B0aW9ucykge1xuICAgICAgb3B0cy5zdHJpY3QgPSB0aGlzLm9wdGlvbnMuc3RyaWN0O1xuICAgIH1cbiAgICBpZiAoJ3N0cmljdFF1ZXJ5JyBpbiB0aGlzLm9wdGlvbnMpIHtcbiAgICAgIG9wdHMuc3RyaWN0UXVlcnkgPSB0aGlzLm9wdGlvbnMuc3RyaWN0UXVlcnk7XG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gY2FzdChtb2RlbC5zY2hlbWEsIG9iaiwgb3B0cywgdGhpcyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIENhc3RFcnJvciwgYXNzaWduIG1vZGVsXG4gICAgaWYgKHR5cGVvZiBlcnIuc2V0TW9kZWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVyci5zZXRNb2RlbChtb2RlbCk7XG4gICAgfVxuICAgIHRocm93IGVycjtcbiAgfVxufTtcblxuLyoqXG4gKiBDYXN0cyBzZWxlY3RlZCBmaWVsZCBhcmd1bWVudHMgZm9yIGZpZWxkIHNlbGVjdGlvbiB3aXRoIG1vbmdvIDIuMlxuICpcbiAqICAgICBxdWVyeS5zZWxlY3QoeyBpZHM6IHsgJGVsZW1NYXRjaDogeyAkaW46IFtoZXhTdHJpbmddIH19KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaWVsZHNcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvbW9uZ29vc2UvaXNzdWVzLzEwOTFcbiAqIEBzZWUgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3Byb2plY3Rpb24vZWxlbU1hdGNoL1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLl9jYXN0RmllbGRzID0gZnVuY3Rpb24gX2Nhc3RGaWVsZHMoZmllbGRzKSB7XG4gIGxldCBzZWxlY3RlZCxcbiAgICAgIGVsZW1NYXRjaEtleXMsXG4gICAgICBrZXlzLFxuICAgICAga2V5LFxuICAgICAgb3V0O1xuXG4gIGlmIChmaWVsZHMpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXMoZmllbGRzKTtcbiAgICBlbGVtTWF0Y2hLZXlzID0gW107XG5cbiAgICAvLyBjb2xsZWN0ICRlbGVtTWF0Y2ggYXJnc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChmaWVsZHNba2V5XS4kZWxlbU1hdGNoKSB7XG4gICAgICAgIHNlbGVjdGVkIHx8IChzZWxlY3RlZCA9IHt9KTtcbiAgICAgICAgc2VsZWN0ZWRba2V5XSA9IGZpZWxkc1trZXldO1xuICAgICAgICBlbGVtTWF0Y2hLZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAvLyB0aGV5IHBhc3NlZCAkZWxlbU1hdGNoLCBjYXN0IGVtXG4gICAgdHJ5IHtcbiAgICAgIG91dCA9IHRoaXMuY2FzdCh0aGlzLm1vZGVsLCBzZWxlY3RlZCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gZXJyO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IHRoZSBjYXN0ZWQgZmllbGQgYXJnc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbU1hdGNoS2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAga2V5ID0gZWxlbU1hdGNoS2V5c1tpXTtcbiAgICAgIGZpZWxkc1trZXldID0gb3V0W2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpZWxkcztcbn07XG5cbi8qKlxuICogQXBwbGllcyBzY2hlbWF0eXBlIHNlbGVjdGVkIG9wdGlvbnMgdG8gdGhpcyBxdWVyeS5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5fYXBwbHlQYXRocyA9IGZ1bmN0aW9uIGFwcGx5UGF0aHMoKSB7XG4gIGlmICghdGhpcy5tb2RlbCkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLl9maWVsZHMgPSB0aGlzLl9maWVsZHMgfHwge307XG4gIGhlbHBlcnMuYXBwbHlQYXRocyh0aGlzLl9maWVsZHMsIHRoaXMubW9kZWwuc2NoZW1hKTtcblxuICBsZXQgX3NlbGVjdFBvcHVsYXRlZFBhdGhzID0gdHJ1ZTtcblxuICBpZiAoJ3NlbGVjdFBvcHVsYXRlZFBhdGhzJyBpbiB0aGlzLm1vZGVsLmJhc2Uub3B0aW9ucykge1xuICAgIF9zZWxlY3RQb3B1bGF0ZWRQYXRocyA9IHRoaXMubW9kZWwuYmFzZS5vcHRpb25zLnNlbGVjdFBvcHVsYXRlZFBhdGhzO1xuICB9XG4gIGlmICgnc2VsZWN0UG9wdWxhdGVkUGF0aHMnIGluIHRoaXMubW9kZWwuc2NoZW1hLm9wdGlvbnMpIHtcbiAgICBfc2VsZWN0UG9wdWxhdGVkUGF0aHMgPSB0aGlzLm1vZGVsLnNjaGVtYS5vcHRpb25zLnNlbGVjdFBvcHVsYXRlZFBhdGhzO1xuICB9XG5cbiAgaWYgKF9zZWxlY3RQb3B1bGF0ZWRQYXRocykge1xuICAgIHNlbGVjdFBvcHVsYXRlZEZpZWxkcyh0aGlzLl9maWVsZHMsIHRoaXMuX3VzZXJQcm92aWRlZEZpZWxkcywgdGhpcy5fbW9uZ29vc2VPcHRpb25zLnBvcHVsYXRlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgd3JhcHBlciBhcm91bmQgYSBbbW9uZ29kYiBkcml2ZXIgY3Vyc29yXShodHRwczovL21vbmdvZGIuZ2l0aHViLmlvL25vZGUtbW9uZ29kYi1uYXRpdmUvNC45L2NsYXNzZXMvRmluZEN1cnNvci5odG1sKS5cbiAqIEEgUXVlcnlDdXJzb3IgZXhwb3NlcyBhIFN0cmVhbXMzIGludGVyZmFjZSwgYXMgd2VsbCBhcyBhIGAubmV4dCgpYCBmdW5jdGlvbi5cbiAqXG4gKiBUaGUgYC5jdXJzb3IoKWAgZnVuY3Rpb24gdHJpZ2dlcnMgcHJlIGZpbmQgaG9va3MsIGJ1dCAqKm5vdCoqIHBvc3QgZmluZCBob29rcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIFRoZXJlIGFyZSAyIHdheXMgdG8gdXNlIGEgY3Vyc29yLiBGaXJzdCwgYXMgYSBzdHJlYW06XG4gKiAgICAgVGhpbmcuXG4gKiAgICAgICBmaW5kKHsgbmFtZTogL15oZWxsby8gfSkuXG4gKiAgICAgICBjdXJzb3IoKS5cbiAqICAgICAgIG9uKCdkYXRhJywgZnVuY3Rpb24oZG9jKSB7IGNvbnNvbGUubG9nKGRvYyk7IH0pLlxuICogICAgICAgb24oJ2VuZCcsIGZ1bmN0aW9uKCkgeyBjb25zb2xlLmxvZygnRG9uZSEnKTsgfSk7XG4gKlxuICogICAgIC8vIE9yIHlvdSBjYW4gdXNlIGAubmV4dCgpYCB0byBtYW51YWxseSBnZXQgdGhlIG5leHQgZG9jIGluIHRoZSBzdHJlYW0uXG4gKiAgICAgLy8gYC5uZXh0KClgIHJldHVybnMgYSBwcm9taXNlLCBzbyB5b3UgY2FuIHVzZSBwcm9taXNlcyBvciBjYWxsYmFja3MuXG4gKiAgICAgY29uc3QgY3Vyc29yID0gVGhpbmcuZmluZCh7IG5hbWU6IC9eaGVsbG8vIH0pLmN1cnNvcigpO1xuICogICAgIGN1cnNvci5uZXh0KGZ1bmN0aW9uKGVycm9yLCBkb2MpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKGRvYyk7XG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vIEJlY2F1c2UgYC5uZXh0KClgIHJldHVybnMgYSBwcm9taXNlLCB5b3UgY2FuIHVzZSBjb1xuICogICAgIC8vIHRvIGVhc2lseSBpdGVyYXRlIHRocm91Z2ggYWxsIGRvY3VtZW50cyB3aXRob3V0IGxvYWRpbmcgdGhlbVxuICogICAgIC8vIGFsbCBpbnRvIG1lbW9yeS5cbiAqICAgICBjb25zdCBjdXJzb3IgPSBUaGluZy5maW5kKHsgbmFtZTogL15oZWxsby8gfSkuY3Vyc29yKCk7XG4gKiAgICAgZm9yIChsZXQgZG9jID0gYXdhaXQgY3Vyc29yLm5leHQoKTsgZG9jICE9IG51bGw7IGRvYyA9IGF3YWl0IGN1cnNvci5uZXh0KCkpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKGRvYyk7XG4gKiAgICAgfVxuICpcbiAqICMjIyMgVmFsaWQgb3B0aW9uc1xuICpcbiAqICAgLSBgdHJhbnNmb3JtYDogb3B0aW9uYWwgZnVuY3Rpb24gd2hpY2ggYWNjZXB0cyBhIG1vbmdvb3NlIGRvY3VtZW50LiBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB3aWxsIGJlIGVtaXR0ZWQgb24gYGRhdGFgIGFuZCByZXR1cm5lZCBieSBgLm5leHQoKWAuXG4gKlxuICogQHJldHVybiB7UXVlcnlDdXJzb3J9XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAc2VlIFF1ZXJ5Q3Vyc29yIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnljdXJzb3IuaHRtbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuY3Vyc29yID0gZnVuY3Rpb24gY3Vyc29yKG9wdHMpIHtcbiAgaWYgKG9wdHMpIHtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0cyk7XG4gIH1cblxuICB0cnkge1xuICAgIHRoaXMuY2FzdCh0aGlzLm1vZGVsKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIChuZXcgUXVlcnlDdXJzb3IodGhpcykpLl9tYXJrRXJyb3IoZXJyKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUXVlcnlDdXJzb3IodGhpcyk7XG59O1xuXG4vLyB0aGUgcmVzdCBvZiB0aGVzZSBhcmUgYmFzaWNhbGx5IHRvIHN1cHBvcnQgb2xkZXIgTW9uZ29vc2Ugc3ludGF4IHdpdGggbXF1ZXJ5XG5cbi8qKlxuICogU2V0cyB0aGUgdGFpbGFibGUgb3B0aW9uIChmb3IgdXNlIHdpdGggY2FwcGVkIGNvbGxlY3Rpb25zKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LnRhaWxhYmxlKCk7IC8vIHRydWVcbiAqICAgICBxdWVyeS50YWlsYWJsZSh0cnVlKTtcbiAqICAgICBxdWVyeS50YWlsYWJsZShmYWxzZSk7XG4gKlxuICogICAgIC8vIFNldCBib3RoIGB0YWlsYWJsZWAgYW5kIGBhd2FpdERhdGFgIG9wdGlvbnNcbiAqICAgICBxdWVyeS50YWlsYWJsZSh7IGF3YWl0RGF0YTogdHJ1ZSB9KTtcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogQ2Fubm90IGJlIHVzZWQgd2l0aCBgZGlzdGluY3QoKWBcbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGJvb2wgZGVmYXVsdHMgdG8gdHJ1ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSBvcHRpb25zIHRvIHNldFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0cy5hd2FpdERhdGFdIGZhbHNlIGJ5IGRlZmF1bHQuIFNldCB0byB0cnVlIHRvIGtlZXAgdGhlIGN1cnNvciBvcGVuIGV2ZW4gaWYgdGhlcmUncyBubyBkYXRhLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRzLm1heEF3YWl0VGltZU1TXSB0aGUgbWF4aW11bSBhbW91bnQgb2YgdGltZSBmb3IgdGhlIHNlcnZlciB0byB3YWl0IG9uIG5ldyBkb2N1bWVudHMgdG8gc2F0aXNmeSBhIHRhaWxhYmxlIGN1cnNvciBxdWVyeS4gUmVxdWlyZXMgYHRhaWxhYmxlYCBhbmQgYGF3YWl0RGF0YWAgdG8gYmUgdHJ1ZVxuICogQHNlZSB0YWlsYWJsZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC90dXRvcmlhbC9jcmVhdGUtdGFpbGFibGUtY3Vyc29yL1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUudGFpbGFibGUgPSBmdW5jdGlvbih2YWwsIG9wdHMpIHtcbiAgLy8gd2UgbmVlZCB0byBzdXBwb3J0IHRoZSB0YWlsYWJsZSh7IGF3YWl0RGF0YSA6IHRydWUgfSkgYXMgd2VsbCBhcyB0aGVcbiAgLy8gdGFpbGFibGUodHJ1ZSwge2F3YWl0RGF0YSA6dHJ1ZX0pIHN5bnRheCB0aGF0IG1xdWVyeSBkb2VzIG5vdCBzdXBwb3J0XG4gIGlmICh2YWwgIT0gbnVsbCAmJiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yID09PSAnZnVuY3Rpb24nICYmIHZhbC5jb25zdHJ1Y3Rvci5uYW1lID09PSAnT2JqZWN0Jykge1xuICAgIG9wdHMgPSB2YWw7XG4gICAgdmFsID0gdHJ1ZTtcbiAgfVxuXG4gIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbCA9IHRydWU7XG4gIH1cblxuICBpZiAob3B0cyAmJiB0eXBlb2Ygb3B0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvcHRzKSkge1xuICAgICAgaWYgKGtleSA9PT0gJ2F3YWl0RGF0YScgfHwga2V5ID09PSAnYXdhaXRkYXRhJykgeyAvLyBiYWNrd2FyZHMgY29tcGF0LCBzZWUgZ2gtMTA4NzVcbiAgICAgICAgLy8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgIHRoaXMub3B0aW9uc1snYXdhaXREYXRhJ10gPSAhIW9wdHNba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3B0aW9uc1trZXldID0gb3B0c1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMub3B0aW9ucy50YWlsYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggPyAhIXZhbCA6IHRydWU7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIERlY2xhcmVzIGFuIGludGVyc2VjdHMgcXVlcnkgZm9yIGBnZW9tZXRyeSgpYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKCdwYXRoJykuaW50ZXJzZWN0cygpLmdlb21ldHJ5KHtcbiAqICAgICAgIHR5cGU6ICdMaW5lU3RyaW5nJyxcbiAqICAgICAgIGNvb3JkaW5hdGVzOiBbWzE4MC4wLCAxMS4wXSwgWzE4MCwgOS4wXV1cbiAqICAgICB9KTtcbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ3BhdGgnKS5pbnRlcnNlY3RzKHtcbiAqICAgICAgIHR5cGU6ICdMaW5lU3RyaW5nJyxcbiAqICAgICAgIGNvb3JkaW5hdGVzOiBbWzE4MC4wLCAxMS4wXSwgWzE4MCwgOS4wXV1cbiAqICAgICB9KTtcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogKipNVVNUKiogYmUgdXNlZCBhZnRlciBgd2hlcmUoKWAuXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIEluIE1vbmdvb3NlIDMuNywgYGludGVyc2VjdHNgIGNoYW5nZWQgZnJvbSBhIGdldHRlciB0byBhIGZ1bmN0aW9uLiBJZiB5b3UgbmVlZCB0aGUgb2xkIHN5bnRheCwgdXNlIFt0aGlzXShodHRwczovL2dpdGh1Yi5jb20vZWJlbnNpbmcvbW9uZ29vc2Utd2l0aGluKS5cbiAqXG4gKiBAbWV0aG9kIGludGVyc2VjdHNcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ11cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlICRnZW9tZXRyeSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvZ2VvbWV0cnkvXG4gKiBAc2VlIGdlb0ludGVyc2VjdHMgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2dlb0ludGVyc2VjdHMvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogU3BlY2lmaWVzIGEgYCRnZW9tZXRyeWAgY29uZGl0aW9uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBwb2x5QSA9IFtbWyAxMCwgMjAgXSwgWyAxMCwgNDAgXSwgWyAzMCwgNDAgXSwgWyAzMCwgMjAgXV1dXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbigpLmdlb21ldHJ5KHsgdHlwZTogJ1BvbHlnb24nLCBjb29yZGluYXRlczogcG9seUEgfSlcbiAqXG4gKiAgICAgLy8gb3JcbiAqICAgICBjb25zdCBwb2x5QiA9IFtbIDAsIDAgXSwgWyAxLCAxIF1dXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbigpLmdlb21ldHJ5KHsgdHlwZTogJ0xpbmVTdHJpbmcnLCBjb29yZGluYXRlczogcG9seUIgfSlcbiAqXG4gKiAgICAgLy8gb3JcbiAqICAgICBjb25zdCBwb2x5QyA9IFsgMCwgMCBdXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbigpLmdlb21ldHJ5KHsgdHlwZTogJ1BvaW50JywgY29vcmRpbmF0ZXM6IHBvbHlDIH0pXG4gKlxuICogICAgIC8vIG9yXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLmludGVyc2VjdHMoKS5nZW9tZXRyeSh7IHR5cGU6ICdQb2ludCcsIGNvb3JkaW5hdGVzOiBwb2x5QyB9KVxuICpcbiAqIFRoZSBhcmd1bWVudCBpcyBhc3NpZ25lZCB0byB0aGUgbW9zdCByZWNlbnQgcGF0aCBwYXNzZWQgdG8gYHdoZXJlKClgLlxuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBgZ2VvbWV0cnkoKWAgKiptdXN0KiogY29tZSBhZnRlciBlaXRoZXIgYGludGVyc2VjdHMoKWAgb3IgYHdpdGhpbigpYC5cbiAqXG4gKiBUaGUgYG9iamVjdGAgYXJndW1lbnQgbXVzdCBjb250YWluIGB0eXBlYCBhbmQgYGNvb3JkaW5hdGVzYCBwcm9wZXJ0aWVzLlxuICogLSB0eXBlIHtTdHJpbmd9XG4gKiAtIGNvb3JkaW5hdGVzIHtBcnJheX1cbiAqXG4gKiBAbWV0aG9kIGdlb21ldHJ5XG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBNdXN0IGNvbnRhaW4gYSBgdHlwZWAgcHJvcGVydHkgd2hpY2ggaXMgYSBTdHJpbmcgYW5kIGEgYGNvb3JkaW5hdGVzYCBwcm9wZXJ0eSB3aGljaCBpcyBhbiBBcnJheS4gU2VlIHRoZSBleGFtcGxlcy5cbiAqIEByZXR1cm4ge1F1ZXJ5fSB0aGlzXG4gKiBAc2VlICRnZW9tZXRyeSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvZ2VvbWV0cnkvXG4gKiBAc2VlIEdlb3NwYXRpYWwgU3VwcG9ydCBFbmhhbmNlbWVudHMgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVsZWFzZS1ub3Rlcy8yLjQvI2dlb3NwYXRpYWwtc3VwcG9ydC1lbmhhbmNlbWVudHNcbiAqIEBzZWUgTW9uZ29EQiBHZW9zcGF0aWFsIEluZGV4aW5nIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL2NvcmUvZ2Vvc3BhdGlhbC1pbmRleGVzL1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIFNwZWNpZmllcyBhIGAkbmVhcmAgb3IgYCRuZWFyU3BoZXJlYCBjb25kaXRpb25cbiAqXG4gKiBUaGVzZSBvcGVyYXRvcnMgcmV0dXJuIGRvY3VtZW50cyBzb3J0ZWQgYnkgZGlzdGFuY2UuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykubmVhcih7IGNlbnRlcjogWzEwLCAxMF0gfSk7XG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLm5lYXIoeyBjZW50ZXI6IFsxMCwgMTBdLCBtYXhEaXN0YW5jZTogNSB9KTtcbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykubmVhcih7IGNlbnRlcjogWzEwLCAxMF0sIG1heERpc3RhbmNlOiA1LCBzcGhlcmljYWw6IHRydWUgfSk7XG4gKiAgICAgcXVlcnkubmVhcignbG9jJywgeyBjZW50ZXI6IFsxMCwgMTBdLCBtYXhEaXN0YW5jZTogNSB9KTtcbiAqXG4gKiBAbWV0aG9kIG5lYXJcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsXG4gKiBAcmV0dXJuIHtRdWVyeX0gdGhpc1xuICogQHNlZSAkbmVhciBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvbmVhci9cbiAqIEBzZWUgJG5lYXJTcGhlcmUgaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL25lYXJTcGhlcmUvXG4gKiBAc2VlICRtYXhEaXN0YW5jZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvbWF4RGlzdGFuY2UvXG4gKiBAc2VlIE1vbmdvREIgR2Vvc3BhdGlhbCBJbmRleGluZyBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9jb3JlL2dlb3NwYXRpYWwtaW5kZXhlcy9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBPdmVyd3JpdGluZyBtcXVlcnkgaXMgbmVlZGVkIHRvIHN1cHBvcnQgYSBjb3VwbGUgZGlmZmVyZW50IG5lYXIoKSBmb3JtcyBmb3VuZCBpbiBvbGRlclxuICogdmVyc2lvbnMgb2YgbW9uZ29vc2VcbiAqIG5lYXIoWzEsMV0pXG4gKiBuZWFyKDEsMSlcbiAqIG5lYXIoZmllbGQsIFsxLDJdKVxuICogbmVhcihmaWVsZCwgMSwgMilcbiAqIEluIGFkZGl0aW9uIHRvIGFsbCBvZiB0aGUgbm9ybWFsIGZvcm1zIHN1cHBvcnRlZCBieSBtcXVlcnlcbiAqXG4gKiBAbWV0aG9kIG5lYXJcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUubmVhciA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgY29uc3Qgc3BoZXJlID0gdGhpcy5fbW9uZ29vc2VPcHRpb25zLm5lYXJTcGhlcmU7XG5cbiAgLy8gVE9ETyByZWZhY3RvclxuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgcGFyYW1zLnB1c2goeyBjZW50ZXI6IGFyZ3VtZW50c1swXSwgc3BoZXJpY2FsOiBzcGhlcmUgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgLy8ganVzdCBwYXNzaW5nIGEgcGF0aFxuICAgICAgcGFyYW1zLnB1c2goYXJndW1lbnRzWzBdKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzT2JqZWN0KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdLnNwaGVyaWNhbCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGFyZ3VtZW50c1swXS5zcGhlcmljYWwgPSBzcGhlcmU7XG4gICAgICB9XG4gICAgICBwYXJhbXMucHVzaChhcmd1bWVudHNbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHBhcmFtcy5wdXNoKHsgY2VudGVyOiBbYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV1dLCBzcGhlcmljYWw6IHNwaGVyZSB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdzdHJpbmcnICYmIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzFdKSkge1xuICAgICAgcGFyYW1zLnB1c2goYXJndW1lbnRzWzBdKTtcbiAgICAgIHBhcmFtcy5wdXNoKHsgY2VudGVyOiBhcmd1bWVudHNbMV0sIHNwaGVyaWNhbDogc3BoZXJlIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ3N0cmluZycgJiYgdXRpbHMuaXNPYmplY3QoYXJndW1lbnRzWzFdKSkge1xuICAgICAgcGFyYW1zLnB1c2goYXJndW1lbnRzWzBdKTtcbiAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzFdLnNwaGVyaWNhbCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGFyZ3VtZW50c1sxXS5zcGhlcmljYWwgPSBzcGhlcmU7XG4gICAgICB9XG4gICAgICBwYXJhbXMucHVzaChhcmd1bWVudHNbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ251bWJlcidcbiAgICAgICAgJiYgdHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHBhcmFtcy5wdXNoKGFyZ3VtZW50c1swXSk7XG4gICAgICBwYXJhbXMucHVzaCh7IGNlbnRlcjogW2FyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdXSwgc3BoZXJpY2FsOiBzcGhlcmUgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBhcmd1bWVudCcpO1xuICB9XG5cbiAgcmV0dXJuIFF1ZXJ5LmJhc2UubmVhci5hcHBseSh0aGlzLCBwYXJhbXMpO1xufTtcblxuLyoqXG4gKiBfREVQUkVDQVRFRF8gU3BlY2lmaWVzIGEgYCRuZWFyU3BoZXJlYCBjb25kaXRpb25cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS5uZWFyU3BoZXJlKHsgY2VudGVyOiBbMTAsIDEwXSwgbWF4RGlzdGFuY2U6IDUgfSk7XG4gKlxuICogKipEZXByZWNhdGVkLioqIFVzZSBgcXVlcnkubmVhcigpYCBpbnN0ZWFkIHdpdGggdGhlIGBzcGhlcmljYWxgIG9wdGlvbiBzZXQgdG8gYHRydWVgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLm5lYXIoeyBjZW50ZXI6IFsxMCwgMTBdLCBzcGhlcmljYWw6IHRydWUgfSk7XG4gKlxuICogQGRlcHJlY2F0ZWRcbiAqIEBzZWUgbmVhcigpIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUubmVhcigpXG4gKiBAc2VlICRuZWFyIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9uZWFyL1xuICogQHNlZSAkbmVhclNwaGVyZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvbmVhclNwaGVyZS9cbiAqIEBzZWUgJG1heERpc3RhbmNlIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9tYXhEaXN0YW5jZS9cbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUubmVhclNwaGVyZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9tb25nb29zZU9wdGlvbnMubmVhclNwaGVyZSA9IHRydWU7XG4gIHRoaXMubmVhci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBhc3luY0l0ZXJhdG9yIGZvciB1c2Ugd2l0aCBbYGZvci9hd2FpdC9vZmAgbG9vcHNdKGh0dHBzOi8vdGhlY29kZWJhcmJhcmlhbi5jb20vZ2V0dGluZy1zdGFydGVkLXdpdGgtYXN5bmMtaXRlcmF0b3JzLWluLW5vZGUtanMpXG4gKiBUaGlzIGZ1bmN0aW9uICpvbmx5KiB3b3JrcyBmb3IgYGZpbmQoKWAgcXVlcmllcy5cbiAqIFlvdSBkbyBub3QgbmVlZCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gZXhwbGljaXRseSwgdGhlIEphdmFTY3JpcHQgcnVudGltZVxuICogd2lsbCBjYWxsIGl0IGZvciB5b3UuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBmb3IgYXdhaXQgKGNvbnN0IGRvYyBvZiBNb2RlbC5hZ2dyZWdhdGUoW3sgJHNvcnQ6IHsgbmFtZTogMSB9IH1dKSkge1xuICogICAgICAgY29uc29sZS5sb2coZG9jLm5hbWUpO1xuICogICAgIH1cbiAqXG4gKiBOb2RlLmpzIDEwLnggc3VwcG9ydHMgYXN5bmMgaXRlcmF0b3JzIG5hdGl2ZWx5IHdpdGhvdXQgYW55IGZsYWdzLiBZb3UgY2FuXG4gKiBlbmFibGUgYXN5bmMgaXRlcmF0b3JzIGluIE5vZGUuanMgOC54IHVzaW5nIHRoZSBbYC0taGFybW9ueV9hc3luY19pdGVyYXRpb25gIGZsYWddKGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWFzeW5jLWl0ZXJhdGlvbi9pc3N1ZXMvMTE3I2lzc3VlY29tbWVudC0zNDY2OTUxODcpLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIG5vdCBpZiBgU3ltYm9sLmFzeW5jSXRlcmF0b3JgIGlzIHVuZGVmaW5lZC4gSWZcbiAqIGBTeW1ib2wuYXN5bmNJdGVyYXRvcmAgaXMgdW5kZWZpbmVkLCB0aGF0IG1lYW5zIHlvdXIgTm9kZS5qcyB2ZXJzaW9uIGRvZXMgbm90XG4gKiBzdXBwb3J0IGFzeW5jIGl0ZXJhdG9ycy5cbiAqXG4gKiBAbWV0aG9kIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl1cbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmlmIChTeW1ib2wuYXN5bmNJdGVyYXRvciAhPSBudWxsKSB7XG4gIFF1ZXJ5LnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJzb3IoKS50cmFuc2Zvcm1OdWxsKCkuX3RyYW5zZm9ybUZvckFzeW5jSXRlcmF0b3IoKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBgJHBvbHlnb25gIGNvbmRpdGlvblxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbigpLnBvbHlnb24oWzEwLCAyMF0sIFsxMywgMjVdLCBbNywgMTVdKTtcbiAqICAgICBxdWVyeS5wb2x5Z29uKCdsb2MnLCBbMTAsIDIwXSwgWzEzLCAyNV0sIFs3LCAxNV0pO1xuICpcbiAqIEBtZXRob2QgcG9seWdvblxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBbcGF0aF1cbiAqIEBwYXJhbSB7Li4uQXJyYXl8T2JqZWN0fSBbY29vcmRpbmF0ZVBhaXJzXVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgJHBvbHlnb24gaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3BvbHlnb24vXG4gKiBAc2VlIE1vbmdvREIgR2Vvc3BhdGlhbCBJbmRleGluZyBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9jb3JlL2dlb3NwYXRpYWwtaW5kZXhlcy9cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiBTcGVjaWZpZXMgYSBgJGJveGAgY29uZGl0aW9uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBsb3dlckxlZnQgPSBbNDAuNzMwODMsIC03My45OTc1Nl1cbiAqICAgICBjb25zdCB1cHBlclJpZ2h0PSBbNDAuNzQxNDA0LCAgLTczLjk4ODEzNV1cbiAqXG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbigpLmJveChsb3dlckxlZnQsIHVwcGVyUmlnaHQpXG4gKiAgICAgcXVlcnkuYm94KHsgbGwgOiBsb3dlckxlZnQsIHVyIDogdXBwZXJSaWdodCB9KVxuICpcbiAqIEBtZXRob2QgYm94XG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHNlZSAkYm94IGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9ib3gvXG4gKiBAc2VlIHdpdGhpbigpIFF1ZXJ5I3dpdGhpbiBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3F1ZXJ5Lmh0bWwjUXVlcnkucHJvdG90eXBlLndpdGhpbigpXG4gKiBAc2VlIE1vbmdvREIgR2Vvc3BhdGlhbCBJbmRleGluZyBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9jb3JlL2dlb3NwYXRpYWwtaW5kZXhlcy9cbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5PE51bWJlcj59IHZhbDEgTG93ZXIgTGVmdCBDb29yZGluYXRlcyBPUiBhIG9iamVjdCBvZiBsb3dlci1sZWZ0KGxsKSBhbmQgdXBwZXItcmlnaHQodXIpIENvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge0FycmF5PE51bWJlcj59IFt2YWwyXSBVcHBlciBSaWdodCBDb29yZGluYXRlc1xuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuLyoqXG4gKiB0aGlzIGlzIG5lZWRlZCB0byBzdXBwb3J0IHRoZSBtb25nb29zZSBzeW50YXggb2Y6XG4gKiBib3goZmllbGQsIHsgbGwgOiBbeCx5XSwgdXIgOiBbeDIseTJdIH0pXG4gKiBib3goeyBsbCA6IFt4LHldLCB1ciA6IFt4Mix5Ml0gfSlcbiAqXG4gKiBAbWV0aG9kIGJveFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5ib3ggPSBmdW5jdGlvbihsbCwgdXIpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxsKSAmJiB1dGlscy5pc09iamVjdChsbCkpIHtcbiAgICB1ciA9IGxsLnVyO1xuICAgIGxsID0gbGwubGw7XG4gIH1cbiAgcmV0dXJuIFF1ZXJ5LmJhc2UuYm94LmNhbGwodGhpcywgbGwsIHVyKTtcbn07XG5cbi8qKlxuICogU3BlY2lmaWVzIGEgYCRjZW50ZXJgIG9yIGAkY2VudGVyU3BoZXJlYCBjb25kaXRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBhcmVhID0geyBjZW50ZXI6IFs1MCwgNTBdLCByYWRpdXM6IDEwLCB1bmlxdWU6IHRydWUgfVxuICogICAgIHF1ZXJ5LndoZXJlKCdsb2MnKS53aXRoaW4oKS5jaXJjbGUoYXJlYSlcbiAqICAgICAvLyBhbHRlcm5hdGl2ZWx5XG4gKiAgICAgcXVlcnkuY2lyY2xlKCdsb2MnLCBhcmVhKTtcbiAqXG4gKiAgICAgLy8gc3BoZXJpY2FsIGNhbGN1bGF0aW9uc1xuICogICAgIGNvbnN0IGFyZWEgPSB7IGNlbnRlcjogWzUwLCA1MF0sIHJhZGl1czogMTAsIHVuaXF1ZTogdHJ1ZSwgc3BoZXJpY2FsOiB0cnVlIH1cbiAqICAgICBxdWVyeS53aGVyZSgnbG9jJykud2l0aGluKCkuY2lyY2xlKGFyZWEpXG4gKiAgICAgLy8gYWx0ZXJuYXRpdmVseVxuICogICAgIHF1ZXJ5LmNpcmNsZSgnbG9jJywgYXJlYSk7XG4gKlxuICogQG1ldGhvZCBjaXJjbGVcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdXG4gKiBAcGFyYW0ge09iamVjdH0gYXJlYVxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgJGNlbnRlciBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvY2VudGVyL1xuICogQHNlZSAkY2VudGVyU3BoZXJlIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9jZW50ZXJTcGhlcmUvXG4gKiBAc2VlICRnZW9XaXRoaW4gaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL2dlb1dpdGhpbi9cbiAqIEBzZWUgTW9uZ29EQiBHZW9zcGF0aWFsIEluZGV4aW5nIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL2NvcmUvZ2Vvc3BhdGlhbC1pbmRleGVzL1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIF9ERVBSRUNBVEVEXyBBbGlhcyBmb3IgW2NpcmNsZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5jaXJjbGUoKSlcbiAqXG4gKiAqKkRlcHJlY2F0ZWQuKiogVXNlIFtjaXJjbGVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuY2lyY2xlKCkpIGluc3RlYWQuXG4gKlxuICogQGRlcHJlY2F0ZWRcbiAqIEBtZXRob2QgY2VudGVyXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuY2VudGVyID0gUXVlcnkuYmFzZS5jaXJjbGU7XG5cbi8qKlxuICogX0RFUFJFQ0FURURfIFNwZWNpZmllcyBhIGAkY2VudGVyU3BoZXJlYCBjb25kaXRpb25cbiAqXG4gKiAqKkRlcHJlY2F0ZWQuKiogVXNlIFtjaXJjbGVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvcXVlcnkuaHRtbCNRdWVyeS5wcm90b3R5cGUuY2lyY2xlKCkpIGluc3RlYWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBhcmVhID0geyBjZW50ZXI6IFs1MCwgNTBdLCByYWRpdXM6IDEwIH07XG4gKiAgICAgcXVlcnkud2hlcmUoJ2xvYycpLndpdGhpbigpLmNlbnRlclNwaGVyZShhcmVhKTtcbiAqXG4gKiBAZGVwcmVjYXRlZFxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtPYmplY3R9IHZhbFxuICogQHJldHVybiB7UXVlcnl9IHRoaXNcbiAqIEBzZWUgTW9uZ29EQiBHZW9zcGF0aWFsIEluZGV4aW5nIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL2NvcmUvZ2Vvc3BhdGlhbC1pbmRleGVzL1xuICogQHNlZSAkY2VudGVyU3BoZXJlIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9jZW50ZXJTcGhlcmUvXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5jZW50ZXJTcGhlcmUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKGFyZ3VtZW50c1swXSAhPSBudWxsICYmIHR5cGVvZiBhcmd1bWVudHNbMF0uY29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicgJiYgYXJndW1lbnRzWzBdLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdPYmplY3QnKSB7XG4gICAgYXJndW1lbnRzWzBdLnNwaGVyaWNhbCA9IHRydWU7XG4gIH1cblxuICBpZiAoYXJndW1lbnRzWzFdICE9IG51bGwgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXS5jb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiBhcmd1bWVudHNbMV0uY29uc3RydWN0b3IubmFtZSA9PT0gJ09iamVjdCcpIHtcbiAgICBhcmd1bWVudHNbMV0uc3BoZXJpY2FsID0gdHJ1ZTtcbiAgfVxuXG4gIFF1ZXJ5LmJhc2UuY2lyY2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgZmllbGQgc2VsZWN0aW9uIGhhcyBiZWVuIG1hZGUuXG4gKlxuICogQG1ldGhvZCBzZWxlY3RlZFxuICogQG1lbWJlck9mIFF1ZXJ5XG4gKiBAaW5zdGFuY2VcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBpbmNsdXNpdmUgZmllbGQgc2VsZWN0aW9uIGhhcyBiZWVuIG1hZGUuXG4gKlxuICogICAgIHF1ZXJ5LnNlbGVjdGVkSW5jbHVzaXZlbHkoKTsgLy8gZmFsc2VcbiAqICAgICBxdWVyeS5zZWxlY3QoJ25hbWUnKTtcbiAqICAgICBxdWVyeS5zZWxlY3RlZEluY2x1c2l2ZWx5KCk7IC8vIHRydWVcbiAqXG4gKiBAbWV0aG9kIHNlbGVjdGVkSW5jbHVzaXZlbHlcbiAqIEBtZW1iZXJPZiBRdWVyeVxuICogQGluc3RhbmNlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5RdWVyeS5wcm90b3R5cGUuc2VsZWN0ZWRJbmNsdXNpdmVseSA9IGZ1bmN0aW9uIHNlbGVjdGVkSW5jbHVzaXZlbHkoKSB7XG4gIHJldHVybiBpc0luY2x1c2l2ZSh0aGlzLl9maWVsZHMpO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGV4Y2x1c2l2ZSBmaWVsZCBzZWxlY3Rpb24gaGFzIGJlZW4gbWFkZS5cbiAqXG4gKiAgICAgcXVlcnkuc2VsZWN0ZWRFeGNsdXNpdmVseSgpOyAvLyBmYWxzZVxuICogICAgIHF1ZXJ5LnNlbGVjdCgnLW5hbWUnKTtcbiAqICAgICBxdWVyeS5zZWxlY3RlZEV4Y2x1c2l2ZWx5KCk7IC8vIHRydWVcbiAqICAgICBxdWVyeS5zZWxlY3RlZEluY2x1c2l2ZWx5KCk7IC8vIGZhbHNlXG4gKlxuICogQG1ldGhvZCBzZWxlY3RlZEV4Y2x1c2l2ZWx5XG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUXVlcnkucHJvdG90eXBlLnNlbGVjdGVkRXhjbHVzaXZlbHkgPSBmdW5jdGlvbiBzZWxlY3RlZEV4Y2x1c2l2ZWx5KCkge1xuICByZXR1cm4gaXNFeGNsdXNpdmUodGhpcy5fZmllbGRzKTtcbn07XG5cbi8qKlxuICogVGhlIG1vZGVsIHRoaXMgcXVlcnkgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcSA9IE15TW9kZWwuZmluZCgpO1xuICogICAgIHEubW9kZWwgPT09IE15TW9kZWw7IC8vIHRydWVcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IG1vZGVsXG4gKiBAbWVtYmVyT2YgUXVlcnlcbiAqIEBpbnN0YW5jZVxuICovXG5cblF1ZXJ5LnByb3RvdHlwZS5tb2RlbDtcblxuLyohXG4gKiBFeHBvcnRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXJ5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/query.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/queryHelpers.js":
/*!************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/queryHelpers.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies\n */\n\nconst checkEmbeddedDiscriminatorKeyProjection =\n  __webpack_require__(/*! ./helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection */ \"../backend/node_modules/mongoose/lib/helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection.js\");\nconst get = __webpack_require__(/*! ./helpers/get */ \"../backend/node_modules/mongoose/lib/helpers/get.js\");\nconst getDiscriminatorByValue =\n  __webpack_require__(/*! ./helpers/discriminator/getDiscriminatorByValue */ \"../backend/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\nconst isDefiningProjection = __webpack_require__(/*! ./helpers/projection/isDefiningProjection */ \"../backend/node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js\");\nconst clone = __webpack_require__(/*! ./helpers/clone */ \"../backend/node_modules/mongoose/lib/helpers/clone.js\");\nconst isPathSelectedInclusive = __webpack_require__(/*! ./helpers/projection/isPathSelectedInclusive */ \"../backend/node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js\");\n\n/**\n * Prepare a set of path options for query population.\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\nexports.preparePopulationOptions = function preparePopulationOptions(query, options) {\n  const _populate = query.options.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);\n\n  // lean options should trickle through all queries\n  if (options.lean != null) {\n    pop\n      .filter(p => (p && p.options && p.options.lean) == null)\n      .forEach(makeLean(options.lean));\n  }\n\n  pop.forEach(opts => {\n    opts._localModel = query.model;\n  });\n\n  return pop;\n};\n\n/**\n * Prepare a set of path options for query population. This is the MongooseQuery\n * version\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\nexports.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options) {\n  const _populate = query._mongooseOptions.populate;\n  const pop = Object.keys(_populate).reduce((vals, key) => vals.concat([_populate[key]]), []);\n\n  // lean options should trickle through all queries\n  if (options.lean != null) {\n    pop\n      .filter(p => (p && p.options && p.options.lean) == null)\n      .forEach(makeLean(options.lean));\n  }\n\n  const session = query && query.options && query.options.session || null;\n  if (session != null) {\n    pop.forEach(path => {\n      if (path.options == null) {\n        path.options = { session: session };\n        return;\n      }\n      if (!('session' in path.options)) {\n        path.options.session = session;\n      }\n    });\n  }\n\n  const projection = query._fieldsForExec();\n  pop.forEach(p => {\n    p._queryProjection = projection;\n  });\n  pop.forEach(opts => {\n    opts._localModel = query.model;\n  });\n\n  return pop;\n};\n\n/**\n * If the document is a mapped discriminator type, it returns a model instance for that type, otherwise,\n * it returns an instance of the given model.\n *\n * @param {Model}  model\n * @param {Object} doc\n * @param {Object} fields\n *\n * @return {Document}\n */\nexports.createModel = function createModel(model, doc, fields, userProvidedFields, options) {\n  model.hooks.execPreSync('createModel', doc);\n  const discriminatorMapping = model.schema ?\n    model.schema.discriminatorMapping :\n    null;\n\n  const key = discriminatorMapping && discriminatorMapping.isRoot ?\n    discriminatorMapping.key :\n    null;\n\n  const value = doc[key];\n  if (key && value && model.discriminators) {\n    const discriminator = model.discriminators[value] || getDiscriminatorByValue(model.discriminators, value);\n    if (discriminator) {\n      const _fields = clone(userProvidedFields);\n      exports.applyPaths(_fields, discriminator.schema);\n      return new discriminator(undefined, _fields, true);\n    }\n  }\n\n  const _opts = {\n    skipId: true,\n    isNew: false,\n    willInit: true\n  };\n  if (options != null && 'defaults' in options) {\n    _opts.defaults = options.defaults;\n  }\n  return new model(undefined, fields, _opts);\n};\n\n/*!\n * ignore\n */\n\nexports.createModelAndInit = function createModelAndInit(model, doc, fields, userProvidedFields, options, populatedIds, callback) {\n  const initOpts = populatedIds ?\n    { populated: populatedIds } :\n    undefined;\n\n  const casted = exports.createModel(model, doc, fields, userProvidedFields, options);\n  try {\n    casted.$init(doc, initOpts, callback);\n  } catch (error) {\n    callback(error, casted);\n  }\n};\n\n/*!\n * ignore\n */\n\nexports.applyPaths = function applyPaths(fields, schema) {\n  // determine if query is selecting or excluding fields\n  let exclude;\n  let keys;\n  const minusPathsToSkip = new Set();\n\n  if (fields) {\n    keys = Object.keys(fields);\n\n    // Collapse minus paths\n    const minusPaths = [];\n    for (let i = 0; i < keys.length; ++i) {\n      const key = keys[i];\n      if (keys[i][0] !== '-') {\n        continue;\n      }\n\n      delete fields[key];\n      if (key === '-_id') {\n        fields['_id'] = 0;\n      } else {\n        minusPaths.push(key.slice(1));\n      }\n    }\n\n    keys = Object.keys(fields);\n    for (let keyIndex = 0; keyIndex < keys.length; ++keyIndex) {\n      if (keys[keyIndex][0] === '+') {\n        continue;\n      }\n      const field = fields[keys[keyIndex]];\n      // Skip `$meta` and `$slice`\n      if (!isDefiningProjection(field)) {\n        continue;\n      }\n      if (keys[keyIndex] === '_id' && keys.length > 1) {\n        continue;\n      }\n      if (keys[keyIndex] === schema.options.discriminatorKey && keys.length > 1 && field != null && !field) {\n        continue;\n      }\n      exclude = !field;\n      break;\n    }\n\n    // Potentially add back minus paths based on schema-level path config\n    // and whether the projection is inclusive\n    for (const path of minusPaths) {\n      const type = schema.path(path);\n      // If the path isn't selected by default or the projection is not\n      // inclusive, minus path is treated as equivalent to `key: 0`.\n      // But we also allow using `-name` to remove `name` from an inclusive\n      // projection if `name` has schema-level `select: true`.\n      if ((!type || !type.selected) || exclude !== false) {\n        fields[path] = 0;\n        exclude = true;\n      } else if (type && type.selected && exclude === false) {\n        // Make a note of minus paths that are overwriting paths that are\n        // included by default.\n        minusPathsToSkip.add(path);\n      }\n    }\n  }\n\n  // if selecting, apply default schematype select:true fields\n  // if excluding, apply schematype select:false fields\n  const selected = [];\n  const excluded = [];\n  const stack = [];\n\n  analyzeSchema(schema);\n  switch (exclude) {\n    case true:\n      for (const fieldName of excluded) {\n        fields[fieldName] = 0;\n      }\n      break;\n    case false:\n      if (schema &&\n          schema.paths['_id'] &&\n          schema.paths['_id'].options &&\n          schema.paths['_id'].options.select === false) {\n        fields._id = 0;\n      }\n\n      for (const fieldName of selected) {\n        if (minusPathsToSkip.has(fieldName)) {\n          continue;\n        }\n        if (isPathSelectedInclusive(fields, fieldName)) {\n          continue;\n        }\n        fields[fieldName] = fields[fieldName] || 1;\n      }\n      break;\n    case undefined:\n      if (fields == null) {\n        break;\n      }\n      // Any leftover plus paths must in the schema, so delete them (gh-7017)\n      for (const key of Object.keys(fields || {})) {\n        if (key.startsWith('+')) {\n          delete fields[key];\n        }\n      }\n\n      // user didn't specify fields, implies returning all fields.\n      // only need to apply excluded fields and delete any plus paths\n      for (const fieldName of excluded) {\n        if (fields[fieldName] != null) {\n          // Skip applying default projections to fields with non-defining\n          // projections, like `$slice`\n          continue;\n        }\n        fields[fieldName] = 0;\n      }\n      break;\n  }\n\n  function analyzeSchema(schema, prefix) {\n    prefix || (prefix = '');\n\n    // avoid recursion\n    if (stack.indexOf(schema) !== -1) {\n      return [];\n    }\n    stack.push(schema);\n\n    const addedPaths = [];\n    schema.eachPath(function(path, type) {\n      if (prefix) path = prefix + '.' + path;\n      if (type.$isSchemaMap || path.endsWith('.$*')) {\n        const plusPath = '+' + path;\n        const hasPlusPath = fields && plusPath in fields;\n        if (type.options && type.options.select === false && !hasPlusPath) {\n          excluded.push(path);\n        }\n        return;\n      }\n      let addedPath = analyzePath(path, type);\n      // arrays\n      if (addedPath == null && !Array.isArray(type) && type.$isMongooseArray && !type.$isMongooseDocumentArray) {\n        addedPath = analyzePath(path, type.caster);\n      }\n      if (addedPath != null) {\n        addedPaths.push(addedPath);\n      }\n\n      // nested schemas\n      if (type.schema) {\n        const _addedPaths = analyzeSchema(type.schema, path);\n\n        // Special case: if discriminator key is the only field that would\n        // be projected in, remove it.\n        if (exclude === false) {\n          checkEmbeddedDiscriminatorKeyProjection(fields, path, type.schema,\n            selected, _addedPaths);\n        }\n      }\n    });\n    stack.pop();\n    return addedPaths;\n  }\n\n  function analyzePath(path, type) {\n    if (fields == null) {\n      return;\n    }\n\n    // If schema-level selected not set, nothing to do\n    if (typeof type.selected !== 'boolean') {\n      return;\n    }\n\n    // User overwriting default exclusion\n    if (type.selected === false && fields[path]) {\n      return;\n    }\n\n    // If set to 0, we're explicitly excluding the discriminator key. Can't do this for all fields,\n    // because we have tests that assert that using `-path` to exclude schema-level `select: true`\n    // fields counts as an exclusive projection. See gh-11546\n    if (!exclude && type.selected && path === schema.options.discriminatorKey && fields[path] != null && !fields[path]) {\n      delete fields[path];\n      return;\n    }\n\n    if (exclude === false && type.selected && fields[path] != null && !fields[path]) {\n      delete fields[path];\n      return;\n    }\n\n    const plusPath = '+' + path;\n    const hasPlusPath = fields && plusPath in fields;\n    if (hasPlusPath) {\n      // forced inclusion\n      delete fields[plusPath];\n\n      // if there are other fields being included, add this one\n      // if no other included fields, leave this out (implied inclusion)\n      if (exclude === false && keys.length > 1 && !~keys.indexOf(path)) {\n        fields[path] = 1;\n      }\n\n      return;\n    }\n\n    // check for parent exclusions\n    const pieces = path.split('.');\n    let cur = '';\n    for (let i = 0; i < pieces.length; ++i) {\n      cur += cur.length ? '.' + pieces[i] : pieces[i];\n      if (excluded.indexOf(cur) !== -1) {\n        return;\n      }\n    }\n\n    // Special case: if user has included a parent path of a discriminator key,\n    // don't explicitly project in the discriminator key because that will\n    // project out everything else under the parent path\n    if (!exclude && (type && type.options && type.options.$skipDiscriminatorCheck || false)) {\n      let cur = '';\n      for (let i = 0; i < pieces.length; ++i) {\n        cur += (cur.length === 0 ? '' : '.') + pieces[i];\n        const projection = get(fields, cur, false) || get(fields, cur + '.$', false);\n        if (projection && typeof projection !== 'object') {\n          return;\n        }\n      }\n    }\n\n    (type.selected ? selected : excluded).push(path);\n    return path;\n  }\n};\n\n/**\n * Set each path query option to lean\n *\n * @param {Object} option\n */\n\nfunction makeLean(val) {\n  return function(option) {\n    option.options || (option.options = {});\n\n    if (val != null && Array.isArray(val.virtuals)) {\n      val = Object.assign({}, val);\n      val.virtuals = val.virtuals.\n        filter(path => typeof path === 'string' && path.startsWith(option.path + '.')).\n        map(path => path.slice(option.path.length + 1));\n    }\n\n    option.options.lean = val;\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3F1ZXJ5SGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFLG1CQUFPLENBQUMsOEtBQWlFO0FBQzNFLFlBQVksbUJBQU8sQ0FBQywwRUFBZTtBQUNuQztBQUNBLEVBQUUsbUJBQU8sQ0FBQyw4SUFBaUQ7QUFDM0QsNkJBQTZCLG1CQUFPLENBQUMsa0lBQTJDO0FBQ2hGLGNBQWMsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDdkMsZ0NBQWdDLG1CQUFPLENBQUMsd0lBQThDOztBQUV0RjtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjs7QUFFQSxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaOztBQUVBLGtDQUFrQztBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxZQUFZO0FBQ1o7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0EsTUFBTSwwQkFBMEI7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQix3QkFBd0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25COztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9xdWVyeUhlbHBlcnMuanM/MWJjNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbmNvbnN0IGNoZWNrRW1iZWRkZWREaXNjcmltaW5hdG9yS2V5UHJvamVjdGlvbiA9XG4gIHJlcXVpcmUoJy4vaGVscGVycy9kaXNjcmltaW5hdG9yL2NoZWNrRW1iZWRkZWREaXNjcmltaW5hdG9yS2V5UHJvamVjdGlvbicpO1xuY29uc3QgZ2V0ID0gcmVxdWlyZSgnLi9oZWxwZXJzL2dldCcpO1xuY29uc3QgZ2V0RGlzY3JpbWluYXRvckJ5VmFsdWUgPVxuICByZXF1aXJlKCcuL2hlbHBlcnMvZGlzY3JpbWluYXRvci9nZXREaXNjcmltaW5hdG9yQnlWYWx1ZScpO1xuY29uc3QgaXNEZWZpbmluZ1Byb2plY3Rpb24gPSByZXF1aXJlKCcuL2hlbHBlcnMvcHJvamVjdGlvbi9pc0RlZmluaW5nUHJvamVjdGlvbicpO1xuY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuL2hlbHBlcnMvY2xvbmUnKTtcbmNvbnN0IGlzUGF0aFNlbGVjdGVkSW5jbHVzaXZlID0gcmVxdWlyZSgnLi9oZWxwZXJzL3Byb2plY3Rpb24vaXNQYXRoU2VsZWN0ZWRJbmNsdXNpdmUnKTtcblxuLyoqXG4gKiBQcmVwYXJlIGEgc2V0IG9mIHBhdGggb3B0aW9ucyBmb3IgcXVlcnkgcG9wdWxhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1F1ZXJ5fSBxdWVyeVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbmV4cG9ydHMucHJlcGFyZVBvcHVsYXRpb25PcHRpb25zID0gZnVuY3Rpb24gcHJlcGFyZVBvcHVsYXRpb25PcHRpb25zKHF1ZXJ5LCBvcHRpb25zKSB7XG4gIGNvbnN0IF9wb3B1bGF0ZSA9IHF1ZXJ5Lm9wdGlvbnMucG9wdWxhdGU7XG4gIGNvbnN0IHBvcCA9IE9iamVjdC5rZXlzKF9wb3B1bGF0ZSkucmVkdWNlKCh2YWxzLCBrZXkpID0+IHZhbHMuY29uY2F0KFtfcG9wdWxhdGVba2V5XV0pLCBbXSk7XG5cbiAgLy8gbGVhbiBvcHRpb25zIHNob3VsZCB0cmlja2xlIHRocm91Z2ggYWxsIHF1ZXJpZXNcbiAgaWYgKG9wdGlvbnMubGVhbiAhPSBudWxsKSB7XG4gICAgcG9wXG4gICAgICAuZmlsdGVyKHAgPT4gKHAgJiYgcC5vcHRpb25zICYmIHAub3B0aW9ucy5sZWFuKSA9PSBudWxsKVxuICAgICAgLmZvckVhY2gobWFrZUxlYW4ob3B0aW9ucy5sZWFuKSk7XG4gIH1cblxuICBwb3AuZm9yRWFjaChvcHRzID0+IHtcbiAgICBvcHRzLl9sb2NhbE1vZGVsID0gcXVlcnkubW9kZWw7XG4gIH0pO1xuXG4gIHJldHVybiBwb3A7XG59O1xuXG4vKipcbiAqIFByZXBhcmUgYSBzZXQgb2YgcGF0aCBvcHRpb25zIGZvciBxdWVyeSBwb3B1bGF0aW9uLiBUaGlzIGlzIHRoZSBNb25nb29zZVF1ZXJ5XG4gKiB2ZXJzaW9uXG4gKlxuICogQHBhcmFtIHtRdWVyeX0gcXVlcnlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5leHBvcnRzLnByZXBhcmVQb3B1bGF0aW9uT3B0aW9uc01RID0gZnVuY3Rpb24gcHJlcGFyZVBvcHVsYXRpb25PcHRpb25zTVEocXVlcnksIG9wdGlvbnMpIHtcbiAgY29uc3QgX3BvcHVsYXRlID0gcXVlcnkuX21vbmdvb3NlT3B0aW9ucy5wb3B1bGF0ZTtcbiAgY29uc3QgcG9wID0gT2JqZWN0LmtleXMoX3BvcHVsYXRlKS5yZWR1Y2UoKHZhbHMsIGtleSkgPT4gdmFscy5jb25jYXQoW19wb3B1bGF0ZVtrZXldXSksIFtdKTtcblxuICAvLyBsZWFuIG9wdGlvbnMgc2hvdWxkIHRyaWNrbGUgdGhyb3VnaCBhbGwgcXVlcmllc1xuICBpZiAob3B0aW9ucy5sZWFuICE9IG51bGwpIHtcbiAgICBwb3BcbiAgICAgIC5maWx0ZXIocCA9PiAocCAmJiBwLm9wdGlvbnMgJiYgcC5vcHRpb25zLmxlYW4pID09IG51bGwpXG4gICAgICAuZm9yRWFjaChtYWtlTGVhbihvcHRpb25zLmxlYW4pKTtcbiAgfVxuXG4gIGNvbnN0IHNlc3Npb24gPSBxdWVyeSAmJiBxdWVyeS5vcHRpb25zICYmIHF1ZXJ5Lm9wdGlvbnMuc2Vzc2lvbiB8fCBudWxsO1xuICBpZiAoc2Vzc2lvbiAhPSBudWxsKSB7XG4gICAgcG9wLmZvckVhY2gocGF0aCA9PiB7XG4gICAgICBpZiAocGF0aC5vcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgcGF0aC5vcHRpb25zID0geyBzZXNzaW9uOiBzZXNzaW9uIH07XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghKCdzZXNzaW9uJyBpbiBwYXRoLm9wdGlvbnMpKSB7XG4gICAgICAgIHBhdGgub3B0aW9ucy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IHByb2plY3Rpb24gPSBxdWVyeS5fZmllbGRzRm9yRXhlYygpO1xuICBwb3AuZm9yRWFjaChwID0+IHtcbiAgICBwLl9xdWVyeVByb2plY3Rpb24gPSBwcm9qZWN0aW9uO1xuICB9KTtcbiAgcG9wLmZvckVhY2gob3B0cyA9PiB7XG4gICAgb3B0cy5fbG9jYWxNb2RlbCA9IHF1ZXJ5Lm1vZGVsO1xuICB9KTtcblxuICByZXR1cm4gcG9wO1xufTtcblxuLyoqXG4gKiBJZiB0aGUgZG9jdW1lbnQgaXMgYSBtYXBwZWQgZGlzY3JpbWluYXRvciB0eXBlLCBpdCByZXR1cm5zIGEgbW9kZWwgaW5zdGFuY2UgZm9yIHRoYXQgdHlwZSwgb3RoZXJ3aXNlLFxuICogaXQgcmV0dXJucyBhbiBpbnN0YW5jZSBvZiB0aGUgZ2l2ZW4gbW9kZWwuXG4gKlxuICogQHBhcmFtIHtNb2RlbH0gIG1vZGVsXG4gKiBAcGFyYW0ge09iamVjdH0gZG9jXG4gKiBAcGFyYW0ge09iamVjdH0gZmllbGRzXG4gKlxuICogQHJldHVybiB7RG9jdW1lbnR9XG4gKi9cbmV4cG9ydHMuY3JlYXRlTW9kZWwgPSBmdW5jdGlvbiBjcmVhdGVNb2RlbChtb2RlbCwgZG9jLCBmaWVsZHMsIHVzZXJQcm92aWRlZEZpZWxkcywgb3B0aW9ucykge1xuICBtb2RlbC5ob29rcy5leGVjUHJlU3luYygnY3JlYXRlTW9kZWwnLCBkb2MpO1xuICBjb25zdCBkaXNjcmltaW5hdG9yTWFwcGluZyA9IG1vZGVsLnNjaGVtYSA/XG4gICAgbW9kZWwuc2NoZW1hLmRpc2NyaW1pbmF0b3JNYXBwaW5nIDpcbiAgICBudWxsO1xuXG4gIGNvbnN0IGtleSA9IGRpc2NyaW1pbmF0b3JNYXBwaW5nICYmIGRpc2NyaW1pbmF0b3JNYXBwaW5nLmlzUm9vdCA/XG4gICAgZGlzY3JpbWluYXRvck1hcHBpbmcua2V5IDpcbiAgICBudWxsO1xuXG4gIGNvbnN0IHZhbHVlID0gZG9jW2tleV07XG4gIGlmIChrZXkgJiYgdmFsdWUgJiYgbW9kZWwuZGlzY3JpbWluYXRvcnMpIHtcbiAgICBjb25zdCBkaXNjcmltaW5hdG9yID0gbW9kZWwuZGlzY3JpbWluYXRvcnNbdmFsdWVdIHx8IGdldERpc2NyaW1pbmF0b3JCeVZhbHVlKG1vZGVsLmRpc2NyaW1pbmF0b3JzLCB2YWx1ZSk7XG4gICAgaWYgKGRpc2NyaW1pbmF0b3IpIHtcbiAgICAgIGNvbnN0IF9maWVsZHMgPSBjbG9uZSh1c2VyUHJvdmlkZWRGaWVsZHMpO1xuICAgICAgZXhwb3J0cy5hcHBseVBhdGhzKF9maWVsZHMsIGRpc2NyaW1pbmF0b3Iuc2NoZW1hKTtcbiAgICAgIHJldHVybiBuZXcgZGlzY3JpbWluYXRvcih1bmRlZmluZWQsIF9maWVsZHMsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IF9vcHRzID0ge1xuICAgIHNraXBJZDogdHJ1ZSxcbiAgICBpc05ldzogZmFsc2UsXG4gICAgd2lsbEluaXQ6IHRydWVcbiAgfTtcbiAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiAnZGVmYXVsdHMnIGluIG9wdGlvbnMpIHtcbiAgICBfb3B0cy5kZWZhdWx0cyA9IG9wdGlvbnMuZGVmYXVsdHM7XG4gIH1cbiAgcmV0dXJuIG5ldyBtb2RlbCh1bmRlZmluZWQsIGZpZWxkcywgX29wdHMpO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5leHBvcnRzLmNyZWF0ZU1vZGVsQW5kSW5pdCA9IGZ1bmN0aW9uIGNyZWF0ZU1vZGVsQW5kSW5pdChtb2RlbCwgZG9jLCBmaWVsZHMsIHVzZXJQcm92aWRlZEZpZWxkcywgb3B0aW9ucywgcG9wdWxhdGVkSWRzLCBjYWxsYmFjaykge1xuICBjb25zdCBpbml0T3B0cyA9IHBvcHVsYXRlZElkcyA/XG4gICAgeyBwb3B1bGF0ZWQ6IHBvcHVsYXRlZElkcyB9IDpcbiAgICB1bmRlZmluZWQ7XG5cbiAgY29uc3QgY2FzdGVkID0gZXhwb3J0cy5jcmVhdGVNb2RlbChtb2RlbCwgZG9jLCBmaWVsZHMsIHVzZXJQcm92aWRlZEZpZWxkcywgb3B0aW9ucyk7XG4gIHRyeSB7XG4gICAgY2FzdGVkLiRpbml0KGRvYywgaW5pdE9wdHMsIGNhbGxiYWNrKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjYWxsYmFjayhlcnJvciwgY2FzdGVkKTtcbiAgfVxufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5leHBvcnRzLmFwcGx5UGF0aHMgPSBmdW5jdGlvbiBhcHBseVBhdGhzKGZpZWxkcywgc2NoZW1hKSB7XG4gIC8vIGRldGVybWluZSBpZiBxdWVyeSBpcyBzZWxlY3Rpbmcgb3IgZXhjbHVkaW5nIGZpZWxkc1xuICBsZXQgZXhjbHVkZTtcbiAgbGV0IGtleXM7XG4gIGNvbnN0IG1pbnVzUGF0aHNUb1NraXAgPSBuZXcgU2V0KCk7XG5cbiAgaWYgKGZpZWxkcykge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyhmaWVsZHMpO1xuXG4gICAgLy8gQ29sbGFwc2UgbWludXMgcGF0aHNcbiAgICBjb25zdCBtaW51c1BhdGhzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKGtleXNbaV1bMF0gIT09ICctJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIGZpZWxkc1trZXldO1xuICAgICAgaWYgKGtleSA9PT0gJy1faWQnKSB7XG4gICAgICAgIGZpZWxkc1snX2lkJ10gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWludXNQYXRocy5wdXNoKGtleS5zbGljZSgxKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGZpZWxkcyk7XG4gICAgZm9yIChsZXQga2V5SW5kZXggPSAwOyBrZXlJbmRleCA8IGtleXMubGVuZ3RoOyArK2tleUluZGV4KSB7XG4gICAgICBpZiAoa2V5c1trZXlJbmRleF1bMF0gPT09ICcrJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZpZWxkID0gZmllbGRzW2tleXNba2V5SW5kZXhdXTtcbiAgICAgIC8vIFNraXAgYCRtZXRhYCBhbmQgYCRzbGljZWBcbiAgICAgIGlmICghaXNEZWZpbmluZ1Byb2plY3Rpb24oZmllbGQpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGtleXNba2V5SW5kZXhdID09PSAnX2lkJyAmJiBrZXlzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoa2V5c1trZXlJbmRleF0gPT09IHNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXkgJiYga2V5cy5sZW5ndGggPiAxICYmIGZpZWxkICE9IG51bGwgJiYgIWZpZWxkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZXhjbHVkZSA9ICFmaWVsZDtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIFBvdGVudGlhbGx5IGFkZCBiYWNrIG1pbnVzIHBhdGhzIGJhc2VkIG9uIHNjaGVtYS1sZXZlbCBwYXRoIGNvbmZpZ1xuICAgIC8vIGFuZCB3aGV0aGVyIHRoZSBwcm9qZWN0aW9uIGlzIGluY2x1c2l2ZVxuICAgIGZvciAoY29uc3QgcGF0aCBvZiBtaW51c1BhdGhzKSB7XG4gICAgICBjb25zdCB0eXBlID0gc2NoZW1hLnBhdGgocGF0aCk7XG4gICAgICAvLyBJZiB0aGUgcGF0aCBpc24ndCBzZWxlY3RlZCBieSBkZWZhdWx0IG9yIHRoZSBwcm9qZWN0aW9uIGlzIG5vdFxuICAgICAgLy8gaW5jbHVzaXZlLCBtaW51cyBwYXRoIGlzIHRyZWF0ZWQgYXMgZXF1aXZhbGVudCB0byBga2V5OiAwYC5cbiAgICAgIC8vIEJ1dCB3ZSBhbHNvIGFsbG93IHVzaW5nIGAtbmFtZWAgdG8gcmVtb3ZlIGBuYW1lYCBmcm9tIGFuIGluY2x1c2l2ZVxuICAgICAgLy8gcHJvamVjdGlvbiBpZiBgbmFtZWAgaGFzIHNjaGVtYS1sZXZlbCBgc2VsZWN0OiB0cnVlYC5cbiAgICAgIGlmICgoIXR5cGUgfHwgIXR5cGUuc2VsZWN0ZWQpIHx8IGV4Y2x1ZGUgIT09IGZhbHNlKSB7XG4gICAgICAgIGZpZWxkc1twYXRoXSA9IDA7XG4gICAgICAgIGV4Y2x1ZGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlICYmIHR5cGUuc2VsZWN0ZWQgJiYgZXhjbHVkZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gTWFrZSBhIG5vdGUgb2YgbWludXMgcGF0aHMgdGhhdCBhcmUgb3ZlcndyaXRpbmcgcGF0aHMgdGhhdCBhcmVcbiAgICAgICAgLy8gaW5jbHVkZWQgYnkgZGVmYXVsdC5cbiAgICAgICAgbWludXNQYXRoc1RvU2tpcC5hZGQocGF0aCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgc2VsZWN0aW5nLCBhcHBseSBkZWZhdWx0IHNjaGVtYXR5cGUgc2VsZWN0OnRydWUgZmllbGRzXG4gIC8vIGlmIGV4Y2x1ZGluZywgYXBwbHkgc2NoZW1hdHlwZSBzZWxlY3Q6ZmFsc2UgZmllbGRzXG4gIGNvbnN0IHNlbGVjdGVkID0gW107XG4gIGNvbnN0IGV4Y2x1ZGVkID0gW107XG4gIGNvbnN0IHN0YWNrID0gW107XG5cbiAgYW5hbHl6ZVNjaGVtYShzY2hlbWEpO1xuICBzd2l0Y2ggKGV4Y2x1ZGUpIHtcbiAgICBjYXNlIHRydWU6XG4gICAgICBmb3IgKGNvbnN0IGZpZWxkTmFtZSBvZiBleGNsdWRlZCkge1xuICAgICAgICBmaWVsZHNbZmllbGROYW1lXSA9IDA7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIGZhbHNlOlxuICAgICAgaWYgKHNjaGVtYSAmJlxuICAgICAgICAgIHNjaGVtYS5wYXRoc1snX2lkJ10gJiZcbiAgICAgICAgICBzY2hlbWEucGF0aHNbJ19pZCddLm9wdGlvbnMgJiZcbiAgICAgICAgICBzY2hlbWEucGF0aHNbJ19pZCddLm9wdGlvbnMuc2VsZWN0ID09PSBmYWxzZSkge1xuICAgICAgICBmaWVsZHMuX2lkID0gMDtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBmaWVsZE5hbWUgb2Ygc2VsZWN0ZWQpIHtcbiAgICAgICAgaWYgKG1pbnVzUGF0aHNUb1NraXAuaGFzKGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQYXRoU2VsZWN0ZWRJbmNsdXNpdmUoZmllbGRzLCBmaWVsZE5hbWUpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZmllbGRzW2ZpZWxkTmFtZV0gPSBmaWVsZHNbZmllbGROYW1lXSB8fCAxO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICBpZiAoZmllbGRzID09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBBbnkgbGVmdG92ZXIgcGx1cyBwYXRocyBtdXN0IGluIHRoZSBzY2hlbWEsIHNvIGRlbGV0ZSB0aGVtIChnaC03MDE3KVxuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoZmllbGRzIHx8IHt9KSkge1xuICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoJysnKSkge1xuICAgICAgICAgIGRlbGV0ZSBmaWVsZHNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB1c2VyIGRpZG4ndCBzcGVjaWZ5IGZpZWxkcywgaW1wbGllcyByZXR1cm5pbmcgYWxsIGZpZWxkcy5cbiAgICAgIC8vIG9ubHkgbmVlZCB0byBhcHBseSBleGNsdWRlZCBmaWVsZHMgYW5kIGRlbGV0ZSBhbnkgcGx1cyBwYXRoc1xuICAgICAgZm9yIChjb25zdCBmaWVsZE5hbWUgb2YgZXhjbHVkZWQpIHtcbiAgICAgICAgaWYgKGZpZWxkc1tmaWVsZE5hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBTa2lwIGFwcGx5aW5nIGRlZmF1bHQgcHJvamVjdGlvbnMgdG8gZmllbGRzIHdpdGggbm9uLWRlZmluaW5nXG4gICAgICAgICAgLy8gcHJvamVjdGlvbnMsIGxpa2UgYCRzbGljZWBcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmaWVsZHNbZmllbGROYW1lXSA9IDA7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGZ1bmN0aW9uIGFuYWx5emVTY2hlbWEoc2NoZW1hLCBwcmVmaXgpIHtcbiAgICBwcmVmaXggfHwgKHByZWZpeCA9ICcnKTtcblxuICAgIC8vIGF2b2lkIHJlY3Vyc2lvblxuICAgIGlmIChzdGFjay5pbmRleE9mKHNjaGVtYSkgIT09IC0xKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHN0YWNrLnB1c2goc2NoZW1hKTtcblxuICAgIGNvbnN0IGFkZGVkUGF0aHMgPSBbXTtcbiAgICBzY2hlbWEuZWFjaFBhdGgoZnVuY3Rpb24ocGF0aCwgdHlwZSkge1xuICAgICAgaWYgKHByZWZpeCkgcGF0aCA9IHByZWZpeCArICcuJyArIHBhdGg7XG4gICAgICBpZiAodHlwZS4kaXNTY2hlbWFNYXAgfHwgcGF0aC5lbmRzV2l0aCgnLiQqJykpIHtcbiAgICAgICAgY29uc3QgcGx1c1BhdGggPSAnKycgKyBwYXRoO1xuICAgICAgICBjb25zdCBoYXNQbHVzUGF0aCA9IGZpZWxkcyAmJiBwbHVzUGF0aCBpbiBmaWVsZHM7XG4gICAgICAgIGlmICh0eXBlLm9wdGlvbnMgJiYgdHlwZS5vcHRpb25zLnNlbGVjdCA9PT0gZmFsc2UgJiYgIWhhc1BsdXNQYXRoKSB7XG4gICAgICAgICAgZXhjbHVkZWQucHVzaChwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgYWRkZWRQYXRoID0gYW5hbHl6ZVBhdGgocGF0aCwgdHlwZSk7XG4gICAgICAvLyBhcnJheXNcbiAgICAgIGlmIChhZGRlZFBhdGggPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh0eXBlKSAmJiB0eXBlLiRpc01vbmdvb3NlQXJyYXkgJiYgIXR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB7XG4gICAgICAgIGFkZGVkUGF0aCA9IGFuYWx5emVQYXRoKHBhdGgsIHR5cGUuY2FzdGVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChhZGRlZFBhdGggIT0gbnVsbCkge1xuICAgICAgICBhZGRlZFBhdGhzLnB1c2goYWRkZWRQYXRoKTtcbiAgICAgIH1cblxuICAgICAgLy8gbmVzdGVkIHNjaGVtYXNcbiAgICAgIGlmICh0eXBlLnNjaGVtYSkge1xuICAgICAgICBjb25zdCBfYWRkZWRQYXRocyA9IGFuYWx5emVTY2hlbWEodHlwZS5zY2hlbWEsIHBhdGgpO1xuXG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZTogaWYgZGlzY3JpbWluYXRvciBrZXkgaXMgdGhlIG9ubHkgZmllbGQgdGhhdCB3b3VsZFxuICAgICAgICAvLyBiZSBwcm9qZWN0ZWQgaW4sIHJlbW92ZSBpdC5cbiAgICAgICAgaWYgKGV4Y2x1ZGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgY2hlY2tFbWJlZGRlZERpc2NyaW1pbmF0b3JLZXlQcm9qZWN0aW9uKGZpZWxkcywgcGF0aCwgdHlwZS5zY2hlbWEsXG4gICAgICAgICAgICBzZWxlY3RlZCwgX2FkZGVkUGF0aHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgc3RhY2sucG9wKCk7XG4gICAgcmV0dXJuIGFkZGVkUGF0aHM7XG4gIH1cblxuICBmdW5jdGlvbiBhbmFseXplUGF0aChwYXRoLCB0eXBlKSB7XG4gICAgaWYgKGZpZWxkcyA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgc2NoZW1hLWxldmVsIHNlbGVjdGVkIG5vdCBzZXQsIG5vdGhpbmcgdG8gZG9cbiAgICBpZiAodHlwZW9mIHR5cGUuc2VsZWN0ZWQgIT09ICdib29sZWFuJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFVzZXIgb3ZlcndyaXRpbmcgZGVmYXVsdCBleGNsdXNpb25cbiAgICBpZiAodHlwZS5zZWxlY3RlZCA9PT0gZmFsc2UgJiYgZmllbGRzW3BhdGhdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgc2V0IHRvIDAsIHdlJ3JlIGV4cGxpY2l0bHkgZXhjbHVkaW5nIHRoZSBkaXNjcmltaW5hdG9yIGtleS4gQ2FuJ3QgZG8gdGhpcyBmb3IgYWxsIGZpZWxkcyxcbiAgICAvLyBiZWNhdXNlIHdlIGhhdmUgdGVzdHMgdGhhdCBhc3NlcnQgdGhhdCB1c2luZyBgLXBhdGhgIHRvIGV4Y2x1ZGUgc2NoZW1hLWxldmVsIGBzZWxlY3Q6IHRydWVgXG4gICAgLy8gZmllbGRzIGNvdW50cyBhcyBhbiBleGNsdXNpdmUgcHJvamVjdGlvbi4gU2VlIGdoLTExNTQ2XG4gICAgaWYgKCFleGNsdWRlICYmIHR5cGUuc2VsZWN0ZWQgJiYgcGF0aCA9PT0gc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleSAmJiBmaWVsZHNbcGF0aF0gIT0gbnVsbCAmJiAhZmllbGRzW3BhdGhdKSB7XG4gICAgICBkZWxldGUgZmllbGRzW3BhdGhdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChleGNsdWRlID09PSBmYWxzZSAmJiB0eXBlLnNlbGVjdGVkICYmIGZpZWxkc1twYXRoXSAhPSBudWxsICYmICFmaWVsZHNbcGF0aF0pIHtcbiAgICAgIGRlbGV0ZSBmaWVsZHNbcGF0aF07XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcGx1c1BhdGggPSAnKycgKyBwYXRoO1xuICAgIGNvbnN0IGhhc1BsdXNQYXRoID0gZmllbGRzICYmIHBsdXNQYXRoIGluIGZpZWxkcztcbiAgICBpZiAoaGFzUGx1c1BhdGgpIHtcbiAgICAgIC8vIGZvcmNlZCBpbmNsdXNpb25cbiAgICAgIGRlbGV0ZSBmaWVsZHNbcGx1c1BhdGhdO1xuXG4gICAgICAvLyBpZiB0aGVyZSBhcmUgb3RoZXIgZmllbGRzIGJlaW5nIGluY2x1ZGVkLCBhZGQgdGhpcyBvbmVcbiAgICAgIC8vIGlmIG5vIG90aGVyIGluY2x1ZGVkIGZpZWxkcywgbGVhdmUgdGhpcyBvdXQgKGltcGxpZWQgaW5jbHVzaW9uKVxuICAgICAgaWYgKGV4Y2x1ZGUgPT09IGZhbHNlICYmIGtleXMubGVuZ3RoID4gMSAmJiAhfmtleXMuaW5kZXhPZihwYXRoKSkge1xuICAgICAgICBmaWVsZHNbcGF0aF0gPSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZm9yIHBhcmVudCBleGNsdXNpb25zXG4gICAgY29uc3QgcGllY2VzID0gcGF0aC5zcGxpdCgnLicpO1xuICAgIGxldCBjdXIgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBpZWNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgY3VyICs9IGN1ci5sZW5ndGggPyAnLicgKyBwaWVjZXNbaV0gOiBwaWVjZXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihjdXIpICE9PSAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3BlY2lhbCBjYXNlOiBpZiB1c2VyIGhhcyBpbmNsdWRlZCBhIHBhcmVudCBwYXRoIG9mIGEgZGlzY3JpbWluYXRvciBrZXksXG4gICAgLy8gZG9uJ3QgZXhwbGljaXRseSBwcm9qZWN0IGluIHRoZSBkaXNjcmltaW5hdG9yIGtleSBiZWNhdXNlIHRoYXQgd2lsbFxuICAgIC8vIHByb2plY3Qgb3V0IGV2ZXJ5dGhpbmcgZWxzZSB1bmRlciB0aGUgcGFyZW50IHBhdGhcbiAgICBpZiAoIWV4Y2x1ZGUgJiYgKHR5cGUgJiYgdHlwZS5vcHRpb25zICYmIHR5cGUub3B0aW9ucy4kc2tpcERpc2NyaW1pbmF0b3JDaGVjayB8fCBmYWxzZSkpIHtcbiAgICAgIGxldCBjdXIgPSAnJztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGllY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGN1ciArPSAoY3VyLmxlbmd0aCA9PT0gMCA/ICcnIDogJy4nKSArIHBpZWNlc1tpXTtcbiAgICAgICAgY29uc3QgcHJvamVjdGlvbiA9IGdldChmaWVsZHMsIGN1ciwgZmFsc2UpIHx8IGdldChmaWVsZHMsIGN1ciArICcuJCcsIGZhbHNlKTtcbiAgICAgICAgaWYgKHByb2plY3Rpb24gJiYgdHlwZW9mIHByb2plY3Rpb24gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgKHR5cGUuc2VsZWN0ZWQgPyBzZWxlY3RlZCA6IGV4Y2x1ZGVkKS5wdXNoKHBhdGgpO1xuICAgIHJldHVybiBwYXRoO1xuICB9XG59O1xuXG4vKipcbiAqIFNldCBlYWNoIHBhdGggcXVlcnkgb3B0aW9uIHRvIGxlYW5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uXG4gKi9cblxuZnVuY3Rpb24gbWFrZUxlYW4odmFsKSB7XG4gIHJldHVybiBmdW5jdGlvbihvcHRpb24pIHtcbiAgICBvcHRpb24ub3B0aW9ucyB8fCAob3B0aW9uLm9wdGlvbnMgPSB7fSk7XG5cbiAgICBpZiAodmFsICE9IG51bGwgJiYgQXJyYXkuaXNBcnJheSh2YWwudmlydHVhbHMpKSB7XG4gICAgICB2YWwgPSBPYmplY3QuYXNzaWduKHt9LCB2YWwpO1xuICAgICAgdmFsLnZpcnR1YWxzID0gdmFsLnZpcnR1YWxzLlxuICAgICAgICBmaWx0ZXIocGF0aCA9PiB0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycgJiYgcGF0aC5zdGFydHNXaXRoKG9wdGlvbi5wYXRoICsgJy4nKSkuXG4gICAgICAgIG1hcChwYXRoID0+IHBhdGguc2xpY2Uob3B0aW9uLnBhdGgubGVuZ3RoICsgMSkpO1xuICAgIH1cblxuICAgIG9wdGlvbi5vcHRpb25zLmxlYW4gPSB2YWw7XG4gIH07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/queryHelpers.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/schema.js":
/*!******************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/schema.js ***!
  \******************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Kareem = __webpack_require__(/*! kareem */ \"../backend/node_modules/kareem/index.js\");\nconst MongooseError = __webpack_require__(/*! ./error/mongooseError */ \"../backend/node_modules/mongoose/lib/error/mongooseError.js\");\nconst SchemaType = __webpack_require__(/*! ./schemaType */ \"../backend/node_modules/mongoose/lib/schemaType.js\");\nconst SchemaTypeOptions = __webpack_require__(/*! ./options/schemaTypeOptions */ \"../backend/node_modules/mongoose/lib/options/schemaTypeOptions.js\");\nconst VirtualOptions = __webpack_require__(/*! ./options/virtualOptions */ \"../backend/node_modules/mongoose/lib/options/virtualOptions.js\");\nconst VirtualType = __webpack_require__(/*! ./virtualType */ \"../backend/node_modules/mongoose/lib/virtualType.js\");\nconst addAutoId = __webpack_require__(/*! ./helpers/schema/addAutoId */ \"../backend/node_modules/mongoose/lib/helpers/schema/addAutoId.js\");\nconst clone = __webpack_require__(/*! ./helpers/clone */ \"../backend/node_modules/mongoose/lib/helpers/clone.js\");\nconst get = __webpack_require__(/*! ./helpers/get */ \"../backend/node_modules/mongoose/lib/helpers/get.js\");\nconst getConstructorName = __webpack_require__(/*! ./helpers/getConstructorName */ \"../backend/node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst getIndexes = __webpack_require__(/*! ./helpers/schema/getIndexes */ \"../backend/node_modules/mongoose/lib/helpers/schema/getIndexes.js\");\nconst handleReadPreferenceAliases = __webpack_require__(/*! ./helpers/query/handleReadPreferenceAliases */ \"../backend/node_modules/mongoose/lib/helpers/query/handleReadPreferenceAliases.js\");\nconst idGetter = __webpack_require__(/*! ./helpers/schema/idGetter */ \"../backend/node_modules/mongoose/lib/helpers/schema/idGetter.js\");\nconst merge = __webpack_require__(/*! ./helpers/schema/merge */ \"../backend/node_modules/mongoose/lib/helpers/schema/merge.js\");\nconst mpath = __webpack_require__(/*! mpath */ \"../backend/node_modules/mpath/index.js\");\nconst setPopulatedVirtualValue = __webpack_require__(/*! ./helpers/populate/setPopulatedVirtualValue */ \"../backend/node_modules/mongoose/lib/helpers/populate/setPopulatedVirtualValue.js\");\nconst setupTimestamps = __webpack_require__(/*! ./helpers/timestamps/setupTimestamps */ \"../backend/node_modules/mongoose/lib/helpers/timestamps/setupTimestamps.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\nconst validateRef = __webpack_require__(/*! ./helpers/populate/validateRef */ \"../backend/node_modules/mongoose/lib/helpers/populate/validateRef.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\nconst hasNumericSubpathRegex = /\\.\\d+(\\.|$)/;\n\nlet MongooseTypes;\n\nconst queryHooks = (__webpack_require__(/*! ./constants */ \"../backend/node_modules/mongoose/lib/constants.js\").queryMiddlewareFunctions);\nconst documentHooks = (__webpack_require__(/*! ./helpers/model/applyHooks */ \"../backend/node_modules/mongoose/lib/helpers/model/applyHooks.js\").middlewareFunctions);\nconst hookNames = queryHooks.concat(documentHooks).\n  reduce((s, hook) => s.add(hook), new Set());\n\nconst isPOJO = utils.isPOJO;\n\nlet id = 0;\n\nconst numberRE = /^\\d+$/;\n\n/**\n * Schema constructor.\n *\n * #### Example:\n *\n *     const child = new Schema({ name: String });\n *     const schema = new Schema({ name: String, age: Number, children: [child] });\n *     const Tree = mongoose.model('Tree', schema);\n *\n *     // setting schema options\n *     new Schema({ name: String }, { id: false, autoIndex: false })\n *\n * #### Options:\n *\n * - [autoIndex](https://mongoosejs.com/docs/guide.html#autoIndex): bool - defaults to null (which means use the connection's autoIndex option)\n * - [autoCreate](https://mongoosejs.com/docs/guide.html#autoCreate): bool - defaults to null (which means use the connection's autoCreate option)\n * - [bufferCommands](https://mongoosejs.com/docs/guide.html#bufferCommands): bool - defaults to true\n * - [bufferTimeoutMS](https://mongoosejs.com/docs/guide.html#bufferTimeoutMS): number - defaults to 10000 (10 seconds). If `bufferCommands` is enabled, the amount of time Mongoose will wait for connectivity to be restablished before erroring out.\n * - [capped](https://mongoosejs.com/docs/guide.html#capped): bool | number | object - defaults to false\n * - [collection](https://mongoosejs.com/docs/guide.html#collection): string - no default\n * - [discriminatorKey](https://mongoosejs.com/docs/guide.html#discriminatorKey): string - defaults to `__t`\n * - [id](https://mongoosejs.com/docs/guide.html#id): bool - defaults to true\n * - [_id](https://mongoosejs.com/docs/guide.html#_id): bool - defaults to true\n * - [minimize](https://mongoosejs.com/docs/guide.html#minimize): bool - controls [document#toObject](https://mongoosejs.com/docs/api/document.html#Document.prototype.toObject()) behavior when called manually - defaults to true\n * - [read](https://mongoosejs.com/docs/guide.html#read): string\n * - [writeConcern](https://mongoosejs.com/docs/guide.html#writeConcern): object - defaults to null, use to override [the MongoDB server's default write concern settings](https://www.mongodb.com/docs/manual/reference/write-concern/)\n * - [shardKey](https://mongoosejs.com/docs/guide.html#shardKey): object - defaults to `null`\n * - [strict](https://mongoosejs.com/docs/guide.html#strict): bool - defaults to true\n * - [strictQuery](https://mongoosejs.com/docs/guide.html#strictQuery): bool - defaults to false\n * - [toJSON](https://mongoosejs.com/docs/guide.html#toJSON) - object - no default\n * - [toObject](https://mongoosejs.com/docs/guide.html#toObject) - object - no default\n * - [typeKey](https://mongoosejs.com/docs/guide.html#typeKey) - string - defaults to 'type'\n * - [validateBeforeSave](https://mongoosejs.com/docs/guide.html#validateBeforeSave) - bool - defaults to `true`\n * - [validateModifiedOnly](https://mongoosejs.com/docs/api/document.html#Document.prototype.validate()) - bool - defaults to `false`\n * - [versionKey](https://mongoosejs.com/docs/guide.html#versionKey): string or object - defaults to \"__v\"\n * - [optimisticConcurrency](https://mongoosejs.com/docs/guide.html#optimisticConcurrency): bool - defaults to false. Set to true to enable [optimistic concurrency](https://thecodebarbarian.com/whats-new-in-mongoose-5-10-optimistic-concurrency.html).\n * - [collation](https://mongoosejs.com/docs/guide.html#collation): object - defaults to null (which means use no collation)\n * - [timeseries](https://mongoosejs.com/docs/guide.html#timeseries): object - defaults to null (which means this schema's collection won't be a timeseries collection)\n * - [selectPopulatedPaths](https://mongoosejs.com/docs/guide.html#selectPopulatedPaths): boolean - defaults to `true`\n * - [skipVersioning](https://mongoosejs.com/docs/guide.html#skipVersioning): object - paths to exclude from versioning\n * - [timestamps](https://mongoosejs.com/docs/guide.html#timestamps): object or boolean - defaults to `false`. If true, Mongoose adds `createdAt` and `updatedAt` properties to your schema and manages those properties for you.\n * - [pluginTags](https://mongoosejs.com/docs/guide.html#pluginTags): array of strings - defaults to `undefined`. If set and plugin called with `tags` option, will only apply that plugin to schemas with a matching tag.\n * - [virtuals](https://mongoosejs.com/docs/tutorials/virtuals.html#virtuals-via-schema-options): object - virtuals to define, alias for [`.virtual`](https://mongoosejs.com/docs/api/schema.html#Schema.prototype.virtual())\n * - [collectionOptions]: object with options passed to [`createCollection()`](https://www.mongodb.com/docs/manual/reference/method/db.createCollection/) when calling `Model.createCollection()` or `autoCreate` set to true.\n *\n * #### Options for Nested Schemas:\n *\n * - `excludeIndexes`: bool - defaults to `false`. If `true`, skip building indexes on this schema's paths.\n *\n * #### Note:\n *\n * _When nesting schemas, (`children` in the example above), always declare the child schema first before passing it into its parent._\n *\n * @param {Object|Schema|Array} [definition] Can be one of: object describing schema paths, or schema to copy, or array of objects and schemas\n * @param {Object} [options]\n * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#class-eventemitter\n * @event `init`: Emitted after the schema is compiled into a `Model`.\n * @api public\n */\n\nfunction Schema(obj, options) {\n  if (!(this instanceof Schema)) {\n    return new Schema(obj, options);\n  }\n\n  this.obj = obj;\n  this.paths = {};\n  this.aliases = {};\n  this.subpaths = {};\n  this.virtuals = {};\n  this.singleNestedPaths = {};\n  this.nested = {};\n  this.inherits = {};\n  this.callQueue = [];\n  this._indexes = [];\n  this._searchIndexes = [];\n  this.methods = (options && options.methods) || {};\n  this.methodOptions = {};\n  this.statics = (options && options.statics) || {};\n  this.tree = {};\n  this.query = (options && options.query) || {};\n  this.childSchemas = [];\n  this.plugins = [];\n  // For internal debugging. Do not use this to try to save a schema in MDB.\n  this.$id = ++id;\n  this.mapPaths = [];\n\n  this.s = {\n    hooks: new Kareem()\n  };\n  this.options = this.defaultOptions(options);\n\n  // build paths\n  if (Array.isArray(obj)) {\n    for (const definition of obj) {\n      this.add(definition);\n    }\n  } else if (obj) {\n    this.add(obj);\n  }\n\n  // build virtual paths\n  if (options && options.virtuals) {\n    const virtuals = options.virtuals;\n    const pathNames = Object.keys(virtuals);\n    for (const pathName of pathNames) {\n      const pathOptions = virtuals[pathName].options ? virtuals[pathName].options : undefined;\n      const virtual = this.virtual(pathName, pathOptions);\n\n      if (virtuals[pathName].get) {\n        virtual.get(virtuals[pathName].get);\n      }\n\n      if (virtuals[pathName].set) {\n        virtual.set(virtuals[pathName].set);\n      }\n    }\n  }\n\n  // check if _id's value is a subdocument (gh-2276)\n  const _idSubDoc = obj && obj._id && utils.isObject(obj._id);\n\n  // ensure the documents get an auto _id unless disabled\n  const auto_id = !this.paths['_id'] &&\n      (this.options._id) && !_idSubDoc;\n\n  if (auto_id) {\n    addAutoId(this);\n  }\n\n  this.setupTimestamp(this.options.timestamps);\n}\n\n/**\n * Create virtual properties with alias field\n * @api private\n */\nfunction aliasFields(schema, paths) {\n  for (const path of Object.keys(paths)) {\n    let alias = null;\n    if (paths[path] != null) {\n      alias = paths[path];\n    } else {\n      const options = get(schema.paths[path], 'options');\n      if (options == null) {\n        continue;\n      }\n\n      alias = options.alias;\n    }\n\n    if (!alias) {\n      continue;\n    }\n\n    const prop = schema.paths[path].path;\n    if (Array.isArray(alias)) {\n      for (const a of alias) {\n        if (typeof a !== 'string') {\n          throw new Error('Invalid value for alias option on ' + prop + ', got ' + a);\n        }\n\n        schema.aliases[a] = prop;\n\n        schema.\n          virtual(a).\n          get((function(p) {\n            return function() {\n              if (typeof this.get === 'function') {\n                return this.get(p);\n              }\n              return this[p];\n            };\n          })(prop)).\n          set((function(p) {\n            return function(v) {\n              return this.$set(p, v);\n            };\n          })(prop));\n      }\n\n      continue;\n    }\n\n    if (typeof alias !== 'string') {\n      throw new Error('Invalid value for alias option on ' + prop + ', got ' + alias);\n    }\n\n    schema.aliases[alias] = prop;\n\n    schema.\n      virtual(alias).\n      get((function(p) {\n        return function() {\n          if (typeof this.get === 'function') {\n            return this.get(p);\n          }\n          return this[p];\n        };\n      })(prop)).\n      set((function(p) {\n        return function(v) {\n          return this.$set(p, v);\n        };\n      })(prop));\n  }\n}\n\n/*!\n * Inherit from EventEmitter.\n */\nSchema.prototype = Object.create(EventEmitter.prototype);\nSchema.prototype.constructor = Schema;\nSchema.prototype.instanceOfSchema = true;\n\n/*!\n * ignore\n */\n\nObject.defineProperty(Schema.prototype, '$schemaType', {\n  configurable: false,\n  enumerable: false,\n  writable: true\n});\n\n/**\n * Array of child schemas (from document arrays and single nested subdocs)\n * and their corresponding compiled models. Each element of the array is\n * an object with 2 properties: `schema` and `model`.\n *\n * This property is typically only useful for plugin authors and advanced users.\n * You do not need to interact with this property at all to use mongoose.\n *\n * @api public\n * @property childSchemas\n * @memberOf Schema\n * @instance\n */\n\nObject.defineProperty(Schema.prototype, 'childSchemas', {\n  configurable: false,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * Object containing all virtuals defined on this schema.\n * The objects' keys are the virtual paths and values are instances of `VirtualType`.\n *\n * This property is typically only useful for plugin authors and advanced users.\n * You do not need to interact with this property at all to use mongoose.\n *\n * #### Example:\n *\n *     const schema = new Schema({});\n *     schema.virtual('answer').get(() => 42);\n *\n *     console.log(schema.virtuals); // { answer: VirtualType { path: 'answer', ... } }\n *     console.log(schema.virtuals['answer'].getters[0].call()); // 42\n *\n * @api public\n * @property virtuals\n * @memberOf Schema\n * @instance\n */\n\nObject.defineProperty(Schema.prototype, 'virtuals', {\n  configurable: false,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The original object passed to the schema constructor\n *\n * #### Example:\n *\n *     const schema = new Schema({ a: String }).add({ b: String });\n *     schema.obj; // { a: String }\n *\n * @api public\n * @property obj\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.obj;\n\n/**\n * The paths defined on this schema. The keys are the top-level paths\n * in this schema, and the values are instances of the SchemaType class.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String }, { _id: false });\n *     schema.paths; // { name: SchemaString { ... } }\n *\n *     schema.add({ age: Number });\n *     schema.paths; // { name: SchemaString { ... }, age: SchemaNumber { ... } }\n *\n * @api public\n * @property paths\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.paths;\n\n/**\n * Schema as a tree\n *\n * #### Example:\n *\n *     {\n *         '_id'     : ObjectId\n *       , 'nested'  : {\n *             'key' : String\n *         }\n *     }\n *\n * @api private\n * @property tree\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.tree;\n\n/**\n * Returns a deep copy of the schema\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String });\n *     const clone = schema.clone();\n *     clone === schema; // false\n *     clone.path('name'); // SchemaString { ... }\n *\n * @return {Schema} the cloned schema\n * @api public\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.clone = function() {\n  const s = this._clone();\n\n  // Bubble up `init` for backwards compat\n  s.on('init', v => this.emit('init', v));\n\n  return s;\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._clone = function _clone(Constructor) {\n  Constructor = Constructor || (this.base == null ? Schema : this.base.Schema);\n\n  const s = new Constructor({}, this._userProvidedOptions);\n  s.base = this.base;\n  s.obj = this.obj;\n  s.options = clone(this.options);\n  s.callQueue = this.callQueue.map(function(f) { return f; });\n  s.methods = clone(this.methods);\n  s.methodOptions = clone(this.methodOptions);\n  s.statics = clone(this.statics);\n  s.query = clone(this.query);\n  s.plugins = Array.prototype.slice.call(this.plugins);\n  s._indexes = clone(this._indexes);\n  s._searchIndexes = clone(this._searchIndexes);\n  s.s.hooks = this.s.hooks.clone();\n\n  s.tree = clone(this.tree);\n  s.paths = Object.fromEntries(\n    Object.entries(this.paths).map(([key, value]) => ([key, value.clone()]))\n  );\n  s.nested = clone(this.nested);\n  s.subpaths = clone(this.subpaths);\n  for (const schemaType of Object.values(s.paths)) {\n    if (schemaType.$isSingleNested) {\n      const path = schemaType.path;\n      for (const key of Object.keys(schemaType.schema.paths)) {\n        s.singleNestedPaths[path + '.' + key] = schemaType.schema.paths[key];\n      }\n      for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {\n        s.singleNestedPaths[path + '.' + key] =\n          schemaType.schema.singleNestedPaths[key];\n      }\n      for (const key of Object.keys(schemaType.schema.subpaths)) {\n        s.singleNestedPaths[path + '.' + key] =\n          schemaType.schema.subpaths[key];\n      }\n      for (const key of Object.keys(schemaType.schema.nested)) {\n        s.singleNestedPaths[path + '.' + key] = 'nested';\n      }\n    }\n  }\n  s.childSchemas = gatherChildSchemas(s);\n\n  s.virtuals = clone(this.virtuals);\n  s.$globalPluginsApplied = this.$globalPluginsApplied;\n  s.$isRootDiscriminator = this.$isRootDiscriminator;\n  s.$implicitlyCreated = this.$implicitlyCreated;\n  s.$id = ++id;\n  s.$originalSchemaId = this.$id;\n  s.mapPaths = [].concat(this.mapPaths);\n\n  if (this.discriminatorMapping != null) {\n    s.discriminatorMapping = Object.assign({}, this.discriminatorMapping);\n  }\n  if (this.discriminators != null) {\n    s.discriminators = Object.assign({}, this.discriminators);\n  }\n  if (this._applyDiscriminators != null) {\n    s._applyDiscriminators = new Map(this._applyDiscriminators);\n  }\n\n  s.aliases = Object.assign({}, this.aliases);\n\n  return s;\n};\n\n/**\n * Returns a new schema that has the picked `paths` from this schema.\n *\n * This method is analagous to [Lodash's `pick()` function](https://lodash.com/docs/4.17.15#pick) for Mongoose schemas.\n *\n * #### Example:\n *\n *     const schema = Schema({ name: String, age: Number });\n *     // Creates a new schema with the same `name` path as `schema`,\n *     // but no `age` path.\n *     const newSchema = schema.pick(['name']);\n *\n *     newSchema.path('name'); // SchemaString { ... }\n *     newSchema.path('age'); // undefined\n *\n * @param {String[]} paths List of Paths to pick for the new Schema\n * @param {Object} [options] Options to pass to the new Schema Constructor (same as `new Schema(.., Options)`). Defaults to `this.options` if not set.\n * @return {Schema}\n * @api public\n */\n\nSchema.prototype.pick = function(paths, options) {\n  const newSchema = new Schema({}, options || this.options);\n  if (!Array.isArray(paths)) {\n    throw new MongooseError('Schema#pick() only accepts an array argument, ' +\n      'got \"' + typeof paths + '\"');\n  }\n\n  for (const path of paths) {\n    if (this.nested[path]) {\n      newSchema.add({ [path]: get(this.tree, path) });\n    } else {\n      const schematype = this.path(path);\n      if (schematype == null) {\n        throw new MongooseError('Path `' + path + '` is not in the schema');\n      }\n      newSchema.add({ [path]: schematype });\n    }\n  }\n\n  return newSchema;\n};\n\n/**\n * Returns a new schema that has the `paths` from the original schema, minus the omitted ones.\n *\n * This method is analagous to [Lodash's `omit()` function](https://lodash.com/docs/#omit) for Mongoose schemas.\n *\n * #### Example:\n *\n *     const schema = Schema({ name: String, age: Number });\n *     // Creates a new schema omitting the `age` path\n *     const newSchema = schema.omit(['age']);\n *\n *     newSchema.path('name'); // SchemaString { ... }\n *     newSchema.path('age'); // undefined\n *\n * @param {String[]} paths List of Paths to omit for the new Schema\n * @param {Object} [options] Options to pass to the new Schema Constructor (same as `new Schema(.., Options)`). Defaults to `this.options` if not set.\n * @return {Schema}\n * @api public\n */\n\nSchema.prototype.omit = function(paths, options) {\n  const newSchema = new Schema(this, options || this.options);\n  if (!Array.isArray(paths)) {\n    throw new MongooseError(\n      'Schema#omit() only accepts an array argument, ' +\n        'got \"' +\n        typeof paths +\n        '\"'\n    );\n  }\n\n  newSchema.remove(paths);\n\n  for (const nested in newSchema.singleNestedPaths) {\n    if (paths.includes(nested)) {\n      delete newSchema.singleNestedPaths[nested];\n    }\n  }\n\n  return newSchema;\n};\n\n/**\n * Returns default options for this schema, merged with `options`.\n *\n * @param {Object} [options] Options to overwrite the default options\n * @return {Object} The merged options of `options` and the default options\n * @api private\n */\n\nSchema.prototype.defaultOptions = function(options) {\n  this._userProvidedOptions = options == null ? {} : clone(options);\n  const baseOptions = this.base && this.base.options || {};\n  const strict = 'strict' in baseOptions ? baseOptions.strict : true;\n  const strictQuery = 'strictQuery' in baseOptions ? baseOptions.strictQuery : false;\n  const id = 'id' in baseOptions ? baseOptions.id : true;\n  options = {\n    strict,\n    strictQuery,\n    bufferCommands: true,\n    capped: false, // { size, max, autoIndexId }\n    versionKey: '__v',\n    optimisticConcurrency: false,\n    minimize: true,\n    autoIndex: null,\n    discriminatorKey: '__t',\n    shardKey: null,\n    read: null,\n    validateBeforeSave: true,\n    validateModifiedOnly: false,\n    // the following are only applied at construction time\n    _id: true,\n    id: id,\n    typeKey: 'type',\n    ...options\n  };\n\n  if (options.versionKey && typeof options.versionKey !== 'string') {\n    throw new MongooseError('`versionKey` must be falsy or string, got `' + (typeof options.versionKey) + '`');\n  }\n\n  if (typeof options.read === 'string') {\n    options.read = handleReadPreferenceAliases(options.read);\n  } else if (Array.isArray(options.read) && typeof options.read[0] === 'string') {\n    options.read = {\n      mode: handleReadPreferenceAliases(options.read[0]),\n      tags: options.read[1]\n    };\n  }\n\n  if (options.optimisticConcurrency && !options.versionKey) {\n    throw new MongooseError('Must set `versionKey` if using `optimisticConcurrency`');\n  }\n\n  return options;\n};\n\n/**\n * Inherit a Schema by applying a discriminator on an existing Schema.\n *\n *\n * #### Example:\n *\n *     const eventSchema = new mongoose.Schema({ timestamp: Date }, { discriminatorKey: 'kind' });\n *\n *     const clickedEventSchema = new mongoose.Schema({ element: String }, { discriminatorKey: 'kind' });\n *     const ClickedModel = eventSchema.discriminator('clicked', clickedEventSchema);\n *\n *     const Event = mongoose.model('Event', eventSchema);\n *\n *     Event.discriminators['clicked']; // Model { clicked }\n *\n *     const doc = await Event.create({ kind: 'clicked', element: '#hero' });\n *     doc.element; // '#hero'\n *     doc instanceof ClickedModel; // true\n *\n * @param {String} name the name of the discriminator\n * @param {Schema} schema the discriminated Schema\n * @param {Object} [options] discriminator options\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @param {Boolean} [options.overwriteModels=false] by default, Mongoose does not allow you to define a discriminator with the same name as another discriminator. Set this to allow overwriting discriminators with the same name.\n * @param {Boolean} [options.mergeHooks=true] By default, Mongoose merges the base schema's hooks with the discriminator schema's hooks. Set this option to `false` to make Mongoose use the discriminator schema's hooks instead.\n * @param {Boolean} [options.mergePlugins=true] By default, Mongoose merges the base schema's plugins with the discriminator schema's plugins. Set this option to `false` to make Mongoose use the discriminator schema's plugins instead.\n * @return {Schema} the Schema instance\n * @api public\n */\nSchema.prototype.discriminator = function(name, schema, options) {\n  this._applyDiscriminators = this._applyDiscriminators || new Map();\n  this._applyDiscriminators.set(name, { schema, options });\n\n  return this;\n};\n\n/**\n * Adds key path / schema type pairs to this schema.\n *\n * #### Example:\n *\n *     const ToySchema = new Schema();\n *     ToySchema.add({ name: 'string', color: 'string', price: 'number' });\n *\n *     const TurboManSchema = new Schema();\n *     // You can also `add()` another schema and copy over all paths, virtuals,\n *     // getters, setters, indexes, methods, and statics.\n *     TurboManSchema.add(ToySchema).add({ year: Number });\n *\n * @param {Object|Schema} obj plain object with paths to add, or another schema\n * @param {String} [prefix] path to prefix the newly added paths with\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.add = function add(obj, prefix) {\n  if (obj instanceof Schema || (obj != null && obj.instanceOfSchema)) {\n    merge(this, obj);\n\n    return this;\n  }\n\n  // Special case: setting top-level `_id` to false should convert to disabling\n  // the `_id` option. This behavior never worked before 5.4.11 but numerous\n  // codebases use it (see gh-7516, gh-7512).\n  if (obj._id === false && prefix == null) {\n    this.options._id = false;\n  }\n\n  prefix = prefix || '';\n  // avoid prototype pollution\n  if (prefix === '__proto__.' || prefix === 'constructor.' || prefix === 'prototype.') {\n    return this;\n  }\n\n  const keys = Object.keys(obj);\n  const typeKey = this.options.typeKey;\n  for (const key of keys) {\n    if (utils.specialProperties.has(key)) {\n      continue;\n    }\n\n    const fullPath = prefix + key;\n    const val = obj[key];\n\n    if (val == null) {\n      throw new TypeError('Invalid value for schema path `' + fullPath +\n        '`, got value \"' + val + '\"');\n    }\n    // Retain `_id: false` but don't set it as a path, re: gh-8274.\n    if (key === '_id' && val === false) {\n      continue;\n    }\n    // Deprecate setting schema paths to primitive types (gh-7558)\n    let isMongooseTypeString = false;\n    if (typeof val === 'string') {\n      // Handle the case in which the type is specified as a string (eg. 'date', 'oid', ...)\n      const MongooseTypes = this.base != null ? this.base.Schema.Types : Schema.Types;\n      const upperVal = val.charAt(0).toUpperCase() + val.substring(1);\n      isMongooseTypeString = MongooseTypes[upperVal] != null;\n    }\n    if (\n      key !== '_id' &&\n      ((typeof val !== 'object' && typeof val !== 'function' && !isMongooseTypeString) ||\n      val == null)\n    ) {\n      throw new TypeError(`Invalid schema configuration: \\`${val}\\` is not ` +\n        `a valid type at path \\`${key}\\`. See ` +\n        'https://bit.ly/mongoose-schematypes for a list of valid schema types.');\n    }\n    if (val instanceof VirtualType || (val.constructor && val.constructor.name || null) === 'VirtualType') {\n      this.virtual(val);\n      continue;\n    }\n\n    if (Array.isArray(val) && val.length === 1 && val[0] == null) {\n      throw new TypeError('Invalid value for schema Array path `' + fullPath +\n        '`, got value \"' + val[0] + '\"');\n    }\n\n    if (!(isPOJO(val) || val instanceof SchemaTypeOptions)) {\n      // Special-case: Non-options definitely a path so leaf at this node\n      // Examples: Schema instances, SchemaType instances\n      if (prefix) {\n        this.nested[prefix.substring(0, prefix.length - 1)] = true;\n      }\n      this.path(prefix + key, val);\n      if (val[0] != null && !(val[0].instanceOfSchema) && utils.isPOJO(val[0].discriminators)) {\n        const schemaType = this.path(prefix + key);\n        for (const key in val[0].discriminators) {\n          schemaType.discriminator(key, val[0].discriminators[key]);\n        }\n      }\n    } else if (Object.keys(val).length < 1) {\n      // Special-case: {} always interpreted as Mixed path so leaf at this node\n      if (prefix) {\n        this.nested[prefix.substring(0, prefix.length - 1)] = true;\n      }\n      this.path(fullPath, val); // mixed type\n    } else if (!val[typeKey] || (typeKey === 'type' && isPOJO(val.type) && val.type.type)) {\n      // Special-case: POJO with no bona-fide type key - interpret as tree of deep paths so recurse\n      // nested object `{ last: { name: String } }`. Avoid functions with `.type` re: #10807 because\n      // NestJS sometimes adds `Date.type`.\n      this.nested[fullPath] = true;\n      this.add(val, fullPath + '.');\n    } else {\n      // There IS a bona-fide type key that may also be a POJO\n      const _typeDef = val[typeKey];\n      if (isPOJO(_typeDef) && Object.keys(_typeDef).length > 0) {\n        // If a POJO is the value of a type key, make it a subdocument\n        if (prefix) {\n          this.nested[prefix.substring(0, prefix.length - 1)] = true;\n        }\n\n        const childSchemaOptions = {};\n        if (this._userProvidedOptions.typeKey) {\n          childSchemaOptions.typeKey = this._userProvidedOptions.typeKey;\n        }\n        // propagate 'strict' option to child schema\n        if (this._userProvidedOptions.strict != null) {\n          childSchemaOptions.strict = this._userProvidedOptions.strict;\n        }\n        if (this._userProvidedOptions.toObject != null) {\n          childSchemaOptions.toObject = utils.omit(this._userProvidedOptions.toObject, ['transform']);\n        }\n        if (this._userProvidedOptions.toJSON != null) {\n          childSchemaOptions.toJSON = utils.omit(this._userProvidedOptions.toJSON, ['transform']);\n        }\n\n        const _schema = new Schema(_typeDef, childSchemaOptions);\n        _schema.$implicitlyCreated = true;\n        const schemaWrappedPath = Object.assign({}, val, { [typeKey]: _schema });\n        this.path(prefix + key, schemaWrappedPath);\n      } else {\n        // Either the type is non-POJO or we interpret it as Mixed anyway\n        if (prefix) {\n          this.nested[prefix.substring(0, prefix.length - 1)] = true;\n        }\n        this.path(prefix + key, val);\n        if (val != null && !(val.instanceOfSchema) && utils.isPOJO(val.discriminators)) {\n          const schemaType = this.path(prefix + key);\n          for (const key in val.discriminators) {\n            schemaType.discriminator(key, val.discriminators[key]);\n          }\n        }\n      }\n    }\n  }\n\n  const aliasObj = Object.fromEntries(\n    Object.entries(obj).map(([key]) => ([prefix + key, null]))\n  );\n  aliasFields(this, aliasObj);\n  return this;\n};\n\n/**\n * Add an alias for `path`. This means getting or setting the `alias`\n * is equivalent to getting or setting the `path`.\n *\n * #### Example:\n *\n *     const toySchema = new Schema({ n: String });\n *\n *     // Make 'name' an alias for 'n'\n *     toySchema.alias('n', 'name');\n *\n *     const Toy = mongoose.model('Toy', toySchema);\n *     const turboMan = new Toy({ n: 'Turbo Man' });\n *\n *     turboMan.name; // 'Turbo Man'\n *     turboMan.n; // 'Turbo Man'\n *\n *     turboMan.name = 'Turbo Man Action Figure';\n *     turboMan.n; // 'Turbo Man Action Figure'\n *\n *     await turboMan.save(); // Saves { _id: ..., n: 'Turbo Man Action Figure' }\n *\n *\n * @param {String} path real path to alias\n * @param {String|String[]} alias the path(s) to use as an alias for `path`\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.alias = function alias(path, alias) {\n  aliasFields(this, { [path]: alias });\n  return this;\n};\n\n/**\n * Remove an index by name or index specification.\n *\n * removeIndex only removes indexes from your schema object. Does **not** affect the indexes\n * in MongoDB.\n *\n * #### Example:\n *\n *     const ToySchema = new Schema({ name: String, color: String, price: Number });\n *\n *     // Add a new index on { name, color }\n *     ToySchema.index({ name: 1, color: 1 });\n *\n *     // Remove index on { name, color }\n *     // Keep in mind that order matters! `removeIndex({ color: 1, name: 1 })` won't remove the index\n *     ToySchema.removeIndex({ name: 1, color: 1 });\n *\n *     // Add an index with a custom name\n *     ToySchema.index({ color: 1 }, { name: 'my custom index name' });\n *     // Remove index by name\n *     ToySchema.removeIndex('my custom index name');\n *\n * @param {Object|string} index name or index specification\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.removeIndex = function removeIndex(index) {\n  if (arguments.length > 1) {\n    throw new Error('removeIndex() takes only 1 argument');\n  }\n\n  if (typeof index !== 'object' && typeof index !== 'string') {\n    throw new Error('removeIndex() may only take either an object or a string as an argument');\n  }\n\n  if (typeof index === 'object') {\n    for (let i = this._indexes.length - 1; i >= 0; --i) {\n      if (util.isDeepStrictEqual(this._indexes[i][0], index)) {\n        this._indexes.splice(i, 1);\n      }\n    }\n  } else {\n    for (let i = this._indexes.length - 1; i >= 0; --i) {\n      if (this._indexes[i][1] != null && this._indexes[i][1].name === index) {\n        this._indexes.splice(i, 1);\n      }\n    }\n  }\n\n  return this;\n};\n\n/**\n * Remove all indexes from this schema.\n *\n * clearIndexes only removes indexes from your schema object. Does **not** affect the indexes\n * in MongoDB.\n *\n * #### Example:\n *\n *     const ToySchema = new Schema({ name: String, color: String, price: Number });\n *     ToySchema.index({ name: 1 });\n *     ToySchema.index({ color: 1 });\n *\n *     // Remove all indexes on this schema\n *     ToySchema.clearIndexes();\n *\n *     ToySchema.indexes(); // []\n *\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.clearIndexes = function clearIndexes() {\n  this._indexes.length = 0;\n\n  return this;\n};\n\n/**\n * Add an [Atlas search index](https://www.mongodb.com/docs/atlas/atlas-search/create-index/) that Mongoose will create using `Model.createSearchIndex()`.\n * This function only works when connected to MongoDB Atlas.\n *\n * #### Example:\n *\n *     const ToySchema = new Schema({ name: String, color: String, price: Number });\n *     ToySchema.searchIndex({ name: 'test', definition: { mappings: { dynamic: true } } });\n *\n * @param {Object} description index options, including `name` and `definition`\n * @param {String} description.name\n * @param {Object} description.definition\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.searchIndex = function searchIndex(description) {\n  this._searchIndexes.push(description);\n\n  return this;\n};\n\n/**\n * Reserved document keys.\n *\n * Keys in this object are names that are warned in schema declarations\n * because they have the potential to break Mongoose/ Mongoose plugins functionality. If you create a schema\n * using `new Schema()` with one of these property names, Mongoose will log a warning.\n *\n * - _posts\n * - _pres\n * - collection\n  * - emit\n * - errors\n * - get\n * - init\n * - isModified\n * - isNew\n * - listeners\n * - modelName\n * - on\n * - once\n * - populated\n * - prototype\n * - remove\n * - removeListener\n * - save\n * - schema\n * - toObject\n * - validate\n *\n * _NOTE:_ Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on.\n *\n *      const schema = new Schema(..);\n *      schema.methods.init = function () {} // potentially breaking\n *\n * @property reserved\n * @memberOf Schema\n * @static\n */\n\nSchema.reserved = Object.create(null);\nSchema.prototype.reserved = Schema.reserved;\n\nconst reserved = Schema.reserved;\n// Core object\nreserved['prototype'] =\n// EventEmitter\nreserved.emit =\nreserved.listeners =\nreserved.removeListener =\n\n// document properties and functions\nreserved.collection =\nreserved.errors =\nreserved.get =\nreserved.init =\nreserved.isModified =\nreserved.isNew =\nreserved.populated =\nreserved.remove =\nreserved.save =\nreserved.toObject =\nreserved.validate = 1;\nreserved.collection = 1;\n\n/**\n * Gets/sets schema paths.\n *\n * Sets a path (if arity 2)\n * Gets a path (if arity 1)\n *\n * #### Example:\n *\n *     schema.path('name') // returns a SchemaType\n *     schema.path('name', Number) // changes the schemaType of `name` to Number\n *\n * @param {String} path The name of the Path to get / set\n * @param {Object} [obj] The Type to set the path to, if provided the path will be SET, otherwise the path will be GET\n * @api public\n */\n\nSchema.prototype.path = function(path, obj) {\n  if (obj === undefined) {\n    if (this.paths[path] != null) {\n      return this.paths[path];\n    }\n    // Convert to '.$' to check subpaths re: gh-6405\n    const cleanPath = _pathToPositionalSyntax(path);\n    let schematype = _getPath(this, path, cleanPath);\n    if (schematype != null) {\n      return schematype;\n    }\n\n    // Look for maps\n    const mapPath = getMapPath(this, path);\n    if (mapPath != null) {\n      return mapPath;\n    }\n\n    // Look if a parent of this path is mixed\n    schematype = this.hasMixedParent(cleanPath);\n    if (schematype != null) {\n      return schematype;\n    }\n\n    // subpaths?\n    return hasNumericSubpathRegex.test(path)\n      ? getPositionalPath(this, path, cleanPath)\n      : undefined;\n  }\n\n  // some path names conflict with document methods\n  const firstPieceOfPath = path.split('.')[0];\n  if (reserved[firstPieceOfPath] && !this.options.suppressReservedKeysWarning) {\n    const errorMessage = `\\`${firstPieceOfPath}\\` is a reserved schema pathname and may break some functionality. ` +\n      'You are allowed to use it, but use at your own risk. ' +\n      'To disable this warning pass `suppressReservedKeysWarning` as a schema option.';\n\n    utils.warn(errorMessage);\n  }\n\n  if (typeof obj === 'object' && utils.hasUserDefinedProperty(obj, 'ref')) {\n    validateRef(obj.ref, path);\n  }\n\n  // update the tree\n  const subpaths = path.split(/\\./);\n  const last = subpaths.pop();\n  let branch = this.tree;\n  let fullPath = '';\n\n  for (const sub of subpaths) {\n    if (utils.specialProperties.has(sub)) {\n      throw new Error('Cannot set special property `' + sub + '` on a schema');\n    }\n    fullPath = fullPath += (fullPath.length > 0 ? '.' : '') + sub;\n    if (!branch[sub]) {\n      this.nested[fullPath] = true;\n      branch[sub] = {};\n    }\n    if (typeof branch[sub] !== 'object') {\n      const msg = 'Cannot set nested path `' + path + '`. '\n          + 'Parent path `'\n          + fullPath\n          + '` already set to type ' + branch[sub].name\n          + '.';\n      throw new Error(msg);\n    }\n    branch = branch[sub];\n  }\n\n  branch[last] = clone(obj);\n\n  this.paths[path] = this.interpretAsType(path, obj, this.options);\n  const schemaType = this.paths[path];\n\n  if (schemaType.$isSchemaMap) {\n    // Maps can have arbitrary keys, so `$*` is internal shorthand for \"any key\"\n    // The '$' is to imply this path should never be stored in MongoDB so we\n    // can easily build a regexp out of this path, and '*' to imply \"any key.\"\n    const mapPath = path + '.$*';\n\n    this.paths[mapPath] = schemaType.$__schemaType;\n    this.mapPaths.push(this.paths[mapPath]);\n  }\n\n  if (schemaType.$isSingleNested) {\n    for (const key of Object.keys(schemaType.schema.paths)) {\n      this.singleNestedPaths[path + '.' + key] = schemaType.schema.paths[key];\n    }\n    for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {\n      this.singleNestedPaths[path + '.' + key] =\n        schemaType.schema.singleNestedPaths[key];\n    }\n    for (const key of Object.keys(schemaType.schema.subpaths)) {\n      this.singleNestedPaths[path + '.' + key] =\n        schemaType.schema.subpaths[key];\n    }\n    for (const key of Object.keys(schemaType.schema.nested)) {\n      this.singleNestedPaths[path + '.' + key] = 'nested';\n    }\n\n    Object.defineProperty(schemaType.schema, 'base', {\n      configurable: true,\n      enumerable: false,\n      writable: false,\n      value: this.base\n    });\n\n    schemaType.caster.base = this.base;\n    this.childSchemas.push({\n      schema: schemaType.schema,\n      model: schemaType.caster\n    });\n  } else if (schemaType.$isMongooseDocumentArray) {\n    Object.defineProperty(schemaType.schema, 'base', {\n      configurable: true,\n      enumerable: false,\n      writable: false,\n      value: this.base\n    });\n\n    schemaType.casterConstructor.base = this.base;\n    this.childSchemas.push({\n      schema: schemaType.schema,\n      model: schemaType.casterConstructor\n    });\n  }\n\n  if (schemaType.$isMongooseArray && schemaType.caster instanceof SchemaType) {\n    let arrayPath = path;\n    let _schemaType = schemaType;\n\n    const toAdd = [];\n    while (_schemaType.$isMongooseArray) {\n      arrayPath = arrayPath + '.$';\n\n      // Skip arrays of document arrays\n      if (_schemaType.$isMongooseDocumentArray) {\n        _schemaType.$embeddedSchemaType._arrayPath = arrayPath;\n        _schemaType.$embeddedSchemaType._arrayParentPath = path;\n        _schemaType = _schemaType.$embeddedSchemaType;\n      } else {\n        _schemaType.caster._arrayPath = arrayPath;\n        _schemaType.caster._arrayParentPath = path;\n        _schemaType = _schemaType.caster;\n      }\n\n      this.subpaths[arrayPath] = _schemaType;\n    }\n\n    for (const _schemaType of toAdd) {\n      this.subpaths[_schemaType.path] = _schemaType;\n    }\n  }\n\n  if (schemaType.$isMongooseDocumentArray) {\n    for (const key of Object.keys(schemaType.schema.paths)) {\n      const _schemaType = schemaType.schema.paths[key];\n      this.subpaths[path + '.' + key] = _schemaType;\n      if (typeof _schemaType === 'object' && _schemaType != null && _schemaType.$parentSchemaDocArray == null) {\n        _schemaType.$parentSchemaDocArray = schemaType;\n      }\n    }\n    for (const key of Object.keys(schemaType.schema.subpaths)) {\n      const _schemaType = schemaType.schema.subpaths[key];\n      this.subpaths[path + '.' + key] = _schemaType;\n      if (typeof _schemaType === 'object' && _schemaType != null && _schemaType.$parentSchemaDocArray == null) {\n        _schemaType.$parentSchemaDocArray = schemaType;\n      }\n    }\n    for (const key of Object.keys(schemaType.schema.singleNestedPaths)) {\n      const _schemaType = schemaType.schema.singleNestedPaths[key];\n      this.subpaths[path + '.' + key] = _schemaType;\n      if (typeof _schemaType === 'object' && _schemaType != null && _schemaType.$parentSchemaDocArray == null) {\n        _schemaType.$parentSchemaDocArray = schemaType;\n      }\n    }\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction gatherChildSchemas(schema) {\n  const childSchemas = [];\n\n  for (const path of Object.keys(schema.paths)) {\n    const schematype = schema.paths[path];\n    if (schematype.$isMongooseDocumentArray || schematype.$isSingleNested) {\n      childSchemas.push({ schema: schematype.schema, model: schematype.caster });\n    }\n  }\n\n  return childSchemas;\n}\n\n/*!\n * ignore\n */\n\nfunction _getPath(schema, path, cleanPath) {\n  if (schema.paths.hasOwnProperty(path)) {\n    return schema.paths[path];\n  }\n  if (schema.subpaths.hasOwnProperty(cleanPath)) {\n    const subpath = schema.subpaths[cleanPath];\n    if (subpath === 'nested') {\n      return undefined;\n    }\n    return subpath;\n  }\n  if (schema.singleNestedPaths.hasOwnProperty(cleanPath) && typeof schema.singleNestedPaths[cleanPath] === 'object') {\n    const singleNestedPath = schema.singleNestedPaths[cleanPath];\n    if (singleNestedPath === 'nested') {\n      return undefined;\n    }\n    return singleNestedPath;\n  }\n\n  return null;\n}\n\n/*!\n * ignore\n */\n\nfunction _pathToPositionalSyntax(path) {\n  if (!/\\.\\d+/.test(path)) {\n    return path;\n  }\n  return path.replace(/\\.\\d+\\./g, '.$.').replace(/\\.\\d+$/, '.$');\n}\n\n/*!\n * ignore\n */\n\nfunction getMapPath(schema, path) {\n  if (schema.mapPaths.length === 0) {\n    return null;\n  }\n  for (const val of schema.mapPaths) {\n    const _path = val.path;\n    const re = new RegExp('^' + _path.replace(/\\.\\$\\*/g, '\\\\.[^.]+') + '$');\n    if (re.test(path)) {\n      return schema.paths[_path];\n    }\n  }\n\n  return null;\n}\n\n/**\n * The Mongoose instance this schema is associated with\n *\n * @property base\n * @api private\n */\n\nObject.defineProperty(Schema.prototype, 'base', {\n  configurable: true,\n  enumerable: false,\n  writable: true,\n  value: null\n});\n\n/**\n * Converts type arguments into Mongoose Types.\n *\n * @param {String} path\n * @param {Object} obj constructor\n * @param {Object} options\n * @api private\n */\n\nSchema.prototype.interpretAsType = function(path, obj, options) {\n  if (obj instanceof SchemaType) {\n    if (obj.path === path) {\n      return obj;\n    }\n    const clone = obj.clone();\n    clone.path = path;\n    return clone;\n  }\n\n\n  // If this schema has an associated Mongoose object, use the Mongoose object's\n  // copy of SchemaTypes re: gh-7158 gh-6933\n  const MongooseTypes = this.base != null ? this.base.Schema.Types : Schema.Types;\n  const Types = this.base != null ? this.base.Types : __webpack_require__(/*! ./types */ \"../backend/node_modules/mongoose/lib/types/index.js\");\n\n  if (!utils.isPOJO(obj) && !(obj instanceof SchemaTypeOptions)) {\n    const constructorName = utils.getFunctionName(obj.constructor);\n    if (constructorName !== 'Object') {\n      const oldObj = obj;\n      obj = {};\n      obj[options.typeKey] = oldObj;\n    }\n  }\n\n  // Get the type making sure to allow keys named \"type\"\n  // and default to mixed if not specified.\n  // { type: { type: String, default: 'freshcut' } }\n  let type = obj[options.typeKey] && (obj[options.typeKey] instanceof Function || options.typeKey !== 'type' || !obj.type.type)\n    ? obj[options.typeKey]\n    : {};\n  let name;\n\n  if (utils.isPOJO(type) || type === 'mixed') {\n    return new MongooseTypes.Mixed(path, obj);\n  }\n\n  if (Array.isArray(type) || type === Array || type === 'array' || type === MongooseTypes.Array) {\n    // if it was specified through { type } look for `cast`\n    let cast = (type === Array || type === 'array')\n      ? obj.cast || obj.of\n      : type[0];\n\n    // new Schema({ path: [new Schema({ ... })] })\n    if (cast && cast.instanceOfSchema) {\n      if (!(cast instanceof Schema)) {\n        if (this.options._isMerging) {\n          cast = new Schema(cast);\n        } else {\n          throw new TypeError('Schema for array path `' + path +\n            '` is from a different copy of the Mongoose module. ' +\n            'Please make sure you\\'re using the same version ' +\n            'of Mongoose everywhere with `npm list mongoose`. If you are still ' +\n            'getting this error, please add `new Schema()` around the path: ' +\n            `${path}: new Schema(...)`);\n        }\n      }\n      return new MongooseTypes.DocumentArray(path, cast, obj);\n    }\n    if (cast &&\n        cast[options.typeKey] &&\n        cast[options.typeKey].instanceOfSchema) {\n      if (!(cast[options.typeKey] instanceof Schema)) {\n        if (this.options._isMerging) {\n          cast[options.typeKey] = new Schema(cast[options.typeKey]);\n        } else {\n          throw new TypeError('Schema for array path `' + path +\n            '` is from a different copy of the Mongoose module. ' +\n            'Please make sure you\\'re using the same version ' +\n            'of Mongoose everywhere with `npm list mongoose`. If you are still ' +\n            'getting this error, please add `new Schema()` around the path: ' +\n            `${path}: new Schema(...)`);\n        }\n      }\n      return new MongooseTypes.DocumentArray(path, cast[options.typeKey], obj, cast);\n    }\n    if (typeof cast !== 'undefined') {\n      if (Array.isArray(cast) || cast.type === Array || cast.type == 'Array') {\n        if (cast && cast.type == 'Array') {\n          cast.type = Array;\n        }\n        return new MongooseTypes.Array(path, this.interpretAsType(path, cast, options), obj);\n      }\n    }\n\n    // Handle both `new Schema({ arr: [{ subpath: String }] })` and `new Schema({ arr: [{ type: { subpath: string } }] })`\n    const castFromTypeKey = (cast != null && cast[options.typeKey] && (options.typeKey !== 'type' || !cast.type.type)) ?\n      cast[options.typeKey] :\n      cast;\n    if (typeof cast === 'string') {\n      cast = MongooseTypes[cast.charAt(0).toUpperCase() + cast.substring(1)];\n    } else if (utils.isPOJO(castFromTypeKey)) {\n      if (Object.keys(castFromTypeKey).length) {\n        // The `minimize` and `typeKey` options propagate to child schemas\n        // declared inline, like `{ arr: [{ val: { $type: String } }] }`.\n        // See gh-3560\n        const childSchemaOptions = { minimize: options.minimize };\n        if (options.typeKey) {\n          childSchemaOptions.typeKey = options.typeKey;\n        }\n        // propagate 'strict' option to child schema\n        if (options.hasOwnProperty('strict')) {\n          childSchemaOptions.strict = options.strict;\n        }\n        if (options.hasOwnProperty('strictQuery')) {\n          childSchemaOptions.strictQuery = options.strictQuery;\n        }\n        if (options.hasOwnProperty('toObject')) {\n          childSchemaOptions.toObject = utils.omit(options.toObject, ['transform']);\n        }\n        if (options.hasOwnProperty('toJSON')) {\n          childSchemaOptions.toJSON = utils.omit(options.toJSON, ['transform']);\n        }\n\n        if (this._userProvidedOptions.hasOwnProperty('_id')) {\n          childSchemaOptions._id = this._userProvidedOptions._id;\n        } else if (Schema.Types.DocumentArray.defaultOptions._id != null) {\n          childSchemaOptions._id = Schema.Types.DocumentArray.defaultOptions._id;\n        }\n\n        const childSchema = new Schema(castFromTypeKey, childSchemaOptions);\n        childSchema.$implicitlyCreated = true;\n        return new MongooseTypes.DocumentArray(path, childSchema, obj);\n      } else {\n        // Special case: empty object becomes mixed\n        return new MongooseTypes.Array(path, MongooseTypes.Mixed, obj);\n      }\n    }\n\n    if (cast) {\n      type = cast[options.typeKey] && (options.typeKey !== 'type' || !cast.type.type)\n        ? cast[options.typeKey]\n        : cast;\n      if (Array.isArray(type)) {\n        return new MongooseTypes.Array(path, this.interpretAsType(path, type, options), obj);\n      }\n\n      name = typeof type === 'string'\n        ? type\n        : type.schemaName || utils.getFunctionName(type);\n\n      // For Jest 26+, see #10296\n      if (name === 'ClockDate') {\n        name = 'Date';\n      }\n\n      if (name === void 0) {\n        throw new TypeError('Invalid schema configuration: ' +\n          `Could not determine the embedded type for array \\`${path}\\`. ` +\n          'See https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.');\n      }\n      if (!MongooseTypes.hasOwnProperty(name)) {\n        throw new TypeError('Invalid schema configuration: ' +\n          `\\`${name}\\` is not a valid type within the array \\`${path}\\`.` +\n          'See https://bit.ly/mongoose-schematypes for a list of valid schema types.');\n      }\n    }\n\n    return new MongooseTypes.Array(path, cast || MongooseTypes.Mixed, obj, options);\n  }\n\n  if (type && type.instanceOfSchema) {\n    return new MongooseTypes.Subdocument(type, path, obj);\n  }\n\n  if (Buffer.isBuffer(type)) {\n    name = 'Buffer';\n  } else if (typeof type === 'function' || typeof type === 'object') {\n    name = type.schemaName || utils.getFunctionName(type);\n  } else if (type === Types.ObjectId) {\n    name = 'ObjectId';\n  } else if (type === Types.Decimal128) {\n    name = 'Decimal128';\n  } else {\n    name = type == null ? '' + type : type.toString();\n  }\n\n  if (name) {\n    name = name.charAt(0).toUpperCase() + name.substring(1);\n  }\n  // Special case re: gh-7049 because the bson `ObjectID` class' capitalization\n  // doesn't line up with Mongoose's.\n  if (name === 'ObjectID') {\n    name = 'ObjectId';\n  }\n  // For Jest 26+, see #10296\n  if (name === 'ClockDate') {\n    name = 'Date';\n  }\n\n  if (name === void 0) {\n    throw new TypeError(`Invalid schema configuration: \\`${path}\\` schematype definition is ` +\n      'invalid. See ' +\n      'https://mongoosejs.com/docs/guide.html#definition for more info on supported schema syntaxes.');\n  }\n  if (MongooseTypes[name] == null) {\n    throw new TypeError(`Invalid schema configuration: \\`${name}\\` is not ` +\n      `a valid type at path \\`${path}\\`. See ` +\n      'https://bit.ly/mongoose-schematypes for a list of valid schema types.');\n  }\n\n  const schemaType = new MongooseTypes[name](path, obj);\n\n  if (schemaType.$isSchemaMap) {\n    createMapNestedSchemaType(this, schemaType, path, obj, options);\n  }\n\n  return schemaType;\n};\n\n/*!\n * ignore\n */\n\nfunction createMapNestedSchemaType(schema, schemaType, path, obj, options) {\n  const mapPath = path + '.$*';\n  let _mapType = { type: {} };\n  if (utils.hasUserDefinedProperty(obj, 'of')) {\n    const isInlineSchema = utils.isPOJO(obj.of) &&\n      Object.keys(obj.of).length > 0 &&\n      !utils.hasUserDefinedProperty(obj.of, schema.options.typeKey);\n    if (isInlineSchema) {\n      _mapType = { [schema.options.typeKey]: new Schema(obj.of) };\n    } else if (utils.isPOJO(obj.of)) {\n      _mapType = Object.assign({}, obj.of);\n    } else {\n      _mapType = { [schema.options.typeKey]: obj.of };\n    }\n\n    if (_mapType[schema.options.typeKey] && _mapType[schema.options.typeKey].instanceOfSchema) {\n      const subdocumentSchema = _mapType[schema.options.typeKey];\n      subdocumentSchema.eachPath((subpath, type) => {\n        if (type.options.select === true || type.options.select === false) {\n          throw new MongooseError('Cannot use schema-level projections (`select: true` or `select: false`) within maps at path \"' + path + '.' + subpath + '\"');\n        }\n      });\n    }\n\n    if (utils.hasUserDefinedProperty(obj, 'ref')) {\n      _mapType.ref = obj.ref;\n    }\n  }\n  schemaType.$__schemaType = schema.interpretAsType(mapPath, _mapType, options);\n}\n\n/**\n * Iterates the schemas paths similar to Array#forEach.\n *\n * The callback is passed the pathname and the schemaType instance.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({ name: String, registeredAt: Date });\n *     userSchema.eachPath((pathname, schematype) => {\n *       // Prints twice:\n *       // name SchemaString { ... }\n *       // registeredAt SchemaDate { ... }\n *       console.log(pathname, schematype);\n *     });\n *\n * @param {Function} fn callback function\n * @return {Schema} this\n * @api public\n */\n\nSchema.prototype.eachPath = function(fn) {\n  const keys = Object.keys(this.paths);\n  const len = keys.length;\n\n  for (let i = 0; i < len; ++i) {\n    fn(keys[i], this.paths[keys[i]]);\n  }\n\n  return this;\n};\n\n/**\n * Returns an Array of path strings that are required by this schema.\n *\n * #### Example:\n *\n *     const s = new Schema({\n *       name: { type: String, required: true },\n *       age: { type: String, required: true },\n *       notes: String\n *     });\n *     s.requiredPaths(); // [ 'age', 'name' ]\n *\n * @api public\n * @param {Boolean} invalidate Refresh the cache\n * @return {Array}\n */\n\nSchema.prototype.requiredPaths = function requiredPaths(invalidate) {\n  if (this._requiredpaths && !invalidate) {\n    return this._requiredpaths;\n  }\n\n  const paths = Object.keys(this.paths);\n  let i = paths.length;\n  const ret = [];\n\n  while (i--) {\n    const path = paths[i];\n    if (this.paths[path].isRequired) {\n      ret.push(path);\n    }\n  }\n  this._requiredpaths = ret;\n  return this._requiredpaths;\n};\n\n/**\n * Returns indexes from fields and schema-level indexes (cached).\n *\n * @api private\n * @return {Array}\n */\n\nSchema.prototype.indexedPaths = function indexedPaths() {\n  if (this._indexedpaths) {\n    return this._indexedpaths;\n  }\n  this._indexedpaths = this.indexes();\n  return this._indexedpaths;\n};\n\n/**\n * Returns the pathType of `path` for this schema.\n *\n * Given a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: String, nested: { foo: String } });\n *     s.virtual('foo').get(() => 42);\n *     s.pathType('name'); // \"real\"\n *     s.pathType('nested'); // \"nested\"\n *     s.pathType('foo'); // \"virtual\"\n *     s.pathType('fail'); // \"adhocOrUndefined\"\n *\n * @param {String} path\n * @return {String}\n * @api public\n */\n\nSchema.prototype.pathType = function(path) {\n  if (this.paths.hasOwnProperty(path)) {\n    return 'real';\n  }\n  if (this.virtuals.hasOwnProperty(path)) {\n    return 'virtual';\n  }\n  if (this.nested.hasOwnProperty(path)) {\n    return 'nested';\n  }\n\n  // Convert to '.$' to check subpaths re: gh-6405\n  const cleanPath = _pathToPositionalSyntax(path);\n\n  if (this.subpaths.hasOwnProperty(cleanPath) || this.subpaths.hasOwnProperty(path)) {\n    return 'real';\n  }\n\n  const singleNestedPath = this.singleNestedPaths.hasOwnProperty(cleanPath) || this.singleNestedPaths.hasOwnProperty(path);\n  if (singleNestedPath) {\n    return singleNestedPath === 'nested' ? 'nested' : 'real';\n  }\n\n  // Look for maps\n  const mapPath = getMapPath(this, path);\n  if (mapPath != null) {\n    return 'real';\n  }\n\n  if (/\\.\\d+\\.|\\.\\d+$/.test(path)) {\n    return getPositionalPathType(this, path, cleanPath);\n  }\n  return 'adhocOrUndefined';\n};\n\n/**\n * Returns true iff this path is a child of a mixed schema.\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\nSchema.prototype.hasMixedParent = function(path) {\n  const subpaths = path.split(/\\./g);\n  path = '';\n  for (let i = 0; i < subpaths.length; ++i) {\n    path = i > 0 ? path + '.' + subpaths[i] : subpaths[i];\n    if (this.paths.hasOwnProperty(path) &&\n        this.paths[path] instanceof MongooseTypes.Mixed) {\n      return this.paths[path];\n    }\n  }\n\n  return null;\n};\n\n/**\n * Setup updatedAt and createdAt timestamps to documents if enabled\n *\n * @param {Boolean|Object} timestamps timestamps options\n * @api private\n */\nSchema.prototype.setupTimestamp = function(timestamps) {\n  return setupTimestamps(this, timestamps);\n};\n\n/**\n * ignore. Deprecated re: #6405\n * @param {Any} self\n * @param {String} path\n * @api private\n */\n\nfunction getPositionalPathType(self, path, cleanPath) {\n  const subpaths = path.split(/\\.(\\d+)\\.|\\.(\\d+)$/).filter(Boolean);\n  if (subpaths.length < 2) {\n    return self.paths.hasOwnProperty(subpaths[0]) ?\n      self.paths[subpaths[0]] :\n      'adhocOrUndefined';\n  }\n\n  let val = self.path(subpaths[0]);\n  let isNested = false;\n  if (!val) {\n    return 'adhocOrUndefined';\n  }\n\n  const last = subpaths.length - 1;\n\n  for (let i = 1; i < subpaths.length; ++i) {\n    isNested = false;\n    const subpath = subpaths[i];\n\n    if (i === last && val && !/\\D/.test(subpath)) {\n      if (val.$isMongooseDocumentArray) {\n        val = val.$embeddedSchemaType;\n      } else if (val instanceof MongooseTypes.Array) {\n        // StringSchema, NumberSchema, etc\n        val = val.caster;\n      } else {\n        val = undefined;\n      }\n      break;\n    }\n\n    // ignore if its just a position segment: path.0.subpath\n    if (!/\\D/.test(subpath)) {\n      // Nested array\n      if (val instanceof MongooseTypes.Array && i !== last) {\n        val = val.caster;\n      }\n      continue;\n    }\n\n    if (!(val && val.schema)) {\n      val = undefined;\n      break;\n    }\n\n    const type = val.schema.pathType(subpath);\n    isNested = (type === 'nested');\n    val = val.schema.path(subpath);\n  }\n\n  self.subpaths[cleanPath] = val;\n  if (val) {\n    return 'real';\n  }\n  if (isNested) {\n    return 'nested';\n  }\n  return 'adhocOrUndefined';\n}\n\n\n/*!\n * ignore\n */\n\nfunction getPositionalPath(self, path, cleanPath) {\n  getPositionalPathType(self, path, cleanPath);\n  return self.subpaths[cleanPath];\n}\n\n/**\n * Adds a method call to the queue.\n *\n * #### Example:\n *\n *     schema.methods.print = function() { console.log(this); };\n *     schema.queue('print', []); // Print the doc every one is instantiated\n *\n *     const Model = mongoose.model('Test', schema);\n *     new Model({ name: 'test' }); // Prints '{\"_id\": ..., \"name\": \"test\" }'\n *\n * @param {String} name name of the document method to call later\n * @param {Array} args arguments to pass to the method\n * @api public\n */\n\nSchema.prototype.queue = function(name, args) {\n  this.callQueue.push([name, args]);\n  return this;\n};\n\n/**\n * Defines a pre hook for the model.\n *\n * #### Example:\n *\n *     const toySchema = new Schema({ name: String, created: Date });\n *\n *     toySchema.pre('save', function(next) {\n *       if (!this.created) this.created = new Date;\n *       next();\n *     });\n *\n *     toySchema.pre('validate', function(next) {\n *       if (this.name !== 'Woody') this.name = 'Woody';\n *       next();\n *     });\n *\n *     // Equivalent to calling `pre()` on `find`, `findOne`, `findOneAndUpdate`.\n *     toySchema.pre(/^find/, function(next) {\n *       console.log(this.getFilter());\n *     });\n *\n *     // Equivalent to calling `pre()` on `updateOne`, `findOneAndUpdate`.\n *     toySchema.pre(['updateOne', 'findOneAndUpdate'], function(next) {\n *       console.log(this.getFilter());\n *     });\n *\n *     toySchema.pre('deleteOne', function() {\n *       // Runs when you call `Toy.deleteOne()`\n *     });\n *\n *     toySchema.pre('deleteOne', { document: true }, function() {\n *       // Runs when you call `doc.deleteOne()`\n *     });\n *\n * @param {String|RegExp|String[]} methodName The method name or regular expression to match method name\n * @param {Object} [options]\n * @param {Boolean} [options.document] If `name` is a hook for both document and query middleware, set to `true` to run on document middleware. For example, set `options.document` to `true` to apply this hook to `Document#deleteOne()` rather than `Query#deleteOne()`.\n * @param {Boolean} [options.query] If `name` is a hook for both document and query middleware, set to `true` to run on query middleware.\n * @param {Function} callback\n * @api public\n */\n\nSchema.prototype.pre = function(name) {\n  if (name instanceof RegExp) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const fn of hookNames) {\n      if (name.test(fn)) {\n        this.pre.apply(this, [fn].concat(remainingArgs));\n      }\n    }\n    return this;\n  }\n  if (Array.isArray(name)) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const el of name) {\n      this.pre.apply(this, [el].concat(remainingArgs));\n    }\n    return this;\n  }\n  this.s.hooks.pre.apply(this.s.hooks, arguments);\n  return this;\n};\n\n/**\n * Defines a post hook for the document\n *\n *     const schema = new Schema(..);\n *     schema.post('save', function (doc) {\n *       console.log('this fired after a document was saved');\n *     });\n *\n *     schema.post('find', function(docs) {\n *       console.log('this fired after you ran a find query');\n *     });\n *\n *     schema.post(/Many$/, function(res) {\n *       console.log('this fired after you ran `updateMany()` or `deleteMany()`');\n *     });\n *\n *     const Model = mongoose.model('Model', schema);\n *\n *     const m = new Model(..);\n *     m.save(function(err) {\n *       console.log('this fires after the `post` hook');\n *     });\n *\n *     m.find(function(err, docs) {\n *       console.log('this fires after the post find hook');\n *     });\n *\n * @param {String|RegExp|String[]} methodName The method name or regular expression to match method name\n * @param {Object} [options]\n * @param {Boolean} [options.document] If `name` is a hook for both document and query middleware, set to `true` to run on document middleware.\n * @param {Boolean} [options.query] If `name` is a hook for both document and query middleware, set to `true` to run on query middleware.\n * @param {Function} fn callback\n * @see middleware https://mongoosejs.com/docs/middleware.html\n * @see kareem https://npmjs.org/package/kareem\n * @api public\n */\n\nSchema.prototype.post = function(name) {\n  if (name instanceof RegExp) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const fn of hookNames) {\n      if (name.test(fn)) {\n        this.post.apply(this, [fn].concat(remainingArgs));\n      }\n    }\n    return this;\n  }\n  if (Array.isArray(name)) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const el of name) {\n      this.post.apply(this, [el].concat(remainingArgs));\n    }\n    return this;\n  }\n  this.s.hooks.post.apply(this.s.hooks, arguments);\n  return this;\n};\n\n/**\n * Registers a plugin for this schema.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: String });\n *     s.plugin(schema => console.log(schema.path('name').path));\n *     mongoose.model('Test', s); // Prints 'name'\n *\n * Or with Options:\n *\n *     const s = new Schema({ name: String });\n *     s.plugin((schema, opts) => console.log(opts.text, schema.path('name').path), { text: \"Schema Path Name:\" });\n *     mongoose.model('Test', s); // Prints 'Schema Path Name: name'\n *\n * @param {Function} plugin The Plugin's callback\n * @param {Object} [opts] Options to pass to the plugin\n * @param {Boolean} [opts.deduplicate=false] If true, ignore duplicate plugins (same `fn` argument using `===`)\n * @see plugins https://mongoosejs.com/docs/plugins.html\n * @api public\n */\n\nSchema.prototype.plugin = function(fn, opts) {\n  if (typeof fn !== 'function') {\n    throw new Error('First param to `schema.plugin()` must be a function, ' +\n      'got \"' + (typeof fn) + '\"');\n  }\n\n\n  if (opts && opts.deduplicate) {\n    for (const plugin of this.plugins) {\n      if (plugin.fn === fn) {\n        return this;\n      }\n    }\n  }\n  this.plugins.push({ fn: fn, opts: opts });\n\n  fn(this, opts);\n  return this;\n};\n\n/**\n * Adds an instance method to documents constructed from Models compiled from this schema.\n *\n * #### Example:\n *\n *     const schema = kittySchema = new Schema(..);\n *\n *     schema.method('meow', function () {\n *       console.log('meeeeeoooooooooooow');\n *     })\n *\n *     const Kitty = mongoose.model('Kitty', schema);\n *\n *     const fizz = new Kitty;\n *     fizz.meow(); // meeeeeooooooooooooow\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.\n *\n *     schema.method({\n *         purr: function () {}\n *       , scratch: function () {}\n *     });\n *\n *     // later\n *     const fizz = new Kitty;\n *     fizz.purr();\n *     fizz.scratch();\n *\n * NOTE: `Schema.method()` adds instance methods to the `Schema.methods` object. You can also add instance methods directly to the `Schema.methods` object as seen in the [guide](https://mongoosejs.com/docs/guide.html#methods)\n *\n * @param {String|Object} name The Method Name for a single function, or a Object of \"string-function\" pairs.\n * @param {Function} [fn] The Function in a single-function definition.\n * @api public\n */\n\nSchema.prototype.method = function(name, fn, options) {\n  if (typeof name !== 'string') {\n    for (const i in name) {\n      this.methods[i] = name[i];\n      this.methodOptions[i] = clone(options);\n    }\n  } else {\n    this.methods[name] = fn;\n    this.methodOptions[name] = clone(options);\n  }\n  return this;\n};\n\n/**\n * Adds static \"class\" methods to Models compiled from this schema.\n *\n * #### Example:\n *\n *     const schema = new Schema(..);\n *     // Equivalent to `schema.statics.findByName = function(name) {}`;\n *     schema.static('findByName', function(name) {\n *       return this.find({ name: name });\n *     });\n *\n *     const Drink = mongoose.model('Drink', schema);\n *     await Drink.findByName('LaCroix');\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.\n *\n *     schema.static({\n *         findByName: function () {..}\n *       , findByCost: function () {..}\n *     });\n *\n *     const Drink = mongoose.model('Drink', schema);\n *     await Drink.findByName('LaCroix');\n *     await Drink.findByCost(3);\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.\n *\n * @param {String|Object} name The Method Name for a single function, or a Object of \"string-function\" pairs.\n * @param {Function} [fn] The Function in a single-function definition.\n * @api public\n * @see Statics https://mongoosejs.com/docs/guide.html#statics\n */\n\nSchema.prototype.static = function(name, fn) {\n  if (typeof name !== 'string') {\n    for (const i in name) {\n      this.statics[i] = name[i];\n    }\n  } else {\n    this.statics[name] = fn;\n  }\n  return this;\n};\n\n/**\n * Defines an index (most likely compound) for this schema.\n *\n * #### Example:\n *\n *     schema.index({ first: 1, last: -1 })\n *\n * @param {Object} fields The Fields to index, with the order, available values: `1 | -1 | '2d' | '2dsphere' | 'geoHaystack' | 'hashed' | 'text'`\n * @param {Object} [options] Options to pass to [MongoDB driver's `createIndex()` function](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#createIndex)\n * @param {String | number} [options.expires=null] Mongoose-specific syntactic sugar, uses [ms](https://www.npmjs.com/package/ms) to convert `expires` option into seconds for the `expireAfterSeconds` in the above link.\n * @param {String} [options.language_override=null] Tells mongodb to use the specified field instead of `language` for parsing text indexes.\n * @api public\n */\n\nSchema.prototype.index = function(fields, options) {\n  fields || (fields = {});\n  options || (options = {});\n\n  if (options.expires) {\n    utils.expires(options);\n  }\n  for (const key in fields) {\n    if (this.aliases[key]) {\n      fields = utils.renameObjKey(fields, key, this.aliases[key]);\n    }\n  }\n  for (const field of Object.keys(fields)) {\n    if (fields[field] === 'ascending' || fields[field] === 'asc') {\n      fields[field] = 1;\n    } else if (fields[field] === 'descending' || fields[field] === 'desc') {\n      fields[field] = -1;\n    }\n  }\n\n  this._indexes.push([fields, options]);\n  return this;\n};\n\n/**\n * Sets a schema option.\n *\n * #### Example:\n *\n *     schema.set('strict'); // 'true' by default\n *     schema.set('strict', false); // Sets 'strict' to false\n *     schema.set('strict'); // 'false'\n *\n * @param {String} key The name of the option to set the value to\n * @param {Object} [value] The value to set the option to, if not passed, the option will be reset to default\n * @param {Array<string>} [tags] tags to add to read preference if key === 'read'\n * @see Schema https://mongoosejs.com/docs/api/schema.html#Schema()\n * @api public\n */\n\nSchema.prototype.set = function(key, value, tags) {\n  if (arguments.length === 1) {\n    return this.options[key];\n  }\n\n  switch (key) {\n    case 'read':\n      if (typeof value === 'string') {\n        this.options[key] = { mode: handleReadPreferenceAliases(value), tags };\n      } else if (Array.isArray(value) && typeof value[0] === 'string') {\n        this.options[key] = {\n          mode: handleReadPreferenceAliases(value[0]),\n          tags: value[1]\n        };\n      } else {\n        this.options[key] = value;\n      }\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n    case 'timestamps':\n      this.setupTimestamp(value);\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n    case '_id':\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n\n      if (value && !this.paths['_id']) {\n        addAutoId(this);\n      } else if (!value && this.paths['_id'] != null && this.paths['_id'].auto) {\n        this.remove('_id');\n      }\n      break;\n    default:\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n  }\n\n  // Propagate `strict` and `strictQuery` changes down to implicitly created schemas\n  if (key === 'strict') {\n    _propagateOptionsToImplicitlyCreatedSchemas(this, { strict: value });\n  }\n  if (key === 'strictQuery') {\n    _propagateOptionsToImplicitlyCreatedSchemas(this, { strictQuery: value });\n  }\n  if (key === 'toObject') {\n    value = { ...value };\n    // Avoid propagating transform to implicitly created schemas re: gh-3279\n    delete value.transform;\n    _propagateOptionsToImplicitlyCreatedSchemas(this, { toObject: value });\n  }\n  if (key === 'toJSON') {\n    value = { ...value };\n    // Avoid propagating transform to implicitly created schemas re: gh-3279\n    delete value.transform;\n    _propagateOptionsToImplicitlyCreatedSchemas(this, { toJSON: value });\n  }\n\n  return this;\n};\n\n/*!\n * Recursively set options on implicitly created schemas\n */\n\nfunction _propagateOptionsToImplicitlyCreatedSchemas(baseSchema, options) {\n  for (const { schema } of baseSchema.childSchemas) {\n    if (!schema.$implicitlyCreated) {\n      continue;\n    }\n    Object.assign(schema.options, options);\n    _propagateOptionsToImplicitlyCreatedSchemas(schema, options);\n  }\n}\n\n/**\n * Gets a schema option.\n *\n * #### Example:\n *\n *     schema.get('strict'); // true\n *     schema.set('strict', false);\n *     schema.get('strict'); // false\n *\n * @param {String} key The name of the Option to get the current value for\n * @api public\n * @return {Any} the option's value\n */\n\nSchema.prototype.get = function(key) {\n  return this.options[key];\n};\n\nconst indexTypes = '2d 2dsphere hashed text'.split(' ');\n\n/**\n * The allowed index types\n *\n * @property {String[]} indexTypes\n * @memberOf Schema\n * @static\n * @api public\n */\n\nObject.defineProperty(Schema, 'indexTypes', {\n  get: function() {\n    return indexTypes;\n  },\n  set: function() {\n    throw new Error('Cannot overwrite Schema.indexTypes');\n  }\n});\n\n/**\n * Returns a list of indexes that this schema declares, via `schema.index()` or by `index: true` in a path's options.\n * Indexes are expressed as an array `[spec, options]`.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({\n *       email: { type: String, required: true, unique: true },\n *       registeredAt: { type: Date, index: true }\n *     });\n *\n *     // [ [ { email: 1 }, { unique: true, background: true } ],\n *     //   [ { registeredAt: 1 }, { background: true } ] ]\n *     userSchema.indexes();\n *\n * [Plugins](https://mongoosejs.com/docs/plugins.html) can use the return value of this function to modify a schema's indexes.\n * For example, the below plugin makes every index unique by default.\n *\n *     function myPlugin(schema) {\n *       for (const index of schema.indexes()) {\n *         if (index[1].unique === undefined) {\n *           index[1].unique = true;\n *         }\n *       }\n *     }\n *\n * @api public\n * @return {Array} list of indexes defined in the schema\n */\n\nSchema.prototype.indexes = function() {\n  return getIndexes(this);\n};\n\n/**\n * Creates a virtual type with the given name.\n *\n * @param {String} name The name of the Virtual\n * @param {Object} [options]\n * @param {String|Model} [options.ref] model name or model instance. Marks this as a [populate virtual](https://mongoosejs.com/docs/populate.html#populate-virtuals).\n * @param {String|Function} [options.localField] Required for populate virtuals. See [populate virtual docs](https://mongoosejs.com/docs/populate.html#populate-virtuals) for more information.\n * @param {String|Function} [options.foreignField] Required for populate virtuals. See [populate virtual docs](https://mongoosejs.com/docs/populate.html#populate-virtuals) for more information.\n * @param {Boolean|Function} [options.justOne=false] Only works with populate virtuals. If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), will be a single doc or `null`. Otherwise, the populate virtual will be an array.\n * @param {Boolean} [options.count=false] Only works with populate virtuals. If [truthy](https://masteringjs.io/tutorials/fundamentals/truthy), this populate virtual will contain the number of documents rather than the documents themselves when you `populate()`.\n * @param {Function|null} [options.get=null] Adds a [getter](https://mongoosejs.com/docs/tutorials/getters-setters.html) to this virtual to transform the populated doc.\n * @param {Object|Function} [options.match=null] Apply a default [`match` option to populate](https://mongoosejs.com/docs/populate.html#match), adding an additional filter to the populate query.\n * @return {VirtualType}\n */\n\nSchema.prototype.virtual = function(name, options) {\n  if (name instanceof VirtualType || getConstructorName(name) === 'VirtualType') {\n    return this.virtual(name.path, name.options);\n  }\n  options = new VirtualOptions(options);\n\n  if (utils.hasUserDefinedProperty(options, ['ref', 'refPath'])) {\n    if (options.localField == null) {\n      throw new Error('Reference virtuals require `localField` option');\n    }\n\n    if (options.foreignField == null) {\n      throw new Error('Reference virtuals require `foreignField` option');\n    }\n\n    this.pre('init', function virtualPreInit(obj) {\n      if (mpath.has(name, obj)) {\n        const _v = mpath.get(name, obj);\n        if (!this.$$populatedVirtuals) {\n          this.$$populatedVirtuals = {};\n        }\n\n        if (options.justOne || options.count) {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v[0] :\n            _v;\n        } else {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v :\n            _v == null ? [] : [_v];\n        }\n\n        mpath.unset(name, obj);\n      }\n    });\n\n    const virtual = this.virtual(name);\n    virtual.options = options;\n\n    virtual.\n      set(function(v) {\n        if (!this.$$populatedVirtuals) {\n          this.$$populatedVirtuals = {};\n        }\n\n        return setPopulatedVirtualValue(\n          this.$$populatedVirtuals,\n          name,\n          v,\n          options\n        );\n      });\n\n    if (typeof options.get === 'function') {\n      virtual.get(options.get);\n    }\n\n    // Workaround for gh-8198: if virtual is under document array, make a fake\n    // virtual. See gh-8210, gh-13189\n    const parts = name.split('.');\n    let cur = parts[0];\n    for (let i = 0; i < parts.length - 1; ++i) {\n      if (this.paths[cur] == null) {\n        continue;\n      }\n\n      if (this.paths[cur].$isMongooseDocumentArray || this.paths[cur].$isSingleNested) {\n        const remnant = parts.slice(i + 1).join('.');\n        this.paths[cur].schema.virtual(remnant, options);\n        break;\n      }\n\n      cur += '.' + parts[i + 1];\n    }\n\n    return virtual;\n  }\n\n  const virtuals = this.virtuals;\n  const parts = name.split('.');\n\n  if (this.pathType(name) === 'real') {\n    throw new Error('Virtual path \"' + name + '\"' +\n      ' conflicts with a real path in the schema');\n  }\n\n  virtuals[name] = parts.reduce(function(mem, part, i) {\n    mem[part] || (mem[part] = (i === parts.length - 1)\n      ? new VirtualType(options, name)\n      : {});\n    return mem[part];\n  }, this.tree);\n\n  return virtuals[name];\n};\n\n/**\n * Returns the virtual type with the given `name`.\n *\n * @param {String} name The name of the Virtual to get\n * @return {VirtualType|null}\n */\n\nSchema.prototype.virtualpath = function(name) {\n  return this.virtuals.hasOwnProperty(name) ? this.virtuals[name] : null;\n};\n\n/**\n * Removes the given `path` (or [`paths`]).\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String, age: Number });\n *     schema.remove('name');\n *     schema.path('name'); // Undefined\n *     schema.path('age'); // SchemaNumber { ... }\n *\n * Or as a Array:\n *\n *     schema.remove(['name', 'age']);\n *     schema.path('name'); // Undefined\n *     schema.path('age'); // Undefined\n *\n * @param {String|Array} path The Path(s) to remove\n * @return {Schema} the Schema instance\n * @api public\n */\nSchema.prototype.remove = function(path) {\n  if (typeof path === 'string') {\n    path = [path];\n  }\n  if (Array.isArray(path)) {\n    path.forEach(function(name) {\n      if (this.path(name) == null && !this.nested[name]) {\n        return;\n      }\n      if (this.nested[name]) {\n        const allKeys = Object.keys(this.paths).\n          concat(Object.keys(this.nested));\n        for (const path of allKeys) {\n          if (path.startsWith(name + '.')) {\n            delete this.paths[path];\n            delete this.nested[path];\n            _deletePath(this, path);\n          }\n        }\n\n        delete this.nested[name];\n        _deletePath(this, name);\n        return;\n      }\n\n      delete this.paths[name];\n      _deletePath(this, name);\n    }, this);\n  }\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _deletePath(schema, name) {\n  const pieces = name.split('.');\n  const last = pieces.pop();\n\n  let branch = schema.tree;\n\n  for (const piece of pieces) {\n    branch = branch[piece];\n  }\n\n  delete branch[last];\n}\n\n/**\n * Removes the given virtual or virtuals from the schema.\n *\n * @param {String|Array} path The virutal path(s) to remove.\n * @returns {Schema} the Schema instance, or a mongoose error if the virtual does not exist.\n * @api public\n */\n\nSchema.prototype.removeVirtual = function(path) {\n  if (typeof path === 'string') {\n    path = [path];\n  }\n  if (Array.isArray(path)) {\n    for (const virtual of path) {\n      if (this.virtuals[virtual] == null) {\n        throw new MongooseError(`Attempting to remove virtual \"${virtual}\" that does not exist.`);\n      }\n    }\n\n    for (const virtual of path) {\n      delete this.paths[virtual];\n      delete this.virtuals[virtual];\n      if (virtual.indexOf('.') !== -1) {\n        mpath.unset(virtual, this.tree);\n      } else {\n        delete this.tree[virtual];\n      }\n    }\n  }\n  return this;\n};\n\n/**\n * Loads an ES6 class into a schema. Maps [setters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set) + [getters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get), [static methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static),\n * and [instance methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Class_body_and_method_definitions)\n * to schema [virtuals](https://mongoosejs.com/docs/guide.html#virtuals),\n * [statics](https://mongoosejs.com/docs/guide.html#statics), and\n * [methods](https://mongoosejs.com/docs/guide.html#methods).\n *\n * #### Example:\n *\n * ```javascript\n * const md5 = require('md5');\n * const userSchema = new Schema({ email: String });\n * class UserClass {\n *   // `gravatarImage` becomes a virtual\n *   get gravatarImage() {\n *     const hash = md5(this.email.toLowerCase());\n *     return `https://www.gravatar.com/avatar/${hash}`;\n *   }\n *\n *   // `getProfileUrl()` becomes a document method\n *   getProfileUrl() {\n *     return `https://mysite.com/${this.email}`;\n *   }\n *\n *   // `findByEmail()` becomes a static\n *   static findByEmail(email) {\n *     return this.findOne({ email });\n *   }\n * }\n *\n * // `schema` will now have a `gravatarImage` virtual, a `getProfileUrl()` method,\n * // and a `findByEmail()` static\n * userSchema.loadClass(UserClass);\n * ```\n *\n * @param {Function} model The Class to load\n * @param {Boolean} [virtualsOnly] if truthy, only pulls virtuals from the class, not methods or statics\n */\nSchema.prototype.loadClass = function(model, virtualsOnly) {\n  // Stop copying when hit certain base classes\n  if (model === Object.prototype ||\n      model === Function.prototype ||\n      model.prototype.hasOwnProperty('$isMongooseModelPrototype') ||\n      model.prototype.hasOwnProperty('$isMongooseDocumentPrototype')) {\n    return this;\n  }\n\n  this.loadClass(Object.getPrototypeOf(model), virtualsOnly);\n\n  // Add static methods\n  if (!virtualsOnly) {\n    Object.getOwnPropertyNames(model).forEach(function(name) {\n      if (name.match(/^(length|name|prototype|constructor|__proto__)$/)) {\n        return;\n      }\n      const prop = Object.getOwnPropertyDescriptor(model, name);\n      if (prop.hasOwnProperty('value')) {\n        this.static(name, prop.value);\n      }\n    }, this);\n  }\n\n  // Add methods and virtuals\n  Object.getOwnPropertyNames(model.prototype).forEach(function(name) {\n    if (name.match(/^(constructor)$/)) {\n      return;\n    }\n    const method = Object.getOwnPropertyDescriptor(model.prototype, name);\n    if (!virtualsOnly) {\n      if (typeof method.value === 'function') {\n        this.method(name, method.value);\n      }\n    }\n    if (typeof method.get === 'function') {\n      if (this.virtuals[name]) {\n        this.virtuals[name].getters = [];\n      }\n      this.virtual(name).get(method.get);\n    }\n    if (typeof method.set === 'function') {\n      if (this.virtuals[name]) {\n        this.virtuals[name].setters = [];\n      }\n      this.virtual(name).set(method.set);\n    }\n  }, this);\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._getSchema = function(path) {\n  const _this = this;\n  const pathschema = _this.path(path);\n  const resultPath = [];\n\n  if (pathschema) {\n    pathschema.$fullPath = path;\n    return pathschema;\n  }\n\n  function search(parts, schema) {\n    let p = parts.length + 1;\n    let foundschema;\n    let trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema) {\n        resultPath.push(trypath);\n\n        if (foundschema.caster) {\n          // array of Mixed?\n          if (foundschema.caster instanceof MongooseTypes.Mixed) {\n            foundschema.caster.$fullPath = resultPath.join('.');\n            return foundschema.caster;\n          }\n\n          // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          // If there is no foundschema.schema we are dealing with\n          // a path like array.$\n          if (p !== parts.length) {\n            if (foundschema.schema) {\n              let ret;\n              if (parts[p] === '$' || isArrayFilter(parts[p])) {\n                if (p + 1 === parts.length) {\n                  // comments.$\n                  return foundschema.$embeddedSchemaType;\n                }\n                // comments.$.comments.$.title\n                ret = search(parts.slice(p + 1), foundschema.schema);\n                if (ret) {\n                  ret.$parentSchemaDocArray = ret.$parentSchemaDocArray ||\n                    (foundschema.schema.$isSingleNested ? null : foundschema);\n                }\n                return ret;\n              }\n              // this is the last path of the selector\n              ret = search(parts.slice(p), foundschema.schema);\n              if (ret) {\n                ret.$parentSchemaDocArray = ret.$parentSchemaDocArray ||\n                  (foundschema.schema.$isSingleNested ? null : foundschema);\n              }\n              return ret;\n            }\n          }\n        } else if (foundschema.$isSchemaMap) {\n          if (p >= parts.length) {\n            return foundschema;\n          }\n          // Any path in the map will be an instance of the map's embedded schematype\n          if (p + 1 >= parts.length) {\n            return foundschema.$__schemaType;\n          }\n\n          if (foundschema.$__schemaType instanceof MongooseTypes.Mixed) {\n            return foundschema.$__schemaType;\n          }\n          if (foundschema.$__schemaType.schema != null) {\n            // Map of docs\n            const ret = search(parts.slice(p + 1), foundschema.$__schemaType.schema);\n            return ret;\n          }\n        }\n\n        foundschema.$fullPath = resultPath.join('.');\n\n        return foundschema;\n      }\n    }\n  }\n\n  // look for arrays\n  const parts = path.split('.');\n  for (let i = 0; i < parts.length; ++i) {\n    if (parts[i] === '$' || isArrayFilter(parts[i])) {\n      // Re: gh-5628, because `schema.path()` doesn't take $ into account.\n      parts[i] = '0';\n    }\n    if (numberRE.test(parts[i])) {\n      parts[i] = '$';\n    }\n  }\n  return search(parts, _this);\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._getPathType = function(path) {\n  const _this = this;\n  const pathschema = _this.path(path);\n\n  if (pathschema) {\n    return 'real';\n  }\n\n  function search(parts, schema) {\n    let p = parts.length + 1,\n        foundschema,\n        trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema) {\n        if (foundschema.caster) {\n          // array of Mixed?\n          if (foundschema.caster instanceof MongooseTypes.Mixed) {\n            return { schema: foundschema, pathType: 'mixed' };\n          }\n\n          // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          // If there is no foundschema.schema we are dealing with\n          // a path like array.$\n          if (p !== parts.length && foundschema.schema) {\n            if (parts[p] === '$' || isArrayFilter(parts[p])) {\n              if (p === parts.length - 1) {\n                return { schema: foundschema, pathType: 'nested' };\n              }\n              // comments.$.comments.$.title\n              return search(parts.slice(p + 1), foundschema.schema);\n            }\n            // this is the last path of the selector\n            return search(parts.slice(p), foundschema.schema);\n          }\n          return {\n            schema: foundschema,\n            pathType: foundschema.$isSingleNested ? 'nested' : 'array'\n          };\n        }\n        return { schema: foundschema, pathType: 'real' };\n      } else if (p === parts.length && schema.nested[trypath]) {\n        return { schema: schema, pathType: 'nested' };\n      }\n    }\n    return { schema: foundschema || schema, pathType: 'undefined' };\n  }\n\n  // look for arrays\n  return search(path.split('.'), _this);\n};\n\n/*!\n * ignore\n */\n\nfunction isArrayFilter(piece) {\n  return piece.startsWith('$[') && piece.endsWith(']');\n}\n\n/**\n * Called by `compile()` _right before_ compiling. Good for making any changes to\n * the schema that should respect options set by plugins, like `id`\n * @method _preCompile\n * @memberOf Schema\n * @instance\n * @api private\n */\n\nSchema.prototype._preCompile = function _preCompile() {\n  this.plugin(idGetter, { deduplicate: true });\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = Schema;\n\n// require down here because of reference issues\n\n/**\n * The various built-in Mongoose Schema Types.\n *\n * #### Example:\n *\n *     const mongoose = require('mongoose');\n *     const ObjectId = mongoose.Schema.Types.ObjectId;\n *\n * #### Types:\n *\n * - [String](https://mongoosejs.com/docs/schematypes.html#strings)\n * - [Number](https://mongoosejs.com/docs/schematypes.html#numbers)\n * - [Boolean](https://mongoosejs.com/docs/schematypes.html#booleans) | Bool\n * - [Array](https://mongoosejs.com/docs/schematypes.html#arrays)\n * - [Buffer](https://mongoosejs.com/docs/schematypes.html#buffers)\n * - [Date](https://mongoosejs.com/docs/schematypes.html#dates)\n * - [ObjectId](https://mongoosejs.com/docs/schematypes.html#objectids) | Oid\n * - [Mixed](https://mongoosejs.com/docs/schematypes.html#mixed)\n * - [UUID](https://mongoosejs.com/docs/schematypes.html#uuid)\n * - [BigInt](https://mongoosejs.com/docs/schematypes.html#bigint)\n *\n * Using this exposed access to the `Mixed` SchemaType, we can use them in our schema.\n *\n *     const Mixed = mongoose.Schema.Types.Mixed;\n *     new mongoose.Schema({ _user: Mixed })\n *\n * @api public\n */\n\nSchema.Types = MongooseTypes = __webpack_require__(/*! ./schema/index */ \"../backend/node_modules/mongoose/lib/schema/index.js\");\n\n/*!\n * ignore\n */\n\nexports.ObjectId = MongooseTypes.ObjectId;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLDBEQUE4QjtBQUNuRCxlQUFlLG1CQUFPLENBQUMsdURBQVE7QUFDL0Isc0JBQXNCLG1CQUFPLENBQUMsMEZBQXVCO0FBQ3JELG1CQUFtQixtQkFBTyxDQUFDLHdFQUFjO0FBQ3pDLDBCQUEwQixtQkFBTyxDQUFDLHNHQUE2QjtBQUMvRCx1QkFBdUIsbUJBQU8sQ0FBQyxnR0FBMEI7QUFDekQsb0JBQW9CLG1CQUFPLENBQUMsMEVBQWU7QUFDM0Msa0JBQWtCLG1CQUFPLENBQUMsb0dBQTRCO0FBQ3RELGNBQWMsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDdkMsWUFBWSxtQkFBTyxDQUFDLDBFQUFlO0FBQ25DLDJCQUEyQixtQkFBTyxDQUFDLHdHQUE4QjtBQUNqRSxtQkFBbUIsbUJBQU8sQ0FBQyxzR0FBNkI7QUFDeEQsb0NBQW9DLG1CQUFPLENBQUMsc0lBQTZDO0FBQ3pGLGlCQUFpQixtQkFBTyxDQUFDLGtHQUEyQjtBQUNwRCxjQUFjLG1CQUFPLENBQUMsNEZBQXdCO0FBQzlDLGNBQWMsbUJBQU8sQ0FBQyxxREFBTztBQUM3QixpQ0FBaUMsbUJBQU8sQ0FBQyxzSUFBNkM7QUFDdEYsd0JBQXdCLG1CQUFPLENBQUMsd0hBQXNDO0FBQ3RFLGNBQWMsbUJBQU8sQ0FBQyw4REFBUztBQUMvQixvQkFBb0IsbUJBQU8sQ0FBQyw0R0FBZ0M7QUFDNUQsYUFBYSxtQkFBTyxDQUFDLGtCQUFNOztBQUUzQjs7QUFFQTs7QUFFQSxtQkFBbUIsc0hBQStDO0FBQ2xFLHNCQUFzQiwrSUFBeUQ7QUFDL0U7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGNBQWM7QUFDaEQsbUNBQW1DLDhDQUE4QztBQUNqRjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYyxJQUFJLDZCQUE2QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpQkFBaUI7QUFDL0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFEQUFxRDtBQUMvRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxtQkFBTyxDQUFDLG9FQUFTOztBQUV2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPLFFBQVE7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLG9CQUFvQixLQUFLLElBQUk7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsUUFBUSxpQkFBaUIsR0FBRyxxQkFBcUIsUUFBUSxRQUFRLG1CQUFtQixHQUFHO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLG9DQUFvQyxRQUFRLE9BQU8saUJBQWlCLEdBQUc7QUFDdkU7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtEQUErRCxLQUFLO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLLDRDQUE0QyxLQUFLO0FBQ3JFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJELEtBQUs7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsS0FBSztBQUNoRSxnQ0FBZ0MsS0FBSztBQUNyQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsTUFBTTtBQUNOLGlDQUFpQztBQUNqQyxNQUFNO0FBQ04sbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsa0NBQWtDO0FBQ3pFO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsc0NBQXNDO0FBQ3RDO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhCQUE4QjtBQUMvQyxnQkFBZ0IsOEJBQThCO0FBQzlDO0FBQ0EsUUFBUTtBQUNSLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHdCQUF3QixlQUFlO0FBQ3JFO0FBQ0EsMkJBQTJCO0FBQzNCLDZCQUE2QjtBQUM3QiwwQkFBMEI7QUFDMUIsMkJBQTJCO0FBQzNCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsbUJBQW1CLGNBQWMsR0FBRyxZQUFZLDRCQUE0QjtBQUM1RTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDZCQUE2QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxvQ0FBb0MsZ0JBQWdCO0FBQ3BEO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsV0FBVyx3QkFBd0I7QUFDbkMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsV0FBVyx3QkFBd0I7QUFDbkMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDLHNGQUFzRiwyQkFBMkI7QUFDakgsa0NBQWtDO0FBQ2xDO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjs7QUFFMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFVBQVU7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0Isb0NBQW9DO0FBQ3BDLDZCQUE2QjtBQUM3QjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdEQUF3RCxlQUFlO0FBQ3ZFO0FBQ0E7QUFDQSx3REFBd0Qsb0JBQW9CO0FBQzVFO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLHdEQUF3RCxpQkFBaUI7QUFDekU7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esd0RBQXdELGVBQWU7QUFDdkU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFlBQVksS0FBSztBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRDQUE0QztBQUM5RCx5QkFBeUI7QUFDekIsUUFBUTtBQUNSO0FBQ0EsZ0JBQWdCLFVBQVUsSUFBSSxpQ0FBaUM7QUFDL0QsZ0JBQWdCLGlCQUFpQixJQUFJLG1CQUFtQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsY0FBYztBQUN6QixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLGtCQUFrQjtBQUM3QixXQUFXLFNBQVM7QUFDcEIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsaUJBQWlCO0FBQzVCLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywyQkFBMkI7QUFDOUQ7QUFDQSw0QkFBNEI7QUFDNUIsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QiwyQkFBMkI7QUFDM0I7QUFDQSxXQUFXLGNBQWM7QUFDekIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixhQUFhLFFBQVE7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxRQUFRO0FBQ3pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxlQUFlO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEtBQUs7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsV0FBVztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixPQUFPO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixRQUFRO0FBQ1IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixtQkFBbUI7QUFDN0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixjQUFjO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsbUJBQU8sQ0FBQyw0RUFBZ0I7O0FBRXZEO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hLmpzP2EwNmQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuY29uc3QgS2FyZWVtID0gcmVxdWlyZSgna2FyZWVtJyk7XG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi9lcnJvci9tb25nb29zZUVycm9yJyk7XG5jb25zdCBTY2hlbWFUeXBlID0gcmVxdWlyZSgnLi9zY2hlbWFUeXBlJyk7XG5jb25zdCBTY2hlbWFUeXBlT3B0aW9ucyA9IHJlcXVpcmUoJy4vb3B0aW9ucy9zY2hlbWFUeXBlT3B0aW9ucycpO1xuY29uc3QgVmlydHVhbE9wdGlvbnMgPSByZXF1aXJlKCcuL29wdGlvbnMvdmlydHVhbE9wdGlvbnMnKTtcbmNvbnN0IFZpcnR1YWxUeXBlID0gcmVxdWlyZSgnLi92aXJ0dWFsVHlwZScpO1xuY29uc3QgYWRkQXV0b0lkID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NjaGVtYS9hZGRBdXRvSWQnKTtcbmNvbnN0IGNsb25lID0gcmVxdWlyZSgnLi9oZWxwZXJzL2Nsb25lJyk7XG5jb25zdCBnZXQgPSByZXF1aXJlKCcuL2hlbHBlcnMvZ2V0Jyk7XG5jb25zdCBnZXRDb25zdHJ1Y3Rvck5hbWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvZ2V0Q29uc3RydWN0b3JOYW1lJyk7XG5jb25zdCBnZXRJbmRleGVzID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NjaGVtYS9nZXRJbmRleGVzJyk7XG5jb25zdCBoYW5kbGVSZWFkUHJlZmVyZW5jZUFsaWFzZXMgPSByZXF1aXJlKCcuL2hlbHBlcnMvcXVlcnkvaGFuZGxlUmVhZFByZWZlcmVuY2VBbGlhc2VzJyk7XG5jb25zdCBpZEdldHRlciA9IHJlcXVpcmUoJy4vaGVscGVycy9zY2hlbWEvaWRHZXR0ZXInKTtcbmNvbnN0IG1lcmdlID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NjaGVtYS9tZXJnZScpO1xuY29uc3QgbXBhdGggPSByZXF1aXJlKCdtcGF0aCcpO1xuY29uc3Qgc2V0UG9wdWxhdGVkVmlydHVhbFZhbHVlID0gcmVxdWlyZSgnLi9oZWxwZXJzL3BvcHVsYXRlL3NldFBvcHVsYXRlZFZpcnR1YWxWYWx1ZScpO1xuY29uc3Qgc2V0dXBUaW1lc3RhbXBzID0gcmVxdWlyZSgnLi9oZWxwZXJzL3RpbWVzdGFtcHMvc2V0dXBUaW1lc3RhbXBzJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbmNvbnN0IHZhbGlkYXRlUmVmID0gcmVxdWlyZSgnLi9oZWxwZXJzL3BvcHVsYXRlL3ZhbGlkYXRlUmVmJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5jb25zdCBoYXNOdW1lcmljU3VicGF0aFJlZ2V4ID0gL1xcLlxcZCsoXFwufCQpLztcblxubGV0IE1vbmdvb3NlVHlwZXM7XG5cbmNvbnN0IHF1ZXJ5SG9va3MgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpLnF1ZXJ5TWlkZGxld2FyZUZ1bmN0aW9ucztcbmNvbnN0IGRvY3VtZW50SG9va3MgPSByZXF1aXJlKCcuL2hlbHBlcnMvbW9kZWwvYXBwbHlIb29rcycpLm1pZGRsZXdhcmVGdW5jdGlvbnM7XG5jb25zdCBob29rTmFtZXMgPSBxdWVyeUhvb2tzLmNvbmNhdChkb2N1bWVudEhvb2tzKS5cbiAgcmVkdWNlKChzLCBob29rKSA9PiBzLmFkZChob29rKSwgbmV3IFNldCgpKTtcblxuY29uc3QgaXNQT0pPID0gdXRpbHMuaXNQT0pPO1xuXG5sZXQgaWQgPSAwO1xuXG5jb25zdCBudW1iZXJSRSA9IC9eXFxkKyQvO1xuXG4vKipcbiAqIFNjaGVtYSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGNoaWxkID0gbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZyB9KTtcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nLCBhZ2U6IE51bWJlciwgY2hpbGRyZW46IFtjaGlsZF0gfSk7XG4gKiAgICAgY29uc3QgVHJlZSA9IG1vbmdvb3NlLm1vZGVsKCdUcmVlJywgc2NoZW1hKTtcbiAqXG4gKiAgICAgLy8gc2V0dGluZyBzY2hlbWEgb3B0aW9uc1xuICogICAgIG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSwgeyBpZDogZmFsc2UsIGF1dG9JbmRleDogZmFsc2UgfSlcbiAqXG4gKiAjIyMjIE9wdGlvbnM6XG4gKlxuICogLSBbYXV0b0luZGV4XShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNhdXRvSW5kZXgpOiBib29sIC0gZGVmYXVsdHMgdG8gbnVsbCAod2hpY2ggbWVhbnMgdXNlIHRoZSBjb25uZWN0aW9uJ3MgYXV0b0luZGV4IG9wdGlvbilcbiAqIC0gW2F1dG9DcmVhdGVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI2F1dG9DcmVhdGUpOiBib29sIC0gZGVmYXVsdHMgdG8gbnVsbCAod2hpY2ggbWVhbnMgdXNlIHRoZSBjb25uZWN0aW9uJ3MgYXV0b0NyZWF0ZSBvcHRpb24pXG4gKiAtIFtidWZmZXJDb21tYW5kc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjYnVmZmVyQ29tbWFuZHMpOiBib29sIC0gZGVmYXVsdHMgdG8gdHJ1ZVxuICogLSBbYnVmZmVyVGltZW91dE1TXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNidWZmZXJUaW1lb3V0TVMpOiBudW1iZXIgLSBkZWZhdWx0cyB0byAxMDAwMCAoMTAgc2Vjb25kcykuIElmIGBidWZmZXJDb21tYW5kc2AgaXMgZW5hYmxlZCwgdGhlIGFtb3VudCBvZiB0aW1lIE1vbmdvb3NlIHdpbGwgd2FpdCBmb3IgY29ubmVjdGl2aXR5IHRvIGJlIHJlc3RhYmxpc2hlZCBiZWZvcmUgZXJyb3Jpbmcgb3V0LlxuICogLSBbY2FwcGVkXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNjYXBwZWQpOiBib29sIHwgbnVtYmVyIHwgb2JqZWN0IC0gZGVmYXVsdHMgdG8gZmFsc2VcbiAqIC0gW2NvbGxlY3Rpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI2NvbGxlY3Rpb24pOiBzdHJpbmcgLSBubyBkZWZhdWx0XG4gKiAtIFtkaXNjcmltaW5hdG9yS2V5XShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNkaXNjcmltaW5hdG9yS2V5KTogc3RyaW5nIC0gZGVmYXVsdHMgdG8gYF9fdGBcbiAqIC0gW2lkXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNpZCk6IGJvb2wgLSBkZWZhdWx0cyB0byB0cnVlXG4gKiAtIFtfaWRdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI19pZCk6IGJvb2wgLSBkZWZhdWx0cyB0byB0cnVlXG4gKiAtIFttaW5pbWl6ZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjbWluaW1pemUpOiBib29sIC0gY29udHJvbHMgW2RvY3VtZW50I3RvT2JqZWN0XShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLnRvT2JqZWN0KCkpIGJlaGF2aW9yIHdoZW4gY2FsbGVkIG1hbnVhbGx5IC0gZGVmYXVsdHMgdG8gdHJ1ZVxuICogLSBbcmVhZF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjcmVhZCk6IHN0cmluZ1xuICogLSBbd3JpdGVDb25jZXJuXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN3cml0ZUNvbmNlcm4pOiBvYmplY3QgLSBkZWZhdWx0cyB0byBudWxsLCB1c2UgdG8gb3ZlcnJpZGUgW3RoZSBNb25nb0RCIHNlcnZlcidzIGRlZmF1bHQgd3JpdGUgY29uY2VybiBzZXR0aW5nc10oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL3dyaXRlLWNvbmNlcm4vKVxuICogLSBbc2hhcmRLZXldKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3NoYXJkS2V5KTogb2JqZWN0IC0gZGVmYXVsdHMgdG8gYG51bGxgXG4gKiAtIFtzdHJpY3RdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3N0cmljdCk6IGJvb2wgLSBkZWZhdWx0cyB0byB0cnVlXG4gKiAtIFtzdHJpY3RRdWVyeV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc3RyaWN0UXVlcnkpOiBib29sIC0gZGVmYXVsdHMgdG8gZmFsc2VcbiAqIC0gW3RvSlNPTl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdG9KU09OKSAtIG9iamVjdCAtIG5vIGRlZmF1bHRcbiAqIC0gW3RvT2JqZWN0XShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0b09iamVjdCkgLSBvYmplY3QgLSBubyBkZWZhdWx0XG4gKiAtIFt0eXBlS2V5XShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0eXBlS2V5KSAtIHN0cmluZyAtIGRlZmF1bHRzIHRvICd0eXBlJ1xuICogLSBbdmFsaWRhdGVCZWZvcmVTYXZlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN2YWxpZGF0ZUJlZm9yZVNhdmUpIC0gYm9vbCAtIGRlZmF1bHRzIHRvIGB0cnVlYFxuICogLSBbdmFsaWRhdGVNb2RpZmllZE9ubHldKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudC5wcm90b3R5cGUudmFsaWRhdGUoKSkgLSBib29sIC0gZGVmYXVsdHMgdG8gYGZhbHNlYFxuICogLSBbdmVyc2lvbktleV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjdmVyc2lvbktleSk6IHN0cmluZyBvciBvYmplY3QgLSBkZWZhdWx0cyB0byBcIl9fdlwiXG4gKiAtIFtvcHRpbWlzdGljQ29uY3VycmVuY3ldKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI29wdGltaXN0aWNDb25jdXJyZW5jeSk6IGJvb2wgLSBkZWZhdWx0cyB0byBmYWxzZS4gU2V0IHRvIHRydWUgdG8gZW5hYmxlIFtvcHRpbWlzdGljIGNvbmN1cnJlbmN5XShodHRwczovL3RoZWNvZGViYXJiYXJpYW4uY29tL3doYXRzLW5ldy1pbi1tb25nb29zZS01LTEwLW9wdGltaXN0aWMtY29uY3VycmVuY3kuaHRtbCkuXG4gKiAtIFtjb2xsYXRpb25dKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI2NvbGxhdGlvbik6IG9iamVjdCAtIGRlZmF1bHRzIHRvIG51bGwgKHdoaWNoIG1lYW5zIHVzZSBubyBjb2xsYXRpb24pXG4gKiAtIFt0aW1lc2VyaWVzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCN0aW1lc2VyaWVzKTogb2JqZWN0IC0gZGVmYXVsdHMgdG8gbnVsbCAod2hpY2ggbWVhbnMgdGhpcyBzY2hlbWEncyBjb2xsZWN0aW9uIHdvbid0IGJlIGEgdGltZXNlcmllcyBjb2xsZWN0aW9uKVxuICogLSBbc2VsZWN0UG9wdWxhdGVkUGF0aHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3NlbGVjdFBvcHVsYXRlZFBhdGhzKTogYm9vbGVhbiAtIGRlZmF1bHRzIHRvIGB0cnVlYFxuICogLSBbc2tpcFZlcnNpb25pbmddKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3NraXBWZXJzaW9uaW5nKTogb2JqZWN0IC0gcGF0aHMgdG8gZXhjbHVkZSBmcm9tIHZlcnNpb25pbmdcbiAqIC0gW3RpbWVzdGFtcHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3RpbWVzdGFtcHMpOiBvYmplY3Qgb3IgYm9vbGVhbiAtIGRlZmF1bHRzIHRvIGBmYWxzZWAuIElmIHRydWUsIE1vbmdvb3NlIGFkZHMgYGNyZWF0ZWRBdGAgYW5kIGB1cGRhdGVkQXRgIHByb3BlcnRpZXMgdG8geW91ciBzY2hlbWEgYW5kIG1hbmFnZXMgdGhvc2UgcHJvcGVydGllcyBmb3IgeW91LlxuICogLSBbcGx1Z2luVGFnc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjcGx1Z2luVGFncyk6IGFycmF5IG9mIHN0cmluZ3MgLSBkZWZhdWx0cyB0byBgdW5kZWZpbmVkYC4gSWYgc2V0IGFuZCBwbHVnaW4gY2FsbGVkIHdpdGggYHRhZ3NgIG9wdGlvbiwgd2lsbCBvbmx5IGFwcGx5IHRoYXQgcGx1Z2luIHRvIHNjaGVtYXMgd2l0aCBhIG1hdGNoaW5nIHRhZy5cbiAqIC0gW3ZpcnR1YWxzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvdHV0b3JpYWxzL3ZpcnR1YWxzLmh0bWwjdmlydHVhbHMtdmlhLXNjaGVtYS1vcHRpb25zKTogb2JqZWN0IC0gdmlydHVhbHMgdG8gZGVmaW5lLCBhbGlhcyBmb3IgW2AudmlydHVhbGBdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvc2NoZW1hLmh0bWwjU2NoZW1hLnByb3RvdHlwZS52aXJ0dWFsKCkpXG4gKiAtIFtjb2xsZWN0aW9uT3B0aW9uc106IG9iamVjdCB3aXRoIG9wdGlvbnMgcGFzc2VkIHRvIFtgY3JlYXRlQ29sbGVjdGlvbigpYF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL21ldGhvZC9kYi5jcmVhdGVDb2xsZWN0aW9uLykgd2hlbiBjYWxsaW5nIGBNb2RlbC5jcmVhdGVDb2xsZWN0aW9uKClgIG9yIGBhdXRvQ3JlYXRlYCBzZXQgdG8gdHJ1ZS5cbiAqXG4gKiAjIyMjIE9wdGlvbnMgZm9yIE5lc3RlZCBTY2hlbWFzOlxuICpcbiAqIC0gYGV4Y2x1ZGVJbmRleGVzYDogYm9vbCAtIGRlZmF1bHRzIHRvIGBmYWxzZWAuIElmIGB0cnVlYCwgc2tpcCBidWlsZGluZyBpbmRleGVzIG9uIHRoaXMgc2NoZW1hJ3MgcGF0aHMuXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIF9XaGVuIG5lc3Rpbmcgc2NoZW1hcywgKGBjaGlsZHJlbmAgaW4gdGhlIGV4YW1wbGUgYWJvdmUpLCBhbHdheXMgZGVjbGFyZSB0aGUgY2hpbGQgc2NoZW1hIGZpcnN0IGJlZm9yZSBwYXNzaW5nIGl0IGludG8gaXRzIHBhcmVudC5fXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U2NoZW1hfEFycmF5fSBbZGVmaW5pdGlvbl0gQ2FuIGJlIG9uZSBvZjogb2JqZWN0IGRlc2NyaWJpbmcgc2NoZW1hIHBhdGhzLCBvciBzY2hlbWEgdG8gY29weSwgb3IgYXJyYXkgb2Ygb2JqZWN0cyBhbmQgc2NoZW1hc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQGluaGVyaXRzIE5vZGVKUyBFdmVudEVtaXR0ZXIgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9ldmVudHMuaHRtbCNjbGFzcy1ldmVudGVtaXR0ZXJcbiAqIEBldmVudCBgaW5pdGA6IEVtaXR0ZWQgYWZ0ZXIgdGhlIHNjaGVtYSBpcyBjb21waWxlZCBpbnRvIGEgYE1vZGVsYC5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU2NoZW1hKG9iaiwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2NoZW1hKSkge1xuICAgIHJldHVybiBuZXcgU2NoZW1hKG9iaiwgb3B0aW9ucyk7XG4gIH1cblxuICB0aGlzLm9iaiA9IG9iajtcbiAgdGhpcy5wYXRocyA9IHt9O1xuICB0aGlzLmFsaWFzZXMgPSB7fTtcbiAgdGhpcy5zdWJwYXRocyA9IHt9O1xuICB0aGlzLnZpcnR1YWxzID0ge307XG4gIHRoaXMuc2luZ2xlTmVzdGVkUGF0aHMgPSB7fTtcbiAgdGhpcy5uZXN0ZWQgPSB7fTtcbiAgdGhpcy5pbmhlcml0cyA9IHt9O1xuICB0aGlzLmNhbGxRdWV1ZSA9IFtdO1xuICB0aGlzLl9pbmRleGVzID0gW107XG4gIHRoaXMuX3NlYXJjaEluZGV4ZXMgPSBbXTtcbiAgdGhpcy5tZXRob2RzID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5tZXRob2RzKSB8fCB7fTtcbiAgdGhpcy5tZXRob2RPcHRpb25zID0ge307XG4gIHRoaXMuc3RhdGljcyA9IChvcHRpb25zICYmIG9wdGlvbnMuc3RhdGljcykgfHwge307XG4gIHRoaXMudHJlZSA9IHt9O1xuICB0aGlzLnF1ZXJ5ID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5xdWVyeSkgfHwge307XG4gIHRoaXMuY2hpbGRTY2hlbWFzID0gW107XG4gIHRoaXMucGx1Z2lucyA9IFtdO1xuICAvLyBGb3IgaW50ZXJuYWwgZGVidWdnaW5nLiBEbyBub3QgdXNlIHRoaXMgdG8gdHJ5IHRvIHNhdmUgYSBzY2hlbWEgaW4gTURCLlxuICB0aGlzLiRpZCA9ICsraWQ7XG4gIHRoaXMubWFwUGF0aHMgPSBbXTtcblxuICB0aGlzLnMgPSB7XG4gICAgaG9va3M6IG5ldyBLYXJlZW0oKVxuICB9O1xuICB0aGlzLm9wdGlvbnMgPSB0aGlzLmRlZmF1bHRPcHRpb25zKG9wdGlvbnMpO1xuXG4gIC8vIGJ1aWxkIHBhdGhzXG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICBmb3IgKGNvbnN0IGRlZmluaXRpb24gb2Ygb2JqKSB7XG4gICAgICB0aGlzLmFkZChkZWZpbml0aW9uKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAob2JqKSB7XG4gICAgdGhpcy5hZGQob2JqKTtcbiAgfVxuXG4gIC8vIGJ1aWxkIHZpcnR1YWwgcGF0aHNcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy52aXJ0dWFscykge1xuICAgIGNvbnN0IHZpcnR1YWxzID0gb3B0aW9ucy52aXJ0dWFscztcbiAgICBjb25zdCBwYXRoTmFtZXMgPSBPYmplY3Qua2V5cyh2aXJ0dWFscyk7XG4gICAgZm9yIChjb25zdCBwYXRoTmFtZSBvZiBwYXRoTmFtZXMpIHtcbiAgICAgIGNvbnN0IHBhdGhPcHRpb25zID0gdmlydHVhbHNbcGF0aE5hbWVdLm9wdGlvbnMgPyB2aXJ0dWFsc1twYXRoTmFtZV0ub3B0aW9ucyA6IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IHZpcnR1YWwgPSB0aGlzLnZpcnR1YWwocGF0aE5hbWUsIHBhdGhPcHRpb25zKTtcblxuICAgICAgaWYgKHZpcnR1YWxzW3BhdGhOYW1lXS5nZXQpIHtcbiAgICAgICAgdmlydHVhbC5nZXQodmlydHVhbHNbcGF0aE5hbWVdLmdldCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2aXJ0dWFsc1twYXRoTmFtZV0uc2V0KSB7XG4gICAgICAgIHZpcnR1YWwuc2V0KHZpcnR1YWxzW3BhdGhOYW1lXS5zZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIGlmIF9pZCdzIHZhbHVlIGlzIGEgc3ViZG9jdW1lbnQgKGdoLTIyNzYpXG4gIGNvbnN0IF9pZFN1YkRvYyA9IG9iaiAmJiBvYmouX2lkICYmIHV0aWxzLmlzT2JqZWN0KG9iai5faWQpO1xuXG4gIC8vIGVuc3VyZSB0aGUgZG9jdW1lbnRzIGdldCBhbiBhdXRvIF9pZCB1bmxlc3MgZGlzYWJsZWRcbiAgY29uc3QgYXV0b19pZCA9ICF0aGlzLnBhdGhzWydfaWQnXSAmJlxuICAgICAgKHRoaXMub3B0aW9ucy5faWQpICYmICFfaWRTdWJEb2M7XG5cbiAgaWYgKGF1dG9faWQpIHtcbiAgICBhZGRBdXRvSWQodGhpcyk7XG4gIH1cblxuICB0aGlzLnNldHVwVGltZXN0YW1wKHRoaXMub3B0aW9ucy50aW1lc3RhbXBzKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgdmlydHVhbCBwcm9wZXJ0aWVzIHdpdGggYWxpYXMgZmllbGRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhbGlhc0ZpZWxkcyhzY2hlbWEsIHBhdGhzKSB7XG4gIGZvciAoY29uc3QgcGF0aCBvZiBPYmplY3Qua2V5cyhwYXRocykpIHtcbiAgICBsZXQgYWxpYXMgPSBudWxsO1xuICAgIGlmIChwYXRoc1twYXRoXSAhPSBudWxsKSB7XG4gICAgICBhbGlhcyA9IHBhdGhzW3BhdGhdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gZ2V0KHNjaGVtYS5wYXRoc1twYXRoXSwgJ29wdGlvbnMnKTtcbiAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGFsaWFzID0gb3B0aW9ucy5hbGlhcztcbiAgICB9XG5cbiAgICBpZiAoIWFsaWFzKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9wID0gc2NoZW1hLnBhdGhzW3BhdGhdLnBhdGg7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYWxpYXMpKSB7XG4gICAgICBmb3IgKGNvbnN0IGEgb2YgYWxpYXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZSBmb3IgYWxpYXMgb3B0aW9uIG9uICcgKyBwcm9wICsgJywgZ290ICcgKyBhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjaGVtYS5hbGlhc2VzW2FdID0gcHJvcDtcblxuICAgICAgICBzY2hlbWEuXG4gICAgICAgICAgdmlydHVhbChhKS5cbiAgICAgICAgICBnZXQoKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdGhpc1twXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSkocHJvcCkpLlxuICAgICAgICAgIHNldCgoZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHNldChwLCB2KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSkocHJvcCkpO1xuICAgICAgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGFsaWFzICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBhbGlhcyBvcHRpb24gb24gJyArIHByb3AgKyAnLCBnb3QgJyArIGFsaWFzKTtcbiAgICB9XG5cbiAgICBzY2hlbWEuYWxpYXNlc1thbGlhc10gPSBwcm9wO1xuXG4gICAgc2NoZW1hLlxuICAgICAgdmlydHVhbChhbGlhcykuXG4gICAgICBnZXQoKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5nZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXNbcF07XG4gICAgICAgIH07XG4gICAgICB9KShwcm9wKSkuXG4gICAgICBzZXQoKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy4kc2V0KHAsIHYpO1xuICAgICAgICB9O1xuICAgICAgfSkocHJvcCkpO1xuICB9XG59XG5cbi8qIVxuICogSW5oZXJpdCBmcm9tIEV2ZW50RW1pdHRlci5cbiAqL1xuU2NoZW1hLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5TY2hlbWEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2NoZW1hO1xuU2NoZW1hLnByb3RvdHlwZS5pbnN0YW5jZU9mU2NoZW1hID0gdHJ1ZTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU2NoZW1hLnByb3RvdHlwZSwgJyRzY2hlbWFUeXBlJywge1xuICBjb25maWd1cmFibGU6IGZhbHNlLFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgd3JpdGFibGU6IHRydWVcbn0pO1xuXG4vKipcbiAqIEFycmF5IG9mIGNoaWxkIHNjaGVtYXMgKGZyb20gZG9jdW1lbnQgYXJyYXlzIGFuZCBzaW5nbGUgbmVzdGVkIHN1YmRvY3MpXG4gKiBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBjb21waWxlZCBtb2RlbHMuIEVhY2ggZWxlbWVudCBvZiB0aGUgYXJyYXkgaXNcbiAqIGFuIG9iamVjdCB3aXRoIDIgcHJvcGVydGllczogYHNjaGVtYWAgYW5kIGBtb2RlbGAuXG4gKlxuICogVGhpcyBwcm9wZXJ0eSBpcyB0eXBpY2FsbHkgb25seSB1c2VmdWwgZm9yIHBsdWdpbiBhdXRob3JzIGFuZCBhZHZhbmNlZCB1c2Vycy5cbiAqIFlvdSBkbyBub3QgbmVlZCB0byBpbnRlcmFjdCB3aXRoIHRoaXMgcHJvcGVydHkgYXQgYWxsIHRvIHVzZSBtb25nb29zZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IGNoaWxkU2NoZW1hc1xuICogQG1lbWJlck9mIFNjaGVtYVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYS5wcm90b3R5cGUsICdjaGlsZFNjaGVtYXMnLCB7XG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlXG59KTtcblxuLyoqXG4gKiBPYmplY3QgY29udGFpbmluZyBhbGwgdmlydHVhbHMgZGVmaW5lZCBvbiB0aGlzIHNjaGVtYS5cbiAqIFRoZSBvYmplY3RzJyBrZXlzIGFyZSB0aGUgdmlydHVhbCBwYXRocyBhbmQgdmFsdWVzIGFyZSBpbnN0YW5jZXMgb2YgYFZpcnR1YWxUeXBlYC5cbiAqXG4gKiBUaGlzIHByb3BlcnR5IGlzIHR5cGljYWxseSBvbmx5IHVzZWZ1bCBmb3IgcGx1Z2luIGF1dGhvcnMgYW5kIGFkdmFuY2VkIHVzZXJzLlxuICogWW91IGRvIG5vdCBuZWVkIHRvIGludGVyYWN0IHdpdGggdGhpcyBwcm9wZXJ0eSBhdCBhbGwgdG8gdXNlIG1vbmdvb3NlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7fSk7XG4gKiAgICAgc2NoZW1hLnZpcnR1YWwoJ2Fuc3dlcicpLmdldCgoKSA9PiA0Mik7XG4gKlxuICogICAgIGNvbnNvbGUubG9nKHNjaGVtYS52aXJ0dWFscyk7IC8vIHsgYW5zd2VyOiBWaXJ0dWFsVHlwZSB7IHBhdGg6ICdhbnN3ZXInLCAuLi4gfSB9XG4gKiAgICAgY29uc29sZS5sb2coc2NoZW1hLnZpcnR1YWxzWydhbnN3ZXInXS5nZXR0ZXJzWzBdLmNhbGwoKSk7IC8vIDQyXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwcm9wZXJ0eSB2aXJ0dWFsc1xuICogQG1lbWJlck9mIFNjaGVtYVxuICogQGluc3RhbmNlXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYS5wcm90b3R5cGUsICd2aXJ0dWFscycsIHtcbiAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWVcbn0pO1xuXG4vKipcbiAqIFRoZSBvcmlnaW5hbCBvYmplY3QgcGFzc2VkIHRvIHRoZSBzY2hlbWEgY29uc3RydWN0b3JcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBhOiBTdHJpbmcgfSkuYWRkKHsgYjogU3RyaW5nIH0pO1xuICogICAgIHNjaGVtYS5vYmo7IC8vIHsgYTogU3RyaW5nIH1cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5IG9ialxuICogQG1lbWJlck9mIFNjaGVtYVxuICogQGluc3RhbmNlXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5vYmo7XG5cbi8qKlxuICogVGhlIHBhdGhzIGRlZmluZWQgb24gdGhpcyBzY2hlbWEuIFRoZSBrZXlzIGFyZSB0aGUgdG9wLWxldmVsIHBhdGhzXG4gKiBpbiB0aGlzIHNjaGVtYSwgYW5kIHRoZSB2YWx1ZXMgYXJlIGluc3RhbmNlcyBvZiB0aGUgU2NoZW1hVHlwZSBjbGFzcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSwgeyBfaWQ6IGZhbHNlIH0pO1xuICogICAgIHNjaGVtYS5wYXRoczsgLy8geyBuYW1lOiBTY2hlbWFTdHJpbmcgeyAuLi4gfSB9XG4gKlxuICogICAgIHNjaGVtYS5hZGQoeyBhZ2U6IE51bWJlciB9KTtcbiAqICAgICBzY2hlbWEucGF0aHM7IC8vIHsgbmFtZTogU2NoZW1hU3RyaW5nIHsgLi4uIH0sIGFnZTogU2NoZW1hTnVtYmVyIHsgLi4uIH0gfVxuICpcbiAqIEBhcGkgcHVibGljXG4gKiBAcHJvcGVydHkgcGF0aHNcbiAqIEBtZW1iZXJPZiBTY2hlbWFcbiAqIEBpbnN0YW5jZVxuICovXG5cblNjaGVtYS5wcm90b3R5cGUucGF0aHM7XG5cbi8qKlxuICogU2NoZW1hIGFzIGEgdHJlZVxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAge1xuICogICAgICAgICAnX2lkJyAgICAgOiBPYmplY3RJZFxuICogICAgICAgLCAnbmVzdGVkJyAgOiB7XG4gKiAgICAgICAgICAgICAna2V5JyA6IFN0cmluZ1xuICogICAgICAgICB9XG4gKiAgICAgfVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICogQHByb3BlcnR5IHRyZWVcbiAqIEBtZW1iZXJPZiBTY2hlbWFcbiAqIEBpbnN0YW5jZVxuICovXG5cblNjaGVtYS5wcm90b3R5cGUudHJlZTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZGVlcCBjb3B5IG9mIHRoZSBzY2hlbWFcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSk7XG4gKiAgICAgY29uc3QgY2xvbmUgPSBzY2hlbWEuY2xvbmUoKTtcbiAqICAgICBjbG9uZSA9PT0gc2NoZW1hOyAvLyBmYWxzZVxuICogICAgIGNsb25lLnBhdGgoJ25hbWUnKTsgLy8gU2NoZW1hU3RyaW5nIHsgLi4uIH1cbiAqXG4gKiBAcmV0dXJuIHtTY2hlbWF9IHRoZSBjbG9uZWQgc2NoZW1hXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIFNjaGVtYVxuICogQGluc3RhbmNlXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBzID0gdGhpcy5fY2xvbmUoKTtcblxuICAvLyBCdWJibGUgdXAgYGluaXRgIGZvciBiYWNrd2FyZHMgY29tcGF0XG4gIHMub24oJ2luaXQnLCB2ID0+IHRoaXMuZW1pdCgnaW5pdCcsIHYpKTtcblxuICByZXR1cm4gcztcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5fY2xvbmUgPSBmdW5jdGlvbiBfY2xvbmUoQ29uc3RydWN0b3IpIHtcbiAgQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvciB8fCAodGhpcy5iYXNlID09IG51bGwgPyBTY2hlbWEgOiB0aGlzLmJhc2UuU2NoZW1hKTtcblxuICBjb25zdCBzID0gbmV3IENvbnN0cnVjdG9yKHt9LCB0aGlzLl91c2VyUHJvdmlkZWRPcHRpb25zKTtcbiAgcy5iYXNlID0gdGhpcy5iYXNlO1xuICBzLm9iaiA9IHRoaXMub2JqO1xuICBzLm9wdGlvbnMgPSBjbG9uZSh0aGlzLm9wdGlvbnMpO1xuICBzLmNhbGxRdWV1ZSA9IHRoaXMuY2FsbFF1ZXVlLm1hcChmdW5jdGlvbihmKSB7IHJldHVybiBmOyB9KTtcbiAgcy5tZXRob2RzID0gY2xvbmUodGhpcy5tZXRob2RzKTtcbiAgcy5tZXRob2RPcHRpb25zID0gY2xvbmUodGhpcy5tZXRob2RPcHRpb25zKTtcbiAgcy5zdGF0aWNzID0gY2xvbmUodGhpcy5zdGF0aWNzKTtcbiAgcy5xdWVyeSA9IGNsb25lKHRoaXMucXVlcnkpO1xuICBzLnBsdWdpbnMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLnBsdWdpbnMpO1xuICBzLl9pbmRleGVzID0gY2xvbmUodGhpcy5faW5kZXhlcyk7XG4gIHMuX3NlYXJjaEluZGV4ZXMgPSBjbG9uZSh0aGlzLl9zZWFyY2hJbmRleGVzKTtcbiAgcy5zLmhvb2tzID0gdGhpcy5zLmhvb2tzLmNsb25lKCk7XG5cbiAgcy50cmVlID0gY2xvbmUodGhpcy50cmVlKTtcbiAgcy5wYXRocyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyh0aGlzLnBhdGhzKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gKFtrZXksIHZhbHVlLmNsb25lKCldKSlcbiAgKTtcbiAgcy5uZXN0ZWQgPSBjbG9uZSh0aGlzLm5lc3RlZCk7XG4gIHMuc3VicGF0aHMgPSBjbG9uZSh0aGlzLnN1YnBhdGhzKTtcbiAgZm9yIChjb25zdCBzY2hlbWFUeXBlIG9mIE9iamVjdC52YWx1ZXMocy5wYXRocykpIHtcbiAgICBpZiAoc2NoZW1hVHlwZS4kaXNTaW5nbGVOZXN0ZWQpIHtcbiAgICAgIGNvbnN0IHBhdGggPSBzY2hlbWFUeXBlLnBhdGg7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzY2hlbWFUeXBlLnNjaGVtYS5wYXRocykpIHtcbiAgICAgICAgcy5zaW5nbGVOZXN0ZWRQYXRoc1twYXRoICsgJy4nICsga2V5XSA9IHNjaGVtYVR5cGUuc2NoZW1hLnBhdGhzW2tleV07XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzY2hlbWFUeXBlLnNjaGVtYS5zaW5nbGVOZXN0ZWRQYXRocykpIHtcbiAgICAgICAgcy5zaW5nbGVOZXN0ZWRQYXRoc1twYXRoICsgJy4nICsga2V5XSA9XG4gICAgICAgICAgc2NoZW1hVHlwZS5zY2hlbWEuc2luZ2xlTmVzdGVkUGF0aHNba2V5XTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjaGVtYVR5cGUuc2NoZW1hLnN1YnBhdGhzKSkge1xuICAgICAgICBzLnNpbmdsZU5lc3RlZFBhdGhzW3BhdGggKyAnLicgKyBrZXldID1cbiAgICAgICAgICBzY2hlbWFUeXBlLnNjaGVtYS5zdWJwYXRoc1trZXldO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NoZW1hVHlwZS5zY2hlbWEubmVzdGVkKSkge1xuICAgICAgICBzLnNpbmdsZU5lc3RlZFBhdGhzW3BhdGggKyAnLicgKyBrZXldID0gJ25lc3RlZCc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHMuY2hpbGRTY2hlbWFzID0gZ2F0aGVyQ2hpbGRTY2hlbWFzKHMpO1xuXG4gIHMudmlydHVhbHMgPSBjbG9uZSh0aGlzLnZpcnR1YWxzKTtcbiAgcy4kZ2xvYmFsUGx1Z2luc0FwcGxpZWQgPSB0aGlzLiRnbG9iYWxQbHVnaW5zQXBwbGllZDtcbiAgcy4kaXNSb290RGlzY3JpbWluYXRvciA9IHRoaXMuJGlzUm9vdERpc2NyaW1pbmF0b3I7XG4gIHMuJGltcGxpY2l0bHlDcmVhdGVkID0gdGhpcy4kaW1wbGljaXRseUNyZWF0ZWQ7XG4gIHMuJGlkID0gKytpZDtcbiAgcy4kb3JpZ2luYWxTY2hlbWFJZCA9IHRoaXMuJGlkO1xuICBzLm1hcFBhdGhzID0gW10uY29uY2F0KHRoaXMubWFwUGF0aHMpO1xuXG4gIGlmICh0aGlzLmRpc2NyaW1pbmF0b3JNYXBwaW5nICE9IG51bGwpIHtcbiAgICBzLmRpc2NyaW1pbmF0b3JNYXBwaW5nID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5kaXNjcmltaW5hdG9yTWFwcGluZyk7XG4gIH1cbiAgaWYgKHRoaXMuZGlzY3JpbWluYXRvcnMgIT0gbnVsbCkge1xuICAgIHMuZGlzY3JpbWluYXRvcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmRpc2NyaW1pbmF0b3JzKTtcbiAgfVxuICBpZiAodGhpcy5fYXBwbHlEaXNjcmltaW5hdG9ycyAhPSBudWxsKSB7XG4gICAgcy5fYXBwbHlEaXNjcmltaW5hdG9ycyA9IG5ldyBNYXAodGhpcy5fYXBwbHlEaXNjcmltaW5hdG9ycyk7XG4gIH1cblxuICBzLmFsaWFzZXMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmFsaWFzZXMpO1xuXG4gIHJldHVybiBzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IHNjaGVtYSB0aGF0IGhhcyB0aGUgcGlja2VkIGBwYXRoc2AgZnJvbSB0aGlzIHNjaGVtYS5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBhbmFsYWdvdXMgdG8gW0xvZGFzaCdzIGBwaWNrKClgIGZ1bmN0aW9uXShodHRwczovL2xvZGFzaC5jb20vZG9jcy80LjE3LjE1I3BpY2spIGZvciBNb25nb29zZSBzY2hlbWFzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gU2NoZW1hKHsgbmFtZTogU3RyaW5nLCBhZ2U6IE51bWJlciB9KTtcbiAqICAgICAvLyBDcmVhdGVzIGEgbmV3IHNjaGVtYSB3aXRoIHRoZSBzYW1lIGBuYW1lYCBwYXRoIGFzIGBzY2hlbWFgLFxuICogICAgIC8vIGJ1dCBubyBgYWdlYCBwYXRoLlxuICogICAgIGNvbnN0IG5ld1NjaGVtYSA9IHNjaGVtYS5waWNrKFsnbmFtZSddKTtcbiAqXG4gKiAgICAgbmV3U2NoZW1hLnBhdGgoJ25hbWUnKTsgLy8gU2NoZW1hU3RyaW5nIHsgLi4uIH1cbiAqICAgICBuZXdTY2hlbWEucGF0aCgnYWdlJyk7IC8vIHVuZGVmaW5lZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nW119IHBhdGhzIExpc3Qgb2YgUGF0aHMgdG8gcGljayBmb3IgdGhlIG5ldyBTY2hlbWFcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyB0byBwYXNzIHRvIHRoZSBuZXcgU2NoZW1hIENvbnN0cnVjdG9yIChzYW1lIGFzIGBuZXcgU2NoZW1hKC4uLCBPcHRpb25zKWApLiBEZWZhdWx0cyB0byBgdGhpcy5vcHRpb25zYCBpZiBub3Qgc2V0LlxuICogQHJldHVybiB7U2NoZW1hfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLnBpY2sgPSBmdW5jdGlvbihwYXRocywgb3B0aW9ucykge1xuICBjb25zdCBuZXdTY2hlbWEgPSBuZXcgU2NoZW1hKHt9LCBvcHRpb25zIHx8IHRoaXMub3B0aW9ucyk7XG4gIGlmICghQXJyYXkuaXNBcnJheShwYXRocykpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcignU2NoZW1hI3BpY2soKSBvbmx5IGFjY2VwdHMgYW4gYXJyYXkgYXJndW1lbnQsICcgK1xuICAgICAgJ2dvdCBcIicgKyB0eXBlb2YgcGF0aHMgKyAnXCInKTtcbiAgfVxuXG4gIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgIGlmICh0aGlzLm5lc3RlZFtwYXRoXSkge1xuICAgICAgbmV3U2NoZW1hLmFkZCh7IFtwYXRoXTogZ2V0KHRoaXMudHJlZSwgcGF0aCkgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNjaGVtYXR5cGUgPSB0aGlzLnBhdGgocGF0aCk7XG4gICAgICBpZiAoc2NoZW1hdHlwZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdQYXRoIGAnICsgcGF0aCArICdgIGlzIG5vdCBpbiB0aGUgc2NoZW1hJyk7XG4gICAgICB9XG4gICAgICBuZXdTY2hlbWEuYWRkKHsgW3BhdGhdOiBzY2hlbWF0eXBlIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdTY2hlbWE7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgc2NoZW1hIHRoYXQgaGFzIHRoZSBgcGF0aHNgIGZyb20gdGhlIG9yaWdpbmFsIHNjaGVtYSwgbWludXMgdGhlIG9taXR0ZWQgb25lcy5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBhbmFsYWdvdXMgdG8gW0xvZGFzaCdzIGBvbWl0KClgIGZ1bmN0aW9uXShodHRwczovL2xvZGFzaC5jb20vZG9jcy8jb21pdCkgZm9yIE1vbmdvb3NlIHNjaGVtYXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBTY2hlbWEoeyBuYW1lOiBTdHJpbmcsIGFnZTogTnVtYmVyIH0pO1xuICogICAgIC8vIENyZWF0ZXMgYSBuZXcgc2NoZW1hIG9taXR0aW5nIHRoZSBgYWdlYCBwYXRoXG4gKiAgICAgY29uc3QgbmV3U2NoZW1hID0gc2NoZW1hLm9taXQoWydhZ2UnXSk7XG4gKlxuICogICAgIG5ld1NjaGVtYS5wYXRoKCduYW1lJyk7IC8vIFNjaGVtYVN0cmluZyB7IC4uLiB9XG4gKiAgICAgbmV3U2NoZW1hLnBhdGgoJ2FnZScpOyAvLyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ1tdfSBwYXRocyBMaXN0IG9mIFBhdGhzIHRvIG9taXQgZm9yIHRoZSBuZXcgU2NoZW1hXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgdG8gcGFzcyB0byB0aGUgbmV3IFNjaGVtYSBDb25zdHJ1Y3RvciAoc2FtZSBhcyBgbmV3IFNjaGVtYSguLiwgT3B0aW9ucylgKS4gRGVmYXVsdHMgdG8gYHRoaXMub3B0aW9uc2AgaWYgbm90IHNldC5cbiAqIEByZXR1cm4ge1NjaGVtYX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5vbWl0ID0gZnVuY3Rpb24ocGF0aHMsIG9wdGlvbnMpIHtcbiAgY29uc3QgbmV3U2NoZW1hID0gbmV3IFNjaGVtYSh0aGlzLCBvcHRpb25zIHx8IHRoaXMub3B0aW9ucyk7XG4gIGlmICghQXJyYXkuaXNBcnJheShwYXRocykpIHtcbiAgICB0aHJvdyBuZXcgTW9uZ29vc2VFcnJvcihcbiAgICAgICdTY2hlbWEjb21pdCgpIG9ubHkgYWNjZXB0cyBhbiBhcnJheSBhcmd1bWVudCwgJyArXG4gICAgICAgICdnb3QgXCInICtcbiAgICAgICAgdHlwZW9mIHBhdGhzICtcbiAgICAgICAgJ1wiJ1xuICAgICk7XG4gIH1cblxuICBuZXdTY2hlbWEucmVtb3ZlKHBhdGhzKTtcblxuICBmb3IgKGNvbnN0IG5lc3RlZCBpbiBuZXdTY2hlbWEuc2luZ2xlTmVzdGVkUGF0aHMpIHtcbiAgICBpZiAocGF0aHMuaW5jbHVkZXMobmVzdGVkKSkge1xuICAgICAgZGVsZXRlIG5ld1NjaGVtYS5zaW5nbGVOZXN0ZWRQYXRoc1tuZXN0ZWRdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdTY2hlbWE7XG59O1xuXG4vKipcbiAqIFJldHVybnMgZGVmYXVsdCBvcHRpb25zIGZvciB0aGlzIHNjaGVtYSwgbWVyZ2VkIHdpdGggYG9wdGlvbnNgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyB0byBvdmVyd3JpdGUgdGhlIGRlZmF1bHQgb3B0aW9uc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgbWVyZ2VkIG9wdGlvbnMgb2YgYG9wdGlvbnNgIGFuZCB0aGUgZGVmYXVsdCBvcHRpb25zXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLmRlZmF1bHRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB0aGlzLl91c2VyUHJvdmlkZWRPcHRpb25zID0gb3B0aW9ucyA9PSBudWxsID8ge30gOiBjbG9uZShvcHRpb25zKTtcbiAgY29uc3QgYmFzZU9wdGlvbnMgPSB0aGlzLmJhc2UgJiYgdGhpcy5iYXNlLm9wdGlvbnMgfHwge307XG4gIGNvbnN0IHN0cmljdCA9ICdzdHJpY3QnIGluIGJhc2VPcHRpb25zID8gYmFzZU9wdGlvbnMuc3RyaWN0IDogdHJ1ZTtcbiAgY29uc3Qgc3RyaWN0UXVlcnkgPSAnc3RyaWN0UXVlcnknIGluIGJhc2VPcHRpb25zID8gYmFzZU9wdGlvbnMuc3RyaWN0UXVlcnkgOiBmYWxzZTtcbiAgY29uc3QgaWQgPSAnaWQnIGluIGJhc2VPcHRpb25zID8gYmFzZU9wdGlvbnMuaWQgOiB0cnVlO1xuICBvcHRpb25zID0ge1xuICAgIHN0cmljdCxcbiAgICBzdHJpY3RRdWVyeSxcbiAgICBidWZmZXJDb21tYW5kczogdHJ1ZSxcbiAgICBjYXBwZWQ6IGZhbHNlLCAvLyB7IHNpemUsIG1heCwgYXV0b0luZGV4SWQgfVxuICAgIHZlcnNpb25LZXk6ICdfX3YnLFxuICAgIG9wdGltaXN0aWNDb25jdXJyZW5jeTogZmFsc2UsXG4gICAgbWluaW1pemU6IHRydWUsXG4gICAgYXV0b0luZGV4OiBudWxsLFxuICAgIGRpc2NyaW1pbmF0b3JLZXk6ICdfX3QnLFxuICAgIHNoYXJkS2V5OiBudWxsLFxuICAgIHJlYWQ6IG51bGwsXG4gICAgdmFsaWRhdGVCZWZvcmVTYXZlOiB0cnVlLFxuICAgIHZhbGlkYXRlTW9kaWZpZWRPbmx5OiBmYWxzZSxcbiAgICAvLyB0aGUgZm9sbG93aW5nIGFyZSBvbmx5IGFwcGxpZWQgYXQgY29uc3RydWN0aW9uIHRpbWVcbiAgICBfaWQ6IHRydWUsXG4gICAgaWQ6IGlkLFxuICAgIHR5cGVLZXk6ICd0eXBlJyxcbiAgICAuLi5vcHRpb25zXG4gIH07XG5cbiAgaWYgKG9wdGlvbnMudmVyc2lvbktleSAmJiB0eXBlb2Ygb3B0aW9ucy52ZXJzaW9uS2V5ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdgdmVyc2lvbktleWAgbXVzdCBiZSBmYWxzeSBvciBzdHJpbmcsIGdvdCBgJyArICh0eXBlb2Ygb3B0aW9ucy52ZXJzaW9uS2V5KSArICdgJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ3N0cmluZycpIHtcbiAgICBvcHRpb25zLnJlYWQgPSBoYW5kbGVSZWFkUHJlZmVyZW5jZUFsaWFzZXMob3B0aW9ucy5yZWFkKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMucmVhZCkgJiYgdHlwZW9mIG9wdGlvbnMucmVhZFswXSA9PT0gJ3N0cmluZycpIHtcbiAgICBvcHRpb25zLnJlYWQgPSB7XG4gICAgICBtb2RlOiBoYW5kbGVSZWFkUHJlZmVyZW5jZUFsaWFzZXMob3B0aW9ucy5yZWFkWzBdKSxcbiAgICAgIHRhZ3M6IG9wdGlvbnMucmVhZFsxXVxuICAgIH07XG4gIH1cblxuICBpZiAob3B0aW9ucy5vcHRpbWlzdGljQ29uY3VycmVuY3kgJiYgIW9wdGlvbnMudmVyc2lvbktleSkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdNdXN0IHNldCBgdmVyc2lvbktleWAgaWYgdXNpbmcgYG9wdGltaXN0aWNDb25jdXJyZW5jeWAnKTtcbiAgfVxuXG4gIHJldHVybiBvcHRpb25zO1xufTtcblxuLyoqXG4gKiBJbmhlcml0IGEgU2NoZW1hIGJ5IGFwcGx5aW5nIGEgZGlzY3JpbWluYXRvciBvbiBhbiBleGlzdGluZyBTY2hlbWEuXG4gKlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgZXZlbnRTY2hlbWEgPSBuZXcgbW9uZ29vc2UuU2NoZW1hKHsgdGltZXN0YW1wOiBEYXRlIH0sIHsgZGlzY3JpbWluYXRvcktleTogJ2tpbmQnIH0pO1xuICpcbiAqICAgICBjb25zdCBjbGlja2VkRXZlbnRTY2hlbWEgPSBuZXcgbW9uZ29vc2UuU2NoZW1hKHsgZWxlbWVudDogU3RyaW5nIH0sIHsgZGlzY3JpbWluYXRvcktleTogJ2tpbmQnIH0pO1xuICogICAgIGNvbnN0IENsaWNrZWRNb2RlbCA9IGV2ZW50U2NoZW1hLmRpc2NyaW1pbmF0b3IoJ2NsaWNrZWQnLCBjbGlja2VkRXZlbnRTY2hlbWEpO1xuICpcbiAqICAgICBjb25zdCBFdmVudCA9IG1vbmdvb3NlLm1vZGVsKCdFdmVudCcsIGV2ZW50U2NoZW1hKTtcbiAqXG4gKiAgICAgRXZlbnQuZGlzY3JpbWluYXRvcnNbJ2NsaWNrZWQnXTsgLy8gTW9kZWwgeyBjbGlja2VkIH1cbiAqXG4gKiAgICAgY29uc3QgZG9jID0gYXdhaXQgRXZlbnQuY3JlYXRlKHsga2luZDogJ2NsaWNrZWQnLCBlbGVtZW50OiAnI2hlcm8nIH0pO1xuICogICAgIGRvYy5lbGVtZW50OyAvLyAnI2hlcm8nXG4gKiAgICAgZG9jIGluc3RhbmNlb2YgQ2xpY2tlZE1vZGVsOyAvLyB0cnVlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGRpc2NyaW1pbmF0b3JcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWEgdGhlIGRpc2NyaW1pbmF0ZWQgU2NoZW1hXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIGRpc2NyaW1pbmF0b3Igb3B0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnZhbHVlXSB0aGUgc3RyaW5nIHN0b3JlZCBpbiB0aGUgYGRpc2NyaW1pbmF0b3JLZXlgIHByb3BlcnR5LiBJZiBub3Qgc3BlY2lmaWVkLCBNb25nb29zZSB1c2VzIHRoZSBgbmFtZWAgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jbG9uZT10cnVlXSBCeSBkZWZhdWx0LCBgZGlzY3JpbWluYXRvcigpYCBjbG9uZXMgdGhlIGdpdmVuIGBzY2hlbWFgLiBTZXQgdG8gYGZhbHNlYCB0byBza2lwIGNsb25pbmcuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm92ZXJ3cml0ZU1vZGVscz1mYWxzZV0gYnkgZGVmYXVsdCwgTW9uZ29vc2UgZG9lcyBub3QgYWxsb3cgeW91IHRvIGRlZmluZSBhIGRpc2NyaW1pbmF0b3Igd2l0aCB0aGUgc2FtZSBuYW1lIGFzIGFub3RoZXIgZGlzY3JpbWluYXRvci4gU2V0IHRoaXMgdG8gYWxsb3cgb3ZlcndyaXRpbmcgZGlzY3JpbWluYXRvcnMgd2l0aCB0aGUgc2FtZSBuYW1lLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tZXJnZUhvb2tzPXRydWVdIEJ5IGRlZmF1bHQsIE1vbmdvb3NlIG1lcmdlcyB0aGUgYmFzZSBzY2hlbWEncyBob29rcyB3aXRoIHRoZSBkaXNjcmltaW5hdG9yIHNjaGVtYSdzIGhvb2tzLiBTZXQgdGhpcyBvcHRpb24gdG8gYGZhbHNlYCB0byBtYWtlIE1vbmdvb3NlIHVzZSB0aGUgZGlzY3JpbWluYXRvciBzY2hlbWEncyBob29rcyBpbnN0ZWFkLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tZXJnZVBsdWdpbnM9dHJ1ZV0gQnkgZGVmYXVsdCwgTW9uZ29vc2UgbWVyZ2VzIHRoZSBiYXNlIHNjaGVtYSdzIHBsdWdpbnMgd2l0aCB0aGUgZGlzY3JpbWluYXRvciBzY2hlbWEncyBwbHVnaW5zLiBTZXQgdGhpcyBvcHRpb24gdG8gYGZhbHNlYCB0byBtYWtlIE1vbmdvb3NlIHVzZSB0aGUgZGlzY3JpbWluYXRvciBzY2hlbWEncyBwbHVnaW5zIGluc3RlYWQuXG4gKiBAcmV0dXJuIHtTY2hlbWF9IHRoZSBTY2hlbWEgaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblNjaGVtYS5wcm90b3R5cGUuZGlzY3JpbWluYXRvciA9IGZ1bmN0aW9uKG5hbWUsIHNjaGVtYSwgb3B0aW9ucykge1xuICB0aGlzLl9hcHBseURpc2NyaW1pbmF0b3JzID0gdGhpcy5fYXBwbHlEaXNjcmltaW5hdG9ycyB8fCBuZXcgTWFwKCk7XG4gIHRoaXMuX2FwcGx5RGlzY3JpbWluYXRvcnMuc2V0KG5hbWUsIHsgc2NoZW1hLCBvcHRpb25zIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGtleSBwYXRoIC8gc2NoZW1hIHR5cGUgcGFpcnMgdG8gdGhpcyBzY2hlbWEuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBUb3lTY2hlbWEgPSBuZXcgU2NoZW1hKCk7XG4gKiAgICAgVG95U2NoZW1hLmFkZCh7IG5hbWU6ICdzdHJpbmcnLCBjb2xvcjogJ3N0cmluZycsIHByaWNlOiAnbnVtYmVyJyB9KTtcbiAqXG4gKiAgICAgY29uc3QgVHVyYm9NYW5TY2hlbWEgPSBuZXcgU2NoZW1hKCk7XG4gKiAgICAgLy8gWW91IGNhbiBhbHNvIGBhZGQoKWAgYW5vdGhlciBzY2hlbWEgYW5kIGNvcHkgb3ZlciBhbGwgcGF0aHMsIHZpcnR1YWxzLFxuICogICAgIC8vIGdldHRlcnMsIHNldHRlcnMsIGluZGV4ZXMsIG1ldGhvZHMsIGFuZCBzdGF0aWNzLlxuICogICAgIFR1cmJvTWFuU2NoZW1hLmFkZChUb3lTY2hlbWEpLmFkZCh7IHllYXI6IE51bWJlciB9KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTY2hlbWF9IG9iaiBwbGFpbiBvYmplY3Qgd2l0aCBwYXRocyB0byBhZGQsIG9yIGFub3RoZXIgc2NoZW1hXG4gKiBAcGFyYW0ge1N0cmluZ30gW3ByZWZpeF0gcGF0aCB0byBwcmVmaXggdGhlIG5ld2x5IGFkZGVkIHBhdGhzIHdpdGhcbiAqIEByZXR1cm4ge1NjaGVtYX0gdGhlIFNjaGVtYSBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChvYmosIHByZWZpeCkge1xuICBpZiAob2JqIGluc3RhbmNlb2YgU2NoZW1hIHx8IChvYmogIT0gbnVsbCAmJiBvYmouaW5zdGFuY2VPZlNjaGVtYSkpIHtcbiAgICBtZXJnZSh0aGlzLCBvYmopO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBTcGVjaWFsIGNhc2U6IHNldHRpbmcgdG9wLWxldmVsIGBfaWRgIHRvIGZhbHNlIHNob3VsZCBjb252ZXJ0IHRvIGRpc2FibGluZ1xuICAvLyB0aGUgYF9pZGAgb3B0aW9uLiBUaGlzIGJlaGF2aW9yIG5ldmVyIHdvcmtlZCBiZWZvcmUgNS40LjExIGJ1dCBudW1lcm91c1xuICAvLyBjb2RlYmFzZXMgdXNlIGl0IChzZWUgZ2gtNzUxNiwgZ2gtNzUxMikuXG4gIGlmIChvYmouX2lkID09PSBmYWxzZSAmJiBwcmVmaXggPT0gbnVsbCkge1xuICAgIHRoaXMub3B0aW9ucy5faWQgPSBmYWxzZTtcbiAgfVxuXG4gIHByZWZpeCA9IHByZWZpeCB8fCAnJztcbiAgLy8gYXZvaWQgcHJvdG90eXBlIHBvbGx1dGlvblxuICBpZiAocHJlZml4ID09PSAnX19wcm90b19fLicgfHwgcHJlZml4ID09PSAnY29uc3RydWN0b3IuJyB8fCBwcmVmaXggPT09ICdwcm90b3R5cGUuJykge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGNvbnN0IHR5cGVLZXkgPSB0aGlzLm9wdGlvbnMudHlwZUtleTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGlmICh1dGlscy5zcGVjaWFsUHJvcGVydGllcy5oYXMoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgZnVsbFBhdGggPSBwcmVmaXggKyBrZXk7XG4gICAgY29uc3QgdmFsID0gb2JqW2tleV07XG5cbiAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdmFsdWUgZm9yIHNjaGVtYSBwYXRoIGAnICsgZnVsbFBhdGggK1xuICAgICAgICAnYCwgZ290IHZhbHVlIFwiJyArIHZhbCArICdcIicpO1xuICAgIH1cbiAgICAvLyBSZXRhaW4gYF9pZDogZmFsc2VgIGJ1dCBkb24ndCBzZXQgaXQgYXMgYSBwYXRoLCByZTogZ2gtODI3NC5cbiAgICBpZiAoa2V5ID09PSAnX2lkJyAmJiB2YWwgPT09IGZhbHNlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gRGVwcmVjYXRlIHNldHRpbmcgc2NoZW1hIHBhdGhzIHRvIHByaW1pdGl2ZSB0eXBlcyAoZ2gtNzU1OClcbiAgICBsZXQgaXNNb25nb29zZVR5cGVTdHJpbmcgPSBmYWxzZTtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIEhhbmRsZSB0aGUgY2FzZSBpbiB3aGljaCB0aGUgdHlwZSBpcyBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgKGVnLiAnZGF0ZScsICdvaWQnLCAuLi4pXG4gICAgICBjb25zdCBNb25nb29zZVR5cGVzID0gdGhpcy5iYXNlICE9IG51bGwgPyB0aGlzLmJhc2UuU2NoZW1hLlR5cGVzIDogU2NoZW1hLlR5cGVzO1xuICAgICAgY29uc3QgdXBwZXJWYWwgPSB2YWwuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB2YWwuc3Vic3RyaW5nKDEpO1xuICAgICAgaXNNb25nb29zZVR5cGVTdHJpbmcgPSBNb25nb29zZVR5cGVzW3VwcGVyVmFsXSAhPSBudWxsO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICBrZXkgIT09ICdfaWQnICYmXG4gICAgICAoKHR5cGVvZiB2YWwgIT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWwgIT09ICdmdW5jdGlvbicgJiYgIWlzTW9uZ29vc2VUeXBlU3RyaW5nKSB8fFxuICAgICAgdmFsID09IG51bGwpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHNjaGVtYSBjb25maWd1cmF0aW9uOiBcXGAke3ZhbH1cXGAgaXMgbm90IGAgK1xuICAgICAgICBgYSB2YWxpZCB0eXBlIGF0IHBhdGggXFxgJHtrZXl9XFxgLiBTZWUgYCArXG4gICAgICAgICdodHRwczovL2JpdC5seS9tb25nb29zZS1zY2hlbWF0eXBlcyBmb3IgYSBsaXN0IG9mIHZhbGlkIHNjaGVtYSB0eXBlcy4nKTtcbiAgICB9XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIFZpcnR1YWxUeXBlIHx8ICh2YWwuY29uc3RydWN0b3IgJiYgdmFsLmNvbnN0cnVjdG9yLm5hbWUgfHwgbnVsbCkgPT09ICdWaXJ0dWFsVHlwZScpIHtcbiAgICAgIHRoaXMudmlydHVhbCh2YWwpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSAmJiB2YWwubGVuZ3RoID09PSAxICYmIHZhbFswXSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBzY2hlbWEgQXJyYXkgcGF0aCBgJyArIGZ1bGxQYXRoICtcbiAgICAgICAgJ2AsIGdvdCB2YWx1ZSBcIicgKyB2YWxbMF0gKyAnXCInKTtcbiAgICB9XG5cbiAgICBpZiAoIShpc1BPSk8odmFsKSB8fCB2YWwgaW5zdGFuY2VvZiBTY2hlbWFUeXBlT3B0aW9ucykpIHtcbiAgICAgIC8vIFNwZWNpYWwtY2FzZTogTm9uLW9wdGlvbnMgZGVmaW5pdGVseSBhIHBhdGggc28gbGVhZiBhdCB0aGlzIG5vZGVcbiAgICAgIC8vIEV4YW1wbGVzOiBTY2hlbWEgaW5zdGFuY2VzLCBTY2hlbWFUeXBlIGluc3RhbmNlc1xuICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICB0aGlzLm5lc3RlZFtwcmVmaXguc3Vic3RyaW5nKDAsIHByZWZpeC5sZW5ndGggLSAxKV0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5wYXRoKHByZWZpeCArIGtleSwgdmFsKTtcbiAgICAgIGlmICh2YWxbMF0gIT0gbnVsbCAmJiAhKHZhbFswXS5pbnN0YW5jZU9mU2NoZW1hKSAmJiB1dGlscy5pc1BPSk8odmFsWzBdLmRpc2NyaW1pbmF0b3JzKSkge1xuICAgICAgICBjb25zdCBzY2hlbWFUeXBlID0gdGhpcy5wYXRoKHByZWZpeCArIGtleSk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbFswXS5kaXNjcmltaW5hdG9ycykge1xuICAgICAgICAgIHNjaGVtYVR5cGUuZGlzY3JpbWluYXRvcihrZXksIHZhbFswXS5kaXNjcmltaW5hdG9yc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmtleXModmFsKS5sZW5ndGggPCAxKSB7XG4gICAgICAvLyBTcGVjaWFsLWNhc2U6IHt9IGFsd2F5cyBpbnRlcnByZXRlZCBhcyBNaXhlZCBwYXRoIHNvIGxlYWYgYXQgdGhpcyBub2RlXG4gICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgIHRoaXMubmVzdGVkW3ByZWZpeC5zdWJzdHJpbmcoMCwgcHJlZml4Lmxlbmd0aCAtIDEpXSA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLnBhdGgoZnVsbFBhdGgsIHZhbCk7IC8vIG1peGVkIHR5cGVcbiAgICB9IGVsc2UgaWYgKCF2YWxbdHlwZUtleV0gfHwgKHR5cGVLZXkgPT09ICd0eXBlJyAmJiBpc1BPSk8odmFsLnR5cGUpICYmIHZhbC50eXBlLnR5cGUpKSB7XG4gICAgICAvLyBTcGVjaWFsLWNhc2U6IFBPSk8gd2l0aCBubyBib25hLWZpZGUgdHlwZSBrZXkgLSBpbnRlcnByZXQgYXMgdHJlZSBvZiBkZWVwIHBhdGhzIHNvIHJlY3Vyc2VcbiAgICAgIC8vIG5lc3RlZCBvYmplY3QgYHsgbGFzdDogeyBuYW1lOiBTdHJpbmcgfSB9YC4gQXZvaWQgZnVuY3Rpb25zIHdpdGggYC50eXBlYCByZTogIzEwODA3IGJlY2F1c2VcbiAgICAgIC8vIE5lc3RKUyBzb21ldGltZXMgYWRkcyBgRGF0ZS50eXBlYC5cbiAgICAgIHRoaXMubmVzdGVkW2Z1bGxQYXRoXSA9IHRydWU7XG4gICAgICB0aGlzLmFkZCh2YWwsIGZ1bGxQYXRoICsgJy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlcmUgSVMgYSBib25hLWZpZGUgdHlwZSBrZXkgdGhhdCBtYXkgYWxzbyBiZSBhIFBPSk9cbiAgICAgIGNvbnN0IF90eXBlRGVmID0gdmFsW3R5cGVLZXldO1xuICAgICAgaWYgKGlzUE9KTyhfdHlwZURlZikgJiYgT2JqZWN0LmtleXMoX3R5cGVEZWYpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gSWYgYSBQT0pPIGlzIHRoZSB2YWx1ZSBvZiBhIHR5cGUga2V5LCBtYWtlIGl0IGEgc3ViZG9jdW1lbnRcbiAgICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICAgIHRoaXMubmVzdGVkW3ByZWZpeC5zdWJzdHJpbmcoMCwgcHJlZml4Lmxlbmd0aCAtIDEpXSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjaGlsZFNjaGVtYU9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuX3VzZXJQcm92aWRlZE9wdGlvbnMudHlwZUtleSkge1xuICAgICAgICAgIGNoaWxkU2NoZW1hT3B0aW9ucy50eXBlS2V5ID0gdGhpcy5fdXNlclByb3ZpZGVkT3B0aW9ucy50eXBlS2V5O1xuICAgICAgICB9XG4gICAgICAgIC8vIHByb3BhZ2F0ZSAnc3RyaWN0JyBvcHRpb24gdG8gY2hpbGQgc2NoZW1hXG4gICAgICAgIGlmICh0aGlzLl91c2VyUHJvdmlkZWRPcHRpb25zLnN0cmljdCAhPSBudWxsKSB7XG4gICAgICAgICAgY2hpbGRTY2hlbWFPcHRpb25zLnN0cmljdCA9IHRoaXMuX3VzZXJQcm92aWRlZE9wdGlvbnMuc3RyaWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl91c2VyUHJvdmlkZWRPcHRpb25zLnRvT2JqZWN0ICE9IG51bGwpIHtcbiAgICAgICAgICBjaGlsZFNjaGVtYU9wdGlvbnMudG9PYmplY3QgPSB1dGlscy5vbWl0KHRoaXMuX3VzZXJQcm92aWRlZE9wdGlvbnMudG9PYmplY3QsIFsndHJhbnNmb3JtJ10pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl91c2VyUHJvdmlkZWRPcHRpb25zLnRvSlNPTiAhPSBudWxsKSB7XG4gICAgICAgICAgY2hpbGRTY2hlbWFPcHRpb25zLnRvSlNPTiA9IHV0aWxzLm9taXQodGhpcy5fdXNlclByb3ZpZGVkT3B0aW9ucy50b0pTT04sIFsndHJhbnNmb3JtJ10pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgX3NjaGVtYSA9IG5ldyBTY2hlbWEoX3R5cGVEZWYsIGNoaWxkU2NoZW1hT3B0aW9ucyk7XG4gICAgICAgIF9zY2hlbWEuJGltcGxpY2l0bHlDcmVhdGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3Qgc2NoZW1hV3JhcHBlZFBhdGggPSBPYmplY3QuYXNzaWduKHt9LCB2YWwsIHsgW3R5cGVLZXldOiBfc2NoZW1hIH0pO1xuICAgICAgICB0aGlzLnBhdGgocHJlZml4ICsga2V5LCBzY2hlbWFXcmFwcGVkUGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFaXRoZXIgdGhlIHR5cGUgaXMgbm9uLVBPSk8gb3Igd2UgaW50ZXJwcmV0IGl0IGFzIE1peGVkIGFueXdheVxuICAgICAgICBpZiAocHJlZml4KSB7XG4gICAgICAgICAgdGhpcy5uZXN0ZWRbcHJlZml4LnN1YnN0cmluZygwLCBwcmVmaXgubGVuZ3RoIC0gMSldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhdGgocHJlZml4ICsga2V5LCB2YWwpO1xuICAgICAgICBpZiAodmFsICE9IG51bGwgJiYgISh2YWwuaW5zdGFuY2VPZlNjaGVtYSkgJiYgdXRpbHMuaXNQT0pPKHZhbC5kaXNjcmltaW5hdG9ycykpIHtcbiAgICAgICAgICBjb25zdCBzY2hlbWFUeXBlID0gdGhpcy5wYXRoKHByZWZpeCArIGtleSk7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsLmRpc2NyaW1pbmF0b3JzKSB7XG4gICAgICAgICAgICBzY2hlbWFUeXBlLmRpc2NyaW1pbmF0b3Ioa2V5LCB2YWwuZGlzY3JpbWluYXRvcnNba2V5XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgYWxpYXNPYmogPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMob2JqKS5tYXAoKFtrZXldKSA9PiAoW3ByZWZpeCArIGtleSwgbnVsbF0pKVxuICApO1xuICBhbGlhc0ZpZWxkcyh0aGlzLCBhbGlhc09iaik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGQgYW4gYWxpYXMgZm9yIGBwYXRoYC4gVGhpcyBtZWFucyBnZXR0aW5nIG9yIHNldHRpbmcgdGhlIGBhbGlhc2BcbiAqIGlzIGVxdWl2YWxlbnQgdG8gZ2V0dGluZyBvciBzZXR0aW5nIHRoZSBgcGF0aGAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCB0b3lTY2hlbWEgPSBuZXcgU2NoZW1hKHsgbjogU3RyaW5nIH0pO1xuICpcbiAqICAgICAvLyBNYWtlICduYW1lJyBhbiBhbGlhcyBmb3IgJ24nXG4gKiAgICAgdG95U2NoZW1hLmFsaWFzKCduJywgJ25hbWUnKTtcbiAqXG4gKiAgICAgY29uc3QgVG95ID0gbW9uZ29vc2UubW9kZWwoJ1RveScsIHRveVNjaGVtYSk7XG4gKiAgICAgY29uc3QgdHVyYm9NYW4gPSBuZXcgVG95KHsgbjogJ1R1cmJvIE1hbicgfSk7XG4gKlxuICogICAgIHR1cmJvTWFuLm5hbWU7IC8vICdUdXJibyBNYW4nXG4gKiAgICAgdHVyYm9NYW4ubjsgLy8gJ1R1cmJvIE1hbidcbiAqXG4gKiAgICAgdHVyYm9NYW4ubmFtZSA9ICdUdXJibyBNYW4gQWN0aW9uIEZpZ3VyZSc7XG4gKiAgICAgdHVyYm9NYW4ubjsgLy8gJ1R1cmJvIE1hbiBBY3Rpb24gRmlndXJlJ1xuICpcbiAqICAgICBhd2FpdCB0dXJib01hbi5zYXZlKCk7IC8vIFNhdmVzIHsgX2lkOiAuLi4sIG46ICdUdXJibyBNYW4gQWN0aW9uIEZpZ3VyZScgfVxuICpcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCByZWFsIHBhdGggdG8gYWxpYXNcbiAqIEBwYXJhbSB7U3RyaW5nfFN0cmluZ1tdfSBhbGlhcyB0aGUgcGF0aChzKSB0byB1c2UgYXMgYW4gYWxpYXMgZm9yIGBwYXRoYFxuICogQHJldHVybiB7U2NoZW1hfSB0aGUgU2NoZW1hIGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYS5wcm90b3R5cGUuYWxpYXMgPSBmdW5jdGlvbiBhbGlhcyhwYXRoLCBhbGlhcykge1xuICBhbGlhc0ZpZWxkcyh0aGlzLCB7IFtwYXRoXTogYWxpYXMgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaW5kZXggYnkgbmFtZSBvciBpbmRleCBzcGVjaWZpY2F0aW9uLlxuICpcbiAqIHJlbW92ZUluZGV4IG9ubHkgcmVtb3ZlcyBpbmRleGVzIGZyb20geW91ciBzY2hlbWEgb2JqZWN0LiBEb2VzICoqbm90KiogYWZmZWN0IHRoZSBpbmRleGVzXG4gKiBpbiBNb25nb0RCLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgVG95U2NoZW1hID0gbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZywgY29sb3I6IFN0cmluZywgcHJpY2U6IE51bWJlciB9KTtcbiAqXG4gKiAgICAgLy8gQWRkIGEgbmV3IGluZGV4IG9uIHsgbmFtZSwgY29sb3IgfVxuICogICAgIFRveVNjaGVtYS5pbmRleCh7IG5hbWU6IDEsIGNvbG9yOiAxIH0pO1xuICpcbiAqICAgICAvLyBSZW1vdmUgaW5kZXggb24geyBuYW1lLCBjb2xvciB9XG4gKiAgICAgLy8gS2VlcCBpbiBtaW5kIHRoYXQgb3JkZXIgbWF0dGVycyEgYHJlbW92ZUluZGV4KHsgY29sb3I6IDEsIG5hbWU6IDEgfSlgIHdvbid0IHJlbW92ZSB0aGUgaW5kZXhcbiAqICAgICBUb3lTY2hlbWEucmVtb3ZlSW5kZXgoeyBuYW1lOiAxLCBjb2xvcjogMSB9KTtcbiAqXG4gKiAgICAgLy8gQWRkIGFuIGluZGV4IHdpdGggYSBjdXN0b20gbmFtZVxuICogICAgIFRveVNjaGVtYS5pbmRleCh7IGNvbG9yOiAxIH0sIHsgbmFtZTogJ215IGN1c3RvbSBpbmRleCBuYW1lJyB9KTtcbiAqICAgICAvLyBSZW1vdmUgaW5kZXggYnkgbmFtZVxuICogICAgIFRveVNjaGVtYS5yZW1vdmVJbmRleCgnbXkgY3VzdG9tIGluZGV4IG5hbWUnKTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IGluZGV4IG5hbWUgb3IgaW5kZXggc3BlY2lmaWNhdGlvblxuICogQHJldHVybiB7U2NoZW1hfSB0aGUgU2NoZW1hIGluc3RhbmNlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYS5wcm90b3R5cGUucmVtb3ZlSW5kZXggPSBmdW5jdGlvbiByZW1vdmVJbmRleChpbmRleCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbW92ZUluZGV4KCkgdGFrZXMgb25seSAxIGFyZ3VtZW50Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIGluZGV4ICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgaW5kZXggIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmVJbmRleCgpIG1heSBvbmx5IHRha2UgZWl0aGVyIGFuIG9iamVjdCBvciBhIHN0cmluZyBhcyBhbiBhcmd1bWVudCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5faW5kZXhlcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgaWYgKHV0aWwuaXNEZWVwU3RyaWN0RXF1YWwodGhpcy5faW5kZXhlc1tpXVswXSwgaW5kZXgpKSB7XG4gICAgICAgIHRoaXMuX2luZGV4ZXMuc3BsaWNlKGksIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5faW5kZXhlcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgaWYgKHRoaXMuX2luZGV4ZXNbaV1bMV0gIT0gbnVsbCAmJiB0aGlzLl9pbmRleGVzW2ldWzFdLm5hbWUgPT09IGluZGV4KSB7XG4gICAgICAgIHRoaXMuX2luZGV4ZXMuc3BsaWNlKGksIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGluZGV4ZXMgZnJvbSB0aGlzIHNjaGVtYS5cbiAqXG4gKiBjbGVhckluZGV4ZXMgb25seSByZW1vdmVzIGluZGV4ZXMgZnJvbSB5b3VyIHNjaGVtYSBvYmplY3QuIERvZXMgKipub3QqKiBhZmZlY3QgdGhlIGluZGV4ZXNcbiAqIGluIE1vbmdvREIuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBUb3lTY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nLCBjb2xvcjogU3RyaW5nLCBwcmljZTogTnVtYmVyIH0pO1xuICogICAgIFRveVNjaGVtYS5pbmRleCh7IG5hbWU6IDEgfSk7XG4gKiAgICAgVG95U2NoZW1hLmluZGV4KHsgY29sb3I6IDEgfSk7XG4gKlxuICogICAgIC8vIFJlbW92ZSBhbGwgaW5kZXhlcyBvbiB0aGlzIHNjaGVtYVxuICogICAgIFRveVNjaGVtYS5jbGVhckluZGV4ZXMoKTtcbiAqXG4gKiAgICAgVG95U2NoZW1hLmluZGV4ZXMoKTsgLy8gW11cbiAqXG4gKiBAcmV0dXJuIHtTY2hlbWF9IHRoZSBTY2hlbWEgaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5jbGVhckluZGV4ZXMgPSBmdW5jdGlvbiBjbGVhckluZGV4ZXMoKSB7XG4gIHRoaXMuX2luZGV4ZXMubGVuZ3RoID0gMDtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkIGFuIFtBdGxhcyBzZWFyY2ggaW5kZXhdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvYXRsYXMvYXRsYXMtc2VhcmNoL2NyZWF0ZS1pbmRleC8pIHRoYXQgTW9uZ29vc2Ugd2lsbCBjcmVhdGUgdXNpbmcgYE1vZGVsLmNyZWF0ZVNlYXJjaEluZGV4KClgLlxuICogVGhpcyBmdW5jdGlvbiBvbmx5IHdvcmtzIHdoZW4gY29ubmVjdGVkIHRvIE1vbmdvREIgQXRsYXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBUb3lTY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nLCBjb2xvcjogU3RyaW5nLCBwcmljZTogTnVtYmVyIH0pO1xuICogICAgIFRveVNjaGVtYS5zZWFyY2hJbmRleCh7IG5hbWU6ICd0ZXN0JywgZGVmaW5pdGlvbjogeyBtYXBwaW5nczogeyBkeW5hbWljOiB0cnVlIH0gfSB9KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzY3JpcHRpb24gaW5kZXggb3B0aW9ucywgaW5jbHVkaW5nIGBuYW1lYCBhbmQgYGRlZmluaXRpb25gXG4gKiBAcGFyYW0ge1N0cmluZ30gZGVzY3JpcHRpb24ubmFtZVxuICogQHBhcmFtIHtPYmplY3R9IGRlc2NyaXB0aW9uLmRlZmluaXRpb25cbiAqIEByZXR1cm4ge1NjaGVtYX0gdGhlIFNjaGVtYSBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLnNlYXJjaEluZGV4ID0gZnVuY3Rpb24gc2VhcmNoSW5kZXgoZGVzY3JpcHRpb24pIHtcbiAgdGhpcy5fc2VhcmNoSW5kZXhlcy5wdXNoKGRlc2NyaXB0aW9uKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVzZXJ2ZWQgZG9jdW1lbnQga2V5cy5cbiAqXG4gKiBLZXlzIGluIHRoaXMgb2JqZWN0IGFyZSBuYW1lcyB0aGF0IGFyZSB3YXJuZWQgaW4gc2NoZW1hIGRlY2xhcmF0aW9uc1xuICogYmVjYXVzZSB0aGV5IGhhdmUgdGhlIHBvdGVudGlhbCB0byBicmVhayBNb25nb29zZS8gTW9uZ29vc2UgcGx1Z2lucyBmdW5jdGlvbmFsaXR5LiBJZiB5b3UgY3JlYXRlIGEgc2NoZW1hXG4gKiB1c2luZyBgbmV3IFNjaGVtYSgpYCB3aXRoIG9uZSBvZiB0aGVzZSBwcm9wZXJ0eSBuYW1lcywgTW9uZ29vc2Ugd2lsbCBsb2cgYSB3YXJuaW5nLlxuICpcbiAqIC0gX3Bvc3RzXG4gKiAtIF9wcmVzXG4gKiAtIGNvbGxlY3Rpb25cbiAgKiAtIGVtaXRcbiAqIC0gZXJyb3JzXG4gKiAtIGdldFxuICogLSBpbml0XG4gKiAtIGlzTW9kaWZpZWRcbiAqIC0gaXNOZXdcbiAqIC0gbGlzdGVuZXJzXG4gKiAtIG1vZGVsTmFtZVxuICogLSBvblxuICogLSBvbmNlXG4gKiAtIHBvcHVsYXRlZFxuICogLSBwcm90b3R5cGVcbiAqIC0gcmVtb3ZlXG4gKiAtIHJlbW92ZUxpc3RlbmVyXG4gKiAtIHNhdmVcbiAqIC0gc2NoZW1hXG4gKiAtIHRvT2JqZWN0XG4gKiAtIHZhbGlkYXRlXG4gKlxuICogX05PVEU6XyBVc2Ugb2YgdGhlc2UgdGVybXMgYXMgbWV0aG9kIG5hbWVzIGlzIHBlcm1pdHRlZCwgYnV0IHBsYXkgYXQgeW91ciBvd24gcmlzaywgYXMgdGhleSBtYXkgYmUgZXhpc3RpbmcgbW9uZ29vc2UgZG9jdW1lbnQgbWV0aG9kcyB5b3UgYXJlIHN0b21waW5nIG9uLlxuICpcbiAqICAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSguLik7XG4gKiAgICAgIHNjaGVtYS5tZXRob2RzLmluaXQgPSBmdW5jdGlvbiAoKSB7fSAvLyBwb3RlbnRpYWxseSBicmVha2luZ1xuICpcbiAqIEBwcm9wZXJ0eSByZXNlcnZlZFxuICogQG1lbWJlck9mIFNjaGVtYVxuICogQHN0YXRpY1xuICovXG5cblNjaGVtYS5yZXNlcnZlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5TY2hlbWEucHJvdG90eXBlLnJlc2VydmVkID0gU2NoZW1hLnJlc2VydmVkO1xuXG5jb25zdCByZXNlcnZlZCA9IFNjaGVtYS5yZXNlcnZlZDtcbi8vIENvcmUgb2JqZWN0XG5yZXNlcnZlZFsncHJvdG90eXBlJ10gPVxuLy8gRXZlbnRFbWl0dGVyXG5yZXNlcnZlZC5lbWl0ID1cbnJlc2VydmVkLmxpc3RlbmVycyA9XG5yZXNlcnZlZC5yZW1vdmVMaXN0ZW5lciA9XG5cbi8vIGRvY3VtZW50IHByb3BlcnRpZXMgYW5kIGZ1bmN0aW9uc1xucmVzZXJ2ZWQuY29sbGVjdGlvbiA9XG5yZXNlcnZlZC5lcnJvcnMgPVxucmVzZXJ2ZWQuZ2V0ID1cbnJlc2VydmVkLmluaXQgPVxucmVzZXJ2ZWQuaXNNb2RpZmllZCA9XG5yZXNlcnZlZC5pc05ldyA9XG5yZXNlcnZlZC5wb3B1bGF0ZWQgPVxucmVzZXJ2ZWQucmVtb3ZlID1cbnJlc2VydmVkLnNhdmUgPVxucmVzZXJ2ZWQudG9PYmplY3QgPVxucmVzZXJ2ZWQudmFsaWRhdGUgPSAxO1xucmVzZXJ2ZWQuY29sbGVjdGlvbiA9IDE7XG5cbi8qKlxuICogR2V0cy9zZXRzIHNjaGVtYSBwYXRocy5cbiAqXG4gKiBTZXRzIGEgcGF0aCAoaWYgYXJpdHkgMilcbiAqIEdldHMgYSBwYXRoIChpZiBhcml0eSAxKVxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgc2NoZW1hLnBhdGgoJ25hbWUnKSAvLyByZXR1cm5zIGEgU2NoZW1hVHlwZVxuICogICAgIHNjaGVtYS5wYXRoKCduYW1lJywgTnVtYmVyKSAvLyBjaGFuZ2VzIHRoZSBzY2hlbWFUeXBlIG9mIGBuYW1lYCB0byBOdW1iZXJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBUaGUgbmFtZSBvZiB0aGUgUGF0aCB0byBnZXQgLyBzZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqXSBUaGUgVHlwZSB0byBzZXQgdGhlIHBhdGggdG8sIGlmIHByb3ZpZGVkIHRoZSBwYXRoIHdpbGwgYmUgU0VULCBvdGhlcndpc2UgdGhlIHBhdGggd2lsbCBiZSBHRVRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24ocGF0aCwgb2JqKSB7XG4gIGlmIChvYmogPT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0aGlzLnBhdGhzW3BhdGhdICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhdGhzW3BhdGhdO1xuICAgIH1cbiAgICAvLyBDb252ZXJ0IHRvICcuJCcgdG8gY2hlY2sgc3VicGF0aHMgcmU6IGdoLTY0MDVcbiAgICBjb25zdCBjbGVhblBhdGggPSBfcGF0aFRvUG9zaXRpb25hbFN5bnRheChwYXRoKTtcbiAgICBsZXQgc2NoZW1hdHlwZSA9IF9nZXRQYXRoKHRoaXMsIHBhdGgsIGNsZWFuUGF0aCk7XG4gICAgaWYgKHNjaGVtYXR5cGUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHNjaGVtYXR5cGU7XG4gICAgfVxuXG4gICAgLy8gTG9vayBmb3IgbWFwc1xuICAgIGNvbnN0IG1hcFBhdGggPSBnZXRNYXBQYXRoKHRoaXMsIHBhdGgpO1xuICAgIGlmIChtYXBQYXRoICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBtYXBQYXRoO1xuICAgIH1cblxuICAgIC8vIExvb2sgaWYgYSBwYXJlbnQgb2YgdGhpcyBwYXRoIGlzIG1peGVkXG4gICAgc2NoZW1hdHlwZSA9IHRoaXMuaGFzTWl4ZWRQYXJlbnQoY2xlYW5QYXRoKTtcbiAgICBpZiAoc2NoZW1hdHlwZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gc2NoZW1hdHlwZTtcbiAgICB9XG5cbiAgICAvLyBzdWJwYXRocz9cbiAgICByZXR1cm4gaGFzTnVtZXJpY1N1YnBhdGhSZWdleC50ZXN0KHBhdGgpXG4gICAgICA/IGdldFBvc2l0aW9uYWxQYXRoKHRoaXMsIHBhdGgsIGNsZWFuUGF0aClcbiAgICAgIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gc29tZSBwYXRoIG5hbWVzIGNvbmZsaWN0IHdpdGggZG9jdW1lbnQgbWV0aG9kc1xuICBjb25zdCBmaXJzdFBpZWNlT2ZQYXRoID0gcGF0aC5zcGxpdCgnLicpWzBdO1xuICBpZiAocmVzZXJ2ZWRbZmlyc3RQaWVjZU9mUGF0aF0gJiYgIXRoaXMub3B0aW9ucy5zdXBwcmVzc1Jlc2VydmVkS2V5c1dhcm5pbmcpIHtcbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgXFxgJHtmaXJzdFBpZWNlT2ZQYXRofVxcYCBpcyBhIHJlc2VydmVkIHNjaGVtYSBwYXRobmFtZSBhbmQgbWF5IGJyZWFrIHNvbWUgZnVuY3Rpb25hbGl0eS4gYCArXG4gICAgICAnWW91IGFyZSBhbGxvd2VkIHRvIHVzZSBpdCwgYnV0IHVzZSBhdCB5b3VyIG93biByaXNrLiAnICtcbiAgICAgICdUbyBkaXNhYmxlIHRoaXMgd2FybmluZyBwYXNzIGBzdXBwcmVzc1Jlc2VydmVkS2V5c1dhcm5pbmdgIGFzIGEgc2NoZW1hIG9wdGlvbi4nO1xuXG4gICAgdXRpbHMud2FybihlcnJvck1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHV0aWxzLmhhc1VzZXJEZWZpbmVkUHJvcGVydHkob2JqLCAncmVmJykpIHtcbiAgICB2YWxpZGF0ZVJlZihvYmoucmVmLCBwYXRoKTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSB0aGUgdHJlZVxuICBjb25zdCBzdWJwYXRocyA9IHBhdGguc3BsaXQoL1xcLi8pO1xuICBjb25zdCBsYXN0ID0gc3VicGF0aHMucG9wKCk7XG4gIGxldCBicmFuY2ggPSB0aGlzLnRyZWU7XG4gIGxldCBmdWxsUGF0aCA9ICcnO1xuXG4gIGZvciAoY29uc3Qgc3ViIG9mIHN1YnBhdGhzKSB7XG4gICAgaWYgKHV0aWxzLnNwZWNpYWxQcm9wZXJ0aWVzLmhhcyhzdWIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzZXQgc3BlY2lhbCBwcm9wZXJ0eSBgJyArIHN1YiArICdgIG9uIGEgc2NoZW1hJyk7XG4gICAgfVxuICAgIGZ1bGxQYXRoID0gZnVsbFBhdGggKz0gKGZ1bGxQYXRoLmxlbmd0aCA+IDAgPyAnLicgOiAnJykgKyBzdWI7XG4gICAgaWYgKCFicmFuY2hbc3ViXSkge1xuICAgICAgdGhpcy5uZXN0ZWRbZnVsbFBhdGhdID0gdHJ1ZTtcbiAgICAgIGJyYW5jaFtzdWJdID0ge307XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYnJhbmNoW3N1Yl0gIT09ICdvYmplY3QnKSB7XG4gICAgICBjb25zdCBtc2cgPSAnQ2Fubm90IHNldCBuZXN0ZWQgcGF0aCBgJyArIHBhdGggKyAnYC4gJ1xuICAgICAgICAgICsgJ1BhcmVudCBwYXRoIGAnXG4gICAgICAgICAgKyBmdWxsUGF0aFxuICAgICAgICAgICsgJ2AgYWxyZWFkeSBzZXQgdG8gdHlwZSAnICsgYnJhbmNoW3N1Yl0ubmFtZVxuICAgICAgICAgICsgJy4nO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuICAgIGJyYW5jaCA9IGJyYW5jaFtzdWJdO1xuICB9XG5cbiAgYnJhbmNoW2xhc3RdID0gY2xvbmUob2JqKTtcblxuICB0aGlzLnBhdGhzW3BhdGhdID0gdGhpcy5pbnRlcnByZXRBc1R5cGUocGF0aCwgb2JqLCB0aGlzLm9wdGlvbnMpO1xuICBjb25zdCBzY2hlbWFUeXBlID0gdGhpcy5wYXRoc1twYXRoXTtcblxuICBpZiAoc2NoZW1hVHlwZS4kaXNTY2hlbWFNYXApIHtcbiAgICAvLyBNYXBzIGNhbiBoYXZlIGFyYml0cmFyeSBrZXlzLCBzbyBgJCpgIGlzIGludGVybmFsIHNob3J0aGFuZCBmb3IgXCJhbnkga2V5XCJcbiAgICAvLyBUaGUgJyQnIGlzIHRvIGltcGx5IHRoaXMgcGF0aCBzaG91bGQgbmV2ZXIgYmUgc3RvcmVkIGluIE1vbmdvREIgc28gd2VcbiAgICAvLyBjYW4gZWFzaWx5IGJ1aWxkIGEgcmVnZXhwIG91dCBvZiB0aGlzIHBhdGgsIGFuZCAnKicgdG8gaW1wbHkgXCJhbnkga2V5LlwiXG4gICAgY29uc3QgbWFwUGF0aCA9IHBhdGggKyAnLiQqJztcblxuICAgIHRoaXMucGF0aHNbbWFwUGF0aF0gPSBzY2hlbWFUeXBlLiRfX3NjaGVtYVR5cGU7XG4gICAgdGhpcy5tYXBQYXRocy5wdXNoKHRoaXMucGF0aHNbbWFwUGF0aF0pO1xuICB9XG5cbiAgaWYgKHNjaGVtYVR5cGUuJGlzU2luZ2xlTmVzdGVkKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NoZW1hVHlwZS5zY2hlbWEucGF0aHMpKSB7XG4gICAgICB0aGlzLnNpbmdsZU5lc3RlZFBhdGhzW3BhdGggKyAnLicgKyBrZXldID0gc2NoZW1hVHlwZS5zY2hlbWEucGF0aHNba2V5XTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NoZW1hVHlwZS5zY2hlbWEuc2luZ2xlTmVzdGVkUGF0aHMpKSB7XG4gICAgICB0aGlzLnNpbmdsZU5lc3RlZFBhdGhzW3BhdGggKyAnLicgKyBrZXldID1cbiAgICAgICAgc2NoZW1hVHlwZS5zY2hlbWEuc2luZ2xlTmVzdGVkUGF0aHNba2V5XTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NoZW1hVHlwZS5zY2hlbWEuc3VicGF0aHMpKSB7XG4gICAgICB0aGlzLnNpbmdsZU5lc3RlZFBhdGhzW3BhdGggKyAnLicgKyBrZXldID1cbiAgICAgICAgc2NoZW1hVHlwZS5zY2hlbWEuc3VicGF0aHNba2V5XTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NoZW1hVHlwZS5zY2hlbWEubmVzdGVkKSkge1xuICAgICAgdGhpcy5zaW5nbGVOZXN0ZWRQYXRoc1twYXRoICsgJy4nICsga2V5XSA9ICduZXN0ZWQnO1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzY2hlbWFUeXBlLnNjaGVtYSwgJ2Jhc2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiB0aGlzLmJhc2VcbiAgICB9KTtcblxuICAgIHNjaGVtYVR5cGUuY2FzdGVyLmJhc2UgPSB0aGlzLmJhc2U7XG4gICAgdGhpcy5jaGlsZFNjaGVtYXMucHVzaCh7XG4gICAgICBzY2hlbWE6IHNjaGVtYVR5cGUuc2NoZW1hLFxuICAgICAgbW9kZWw6IHNjaGVtYVR5cGUuY2FzdGVyXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoc2NoZW1hVHlwZS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2NoZW1hVHlwZS5zY2hlbWEsICdiYXNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogdGhpcy5iYXNlXG4gICAgfSk7XG5cbiAgICBzY2hlbWFUeXBlLmNhc3RlckNvbnN0cnVjdG9yLmJhc2UgPSB0aGlzLmJhc2U7XG4gICAgdGhpcy5jaGlsZFNjaGVtYXMucHVzaCh7XG4gICAgICBzY2hlbWE6IHNjaGVtYVR5cGUuc2NoZW1hLFxuICAgICAgbW9kZWw6IHNjaGVtYVR5cGUuY2FzdGVyQ29uc3RydWN0b3JcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChzY2hlbWFUeXBlLiRpc01vbmdvb3NlQXJyYXkgJiYgc2NoZW1hVHlwZS5jYXN0ZXIgaW5zdGFuY2VvZiBTY2hlbWFUeXBlKSB7XG4gICAgbGV0IGFycmF5UGF0aCA9IHBhdGg7XG4gICAgbGV0IF9zY2hlbWFUeXBlID0gc2NoZW1hVHlwZTtcblxuICAgIGNvbnN0IHRvQWRkID0gW107XG4gICAgd2hpbGUgKF9zY2hlbWFUeXBlLiRpc01vbmdvb3NlQXJyYXkpIHtcbiAgICAgIGFycmF5UGF0aCA9IGFycmF5UGF0aCArICcuJCc7XG5cbiAgICAgIC8vIFNraXAgYXJyYXlzIG9mIGRvY3VtZW50IGFycmF5c1xuICAgICAgaWYgKF9zY2hlbWFUeXBlLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSkge1xuICAgICAgICBfc2NoZW1hVHlwZS4kZW1iZWRkZWRTY2hlbWFUeXBlLl9hcnJheVBhdGggPSBhcnJheVBhdGg7XG4gICAgICAgIF9zY2hlbWFUeXBlLiRlbWJlZGRlZFNjaGVtYVR5cGUuX2FycmF5UGFyZW50UGF0aCA9IHBhdGg7XG4gICAgICAgIF9zY2hlbWFUeXBlID0gX3NjaGVtYVR5cGUuJGVtYmVkZGVkU2NoZW1hVHlwZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9zY2hlbWFUeXBlLmNhc3Rlci5fYXJyYXlQYXRoID0gYXJyYXlQYXRoO1xuICAgICAgICBfc2NoZW1hVHlwZS5jYXN0ZXIuX2FycmF5UGFyZW50UGF0aCA9IHBhdGg7XG4gICAgICAgIF9zY2hlbWFUeXBlID0gX3NjaGVtYVR5cGUuY2FzdGVyO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN1YnBhdGhzW2FycmF5UGF0aF0gPSBfc2NoZW1hVHlwZTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IF9zY2hlbWFUeXBlIG9mIHRvQWRkKSB7XG4gICAgICB0aGlzLnN1YnBhdGhzW19zY2hlbWFUeXBlLnBhdGhdID0gX3NjaGVtYVR5cGU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNjaGVtYVR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NoZW1hVHlwZS5zY2hlbWEucGF0aHMpKSB7XG4gICAgICBjb25zdCBfc2NoZW1hVHlwZSA9IHNjaGVtYVR5cGUuc2NoZW1hLnBhdGhzW2tleV07XG4gICAgICB0aGlzLnN1YnBhdGhzW3BhdGggKyAnLicgKyBrZXldID0gX3NjaGVtYVR5cGU7XG4gICAgICBpZiAodHlwZW9mIF9zY2hlbWFUeXBlID09PSAnb2JqZWN0JyAmJiBfc2NoZW1hVHlwZSAhPSBudWxsICYmIF9zY2hlbWFUeXBlLiRwYXJlbnRTY2hlbWFEb2NBcnJheSA9PSBudWxsKSB7XG4gICAgICAgIF9zY2hlbWFUeXBlLiRwYXJlbnRTY2hlbWFEb2NBcnJheSA9IHNjaGVtYVR5cGU7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjaGVtYVR5cGUuc2NoZW1hLnN1YnBhdGhzKSkge1xuICAgICAgY29uc3QgX3NjaGVtYVR5cGUgPSBzY2hlbWFUeXBlLnNjaGVtYS5zdWJwYXRoc1trZXldO1xuICAgICAgdGhpcy5zdWJwYXRoc1twYXRoICsgJy4nICsga2V5XSA9IF9zY2hlbWFUeXBlO1xuICAgICAgaWYgKHR5cGVvZiBfc2NoZW1hVHlwZSA9PT0gJ29iamVjdCcgJiYgX3NjaGVtYVR5cGUgIT0gbnVsbCAmJiBfc2NoZW1hVHlwZS4kcGFyZW50U2NoZW1hRG9jQXJyYXkgPT0gbnVsbCkge1xuICAgICAgICBfc2NoZW1hVHlwZS4kcGFyZW50U2NoZW1hRG9jQXJyYXkgPSBzY2hlbWFUeXBlO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzY2hlbWFUeXBlLnNjaGVtYS5zaW5nbGVOZXN0ZWRQYXRocykpIHtcbiAgICAgIGNvbnN0IF9zY2hlbWFUeXBlID0gc2NoZW1hVHlwZS5zY2hlbWEuc2luZ2xlTmVzdGVkUGF0aHNba2V5XTtcbiAgICAgIHRoaXMuc3VicGF0aHNbcGF0aCArICcuJyArIGtleV0gPSBfc2NoZW1hVHlwZTtcbiAgICAgIGlmICh0eXBlb2YgX3NjaGVtYVR5cGUgPT09ICdvYmplY3QnICYmIF9zY2hlbWFUeXBlICE9IG51bGwgJiYgX3NjaGVtYVR5cGUuJHBhcmVudFNjaGVtYURvY0FycmF5ID09IG51bGwpIHtcbiAgICAgICAgX3NjaGVtYVR5cGUuJHBhcmVudFNjaGVtYURvY0FycmF5ID0gc2NoZW1hVHlwZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gZ2F0aGVyQ2hpbGRTY2hlbWFzKHNjaGVtYSkge1xuICBjb25zdCBjaGlsZFNjaGVtYXMgPSBbXTtcblxuICBmb3IgKGNvbnN0IHBhdGggb2YgT2JqZWN0LmtleXMoc2NoZW1hLnBhdGhzKSkge1xuICAgIGNvbnN0IHNjaGVtYXR5cGUgPSBzY2hlbWEucGF0aHNbcGF0aF07XG4gICAgaWYgKHNjaGVtYXR5cGUuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5IHx8IHNjaGVtYXR5cGUuJGlzU2luZ2xlTmVzdGVkKSB7XG4gICAgICBjaGlsZFNjaGVtYXMucHVzaCh7IHNjaGVtYTogc2NoZW1hdHlwZS5zY2hlbWEsIG1vZGVsOiBzY2hlbWF0eXBlLmNhc3RlciB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2hpbGRTY2hlbWFzO1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9nZXRQYXRoKHNjaGVtYSwgcGF0aCwgY2xlYW5QYXRoKSB7XG4gIGlmIChzY2hlbWEucGF0aHMuaGFzT3duUHJvcGVydHkocGF0aCkpIHtcbiAgICByZXR1cm4gc2NoZW1hLnBhdGhzW3BhdGhdO1xuICB9XG4gIGlmIChzY2hlbWEuc3VicGF0aHMuaGFzT3duUHJvcGVydHkoY2xlYW5QYXRoKSkge1xuICAgIGNvbnN0IHN1YnBhdGggPSBzY2hlbWEuc3VicGF0aHNbY2xlYW5QYXRoXTtcbiAgICBpZiAoc3VicGF0aCA9PT0gJ25lc3RlZCcpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBzdWJwYXRoO1xuICB9XG4gIGlmIChzY2hlbWEuc2luZ2xlTmVzdGVkUGF0aHMuaGFzT3duUHJvcGVydHkoY2xlYW5QYXRoKSAmJiB0eXBlb2Ygc2NoZW1hLnNpbmdsZU5lc3RlZFBhdGhzW2NsZWFuUGF0aF0gPT09ICdvYmplY3QnKSB7XG4gICAgY29uc3Qgc2luZ2xlTmVzdGVkUGF0aCA9IHNjaGVtYS5zaW5nbGVOZXN0ZWRQYXRoc1tjbGVhblBhdGhdO1xuICAgIGlmIChzaW5nbGVOZXN0ZWRQYXRoID09PSAnbmVzdGVkJykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHNpbmdsZU5lc3RlZFBhdGg7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfcGF0aFRvUG9zaXRpb25hbFN5bnRheChwYXRoKSB7XG4gIGlmICghL1xcLlxcZCsvLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuICByZXR1cm4gcGF0aC5yZXBsYWNlKC9cXC5cXGQrXFwuL2csICcuJC4nKS5yZXBsYWNlKC9cXC5cXGQrJC8sICcuJCcpO1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGdldE1hcFBhdGgoc2NoZW1hLCBwYXRoKSB7XG4gIGlmIChzY2hlbWEubWFwUGF0aHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZm9yIChjb25zdCB2YWwgb2Ygc2NoZW1hLm1hcFBhdGhzKSB7XG4gICAgY29uc3QgX3BhdGggPSB2YWwucGF0aDtcbiAgICBjb25zdCByZSA9IG5ldyBSZWdFeHAoJ14nICsgX3BhdGgucmVwbGFjZSgvXFwuXFwkXFwqL2csICdcXFxcLlteLl0rJykgKyAnJCcpO1xuICAgIGlmIChyZS50ZXN0KHBhdGgpKSB7XG4gICAgICByZXR1cm4gc2NoZW1hLnBhdGhzW19wYXRoXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBUaGUgTW9uZ29vc2UgaW5zdGFuY2UgdGhpcyBzY2hlbWEgaXMgYXNzb2NpYXRlZCB3aXRoXG4gKlxuICogQHByb3BlcnR5IGJhc2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWEucHJvdG90eXBlLCAnYmFzZScsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIHZhbHVlOiBudWxsXG59KTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0eXBlIGFyZ3VtZW50cyBpbnRvIE1vbmdvb3NlIFR5cGVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5pbnRlcnByZXRBc1R5cGUgPSBmdW5jdGlvbihwYXRoLCBvYmosIG9wdGlvbnMpIHtcbiAgaWYgKG9iaiBpbnN0YW5jZW9mIFNjaGVtYVR5cGUpIHtcbiAgICBpZiAob2JqLnBhdGggPT09IHBhdGgpIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIGNvbnN0IGNsb25lID0gb2JqLmNsb25lKCk7XG4gICAgY2xvbmUucGF0aCA9IHBhdGg7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG5cblxuICAvLyBJZiB0aGlzIHNjaGVtYSBoYXMgYW4gYXNzb2NpYXRlZCBNb25nb29zZSBvYmplY3QsIHVzZSB0aGUgTW9uZ29vc2Ugb2JqZWN0J3NcbiAgLy8gY29weSBvZiBTY2hlbWFUeXBlcyByZTogZ2gtNzE1OCBnaC02OTMzXG4gIGNvbnN0IE1vbmdvb3NlVHlwZXMgPSB0aGlzLmJhc2UgIT0gbnVsbCA/IHRoaXMuYmFzZS5TY2hlbWEuVHlwZXMgOiBTY2hlbWEuVHlwZXM7XG4gIGNvbnN0IFR5cGVzID0gdGhpcy5iYXNlICE9IG51bGwgPyB0aGlzLmJhc2UuVHlwZXMgOiByZXF1aXJlKCcuL3R5cGVzJyk7XG5cbiAgaWYgKCF1dGlscy5pc1BPSk8ob2JqKSAmJiAhKG9iaiBpbnN0YW5jZW9mIFNjaGVtYVR5cGVPcHRpb25zKSkge1xuICAgIGNvbnN0IGNvbnN0cnVjdG9yTmFtZSA9IHV0aWxzLmdldEZ1bmN0aW9uTmFtZShvYmouY29uc3RydWN0b3IpO1xuICAgIGlmIChjb25zdHJ1Y3Rvck5hbWUgIT09ICdPYmplY3QnKSB7XG4gICAgICBjb25zdCBvbGRPYmogPSBvYmo7XG4gICAgICBvYmogPSB7fTtcbiAgICAgIG9ialtvcHRpb25zLnR5cGVLZXldID0gb2xkT2JqO1xuICAgIH1cbiAgfVxuXG4gIC8vIEdldCB0aGUgdHlwZSBtYWtpbmcgc3VyZSB0byBhbGxvdyBrZXlzIG5hbWVkIFwidHlwZVwiXG4gIC8vIGFuZCBkZWZhdWx0IHRvIG1peGVkIGlmIG5vdCBzcGVjaWZpZWQuXG4gIC8vIHsgdHlwZTogeyB0eXBlOiBTdHJpbmcsIGRlZmF1bHQ6ICdmcmVzaGN1dCcgfSB9XG4gIGxldCB0eXBlID0gb2JqW29wdGlvbnMudHlwZUtleV0gJiYgKG9ialtvcHRpb25zLnR5cGVLZXldIGluc3RhbmNlb2YgRnVuY3Rpb24gfHwgb3B0aW9ucy50eXBlS2V5ICE9PSAndHlwZScgfHwgIW9iai50eXBlLnR5cGUpXG4gICAgPyBvYmpbb3B0aW9ucy50eXBlS2V5XVxuICAgIDoge307XG4gIGxldCBuYW1lO1xuXG4gIGlmICh1dGlscy5pc1BPSk8odHlwZSkgfHwgdHlwZSA9PT0gJ21peGVkJykge1xuICAgIHJldHVybiBuZXcgTW9uZ29vc2VUeXBlcy5NaXhlZChwYXRoLCBvYmopO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkgfHwgdHlwZSA9PT0gQXJyYXkgfHwgdHlwZSA9PT0gJ2FycmF5JyB8fCB0eXBlID09PSBNb25nb29zZVR5cGVzLkFycmF5KSB7XG4gICAgLy8gaWYgaXQgd2FzIHNwZWNpZmllZCB0aHJvdWdoIHsgdHlwZSB9IGxvb2sgZm9yIGBjYXN0YFxuICAgIGxldCBjYXN0ID0gKHR5cGUgPT09IEFycmF5IHx8IHR5cGUgPT09ICdhcnJheScpXG4gICAgICA/IG9iai5jYXN0IHx8IG9iai5vZlxuICAgICAgOiB0eXBlWzBdO1xuXG4gICAgLy8gbmV3IFNjaGVtYSh7IHBhdGg6IFtuZXcgU2NoZW1hKHsgLi4uIH0pXSB9KVxuICAgIGlmIChjYXN0ICYmIGNhc3QuaW5zdGFuY2VPZlNjaGVtYSkge1xuICAgICAgaWYgKCEoY2FzdCBpbnN0YW5jZW9mIFNjaGVtYSkpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5faXNNZXJnaW5nKSB7XG4gICAgICAgICAgY2FzdCA9IG5ldyBTY2hlbWEoY2FzdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2NoZW1hIGZvciBhcnJheSBwYXRoIGAnICsgcGF0aCArXG4gICAgICAgICAgICAnYCBpcyBmcm9tIGEgZGlmZmVyZW50IGNvcHkgb2YgdGhlIE1vbmdvb3NlIG1vZHVsZS4gJyArXG4gICAgICAgICAgICAnUGxlYXNlIG1ha2Ugc3VyZSB5b3VcXCdyZSB1c2luZyB0aGUgc2FtZSB2ZXJzaW9uICcgK1xuICAgICAgICAgICAgJ29mIE1vbmdvb3NlIGV2ZXJ5d2hlcmUgd2l0aCBgbnBtIGxpc3QgbW9uZ29vc2VgLiBJZiB5b3UgYXJlIHN0aWxsICcgK1xuICAgICAgICAgICAgJ2dldHRpbmcgdGhpcyBlcnJvciwgcGxlYXNlIGFkZCBgbmV3IFNjaGVtYSgpYCBhcm91bmQgdGhlIHBhdGg6ICcgK1xuICAgICAgICAgICAgYCR7cGF0aH06IG5ldyBTY2hlbWEoLi4uKWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IE1vbmdvb3NlVHlwZXMuRG9jdW1lbnRBcnJheShwYXRoLCBjYXN0LCBvYmopO1xuICAgIH1cbiAgICBpZiAoY2FzdCAmJlxuICAgICAgICBjYXN0W29wdGlvbnMudHlwZUtleV0gJiZcbiAgICAgICAgY2FzdFtvcHRpb25zLnR5cGVLZXldLmluc3RhbmNlT2ZTY2hlbWEpIHtcbiAgICAgIGlmICghKGNhc3Rbb3B0aW9ucy50eXBlS2V5XSBpbnN0YW5jZW9mIFNjaGVtYSkpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5faXNNZXJnaW5nKSB7XG4gICAgICAgICAgY2FzdFtvcHRpb25zLnR5cGVLZXldID0gbmV3IFNjaGVtYShjYXN0W29wdGlvbnMudHlwZUtleV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1NjaGVtYSBmb3IgYXJyYXkgcGF0aCBgJyArIHBhdGggK1xuICAgICAgICAgICAgJ2AgaXMgZnJvbSBhIGRpZmZlcmVudCBjb3B5IG9mIHRoZSBNb25nb29zZSBtb2R1bGUuICcgK1xuICAgICAgICAgICAgJ1BsZWFzZSBtYWtlIHN1cmUgeW91XFwncmUgdXNpbmcgdGhlIHNhbWUgdmVyc2lvbiAnICtcbiAgICAgICAgICAgICdvZiBNb25nb29zZSBldmVyeXdoZXJlIHdpdGggYG5wbSBsaXN0IG1vbmdvb3NlYC4gSWYgeW91IGFyZSBzdGlsbCAnICtcbiAgICAgICAgICAgICdnZXR0aW5nIHRoaXMgZXJyb3IsIHBsZWFzZSBhZGQgYG5ldyBTY2hlbWEoKWAgYXJvdW5kIHRoZSBwYXRoOiAnICtcbiAgICAgICAgICAgIGAke3BhdGh9OiBuZXcgU2NoZW1hKC4uLilgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBNb25nb29zZVR5cGVzLkRvY3VtZW50QXJyYXkocGF0aCwgY2FzdFtvcHRpb25zLnR5cGVLZXldLCBvYmosIGNhc3QpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNhc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjYXN0KSB8fCBjYXN0LnR5cGUgPT09IEFycmF5IHx8IGNhc3QudHlwZSA9PSAnQXJyYXknKSB7XG4gICAgICAgIGlmIChjYXN0ICYmIGNhc3QudHlwZSA9PSAnQXJyYXknKSB7XG4gICAgICAgICAgY2FzdC50eXBlID0gQXJyYXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBNb25nb29zZVR5cGVzLkFycmF5KHBhdGgsIHRoaXMuaW50ZXJwcmV0QXNUeXBlKHBhdGgsIGNhc3QsIG9wdGlvbnMpLCBvYmopO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEhhbmRsZSBib3RoIGBuZXcgU2NoZW1hKHsgYXJyOiBbeyBzdWJwYXRoOiBTdHJpbmcgfV0gfSlgIGFuZCBgbmV3IFNjaGVtYSh7IGFycjogW3sgdHlwZTogeyBzdWJwYXRoOiBzdHJpbmcgfSB9XSB9KWBcbiAgICBjb25zdCBjYXN0RnJvbVR5cGVLZXkgPSAoY2FzdCAhPSBudWxsICYmIGNhc3Rbb3B0aW9ucy50eXBlS2V5XSAmJiAob3B0aW9ucy50eXBlS2V5ICE9PSAndHlwZScgfHwgIWNhc3QudHlwZS50eXBlKSkgP1xuICAgICAgY2FzdFtvcHRpb25zLnR5cGVLZXldIDpcbiAgICAgIGNhc3Q7XG4gICAgaWYgKHR5cGVvZiBjYXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgY2FzdCA9IE1vbmdvb3NlVHlwZXNbY2FzdC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGNhc3Quc3Vic3RyaW5nKDEpXTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzUE9KTyhjYXN0RnJvbVR5cGVLZXkpKSB7XG4gICAgICBpZiAoT2JqZWN0LmtleXMoY2FzdEZyb21UeXBlS2V5KS5sZW5ndGgpIHtcbiAgICAgICAgLy8gVGhlIGBtaW5pbWl6ZWAgYW5kIGB0eXBlS2V5YCBvcHRpb25zIHByb3BhZ2F0ZSB0byBjaGlsZCBzY2hlbWFzXG4gICAgICAgIC8vIGRlY2xhcmVkIGlubGluZSwgbGlrZSBgeyBhcnI6IFt7IHZhbDogeyAkdHlwZTogU3RyaW5nIH0gfV0gfWAuXG4gICAgICAgIC8vIFNlZSBnaC0zNTYwXG4gICAgICAgIGNvbnN0IGNoaWxkU2NoZW1hT3B0aW9ucyA9IHsgbWluaW1pemU6IG9wdGlvbnMubWluaW1pemUgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMudHlwZUtleSkge1xuICAgICAgICAgIGNoaWxkU2NoZW1hT3B0aW9ucy50eXBlS2V5ID0gb3B0aW9ucy50eXBlS2V5O1xuICAgICAgICB9XG4gICAgICAgIC8vIHByb3BhZ2F0ZSAnc3RyaWN0JyBvcHRpb24gdG8gY2hpbGQgc2NoZW1hXG4gICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KCdzdHJpY3QnKSkge1xuICAgICAgICAgIGNoaWxkU2NoZW1hT3B0aW9ucy5zdHJpY3QgPSBvcHRpb25zLnN0cmljdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnc3RyaWN0UXVlcnknKSkge1xuICAgICAgICAgIGNoaWxkU2NoZW1hT3B0aW9ucy5zdHJpY3RRdWVyeSA9IG9wdGlvbnMuc3RyaWN0UXVlcnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3RvT2JqZWN0JykpIHtcbiAgICAgICAgICBjaGlsZFNjaGVtYU9wdGlvbnMudG9PYmplY3QgPSB1dGlscy5vbWl0KG9wdGlvbnMudG9PYmplY3QsIFsndHJhbnNmb3JtJ10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KCd0b0pTT04nKSkge1xuICAgICAgICAgIGNoaWxkU2NoZW1hT3B0aW9ucy50b0pTT04gPSB1dGlscy5vbWl0KG9wdGlvbnMudG9KU09OLCBbJ3RyYW5zZm9ybSddKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl91c2VyUHJvdmlkZWRPcHRpb25zLmhhc093blByb3BlcnR5KCdfaWQnKSkge1xuICAgICAgICAgIGNoaWxkU2NoZW1hT3B0aW9ucy5faWQgPSB0aGlzLl91c2VyUHJvdmlkZWRPcHRpb25zLl9pZDtcbiAgICAgICAgfSBlbHNlIGlmIChTY2hlbWEuVHlwZXMuRG9jdW1lbnRBcnJheS5kZWZhdWx0T3B0aW9ucy5faWQgIT0gbnVsbCkge1xuICAgICAgICAgIGNoaWxkU2NoZW1hT3B0aW9ucy5faWQgPSBTY2hlbWEuVHlwZXMuRG9jdW1lbnRBcnJheS5kZWZhdWx0T3B0aW9ucy5faWQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjaGlsZFNjaGVtYSA9IG5ldyBTY2hlbWEoY2FzdEZyb21UeXBlS2V5LCBjaGlsZFNjaGVtYU9wdGlvbnMpO1xuICAgICAgICBjaGlsZFNjaGVtYS4kaW1wbGljaXRseUNyZWF0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbmV3IE1vbmdvb3NlVHlwZXMuRG9jdW1lbnRBcnJheShwYXRoLCBjaGlsZFNjaGVtYSwgb2JqKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZTogZW1wdHkgb2JqZWN0IGJlY29tZXMgbWl4ZWRcbiAgICAgICAgcmV0dXJuIG5ldyBNb25nb29zZVR5cGVzLkFycmF5KHBhdGgsIE1vbmdvb3NlVHlwZXMuTWl4ZWQsIG9iaik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNhc3QpIHtcbiAgICAgIHR5cGUgPSBjYXN0W29wdGlvbnMudHlwZUtleV0gJiYgKG9wdGlvbnMudHlwZUtleSAhPT0gJ3R5cGUnIHx8ICFjYXN0LnR5cGUudHlwZSlcbiAgICAgICAgPyBjYXN0W29wdGlvbnMudHlwZUtleV1cbiAgICAgICAgOiBjYXN0O1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNb25nb29zZVR5cGVzLkFycmF5KHBhdGgsIHRoaXMuaW50ZXJwcmV0QXNUeXBlKHBhdGgsIHR5cGUsIG9wdGlvbnMpLCBvYmopO1xuICAgICAgfVxuXG4gICAgICBuYW1lID0gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnXG4gICAgICAgID8gdHlwZVxuICAgICAgICA6IHR5cGUuc2NoZW1hTmFtZSB8fCB1dGlscy5nZXRGdW5jdGlvbk5hbWUodHlwZSk7XG5cbiAgICAgIC8vIEZvciBKZXN0IDI2Kywgc2VlICMxMDI5NlxuICAgICAgaWYgKG5hbWUgPT09ICdDbG9ja0RhdGUnKSB7XG4gICAgICAgIG5hbWUgPSAnRGF0ZSc7XG4gICAgICB9XG5cbiAgICAgIGlmIChuYW1lID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzY2hlbWEgY29uZmlndXJhdGlvbjogJyArXG4gICAgICAgICAgYENvdWxkIG5vdCBkZXRlcm1pbmUgdGhlIGVtYmVkZGVkIHR5cGUgZm9yIGFycmF5IFxcYCR7cGF0aH1cXGAuIGAgK1xuICAgICAgICAgICdTZWUgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjZGVmaW5pdGlvbiBmb3IgbW9yZSBpbmZvIG9uIHN1cHBvcnRlZCBzY2hlbWEgc3ludGF4ZXMuJyk7XG4gICAgICB9XG4gICAgICBpZiAoIU1vbmdvb3NlVHlwZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzY2hlbWEgY29uZmlndXJhdGlvbjogJyArXG4gICAgICAgICAgYFxcYCR7bmFtZX1cXGAgaXMgbm90IGEgdmFsaWQgdHlwZSB3aXRoaW4gdGhlIGFycmF5IFxcYCR7cGF0aH1cXGAuYCArXG4gICAgICAgICAgJ1NlZSBodHRwczovL2JpdC5seS9tb25nb29zZS1zY2hlbWF0eXBlcyBmb3IgYSBsaXN0IG9mIHZhbGlkIHNjaGVtYSB0eXBlcy4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE1vbmdvb3NlVHlwZXMuQXJyYXkocGF0aCwgY2FzdCB8fCBNb25nb29zZVR5cGVzLk1peGVkLCBvYmosIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKHR5cGUgJiYgdHlwZS5pbnN0YW5jZU9mU2NoZW1hKSB7XG4gICAgcmV0dXJuIG5ldyBNb25nb29zZVR5cGVzLlN1YmRvY3VtZW50KHR5cGUsIHBhdGgsIG9iaik7XG4gIH1cblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHR5cGUpKSB7XG4gICAgbmFtZSA9ICdCdWZmZXInO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIG5hbWUgPSB0eXBlLnNjaGVtYU5hbWUgfHwgdXRpbHMuZ2V0RnVuY3Rpb25OYW1lKHR5cGUpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFR5cGVzLk9iamVjdElkKSB7XG4gICAgbmFtZSA9ICdPYmplY3RJZCc7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gVHlwZXMuRGVjaW1hbDEyOCkge1xuICAgIG5hbWUgPSAnRGVjaW1hbDEyOCc7XG4gIH0gZWxzZSB7XG4gICAgbmFtZSA9IHR5cGUgPT0gbnVsbCA/ICcnICsgdHlwZSA6IHR5cGUudG9TdHJpbmcoKTtcbiAgfVxuXG4gIGlmIChuYW1lKSB7XG4gICAgbmFtZSA9IG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnN1YnN0cmluZygxKTtcbiAgfVxuICAvLyBTcGVjaWFsIGNhc2UgcmU6IGdoLTcwNDkgYmVjYXVzZSB0aGUgYnNvbiBgT2JqZWN0SURgIGNsYXNzJyBjYXBpdGFsaXphdGlvblxuICAvLyBkb2Vzbid0IGxpbmUgdXAgd2l0aCBNb25nb29zZSdzLlxuICBpZiAobmFtZSA9PT0gJ09iamVjdElEJykge1xuICAgIG5hbWUgPSAnT2JqZWN0SWQnO1xuICB9XG4gIC8vIEZvciBKZXN0IDI2Kywgc2VlICMxMDI5NlxuICBpZiAobmFtZSA9PT0gJ0Nsb2NrRGF0ZScpIHtcbiAgICBuYW1lID0gJ0RhdGUnO1xuICB9XG5cbiAgaWYgKG5hbWUgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgc2NoZW1hIGNvbmZpZ3VyYXRpb246IFxcYCR7cGF0aH1cXGAgc2NoZW1hdHlwZSBkZWZpbml0aW9uIGlzIGAgK1xuICAgICAgJ2ludmFsaWQuIFNlZSAnICtcbiAgICAgICdodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNkZWZpbml0aW9uIGZvciBtb3JlIGluZm8gb24gc3VwcG9ydGVkIHNjaGVtYSBzeW50YXhlcy4nKTtcbiAgfVxuICBpZiAoTW9uZ29vc2VUeXBlc1tuYW1lXSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBzY2hlbWEgY29uZmlndXJhdGlvbjogXFxgJHtuYW1lfVxcYCBpcyBub3QgYCArXG4gICAgICBgYSB2YWxpZCB0eXBlIGF0IHBhdGggXFxgJHtwYXRofVxcYC4gU2VlIGAgK1xuICAgICAgJ2h0dHBzOi8vYml0Lmx5L21vbmdvb3NlLXNjaGVtYXR5cGVzIGZvciBhIGxpc3Qgb2YgdmFsaWQgc2NoZW1hIHR5cGVzLicpO1xuICB9XG5cbiAgY29uc3Qgc2NoZW1hVHlwZSA9IG5ldyBNb25nb29zZVR5cGVzW25hbWVdKHBhdGgsIG9iaik7XG5cbiAgaWYgKHNjaGVtYVR5cGUuJGlzU2NoZW1hTWFwKSB7XG4gICAgY3JlYXRlTWFwTmVzdGVkU2NoZW1hVHlwZSh0aGlzLCBzY2hlbWFUeXBlLCBwYXRoLCBvYmosIG9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIHNjaGVtYVR5cGU7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZU1hcE5lc3RlZFNjaGVtYVR5cGUoc2NoZW1hLCBzY2hlbWFUeXBlLCBwYXRoLCBvYmosIG9wdGlvbnMpIHtcbiAgY29uc3QgbWFwUGF0aCA9IHBhdGggKyAnLiQqJztcbiAgbGV0IF9tYXBUeXBlID0geyB0eXBlOiB7fSB9O1xuICBpZiAodXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eShvYmosICdvZicpKSB7XG4gICAgY29uc3QgaXNJbmxpbmVTY2hlbWEgPSB1dGlscy5pc1BPSk8ob2JqLm9mKSAmJlxuICAgICAgT2JqZWN0LmtleXMob2JqLm9mKS5sZW5ndGggPiAwICYmXG4gICAgICAhdXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eShvYmoub2YsIHNjaGVtYS5vcHRpb25zLnR5cGVLZXkpO1xuICAgIGlmIChpc0lubGluZVNjaGVtYSkge1xuICAgICAgX21hcFR5cGUgPSB7IFtzY2hlbWEub3B0aW9ucy50eXBlS2V5XTogbmV3IFNjaGVtYShvYmoub2YpIH07XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc1BPSk8ob2JqLm9mKSkge1xuICAgICAgX21hcFR5cGUgPSBPYmplY3QuYXNzaWduKHt9LCBvYmoub2YpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfbWFwVHlwZSA9IHsgW3NjaGVtYS5vcHRpb25zLnR5cGVLZXldOiBvYmoub2YgfTtcbiAgICB9XG5cbiAgICBpZiAoX21hcFR5cGVbc2NoZW1hLm9wdGlvbnMudHlwZUtleV0gJiYgX21hcFR5cGVbc2NoZW1hLm9wdGlvbnMudHlwZUtleV0uaW5zdGFuY2VPZlNjaGVtYSkge1xuICAgICAgY29uc3Qgc3ViZG9jdW1lbnRTY2hlbWEgPSBfbWFwVHlwZVtzY2hlbWEub3B0aW9ucy50eXBlS2V5XTtcbiAgICAgIHN1YmRvY3VtZW50U2NoZW1hLmVhY2hQYXRoKChzdWJwYXRoLCB0eXBlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlLm9wdGlvbnMuc2VsZWN0ID09PSB0cnVlIHx8IHR5cGUub3B0aW9ucy5zZWxlY3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ0Nhbm5vdCB1c2Ugc2NoZW1hLWxldmVsIHByb2plY3Rpb25zIChgc2VsZWN0OiB0cnVlYCBvciBgc2VsZWN0OiBmYWxzZWApIHdpdGhpbiBtYXBzIGF0IHBhdGggXCInICsgcGF0aCArICcuJyArIHN1YnBhdGggKyAnXCInKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzLmhhc1VzZXJEZWZpbmVkUHJvcGVydHkob2JqLCAncmVmJykpIHtcbiAgICAgIF9tYXBUeXBlLnJlZiA9IG9iai5yZWY7XG4gICAgfVxuICB9XG4gIHNjaGVtYVR5cGUuJF9fc2NoZW1hVHlwZSA9IHNjaGVtYS5pbnRlcnByZXRBc1R5cGUobWFwUGF0aCwgX21hcFR5cGUsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIHRoZSBzY2hlbWFzIHBhdGhzIHNpbWlsYXIgdG8gQXJyYXkjZm9yRWFjaC5cbiAqXG4gKiBUaGUgY2FsbGJhY2sgaXMgcGFzc2VkIHRoZSBwYXRobmFtZSBhbmQgdGhlIHNjaGVtYVR5cGUgaW5zdGFuY2UuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCB1c2VyU2NoZW1hID0gbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZywgcmVnaXN0ZXJlZEF0OiBEYXRlIH0pO1xuICogICAgIHVzZXJTY2hlbWEuZWFjaFBhdGgoKHBhdGhuYW1lLCBzY2hlbWF0eXBlKSA9PiB7XG4gKiAgICAgICAvLyBQcmludHMgdHdpY2U6XG4gKiAgICAgICAvLyBuYW1lIFNjaGVtYVN0cmluZyB7IC4uLiB9XG4gKiAgICAgICAvLyByZWdpc3RlcmVkQXQgU2NoZW1hRGF0ZSB7IC4uLiB9XG4gKiAgICAgICBjb25zb2xlLmxvZyhwYXRobmFtZSwgc2NoZW1hdHlwZSk7XG4gKiAgICAgfSk7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gY2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm4ge1NjaGVtYX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLmVhY2hQYXRoID0gZnVuY3Rpb24oZm4pIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMucGF0aHMpO1xuICBjb25zdCBsZW4gPSBrZXlzLmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgZm4oa2V5c1tpXSwgdGhpcy5wYXRoc1trZXlzW2ldXSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBBcnJheSBvZiBwYXRoIHN0cmluZ3MgdGhhdCBhcmUgcmVxdWlyZWQgYnkgdGhpcyBzY2hlbWEuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7XG4gKiAgICAgICBuYW1lOiB7IHR5cGU6IFN0cmluZywgcmVxdWlyZWQ6IHRydWUgfSxcbiAqICAgICAgIGFnZTogeyB0eXBlOiBTdHJpbmcsIHJlcXVpcmVkOiB0cnVlIH0sXG4gKiAgICAgICBub3RlczogU3RyaW5nXG4gKiAgICAgfSk7XG4gKiAgICAgcy5yZXF1aXJlZFBhdGhzKCk7IC8vIFsgJ2FnZScsICduYW1lJyBdXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW52YWxpZGF0ZSBSZWZyZXNoIHRoZSBjYWNoZVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5yZXF1aXJlZFBhdGhzID0gZnVuY3Rpb24gcmVxdWlyZWRQYXRocyhpbnZhbGlkYXRlKSB7XG4gIGlmICh0aGlzLl9yZXF1aXJlZHBhdGhzICYmICFpbnZhbGlkYXRlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlcXVpcmVkcGF0aHM7XG4gIH1cblxuICBjb25zdCBwYXRocyA9IE9iamVjdC5rZXlzKHRoaXMucGF0aHMpO1xuICBsZXQgaSA9IHBhdGhzLmxlbmd0aDtcbiAgY29uc3QgcmV0ID0gW107XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGNvbnN0IHBhdGggPSBwYXRoc1tpXTtcbiAgICBpZiAodGhpcy5wYXRoc1twYXRoXS5pc1JlcXVpcmVkKSB7XG4gICAgICByZXQucHVzaChwYXRoKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5fcmVxdWlyZWRwYXRocyA9IHJldDtcbiAgcmV0dXJuIHRoaXMuX3JlcXVpcmVkcGF0aHM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgaW5kZXhlcyBmcm9tIGZpZWxkcyBhbmQgc2NoZW1hLWxldmVsIGluZGV4ZXMgKGNhY2hlZCkuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLmluZGV4ZWRQYXRocyA9IGZ1bmN0aW9uIGluZGV4ZWRQYXRocygpIHtcbiAgaWYgKHRoaXMuX2luZGV4ZWRwYXRocykge1xuICAgIHJldHVybiB0aGlzLl9pbmRleGVkcGF0aHM7XG4gIH1cbiAgdGhpcy5faW5kZXhlZHBhdGhzID0gdGhpcy5pbmRleGVzKCk7XG4gIHJldHVybiB0aGlzLl9pbmRleGVkcGF0aHM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHBhdGhUeXBlIG9mIGBwYXRoYCBmb3IgdGhpcyBzY2hlbWEuXG4gKlxuICogR2l2ZW4gYSBwYXRoLCByZXR1cm5zIHdoZXRoZXIgaXQgaXMgYSByZWFsLCB2aXJ0dWFsLCBuZXN0ZWQsIG9yIGFkLWhvYy91bmRlZmluZWQgcGF0aC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nLCBuZXN0ZWQ6IHsgZm9vOiBTdHJpbmcgfSB9KTtcbiAqICAgICBzLnZpcnR1YWwoJ2ZvbycpLmdldCgoKSA9PiA0Mik7XG4gKiAgICAgcy5wYXRoVHlwZSgnbmFtZScpOyAvLyBcInJlYWxcIlxuICogICAgIHMucGF0aFR5cGUoJ25lc3RlZCcpOyAvLyBcIm5lc3RlZFwiXG4gKiAgICAgcy5wYXRoVHlwZSgnZm9vJyk7IC8vIFwidmlydHVhbFwiXG4gKiAgICAgcy5wYXRoVHlwZSgnZmFpbCcpOyAvLyBcImFkaG9jT3JVbmRlZmluZWRcIlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYS5wcm90b3R5cGUucGF0aFR5cGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIGlmICh0aGlzLnBhdGhzLmhhc093blByb3BlcnR5KHBhdGgpKSB7XG4gICAgcmV0dXJuICdyZWFsJztcbiAgfVxuICBpZiAodGhpcy52aXJ0dWFscy5oYXNPd25Qcm9wZXJ0eShwYXRoKSkge1xuICAgIHJldHVybiAndmlydHVhbCc7XG4gIH1cbiAgaWYgKHRoaXMubmVzdGVkLmhhc093blByb3BlcnR5KHBhdGgpKSB7XG4gICAgcmV0dXJuICduZXN0ZWQnO1xuICB9XG5cbiAgLy8gQ29udmVydCB0byAnLiQnIHRvIGNoZWNrIHN1YnBhdGhzIHJlOiBnaC02NDA1XG4gIGNvbnN0IGNsZWFuUGF0aCA9IF9wYXRoVG9Qb3NpdGlvbmFsU3ludGF4KHBhdGgpO1xuXG4gIGlmICh0aGlzLnN1YnBhdGhzLmhhc093blByb3BlcnR5KGNsZWFuUGF0aCkgfHwgdGhpcy5zdWJwYXRocy5oYXNPd25Qcm9wZXJ0eShwYXRoKSkge1xuICAgIHJldHVybiAncmVhbCc7XG4gIH1cblxuICBjb25zdCBzaW5nbGVOZXN0ZWRQYXRoID0gdGhpcy5zaW5nbGVOZXN0ZWRQYXRocy5oYXNPd25Qcm9wZXJ0eShjbGVhblBhdGgpIHx8IHRoaXMuc2luZ2xlTmVzdGVkUGF0aHMuaGFzT3duUHJvcGVydHkocGF0aCk7XG4gIGlmIChzaW5nbGVOZXN0ZWRQYXRoKSB7XG4gICAgcmV0dXJuIHNpbmdsZU5lc3RlZFBhdGggPT09ICduZXN0ZWQnID8gJ25lc3RlZCcgOiAncmVhbCc7XG4gIH1cblxuICAvLyBMb29rIGZvciBtYXBzXG4gIGNvbnN0IG1hcFBhdGggPSBnZXRNYXBQYXRoKHRoaXMsIHBhdGgpO1xuICBpZiAobWFwUGF0aCAhPSBudWxsKSB7XG4gICAgcmV0dXJuICdyZWFsJztcbiAgfVxuXG4gIGlmICgvXFwuXFxkK1xcLnxcXC5cXGQrJC8udGVzdChwYXRoKSkge1xuICAgIHJldHVybiBnZXRQb3NpdGlvbmFsUGF0aFR5cGUodGhpcywgcGF0aCwgY2xlYW5QYXRoKTtcbiAgfVxuICByZXR1cm4gJ2FkaG9jT3JVbmRlZmluZWQnO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWZmIHRoaXMgcGF0aCBpcyBhIGNoaWxkIG9mIGEgbWl4ZWQgc2NoZW1hLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5oYXNNaXhlZFBhcmVudCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgY29uc3Qgc3VicGF0aHMgPSBwYXRoLnNwbGl0KC9cXC4vZyk7XG4gIHBhdGggPSAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJwYXRocy5sZW5ndGg7ICsraSkge1xuICAgIHBhdGggPSBpID4gMCA/IHBhdGggKyAnLicgKyBzdWJwYXRoc1tpXSA6IHN1YnBhdGhzW2ldO1xuICAgIGlmICh0aGlzLnBhdGhzLmhhc093blByb3BlcnR5KHBhdGgpICYmXG4gICAgICAgIHRoaXMucGF0aHNbcGF0aF0gaW5zdGFuY2VvZiBNb25nb29zZVR5cGVzLk1peGVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXRoc1twYXRoXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogU2V0dXAgdXBkYXRlZEF0IGFuZCBjcmVhdGVkQXQgdGltZXN0YW1wcyB0byBkb2N1bWVudHMgaWYgZW5hYmxlZFxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbnxPYmplY3R9IHRpbWVzdGFtcHMgdGltZXN0YW1wcyBvcHRpb25zXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuU2NoZW1hLnByb3RvdHlwZS5zZXR1cFRpbWVzdGFtcCA9IGZ1bmN0aW9uKHRpbWVzdGFtcHMpIHtcbiAgcmV0dXJuIHNldHVwVGltZXN0YW1wcyh0aGlzLCB0aW1lc3RhbXBzKTtcbn07XG5cbi8qKlxuICogaWdub3JlLiBEZXByZWNhdGVkIHJlOiAjNjQwNVxuICogQHBhcmFtIHtBbnl9IHNlbGZcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBnZXRQb3NpdGlvbmFsUGF0aFR5cGUoc2VsZiwgcGF0aCwgY2xlYW5QYXRoKSB7XG4gIGNvbnN0IHN1YnBhdGhzID0gcGF0aC5zcGxpdCgvXFwuKFxcZCspXFwufFxcLihcXGQrKSQvKS5maWx0ZXIoQm9vbGVhbik7XG4gIGlmIChzdWJwYXRocy5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuIHNlbGYucGF0aHMuaGFzT3duUHJvcGVydHkoc3VicGF0aHNbMF0pID9cbiAgICAgIHNlbGYucGF0aHNbc3VicGF0aHNbMF1dIDpcbiAgICAgICdhZGhvY09yVW5kZWZpbmVkJztcbiAgfVxuXG4gIGxldCB2YWwgPSBzZWxmLnBhdGgoc3VicGF0aHNbMF0pO1xuICBsZXQgaXNOZXN0ZWQgPSBmYWxzZTtcbiAgaWYgKCF2YWwpIHtcbiAgICByZXR1cm4gJ2FkaG9jT3JVbmRlZmluZWQnO1xuICB9XG5cbiAgY29uc3QgbGFzdCA9IHN1YnBhdGhzLmxlbmd0aCAtIDE7XG5cbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBzdWJwYXRocy5sZW5ndGg7ICsraSkge1xuICAgIGlzTmVzdGVkID0gZmFsc2U7XG4gICAgY29uc3Qgc3VicGF0aCA9IHN1YnBhdGhzW2ldO1xuXG4gICAgaWYgKGkgPT09IGxhc3QgJiYgdmFsICYmICEvXFxELy50ZXN0KHN1YnBhdGgpKSB7XG4gICAgICBpZiAodmFsLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSkge1xuICAgICAgICB2YWwgPSB2YWwuJGVtYmVkZGVkU2NoZW1hVHlwZTtcbiAgICAgIH0gZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgTW9uZ29vc2VUeXBlcy5BcnJheSkge1xuICAgICAgICAvLyBTdHJpbmdTY2hlbWEsIE51bWJlclNjaGVtYSwgZXRjXG4gICAgICAgIHZhbCA9IHZhbC5jYXN0ZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBpZ25vcmUgaWYgaXRzIGp1c3QgYSBwb3NpdGlvbiBzZWdtZW50OiBwYXRoLjAuc3VicGF0aFxuICAgIGlmICghL1xcRC8udGVzdChzdWJwYXRoKSkge1xuICAgICAgLy8gTmVzdGVkIGFycmF5XG4gICAgICBpZiAodmFsIGluc3RhbmNlb2YgTW9uZ29vc2VUeXBlcy5BcnJheSAmJiBpICE9PSBsYXN0KSB7XG4gICAgICAgIHZhbCA9IHZhbC5jYXN0ZXI7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoISh2YWwgJiYgdmFsLnNjaGVtYSkpIHtcbiAgICAgIHZhbCA9IHVuZGVmaW5lZDtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNvbnN0IHR5cGUgPSB2YWwuc2NoZW1hLnBhdGhUeXBlKHN1YnBhdGgpO1xuICAgIGlzTmVzdGVkID0gKHR5cGUgPT09ICduZXN0ZWQnKTtcbiAgICB2YWwgPSB2YWwuc2NoZW1hLnBhdGgoc3VicGF0aCk7XG4gIH1cblxuICBzZWxmLnN1YnBhdGhzW2NsZWFuUGF0aF0gPSB2YWw7XG4gIGlmICh2YWwpIHtcbiAgICByZXR1cm4gJ3JlYWwnO1xuICB9XG4gIGlmIChpc05lc3RlZCkge1xuICAgIHJldHVybiAnbmVzdGVkJztcbiAgfVxuICByZXR1cm4gJ2FkaG9jT3JVbmRlZmluZWQnO1xufVxuXG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gZ2V0UG9zaXRpb25hbFBhdGgoc2VsZiwgcGF0aCwgY2xlYW5QYXRoKSB7XG4gIGdldFBvc2l0aW9uYWxQYXRoVHlwZShzZWxmLCBwYXRoLCBjbGVhblBhdGgpO1xuICByZXR1cm4gc2VsZi5zdWJwYXRoc1tjbGVhblBhdGhdO1xufVxuXG4vKipcbiAqIEFkZHMgYSBtZXRob2QgY2FsbCB0byB0aGUgcXVldWUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBzY2hlbWEubWV0aG9kcy5wcmludCA9IGZ1bmN0aW9uKCkgeyBjb25zb2xlLmxvZyh0aGlzKTsgfTtcbiAqICAgICBzY2hlbWEucXVldWUoJ3ByaW50JywgW10pOyAvLyBQcmludCB0aGUgZG9jIGV2ZXJ5IG9uZSBpcyBpbnN0YW50aWF0ZWRcbiAqXG4gKiAgICAgY29uc3QgTW9kZWwgPSBtb25nb29zZS5tb2RlbCgnVGVzdCcsIHNjaGVtYSk7XG4gKiAgICAgbmV3IE1vZGVsKHsgbmFtZTogJ3Rlc3QnIH0pOyAvLyBQcmludHMgJ3tcIl9pZFwiOiAuLi4sIFwibmFtZVwiOiBcInRlc3RcIiB9J1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIGRvY3VtZW50IG1ldGhvZCB0byBjYWxsIGxhdGVyXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5xdWV1ZSA9IGZ1bmN0aW9uKG5hbWUsIGFyZ3MpIHtcbiAgdGhpcy5jYWxsUXVldWUucHVzaChbbmFtZSwgYXJnc10pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGVmaW5lcyBhIHByZSBob29rIGZvciB0aGUgbW9kZWwuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCB0b3lTY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nLCBjcmVhdGVkOiBEYXRlIH0pO1xuICpcbiAqICAgICB0b3lTY2hlbWEucHJlKCdzYXZlJywgZnVuY3Rpb24obmV4dCkge1xuICogICAgICAgaWYgKCF0aGlzLmNyZWF0ZWQpIHRoaXMuY3JlYXRlZCA9IG5ldyBEYXRlO1xuICogICAgICAgbmV4dCgpO1xuICogICAgIH0pO1xuICpcbiAqICAgICB0b3lTY2hlbWEucHJlKCd2YWxpZGF0ZScsIGZ1bmN0aW9uKG5leHQpIHtcbiAqICAgICAgIGlmICh0aGlzLm5hbWUgIT09ICdXb29keScpIHRoaXMubmFtZSA9ICdXb29keSc7XG4gKiAgICAgICBuZXh0KCk7XG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vIEVxdWl2YWxlbnQgdG8gY2FsbGluZyBgcHJlKClgIG9uIGBmaW5kYCwgYGZpbmRPbmVgLCBgZmluZE9uZUFuZFVwZGF0ZWAuXG4gKiAgICAgdG95U2NoZW1hLnByZSgvXmZpbmQvLCBmdW5jdGlvbihuZXh0KSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyh0aGlzLmdldEZpbHRlcigpKTtcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gRXF1aXZhbGVudCB0byBjYWxsaW5nIGBwcmUoKWAgb24gYHVwZGF0ZU9uZWAsIGBmaW5kT25lQW5kVXBkYXRlYC5cbiAqICAgICB0b3lTY2hlbWEucHJlKFsndXBkYXRlT25lJywgJ2ZpbmRPbmVBbmRVcGRhdGUnXSwgZnVuY3Rpb24obmV4dCkge1xuICogICAgICAgY29uc29sZS5sb2codGhpcy5nZXRGaWx0ZXIoKSk7XG4gKiAgICAgfSk7XG4gKlxuICogICAgIHRveVNjaGVtYS5wcmUoJ2RlbGV0ZU9uZScsIGZ1bmN0aW9uKCkge1xuICogICAgICAgLy8gUnVucyB3aGVuIHlvdSBjYWxsIGBUb3kuZGVsZXRlT25lKClgXG4gKiAgICAgfSk7XG4gKlxuICogICAgIHRveVNjaGVtYS5wcmUoJ2RlbGV0ZU9uZScsIHsgZG9jdW1lbnQ6IHRydWUgfSwgZnVuY3Rpb24oKSB7XG4gKiAgICAgICAvLyBSdW5zIHdoZW4geW91IGNhbGwgYGRvYy5kZWxldGVPbmUoKWBcbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB8U3RyaW5nW119IG1ldGhvZE5hbWUgVGhlIG1ldGhvZCBuYW1lIG9yIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYXRjaCBtZXRob2QgbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5kb2N1bWVudF0gSWYgYG5hbWVgIGlzIGEgaG9vayBmb3IgYm90aCBkb2N1bWVudCBhbmQgcXVlcnkgbWlkZGxld2FyZSwgc2V0IHRvIGB0cnVlYCB0byBydW4gb24gZG9jdW1lbnQgbWlkZGxld2FyZS4gRm9yIGV4YW1wbGUsIHNldCBgb3B0aW9ucy5kb2N1bWVudGAgdG8gYHRydWVgIHRvIGFwcGx5IHRoaXMgaG9vayB0byBgRG9jdW1lbnQjZGVsZXRlT25lKClgIHJhdGhlciB0aGFuIGBRdWVyeSNkZWxldGVPbmUoKWAuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnF1ZXJ5XSBJZiBgbmFtZWAgaXMgYSBob29rIGZvciBib3RoIGRvY3VtZW50IGFuZCBxdWVyeSBtaWRkbGV3YXJlLCBzZXQgdG8gYHRydWVgIHRvIHJ1biBvbiBxdWVyeSBtaWRkbGV3YXJlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5wcmUgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmIChuYW1lIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgY29uc3QgcmVtYWluaW5nQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgZm9yIChjb25zdCBmbiBvZiBob29rTmFtZXMpIHtcbiAgICAgIGlmIChuYW1lLnRlc3QoZm4pKSB7XG4gICAgICAgIHRoaXMucHJlLmFwcGx5KHRoaXMsIFtmbl0uY29uY2F0KHJlbWFpbmluZ0FyZ3MpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkobmFtZSkpIHtcbiAgICBjb25zdCByZW1haW5pbmdBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBmb3IgKGNvbnN0IGVsIG9mIG5hbWUpIHtcbiAgICAgIHRoaXMucHJlLmFwcGx5KHRoaXMsIFtlbF0uY29uY2F0KHJlbWFpbmluZ0FyZ3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdGhpcy5zLmhvb2tzLnByZS5hcHBseSh0aGlzLnMuaG9va3MsIGFyZ3VtZW50cyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEZWZpbmVzIGEgcG9zdCBob29rIGZvciB0aGUgZG9jdW1lbnRcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSguLik7XG4gKiAgICAgc2NoZW1hLnBvc3QoJ3NhdmUnLCBmdW5jdGlvbiAoZG9jKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZygndGhpcyBmaXJlZCBhZnRlciBhIGRvY3VtZW50IHdhcyBzYXZlZCcpO1xuICogICAgIH0pO1xuICpcbiAqICAgICBzY2hlbWEucG9zdCgnZmluZCcsIGZ1bmN0aW9uKGRvY3MpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKCd0aGlzIGZpcmVkIGFmdGVyIHlvdSByYW4gYSBmaW5kIHF1ZXJ5Jyk7XG4gKiAgICAgfSk7XG4gKlxuICogICAgIHNjaGVtYS5wb3N0KC9NYW55JC8sIGZ1bmN0aW9uKHJlcykge1xuICogICAgICAgY29uc29sZS5sb2coJ3RoaXMgZmlyZWQgYWZ0ZXIgeW91IHJhbiBgdXBkYXRlTWFueSgpYCBvciBgZGVsZXRlTWFueSgpYCcpO1xuICogICAgIH0pO1xuICpcbiAqICAgICBjb25zdCBNb2RlbCA9IG1vbmdvb3NlLm1vZGVsKCdNb2RlbCcsIHNjaGVtYSk7XG4gKlxuICogICAgIGNvbnN0IG0gPSBuZXcgTW9kZWwoLi4pO1xuICogICAgIG0uc2F2ZShmdW5jdGlvbihlcnIpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKCd0aGlzIGZpcmVzIGFmdGVyIHRoZSBgcG9zdGAgaG9vaycpO1xuICogICAgIH0pO1xuICpcbiAqICAgICBtLmZpbmQoZnVuY3Rpb24oZXJyLCBkb2NzKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZygndGhpcyBmaXJlcyBhZnRlciB0aGUgcG9zdCBmaW5kIGhvb2snKTtcbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB8U3RyaW5nW119IG1ldGhvZE5hbWUgVGhlIG1ldGhvZCBuYW1lIG9yIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYXRjaCBtZXRob2QgbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5kb2N1bWVudF0gSWYgYG5hbWVgIGlzIGEgaG9vayBmb3IgYm90aCBkb2N1bWVudCBhbmQgcXVlcnkgbWlkZGxld2FyZSwgc2V0IHRvIGB0cnVlYCB0byBydW4gb24gZG9jdW1lbnQgbWlkZGxld2FyZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucXVlcnldIElmIGBuYW1lYCBpcyBhIGhvb2sgZm9yIGJvdGggZG9jdW1lbnQgYW5kIHF1ZXJ5IG1pZGRsZXdhcmUsIHNldCB0byBgdHJ1ZWAgdG8gcnVuIG9uIHF1ZXJ5IG1pZGRsZXdhcmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBjYWxsYmFja1xuICogQHNlZSBtaWRkbGV3YXJlIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9taWRkbGV3YXJlLmh0bWxcbiAqIEBzZWUga2FyZWVtIGh0dHBzOi8vbnBtanMub3JnL3BhY2thZ2Uva2FyZWVtXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYS5wcm90b3R5cGUucG9zdCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYgKG5hbWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICBjb25zdCByZW1haW5pbmdBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBmb3IgKGNvbnN0IGZuIG9mIGhvb2tOYW1lcykge1xuICAgICAgaWYgKG5hbWUudGVzdChmbikpIHtcbiAgICAgICAgdGhpcy5wb3N0LmFwcGx5KHRoaXMsIFtmbl0uY29uY2F0KHJlbWFpbmluZ0FyZ3MpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkobmFtZSkpIHtcbiAgICBjb25zdCByZW1haW5pbmdBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBmb3IgKGNvbnN0IGVsIG9mIG5hbWUpIHtcbiAgICAgIHRoaXMucG9zdC5hcHBseSh0aGlzLCBbZWxdLmNvbmNhdChyZW1haW5pbmdBcmdzKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRoaXMucy5ob29rcy5wb3N0LmFwcGx5KHRoaXMucy5ob29rcywgYXJndW1lbnRzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVycyBhIHBsdWdpbiBmb3IgdGhpcyBzY2hlbWEuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZyB9KTtcbiAqICAgICBzLnBsdWdpbihzY2hlbWEgPT4gY29uc29sZS5sb2coc2NoZW1hLnBhdGgoJ25hbWUnKS5wYXRoKSk7XG4gKiAgICAgbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBzKTsgLy8gUHJpbnRzICduYW1lJ1xuICpcbiAqIE9yIHdpdGggT3B0aW9uczpcbiAqXG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcgfSk7XG4gKiAgICAgcy5wbHVnaW4oKHNjaGVtYSwgb3B0cykgPT4gY29uc29sZS5sb2cob3B0cy50ZXh0LCBzY2hlbWEucGF0aCgnbmFtZScpLnBhdGgpLCB7IHRleHQ6IFwiU2NoZW1hIFBhdGggTmFtZTpcIiB9KTtcbiAqICAgICBtb25nb29zZS5tb2RlbCgnVGVzdCcsIHMpOyAvLyBQcmludHMgJ1NjaGVtYSBQYXRoIE5hbWU6IG5hbWUnXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcGx1Z2luIFRoZSBQbHVnaW4ncyBjYWxsYmFja1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSBPcHRpb25zIHRvIHBhc3MgdG8gdGhlIHBsdWdpblxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0cy5kZWR1cGxpY2F0ZT1mYWxzZV0gSWYgdHJ1ZSwgaWdub3JlIGR1cGxpY2F0ZSBwbHVnaW5zIChzYW1lIGBmbmAgYXJndW1lbnQgdXNpbmcgYD09PWApXG4gKiBAc2VlIHBsdWdpbnMgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3BsdWdpbnMuaHRtbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLnBsdWdpbiA9IGZ1bmN0aW9uKGZuLCBvcHRzKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IHBhcmFtIHRvIGBzY2hlbWEucGx1Z2luKClgIG11c3QgYmUgYSBmdW5jdGlvbiwgJyArXG4gICAgICAnZ290IFwiJyArICh0eXBlb2YgZm4pICsgJ1wiJyk7XG4gIH1cblxuXG4gIGlmIChvcHRzICYmIG9wdHMuZGVkdXBsaWNhdGUpIHtcbiAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiB0aGlzLnBsdWdpbnMpIHtcbiAgICAgIGlmIChwbHVnaW4uZm4gPT09IGZuKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0aGlzLnBsdWdpbnMucHVzaCh7IGZuOiBmbiwgb3B0czogb3B0cyB9KTtcblxuICBmbih0aGlzLCBvcHRzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYW4gaW5zdGFuY2UgbWV0aG9kIHRvIGRvY3VtZW50cyBjb25zdHJ1Y3RlZCBmcm9tIE1vZGVscyBjb21waWxlZCBmcm9tIHRoaXMgc2NoZW1hLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0ga2l0dHlTY2hlbWEgPSBuZXcgU2NoZW1hKC4uKTtcbiAqXG4gKiAgICAgc2NoZW1hLm1ldGhvZCgnbWVvdycsIGZ1bmN0aW9uICgpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKCdtZWVlZWVvb29vb29vb29vb293Jyk7XG4gKiAgICAgfSlcbiAqXG4gKiAgICAgY29uc3QgS2l0dHkgPSBtb25nb29zZS5tb2RlbCgnS2l0dHknLCBzY2hlbWEpO1xuICpcbiAqICAgICBjb25zdCBmaXp6ID0gbmV3IEtpdHR5O1xuICogICAgIGZpenoubWVvdygpOyAvLyBtZWVlZWVvb29vb29vb29vb29vd1xuICpcbiAqIElmIGEgaGFzaCBvZiBuYW1lL2ZuIHBhaXJzIGlzIHBhc3NlZCBhcyB0aGUgb25seSBhcmd1bWVudCwgZWFjaCBuYW1lL2ZuIHBhaXIgd2lsbCBiZSBhZGRlZCBhcyBtZXRob2RzLlxuICpcbiAqICAgICBzY2hlbWEubWV0aG9kKHtcbiAqICAgICAgICAgcHVycjogZnVuY3Rpb24gKCkge31cbiAqICAgICAgICwgc2NyYXRjaDogZnVuY3Rpb24gKCkge31cbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gbGF0ZXJcbiAqICAgICBjb25zdCBmaXp6ID0gbmV3IEtpdHR5O1xuICogICAgIGZpenoucHVycigpO1xuICogICAgIGZpenouc2NyYXRjaCgpO1xuICpcbiAqIE5PVEU6IGBTY2hlbWEubWV0aG9kKClgIGFkZHMgaW5zdGFuY2UgbWV0aG9kcyB0byB0aGUgYFNjaGVtYS5tZXRob2RzYCBvYmplY3QuIFlvdSBjYW4gYWxzbyBhZGQgaW5zdGFuY2UgbWV0aG9kcyBkaXJlY3RseSB0byB0aGUgYFNjaGVtYS5tZXRob2RzYCBvYmplY3QgYXMgc2VlbiBpbiB0aGUgW2d1aWRlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNtZXRob2RzKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gbmFtZSBUaGUgTWV0aG9kIE5hbWUgZm9yIGEgc2luZ2xlIGZ1bmN0aW9uLCBvciBhIE9iamVjdCBvZiBcInN0cmluZy1mdW5jdGlvblwiIHBhaXJzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXSBUaGUgRnVuY3Rpb24gaW4gYSBzaW5nbGUtZnVuY3Rpb24gZGVmaW5pdGlvbi5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5tZXRob2QgPSBmdW5jdGlvbihuYW1lLCBmbiwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgZm9yIChjb25zdCBpIGluIG5hbWUpIHtcbiAgICAgIHRoaXMubWV0aG9kc1tpXSA9IG5hbWVbaV07XG4gICAgICB0aGlzLm1ldGhvZE9wdGlvbnNbaV0gPSBjbG9uZShvcHRpb25zKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5tZXRob2RzW25hbWVdID0gZm47XG4gICAgdGhpcy5tZXRob2RPcHRpb25zW25hbWVdID0gY2xvbmUob3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgc3RhdGljIFwiY2xhc3NcIiBtZXRob2RzIHRvIE1vZGVscyBjb21waWxlZCBmcm9tIHRoaXMgc2NoZW1hLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSguLik7XG4gKiAgICAgLy8gRXF1aXZhbGVudCB0byBgc2NoZW1hLnN0YXRpY3MuZmluZEJ5TmFtZSA9IGZ1bmN0aW9uKG5hbWUpIHt9YDtcbiAqICAgICBzY2hlbWEuc3RhdGljKCdmaW5kQnlOYW1lJywgZnVuY3Rpb24obmFtZSkge1xuICogICAgICAgcmV0dXJuIHRoaXMuZmluZCh7IG5hbWU6IG5hbWUgfSk7XG4gKiAgICAgfSk7XG4gKlxuICogICAgIGNvbnN0IERyaW5rID0gbW9uZ29vc2UubW9kZWwoJ0RyaW5rJywgc2NoZW1hKTtcbiAqICAgICBhd2FpdCBEcmluay5maW5kQnlOYW1lKCdMYUNyb2l4Jyk7XG4gKlxuICogSWYgYSBoYXNoIG9mIG5hbWUvZm4gcGFpcnMgaXMgcGFzc2VkIGFzIHRoZSBvbmx5IGFyZ3VtZW50LCBlYWNoIG5hbWUvZm4gcGFpciB3aWxsIGJlIGFkZGVkIGFzIG1ldGhvZHMuXG4gKlxuICogICAgIHNjaGVtYS5zdGF0aWMoe1xuICogICAgICAgICBmaW5kQnlOYW1lOiBmdW5jdGlvbiAoKSB7Li59XG4gKiAgICAgICAsIGZpbmRCeUNvc3Q6IGZ1bmN0aW9uICgpIHsuLn1cbiAqICAgICB9KTtcbiAqXG4gKiAgICAgY29uc3QgRHJpbmsgPSBtb25nb29zZS5tb2RlbCgnRHJpbmsnLCBzY2hlbWEpO1xuICogICAgIGF3YWl0IERyaW5rLmZpbmRCeU5hbWUoJ0xhQ3JvaXgnKTtcbiAqICAgICBhd2FpdCBEcmluay5maW5kQnlDb3N0KDMpO1xuICpcbiAqIElmIGEgaGFzaCBvZiBuYW1lL2ZuIHBhaXJzIGlzIHBhc3NlZCBhcyB0aGUgb25seSBhcmd1bWVudCwgZWFjaCBuYW1lL2ZuIHBhaXIgd2lsbCBiZSBhZGRlZCBhcyBzdGF0aWNzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gbmFtZSBUaGUgTWV0aG9kIE5hbWUgZm9yIGEgc2luZ2xlIGZ1bmN0aW9uLCBvciBhIE9iamVjdCBvZiBcInN0cmluZy1mdW5jdGlvblwiIHBhaXJzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXSBUaGUgRnVuY3Rpb24gaW4gYSBzaW5nbGUtZnVuY3Rpb24gZGVmaW5pdGlvbi5cbiAqIEBhcGkgcHVibGljXG4gKiBAc2VlIFN0YXRpY3MgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc3RhdGljc1xuICovXG5cblNjaGVtYS5wcm90b3R5cGUuc3RhdGljID0gZnVuY3Rpb24obmFtZSwgZm4pIHtcbiAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgIGZvciAoY29uc3QgaSBpbiBuYW1lKSB7XG4gICAgICB0aGlzLnN0YXRpY3NbaV0gPSBuYW1lW2ldO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLnN0YXRpY3NbbmFtZV0gPSBmbjtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGVmaW5lcyBhbiBpbmRleCAobW9zdCBsaWtlbHkgY29tcG91bmQpIGZvciB0aGlzIHNjaGVtYS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIHNjaGVtYS5pbmRleCh7IGZpcnN0OiAxLCBsYXN0OiAtMSB9KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaWVsZHMgVGhlIEZpZWxkcyB0byBpbmRleCwgd2l0aCB0aGUgb3JkZXIsIGF2YWlsYWJsZSB2YWx1ZXM6IGAxIHwgLTEgfCAnMmQnIHwgJzJkc3BoZXJlJyB8ICdnZW9IYXlzdGFjaycgfCAnaGFzaGVkJyB8ICd0ZXh0J2BcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyB0byBwYXNzIHRvIFtNb25nb0RCIGRyaXZlcidzIGBjcmVhdGVJbmRleCgpYCBmdW5jdGlvbl0oaHR0cHM6Ly9tb25nb2RiLmdpdGh1Yi5pby9ub2RlLW1vbmdvZGItbmF0aXZlLzQuOS9jbGFzc2VzL0NvbGxlY3Rpb24uaHRtbCNjcmVhdGVJbmRleClcbiAqIEBwYXJhbSB7U3RyaW5nIHwgbnVtYmVyfSBbb3B0aW9ucy5leHBpcmVzPW51bGxdIE1vbmdvb3NlLXNwZWNpZmljIHN5bnRhY3RpYyBzdWdhciwgdXNlcyBbbXNdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21zKSB0byBjb252ZXJ0IGBleHBpcmVzYCBvcHRpb24gaW50byBzZWNvbmRzIGZvciB0aGUgYGV4cGlyZUFmdGVyU2Vjb25kc2AgaW4gdGhlIGFib3ZlIGxpbmsuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubGFuZ3VhZ2Vfb3ZlcnJpZGU9bnVsbF0gVGVsbHMgbW9uZ29kYiB0byB1c2UgdGhlIHNwZWNpZmllZCBmaWVsZCBpbnN0ZWFkIG9mIGBsYW5ndWFnZWAgZm9yIHBhcnNpbmcgdGV4dCBpbmRleGVzLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLmluZGV4ID0gZnVuY3Rpb24oZmllbGRzLCBvcHRpb25zKSB7XG4gIGZpZWxkcyB8fCAoZmllbGRzID0ge30pO1xuICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xuXG4gIGlmIChvcHRpb25zLmV4cGlyZXMpIHtcbiAgICB1dGlscy5leHBpcmVzKG9wdGlvbnMpO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIGZpZWxkcykge1xuICAgIGlmICh0aGlzLmFsaWFzZXNba2V5XSkge1xuICAgICAgZmllbGRzID0gdXRpbHMucmVuYW1lT2JqS2V5KGZpZWxkcywga2V5LCB0aGlzLmFsaWFzZXNba2V5XSk7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgZmllbGQgb2YgT2JqZWN0LmtleXMoZmllbGRzKSkge1xuICAgIGlmIChmaWVsZHNbZmllbGRdID09PSAnYXNjZW5kaW5nJyB8fCBmaWVsZHNbZmllbGRdID09PSAnYXNjJykge1xuICAgICAgZmllbGRzW2ZpZWxkXSA9IDE7XG4gICAgfSBlbHNlIGlmIChmaWVsZHNbZmllbGRdID09PSAnZGVzY2VuZGluZycgfHwgZmllbGRzW2ZpZWxkXSA9PT0gJ2Rlc2MnKSB7XG4gICAgICBmaWVsZHNbZmllbGRdID0gLTE7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5faW5kZXhlcy5wdXNoKFtmaWVsZHMsIG9wdGlvbnNdKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgYSBzY2hlbWEgb3B0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgc2NoZW1hLnNldCgnc3RyaWN0Jyk7IC8vICd0cnVlJyBieSBkZWZhdWx0XG4gKiAgICAgc2NoZW1hLnNldCgnc3RyaWN0JywgZmFsc2UpOyAvLyBTZXRzICdzdHJpY3QnIHRvIGZhbHNlXG4gKiAgICAgc2NoZW1hLnNldCgnc3RyaWN0Jyk7IC8vICdmYWxzZSdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBuYW1lIG9mIHRoZSBvcHRpb24gdG8gc2V0IHRoZSB2YWx1ZSB0b1xuICogQHBhcmFtIHtPYmplY3R9IFt2YWx1ZV0gVGhlIHZhbHVlIHRvIHNldCB0aGUgb3B0aW9uIHRvLCBpZiBub3QgcGFzc2VkLCB0aGUgb3B0aW9uIHdpbGwgYmUgcmVzZXQgdG8gZGVmYXVsdFxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBbdGFnc10gdGFncyB0byBhZGQgdG8gcmVhZCBwcmVmZXJlbmNlIGlmIGtleSA9PT0gJ3JlYWQnXG4gKiBAc2VlIFNjaGVtYSBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3NjaGVtYS5odG1sI1NjaGVtYSgpXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSwgdGFncykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnNba2V5XTtcbiAgfVxuXG4gIHN3aXRjaCAoa2V5KSB7XG4gICAgY2FzZSAncmVhZCc6XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLm9wdGlvbnNba2V5XSA9IHsgbW9kZTogaGFuZGxlUmVhZFByZWZlcmVuY2VBbGlhc2VzKHZhbHVlKSwgdGFncyB9O1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWVbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMub3B0aW9uc1trZXldID0ge1xuICAgICAgICAgIG1vZGU6IGhhbmRsZVJlYWRQcmVmZXJlbmNlQWxpYXNlcyh2YWx1ZVswXSksXG4gICAgICAgICAgdGFnczogdmFsdWVbMV1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3B0aW9uc1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgICB0aGlzLl91c2VyUHJvdmlkZWRPcHRpb25zW2tleV0gPSB0aGlzLm9wdGlvbnNba2V5XTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RpbWVzdGFtcHMnOlxuICAgICAgdGhpcy5zZXR1cFRpbWVzdGFtcCh2YWx1ZSk7XG4gICAgICB0aGlzLm9wdGlvbnNba2V5XSA9IHZhbHVlO1xuICAgICAgdGhpcy5fdXNlclByb3ZpZGVkT3B0aW9uc1trZXldID0gdGhpcy5vcHRpb25zW2tleV07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdfaWQnOlxuICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgIHRoaXMuX3VzZXJQcm92aWRlZE9wdGlvbnNba2V5XSA9IHRoaXMub3B0aW9uc1trZXldO1xuXG4gICAgICBpZiAodmFsdWUgJiYgIXRoaXMucGF0aHNbJ19pZCddKSB7XG4gICAgICAgIGFkZEF1dG9JZCh0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoIXZhbHVlICYmIHRoaXMucGF0aHNbJ19pZCddICE9IG51bGwgJiYgdGhpcy5wYXRoc1snX2lkJ10uYXV0bykge1xuICAgICAgICB0aGlzLnJlbW92ZSgnX2lkJyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgIHRoaXMuX3VzZXJQcm92aWRlZE9wdGlvbnNba2V5XSA9IHRoaXMub3B0aW9uc1trZXldO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICAvLyBQcm9wYWdhdGUgYHN0cmljdGAgYW5kIGBzdHJpY3RRdWVyeWAgY2hhbmdlcyBkb3duIHRvIGltcGxpY2l0bHkgY3JlYXRlZCBzY2hlbWFzXG4gIGlmIChrZXkgPT09ICdzdHJpY3QnKSB7XG4gICAgX3Byb3BhZ2F0ZU9wdGlvbnNUb0ltcGxpY2l0bHlDcmVhdGVkU2NoZW1hcyh0aGlzLCB7IHN0cmljdDogdmFsdWUgfSk7XG4gIH1cbiAgaWYgKGtleSA9PT0gJ3N0cmljdFF1ZXJ5Jykge1xuICAgIF9wcm9wYWdhdGVPcHRpb25zVG9JbXBsaWNpdGx5Q3JlYXRlZFNjaGVtYXModGhpcywgeyBzdHJpY3RRdWVyeTogdmFsdWUgfSk7XG4gIH1cbiAgaWYgKGtleSA9PT0gJ3RvT2JqZWN0Jykge1xuICAgIHZhbHVlID0geyAuLi52YWx1ZSB9O1xuICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIHRyYW5zZm9ybSB0byBpbXBsaWNpdGx5IGNyZWF0ZWQgc2NoZW1hcyByZTogZ2gtMzI3OVxuICAgIGRlbGV0ZSB2YWx1ZS50cmFuc2Zvcm07XG4gICAgX3Byb3BhZ2F0ZU9wdGlvbnNUb0ltcGxpY2l0bHlDcmVhdGVkU2NoZW1hcyh0aGlzLCB7IHRvT2JqZWN0OiB2YWx1ZSB9KTtcbiAgfVxuICBpZiAoa2V5ID09PSAndG9KU09OJykge1xuICAgIHZhbHVlID0geyAuLi52YWx1ZSB9O1xuICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIHRyYW5zZm9ybSB0byBpbXBsaWNpdGx5IGNyZWF0ZWQgc2NoZW1hcyByZTogZ2gtMzI3OVxuICAgIGRlbGV0ZSB2YWx1ZS50cmFuc2Zvcm07XG4gICAgX3Byb3BhZ2F0ZU9wdGlvbnNUb0ltcGxpY2l0bHlDcmVhdGVkU2NoZW1hcyh0aGlzLCB7IHRvSlNPTjogdmFsdWUgfSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qIVxuICogUmVjdXJzaXZlbHkgc2V0IG9wdGlvbnMgb24gaW1wbGljaXRseSBjcmVhdGVkIHNjaGVtYXNcbiAqL1xuXG5mdW5jdGlvbiBfcHJvcGFnYXRlT3B0aW9uc1RvSW1wbGljaXRseUNyZWF0ZWRTY2hlbWFzKGJhc2VTY2hlbWEsIG9wdGlvbnMpIHtcbiAgZm9yIChjb25zdCB7IHNjaGVtYSB9IG9mIGJhc2VTY2hlbWEuY2hpbGRTY2hlbWFzKSB7XG4gICAgaWYgKCFzY2hlbWEuJGltcGxpY2l0bHlDcmVhdGVkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbihzY2hlbWEub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgX3Byb3BhZ2F0ZU9wdGlvbnNUb0ltcGxpY2l0bHlDcmVhdGVkU2NoZW1hcyhzY2hlbWEsIG9wdGlvbnMpO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyBhIHNjaGVtYSBvcHRpb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBzY2hlbWEuZ2V0KCdzdHJpY3QnKTsgLy8gdHJ1ZVxuICogICAgIHNjaGVtYS5zZXQoJ3N0cmljdCcsIGZhbHNlKTtcbiAqICAgICBzY2hlbWEuZ2V0KCdzdHJpY3QnKTsgLy8gZmFsc2VcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBuYW1lIG9mIHRoZSBPcHRpb24gdG8gZ2V0IHRoZSBjdXJyZW50IHZhbHVlIGZvclxuICogQGFwaSBwdWJsaWNcbiAqIEByZXR1cm4ge0FueX0gdGhlIG9wdGlvbidzIHZhbHVlXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgcmV0dXJuIHRoaXMub3B0aW9uc1trZXldO1xufTtcblxuY29uc3QgaW5kZXhUeXBlcyA9ICcyZCAyZHNwaGVyZSBoYXNoZWQgdGV4dCcuc3BsaXQoJyAnKTtcblxuLyoqXG4gKiBUaGUgYWxsb3dlZCBpbmRleCB0eXBlc1xuICpcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nW119IGluZGV4VHlwZXNcbiAqIEBtZW1iZXJPZiBTY2hlbWFcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYSwgJ2luZGV4VHlwZXMnLCB7XG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGluZGV4VHlwZXM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgb3ZlcndyaXRlIFNjaGVtYS5pbmRleFR5cGVzJyk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIGluZGV4ZXMgdGhhdCB0aGlzIHNjaGVtYSBkZWNsYXJlcywgdmlhIGBzY2hlbWEuaW5kZXgoKWAgb3IgYnkgYGluZGV4OiB0cnVlYCBpbiBhIHBhdGgncyBvcHRpb25zLlxuICogSW5kZXhlcyBhcmUgZXhwcmVzc2VkIGFzIGFuIGFycmF5IGBbc3BlYywgb3B0aW9uc11gLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgdXNlclNjaGVtYSA9IG5ldyBTY2hlbWEoe1xuICogICAgICAgZW1haWw6IHsgdHlwZTogU3RyaW5nLCByZXF1aXJlZDogdHJ1ZSwgdW5pcXVlOiB0cnVlIH0sXG4gKiAgICAgICByZWdpc3RlcmVkQXQ6IHsgdHlwZTogRGF0ZSwgaW5kZXg6IHRydWUgfVxuICogICAgIH0pO1xuICpcbiAqICAgICAvLyBbIFsgeyBlbWFpbDogMSB9LCB7IHVuaXF1ZTogdHJ1ZSwgYmFja2dyb3VuZDogdHJ1ZSB9IF0sXG4gKiAgICAgLy8gICBbIHsgcmVnaXN0ZXJlZEF0OiAxIH0sIHsgYmFja2dyb3VuZDogdHJ1ZSB9IF0gXVxuICogICAgIHVzZXJTY2hlbWEuaW5kZXhlcygpO1xuICpcbiAqIFtQbHVnaW5zXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvcGx1Z2lucy5odG1sKSBjYW4gdXNlIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhpcyBmdW5jdGlvbiB0byBtb2RpZnkgYSBzY2hlbWEncyBpbmRleGVzLlxuICogRm9yIGV4YW1wbGUsIHRoZSBiZWxvdyBwbHVnaW4gbWFrZXMgZXZlcnkgaW5kZXggdW5pcXVlIGJ5IGRlZmF1bHQuXG4gKlxuICogICAgIGZ1bmN0aW9uIG15UGx1Z2luKHNjaGVtYSkge1xuICogICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBzY2hlbWEuaW5kZXhlcygpKSB7XG4gKiAgICAgICAgIGlmIChpbmRleFsxXS51bmlxdWUgPT09IHVuZGVmaW5lZCkge1xuICogICAgICAgICAgIGluZGV4WzFdLnVuaXF1ZSA9IHRydWU7XG4gKiAgICAgICAgIH1cbiAqICAgICAgIH1cbiAqICAgICB9XG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEByZXR1cm4ge0FycmF5fSBsaXN0IG9mIGluZGV4ZXMgZGVmaW5lZCBpbiB0aGUgc2NoZW1hXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5pbmRleGVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBnZXRJbmRleGVzKHRoaXMpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgdmlydHVhbCB0eXBlIHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIFZpcnR1YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7U3RyaW5nfE1vZGVsfSBbb3B0aW9ucy5yZWZdIG1vZGVsIG5hbWUgb3IgbW9kZWwgaW5zdGFuY2UuIE1hcmtzIHRoaXMgYXMgYSBbcG9wdWxhdGUgdmlydHVhbF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3BvcHVsYXRlLmh0bWwjcG9wdWxhdGUtdmlydHVhbHMpLlxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IFtvcHRpb25zLmxvY2FsRmllbGRdIFJlcXVpcmVkIGZvciBwb3B1bGF0ZSB2aXJ0dWFscy4gU2VlIFtwb3B1bGF0ZSB2aXJ0dWFsIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9wb3B1bGF0ZS5odG1sI3BvcHVsYXRlLXZpcnR1YWxzKSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBbb3B0aW9ucy5mb3JlaWduRmllbGRdIFJlcXVpcmVkIGZvciBwb3B1bGF0ZSB2aXJ0dWFscy4gU2VlIFtwb3B1bGF0ZSB2aXJ0dWFsIGRvY3NdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9wb3B1bGF0ZS5odG1sI3BvcHVsYXRlLXZpcnR1YWxzKSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gW29wdGlvbnMuanVzdE9uZT1mYWxzZV0gT25seSB3b3JrcyB3aXRoIHBvcHVsYXRlIHZpcnR1YWxzLiBJZiBbdHJ1dGh5XShodHRwczovL21hc3RlcmluZ2pzLmlvL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvdHJ1dGh5KSwgd2lsbCBiZSBhIHNpbmdsZSBkb2Mgb3IgYG51bGxgLiBPdGhlcndpc2UsIHRoZSBwb3B1bGF0ZSB2aXJ0dWFsIHdpbGwgYmUgYW4gYXJyYXkuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNvdW50PWZhbHNlXSBPbmx5IHdvcmtzIHdpdGggcG9wdWxhdGUgdmlydHVhbHMuIElmIFt0cnV0aHldKGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy90cnV0aHkpLCB0aGlzIHBvcHVsYXRlIHZpcnR1YWwgd2lsbCBjb250YWluIHRoZSBudW1iZXIgb2YgZG9jdW1lbnRzIHJhdGhlciB0aGFuIHRoZSBkb2N1bWVudHMgdGhlbXNlbHZlcyB3aGVuIHlvdSBgcG9wdWxhdGUoKWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufG51bGx9IFtvcHRpb25zLmdldD1udWxsXSBBZGRzIGEgW2dldHRlcl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3R1dG9yaWFscy9nZXR0ZXJzLXNldHRlcnMuaHRtbCkgdG8gdGhpcyB2aXJ0dWFsIHRvIHRyYW5zZm9ybSB0aGUgcG9wdWxhdGVkIGRvYy5cbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBbb3B0aW9ucy5tYXRjaD1udWxsXSBBcHBseSBhIGRlZmF1bHQgW2BtYXRjaGAgb3B0aW9uIHRvIHBvcHVsYXRlXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvcG9wdWxhdGUuaHRtbCNtYXRjaCksIGFkZGluZyBhbiBhZGRpdGlvbmFsIGZpbHRlciB0byB0aGUgcG9wdWxhdGUgcXVlcnkuXG4gKiBAcmV0dXJuIHtWaXJ0dWFsVHlwZX1cbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLnZpcnR1YWwgPSBmdW5jdGlvbihuYW1lLCBvcHRpb25zKSB7XG4gIGlmIChuYW1lIGluc3RhbmNlb2YgVmlydHVhbFR5cGUgfHwgZ2V0Q29uc3RydWN0b3JOYW1lKG5hbWUpID09PSAnVmlydHVhbFR5cGUnKSB7XG4gICAgcmV0dXJuIHRoaXMudmlydHVhbChuYW1lLnBhdGgsIG5hbWUub3B0aW9ucyk7XG4gIH1cbiAgb3B0aW9ucyA9IG5ldyBWaXJ0dWFsT3B0aW9ucyhvcHRpb25zKTtcblxuICBpZiAodXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eShvcHRpb25zLCBbJ3JlZicsICdyZWZQYXRoJ10pKSB7XG4gICAgaWYgKG9wdGlvbnMubG9jYWxGaWVsZCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZmVyZW5jZSB2aXJ0dWFscyByZXF1aXJlIGBsb2NhbEZpZWxkYCBvcHRpb24nKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5mb3JlaWduRmllbGQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWZlcmVuY2UgdmlydHVhbHMgcmVxdWlyZSBgZm9yZWlnbkZpZWxkYCBvcHRpb24nKTtcbiAgICB9XG5cbiAgICB0aGlzLnByZSgnaW5pdCcsIGZ1bmN0aW9uIHZpcnR1YWxQcmVJbml0KG9iaikge1xuICAgICAgaWYgKG1wYXRoLmhhcyhuYW1lLCBvYmopKSB7XG4gICAgICAgIGNvbnN0IF92ID0gbXBhdGguZ2V0KG5hbWUsIG9iaik7XG4gICAgICAgIGlmICghdGhpcy4kJHBvcHVsYXRlZFZpcnR1YWxzKSB7XG4gICAgICAgICAgdGhpcy4kJHBvcHVsYXRlZFZpcnR1YWxzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5qdXN0T25lIHx8IG9wdGlvbnMuY291bnQpIHtcbiAgICAgICAgICB0aGlzLiQkcG9wdWxhdGVkVmlydHVhbHNbbmFtZV0gPSBBcnJheS5pc0FycmF5KF92KSA/XG4gICAgICAgICAgICBfdlswXSA6XG4gICAgICAgICAgICBfdjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLiQkcG9wdWxhdGVkVmlydHVhbHNbbmFtZV0gPSBBcnJheS5pc0FycmF5KF92KSA/XG4gICAgICAgICAgICBfdiA6XG4gICAgICAgICAgICBfdiA9PSBudWxsID8gW10gOiBbX3ZdO1xuICAgICAgICB9XG5cbiAgICAgICAgbXBhdGgudW5zZXQobmFtZSwgb2JqKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHZpcnR1YWwgPSB0aGlzLnZpcnR1YWwobmFtZSk7XG4gICAgdmlydHVhbC5vcHRpb25zID0gb3B0aW9ucztcblxuICAgIHZpcnR1YWwuXG4gICAgICBzZXQoZnVuY3Rpb24odikge1xuICAgICAgICBpZiAoIXRoaXMuJCRwb3B1bGF0ZWRWaXJ0dWFscykge1xuICAgICAgICAgIHRoaXMuJCRwb3B1bGF0ZWRWaXJ0dWFscyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNldFBvcHVsYXRlZFZpcnR1YWxWYWx1ZShcbiAgICAgICAgICB0aGlzLiQkcG9wdWxhdGVkVmlydHVhbHMsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICB2LFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmlydHVhbC5nZXQob3B0aW9ucy5nZXQpO1xuICAgIH1cblxuICAgIC8vIFdvcmthcm91bmQgZm9yIGdoLTgxOTg6IGlmIHZpcnR1YWwgaXMgdW5kZXIgZG9jdW1lbnQgYXJyYXksIG1ha2UgYSBmYWtlXG4gICAgLy8gdmlydHVhbC4gU2VlIGdoLTgyMTAsIGdoLTEzMTg5XG4gICAgY29uc3QgcGFydHMgPSBuYW1lLnNwbGl0KCcuJyk7XG4gICAgbGV0IGN1ciA9IHBhcnRzWzBdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICBpZiAodGhpcy5wYXRoc1tjdXJdID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnBhdGhzW2N1cl0uJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5IHx8IHRoaXMucGF0aHNbY3VyXS4kaXNTaW5nbGVOZXN0ZWQpIHtcbiAgICAgICAgY29uc3QgcmVtbmFudCA9IHBhcnRzLnNsaWNlKGkgKyAxKS5qb2luKCcuJyk7XG4gICAgICAgIHRoaXMucGF0aHNbY3VyXS5zY2hlbWEudmlydHVhbChyZW1uYW50LCBvcHRpb25zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGN1ciArPSAnLicgKyBwYXJ0c1tpICsgMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHZpcnR1YWw7XG4gIH1cblxuICBjb25zdCB2aXJ0dWFscyA9IHRoaXMudmlydHVhbHM7XG4gIGNvbnN0IHBhcnRzID0gbmFtZS5zcGxpdCgnLicpO1xuXG4gIGlmICh0aGlzLnBhdGhUeXBlKG5hbWUpID09PSAncmVhbCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZpcnR1YWwgcGF0aCBcIicgKyBuYW1lICsgJ1wiJyArXG4gICAgICAnIGNvbmZsaWN0cyB3aXRoIGEgcmVhbCBwYXRoIGluIHRoZSBzY2hlbWEnKTtcbiAgfVxuXG4gIHZpcnR1YWxzW25hbWVdID0gcGFydHMucmVkdWNlKGZ1bmN0aW9uKG1lbSwgcGFydCwgaSkge1xuICAgIG1lbVtwYXJ0XSB8fCAobWVtW3BhcnRdID0gKGkgPT09IHBhcnRzLmxlbmd0aCAtIDEpXG4gICAgICA/IG5ldyBWaXJ0dWFsVHlwZShvcHRpb25zLCBuYW1lKVxuICAgICAgOiB7fSk7XG4gICAgcmV0dXJuIG1lbVtwYXJ0XTtcbiAgfSwgdGhpcy50cmVlKTtcblxuICByZXR1cm4gdmlydHVhbHNbbmFtZV07XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHZpcnR1YWwgdHlwZSB3aXRoIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIFZpcnR1YWwgdG8gZ2V0XG4gKiBAcmV0dXJuIHtWaXJ0dWFsVHlwZXxudWxsfVxuICovXG5cblNjaGVtYS5wcm90b3R5cGUudmlydHVhbHBhdGggPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiB0aGlzLnZpcnR1YWxzLmhhc093blByb3BlcnR5KG5hbWUpID8gdGhpcy52aXJ0dWFsc1tuYW1lXSA6IG51bGw7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgdGhlIGdpdmVuIGBwYXRoYCAob3IgW2BwYXRoc2BdKS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiBTdHJpbmcsIGFnZTogTnVtYmVyIH0pO1xuICogICAgIHNjaGVtYS5yZW1vdmUoJ25hbWUnKTtcbiAqICAgICBzY2hlbWEucGF0aCgnbmFtZScpOyAvLyBVbmRlZmluZWRcbiAqICAgICBzY2hlbWEucGF0aCgnYWdlJyk7IC8vIFNjaGVtYU51bWJlciB7IC4uLiB9XG4gKlxuICogT3IgYXMgYSBBcnJheTpcbiAqXG4gKiAgICAgc2NoZW1hLnJlbW92ZShbJ25hbWUnLCAnYWdlJ10pO1xuICogICAgIHNjaGVtYS5wYXRoKCduYW1lJyk7IC8vIFVuZGVmaW5lZFxuICogICAgIHNjaGVtYS5wYXRoKCdhZ2UnKTsgLy8gVW5kZWZpbmVkXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHBhdGggVGhlIFBhdGgocykgdG8gcmVtb3ZlXG4gKiBAcmV0dXJuIHtTY2hlbWF9IHRoZSBTY2hlbWEgaW5zdGFuY2VcbiAqIEBhcGkgcHVibGljXG4gKi9cblNjaGVtYS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24ocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgcGF0aCA9IFtwYXRoXTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgIHBhdGguZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICBpZiAodGhpcy5wYXRoKG5hbWUpID09IG51bGwgJiYgIXRoaXMubmVzdGVkW25hbWVdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm5lc3RlZFtuYW1lXSkge1xuICAgICAgICBjb25zdCBhbGxLZXlzID0gT2JqZWN0LmtleXModGhpcy5wYXRocykuXG4gICAgICAgICAgY29uY2F0KE9iamVjdC5rZXlzKHRoaXMubmVzdGVkKSk7XG4gICAgICAgIGZvciAoY29uc3QgcGF0aCBvZiBhbGxLZXlzKSB7XG4gICAgICAgICAgaWYgKHBhdGguc3RhcnRzV2l0aChuYW1lICsgJy4nKSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMucGF0aHNbcGF0aF07XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5uZXN0ZWRbcGF0aF07XG4gICAgICAgICAgICBfZGVsZXRlUGF0aCh0aGlzLCBwYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgdGhpcy5uZXN0ZWRbbmFtZV07XG4gICAgICAgIF9kZWxldGVQYXRoKHRoaXMsIG5hbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSB0aGlzLnBhdGhzW25hbWVdO1xuICAgICAgX2RlbGV0ZVBhdGgodGhpcywgbmFtZSk7XG4gICAgfSwgdGhpcyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9kZWxldGVQYXRoKHNjaGVtYSwgbmFtZSkge1xuICBjb25zdCBwaWVjZXMgPSBuYW1lLnNwbGl0KCcuJyk7XG4gIGNvbnN0IGxhc3QgPSBwaWVjZXMucG9wKCk7XG5cbiAgbGV0IGJyYW5jaCA9IHNjaGVtYS50cmVlO1xuXG4gIGZvciAoY29uc3QgcGllY2Ugb2YgcGllY2VzKSB7XG4gICAgYnJhbmNoID0gYnJhbmNoW3BpZWNlXTtcbiAgfVxuXG4gIGRlbGV0ZSBicmFuY2hbbGFzdF07XG59XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgZ2l2ZW4gdmlydHVhbCBvciB2aXJ0dWFscyBmcm9tIHRoZSBzY2hlbWEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHBhdGggVGhlIHZpcnV0YWwgcGF0aChzKSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7U2NoZW1hfSB0aGUgU2NoZW1hIGluc3RhbmNlLCBvciBhIG1vbmdvb3NlIGVycm9yIGlmIHRoZSB2aXJ0dWFsIGRvZXMgbm90IGV4aXN0LlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLnJlbW92ZVZpcnR1YWwgPSBmdW5jdGlvbihwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICBwYXRoID0gW3BhdGhdO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgZm9yIChjb25zdCB2aXJ0dWFsIG9mIHBhdGgpIHtcbiAgICAgIGlmICh0aGlzLnZpcnR1YWxzW3ZpcnR1YWxdID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoYEF0dGVtcHRpbmcgdG8gcmVtb3ZlIHZpcnR1YWwgXCIke3ZpcnR1YWx9XCIgdGhhdCBkb2VzIG5vdCBleGlzdC5gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHZpcnR1YWwgb2YgcGF0aCkge1xuICAgICAgZGVsZXRlIHRoaXMucGF0aHNbdmlydHVhbF07XG4gICAgICBkZWxldGUgdGhpcy52aXJ0dWFsc1t2aXJ0dWFsXTtcbiAgICAgIGlmICh2aXJ0dWFsLmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICAgICAgbXBhdGgudW5zZXQodmlydHVhbCwgdGhpcy50cmVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnRyZWVbdmlydHVhbF07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBMb2FkcyBhbiBFUzYgY2xhc3MgaW50byBhIHNjaGVtYS4gTWFwcyBbc2V0dGVyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvRnVuY3Rpb25zL3NldCkgKyBbZ2V0dGVyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvRnVuY3Rpb25zL2dldCksIFtzdGF0aWMgbWV0aG9kc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvQ2xhc3Nlcy9zdGF0aWMpLFxuICogYW5kIFtpbnN0YW5jZSBtZXRob2RzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9DbGFzc2VzI0NsYXNzX2JvZHlfYW5kX21ldGhvZF9kZWZpbml0aW9ucylcbiAqIHRvIHNjaGVtYSBbdmlydHVhbHNdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9ndWlkZS5odG1sI3ZpcnR1YWxzKSxcbiAqIFtzdGF0aWNzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZ3VpZGUuaHRtbCNzdGF0aWNzKSwgYW5kXG4gKiBbbWV0aG9kc10oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjbWV0aG9kcykuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGNvbnN0IG1kNSA9IHJlcXVpcmUoJ21kNScpO1xuICogY29uc3QgdXNlclNjaGVtYSA9IG5ldyBTY2hlbWEoeyBlbWFpbDogU3RyaW5nIH0pO1xuICogY2xhc3MgVXNlckNsYXNzIHtcbiAqICAgLy8gYGdyYXZhdGFySW1hZ2VgIGJlY29tZXMgYSB2aXJ0dWFsXG4gKiAgIGdldCBncmF2YXRhckltYWdlKCkge1xuICogICAgIGNvbnN0IGhhc2ggPSBtZDUodGhpcy5lbWFpbC50b0xvd2VyQ2FzZSgpKTtcbiAqICAgICByZXR1cm4gYGh0dHBzOi8vd3d3LmdyYXZhdGFyLmNvbS9hdmF0YXIvJHtoYXNofWA7XG4gKiAgIH1cbiAqXG4gKiAgIC8vIGBnZXRQcm9maWxlVXJsKClgIGJlY29tZXMgYSBkb2N1bWVudCBtZXRob2RcbiAqICAgZ2V0UHJvZmlsZVVybCgpIHtcbiAqICAgICByZXR1cm4gYGh0dHBzOi8vbXlzaXRlLmNvbS8ke3RoaXMuZW1haWx9YDtcbiAqICAgfVxuICpcbiAqICAgLy8gYGZpbmRCeUVtYWlsKClgIGJlY29tZXMgYSBzdGF0aWNcbiAqICAgc3RhdGljIGZpbmRCeUVtYWlsKGVtYWlsKSB7XG4gKiAgICAgcmV0dXJuIHRoaXMuZmluZE9uZSh7IGVtYWlsIH0pO1xuICogICB9XG4gKiB9XG4gKlxuICogLy8gYHNjaGVtYWAgd2lsbCBub3cgaGF2ZSBhIGBncmF2YXRhckltYWdlYCB2aXJ0dWFsLCBhIGBnZXRQcm9maWxlVXJsKClgIG1ldGhvZCxcbiAqIC8vIGFuZCBhIGBmaW5kQnlFbWFpbCgpYCBzdGF0aWNcbiAqIHVzZXJTY2hlbWEubG9hZENsYXNzKFVzZXJDbGFzcyk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtb2RlbCBUaGUgQ2xhc3MgdG8gbG9hZFxuICogQHBhcmFtIHtCb29sZWFufSBbdmlydHVhbHNPbmx5XSBpZiB0cnV0aHksIG9ubHkgcHVsbHMgdmlydHVhbHMgZnJvbSB0aGUgY2xhc3MsIG5vdCBtZXRob2RzIG9yIHN0YXRpY3NcbiAqL1xuU2NoZW1hLnByb3RvdHlwZS5sb2FkQ2xhc3MgPSBmdW5jdGlvbihtb2RlbCwgdmlydHVhbHNPbmx5KSB7XG4gIC8vIFN0b3AgY29weWluZyB3aGVuIGhpdCBjZXJ0YWluIGJhc2UgY2xhc3Nlc1xuICBpZiAobW9kZWwgPT09IE9iamVjdC5wcm90b3R5cGUgfHxcbiAgICAgIG1vZGVsID09PSBGdW5jdGlvbi5wcm90b3R5cGUgfHxcbiAgICAgIG1vZGVsLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnJGlzTW9uZ29vc2VNb2RlbFByb3RvdHlwZScpIHx8XG4gICAgICBtb2RlbC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJyRpc01vbmdvb3NlRG9jdW1lbnRQcm90b3R5cGUnKSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdGhpcy5sb2FkQ2xhc3MoT2JqZWN0LmdldFByb3RvdHlwZU9mKG1vZGVsKSwgdmlydHVhbHNPbmx5KTtcblxuICAvLyBBZGQgc3RhdGljIG1ldGhvZHNcbiAgaWYgKCF2aXJ0dWFsc09ubHkpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhtb2RlbCkuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICBpZiAobmFtZS5tYXRjaCgvXihsZW5ndGh8bmFtZXxwcm90b3R5cGV8Y29uc3RydWN0b3J8X19wcm90b19fKSQvKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwcm9wID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtb2RlbCwgbmFtZSk7XG4gICAgICBpZiAocHJvcC5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSkge1xuICAgICAgICB0aGlzLnN0YXRpYyhuYW1lLCBwcm9wLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfVxuXG4gIC8vIEFkZCBtZXRob2RzIGFuZCB2aXJ0dWFsc1xuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhtb2RlbC5wcm90b3R5cGUpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgIGlmIChuYW1lLm1hdGNoKC9eKGNvbnN0cnVjdG9yKSQvKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZXRob2QgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG1vZGVsLnByb3RvdHlwZSwgbmFtZSk7XG4gICAgaWYgKCF2aXJ0dWFsc09ubHkpIHtcbiAgICAgIGlmICh0eXBlb2YgbWV0aG9kLnZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMubWV0aG9kKG5hbWUsIG1ldGhvZC52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbWV0aG9kLmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHRoaXMudmlydHVhbHNbbmFtZV0pIHtcbiAgICAgICAgdGhpcy52aXJ0dWFsc1tuYW1lXS5nZXR0ZXJzID0gW107XG4gICAgICB9XG4gICAgICB0aGlzLnZpcnR1YWwobmFtZSkuZ2V0KG1ldGhvZC5nZXQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG1ldGhvZC5zZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh0aGlzLnZpcnR1YWxzW25hbWVdKSB7XG4gICAgICAgIHRoaXMudmlydHVhbHNbbmFtZV0uc2V0dGVycyA9IFtdO1xuICAgICAgfVxuICAgICAgdGhpcy52aXJ0dWFsKG5hbWUpLnNldChtZXRob2Quc2V0KTtcbiAgICB9XG4gIH0sIHRoaXMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWEucHJvdG90eXBlLl9nZXRTY2hlbWEgPSBmdW5jdGlvbihwYXRoKSB7XG4gIGNvbnN0IF90aGlzID0gdGhpcztcbiAgY29uc3QgcGF0aHNjaGVtYSA9IF90aGlzLnBhdGgocGF0aCk7XG4gIGNvbnN0IHJlc3VsdFBhdGggPSBbXTtcblxuICBpZiAocGF0aHNjaGVtYSkge1xuICAgIHBhdGhzY2hlbWEuJGZ1bGxQYXRoID0gcGF0aDtcbiAgICByZXR1cm4gcGF0aHNjaGVtYTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlYXJjaChwYXJ0cywgc2NoZW1hKSB7XG4gICAgbGV0IHAgPSBwYXJ0cy5sZW5ndGggKyAxO1xuICAgIGxldCBmb3VuZHNjaGVtYTtcbiAgICBsZXQgdHJ5cGF0aDtcblxuICAgIHdoaWxlIChwLS0pIHtcbiAgICAgIHRyeXBhdGggPSBwYXJ0cy5zbGljZSgwLCBwKS5qb2luKCcuJyk7XG4gICAgICBmb3VuZHNjaGVtYSA9IHNjaGVtYS5wYXRoKHRyeXBhdGgpO1xuICAgICAgaWYgKGZvdW5kc2NoZW1hKSB7XG4gICAgICAgIHJlc3VsdFBhdGgucHVzaCh0cnlwYXRoKTtcblxuICAgICAgICBpZiAoZm91bmRzY2hlbWEuY2FzdGVyKSB7XG4gICAgICAgICAgLy8gYXJyYXkgb2YgTWl4ZWQ/XG4gICAgICAgICAgaWYgKGZvdW5kc2NoZW1hLmNhc3RlciBpbnN0YW5jZW9mIE1vbmdvb3NlVHlwZXMuTWl4ZWQpIHtcbiAgICAgICAgICAgIGZvdW5kc2NoZW1hLmNhc3Rlci4kZnVsbFBhdGggPSByZXN1bHRQYXRoLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZHNjaGVtYS5jYXN0ZXI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gTm93IHRoYXQgd2UgZm91bmQgdGhlIGFycmF5LCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZXJlXG4gICAgICAgICAgLy8gYXJlIHJlbWFpbmluZyBkb2N1bWVudCBwYXRocyB0byBsb29rIHVwIGZvciBjYXN0aW5nLlxuICAgICAgICAgIC8vIEFsc28gd2UgbmVlZCB0byBoYW5kbGUgYXJyYXkuJC5wYXRoIHNpbmNlIHNjaGVtYS5wYXRoXG4gICAgICAgICAgLy8gZG9lc24ndCB3b3JrIGZvciB0aGF0LlxuICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGZvdW5kc2NoZW1hLnNjaGVtYSB3ZSBhcmUgZGVhbGluZyB3aXRoXG4gICAgICAgICAgLy8gYSBwYXRoIGxpa2UgYXJyYXkuJFxuICAgICAgICAgIGlmIChwICE9PSBwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChmb3VuZHNjaGVtYS5zY2hlbWEpIHtcbiAgICAgICAgICAgICAgbGV0IHJldDtcbiAgICAgICAgICAgICAgaWYgKHBhcnRzW3BdID09PSAnJCcgfHwgaXNBcnJheUZpbHRlcihwYXJ0c1twXSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocCArIDEgPT09IHBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgLy8gY29tbWVudHMuJFxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kc2NoZW1hLiRlbWJlZGRlZFNjaGVtYVR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNvbW1lbnRzLiQuY29tbWVudHMuJC50aXRsZVxuICAgICAgICAgICAgICAgIHJldCA9IHNlYXJjaChwYXJ0cy5zbGljZShwICsgMSksIGZvdW5kc2NoZW1hLnNjaGVtYSk7XG4gICAgICAgICAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgICAgICAgICAgcmV0LiRwYXJlbnRTY2hlbWFEb2NBcnJheSA9IHJldC4kcGFyZW50U2NoZW1hRG9jQXJyYXkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGZvdW5kc2NoZW1hLnNjaGVtYS4kaXNTaW5nbGVOZXN0ZWQgPyBudWxsIDogZm91bmRzY2hlbWEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIGxhc3QgcGF0aCBvZiB0aGUgc2VsZWN0b3JcbiAgICAgICAgICAgICAgcmV0ID0gc2VhcmNoKHBhcnRzLnNsaWNlKHApLCBmb3VuZHNjaGVtYS5zY2hlbWEpO1xuICAgICAgICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgICAgICAgcmV0LiRwYXJlbnRTY2hlbWFEb2NBcnJheSA9IHJldC4kcGFyZW50U2NoZW1hRG9jQXJyYXkgfHxcbiAgICAgICAgICAgICAgICAgIChmb3VuZHNjaGVtYS5zY2hlbWEuJGlzU2luZ2xlTmVzdGVkID8gbnVsbCA6IGZvdW5kc2NoZW1hKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChmb3VuZHNjaGVtYS4kaXNTY2hlbWFNYXApIHtcbiAgICAgICAgICBpZiAocCA+PSBwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZHNjaGVtYTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQW55IHBhdGggaW4gdGhlIG1hcCB3aWxsIGJlIGFuIGluc3RhbmNlIG9mIHRoZSBtYXAncyBlbWJlZGRlZCBzY2hlbWF0eXBlXG4gICAgICAgICAgaWYgKHAgKyAxID49IHBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kc2NoZW1hLiRfX3NjaGVtYVR5cGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZvdW5kc2NoZW1hLiRfX3NjaGVtYVR5cGUgaW5zdGFuY2VvZiBNb25nb29zZVR5cGVzLk1peGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZm91bmRzY2hlbWEuJF9fc2NoZW1hVHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZvdW5kc2NoZW1hLiRfX3NjaGVtYVR5cGUuc2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIE1hcCBvZiBkb2NzXG4gICAgICAgICAgICBjb25zdCByZXQgPSBzZWFyY2gocGFydHMuc2xpY2UocCArIDEpLCBmb3VuZHNjaGVtYS4kX19zY2hlbWFUeXBlLnNjaGVtYSk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvdW5kc2NoZW1hLiRmdWxsUGF0aCA9IHJlc3VsdFBhdGguam9pbignLicpO1xuXG4gICAgICAgIHJldHVybiBmb3VuZHNjaGVtYTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBsb29rIGZvciBhcnJheXNcbiAgY29uc3QgcGFydHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAocGFydHNbaV0gPT09ICckJyB8fCBpc0FycmF5RmlsdGVyKHBhcnRzW2ldKSkge1xuICAgICAgLy8gUmU6IGdoLTU2MjgsIGJlY2F1c2UgYHNjaGVtYS5wYXRoKClgIGRvZXNuJ3QgdGFrZSAkIGludG8gYWNjb3VudC5cbiAgICAgIHBhcnRzW2ldID0gJzAnO1xuICAgIH1cbiAgICBpZiAobnVtYmVyUkUudGVzdChwYXJ0c1tpXSkpIHtcbiAgICAgIHBhcnRzW2ldID0gJyQnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2VhcmNoKHBhcnRzLCBfdGhpcyk7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYS5wcm90b3R5cGUuX2dldFBhdGhUeXBlID0gZnVuY3Rpb24ocGF0aCkge1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIGNvbnN0IHBhdGhzY2hlbWEgPSBfdGhpcy5wYXRoKHBhdGgpO1xuXG4gIGlmIChwYXRoc2NoZW1hKSB7XG4gICAgcmV0dXJuICdyZWFsJztcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlYXJjaChwYXJ0cywgc2NoZW1hKSB7XG4gICAgbGV0IHAgPSBwYXJ0cy5sZW5ndGggKyAxLFxuICAgICAgICBmb3VuZHNjaGVtYSxcbiAgICAgICAgdHJ5cGF0aDtcblxuICAgIHdoaWxlIChwLS0pIHtcbiAgICAgIHRyeXBhdGggPSBwYXJ0cy5zbGljZSgwLCBwKS5qb2luKCcuJyk7XG4gICAgICBmb3VuZHNjaGVtYSA9IHNjaGVtYS5wYXRoKHRyeXBhdGgpO1xuICAgICAgaWYgKGZvdW5kc2NoZW1hKSB7XG4gICAgICAgIGlmIChmb3VuZHNjaGVtYS5jYXN0ZXIpIHtcbiAgICAgICAgICAvLyBhcnJheSBvZiBNaXhlZD9cbiAgICAgICAgICBpZiAoZm91bmRzY2hlbWEuY2FzdGVyIGluc3RhbmNlb2YgTW9uZ29vc2VUeXBlcy5NaXhlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc2NoZW1hOiBmb3VuZHNjaGVtYSwgcGF0aFR5cGU6ICdtaXhlZCcgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBOb3cgdGhhdCB3ZSBmb3VuZCB0aGUgYXJyYXksIHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlcmVcbiAgICAgICAgICAvLyBhcmUgcmVtYWluaW5nIGRvY3VtZW50IHBhdGhzIHRvIGxvb2sgdXAgZm9yIGNhc3RpbmcuXG4gICAgICAgICAgLy8gQWxzbyB3ZSBuZWVkIHRvIGhhbmRsZSBhcnJheS4kLnBhdGggc2luY2Ugc2NoZW1hLnBhdGhcbiAgICAgICAgICAvLyBkb2Vzbid0IHdvcmsgZm9yIHRoYXQuXG4gICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gZm91bmRzY2hlbWEuc2NoZW1hIHdlIGFyZSBkZWFsaW5nIHdpdGhcbiAgICAgICAgICAvLyBhIHBhdGggbGlrZSBhcnJheS4kXG4gICAgICAgICAgaWYgKHAgIT09IHBhcnRzLmxlbmd0aCAmJiBmb3VuZHNjaGVtYS5zY2hlbWEpIHtcbiAgICAgICAgICAgIGlmIChwYXJ0c1twXSA9PT0gJyQnIHx8IGlzQXJyYXlGaWx0ZXIocGFydHNbcF0pKSB7XG4gICAgICAgICAgICAgIGlmIChwID09PSBwYXJ0cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc2NoZW1hOiBmb3VuZHNjaGVtYSwgcGF0aFR5cGU6ICduZXN0ZWQnIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gY29tbWVudHMuJC5jb21tZW50cy4kLnRpdGxlXG4gICAgICAgICAgICAgIHJldHVybiBzZWFyY2gocGFydHMuc2xpY2UocCArIDEpLCBmb3VuZHNjaGVtYS5zY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgbGFzdCBwYXRoIG9mIHRoZSBzZWxlY3RvclxuICAgICAgICAgICAgcmV0dXJuIHNlYXJjaChwYXJ0cy5zbGljZShwKSwgZm91bmRzY2hlbWEuc2NoZW1hKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNjaGVtYTogZm91bmRzY2hlbWEsXG4gICAgICAgICAgICBwYXRoVHlwZTogZm91bmRzY2hlbWEuJGlzU2luZ2xlTmVzdGVkID8gJ25lc3RlZCcgOiAnYXJyYXknXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzY2hlbWE6IGZvdW5kc2NoZW1hLCBwYXRoVHlwZTogJ3JlYWwnIH07XG4gICAgICB9IGVsc2UgaWYgKHAgPT09IHBhcnRzLmxlbmd0aCAmJiBzY2hlbWEubmVzdGVkW3RyeXBhdGhdKSB7XG4gICAgICAgIHJldHVybiB7IHNjaGVtYTogc2NoZW1hLCBwYXRoVHlwZTogJ25lc3RlZCcgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc2NoZW1hOiBmb3VuZHNjaGVtYSB8fCBzY2hlbWEsIHBhdGhUeXBlOiAndW5kZWZpbmVkJyB9O1xuICB9XG5cbiAgLy8gbG9vayBmb3IgYXJyYXlzXG4gIHJldHVybiBzZWFyY2gocGF0aC5zcGxpdCgnLicpLCBfdGhpcyk7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGlzQXJyYXlGaWx0ZXIocGllY2UpIHtcbiAgcmV0dXJuIHBpZWNlLnN0YXJ0c1dpdGgoJyRbJykgJiYgcGllY2UuZW5kc1dpdGgoJ10nKTtcbn1cblxuLyoqXG4gKiBDYWxsZWQgYnkgYGNvbXBpbGUoKWAgX3JpZ2h0IGJlZm9yZV8gY29tcGlsaW5nLiBHb29kIGZvciBtYWtpbmcgYW55IGNoYW5nZXMgdG9cbiAqIHRoZSBzY2hlbWEgdGhhdCBzaG91bGQgcmVzcGVjdCBvcHRpb25zIHNldCBieSBwbHVnaW5zLCBsaWtlIGBpZGBcbiAqIEBtZXRob2QgX3ByZUNvbXBpbGVcbiAqIEBtZW1iZXJPZiBTY2hlbWFcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hLnByb3RvdHlwZS5fcHJlQ29tcGlsZSA9IGZ1bmN0aW9uIF9wcmVDb21waWxlKCkge1xuICB0aGlzLnBsdWdpbihpZEdldHRlciwgeyBkZWR1cGxpY2F0ZTogdHJ1ZSB9KTtcbn07XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gU2NoZW1hO1xuXG4vLyByZXF1aXJlIGRvd24gaGVyZSBiZWNhdXNlIG9mIHJlZmVyZW5jZSBpc3N1ZXNcblxuLyoqXG4gKiBUaGUgdmFyaW91cyBidWlsdC1pbiBNb25nb29zZSBTY2hlbWEgVHlwZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBtb25nb29zZSA9IHJlcXVpcmUoJ21vbmdvb3NlJyk7XG4gKiAgICAgY29uc3QgT2JqZWN0SWQgPSBtb25nb29zZS5TY2hlbWEuVHlwZXMuT2JqZWN0SWQ7XG4gKlxuICogIyMjIyBUeXBlczpcbiAqXG4gKiAtIFtTdHJpbmddKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zY2hlbWF0eXBlcy5odG1sI3N0cmluZ3MpXG4gKiAtIFtOdW1iZXJdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zY2hlbWF0eXBlcy5odG1sI251bWJlcnMpXG4gKiAtIFtCb29sZWFuXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3Mvc2NoZW1hdHlwZXMuaHRtbCNib29sZWFucykgfCBCb29sXG4gKiAtIFtBcnJheV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWwjYXJyYXlzKVxuICogLSBbQnVmZmVyXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3Mvc2NoZW1hdHlwZXMuaHRtbCNidWZmZXJzKVxuICogLSBbRGF0ZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWwjZGF0ZXMpXG4gKiAtIFtPYmplY3RJZF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWwjb2JqZWN0aWRzKSB8IE9pZFxuICogLSBbTWl4ZWRdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9zY2hlbWF0eXBlcy5odG1sI21peGVkKVxuICogLSBbVVVJRF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWwjdXVpZClcbiAqIC0gW0JpZ0ludF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3NjaGVtYXR5cGVzLmh0bWwjYmlnaW50KVxuICpcbiAqIFVzaW5nIHRoaXMgZXhwb3NlZCBhY2Nlc3MgdG8gdGhlIGBNaXhlZGAgU2NoZW1hVHlwZSwgd2UgY2FuIHVzZSB0aGVtIGluIG91ciBzY2hlbWEuXG4gKlxuICogICAgIGNvbnN0IE1peGVkID0gbW9uZ29vc2UuU2NoZW1hLlR5cGVzLk1peGVkO1xuICogICAgIG5ldyBtb25nb29zZS5TY2hlbWEoeyBfdXNlcjogTWl4ZWQgfSlcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYS5UeXBlcyA9IE1vbmdvb3NlVHlwZXMgPSByZXF1aXJlKCcuL3NjaGVtYS9pbmRleCcpO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmV4cG9ydHMuT2JqZWN0SWQgPSBNb25nb29zZVR5cGVzLk9iamVjdElkO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/schema.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/schemaType.js":
/*!**********************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/schemaType.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseError = __webpack_require__(/*! ./error/index */ \"../backend/node_modules/mongoose/lib/error/index.js\");\nconst SchemaTypeOptions = __webpack_require__(/*! ./options/schemaTypeOptions */ \"../backend/node_modules/mongoose/lib/options/schemaTypeOptions.js\");\nconst $exists = __webpack_require__(/*! ./schema/operators/exists */ \"../backend/node_modules/mongoose/lib/schema/operators/exists.js\");\nconst $type = __webpack_require__(/*! ./schema/operators/type */ \"../backend/node_modules/mongoose/lib/schema/operators/type.js\");\nconst clone = __webpack_require__(/*! ./helpers/clone */ \"../backend/node_modules/mongoose/lib/helpers/clone.js\");\nconst handleImmutable = __webpack_require__(/*! ./helpers/schematype/handleImmutable */ \"../backend/node_modules/mongoose/lib/helpers/schematype/handleImmutable.js\");\nconst isAsyncFunction = __webpack_require__(/*! ./helpers/isAsyncFunction */ \"../backend/node_modules/mongoose/lib/helpers/isAsyncFunction.js\");\nconst isSimpleValidator = __webpack_require__(/*! ./helpers/isSimpleValidator */ \"../backend/node_modules/mongoose/lib/helpers/isSimpleValidator.js\");\nconst immediate = __webpack_require__(/*! ./helpers/immediate */ \"../backend/node_modules/mongoose/lib/helpers/immediate.js\");\nconst schemaTypeSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").schemaTypeSymbol);\nconst utils = __webpack_require__(/*! ./utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\nconst validatorErrorSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").validatorErrorSymbol);\nconst documentIsModified = (__webpack_require__(/*! ./helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").documentIsModified);\n\nconst populateModelSymbol = (__webpack_require__(/*! ./helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").populateModelSymbol);\n\nconst CastError = MongooseError.CastError;\nconst ValidatorError = MongooseError.ValidatorError;\n\nconst setOptionsForDefaults = { _skipMarkModified: true };\n\n/**\n * SchemaType constructor. Do **not** instantiate `SchemaType` directly.\n * Mongoose converts your schema paths into SchemaTypes automatically.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String });\n *     schema.path('name') instanceof SchemaType; // true\n *\n * @param {String} path\n * @param {SchemaTypeOptions} [options] See [SchemaTypeOptions docs](https://mongoosejs.com/docs/api/schematypeoptions.html)\n * @param {String} [instance]\n * @api public\n */\n\nfunction SchemaType(path, options, instance) {\n  this[schemaTypeSymbol] = true;\n  this.path = path;\n  this.instance = instance;\n  this.validators = [];\n  this.getters = this.constructor.hasOwnProperty('getters') ?\n    this.constructor.getters.slice() :\n    [];\n  this.setters = this.constructor.hasOwnProperty('setters') ?\n    this.constructor.setters.slice() :\n    [];\n\n  this.splitPath();\n\n  options = options || {};\n  const defaultOptions = this.constructor.defaultOptions || {};\n  const defaultOptionsKeys = Object.keys(defaultOptions);\n\n  for (const option of defaultOptionsKeys) {\n    if (option === 'validate') {\n      this.validate(defaultOptions.validate);\n    } else if (defaultOptions.hasOwnProperty(option) && !Object.prototype.hasOwnProperty.call(options, option)) {\n      options[option] = defaultOptions[option];\n    }\n  }\n\n  if (options.select == null) {\n    delete options.select;\n  }\n\n  const Options = this.OptionsConstructor || SchemaTypeOptions;\n  this.options = new Options(options);\n  this._index = null;\n\n\n  if (utils.hasUserDefinedProperty(this.options, 'immutable')) {\n    this.$immutable = this.options.immutable;\n\n    handleImmutable(this);\n  }\n\n  const keys = Object.keys(this.options);\n  for (const prop of keys) {\n    if (prop === 'cast') {\n      if (Array.isArray(this.options[prop])) {\n        this.castFunction.apply(this, this.options[prop]);\n      } else {\n        this.castFunction(this.options[prop]);\n      }\n      continue;\n    }\n    if (utils.hasUserDefinedProperty(this.options, prop) && typeof this[prop] === 'function') {\n      // { unique: true, index: true }\n      if (prop === 'index' && this._index) {\n        if (options.index === false) {\n          const index = this._index;\n          if (typeof index === 'object' && index != null) {\n            if (index.unique) {\n              throw new Error('Path \"' + this.path + '\" may not have `index` ' +\n                'set to false and `unique` set to true');\n            }\n            if (index.sparse) {\n              throw new Error('Path \"' + this.path + '\" may not have `index` ' +\n                'set to false and `sparse` set to true');\n            }\n          }\n\n          this._index = false;\n        }\n        continue;\n      }\n\n      const val = options[prop];\n      // Special case so we don't screw up array defaults, see gh-5780\n      if (prop === 'default') {\n        this.default(val);\n        continue;\n      }\n\n      const opts = Array.isArray(val) ? val : [val];\n\n      this[prop].apply(this, opts);\n    }\n  }\n\n  Object.defineProperty(this, '$$context', {\n    enumerable: false,\n    configurable: false,\n    writable: true,\n    value: null\n  });\n}\n\n/**\n * The class that Mongoose uses internally to instantiate this SchemaType's `options` property.\n * @memberOf SchemaType\n * @instance\n * @api private\n */\n\nSchemaType.prototype.OptionsConstructor = SchemaTypeOptions;\n\n/**\n * The path to this SchemaType in a Schema.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: String });\n *     schema.path('name').path; // 'name'\n *\n * @property path\n * @api public\n * @memberOf SchemaType\n */\n\nSchemaType.prototype.path;\n\n/**\n * The validators that Mongoose should run to validate properties at this SchemaType's path.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: { type: String, required: true } });\n *     schema.path('name').validators.length; // 1, the `required` validator\n *\n * @property validators\n * @api public\n * @memberOf SchemaType\n */\n\nSchemaType.prototype.validators;\n\n/**\n * True if this SchemaType has a required validator. False otherwise.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: { type: String, required: true } });\n *     schema.path('name').isRequired; // true\n *\n *     schema.path('name').required(false);\n *     schema.path('name').isRequired; // false\n *\n * @property isRequired\n * @api public\n * @memberOf SchemaType\n */\n\nSchemaType.prototype.isRequired;\n\n/**\n * Split the current dottet path into segments\n *\n * @return {String[]|undefined}\n * @api private\n */\n\nSchemaType.prototype.splitPath = function() {\n  if (this._presplitPath != null) {\n    return this._presplitPath;\n  }\n  if (this.path == null) {\n    return undefined;\n  }\n\n  this._presplitPath = this.path.indexOf('.') === -1 ? [this.path] : this.path.split('.');\n  return this._presplitPath;\n};\n\n/**\n * Get/set the function used to cast arbitrary values to this type.\n *\n * #### Example:\n *\n *     // Disallow `null` for numbers, and don't try to cast any values to\n *     // numbers, so even strings like '123' will cause a CastError.\n *     mongoose.Number.cast(function(v) {\n *       assert.ok(v === undefined || typeof v === 'number');\n *       return v;\n *     });\n *\n * @param {Function|false} caster Function that casts arbitrary values to this type, or throws an error if casting failed\n * @return {Function}\n * @static\n * @memberOf SchemaType\n * @function cast\n * @api public\n */\n\nSchemaType.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = v => v;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/**\n * Get/set the function used to cast arbitrary values to this particular schematype instance.\n * Overrides `SchemaType.cast()`.\n *\n * #### Example:\n *\n *     // Disallow `null` for numbers, and don't try to cast any values to\n *     // numbers, so even strings like '123' will cause a CastError.\n *     const number = new mongoose.Number('mypath', {});\n *     number.cast(function(v) {\n *       assert.ok(v === undefined || typeof v === 'number');\n *       return v;\n *     });\n *\n * @param {Function|false} caster Function that casts arbitrary values to this type, or throws an error if casting failed\n * @return {Function}\n * @memberOf SchemaType\n * @api public\n */\n\nSchemaType.prototype.castFunction = function castFunction(caster, message) {\n  if (arguments.length === 0) {\n    return this._castFunction;\n  }\n\n  if (caster === false) {\n    caster = this.constructor._defaultCaster || (v => v);\n  }\n  if (typeof caster === 'string') {\n    this._castErrorMessage = caster;\n    return this._castFunction;\n  }\n  if (caster != null) {\n    this._castFunction = caster;\n  }\n  if (message != null) {\n    this._castErrorMessage = message;\n  }\n\n  return this._castFunction;\n};\n\n/**\n * The function that Mongoose calls to cast arbitrary values to this SchemaType.\n *\n * @param {Object} value value to cast\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init\n * @api public\n */\n\nSchemaType.prototype.cast = function cast() {\n  throw new Error('Base SchemaType class does not implement a `cast()` function');\n};\n\n/**\n * Sets a default option for this schema type.\n *\n * #### Example:\n *\n *     // Make all strings be trimmed by default\n *     mongoose.SchemaTypes.String.set('trim', true);\n *\n * @param {String} option The name of the option you'd like to set (e.g. trim, lowercase, etc...)\n * @param {Any} value The value of the option you'd like to set.\n * @return {void}\n * @static\n * @memberOf SchemaType\n * @function set\n * @api public\n */\n\nSchemaType.set = function set(option, value) {\n  if (!this.hasOwnProperty('defaultOptions')) {\n    this.defaultOptions = Object.assign({}, this.defaultOptions);\n  }\n  this.defaultOptions[option] = value;\n};\n\n/**\n * Attaches a getter for all instances of this schema type.\n *\n * #### Example:\n *\n *     // Make all numbers round down\n *     mongoose.Number.get(function(v) { return Math.floor(v); });\n *\n * @param {Function} getter\n * @return {this}\n * @static\n * @memberOf SchemaType\n * @function get\n * @api public\n */\n\nSchemaType.get = function(getter) {\n  this.getters = this.hasOwnProperty('getters') ? this.getters : [];\n  this.getters.push(getter);\n};\n\n/**\n * Sets a default value for this SchemaType.\n *\n * #### Example:\n *\n *     const schema = new Schema({ n: { type: Number, default: 10 })\n *     const M = db.model('M', schema)\n *     const m = new M;\n *     console.log(m.n) // 10\n *\n * Defaults can be either `functions` which return the value to use as the default or the literal value itself. Either way, the value will be cast based on its schema type before being set during document creation.\n *\n * #### Example:\n *\n *     // values are cast:\n *     const schema = new Schema({ aNumber: { type: Number, default: 4.815162342 }})\n *     const M = db.model('M', schema)\n *     const m = new M;\n *     console.log(m.aNumber) // 4.815162342\n *\n *     // default unique objects for Mixed types:\n *     const schema = new Schema({ mixed: Schema.Types.Mixed });\n *     schema.path('mixed').default(function () {\n *       return {};\n *     });\n *\n *     // if we don't use a function to return object literals for Mixed defaults,\n *     // each document will receive a reference to the same object literal creating\n *     // a \"shared\" object instance:\n *     const schema = new Schema({ mixed: Schema.Types.Mixed });\n *     schema.path('mixed').default({});\n *     const M = db.model('M', schema);\n *     const m1 = new M;\n *     m1.mixed.added = 1;\n *     console.log(m1.mixed); // { added: 1 }\n *     const m2 = new M;\n *     console.log(m2.mixed); // { added: 1 }\n *\n * @param {Function|any} val The default value to set\n * @return {Any|undefined} Returns the set default value.\n * @api public\n */\n\nSchemaType.prototype.default = function(val) {\n  if (arguments.length === 1) {\n    if (val === void 0) {\n      this.defaultValue = void 0;\n      return void 0;\n    }\n\n    if (val != null && val.instanceOfSchema) {\n      throw new MongooseError('Cannot set default value of path `' + this.path +\n        '` to a mongoose Schema instance.');\n    }\n\n    this.defaultValue = val;\n    return this.defaultValue;\n  } else if (arguments.length > 1) {\n    this.defaultValue = [...arguments];\n  }\n  return this.defaultValue;\n};\n\n/**\n * Declares the index options for this schematype.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: { type: String, index: true })\n *     const s = new Schema({ name: { type: String, index: -1 })\n *     const s = new Schema({ loc: { type: [Number], index: 'hashed' })\n *     const s = new Schema({ loc: { type: [Number], index: '2d', sparse: true })\n *     const s = new Schema({ loc: { type: [Number], index: { type: '2dsphere', sparse: true }})\n *     const s = new Schema({ date: { type: Date, index: { unique: true, expires: '1d' }})\n *     s.path('my.path').index(true);\n *     s.path('my.date').index({ expires: 60 });\n *     s.path('my.path').index({ unique: true, sparse: true });\n *\n * #### Note:\n *\n * _Indexes are created [in the background](https://www.mongodb.com/docs/manual/core/index-creation/#index-creation-background)\n * by default. If `background` is set to `false`, MongoDB will not execute any\n * read/write operations you send until the index build.\n * Specify `background: false` to override Mongoose's default._\n *\n * @param {Object|Boolean|String|Number} options\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.index = function(options) {\n  this._index = options;\n  utils.expires(this._index);\n  return this;\n};\n\n/**\n * Declares an unique index.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: { type: String, unique: true } });\n *     s.path('name').index({ unique: true });\n *\n * _NOTE: violating the constraint returns an `E11000` error from MongoDB when saving, not a Mongoose validation error._\n *\n * @param {Boolean} bool\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.unique = function(bool) {\n  if (this._index === false) {\n    if (!bool) {\n      return;\n    }\n    throw new Error('Path \"' + this.path + '\" may not have `index` set to ' +\n      'false and `unique` set to true');\n  }\n\n  if (!this.options.hasOwnProperty('index') && bool === false) {\n    return this;\n  }\n\n  if (this._index == null || this._index === true) {\n    this._index = {};\n  } else if (typeof this._index === 'string') {\n    this._index = { type: this._index };\n  }\n\n  this._index.unique = bool;\n  return this;\n};\n\n/**\n * Declares a full text index.\n *\n * ### Example:\n *\n *      const s = new Schema({ name : { type: String, text : true } })\n *      s.path('name').index({ text : true });\n *\n * @param {Boolean} bool\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.text = function(bool) {\n  if (this._index === false) {\n    if (!bool) {\n      return this;\n    }\n    throw new Error('Path \"' + this.path + '\" may not have `index` set to ' +\n      'false and `text` set to true');\n  }\n\n  if (!this.options.hasOwnProperty('index') && bool === false) {\n    return this;\n  }\n\n  if (this._index === null || this._index === undefined ||\n    typeof this._index === 'boolean') {\n    this._index = {};\n  } else if (typeof this._index === 'string') {\n    this._index = { type: this._index };\n  }\n\n  this._index.text = bool;\n  return this;\n};\n\n/**\n * Declares a sparse index.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: { type: String, sparse: true } });\n *     s.path('name').index({ sparse: true });\n *\n * @param {Boolean} bool\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.sparse = function(bool) {\n  if (this._index === false) {\n    if (!bool) {\n      return this;\n    }\n    throw new Error('Path \"' + this.path + '\" may not have `index` set to ' +\n      'false and `sparse` set to true');\n  }\n\n  if (!this.options.hasOwnProperty('index') && bool === false) {\n    return this;\n  }\n\n  if (this._index == null || typeof this._index === 'boolean') {\n    this._index = {};\n  } else if (typeof this._index === 'string') {\n    this._index = { type: this._index };\n  }\n\n  this._index.sparse = bool;\n  return this;\n};\n\n/**\n * Defines this path as immutable. Mongoose prevents you from changing\n * immutable paths unless the parent document has [`isNew: true`](https://mongoosejs.com/docs/api/document.html#Document.prototype.isNew()).\n *\n * #### Example:\n *\n *     const schema = new Schema({\n *       name: { type: String, immutable: true },\n *       age: Number\n *     });\n *     const Model = mongoose.model('Test', schema);\n *\n *     await Model.create({ name: 'test' });\n *     const doc = await Model.findOne();\n *\n *     doc.isNew; // false\n *     doc.name = 'new name';\n *     doc.name; // 'test', because `name` is immutable\n *\n * Mongoose also prevents changing immutable properties using `updateOne()`\n * and `updateMany()` based on [strict mode](https://mongoosejs.com/docs/guide.html#strict).\n *\n * #### Example:\n *\n *     // Mongoose will strip out the `name` update, because `name` is immutable\n *     Model.updateOne({}, { $set: { name: 'test2' }, $inc: { age: 1 } });\n *\n *     // If `strict` is set to 'throw', Mongoose will throw an error if you\n *     // update `name`\n *     const err = await Model.updateOne({}, { name: 'test2' }, { strict: 'throw' }).\n *       then(() => null, err => err);\n *     err.name; // StrictModeError\n *\n *     // If `strict` is `false`, Mongoose allows updating `name` even though\n *     // the property is immutable.\n *     Model.updateOne({}, { name: 'test2' }, { strict: false });\n *\n * @param {Boolean} bool\n * @return {SchemaType} this\n * @see isNew https://mongoosejs.com/docs/api/document.html#Document.prototype.isNew()\n * @api public\n */\n\nSchemaType.prototype.immutable = function(bool) {\n  this.$immutable = bool;\n  handleImmutable(this);\n\n  return this;\n};\n\n/**\n * Defines a custom function for transforming this path when converting a document to JSON.\n *\n * Mongoose calls this function with one parameter: the current `value` of the path. Mongoose\n * then uses the return value in the JSON output.\n *\n * #### Example:\n *\n *     const schema = new Schema({\n *       date: { type: Date, transform: v => v.getFullYear() }\n *     });\n *     const Model = mongoose.model('Test', schema);\n *\n *     await Model.create({ date: new Date('2016-06-01') });\n *     const doc = await Model.findOne();\n *\n *     doc.date instanceof Date; // true\n *\n *     doc.toJSON().date; // 2016 as a number\n *     JSON.stringify(doc); // '{\"_id\":...,\"date\":2016}'\n *\n * @param {Function} fn\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.transform = function(fn) {\n  this.options.transform = fn;\n\n  return this;\n};\n\n/**\n * Adds a setter to this schematype.\n *\n * #### Example:\n *\n *     function capitalize (val) {\n *       if (typeof val !== 'string') val = '';\n *       return val.charAt(0).toUpperCase() + val.substring(1);\n *     }\n *\n *     // defining within the schema\n *     const s = new Schema({ name: { type: String, set: capitalize }});\n *\n *     // or with the SchemaType\n *     const s = new Schema({ name: String })\n *     s.path('name').set(capitalize);\n *\n * Setters allow you to transform the data before it gets to the raw mongodb\n * document or query.\n *\n * Suppose you are implementing user registration for a website. Users provide\n * an email and password, which gets saved to mongodb. The email is a string\n * that you will want to normalize to lower case, in order to avoid one email\n * having more than one account -- e.g., otherwise, avenue@q.com can be registered for 2 accounts via avenue@q.com and AvEnUe@Q.CoM.\n *\n * You can set up email lower case normalization easily via a Mongoose setter.\n *\n *     function toLower(v) {\n *       return v.toLowerCase();\n *     }\n *\n *     const UserSchema = new Schema({\n *       email: { type: String, set: toLower }\n *     });\n *\n *     const User = db.model('User', UserSchema);\n *\n *     const user = new User({email: 'AVENUE@Q.COM'});\n *     console.log(user.email); // 'avenue@q.com'\n *\n *     // or\n *     const user = new User();\n *     user.email = 'Avenue@Q.com';\n *     console.log(user.email); // 'avenue@q.com'\n *     User.updateOne({ _id: _id }, { $set: { email: 'AVENUE@Q.COM' } }); // update to 'avenue@q.com'\n *\n * As you can see above, setters allow you to transform the data before it\n * stored in MongoDB, or before executing a query.\n *\n * _NOTE: we could have also just used the built-in `lowercase: true` SchemaType option instead of defining our own function._\n *\n *     new Schema({ email: { type: String, lowercase: true }})\n *\n * Setters are also passed a second argument, the schematype on which the setter was defined. This allows for tailored behavior based on options passed in the schema.\n *\n *     function inspector (val, priorValue, schematype) {\n *       if (schematype.options.required) {\n *         return schematype.path + ' is required';\n *       } else {\n *         return val;\n *       }\n *     }\n *\n *     const VirusSchema = new Schema({\n *       name: { type: String, required: true, set: inspector },\n *       taxonomy: { type: String, set: inspector }\n *     })\n *\n *     const Virus = db.model('Virus', VirusSchema);\n *     const v = new Virus({ name: 'Parvoviridae', taxonomy: 'Parvovirinae' });\n *\n *     console.log(v.name);     // name is required\n *     console.log(v.taxonomy); // Parvovirinae\n *\n * You can also use setters to modify other properties on the document. If\n * you're setting a property `name` on a document, the setter will run with\n * `this` as the document. Be careful, in mongoose 5 setters will also run\n * when querying by `name` with `this` as the query.\n *\n *     const nameSchema = new Schema({ name: String, keywords: [String] });\n *     nameSchema.path('name').set(function(v) {\n *       // Need to check if `this` is a document, because in mongoose 5\n *       // setters will also run on queries, in which case `this` will be a\n *       // mongoose query object.\n *       if (this instanceof Document && v != null) {\n *         this.keywords = v.split(' ');\n *       }\n *       return v;\n *     });\n *\n * @param {Function} fn\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.set = function(fn) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('A setter must be a function.');\n  }\n  this.setters.push(fn);\n  return this;\n};\n\n/**\n * Adds a getter to this schematype.\n *\n * #### Example:\n *\n *     function dob (val) {\n *       if (!val) return val;\n *       return (val.getMonth() + 1) + \"/\" + val.getDate() + \"/\" + val.getFullYear();\n *     }\n *\n *     // defining within the schema\n *     const s = new Schema({ born: { type: Date, get: dob })\n *\n *     // or by retreiving its SchemaType\n *     const s = new Schema({ born: Date })\n *     s.path('born').get(dob)\n *\n * Getters allow you to transform the representation of the data as it travels from the raw mongodb document to the value that you see.\n *\n * Suppose you are storing credit card numbers and you want to hide everything except the last 4 digits to the mongoose user. You can do so by defining a getter in the following way:\n *\n *     function obfuscate (cc) {\n *       return '****-****-****-' + cc.slice(cc.length-4, cc.length);\n *     }\n *\n *     const AccountSchema = new Schema({\n *       creditCardNumber: { type: String, get: obfuscate }\n *     });\n *\n *     const Account = db.model('Account', AccountSchema);\n *\n *     Account.findById(id, function (err, found) {\n *       console.log(found.creditCardNumber); // '****-****-****-1234'\n *     });\n *\n * Getters are also passed a second argument, the schematype on which the getter was defined. This allows for tailored behavior based on options passed in the schema.\n *\n *     function inspector (val, priorValue, schematype) {\n *       if (schematype.options.required) {\n *         return schematype.path + ' is required';\n *       } else {\n *         return schematype.path + ' is not';\n *       }\n *     }\n *\n *     const VirusSchema = new Schema({\n *       name: { type: String, required: true, get: inspector },\n *       taxonomy: { type: String, get: inspector }\n *     })\n *\n *     const Virus = db.model('Virus', VirusSchema);\n *\n *     Virus.findById(id, function (err, virus) {\n *       console.log(virus.name);     // name is required\n *       console.log(virus.taxonomy); // taxonomy is not\n *     })\n *\n * @param {Function} fn\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.get = function(fn) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('A getter must be a function.');\n  }\n  this.getters.push(fn);\n  return this;\n};\n\n/**\n * Adds multiple validators for this document path.\n * Calls `validate()` for every element in validators.\n *\n * @param {Array<RegExp|Function|Object>} validators\n * @returns this\n */\n\nSchemaType.prototype.validateAll = function(validators) {\n  for (let i = 0; i < validators.length; i++) {\n    this.validate(validators[i]);\n  }\n  return this;\n};\n\n/**\n * Adds validator(s) for this document path.\n *\n * Validators always receive the value to validate as their first argument and\n * must return `Boolean`. Returning `false` or throwing an error means\n * validation failed.\n *\n * The error message argument is optional. If not passed, the [default generic error message template](https://mongoosejs.com/docs/api/error.html#Error.messages) will be used.\n *\n * #### Example:\n *\n *     // make sure every value is equal to \"something\"\n *     function validator (val) {\n *       return val === 'something';\n *     }\n *     new Schema({ name: { type: String, validate: validator }});\n *\n *     // with a custom error message\n *\n *     const custom = [validator, 'Uh oh, {PATH} does not equal \"something\".']\n *     new Schema({ name: { type: String, validate: custom }});\n *\n *     // adding many validators at a time\n *\n *     const many = [\n *         { validator: validator, message: 'uh oh' }\n *       , { validator: anotherValidator, message: 'failed' }\n *     ]\n *     new Schema({ name: { type: String, validate: many }});\n *\n *     // or utilizing SchemaType methods directly:\n *\n *     const schema = new Schema({ name: 'string' });\n *     schema.path('name').validate(validator, 'validation of `{PATH}` failed with value `{VALUE}`');\n *\n * #### Error message templates:\n *\n * Below is a list of supported template keywords:\n *\n * - PATH: The schema path where the error is being triggered.\n * - VALUE: The value assigned to the PATH that is triggering the error.\n * - KIND: The validation property that triggered the error i.e. required.\n * - REASON: The error object that caused this error if there was one.\n *\n * If Mongoose's built-in error message templating isn't enough, Mongoose\n * supports setting the `message` property to a function.\n *\n *     schema.path('name').validate({\n *       validator: function(v) { return v.length > 5; },\n *       // `errors['name']` will be \"name must have length 5, got 'foo'\"\n *       message: function(props) {\n *         return `${props.path} must have length 5, got '${props.value}'`;\n *       }\n *     });\n *\n * To bypass Mongoose's error messages and just copy the error message that\n * the validator throws, do this:\n *\n *     schema.path('name').validate({\n *       validator: function() { throw new Error('Oops!'); },\n *       // `errors['name'].message` will be \"Oops!\"\n *       message: function(props) { return props.reason.message; }\n *     });\n *\n * #### Asynchronous validation:\n *\n * Mongoose supports validators that return a promise. A validator that returns\n * a promise is called an _async validator_. Async validators run in\n * parallel, and `validate()` will wait until all async validators have settled.\n *\n *     schema.path('name').validate({\n *       validator: function (value) {\n *         return new Promise(function (resolve, reject) {\n *           resolve(false); // validation failed\n *         });\n *       }\n *     });\n *\n * You might use asynchronous validators to retreive other documents from the database to validate against or to meet other I/O bound validation needs.\n *\n * Validation occurs `pre('save')` or whenever you manually execute [document#validate](https://mongoosejs.com/docs/api/document.html#Document.prototype.validate()).\n *\n * If validation fails during `pre('save')` and no callback was passed to receive the error, an `error` event will be emitted on your Models associated db [connection](https://mongoosejs.com/docs/api/connection.html#Connection()), passing the validation error object along.\n *\n *     const conn = mongoose.createConnection(..);\n *     conn.on('error', handleError);\n *\n *     const Product = conn.model('Product', yourSchema);\n *     const dvd = new Product(..);\n *     dvd.save(); // emits error on the `conn` above\n *\n * If you want to handle these errors at the Model level, add an `error`\n * listener to your Model as shown below.\n *\n *     // registering an error listener on the Model lets us handle errors more locally\n *     Product.on('error', handleError);\n *\n * @param {RegExp|Function|Object} obj validator function, or hash describing options\n * @param {Function} [obj.validator] validator function. If the validator function returns `undefined` or a truthy value, validation succeeds. If it returns [falsy](https://masteringjs.io/tutorials/fundamentals/falsy) (except `undefined`) or throws an error, validation fails.\n * @param {String|Function} [obj.message] optional error message. If function, should return the error message as a string\n * @param {Boolean} [obj.propsParameter=false] If true, Mongoose will pass the validator properties object (with the `validator` function, `message`, etc.) as the 2nd arg to the validator function. This is disabled by default because many validators [rely on positional args](https://github.com/chriso/validator.js#validators), so turning this on may cause unpredictable behavior in external validators.\n * @param {String|Function} [errorMsg] optional error message. If function, should return the error message as a string\n * @param {String} [type] optional validator type\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.validate = function(obj, message, type) {\n  if (typeof obj === 'function' || obj && utils.getFunctionName(obj.constructor) === 'RegExp') {\n    let properties;\n    if (typeof message === 'function') {\n      properties = { validator: obj, message: message };\n      properties.type = type || 'user defined';\n    } else if (message instanceof Object && !type) {\n      properties = isSimpleValidator(message) ? Object.assign({}, message) : clone(message);\n      if (!properties.message) {\n        properties.message = properties.msg;\n      }\n      properties.validator = obj;\n      properties.type = properties.type || 'user defined';\n    } else {\n      if (message == null) {\n        message = MongooseError.messages.general.default;\n      }\n      if (!type) {\n        type = 'user defined';\n      }\n      properties = { message: message, type: type, validator: obj };\n    }\n\n    this.validators.push(properties);\n    return this;\n  }\n\n  let i;\n  let length;\n  let arg;\n\n  for (i = 0, length = arguments.length; i < length; i++) {\n    arg = arguments[i];\n    if (!utils.isPOJO(arg)) {\n      const msg = 'Invalid validator. Received (' + typeof arg + ') '\n        + arg\n        + '. See https://mongoosejs.com/docs/api/schematype.html#SchemaType.prototype.validate()';\n\n      throw new Error(msg);\n    }\n    this.validate(arg.validator, arg);\n  }\n\n  return this;\n};\n\n/**\n * Adds a required validator to this SchemaType. The validator gets added\n * to the front of this SchemaType's validators array using `unshift()`.\n *\n * #### Example:\n *\n *     const s = new Schema({ born: { type: Date, required: true })\n *\n *     // or with custom error message\n *\n *     const s = new Schema({ born: { type: Date, required: '{PATH} is required!' })\n *\n *     // or with a function\n *\n *     const s = new Schema({\n *       userId: ObjectId,\n *       username: {\n *         type: String,\n *         required: function() { return this.userId != null; }\n *       }\n *     })\n *\n *     // or with a function and a custom message\n *     const s = new Schema({\n *       userId: ObjectId,\n *       username: {\n *         type: String,\n *         required: [\n *           function() { return this.userId != null; },\n *           'username is required if id is specified'\n *         ]\n *       }\n *     })\n *\n *     // or through the path API\n *\n *     s.path('name').required(true);\n *\n *     // with custom error messaging\n *\n *     s.path('name').required(true, 'grrr :( ');\n *\n *     // or make a path conditionally required based on a function\n *     const isOver18 = function() { return this.age >= 18; };\n *     s.path('voterRegistrationId').required(isOver18);\n *\n * The required validator uses the SchemaType's `checkRequired` function to\n * determine whether a given value satisfies the required validator. By default,\n * a value satisfies the required validator if `val != null` (that is, if\n * the value is not null nor undefined). However, most built-in mongoose schema\n * types override the default `checkRequired` function:\n *\n * @param {Boolean|Function|Object} required enable/disable the validator, or function that returns required boolean, or options object\n * @param {Boolean|Function} [options.isRequired] enable/disable the validator, or function that returns required boolean\n * @param {Function} [options.ErrorConstructor] custom error constructor. The constructor receives 1 parameter, an object containing the validator properties.\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @see SchemaArray#checkRequired https://mongoosejs.com/docs/api/schemaarray.html#SchemaArray.prototype.checkRequired()\n * @see SchemaBoolean#checkRequired https://mongoosejs.com/docs/api/schemaboolean.html#SchemaBoolean.prototype.checkRequired()\n * @see SchemaBuffer#checkRequired https://mongoosejs.com/docs/api/schemabuffer.html#SchemaBuffer.prototype.checkRequired()\n * @see SchemaNumber#checkRequired https://mongoosejs.com/docs/api/schemanumber.html#SchemaNumber.prototype.checkRequired()\n * @see SchemaObjectId#checkRequired https://mongoosejs.com/docs/api/schemaobjectid.html#ObjectId.prototype.checkRequired()\n * @see SchemaString#checkRequired https://mongoosejs.com/docs/api/schemastring.html#SchemaString.prototype.checkRequired()\n * @api public\n */\n\nSchemaType.prototype.required = function(required, message) {\n  let customOptions = {};\n\n  if (arguments.length > 0 && required == null) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.requiredValidator;\n    }, this);\n\n    this.isRequired = false;\n    delete this.originalRequiredValue;\n    return this;\n  }\n\n  if (typeof required === 'object') {\n    customOptions = required;\n    message = customOptions.message || message;\n    required = required.isRequired;\n  }\n\n  if (required === false) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.requiredValidator;\n    }, this);\n\n    this.isRequired = false;\n    delete this.originalRequiredValue;\n    return this;\n  }\n\n  const _this = this;\n  this.isRequired = true;\n\n  this.requiredValidator = function(v) {\n    const cachedRequired = this && this.$__ && this.$__.cachedRequired;\n\n    // no validation when this path wasn't selected in the query.\n    if (cachedRequired != null && !this.$__isSelected(_this.path) && !this[documentIsModified](_this.path)) {\n      return true;\n    }\n\n    // `$cachedRequired` gets set in `_evaluateRequiredFunctions()` so we\n    // don't call required functions multiple times in one validate call\n    // See gh-6801\n    if (cachedRequired != null && _this.path in cachedRequired) {\n      const res = cachedRequired[_this.path] ?\n        _this.checkRequired(v, this) :\n        true;\n      delete cachedRequired[_this.path];\n      return res;\n    } else if (typeof required === 'function') {\n      return required.apply(this) ? _this.checkRequired(v, this) : true;\n    }\n\n    return _this.checkRequired(v, this);\n  };\n  this.originalRequiredValue = required;\n\n  if (typeof required === 'string') {\n    message = required;\n    required = undefined;\n  }\n\n  const msg = message || MongooseError.messages.general.required;\n  this.validators.unshift(Object.assign({}, customOptions, {\n    validator: this.requiredValidator,\n    message: msg,\n    type: 'required'\n  }));\n\n  return this;\n};\n\n/**\n * Set the model that this path refers to. This is the option that [populate](https://mongoosejs.com/docs/populate.html)\n * looks at to determine the foreign collection it should query.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({ name: String });\n *     const User = mongoose.model('User', userSchema);\n *\n *     const postSchema = new Schema({ user: mongoose.ObjectId });\n *     postSchema.path('user').ref('User'); // Can set ref to a model name\n *     postSchema.path('user').ref(User); // Or a model class\n *     postSchema.path('user').ref(() => 'User'); // Or a function that returns the model name\n *     postSchema.path('user').ref(() => User); // Or a function that returns the model class\n *\n *     // Or you can just declare the `ref` inline in your schema\n *     const postSchema2 = new Schema({\n *       user: { type: mongoose.ObjectId, ref: User }\n *     });\n *\n * @param {String|Model|Function} ref either a model name, a [Model](https://mongoosejs.com/docs/models.html), or a function that returns a model name or model.\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.ref = function(ref) {\n  this.options.ref = ref;\n  return this;\n};\n\n/**\n * Gets the default value\n *\n * @param {Object} scope the scope which callback are executed\n * @param {Boolean} init\n * @return {Any} The Stored default value.\n * @api private\n */\n\nSchemaType.prototype.getDefault = function(scope, init, options) {\n  let ret;\n  if (typeof this.defaultValue === 'function') {\n    if (\n      this.defaultValue === Date.now ||\n      this.defaultValue === Array ||\n      this.defaultValue.name.toLowerCase() === 'objectid'\n    ) {\n      ret = this.defaultValue.call(scope);\n    } else {\n      ret = this.defaultValue.call(scope, scope);\n    }\n  } else {\n    ret = this.defaultValue;\n  }\n\n  if (ret !== null && ret !== undefined) {\n    if (typeof ret === 'object' && (!this.options || !this.options.shared)) {\n      ret = clone(ret);\n    }\n\n    if (options && options.skipCast) {\n      return this._applySetters(ret, scope);\n    }\n\n    const casted = this.applySetters(ret, scope, init, undefined, setOptionsForDefaults);\n    if (casted && !Array.isArray(casted) && casted.$isSingleNested) {\n      casted.$__parent = scope;\n    }\n    return casted;\n  }\n  return ret;\n};\n\n/**\n * Applies setters without casting\n *\n * @param {Any} value\n * @param {Any} scope\n * @param {Boolean} init\n * @param {Any} priorVal\n * @param {Object} [options]\n * @instance\n * @api private\n */\n\nSchemaType.prototype._applySetters = function(value, scope, init, priorVal, options) {\n  let v = value;\n  if (init) {\n    return v;\n  }\n  const setters = this.setters;\n\n  for (let i = setters.length - 1; i >= 0; i--) {\n    v = setters[i].call(scope, v, priorVal, this, options);\n  }\n\n  return v;\n};\n\n/*!\n * ignore\n */\n\nSchemaType.prototype._castNullish = function _castNullish(v) {\n  return v;\n};\n\n/**\n * Applies setters\n *\n * @param {Object} value\n * @param {Object} scope\n * @param {Boolean} init\n * @return {Any}\n * @api private\n */\n\nSchemaType.prototype.applySetters = function(value, scope, init, priorVal, options) {\n  let v = this._applySetters(value, scope, init, priorVal, options);\n  if (v == null) {\n    return this._castNullish(v);\n  }\n  // do not cast until all setters are applied #665\n  v = this.cast(v, scope, init, priorVal, options);\n\n  return v;\n};\n\n/**\n * Applies getters to a value\n *\n * @param {Object} value\n * @param {Object} scope\n * @return {Any}\n * @api private\n */\n\nSchemaType.prototype.applyGetters = function(value, scope) {\n  let v = value;\n  const getters = this.getters;\n  const len = getters.length;\n\n  if (len === 0) {\n    return v;\n  }\n\n  for (let i = 0; i < len; ++i) {\n    v = getters[i].call(scope, v, this);\n  }\n\n  return v;\n};\n\n/**\n * Sets default `select()` behavior for this path.\n *\n * Set to `true` if this path should always be included in the results, `false` if it should be excluded by default. This setting can be overridden at the query level.\n *\n * #### Example:\n *\n *     T = db.model('T', new Schema({ x: { type: String, select: true }}));\n *     T.find(..); // field x will always be selected ..\n *     // .. unless overridden;\n *     T.find().select('-x').exec(callback);\n *\n * @param {Boolean} val\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.select = function select(val) {\n  this.selected = !!val;\n  return this;\n};\n\n/**\n * Performs a validation of `value` using the validators declared for this SchemaType.\n *\n * @param {Any} value\n * @param {Function} callback\n * @param {Object} scope\n * @param {Object} [options]\n * @param {String} [options.path]\n * @return {Any} If no validators, returns the output from calling `fn`, otherwise no return\n * @api public\n */\n\nSchemaType.prototype.doValidate = function(value, fn, scope, options) {\n  let err = false;\n  const path = this.path;\n  if (typeof fn !== 'function') {\n    throw new TypeError(`Must pass callback function to doValidate(), got ${typeof fn}`);\n  }\n\n  // Avoid non-object `validators`\n  const validators = this.validators.\n    filter(v => typeof v === 'object' && v !== null);\n\n  let count = validators.length;\n\n  if (!count) {\n    return fn(null);\n  }\n\n  for (let i = 0, len = validators.length; i < len; ++i) {\n    if (err) {\n      break;\n    }\n\n    const v = validators[i];\n    const validator = v.validator;\n    let ok;\n\n    const validatorProperties = isSimpleValidator(v) ? Object.assign({}, v) : clone(v);\n    validatorProperties.path = options && options.path ? options.path : path;\n    validatorProperties.fullPath = this.$fullPath;\n    validatorProperties.value = value;\n\n    if (validator instanceof RegExp) {\n      validate(validator.test(value), validatorProperties, scope);\n      continue;\n    }\n\n    if (typeof validator !== 'function') {\n      continue;\n    }\n\n    if (value === undefined && validator !== this.requiredValidator) {\n      validate(true, validatorProperties, scope);\n      continue;\n    }\n\n    try {\n      if (validatorProperties.propsParameter) {\n        ok = validator.call(scope, value, validatorProperties);\n      } else {\n        ok = validator.call(scope, value);\n      }\n    } catch (error) {\n      ok = false;\n      validatorProperties.reason = error;\n      if (error.message) {\n        validatorProperties.message = error.message;\n      }\n    }\n\n    if (ok != null && typeof ok.then === 'function') {\n      ok.then(\n        function(ok) { validate(ok, validatorProperties, scope); },\n        function(error) {\n          validatorProperties.reason = error;\n          validatorProperties.message = error.message;\n          ok = false;\n          validate(ok, validatorProperties, scope);\n        });\n    } else {\n      validate(ok, validatorProperties, scope);\n    }\n  }\n\n  function validate(ok, validatorProperties, scope) {\n    if (err) {\n      return;\n    }\n    if (ok === undefined || ok) {\n      if (--count <= 0) {\n        immediate(function() {\n          fn(null);\n        });\n      }\n    } else {\n      const ErrorConstructor = validatorProperties.ErrorConstructor || ValidatorError;\n      err = new ErrorConstructor(validatorProperties, scope);\n      err[validatorErrorSymbol] = true;\n      immediate(function() {\n        fn(err);\n      });\n    }\n  }\n};\n\n\nfunction _validate(ok, validatorProperties) {\n  if (ok !== undefined && !ok) {\n    const ErrorConstructor = validatorProperties.ErrorConstructor || ValidatorError;\n    const err = new ErrorConstructor(validatorProperties);\n    err[validatorErrorSymbol] = true;\n    return err;\n  }\n}\n\n/**\n * Performs a validation of `value` using the validators declared for this SchemaType.\n *\n * #### Note:\n *\n * This method ignores the asynchronous validators.\n *\n * @param {Any} value\n * @param {Object} scope\n * @param {Object} [options]\n * @param {Object} [options.path]\n * @return {MongooseError|null}\n * @api private\n */\n\nSchemaType.prototype.doValidateSync = function(value, scope, options) {\n  const path = this.path;\n  const count = this.validators.length;\n\n  if (!count) {\n    return null;\n  }\n\n  let validators = this.validators;\n  if (value === void 0) {\n    if (this.validators.length !== 0 && this.validators[0].type === 'required') {\n      validators = [this.validators[0]];\n    } else {\n      return null;\n    }\n  }\n\n  let err = null;\n  let i = 0;\n  const len = validators.length;\n  for (i = 0; i < len; ++i) {\n    const v = validators[i];\n\n    if (v === null || typeof v !== 'object') {\n      continue;\n    }\n\n    const validator = v.validator;\n    const validatorProperties = isSimpleValidator(v) ? Object.assign({}, v) : clone(v);\n    validatorProperties.path = options && options.path ? options.path : path;\n    validatorProperties.fullPath = this.$fullPath;\n    validatorProperties.value = value;\n    let ok = false;\n\n    // Skip any explicit async validators. Validators that return a promise\n    // will still run, but won't trigger any errors.\n    if (isAsyncFunction(validator)) {\n      continue;\n    }\n\n    if (validator instanceof RegExp) {\n      err = _validate(validator.test(value), validatorProperties);\n      continue;\n    }\n\n    if (typeof validator !== 'function') {\n      continue;\n    }\n\n    try {\n      if (validatorProperties.propsParameter) {\n        ok = validator.call(scope, value, validatorProperties);\n      } else {\n        ok = validator.call(scope, value);\n      }\n    } catch (error) {\n      ok = false;\n      validatorProperties.reason = error;\n    }\n\n    // Skip any validators that return a promise, we can't handle those\n    // synchronously\n    if (ok != null && typeof ok.then === 'function') {\n      continue;\n    }\n    err = _validate(ok, validatorProperties);\n    if (err) {\n      break;\n    }\n  }\n\n  return err;\n};\n\n/**\n * Determines if value is a valid Reference.\n *\n * @param {SchemaType} self\n * @param {Object} value\n * @param {Document} doc\n * @param {Boolean} init\n * @return {Boolean}\n * @api private\n */\n\nSchemaType._isRef = function(self, value, doc, init) {\n  // fast path\n  let ref = init && self.options && (self.options.ref || self.options.refPath);\n\n  if (!ref && doc && doc.$__ != null) {\n    // checks for\n    // - this populated with adhoc model and no ref was set in schema OR\n    // - setting / pushing values after population\n    const path = doc.$__fullPath(self.path, true);\n\n    const owner = doc.ownerDocument();\n    ref = (path != null && owner.$populated(path)) || doc.$populated(self.path);\n  }\n\n  if (ref) {\n    if (value == null) {\n      return true;\n    }\n    if (!Buffer.isBuffer(value) && // buffers are objects too\n      value._bsontype !== 'Binary' // raw binary value from the db\n      && utils.isObject(value) // might have deselected _id in population query\n    ) {\n      return true;\n    }\n\n    return init;\n  }\n\n  return false;\n};\n\n/*!\n * ignore\n */\n\nSchemaType.prototype._castRef = function _castRef(value, doc, init) {\n  if (value == null) {\n    return value;\n  }\n\n  if (value.$__ != null) {\n    value.$__.wasPopulated = value.$__.wasPopulated || { value: value._id };\n    return value;\n  }\n\n  // setting a populated path\n  if (Buffer.isBuffer(value) || !utils.isObject(value)) {\n    if (init) {\n      return value;\n    }\n    throw new CastError(this.instance, value, this.path, null, this);\n  }\n\n  // Handle the case where user directly sets a populated\n  // path to a plain object; cast to the Model used in\n  // the population query.\n  const path = doc.$__fullPath(this.path, true);\n  const owner = doc.ownerDocument();\n  const pop = owner.$populated(path, true);\n\n  let ret = value;\n  if (!doc.$__.populated ||\n    !doc.$__.populated[path] ||\n    !doc.$__.populated[path].options ||\n    !doc.$__.populated[path].options.options ||\n    !doc.$__.populated[path].options.options.lean) {\n    ret = new pop.options[populateModelSymbol](value);\n    ret.$__.wasPopulated = { value: ret._id };\n  }\n\n  return ret;\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val, context) {\n  return this.castForQuery(null, val, context);\n}\n\n/*!\n * ignore\n */\n\nfunction handleArray(val, context) {\n  const _this = this;\n  if (!Array.isArray(val)) {\n    return [this.castForQuery(null, val, context)];\n  }\n  return val.map(function(m) {\n    return _this.castForQuery(null, m, context);\n  });\n}\n\n/**\n * Just like handleArray, except also allows `[]` because surprisingly\n * `$in: [1, []]` works fine\n * @api private\n */\n\nfunction handle$in(val, context) {\n  const _this = this;\n  if (!Array.isArray(val)) {\n    return [this.castForQuery(null, val, context)];\n  }\n  return val.map(function(m) {\n    if (Array.isArray(m) && m.length === 0) {\n      return m;\n    }\n    return _this.castForQuery(null, m, context);\n  });\n}\n\n/*!\n * ignore\n */\n\nSchemaType.prototype.$conditionalHandlers = {\n  $all: handleArray,\n  $eq: handleSingle,\n  $in: handle$in,\n  $ne: handleSingle,\n  $nin: handle$in,\n  $exists: $exists,\n  $type: $type\n};\n\n/**\n * Cast the given value with the given optional query operator.\n *\n * @param {String} [$conditional] query operator, like `$eq` or `$in`\n * @param {Any} val\n * @param {Query} context\n * @return {Any}\n * @api private\n */\n\nSchemaType.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional);\n    }\n    return handler.call(this, val, context);\n  }\n\n  try {\n    return this.applySetters(val, context);\n  } catch (err) {\n    if (err instanceof CastError && err.path === this.path && this.$fullPath != null) {\n      err.path = this.$fullPath;\n    }\n    throw err;\n  }\n};\n\n/**\n * Set & Get the `checkRequired` function\n * Override the function the required validator uses to check whether a value\n * passes the `required` check. Override this on the individual SchemaType.\n *\n * #### Example:\n *\n *     // Use this to allow empty strings to pass the `required` validator\n *     mongoose.Schema.Types.String.checkRequired(v => typeof v === 'string');\n *\n * @param {Function} [fn] If set, will overwrite the current set function\n * @return {Function} The input `fn` or the already set function\n * @static\n * @memberOf SchemaType\n * @function checkRequired\n * @api public\n */\n\nSchemaType.checkRequired = function(fn) {\n  if (arguments.length !== 0) {\n    this._checkRequired = fn;\n  }\n\n  return this._checkRequired;\n};\n\n/**\n * Default check for if this path satisfies the `required` validator.\n *\n * @param {Any} val\n * @return {Boolean} `true` when the value is not `null`, `false` otherwise\n * @api private\n */\n\nSchemaType.prototype.checkRequired = function(val) {\n  return val != null;\n};\n\n/**\n * Clone the current SchemaType\n *\n * @return {SchemaType} The cloned SchemaType instance\n * @api private\n */\n\nSchemaType.prototype.clone = function() {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, options, this.instance);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) schematype.requiredValidator = this.requiredValidator;\n  if (this.defaultValue !== undefined) schematype.defaultValue = this.defaultValue;\n  if (this.$immutable !== undefined && this.options.immutable === undefined) {\n    schematype.$immutable = this.$immutable;\n\n    handleImmutable(schematype);\n  }\n  if (this._index !== undefined) schematype._index = this._index;\n  if (this.selected !== undefined) schematype.selected = this.selected;\n  if (this.isRequired !== undefined) schematype.isRequired = this.isRequired;\n  if (this.originalRequiredValue !== undefined) schematype.originalRequiredValue = this.originalRequiredValue;\n  schematype.getters = this.getters.slice();\n  schematype.setters = this.setters.slice();\n  return schematype;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = SchemaType;\n\nexports.CastError = CastError;\n\nexports.ValidatorError = ValidatorError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYVR5cGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixtQkFBTyxDQUFDLDBFQUFlO0FBQzdDLDBCQUEwQixtQkFBTyxDQUFDLHNHQUE2QjtBQUMvRCxnQkFBZ0IsbUJBQU8sQ0FBQyxrR0FBMkI7QUFDbkQsY0FBYyxtQkFBTyxDQUFDLDhGQUF5QjtBQUMvQyxjQUFjLG1CQUFPLENBQUMsOEVBQWlCO0FBQ3ZDLHdCQUF3QixtQkFBTyxDQUFDLHdIQUFzQztBQUN0RSx3QkFBd0IsbUJBQU8sQ0FBQyxrR0FBMkI7QUFDM0QsMEJBQTBCLG1CQUFPLENBQUMsc0dBQTZCO0FBQy9ELGtCQUFrQixtQkFBTyxDQUFDLHNGQUFxQjtBQUMvQyx5QkFBeUIsMEhBQTZDO0FBQ3RFLGNBQWMsbUJBQU8sQ0FBQyw4REFBUztBQUMvQiw2QkFBNkIsOEhBQWlEO0FBQzlFLDJCQUEyQiw0SEFBK0M7O0FBRTFFLDRCQUE0Qiw2SEFBZ0Q7O0FBRTVFO0FBQ0E7O0FBRUEsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsY0FBYztBQUNqRCxrREFBa0Q7QUFDbEQ7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLDJDQUEyQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsU0FBUztBQUNwQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixZQUFZLFNBQVM7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpQkFBaUI7O0FBRWpCLHNCQUFzQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9zY2hlbWFUeXBlLmpzP2Q1OWQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3IvaW5kZXgnKTtcbmNvbnN0IFNjaGVtYVR5cGVPcHRpb25zID0gcmVxdWlyZSgnLi9vcHRpb25zL3NjaGVtYVR5cGVPcHRpb25zJyk7XG5jb25zdCAkZXhpc3RzID0gcmVxdWlyZSgnLi9zY2hlbWEvb3BlcmF0b3JzL2V4aXN0cycpO1xuY29uc3QgJHR5cGUgPSByZXF1aXJlKCcuL3NjaGVtYS9vcGVyYXRvcnMvdHlwZScpO1xuY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuL2hlbHBlcnMvY2xvbmUnKTtcbmNvbnN0IGhhbmRsZUltbXV0YWJsZSA9IHJlcXVpcmUoJy4vaGVscGVycy9zY2hlbWF0eXBlL2hhbmRsZUltbXV0YWJsZScpO1xuY29uc3QgaXNBc3luY0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9oZWxwZXJzL2lzQXN5bmNGdW5jdGlvbicpO1xuY29uc3QgaXNTaW1wbGVWYWxpZGF0b3IgPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNTaW1wbGVWYWxpZGF0b3InKTtcbmNvbnN0IGltbWVkaWF0ZSA9IHJlcXVpcmUoJy4vaGVscGVycy9pbW1lZGlhdGUnKTtcbmNvbnN0IHNjaGVtYVR5cGVTeW1ib2wgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ltYm9scycpLnNjaGVtYVR5cGVTeW1ib2w7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbmNvbnN0IHZhbGlkYXRvckVycm9yU3ltYm9sID0gcmVxdWlyZSgnLi9oZWxwZXJzL3N5bWJvbHMnKS52YWxpZGF0b3JFcnJvclN5bWJvbDtcbmNvbnN0IGRvY3VtZW50SXNNb2RpZmllZCA9IHJlcXVpcmUoJy4vaGVscGVycy9zeW1ib2xzJykuZG9jdW1lbnRJc01vZGlmaWVkO1xuXG5jb25zdCBwb3B1bGF0ZU1vZGVsU3ltYm9sID0gcmVxdWlyZSgnLi9oZWxwZXJzL3N5bWJvbHMnKS5wb3B1bGF0ZU1vZGVsU3ltYm9sO1xuXG5jb25zdCBDYXN0RXJyb3IgPSBNb25nb29zZUVycm9yLkNhc3RFcnJvcjtcbmNvbnN0IFZhbGlkYXRvckVycm9yID0gTW9uZ29vc2VFcnJvci5WYWxpZGF0b3JFcnJvcjtcblxuY29uc3Qgc2V0T3B0aW9uc0ZvckRlZmF1bHRzID0geyBfc2tpcE1hcmtNb2RpZmllZDogdHJ1ZSB9O1xuXG4vKipcbiAqIFNjaGVtYVR5cGUgY29uc3RydWN0b3IuIERvICoqbm90KiogaW5zdGFudGlhdGUgYFNjaGVtYVR5cGVgIGRpcmVjdGx5LlxuICogTW9uZ29vc2UgY29udmVydHMgeW91ciBzY2hlbWEgcGF0aHMgaW50byBTY2hlbWFUeXBlcyBhdXRvbWF0aWNhbGx5LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZyB9KTtcbiAqICAgICBzY2hlbWEucGF0aCgnbmFtZScpIGluc3RhbmNlb2YgU2NoZW1hVHlwZTsgLy8gdHJ1ZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge1NjaGVtYVR5cGVPcHRpb25zfSBbb3B0aW9uc10gU2VlIFtTY2hlbWFUeXBlT3B0aW9ucyBkb2NzXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3NjaGVtYXR5cGVvcHRpb25zLmh0bWwpXG4gKiBAcGFyYW0ge1N0cmluZ30gW2luc3RhbmNlXVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTY2hlbWFUeXBlKHBhdGgsIG9wdGlvbnMsIGluc3RhbmNlKSB7XG4gIHRoaXNbc2NoZW1hVHlwZVN5bWJvbF0gPSB0cnVlO1xuICB0aGlzLnBhdGggPSBwYXRoO1xuICB0aGlzLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gIHRoaXMudmFsaWRhdG9ycyA9IFtdO1xuICB0aGlzLmdldHRlcnMgPSB0aGlzLmNvbnN0cnVjdG9yLmhhc093blByb3BlcnR5KCdnZXR0ZXJzJykgP1xuICAgIHRoaXMuY29uc3RydWN0b3IuZ2V0dGVycy5zbGljZSgpIDpcbiAgICBbXTtcbiAgdGhpcy5zZXR0ZXJzID0gdGhpcy5jb25zdHJ1Y3Rvci5oYXNPd25Qcm9wZXJ0eSgnc2V0dGVycycpID9cbiAgICB0aGlzLmNvbnN0cnVjdG9yLnNldHRlcnMuc2xpY2UoKSA6XG4gICAgW107XG5cbiAgdGhpcy5zcGxpdFBhdGgoKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB0aGlzLmNvbnN0cnVjdG9yLmRlZmF1bHRPcHRpb25zIHx8IHt9O1xuICBjb25zdCBkZWZhdWx0T3B0aW9uc0tleXMgPSBPYmplY3Qua2V5cyhkZWZhdWx0T3B0aW9ucyk7XG5cbiAgZm9yIChjb25zdCBvcHRpb24gb2YgZGVmYXVsdE9wdGlvbnNLZXlzKSB7XG4gICAgaWYgKG9wdGlvbiA9PT0gJ3ZhbGlkYXRlJykge1xuICAgICAgdGhpcy52YWxpZGF0ZShkZWZhdWx0T3B0aW9ucy52YWxpZGF0ZSk7XG4gICAgfSBlbHNlIGlmIChkZWZhdWx0T3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShvcHRpb24pICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgb3B0aW9uKSkge1xuICAgICAgb3B0aW9uc1tvcHRpb25dID0gZGVmYXVsdE9wdGlvbnNbb3B0aW9uXTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0aW9ucy5zZWxlY3QgPT0gbnVsbCkge1xuICAgIGRlbGV0ZSBvcHRpb25zLnNlbGVjdDtcbiAgfVxuXG4gIGNvbnN0IE9wdGlvbnMgPSB0aGlzLk9wdGlvbnNDb25zdHJ1Y3RvciB8fCBTY2hlbWFUeXBlT3B0aW9ucztcbiAgdGhpcy5vcHRpb25zID0gbmV3IE9wdGlvbnMob3B0aW9ucyk7XG4gIHRoaXMuX2luZGV4ID0gbnVsbDtcblxuXG4gIGlmICh1dGlscy5oYXNVc2VyRGVmaW5lZFByb3BlcnR5KHRoaXMub3B0aW9ucywgJ2ltbXV0YWJsZScpKSB7XG4gICAgdGhpcy4kaW1tdXRhYmxlID0gdGhpcy5vcHRpb25zLmltbXV0YWJsZTtcblxuICAgIGhhbmRsZUltbXV0YWJsZSh0aGlzKTtcbiAgfVxuXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMpO1xuICBmb3IgKGNvbnN0IHByb3Agb2Yga2V5cykge1xuICAgIGlmIChwcm9wID09PSAnY2FzdCcpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMub3B0aW9uc1twcm9wXSkpIHtcbiAgICAgICAgdGhpcy5jYXN0RnVuY3Rpb24uYXBwbHkodGhpcywgdGhpcy5vcHRpb25zW3Byb3BdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2FzdEZ1bmN0aW9uKHRoaXMub3B0aW9uc1twcm9wXSk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmhhc1VzZXJEZWZpbmVkUHJvcGVydHkodGhpcy5vcHRpb25zLCBwcm9wKSAmJiB0eXBlb2YgdGhpc1twcm9wXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8geyB1bmlxdWU6IHRydWUsIGluZGV4OiB0cnVlIH1cbiAgICAgIGlmIChwcm9wID09PSAnaW5kZXgnICYmIHRoaXMuX2luZGV4KSB7XG4gICAgICAgIGlmIChvcHRpb25zLmluZGV4ID09PSBmYWxzZSkge1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5faW5kZXg7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ29iamVjdCcgJiYgaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGluZGV4LnVuaXF1ZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhdGggXCInICsgdGhpcy5wYXRoICsgJ1wiIG1heSBub3QgaGF2ZSBgaW5kZXhgICcgK1xuICAgICAgICAgICAgICAgICdzZXQgdG8gZmFsc2UgYW5kIGB1bmlxdWVgIHNldCB0byB0cnVlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5kZXguc3BhcnNlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGF0aCBcIicgKyB0aGlzLnBhdGggKyAnXCIgbWF5IG5vdCBoYXZlIGBpbmRleGAgJyArXG4gICAgICAgICAgICAgICAgJ3NldCB0byBmYWxzZSBhbmQgYHNwYXJzZWAgc2V0IHRvIHRydWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9pbmRleCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB2YWwgPSBvcHRpb25zW3Byb3BdO1xuICAgICAgLy8gU3BlY2lhbCBjYXNlIHNvIHdlIGRvbid0IHNjcmV3IHVwIGFycmF5IGRlZmF1bHRzLCBzZWUgZ2gtNTc4MFxuICAgICAgaWYgKHByb3AgPT09ICdkZWZhdWx0Jykge1xuICAgICAgICB0aGlzLmRlZmF1bHQodmFsKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9wdHMgPSBBcnJheS5pc0FycmF5KHZhbCkgPyB2YWwgOiBbdmFsXTtcblxuICAgICAgdGhpc1twcm9wXS5hcHBseSh0aGlzLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJyQkY29udGV4dCcsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBudWxsXG4gIH0pO1xufVxuXG4vKipcbiAqIFRoZSBjbGFzcyB0aGF0IE1vbmdvb3NlIHVzZXMgaW50ZXJuYWxseSB0byBpbnN0YW50aWF0ZSB0aGlzIFNjaGVtYVR5cGUncyBgb3B0aW9uc2AgcHJvcGVydHkuXG4gKiBAbWVtYmVyT2YgU2NoZW1hVHlwZVxuICogQGluc3RhbmNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5PcHRpb25zQ29uc3RydWN0b3IgPSBTY2hlbWFUeXBlT3B0aW9ucztcblxuLyoqXG4gKiBUaGUgcGF0aCB0byB0aGlzIFNjaGVtYVR5cGUgaW4gYSBTY2hlbWEuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0pO1xuICogICAgIHNjaGVtYS5wYXRoKCduYW1lJykucGF0aDsgLy8gJ25hbWUnXG4gKlxuICogQHByb3BlcnR5IHBhdGhcbiAqIEBhcGkgcHVibGljXG4gKiBAbWVtYmVyT2YgU2NoZW1hVHlwZVxuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLnBhdGg7XG5cbi8qKlxuICogVGhlIHZhbGlkYXRvcnMgdGhhdCBNb25nb29zZSBzaG91bGQgcnVuIHRvIHZhbGlkYXRlIHByb3BlcnRpZXMgYXQgdGhpcyBTY2hlbWFUeXBlJ3MgcGF0aC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiB7IHR5cGU6IFN0cmluZywgcmVxdWlyZWQ6IHRydWUgfSB9KTtcbiAqICAgICBzY2hlbWEucGF0aCgnbmFtZScpLnZhbGlkYXRvcnMubGVuZ3RoOyAvLyAxLCB0aGUgYHJlcXVpcmVkYCB2YWxpZGF0b3JcbiAqXG4gKiBAcHJvcGVydHkgdmFsaWRhdG9yc1xuICogQGFwaSBwdWJsaWNcbiAqIEBtZW1iZXJPZiBTY2hlbWFUeXBlXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUudmFsaWRhdG9ycztcblxuLyoqXG4gKiBUcnVlIGlmIHRoaXMgU2NoZW1hVHlwZSBoYXMgYSByZXF1aXJlZCB2YWxpZGF0b3IuIEZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiB7IHR5cGU6IFN0cmluZywgcmVxdWlyZWQ6IHRydWUgfSB9KTtcbiAqICAgICBzY2hlbWEucGF0aCgnbmFtZScpLmlzUmVxdWlyZWQ7IC8vIHRydWVcbiAqXG4gKiAgICAgc2NoZW1hLnBhdGgoJ25hbWUnKS5yZXF1aXJlZChmYWxzZSk7XG4gKiAgICAgc2NoZW1hLnBhdGgoJ25hbWUnKS5pc1JlcXVpcmVkOyAvLyBmYWxzZVxuICpcbiAqIEBwcm9wZXJ0eSBpc1JlcXVpcmVkXG4gKiBAYXBpIHB1YmxpY1xuICogQG1lbWJlck9mIFNjaGVtYVR5cGVcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5pc1JlcXVpcmVkO1xuXG4vKipcbiAqIFNwbGl0IHRoZSBjdXJyZW50IGRvdHRldCBwYXRoIGludG8gc2VnbWVudHNcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmdbXXx1bmRlZmluZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5zcGxpdFBhdGggPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX3ByZXNwbGl0UGF0aCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByZXNwbGl0UGF0aDtcbiAgfVxuICBpZiAodGhpcy5wYXRoID09IG51bGwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgdGhpcy5fcHJlc3BsaXRQYXRoID0gdGhpcy5wYXRoLmluZGV4T2YoJy4nKSA9PT0gLTEgPyBbdGhpcy5wYXRoXSA6IHRoaXMucGF0aC5zcGxpdCgnLicpO1xuICByZXR1cm4gdGhpcy5fcHJlc3BsaXRQYXRoO1xufTtcblxuLyoqXG4gKiBHZXQvc2V0IHRoZSBmdW5jdGlvbiB1c2VkIHRvIGNhc3QgYXJiaXRyYXJ5IHZhbHVlcyB0byB0aGlzIHR5cGUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBEaXNhbGxvdyBgbnVsbGAgZm9yIG51bWJlcnMsIGFuZCBkb24ndCB0cnkgdG8gY2FzdCBhbnkgdmFsdWVzIHRvXG4gKiAgICAgLy8gbnVtYmVycywgc28gZXZlbiBzdHJpbmdzIGxpa2UgJzEyMycgd2lsbCBjYXVzZSBhIENhc3RFcnJvci5cbiAqICAgICBtb25nb29zZS5OdW1iZXIuY2FzdChmdW5jdGlvbih2KSB7XG4gKiAgICAgICBhc3NlcnQub2sodiA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB2ID09PSAnbnVtYmVyJyk7XG4gKiAgICAgICByZXR1cm4gdjtcbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufGZhbHNlfSBjYXN0ZXIgRnVuY3Rpb24gdGhhdCBjYXN0cyBhcmJpdHJhcnkgdmFsdWVzIHRvIHRoaXMgdHlwZSwgb3IgdGhyb3dzIGFuIGVycm9yIGlmIGNhc3RpbmcgZmFpbGVkXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBTY2hlbWFUeXBlXG4gKiBAZnVuY3Rpb24gY2FzdFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFUeXBlLmNhc3QgPSBmdW5jdGlvbiBjYXN0KGNhc3Rlcikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzLl9jYXN0O1xuICB9XG4gIGlmIChjYXN0ZXIgPT09IGZhbHNlKSB7XG4gICAgY2FzdGVyID0gdiA9PiB2O1xuICB9XG4gIHRoaXMuX2Nhc3QgPSBjYXN0ZXI7XG5cbiAgcmV0dXJuIHRoaXMuX2Nhc3Q7XG59O1xuXG4vKipcbiAqIEdldC9zZXQgdGhlIGZ1bmN0aW9uIHVzZWQgdG8gY2FzdCBhcmJpdHJhcnkgdmFsdWVzIHRvIHRoaXMgcGFydGljdWxhciBzY2hlbWF0eXBlIGluc3RhbmNlLlxuICogT3ZlcnJpZGVzIGBTY2hlbWFUeXBlLmNhc3QoKWAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBEaXNhbGxvdyBgbnVsbGAgZm9yIG51bWJlcnMsIGFuZCBkb24ndCB0cnkgdG8gY2FzdCBhbnkgdmFsdWVzIHRvXG4gKiAgICAgLy8gbnVtYmVycywgc28gZXZlbiBzdHJpbmdzIGxpa2UgJzEyMycgd2lsbCBjYXVzZSBhIENhc3RFcnJvci5cbiAqICAgICBjb25zdCBudW1iZXIgPSBuZXcgbW9uZ29vc2UuTnVtYmVyKCdteXBhdGgnLCB7fSk7XG4gKiAgICAgbnVtYmVyLmNhc3QoZnVuY3Rpb24odikge1xuICogICAgICAgYXNzZXJ0Lm9rKHYgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdiA9PT0gJ251bWJlcicpO1xuICogICAgICAgcmV0dXJuIHY7XG4gKiAgICAgfSk7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbnxmYWxzZX0gY2FzdGVyIEZ1bmN0aW9uIHRoYXQgY2FzdHMgYXJiaXRyYXJ5IHZhbHVlcyB0byB0aGlzIHR5cGUsIG9yIHRocm93cyBhbiBlcnJvciBpZiBjYXN0aW5nIGZhaWxlZFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAbWVtYmVyT2YgU2NoZW1hVHlwZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5jYXN0RnVuY3Rpb24gPSBmdW5jdGlvbiBjYXN0RnVuY3Rpb24oY2FzdGVyLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nhc3RGdW5jdGlvbjtcbiAgfVxuXG4gIGlmIChjYXN0ZXIgPT09IGZhbHNlKSB7XG4gICAgY2FzdGVyID0gdGhpcy5jb25zdHJ1Y3Rvci5fZGVmYXVsdENhc3RlciB8fCAodiA9PiB2KTtcbiAgfVxuICBpZiAodHlwZW9mIGNhc3RlciA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLl9jYXN0RXJyb3JNZXNzYWdlID0gY2FzdGVyO1xuICAgIHJldHVybiB0aGlzLl9jYXN0RnVuY3Rpb247XG4gIH1cbiAgaWYgKGNhc3RlciAhPSBudWxsKSB7XG4gICAgdGhpcy5fY2FzdEZ1bmN0aW9uID0gY2FzdGVyO1xuICB9XG4gIGlmIChtZXNzYWdlICE9IG51bGwpIHtcbiAgICB0aGlzLl9jYXN0RXJyb3JNZXNzYWdlID0gbWVzc2FnZTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9jYXN0RnVuY3Rpb247XG59O1xuXG4vKipcbiAqIFRoZSBmdW5jdGlvbiB0aGF0IE1vbmdvb3NlIGNhbGxzIHRvIGNhc3QgYXJiaXRyYXJ5IHZhbHVlcyB0byB0aGlzIFNjaGVtYVR5cGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIHZhbHVlIHRvIGNhc3RcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvYyBkb2N1bWVudCB0aGF0IHRyaWdnZXJzIHRoZSBjYXN0aW5nXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluaXRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUuY2FzdCA9IGZ1bmN0aW9uIGNhc3QoKSB7XG4gIHRocm93IG5ldyBFcnJvcignQmFzZSBTY2hlbWFUeXBlIGNsYXNzIGRvZXMgbm90IGltcGxlbWVudCBhIGBjYXN0KClgIGZ1bmN0aW9uJyk7XG59O1xuXG4vKipcbiAqIFNldHMgYSBkZWZhdWx0IG9wdGlvbiBmb3IgdGhpcyBzY2hlbWEgdHlwZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1ha2UgYWxsIHN0cmluZ3MgYmUgdHJpbW1lZCBieSBkZWZhdWx0XG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hVHlwZXMuU3RyaW5nLnNldCgndHJpbScsIHRydWUpO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb24gVGhlIG5hbWUgb2YgdGhlIG9wdGlvbiB5b3UnZCBsaWtlIHRvIHNldCAoZS5nLiB0cmltLCBsb3dlcmNhc2UsIGV0Yy4uLilcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIG9wdGlvbiB5b3UnZCBsaWtlIHRvIHNldC5cbiAqIEByZXR1cm4ge3ZvaWR9XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgU2NoZW1hVHlwZVxuICogQGZ1bmN0aW9uIHNldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFUeXBlLnNldCA9IGZ1bmN0aW9uIHNldChvcHRpb24sIHZhbHVlKSB7XG4gIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdE9wdGlvbnMnKSkge1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcbiAgfVxuICB0aGlzLmRlZmF1bHRPcHRpb25zW29wdGlvbl0gPSB2YWx1ZTtcbn07XG5cbi8qKlxuICogQXR0YWNoZXMgYSBnZXR0ZXIgZm9yIGFsbCBpbnN0YW5jZXMgb2YgdGhpcyBzY2hlbWEgdHlwZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1ha2UgYWxsIG51bWJlcnMgcm91bmQgZG93blxuICogICAgIG1vbmdvb3NlLk51bWJlci5nZXQoZnVuY3Rpb24odikgeyByZXR1cm4gTWF0aC5mbG9vcih2KTsgfSk7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyXG4gKiBAcmV0dXJuIHt0aGlzfVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIFNjaGVtYVR5cGVcbiAqIEBmdW5jdGlvbiBnZXRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hVHlwZS5nZXQgPSBmdW5jdGlvbihnZXR0ZXIpIHtcbiAgdGhpcy5nZXR0ZXJzID0gdGhpcy5oYXNPd25Qcm9wZXJ0eSgnZ2V0dGVycycpID8gdGhpcy5nZXR0ZXJzIDogW107XG4gIHRoaXMuZ2V0dGVycy5wdXNoKGdldHRlcik7XG59O1xuXG4vKipcbiAqIFNldHMgYSBkZWZhdWx0IHZhbHVlIGZvciB0aGlzIFNjaGVtYVR5cGUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbjogeyB0eXBlOiBOdW1iZXIsIGRlZmF1bHQ6IDEwIH0pXG4gKiAgICAgY29uc3QgTSA9IGRiLm1vZGVsKCdNJywgc2NoZW1hKVxuICogICAgIGNvbnN0IG0gPSBuZXcgTTtcbiAqICAgICBjb25zb2xlLmxvZyhtLm4pIC8vIDEwXG4gKlxuICogRGVmYXVsdHMgY2FuIGJlIGVpdGhlciBgZnVuY3Rpb25zYCB3aGljaCByZXR1cm4gdGhlIHZhbHVlIHRvIHVzZSBhcyB0aGUgZGVmYXVsdCBvciB0aGUgbGl0ZXJhbCB2YWx1ZSBpdHNlbGYuIEVpdGhlciB3YXksIHRoZSB2YWx1ZSB3aWxsIGJlIGNhc3QgYmFzZWQgb24gaXRzIHNjaGVtYSB0eXBlIGJlZm9yZSBiZWluZyBzZXQgZHVyaW5nIGRvY3VtZW50IGNyZWF0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gdmFsdWVzIGFyZSBjYXN0OlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBhTnVtYmVyOiB7IHR5cGU6IE51bWJlciwgZGVmYXVsdDogNC44MTUxNjIzNDIgfX0pXG4gKiAgICAgY29uc3QgTSA9IGRiLm1vZGVsKCdNJywgc2NoZW1hKVxuICogICAgIGNvbnN0IG0gPSBuZXcgTTtcbiAqICAgICBjb25zb2xlLmxvZyhtLmFOdW1iZXIpIC8vIDQuODE1MTYyMzQyXG4gKlxuICogICAgIC8vIGRlZmF1bHQgdW5pcXVlIG9iamVjdHMgZm9yIE1peGVkIHR5cGVzOlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBtaXhlZDogU2NoZW1hLlR5cGVzLk1peGVkIH0pO1xuICogICAgIHNjaGVtYS5wYXRoKCdtaXhlZCcpLmRlZmF1bHQoZnVuY3Rpb24gKCkge1xuICogICAgICAgcmV0dXJuIHt9O1xuICogICAgIH0pO1xuICpcbiAqICAgICAvLyBpZiB3ZSBkb24ndCB1c2UgYSBmdW5jdGlvbiB0byByZXR1cm4gb2JqZWN0IGxpdGVyYWxzIGZvciBNaXhlZCBkZWZhdWx0cyxcbiAqICAgICAvLyBlYWNoIGRvY3VtZW50IHdpbGwgcmVjZWl2ZSBhIHJlZmVyZW5jZSB0byB0aGUgc2FtZSBvYmplY3QgbGl0ZXJhbCBjcmVhdGluZ1xuICogICAgIC8vIGEgXCJzaGFyZWRcIiBvYmplY3QgaW5zdGFuY2U6XG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IG1peGVkOiBTY2hlbWEuVHlwZXMuTWl4ZWQgfSk7XG4gKiAgICAgc2NoZW1hLnBhdGgoJ21peGVkJykuZGVmYXVsdCh7fSk7XG4gKiAgICAgY29uc3QgTSA9IGRiLm1vZGVsKCdNJywgc2NoZW1hKTtcbiAqICAgICBjb25zdCBtMSA9IG5ldyBNO1xuICogICAgIG0xLm1peGVkLmFkZGVkID0gMTtcbiAqICAgICBjb25zb2xlLmxvZyhtMS5taXhlZCk7IC8vIHsgYWRkZWQ6IDEgfVxuICogICAgIGNvbnN0IG0yID0gbmV3IE07XG4gKiAgICAgY29uc29sZS5sb2cobTIubWl4ZWQpOyAvLyB7IGFkZGVkOiAxIH1cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufGFueX0gdmFsIFRoZSBkZWZhdWx0IHZhbHVlIHRvIHNldFxuICogQHJldHVybiB7QW55fHVuZGVmaW5lZH0gUmV0dXJucyB0aGUgc2V0IGRlZmF1bHQgdmFsdWUuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLmRlZmF1bHQgPSBmdW5jdGlvbih2YWwpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAodmFsID09PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gdm9pZCAwO1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG5cbiAgICBpZiAodmFsICE9IG51bGwgJiYgdmFsLmluc3RhbmNlT2ZTY2hlbWEpIHtcbiAgICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdDYW5ub3Qgc2V0IGRlZmF1bHQgdmFsdWUgb2YgcGF0aCBgJyArIHRoaXMucGF0aCArXG4gICAgICAgICdgIHRvIGEgbW9uZ29vc2UgU2NoZW1hIGluc3RhbmNlLicpO1xuICAgIH1cblxuICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gdmFsO1xuICAgIHJldHVybiB0aGlzLmRlZmF1bHRWYWx1ZTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gWy4uLmFyZ3VtZW50c107XG4gIH1cbiAgcmV0dXJuIHRoaXMuZGVmYXVsdFZhbHVlO1xufTtcblxuLyoqXG4gKiBEZWNsYXJlcyB0aGUgaW5kZXggb3B0aW9ucyBmb3IgdGhpcyBzY2hlbWF0eXBlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoeyBuYW1lOiB7IHR5cGU6IFN0cmluZywgaW5kZXg6IHRydWUgfSlcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IG5hbWU6IHsgdHlwZTogU3RyaW5nLCBpbmRleDogLTEgfSlcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IGxvYzogeyB0eXBlOiBbTnVtYmVyXSwgaW5kZXg6ICdoYXNoZWQnIH0pXG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoeyBsb2M6IHsgdHlwZTogW051bWJlcl0sIGluZGV4OiAnMmQnLCBzcGFyc2U6IHRydWUgfSlcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IGxvYzogeyB0eXBlOiBbTnVtYmVyXSwgaW5kZXg6IHsgdHlwZTogJzJkc3BoZXJlJywgc3BhcnNlOiB0cnVlIH19KVxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgZGF0ZTogeyB0eXBlOiBEYXRlLCBpbmRleDogeyB1bmlxdWU6IHRydWUsIGV4cGlyZXM6ICcxZCcgfX0pXG4gKiAgICAgcy5wYXRoKCdteS5wYXRoJykuaW5kZXgodHJ1ZSk7XG4gKiAgICAgcy5wYXRoKCdteS5kYXRlJykuaW5kZXgoeyBleHBpcmVzOiA2MCB9KTtcbiAqICAgICBzLnBhdGgoJ215LnBhdGgnKS5pbmRleCh7IHVuaXF1ZTogdHJ1ZSwgc3BhcnNlOiB0cnVlIH0pO1xuICpcbiAqICMjIyMgTm90ZTpcbiAqXG4gKiBfSW5kZXhlcyBhcmUgY3JlYXRlZCBbaW4gdGhlIGJhY2tncm91bmRdKGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL2NvcmUvaW5kZXgtY3JlYXRpb24vI2luZGV4LWNyZWF0aW9uLWJhY2tncm91bmQpXG4gKiBieSBkZWZhdWx0LiBJZiBgYmFja2dyb3VuZGAgaXMgc2V0IHRvIGBmYWxzZWAsIE1vbmdvREIgd2lsbCBub3QgZXhlY3V0ZSBhbnlcbiAqIHJlYWQvd3JpdGUgb3BlcmF0aW9ucyB5b3Ugc2VuZCB1bnRpbCB0aGUgaW5kZXggYnVpbGQuXG4gKiBTcGVjaWZ5IGBiYWNrZ3JvdW5kOiBmYWxzZWAgdG8gb3ZlcnJpZGUgTW9uZ29vc2UncyBkZWZhdWx0Ll9cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxCb29sZWFufFN0cmluZ3xOdW1iZXJ9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUuaW5kZXggPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHRoaXMuX2luZGV4ID0gb3B0aW9ucztcbiAgdXRpbHMuZXhwaXJlcyh0aGlzLl9pbmRleCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEZWNsYXJlcyBhbiB1bmlxdWUgaW5kZXguXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IG5hbWU6IHsgdHlwZTogU3RyaW5nLCB1bmlxdWU6IHRydWUgfSB9KTtcbiAqICAgICBzLnBhdGgoJ25hbWUnKS5pbmRleCh7IHVuaXF1ZTogdHJ1ZSB9KTtcbiAqXG4gKiBfTk9URTogdmlvbGF0aW5nIHRoZSBjb25zdHJhaW50IHJldHVybnMgYW4gYEUxMTAwMGAgZXJyb3IgZnJvbSBNb25nb0RCIHdoZW4gc2F2aW5nLCBub3QgYSBNb25nb29zZSB2YWxpZGF0aW9uIGVycm9yLl9cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGJvb2xcbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUudW5pcXVlID0gZnVuY3Rpb24oYm9vbCkge1xuICBpZiAodGhpcy5faW5kZXggPT09IGZhbHNlKSB7XG4gICAgaWYgKCFib29sKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignUGF0aCBcIicgKyB0aGlzLnBhdGggKyAnXCIgbWF5IG5vdCBoYXZlIGBpbmRleGAgc2V0IHRvICcgK1xuICAgICAgJ2ZhbHNlIGFuZCBgdW5pcXVlYCBzZXQgdG8gdHJ1ZScpO1xuICB9XG5cbiAgaWYgKCF0aGlzLm9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2luZGV4JykgJiYgYm9vbCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmICh0aGlzLl9pbmRleCA9PSBudWxsIHx8IHRoaXMuX2luZGV4ID09PSB0cnVlKSB7XG4gICAgdGhpcy5faW5kZXggPSB7fTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5faW5kZXggPT09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy5faW5kZXggPSB7IHR5cGU6IHRoaXMuX2luZGV4IH07XG4gIH1cblxuICB0aGlzLl9pbmRleC51bmlxdWUgPSBib29sO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGVjbGFyZXMgYSBmdWxsIHRleHQgaW5kZXguXG4gKlxuICogIyMjIEV4YW1wbGU6XG4gKlxuICogICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IG5hbWUgOiB7IHR5cGU6IFN0cmluZywgdGV4dCA6IHRydWUgfSB9KVxuICogICAgICBzLnBhdGgoJ25hbWUnKS5pbmRleCh7IHRleHQgOiB0cnVlIH0pO1xuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYm9vbFxuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24oYm9vbCkge1xuICBpZiAodGhpcy5faW5kZXggPT09IGZhbHNlKSB7XG4gICAgaWYgKCFib29sKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYXRoIFwiJyArIHRoaXMucGF0aCArICdcIiBtYXkgbm90IGhhdmUgYGluZGV4YCBzZXQgdG8gJyArXG4gICAgICAnZmFsc2UgYW5kIGB0ZXh0YCBzZXQgdG8gdHJ1ZScpO1xuICB9XG5cbiAgaWYgKCF0aGlzLm9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2luZGV4JykgJiYgYm9vbCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmICh0aGlzLl9pbmRleCA9PT0gbnVsbCB8fCB0aGlzLl9pbmRleCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgdHlwZW9mIHRoaXMuX2luZGV4ID09PSAnYm9vbGVhbicpIHtcbiAgICB0aGlzLl9pbmRleCA9IHt9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9pbmRleCA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLl9pbmRleCA9IHsgdHlwZTogdGhpcy5faW5kZXggfTtcbiAgfVxuXG4gIHRoaXMuX2luZGV4LnRleHQgPSBib29sO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGVjbGFyZXMgYSBzcGFyc2UgaW5kZXguXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IG5hbWU6IHsgdHlwZTogU3RyaW5nLCBzcGFyc2U6IHRydWUgfSB9KTtcbiAqICAgICBzLnBhdGgoJ25hbWUnKS5pbmRleCh7IHNwYXJzZTogdHJ1ZSB9KTtcbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGJvb2xcbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUuc3BhcnNlID0gZnVuY3Rpb24oYm9vbCkge1xuICBpZiAodGhpcy5faW5kZXggPT09IGZhbHNlKSB7XG4gICAgaWYgKCFib29sKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYXRoIFwiJyArIHRoaXMucGF0aCArICdcIiBtYXkgbm90IGhhdmUgYGluZGV4YCBzZXQgdG8gJyArXG4gICAgICAnZmFsc2UgYW5kIGBzcGFyc2VgIHNldCB0byB0cnVlJyk7XG4gIH1cblxuICBpZiAoIXRoaXMub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnaW5kZXgnKSAmJiBib29sID09PSBmYWxzZSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKHRoaXMuX2luZGV4ID09IG51bGwgfHwgdHlwZW9mIHRoaXMuX2luZGV4ID09PSAnYm9vbGVhbicpIHtcbiAgICB0aGlzLl9pbmRleCA9IHt9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9pbmRleCA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLl9pbmRleCA9IHsgdHlwZTogdGhpcy5faW5kZXggfTtcbiAgfVxuXG4gIHRoaXMuX2luZGV4LnNwYXJzZSA9IGJvb2w7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEZWZpbmVzIHRoaXMgcGF0aCBhcyBpbW11dGFibGUuIE1vbmdvb3NlIHByZXZlbnRzIHlvdSBmcm9tIGNoYW5naW5nXG4gKiBpbW11dGFibGUgcGF0aHMgdW5sZXNzIHRoZSBwYXJlbnQgZG9jdW1lbnQgaGFzIFtgaXNOZXc6IHRydWVgXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2RvY3VtZW50Lmh0bWwjRG9jdW1lbnQucHJvdG90eXBlLmlzTmV3KCkpLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7XG4gKiAgICAgICBuYW1lOiB7IHR5cGU6IFN0cmluZywgaW1tdXRhYmxlOiB0cnVlIH0sXG4gKiAgICAgICBhZ2U6IE51bWJlclxuICogICAgIH0pO1xuICogICAgIGNvbnN0IE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBzY2hlbWEpO1xuICpcbiAqICAgICBhd2FpdCBNb2RlbC5jcmVhdGUoeyBuYW1lOiAndGVzdCcgfSk7XG4gKiAgICAgY29uc3QgZG9jID0gYXdhaXQgTW9kZWwuZmluZE9uZSgpO1xuICpcbiAqICAgICBkb2MuaXNOZXc7IC8vIGZhbHNlXG4gKiAgICAgZG9jLm5hbWUgPSAnbmV3IG5hbWUnO1xuICogICAgIGRvYy5uYW1lOyAvLyAndGVzdCcsIGJlY2F1c2UgYG5hbWVgIGlzIGltbXV0YWJsZVxuICpcbiAqIE1vbmdvb3NlIGFsc28gcHJldmVudHMgY2hhbmdpbmcgaW1tdXRhYmxlIHByb3BlcnRpZXMgdXNpbmcgYHVwZGF0ZU9uZSgpYFxuICogYW5kIGB1cGRhdGVNYW55KClgIGJhc2VkIG9uIFtzdHJpY3QgbW9kZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2d1aWRlLmh0bWwjc3RyaWN0KS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1vbmdvb3NlIHdpbGwgc3RyaXAgb3V0IHRoZSBgbmFtZWAgdXBkYXRlLCBiZWNhdXNlIGBuYW1lYCBpcyBpbW11dGFibGVcbiAqICAgICBNb2RlbC51cGRhdGVPbmUoe30sIHsgJHNldDogeyBuYW1lOiAndGVzdDInIH0sICRpbmM6IHsgYWdlOiAxIH0gfSk7XG4gKlxuICogICAgIC8vIElmIGBzdHJpY3RgIGlzIHNldCB0byAndGhyb3cnLCBNb25nb29zZSB3aWxsIHRocm93IGFuIGVycm9yIGlmIHlvdVxuICogICAgIC8vIHVwZGF0ZSBgbmFtZWBcbiAqICAgICBjb25zdCBlcnIgPSBhd2FpdCBNb2RlbC51cGRhdGVPbmUoe30sIHsgbmFtZTogJ3Rlc3QyJyB9LCB7IHN0cmljdDogJ3Rocm93JyB9KS5cbiAqICAgICAgIHRoZW4oKCkgPT4gbnVsbCwgZXJyID0+IGVycik7XG4gKiAgICAgZXJyLm5hbWU7IC8vIFN0cmljdE1vZGVFcnJvclxuICpcbiAqICAgICAvLyBJZiBgc3RyaWN0YCBpcyBgZmFsc2VgLCBNb25nb29zZSBhbGxvd3MgdXBkYXRpbmcgYG5hbWVgIGV2ZW4gdGhvdWdoXG4gKiAgICAgLy8gdGhlIHByb3BlcnR5IGlzIGltbXV0YWJsZS5cbiAqICAgICBNb2RlbC51cGRhdGVPbmUoe30sIHsgbmFtZTogJ3Rlc3QyJyB9LCB7IHN0cmljdDogZmFsc2UgfSk7XG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBib29sXG4gKiBAcmV0dXJuIHtTY2hlbWFUeXBlfSB0aGlzXG4gKiBAc2VlIGlzTmV3IGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudC5wcm90b3R5cGUuaXNOZXcoKVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5pbW11dGFibGUgPSBmdW5jdGlvbihib29sKSB7XG4gIHRoaXMuJGltbXV0YWJsZSA9IGJvb2w7XG4gIGhhbmRsZUltbXV0YWJsZSh0aGlzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGVmaW5lcyBhIGN1c3RvbSBmdW5jdGlvbiBmb3IgdHJhbnNmb3JtaW5nIHRoaXMgcGF0aCB3aGVuIGNvbnZlcnRpbmcgYSBkb2N1bWVudCB0byBKU09OLlxuICpcbiAqIE1vbmdvb3NlIGNhbGxzIHRoaXMgZnVuY3Rpb24gd2l0aCBvbmUgcGFyYW1ldGVyOiB0aGUgY3VycmVudCBgdmFsdWVgIG9mIHRoZSBwYXRoLiBNb25nb29zZVxuICogdGhlbiB1c2VzIHRoZSByZXR1cm4gdmFsdWUgaW4gdGhlIEpTT04gb3V0cHV0LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7XG4gKiAgICAgICBkYXRlOiB7IHR5cGU6IERhdGUsIHRyYW5zZm9ybTogdiA9PiB2LmdldEZ1bGxZZWFyKCkgfVxuICogICAgIH0pO1xuICogICAgIGNvbnN0IE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBzY2hlbWEpO1xuICpcbiAqICAgICBhd2FpdCBNb2RlbC5jcmVhdGUoeyBkYXRlOiBuZXcgRGF0ZSgnMjAxNi0wNi0wMScpIH0pO1xuICogICAgIGNvbnN0IGRvYyA9IGF3YWl0IE1vZGVsLmZpbmRPbmUoKTtcbiAqXG4gKiAgICAgZG9jLmRhdGUgaW5zdGFuY2VvZiBEYXRlOyAvLyB0cnVlXG4gKlxuICogICAgIGRvYy50b0pTT04oKS5kYXRlOyAvLyAyMDE2IGFzIGEgbnVtYmVyXG4gKiAgICAgSlNPTi5zdHJpbmdpZnkoZG9jKTsgLy8gJ3tcIl9pZFwiOi4uLixcImRhdGVcIjoyMDE2fSdcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbihmbikge1xuICB0aGlzLm9wdGlvbnMudHJhbnNmb3JtID0gZm47XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBzZXR0ZXIgdG8gdGhpcyBzY2hlbWF0eXBlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgZnVuY3Rpb24gY2FwaXRhbGl6ZSAodmFsKSB7XG4gKiAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ3N0cmluZycpIHZhbCA9ICcnO1xuICogICAgICAgcmV0dXJuIHZhbC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHZhbC5zdWJzdHJpbmcoMSk7XG4gKiAgICAgfVxuICpcbiAqICAgICAvLyBkZWZpbmluZyB3aXRoaW4gdGhlIHNjaGVtYVxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgbmFtZTogeyB0eXBlOiBTdHJpbmcsIHNldDogY2FwaXRhbGl6ZSB9fSk7XG4gKlxuICogICAgIC8vIG9yIHdpdGggdGhlIFNjaGVtYVR5cGVcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZyB9KVxuICogICAgIHMucGF0aCgnbmFtZScpLnNldChjYXBpdGFsaXplKTtcbiAqXG4gKiBTZXR0ZXJzIGFsbG93IHlvdSB0byB0cmFuc2Zvcm0gdGhlIGRhdGEgYmVmb3JlIGl0IGdldHMgdG8gdGhlIHJhdyBtb25nb2RiXG4gKiBkb2N1bWVudCBvciBxdWVyeS5cbiAqXG4gKiBTdXBwb3NlIHlvdSBhcmUgaW1wbGVtZW50aW5nIHVzZXIgcmVnaXN0cmF0aW9uIGZvciBhIHdlYnNpdGUuIFVzZXJzIHByb3ZpZGVcbiAqIGFuIGVtYWlsIGFuZCBwYXNzd29yZCwgd2hpY2ggZ2V0cyBzYXZlZCB0byBtb25nb2RiLiBUaGUgZW1haWwgaXMgYSBzdHJpbmdcbiAqIHRoYXQgeW91IHdpbGwgd2FudCB0byBub3JtYWxpemUgdG8gbG93ZXIgY2FzZSwgaW4gb3JkZXIgdG8gYXZvaWQgb25lIGVtYWlsXG4gKiBoYXZpbmcgbW9yZSB0aGFuIG9uZSBhY2NvdW50IC0tIGUuZy4sIG90aGVyd2lzZSwgYXZlbnVlQHEuY29tIGNhbiBiZSByZWdpc3RlcmVkIGZvciAyIGFjY291bnRzIHZpYSBhdmVudWVAcS5jb20gYW5kIEF2RW5VZUBRLkNvTS5cbiAqXG4gKiBZb3UgY2FuIHNldCB1cCBlbWFpbCBsb3dlciBjYXNlIG5vcm1hbGl6YXRpb24gZWFzaWx5IHZpYSBhIE1vbmdvb3NlIHNldHRlci5cbiAqXG4gKiAgICAgZnVuY3Rpb24gdG9Mb3dlcih2KSB7XG4gKiAgICAgICByZXR1cm4gdi50b0xvd2VyQ2FzZSgpO1xuICogICAgIH1cbiAqXG4gKiAgICAgY29uc3QgVXNlclNjaGVtYSA9IG5ldyBTY2hlbWEoe1xuICogICAgICAgZW1haWw6IHsgdHlwZTogU3RyaW5nLCBzZXQ6IHRvTG93ZXIgfVxuICogICAgIH0pO1xuICpcbiAqICAgICBjb25zdCBVc2VyID0gZGIubW9kZWwoJ1VzZXInLCBVc2VyU2NoZW1hKTtcbiAqXG4gKiAgICAgY29uc3QgdXNlciA9IG5ldyBVc2VyKHtlbWFpbDogJ0FWRU5VRUBRLkNPTSd9KTtcbiAqICAgICBjb25zb2xlLmxvZyh1c2VyLmVtYWlsKTsgLy8gJ2F2ZW51ZUBxLmNvbSdcbiAqXG4gKiAgICAgLy8gb3JcbiAqICAgICBjb25zdCB1c2VyID0gbmV3IFVzZXIoKTtcbiAqICAgICB1c2VyLmVtYWlsID0gJ0F2ZW51ZUBRLmNvbSc7XG4gKiAgICAgY29uc29sZS5sb2codXNlci5lbWFpbCk7IC8vICdhdmVudWVAcS5jb20nXG4gKiAgICAgVXNlci51cGRhdGVPbmUoeyBfaWQ6IF9pZCB9LCB7ICRzZXQ6IHsgZW1haWw6ICdBVkVOVUVAUS5DT00nIH0gfSk7IC8vIHVwZGF0ZSB0byAnYXZlbnVlQHEuY29tJ1xuICpcbiAqIEFzIHlvdSBjYW4gc2VlIGFib3ZlLCBzZXR0ZXJzIGFsbG93IHlvdSB0byB0cmFuc2Zvcm0gdGhlIGRhdGEgYmVmb3JlIGl0XG4gKiBzdG9yZWQgaW4gTW9uZ29EQiwgb3IgYmVmb3JlIGV4ZWN1dGluZyBhIHF1ZXJ5LlxuICpcbiAqIF9OT1RFOiB3ZSBjb3VsZCBoYXZlIGFsc28ganVzdCB1c2VkIHRoZSBidWlsdC1pbiBgbG93ZXJjYXNlOiB0cnVlYCBTY2hlbWFUeXBlIG9wdGlvbiBpbnN0ZWFkIG9mIGRlZmluaW5nIG91ciBvd24gZnVuY3Rpb24uX1xuICpcbiAqICAgICBuZXcgU2NoZW1hKHsgZW1haWw6IHsgdHlwZTogU3RyaW5nLCBsb3dlcmNhc2U6IHRydWUgfX0pXG4gKlxuICogU2V0dGVycyBhcmUgYWxzbyBwYXNzZWQgYSBzZWNvbmQgYXJndW1lbnQsIHRoZSBzY2hlbWF0eXBlIG9uIHdoaWNoIHRoZSBzZXR0ZXIgd2FzIGRlZmluZWQuIFRoaXMgYWxsb3dzIGZvciB0YWlsb3JlZCBiZWhhdmlvciBiYXNlZCBvbiBvcHRpb25zIHBhc3NlZCBpbiB0aGUgc2NoZW1hLlxuICpcbiAqICAgICBmdW5jdGlvbiBpbnNwZWN0b3IgKHZhbCwgcHJpb3JWYWx1ZSwgc2NoZW1hdHlwZSkge1xuICogICAgICAgaWYgKHNjaGVtYXR5cGUub3B0aW9ucy5yZXF1aXJlZCkge1xuICogICAgICAgICByZXR1cm4gc2NoZW1hdHlwZS5wYXRoICsgJyBpcyByZXF1aXJlZCc7XG4gKiAgICAgICB9IGVsc2Uge1xuICogICAgICAgICByZXR1cm4gdmFsO1xuICogICAgICAgfVxuICogICAgIH1cbiAqXG4gKiAgICAgY29uc3QgVmlydXNTY2hlbWEgPSBuZXcgU2NoZW1hKHtcbiAqICAgICAgIG5hbWU6IHsgdHlwZTogU3RyaW5nLCByZXF1aXJlZDogdHJ1ZSwgc2V0OiBpbnNwZWN0b3IgfSxcbiAqICAgICAgIHRheG9ub215OiB7IHR5cGU6IFN0cmluZywgc2V0OiBpbnNwZWN0b3IgfVxuICogICAgIH0pXG4gKlxuICogICAgIGNvbnN0IFZpcnVzID0gZGIubW9kZWwoJ1ZpcnVzJywgVmlydXNTY2hlbWEpO1xuICogICAgIGNvbnN0IHYgPSBuZXcgVmlydXMoeyBuYW1lOiAnUGFydm92aXJpZGFlJywgdGF4b25vbXk6ICdQYXJ2b3ZpcmluYWUnIH0pO1xuICpcbiAqICAgICBjb25zb2xlLmxvZyh2Lm5hbWUpOyAgICAgLy8gbmFtZSBpcyByZXF1aXJlZFxuICogICAgIGNvbnNvbGUubG9nKHYudGF4b25vbXkpOyAvLyBQYXJ2b3ZpcmluYWVcbiAqXG4gKiBZb3UgY2FuIGFsc28gdXNlIHNldHRlcnMgdG8gbW9kaWZ5IG90aGVyIHByb3BlcnRpZXMgb24gdGhlIGRvY3VtZW50LiBJZlxuICogeW91J3JlIHNldHRpbmcgYSBwcm9wZXJ0eSBgbmFtZWAgb24gYSBkb2N1bWVudCwgdGhlIHNldHRlciB3aWxsIHJ1biB3aXRoXG4gKiBgdGhpc2AgYXMgdGhlIGRvY3VtZW50LiBCZSBjYXJlZnVsLCBpbiBtb25nb29zZSA1IHNldHRlcnMgd2lsbCBhbHNvIHJ1blxuICogd2hlbiBxdWVyeWluZyBieSBgbmFtZWAgd2l0aCBgdGhpc2AgYXMgdGhlIHF1ZXJ5LlxuICpcbiAqICAgICBjb25zdCBuYW1lU2NoZW1hID0gbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZywga2V5d29yZHM6IFtTdHJpbmddIH0pO1xuICogICAgIG5hbWVTY2hlbWEucGF0aCgnbmFtZScpLnNldChmdW5jdGlvbih2KSB7XG4gKiAgICAgICAvLyBOZWVkIHRvIGNoZWNrIGlmIGB0aGlzYCBpcyBhIGRvY3VtZW50LCBiZWNhdXNlIGluIG1vbmdvb3NlIDVcbiAqICAgICAgIC8vIHNldHRlcnMgd2lsbCBhbHNvIHJ1biBvbiBxdWVyaWVzLCBpbiB3aGljaCBjYXNlIGB0aGlzYCB3aWxsIGJlIGFcbiAqICAgICAgIC8vIG1vbmdvb3NlIHF1ZXJ5IG9iamVjdC5cbiAqICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgRG9jdW1lbnQgJiYgdiAhPSBudWxsKSB7XG4gKiAgICAgICAgIHRoaXMua2V5d29yZHMgPSB2LnNwbGl0KCcgJyk7XG4gKiAgICAgICB9XG4gKiAgICAgICByZXR1cm4gdjtcbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihmbikge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBzZXR0ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG4gIHRoaXMuc2V0dGVycy5wdXNoKGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBnZXR0ZXIgdG8gdGhpcyBzY2hlbWF0eXBlLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgZnVuY3Rpb24gZG9iICh2YWwpIHtcbiAqICAgICAgIGlmICghdmFsKSByZXR1cm4gdmFsO1xuICogICAgICAgcmV0dXJuICh2YWwuZ2V0TW9udGgoKSArIDEpICsgXCIvXCIgKyB2YWwuZ2V0RGF0ZSgpICsgXCIvXCIgKyB2YWwuZ2V0RnVsbFllYXIoKTtcbiAqICAgICB9XG4gKlxuICogICAgIC8vIGRlZmluaW5nIHdpdGhpbiB0aGUgc2NoZW1hXG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoeyBib3JuOiB7IHR5cGU6IERhdGUsIGdldDogZG9iIH0pXG4gKlxuICogICAgIC8vIG9yIGJ5IHJldHJlaXZpbmcgaXRzIFNjaGVtYVR5cGVcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IGJvcm46IERhdGUgfSlcbiAqICAgICBzLnBhdGgoJ2Jvcm4nKS5nZXQoZG9iKVxuICpcbiAqIEdldHRlcnMgYWxsb3cgeW91IHRvIHRyYW5zZm9ybSB0aGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGRhdGEgYXMgaXQgdHJhdmVscyBmcm9tIHRoZSByYXcgbW9uZ29kYiBkb2N1bWVudCB0byB0aGUgdmFsdWUgdGhhdCB5b3Ugc2VlLlxuICpcbiAqIFN1cHBvc2UgeW91IGFyZSBzdG9yaW5nIGNyZWRpdCBjYXJkIG51bWJlcnMgYW5kIHlvdSB3YW50IHRvIGhpZGUgZXZlcnl0aGluZyBleGNlcHQgdGhlIGxhc3QgNCBkaWdpdHMgdG8gdGhlIG1vbmdvb3NlIHVzZXIuIFlvdSBjYW4gZG8gc28gYnkgZGVmaW5pbmcgYSBnZXR0ZXIgaW4gdGhlIGZvbGxvd2luZyB3YXk6XG4gKlxuICogICAgIGZ1bmN0aW9uIG9iZnVzY2F0ZSAoY2MpIHtcbiAqICAgICAgIHJldHVybiAnKioqKi0qKioqLSoqKiotJyArIGNjLnNsaWNlKGNjLmxlbmd0aC00LCBjYy5sZW5ndGgpO1xuICogICAgIH1cbiAqXG4gKiAgICAgY29uc3QgQWNjb3VudFNjaGVtYSA9IG5ldyBTY2hlbWEoe1xuICogICAgICAgY3JlZGl0Q2FyZE51bWJlcjogeyB0eXBlOiBTdHJpbmcsIGdldDogb2JmdXNjYXRlIH1cbiAqICAgICB9KTtcbiAqXG4gKiAgICAgY29uc3QgQWNjb3VudCA9IGRiLm1vZGVsKCdBY2NvdW50JywgQWNjb3VudFNjaGVtYSk7XG4gKlxuICogICAgIEFjY291bnQuZmluZEJ5SWQoaWQsIGZ1bmN0aW9uIChlcnIsIGZvdW5kKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyhmb3VuZC5jcmVkaXRDYXJkTnVtYmVyKTsgLy8gJyoqKiotKioqKi0qKioqLTEyMzQnXG4gKiAgICAgfSk7XG4gKlxuICogR2V0dGVycyBhcmUgYWxzbyBwYXNzZWQgYSBzZWNvbmQgYXJndW1lbnQsIHRoZSBzY2hlbWF0eXBlIG9uIHdoaWNoIHRoZSBnZXR0ZXIgd2FzIGRlZmluZWQuIFRoaXMgYWxsb3dzIGZvciB0YWlsb3JlZCBiZWhhdmlvciBiYXNlZCBvbiBvcHRpb25zIHBhc3NlZCBpbiB0aGUgc2NoZW1hLlxuICpcbiAqICAgICBmdW5jdGlvbiBpbnNwZWN0b3IgKHZhbCwgcHJpb3JWYWx1ZSwgc2NoZW1hdHlwZSkge1xuICogICAgICAgaWYgKHNjaGVtYXR5cGUub3B0aW9ucy5yZXF1aXJlZCkge1xuICogICAgICAgICByZXR1cm4gc2NoZW1hdHlwZS5wYXRoICsgJyBpcyByZXF1aXJlZCc7XG4gKiAgICAgICB9IGVsc2Uge1xuICogICAgICAgICByZXR1cm4gc2NoZW1hdHlwZS5wYXRoICsgJyBpcyBub3QnO1xuICogICAgICAgfVxuICogICAgIH1cbiAqXG4gKiAgICAgY29uc3QgVmlydXNTY2hlbWEgPSBuZXcgU2NoZW1hKHtcbiAqICAgICAgIG5hbWU6IHsgdHlwZTogU3RyaW5nLCByZXF1aXJlZDogdHJ1ZSwgZ2V0OiBpbnNwZWN0b3IgfSxcbiAqICAgICAgIHRheG9ub215OiB7IHR5cGU6IFN0cmluZywgZ2V0OiBpbnNwZWN0b3IgfVxuICogICAgIH0pXG4gKlxuICogICAgIGNvbnN0IFZpcnVzID0gZGIubW9kZWwoJ1ZpcnVzJywgVmlydXNTY2hlbWEpO1xuICpcbiAqICAgICBWaXJ1cy5maW5kQnlJZChpZCwgZnVuY3Rpb24gKGVyciwgdmlydXMpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKHZpcnVzLm5hbWUpOyAgICAgLy8gbmFtZSBpcyByZXF1aXJlZFxuICogICAgICAgY29uc29sZS5sb2codmlydXMudGF4b25vbXkpOyAvLyB0YXhvbm9teSBpcyBub3RcbiAqICAgICB9KVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtTY2hlbWFUeXBlfSB0aGlzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGZuKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIGdldHRlciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cbiAgdGhpcy5nZXR0ZXJzLnB1c2goZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBtdWx0aXBsZSB2YWxpZGF0b3JzIGZvciB0aGlzIGRvY3VtZW50IHBhdGguXG4gKiBDYWxscyBgdmFsaWRhdGUoKWAgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdmFsaWRhdG9ycy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFJlZ0V4cHxGdW5jdGlvbnxPYmplY3Q+fSB2YWxpZGF0b3JzXG4gKiBAcmV0dXJucyB0aGlzXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUudmFsaWRhdGVBbGwgPSBmdW5jdGlvbih2YWxpZGF0b3JzKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsaWRhdG9ycy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMudmFsaWRhdGUodmFsaWRhdG9yc1tpXSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgdmFsaWRhdG9yKHMpIGZvciB0aGlzIGRvY3VtZW50IHBhdGguXG4gKlxuICogVmFsaWRhdG9ycyBhbHdheXMgcmVjZWl2ZSB0aGUgdmFsdWUgdG8gdmFsaWRhdGUgYXMgdGhlaXIgZmlyc3QgYXJndW1lbnQgYW5kXG4gKiBtdXN0IHJldHVybiBgQm9vbGVhbmAuIFJldHVybmluZyBgZmFsc2VgIG9yIHRocm93aW5nIGFuIGVycm9yIG1lYW5zXG4gKiB2YWxpZGF0aW9uIGZhaWxlZC5cbiAqXG4gKiBUaGUgZXJyb3IgbWVzc2FnZSBhcmd1bWVudCBpcyBvcHRpb25hbC4gSWYgbm90IHBhc3NlZCwgdGhlIFtkZWZhdWx0IGdlbmVyaWMgZXJyb3IgbWVzc2FnZSB0ZW1wbGF0ZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9lcnJvci5odG1sI0Vycm9yLm1lc3NhZ2VzKSB3aWxsIGJlIHVzZWQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBtYWtlIHN1cmUgZXZlcnkgdmFsdWUgaXMgZXF1YWwgdG8gXCJzb21ldGhpbmdcIlxuICogICAgIGZ1bmN0aW9uIHZhbGlkYXRvciAodmFsKSB7XG4gKiAgICAgICByZXR1cm4gdmFsID09PSAnc29tZXRoaW5nJztcbiAqICAgICB9XG4gKiAgICAgbmV3IFNjaGVtYSh7IG5hbWU6IHsgdHlwZTogU3RyaW5nLCB2YWxpZGF0ZTogdmFsaWRhdG9yIH19KTtcbiAqXG4gKiAgICAgLy8gd2l0aCBhIGN1c3RvbSBlcnJvciBtZXNzYWdlXG4gKlxuICogICAgIGNvbnN0IGN1c3RvbSA9IFt2YWxpZGF0b3IsICdVaCBvaCwge1BBVEh9IGRvZXMgbm90IGVxdWFsIFwic29tZXRoaW5nXCIuJ11cbiAqICAgICBuZXcgU2NoZW1hKHsgbmFtZTogeyB0eXBlOiBTdHJpbmcsIHZhbGlkYXRlOiBjdXN0b20gfX0pO1xuICpcbiAqICAgICAvLyBhZGRpbmcgbWFueSB2YWxpZGF0b3JzIGF0IGEgdGltZVxuICpcbiAqICAgICBjb25zdCBtYW55ID0gW1xuICogICAgICAgICB7IHZhbGlkYXRvcjogdmFsaWRhdG9yLCBtZXNzYWdlOiAndWggb2gnIH1cbiAqICAgICAgICwgeyB2YWxpZGF0b3I6IGFub3RoZXJWYWxpZGF0b3IsIG1lc3NhZ2U6ICdmYWlsZWQnIH1cbiAqICAgICBdXG4gKiAgICAgbmV3IFNjaGVtYSh7IG5hbWU6IHsgdHlwZTogU3RyaW5nLCB2YWxpZGF0ZTogbWFueSB9fSk7XG4gKlxuICogICAgIC8vIG9yIHV0aWxpemluZyBTY2hlbWFUeXBlIG1ldGhvZHMgZGlyZWN0bHk6XG4gKlxuICogICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoeyBuYW1lOiAnc3RyaW5nJyB9KTtcbiAqICAgICBzY2hlbWEucGF0aCgnbmFtZScpLnZhbGlkYXRlKHZhbGlkYXRvciwgJ3ZhbGlkYXRpb24gb2YgYHtQQVRIfWAgZmFpbGVkIHdpdGggdmFsdWUgYHtWQUxVRX1gJyk7XG4gKlxuICogIyMjIyBFcnJvciBtZXNzYWdlIHRlbXBsYXRlczpcbiAqXG4gKiBCZWxvdyBpcyBhIGxpc3Qgb2Ygc3VwcG9ydGVkIHRlbXBsYXRlIGtleXdvcmRzOlxuICpcbiAqIC0gUEFUSDogVGhlIHNjaGVtYSBwYXRoIHdoZXJlIHRoZSBlcnJvciBpcyBiZWluZyB0cmlnZ2VyZWQuXG4gKiAtIFZBTFVFOiBUaGUgdmFsdWUgYXNzaWduZWQgdG8gdGhlIFBBVEggdGhhdCBpcyB0cmlnZ2VyaW5nIHRoZSBlcnJvci5cbiAqIC0gS0lORDogVGhlIHZhbGlkYXRpb24gcHJvcGVydHkgdGhhdCB0cmlnZ2VyZWQgdGhlIGVycm9yIGkuZS4gcmVxdWlyZWQuXG4gKiAtIFJFQVNPTjogVGhlIGVycm9yIG9iamVjdCB0aGF0IGNhdXNlZCB0aGlzIGVycm9yIGlmIHRoZXJlIHdhcyBvbmUuXG4gKlxuICogSWYgTW9uZ29vc2UncyBidWlsdC1pbiBlcnJvciBtZXNzYWdlIHRlbXBsYXRpbmcgaXNuJ3QgZW5vdWdoLCBNb25nb29zZVxuICogc3VwcG9ydHMgc2V0dGluZyB0aGUgYG1lc3NhZ2VgIHByb3BlcnR5IHRvIGEgZnVuY3Rpb24uXG4gKlxuICogICAgIHNjaGVtYS5wYXRoKCduYW1lJykudmFsaWRhdGUoe1xuICogICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbih2KSB7IHJldHVybiB2Lmxlbmd0aCA+IDU7IH0sXG4gKiAgICAgICAvLyBgZXJyb3JzWyduYW1lJ11gIHdpbGwgYmUgXCJuYW1lIG11c3QgaGF2ZSBsZW5ndGggNSwgZ290ICdmb28nXCJcbiAqICAgICAgIG1lc3NhZ2U6IGZ1bmN0aW9uKHByb3BzKSB7XG4gKiAgICAgICAgIHJldHVybiBgJHtwcm9wcy5wYXRofSBtdXN0IGhhdmUgbGVuZ3RoIDUsIGdvdCAnJHtwcm9wcy52YWx1ZX0nYDtcbiAqICAgICAgIH1cbiAqICAgICB9KTtcbiAqXG4gKiBUbyBieXBhc3MgTW9uZ29vc2UncyBlcnJvciBtZXNzYWdlcyBhbmQganVzdCBjb3B5IHRoZSBlcnJvciBtZXNzYWdlIHRoYXRcbiAqIHRoZSB2YWxpZGF0b3IgdGhyb3dzLCBkbyB0aGlzOlxuICpcbiAqICAgICBzY2hlbWEucGF0aCgnbmFtZScpLnZhbGlkYXRlKHtcbiAqICAgICAgIHZhbGlkYXRvcjogZnVuY3Rpb24oKSB7IHRocm93IG5ldyBFcnJvcignT29wcyEnKTsgfSxcbiAqICAgICAgIC8vIGBlcnJvcnNbJ25hbWUnXS5tZXNzYWdlYCB3aWxsIGJlIFwiT29wcyFcIlxuICogICAgICAgbWVzc2FnZTogZnVuY3Rpb24ocHJvcHMpIHsgcmV0dXJuIHByb3BzLnJlYXNvbi5tZXNzYWdlOyB9XG4gKiAgICAgfSk7XG4gKlxuICogIyMjIyBBc3luY2hyb25vdXMgdmFsaWRhdGlvbjpcbiAqXG4gKiBNb25nb29zZSBzdXBwb3J0cyB2YWxpZGF0b3JzIHRoYXQgcmV0dXJuIGEgcHJvbWlzZS4gQSB2YWxpZGF0b3IgdGhhdCByZXR1cm5zXG4gKiBhIHByb21pc2UgaXMgY2FsbGVkIGFuIF9hc3luYyB2YWxpZGF0b3JfLiBBc3luYyB2YWxpZGF0b3JzIHJ1biBpblxuICogcGFyYWxsZWwsIGFuZCBgdmFsaWRhdGUoKWAgd2lsbCB3YWl0IHVudGlsIGFsbCBhc3luYyB2YWxpZGF0b3JzIGhhdmUgc2V0dGxlZC5cbiAqXG4gKiAgICAgc2NoZW1hLnBhdGgoJ25hbWUnKS52YWxpZGF0ZSh7XG4gKiAgICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICogICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICogICAgICAgICAgIHJlc29sdmUoZmFsc2UpOyAvLyB2YWxpZGF0aW9uIGZhaWxlZFxuICogICAgICAgICB9KTtcbiAqICAgICAgIH1cbiAqICAgICB9KTtcbiAqXG4gKiBZb3UgbWlnaHQgdXNlIGFzeW5jaHJvbm91cyB2YWxpZGF0b3JzIHRvIHJldHJlaXZlIG90aGVyIGRvY3VtZW50cyBmcm9tIHRoZSBkYXRhYmFzZSB0byB2YWxpZGF0ZSBhZ2FpbnN0IG9yIHRvIG1lZXQgb3RoZXIgSS9PIGJvdW5kIHZhbGlkYXRpb24gbmVlZHMuXG4gKlxuICogVmFsaWRhdGlvbiBvY2N1cnMgYHByZSgnc2F2ZScpYCBvciB3aGVuZXZlciB5b3UgbWFudWFsbHkgZXhlY3V0ZSBbZG9jdW1lbnQjdmFsaWRhdGVdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZG9jdW1lbnQuaHRtbCNEb2N1bWVudC5wcm90b3R5cGUudmFsaWRhdGUoKSkuXG4gKlxuICogSWYgdmFsaWRhdGlvbiBmYWlscyBkdXJpbmcgYHByZSgnc2F2ZScpYCBhbmQgbm8gY2FsbGJhY2sgd2FzIHBhc3NlZCB0byByZWNlaXZlIHRoZSBlcnJvciwgYW4gYGVycm9yYCBldmVudCB3aWxsIGJlIGVtaXR0ZWQgb24geW91ciBNb2RlbHMgYXNzb2NpYXRlZCBkYiBbY29ubmVjdGlvbl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9jb25uZWN0aW9uLmh0bWwjQ29ubmVjdGlvbigpKSwgcGFzc2luZyB0aGUgdmFsaWRhdGlvbiBlcnJvciBvYmplY3QgYWxvbmcuXG4gKlxuICogICAgIGNvbnN0IGNvbm4gPSBtb25nb29zZS5jcmVhdGVDb25uZWN0aW9uKC4uKTtcbiAqICAgICBjb25uLm9uKCdlcnJvcicsIGhhbmRsZUVycm9yKTtcbiAqXG4gKiAgICAgY29uc3QgUHJvZHVjdCA9IGNvbm4ubW9kZWwoJ1Byb2R1Y3QnLCB5b3VyU2NoZW1hKTtcbiAqICAgICBjb25zdCBkdmQgPSBuZXcgUHJvZHVjdCguLik7XG4gKiAgICAgZHZkLnNhdmUoKTsgLy8gZW1pdHMgZXJyb3Igb24gdGhlIGBjb25uYCBhYm92ZVxuICpcbiAqIElmIHlvdSB3YW50IHRvIGhhbmRsZSB0aGVzZSBlcnJvcnMgYXQgdGhlIE1vZGVsIGxldmVsLCBhZGQgYW4gYGVycm9yYFxuICogbGlzdGVuZXIgdG8geW91ciBNb2RlbCBhcyBzaG93biBiZWxvdy5cbiAqXG4gKiAgICAgLy8gcmVnaXN0ZXJpbmcgYW4gZXJyb3IgbGlzdGVuZXIgb24gdGhlIE1vZGVsIGxldHMgdXMgaGFuZGxlIGVycm9ycyBtb3JlIGxvY2FsbHlcbiAqICAgICBQcm9kdWN0Lm9uKCdlcnJvcicsIGhhbmRsZUVycm9yKTtcbiAqXG4gKiBAcGFyYW0ge1JlZ0V4cHxGdW5jdGlvbnxPYmplY3R9IG9iaiB2YWxpZGF0b3IgZnVuY3Rpb24sIG9yIGhhc2ggZGVzY3JpYmluZyBvcHRpb25zXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb2JqLnZhbGlkYXRvcl0gdmFsaWRhdG9yIGZ1bmN0aW9uLiBJZiB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uIHJldHVybnMgYHVuZGVmaW5lZGAgb3IgYSB0cnV0aHkgdmFsdWUsIHZhbGlkYXRpb24gc3VjY2VlZHMuIElmIGl0IHJldHVybnMgW2ZhbHN5XShodHRwczovL21hc3RlcmluZ2pzLmlvL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvZmFsc3kpIChleGNlcHQgYHVuZGVmaW5lZGApIG9yIHRocm93cyBhbiBlcnJvciwgdmFsaWRhdGlvbiBmYWlscy5cbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBbb2JqLm1lc3NhZ2VdIG9wdGlvbmFsIGVycm9yIG1lc3NhZ2UuIElmIGZ1bmN0aW9uLCBzaG91bGQgcmV0dXJuIHRoZSBlcnJvciBtZXNzYWdlIGFzIGEgc3RyaW5nXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvYmoucHJvcHNQYXJhbWV0ZXI9ZmFsc2VdIElmIHRydWUsIE1vbmdvb3NlIHdpbGwgcGFzcyB0aGUgdmFsaWRhdG9yIHByb3BlcnRpZXMgb2JqZWN0ICh3aXRoIHRoZSBgdmFsaWRhdG9yYCBmdW5jdGlvbiwgYG1lc3NhZ2VgLCBldGMuKSBhcyB0aGUgMm5kIGFyZyB0byB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uLiBUaGlzIGlzIGRpc2FibGVkIGJ5IGRlZmF1bHQgYmVjYXVzZSBtYW55IHZhbGlkYXRvcnMgW3JlbHkgb24gcG9zaXRpb25hbCBhcmdzXShodHRwczovL2dpdGh1Yi5jb20vY2hyaXNvL3ZhbGlkYXRvci5qcyN2YWxpZGF0b3JzKSwgc28gdHVybmluZyB0aGlzIG9uIG1heSBjYXVzZSB1bnByZWRpY3RhYmxlIGJlaGF2aW9yIGluIGV4dGVybmFsIHZhbGlkYXRvcnMuXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gW2Vycm9yTXNnXSBvcHRpb25hbCBlcnJvciBtZXNzYWdlLiBJZiBmdW5jdGlvbiwgc2hvdWxkIHJldHVybiB0aGUgZXJyb3IgbWVzc2FnZSBhcyBhIHN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd9IFt0eXBlXSBvcHRpb25hbCB2YWxpZGF0b3IgdHlwZVxuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uKG9iaiwgbWVzc2FnZSwgdHlwZSkge1xuICBpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJyB8fCBvYmogJiYgdXRpbHMuZ2V0RnVuY3Rpb25OYW1lKG9iai5jb25zdHJ1Y3RvcikgPT09ICdSZWdFeHAnKSB7XG4gICAgbGV0IHByb3BlcnRpZXM7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wZXJ0aWVzID0geyB2YWxpZGF0b3I6IG9iaiwgbWVzc2FnZTogbWVzc2FnZSB9O1xuICAgICAgcHJvcGVydGllcy50eXBlID0gdHlwZSB8fCAndXNlciBkZWZpbmVkJztcbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBPYmplY3QgJiYgIXR5cGUpIHtcbiAgICAgIHByb3BlcnRpZXMgPSBpc1NpbXBsZVZhbGlkYXRvcihtZXNzYWdlKSA/IE9iamVjdC5hc3NpZ24oe30sIG1lc3NhZ2UpIDogY2xvbmUobWVzc2FnZSk7XG4gICAgICBpZiAoIXByb3BlcnRpZXMubWVzc2FnZSkge1xuICAgICAgICBwcm9wZXJ0aWVzLm1lc3NhZ2UgPSBwcm9wZXJ0aWVzLm1zZztcbiAgICAgIH1cbiAgICAgIHByb3BlcnRpZXMudmFsaWRhdG9yID0gb2JqO1xuICAgICAgcHJvcGVydGllcy50eXBlID0gcHJvcGVydGllcy50eXBlIHx8ICd1c2VyIGRlZmluZWQnO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobWVzc2FnZSA9PSBudWxsKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBNb25nb29zZUVycm9yLm1lc3NhZ2VzLmdlbmVyYWwuZGVmYXVsdDtcbiAgICAgIH1cbiAgICAgIGlmICghdHlwZSkge1xuICAgICAgICB0eXBlID0gJ3VzZXIgZGVmaW5lZCc7XG4gICAgICB9XG4gICAgICBwcm9wZXJ0aWVzID0geyBtZXNzYWdlOiBtZXNzYWdlLCB0eXBlOiB0eXBlLCB2YWxpZGF0b3I6IG9iaiB9O1xuICAgIH1cblxuICAgIHRoaXMudmFsaWRhdG9ycy5wdXNoKHByb3BlcnRpZXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGV0IGk7XG4gIGxldCBsZW5ndGg7XG4gIGxldCBhcmc7XG5cbiAgZm9yIChpID0gMCwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgIGlmICghdXRpbHMuaXNQT0pPKGFyZykpIHtcbiAgICAgIGNvbnN0IG1zZyA9ICdJbnZhbGlkIHZhbGlkYXRvci4gUmVjZWl2ZWQgKCcgKyB0eXBlb2YgYXJnICsgJykgJ1xuICAgICAgICArIGFyZ1xuICAgICAgICArICcuIFNlZSBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3NjaGVtYXR5cGUuaHRtbCNTY2hlbWFUeXBlLnByb3RvdHlwZS52YWxpZGF0ZSgpJztcblxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuICAgIHRoaXMudmFsaWRhdGUoYXJnLnZhbGlkYXRvciwgYXJnKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgcmVxdWlyZWQgdmFsaWRhdG9yIHRvIHRoaXMgU2NoZW1hVHlwZS4gVGhlIHZhbGlkYXRvciBnZXRzIGFkZGVkXG4gKiB0byB0aGUgZnJvbnQgb2YgdGhpcyBTY2hlbWFUeXBlJ3MgdmFsaWRhdG9ycyBhcnJheSB1c2luZyBgdW5zaGlmdCgpYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgYm9ybjogeyB0eXBlOiBEYXRlLCByZXF1aXJlZDogdHJ1ZSB9KVxuICpcbiAqICAgICAvLyBvciB3aXRoIGN1c3RvbSBlcnJvciBtZXNzYWdlXG4gKlxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgYm9ybjogeyB0eXBlOiBEYXRlLCByZXF1aXJlZDogJ3tQQVRIfSBpcyByZXF1aXJlZCEnIH0pXG4gKlxuICogICAgIC8vIG9yIHdpdGggYSBmdW5jdGlvblxuICpcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7XG4gKiAgICAgICB1c2VySWQ6IE9iamVjdElkLFxuICogICAgICAgdXNlcm5hbWU6IHtcbiAqICAgICAgICAgdHlwZTogU3RyaW5nLFxuICogICAgICAgICByZXF1aXJlZDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnVzZXJJZCAhPSBudWxsOyB9XG4gKiAgICAgICB9XG4gKiAgICAgfSlcbiAqXG4gKiAgICAgLy8gb3Igd2l0aCBhIGZ1bmN0aW9uIGFuZCBhIGN1c3RvbSBtZXNzYWdlXG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoe1xuICogICAgICAgdXNlcklkOiBPYmplY3RJZCxcbiAqICAgICAgIHVzZXJuYW1lOiB7XG4gKiAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAqICAgICAgICAgcmVxdWlyZWQ6IFtcbiAqICAgICAgICAgICBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudXNlcklkICE9IG51bGw7IH0sXG4gKiAgICAgICAgICAgJ3VzZXJuYW1lIGlzIHJlcXVpcmVkIGlmIGlkIGlzIHNwZWNpZmllZCdcbiAqICAgICAgICAgXVxuICogICAgICAgfVxuICogICAgIH0pXG4gKlxuICogICAgIC8vIG9yIHRocm91Z2ggdGhlIHBhdGggQVBJXG4gKlxuICogICAgIHMucGF0aCgnbmFtZScpLnJlcXVpcmVkKHRydWUpO1xuICpcbiAqICAgICAvLyB3aXRoIGN1c3RvbSBlcnJvciBtZXNzYWdpbmdcbiAqXG4gKiAgICAgcy5wYXRoKCduYW1lJykucmVxdWlyZWQodHJ1ZSwgJ2dycnIgOiggJyk7XG4gKlxuICogICAgIC8vIG9yIG1ha2UgYSBwYXRoIGNvbmRpdGlvbmFsbHkgcmVxdWlyZWQgYmFzZWQgb24gYSBmdW5jdGlvblxuICogICAgIGNvbnN0IGlzT3ZlcjE4ID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmFnZSA+PSAxODsgfTtcbiAqICAgICBzLnBhdGgoJ3ZvdGVyUmVnaXN0cmF0aW9uSWQnKS5yZXF1aXJlZChpc092ZXIxOCk7XG4gKlxuICogVGhlIHJlcXVpcmVkIHZhbGlkYXRvciB1c2VzIHRoZSBTY2hlbWFUeXBlJ3MgYGNoZWNrUmVxdWlyZWRgIGZ1bmN0aW9uIHRvXG4gKiBkZXRlcm1pbmUgd2hldGhlciBhIGdpdmVuIHZhbHVlIHNhdGlzZmllcyB0aGUgcmVxdWlyZWQgdmFsaWRhdG9yLiBCeSBkZWZhdWx0LFxuICogYSB2YWx1ZSBzYXRpc2ZpZXMgdGhlIHJlcXVpcmVkIHZhbGlkYXRvciBpZiBgdmFsICE9IG51bGxgICh0aGF0IGlzLCBpZlxuICogdGhlIHZhbHVlIGlzIG5vdCBudWxsIG5vciB1bmRlZmluZWQpLiBIb3dldmVyLCBtb3N0IGJ1aWx0LWluIG1vbmdvb3NlIHNjaGVtYVxuICogdHlwZXMgb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYGNoZWNrUmVxdWlyZWRgIGZ1bmN0aW9uOlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbnxPYmplY3R9IHJlcXVpcmVkIGVuYWJsZS9kaXNhYmxlIHRoZSB2YWxpZGF0b3IsIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyByZXF1aXJlZCBib29sZWFuLCBvciBvcHRpb25zIG9iamVjdFxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSBbb3B0aW9ucy5pc1JlcXVpcmVkXSBlbmFibGUvZGlzYWJsZSB0aGUgdmFsaWRhdG9yLCBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgcmVxdWlyZWQgYm9vbGVhblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuRXJyb3JDb25zdHJ1Y3Rvcl0gY3VzdG9tIGVycm9yIGNvbnN0cnVjdG9yLiBUaGUgY29uc3RydWN0b3IgcmVjZWl2ZXMgMSBwYXJhbWV0ZXIsIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSB2YWxpZGF0b3IgcHJvcGVydGllcy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWVzc2FnZV0gb3B0aW9uYWwgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IHRoaXNcbiAqIEBzZWUgQ3VzdG9taXplZCBFcnJvciBNZXNzYWdlcyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2Vycm9yLmh0bWwjRXJyb3IubWVzc2FnZXNcbiAqIEBzZWUgU2NoZW1hQXJyYXkjY2hlY2tSZXF1aXJlZCBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3NjaGVtYWFycmF5Lmh0bWwjU2NoZW1hQXJyYXkucHJvdG90eXBlLmNoZWNrUmVxdWlyZWQoKVxuICogQHNlZSBTY2hlbWFCb29sZWFuI2NoZWNrUmVxdWlyZWQgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9zY2hlbWFib29sZWFuLmh0bWwjU2NoZW1hQm9vbGVhbi5wcm90b3R5cGUuY2hlY2tSZXF1aXJlZCgpXG4gKiBAc2VlIFNjaGVtYUJ1ZmZlciNjaGVja1JlcXVpcmVkIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvc2NoZW1hYnVmZmVyLmh0bWwjU2NoZW1hQnVmZmVyLnByb3RvdHlwZS5jaGVja1JlcXVpcmVkKClcbiAqIEBzZWUgU2NoZW1hTnVtYmVyI2NoZWNrUmVxdWlyZWQgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9zY2hlbWFudW1iZXIuaHRtbCNTY2hlbWFOdW1iZXIucHJvdG90eXBlLmNoZWNrUmVxdWlyZWQoKVxuICogQHNlZSBTY2hlbWFPYmplY3RJZCNjaGVja1JlcXVpcmVkIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvc2NoZW1hb2JqZWN0aWQuaHRtbCNPYmplY3RJZC5wcm90b3R5cGUuY2hlY2tSZXF1aXJlZCgpXG4gKiBAc2VlIFNjaGVtYVN0cmluZyNjaGVja1JlcXVpcmVkIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvc2NoZW1hc3RyaW5nLmh0bWwjU2NoZW1hU3RyaW5nLnByb3RvdHlwZS5jaGVja1JlcXVpcmVkKClcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUucmVxdWlyZWQgPSBmdW5jdGlvbihyZXF1aXJlZCwgbWVzc2FnZSkge1xuICBsZXQgY3VzdG9tT3B0aW9ucyA9IHt9O1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCAmJiByZXF1aXJlZCA9PSBudWxsKSB7XG4gICAgdGhpcy52YWxpZGF0b3JzID0gdGhpcy52YWxpZGF0b3JzLmZpbHRlcihmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gdi52YWxpZGF0b3IgIT09IHRoaXMucmVxdWlyZWRWYWxpZGF0b3I7XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLmlzUmVxdWlyZWQgPSBmYWxzZTtcbiAgICBkZWxldGUgdGhpcy5vcmlnaW5hbFJlcXVpcmVkVmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZiAodHlwZW9mIHJlcXVpcmVkID09PSAnb2JqZWN0Jykge1xuICAgIGN1c3RvbU9wdGlvbnMgPSByZXF1aXJlZDtcbiAgICBtZXNzYWdlID0gY3VzdG9tT3B0aW9ucy5tZXNzYWdlIHx8IG1lc3NhZ2U7XG4gICAgcmVxdWlyZWQgPSByZXF1aXJlZC5pc1JlcXVpcmVkO1xuICB9XG5cbiAgaWYgKHJlcXVpcmVkID09PSBmYWxzZSkge1xuICAgIHRoaXMudmFsaWRhdG9ycyA9IHRoaXMudmFsaWRhdG9ycy5maWx0ZXIoZnVuY3Rpb24odikge1xuICAgICAgcmV0dXJuIHYudmFsaWRhdG9yICE9PSB0aGlzLnJlcXVpcmVkVmFsaWRhdG9yO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5pc1JlcXVpcmVkID0gZmFsc2U7XG4gICAgZGVsZXRlIHRoaXMub3JpZ2luYWxSZXF1aXJlZFZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICB0aGlzLmlzUmVxdWlyZWQgPSB0cnVlO1xuXG4gIHRoaXMucmVxdWlyZWRWYWxpZGF0b3IgPSBmdW5jdGlvbih2KSB7XG4gICAgY29uc3QgY2FjaGVkUmVxdWlyZWQgPSB0aGlzICYmIHRoaXMuJF9fICYmIHRoaXMuJF9fLmNhY2hlZFJlcXVpcmVkO1xuXG4gICAgLy8gbm8gdmFsaWRhdGlvbiB3aGVuIHRoaXMgcGF0aCB3YXNuJ3Qgc2VsZWN0ZWQgaW4gdGhlIHF1ZXJ5LlxuICAgIGlmIChjYWNoZWRSZXF1aXJlZCAhPSBudWxsICYmICF0aGlzLiRfX2lzU2VsZWN0ZWQoX3RoaXMucGF0aCkgJiYgIXRoaXNbZG9jdW1lbnRJc01vZGlmaWVkXShfdGhpcy5wYXRoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gYCRjYWNoZWRSZXF1aXJlZGAgZ2V0cyBzZXQgaW4gYF9ldmFsdWF0ZVJlcXVpcmVkRnVuY3Rpb25zKClgIHNvIHdlXG4gICAgLy8gZG9uJ3QgY2FsbCByZXF1aXJlZCBmdW5jdGlvbnMgbXVsdGlwbGUgdGltZXMgaW4gb25lIHZhbGlkYXRlIGNhbGxcbiAgICAvLyBTZWUgZ2gtNjgwMVxuICAgIGlmIChjYWNoZWRSZXF1aXJlZCAhPSBudWxsICYmIF90aGlzLnBhdGggaW4gY2FjaGVkUmVxdWlyZWQpIHtcbiAgICAgIGNvbnN0IHJlcyA9IGNhY2hlZFJlcXVpcmVkW190aGlzLnBhdGhdID9cbiAgICAgICAgX3RoaXMuY2hlY2tSZXF1aXJlZCh2LCB0aGlzKSA6XG4gICAgICAgIHRydWU7XG4gICAgICBkZWxldGUgY2FjaGVkUmVxdWlyZWRbX3RoaXMucGF0aF07XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlcXVpcmVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gcmVxdWlyZWQuYXBwbHkodGhpcykgPyBfdGhpcy5jaGVja1JlcXVpcmVkKHYsIHRoaXMpIDogdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXMuY2hlY2tSZXF1aXJlZCh2LCB0aGlzKTtcbiAgfTtcbiAgdGhpcy5vcmlnaW5hbFJlcXVpcmVkVmFsdWUgPSByZXF1aXJlZDtcblxuICBpZiAodHlwZW9mIHJlcXVpcmVkID09PSAnc3RyaW5nJykge1xuICAgIG1lc3NhZ2UgPSByZXF1aXJlZDtcbiAgICByZXF1aXJlZCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IG1zZyA9IG1lc3NhZ2UgfHwgTW9uZ29vc2VFcnJvci5tZXNzYWdlcy5nZW5lcmFsLnJlcXVpcmVkO1xuICB0aGlzLnZhbGlkYXRvcnMudW5zaGlmdChPYmplY3QuYXNzaWduKHt9LCBjdXN0b21PcHRpb25zLCB7XG4gICAgdmFsaWRhdG9yOiB0aGlzLnJlcXVpcmVkVmFsaWRhdG9yLFxuICAgIG1lc3NhZ2U6IG1zZyxcbiAgICB0eXBlOiAncmVxdWlyZWQnXG4gIH0pKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtb2RlbCB0aGF0IHRoaXMgcGF0aCByZWZlcnMgdG8uIFRoaXMgaXMgdGhlIG9wdGlvbiB0aGF0IFtwb3B1bGF0ZV0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL3BvcHVsYXRlLmh0bWwpXG4gKiBsb29rcyBhdCB0byBkZXRlcm1pbmUgdGhlIGZvcmVpZ24gY29sbGVjdGlvbiBpdCBzaG91bGQgcXVlcnkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCB1c2VyU2NoZW1hID0gbmV3IFNjaGVtYSh7IG5hbWU6IFN0cmluZyB9KTtcbiAqICAgICBjb25zdCBVc2VyID0gbW9uZ29vc2UubW9kZWwoJ1VzZXInLCB1c2VyU2NoZW1hKTtcbiAqXG4gKiAgICAgY29uc3QgcG9zdFNjaGVtYSA9IG5ldyBTY2hlbWEoeyB1c2VyOiBtb25nb29zZS5PYmplY3RJZCB9KTtcbiAqICAgICBwb3N0U2NoZW1hLnBhdGgoJ3VzZXInKS5yZWYoJ1VzZXInKTsgLy8gQ2FuIHNldCByZWYgdG8gYSBtb2RlbCBuYW1lXG4gKiAgICAgcG9zdFNjaGVtYS5wYXRoKCd1c2VyJykucmVmKFVzZXIpOyAvLyBPciBhIG1vZGVsIGNsYXNzXG4gKiAgICAgcG9zdFNjaGVtYS5wYXRoKCd1c2VyJykucmVmKCgpID0+ICdVc2VyJyk7IC8vIE9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBtb2RlbCBuYW1lXG4gKiAgICAgcG9zdFNjaGVtYS5wYXRoKCd1c2VyJykucmVmKCgpID0+IFVzZXIpOyAvLyBPciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbW9kZWwgY2xhc3NcbiAqXG4gKiAgICAgLy8gT3IgeW91IGNhbiBqdXN0IGRlY2xhcmUgdGhlIGByZWZgIGlubGluZSBpbiB5b3VyIHNjaGVtYVxuICogICAgIGNvbnN0IHBvc3RTY2hlbWEyID0gbmV3IFNjaGVtYSh7XG4gKiAgICAgICB1c2VyOiB7IHR5cGU6IG1vbmdvb3NlLk9iamVjdElkLCByZWY6IFVzZXIgfVxuICogICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE1vZGVsfEZ1bmN0aW9ufSByZWYgZWl0aGVyIGEgbW9kZWwgbmFtZSwgYSBbTW9kZWxdKGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9tb2RlbHMuaHRtbCksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgbW9kZWwgbmFtZSBvciBtb2RlbC5cbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24ocmVmKSB7XG4gIHRoaXMub3B0aW9ucy5yZWYgPSByZWY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkZWZhdWx0IHZhbHVlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHNjb3BlIHRoZSBzY29wZSB3aGljaCBjYWxsYmFjayBhcmUgZXhlY3V0ZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5pdFxuICogQHJldHVybiB7QW55fSBUaGUgU3RvcmVkIGRlZmF1bHQgdmFsdWUuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5nZXREZWZhdWx0ID0gZnVuY3Rpb24oc2NvcGUsIGluaXQsIG9wdGlvbnMpIHtcbiAgbGV0IHJldDtcbiAgaWYgKHR5cGVvZiB0aGlzLmRlZmF1bHRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChcbiAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID09PSBEYXRlLm5vdyB8fFxuICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPT09IEFycmF5IHx8XG4gICAgICB0aGlzLmRlZmF1bHRWYWx1ZS5uYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvYmplY3RpZCdcbiAgICApIHtcbiAgICAgIHJldCA9IHRoaXMuZGVmYXVsdFZhbHVlLmNhbGwoc2NvcGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXQgPSB0aGlzLmRlZmF1bHRWYWx1ZS5jYWxsKHNjb3BlLCBzY29wZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldCA9IHRoaXMuZGVmYXVsdFZhbHVlO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCAmJiByZXQgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgcmV0ID09PSAnb2JqZWN0JyAmJiAoIXRoaXMub3B0aW9ucyB8fCAhdGhpcy5vcHRpb25zLnNoYXJlZCkpIHtcbiAgICAgIHJldCA9IGNsb25lKHJldCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5za2lwQ2FzdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5U2V0dGVycyhyZXQsIHNjb3BlKTtcbiAgICB9XG5cbiAgICBjb25zdCBjYXN0ZWQgPSB0aGlzLmFwcGx5U2V0dGVycyhyZXQsIHNjb3BlLCBpbml0LCB1bmRlZmluZWQsIHNldE9wdGlvbnNGb3JEZWZhdWx0cyk7XG4gICAgaWYgKGNhc3RlZCAmJiAhQXJyYXkuaXNBcnJheShjYXN0ZWQpICYmIGNhc3RlZC4kaXNTaW5nbGVOZXN0ZWQpIHtcbiAgICAgIGNhc3RlZC4kX19wYXJlbnQgPSBzY29wZTtcbiAgICB9XG4gICAgcmV0dXJuIGNhc3RlZDtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBBcHBsaWVzIHNldHRlcnMgd2l0aG91dCBjYXN0aW5nXG4gKlxuICogQHBhcmFtIHtBbnl9IHZhbHVlXG4gKiBAcGFyYW0ge0FueX0gc2NvcGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5pdFxuICogQHBhcmFtIHtBbnl9IHByaW9yVmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLl9hcHBseVNldHRlcnMgPSBmdW5jdGlvbih2YWx1ZSwgc2NvcGUsIGluaXQsIHByaW9yVmFsLCBvcHRpb25zKSB7XG4gIGxldCB2ID0gdmFsdWU7XG4gIGlmIChpbml0KSB7XG4gICAgcmV0dXJuIHY7XG4gIH1cbiAgY29uc3Qgc2V0dGVycyA9IHRoaXMuc2V0dGVycztcblxuICBmb3IgKGxldCBpID0gc2V0dGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHYgPSBzZXR0ZXJzW2ldLmNhbGwoc2NvcGUsIHYsIHByaW9yVmFsLCB0aGlzLCBvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiB2O1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5fY2FzdE51bGxpc2ggPSBmdW5jdGlvbiBfY2FzdE51bGxpc2godikge1xuICByZXR1cm4gdjtcbn07XG5cbi8qKlxuICogQXBwbGllcyBzZXR0ZXJzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gc2NvcGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5pdFxuICogQHJldHVybiB7QW55fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUuYXBwbHlTZXR0ZXJzID0gZnVuY3Rpb24odmFsdWUsIHNjb3BlLCBpbml0LCBwcmlvclZhbCwgb3B0aW9ucykge1xuICBsZXQgdiA9IHRoaXMuX2FwcGx5U2V0dGVycyh2YWx1ZSwgc2NvcGUsIGluaXQsIHByaW9yVmFsLCBvcHRpb25zKTtcbiAgaWYgKHYgPT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLl9jYXN0TnVsbGlzaCh2KTtcbiAgfVxuICAvLyBkbyBub3QgY2FzdCB1bnRpbCBhbGwgc2V0dGVycyBhcmUgYXBwbGllZCAjNjY1XG4gIHYgPSB0aGlzLmNhc3Qodiwgc2NvcGUsIGluaXQsIHByaW9yVmFsLCBvcHRpb25zKTtcblxuICByZXR1cm4gdjtcbn07XG5cbi8qKlxuICogQXBwbGllcyBnZXR0ZXJzIHRvIGEgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZVxuICogQHJldHVybiB7QW55fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUuYXBwbHlHZXR0ZXJzID0gZnVuY3Rpb24odmFsdWUsIHNjb3BlKSB7XG4gIGxldCB2ID0gdmFsdWU7XG4gIGNvbnN0IGdldHRlcnMgPSB0aGlzLmdldHRlcnM7XG4gIGNvbnN0IGxlbiA9IGdldHRlcnMubGVuZ3RoO1xuXG4gIGlmIChsZW4gPT09IDApIHtcbiAgICByZXR1cm4gdjtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2ID0gZ2V0dGVyc1tpXS5jYWxsKHNjb3BlLCB2LCB0aGlzKTtcbiAgfVxuXG4gIHJldHVybiB2O1xufTtcblxuLyoqXG4gKiBTZXRzIGRlZmF1bHQgYHNlbGVjdCgpYCBiZWhhdmlvciBmb3IgdGhpcyBwYXRoLlxuICpcbiAqIFNldCB0byBgdHJ1ZWAgaWYgdGhpcyBwYXRoIHNob3VsZCBhbHdheXMgYmUgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdHMsIGBmYWxzZWAgaWYgaXQgc2hvdWxkIGJlIGV4Y2x1ZGVkIGJ5IGRlZmF1bHQuIFRoaXMgc2V0dGluZyBjYW4gYmUgb3ZlcnJpZGRlbiBhdCB0aGUgcXVlcnkgbGV2ZWwuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBUID0gZGIubW9kZWwoJ1QnLCBuZXcgU2NoZW1hKHsgeDogeyB0eXBlOiBTdHJpbmcsIHNlbGVjdDogdHJ1ZSB9fSkpO1xuICogICAgIFQuZmluZCguLik7IC8vIGZpZWxkIHggd2lsbCBhbHdheXMgYmUgc2VsZWN0ZWQgLi5cbiAqICAgICAvLyAuLiB1bmxlc3Mgb3ZlcnJpZGRlbjtcbiAqICAgICBULmZpbmQoKS5zZWxlY3QoJy14JykuZXhlYyhjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtCb29sZWFufSB2YWxcbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gc2VsZWN0KHZhbCkge1xuICB0aGlzLnNlbGVjdGVkID0gISF2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIHZhbGlkYXRpb24gb2YgYHZhbHVlYCB1c2luZyB0aGUgdmFsaWRhdG9ycyBkZWNsYXJlZCBmb3IgdGhpcyBTY2hlbWFUeXBlLlxuICpcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBhdGhdXG4gKiBAcmV0dXJuIHtBbnl9IElmIG5vIHZhbGlkYXRvcnMsIHJldHVybnMgdGhlIG91dHB1dCBmcm9tIGNhbGxpbmcgYGZuYCwgb3RoZXJ3aXNlIG5vIHJldHVyblxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5kb1ZhbGlkYXRlID0gZnVuY3Rpb24odmFsdWUsIGZuLCBzY29wZSwgb3B0aW9ucykge1xuICBsZXQgZXJyID0gZmFsc2U7XG4gIGNvbnN0IHBhdGggPSB0aGlzLnBhdGg7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBNdXN0IHBhc3MgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZG9WYWxpZGF0ZSgpLCBnb3QgJHt0eXBlb2YgZm59YCk7XG4gIH1cblxuICAvLyBBdm9pZCBub24tb2JqZWN0IGB2YWxpZGF0b3JzYFxuICBjb25zdCB2YWxpZGF0b3JzID0gdGhpcy52YWxpZGF0b3JzLlxuICAgIGZpbHRlcih2ID0+IHR5cGVvZiB2ID09PSAnb2JqZWN0JyAmJiB2ICE9PSBudWxsKTtcblxuICBsZXQgY291bnQgPSB2YWxpZGF0b3JzLmxlbmd0aDtcblxuICBpZiAoIWNvdW50KSB7XG4gICAgcmV0dXJuIGZuKG51bGwpO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHZhbGlkYXRvcnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjb25zdCB2ID0gdmFsaWRhdG9yc1tpXTtcbiAgICBjb25zdCB2YWxpZGF0b3IgPSB2LnZhbGlkYXRvcjtcbiAgICBsZXQgb2s7XG5cbiAgICBjb25zdCB2YWxpZGF0b3JQcm9wZXJ0aWVzID0gaXNTaW1wbGVWYWxpZGF0b3IodikgPyBPYmplY3QuYXNzaWduKHt9LCB2KSA6IGNsb25lKHYpO1xuICAgIHZhbGlkYXRvclByb3BlcnRpZXMucGF0aCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5wYXRoID8gb3B0aW9ucy5wYXRoIDogcGF0aDtcbiAgICB2YWxpZGF0b3JQcm9wZXJ0aWVzLmZ1bGxQYXRoID0gdGhpcy4kZnVsbFBhdGg7XG4gICAgdmFsaWRhdG9yUHJvcGVydGllcy52YWx1ZSA9IHZhbHVlO1xuXG4gICAgaWYgKHZhbGlkYXRvciBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgdmFsaWRhdGUodmFsaWRhdG9yLnRlc3QodmFsdWUpLCB2YWxpZGF0b3JQcm9wZXJ0aWVzLCBzY29wZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbGlkYXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgdmFsaWRhdG9yICE9PSB0aGlzLnJlcXVpcmVkVmFsaWRhdG9yKSB7XG4gICAgICB2YWxpZGF0ZSh0cnVlLCB2YWxpZGF0b3JQcm9wZXJ0aWVzLCBzY29wZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaWYgKHZhbGlkYXRvclByb3BlcnRpZXMucHJvcHNQYXJhbWV0ZXIpIHtcbiAgICAgICAgb2sgPSB2YWxpZGF0b3IuY2FsbChzY29wZSwgdmFsdWUsIHZhbGlkYXRvclByb3BlcnRpZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2sgPSB2YWxpZGF0b3IuY2FsbChzY29wZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBvayA9IGZhbHNlO1xuICAgICAgdmFsaWRhdG9yUHJvcGVydGllcy5yZWFzb24gPSBlcnJvcjtcbiAgICAgIGlmIChlcnJvci5tZXNzYWdlKSB7XG4gICAgICAgIHZhbGlkYXRvclByb3BlcnRpZXMubWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9rICE9IG51bGwgJiYgdHlwZW9mIG9rLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9rLnRoZW4oXG4gICAgICAgIGZ1bmN0aW9uKG9rKSB7IHZhbGlkYXRlKG9rLCB2YWxpZGF0b3JQcm9wZXJ0aWVzLCBzY29wZSk7IH0sXG4gICAgICAgIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgdmFsaWRhdG9yUHJvcGVydGllcy5yZWFzb24gPSBlcnJvcjtcbiAgICAgICAgICB2YWxpZGF0b3JQcm9wZXJ0aWVzLm1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgICAgIG9rID0gZmFsc2U7XG4gICAgICAgICAgdmFsaWRhdGUob2ssIHZhbGlkYXRvclByb3BlcnRpZXMsIHNjb3BlKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlKG9rLCB2YWxpZGF0b3JQcm9wZXJ0aWVzLCBzY29wZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGUob2ssIHZhbGlkYXRvclByb3BlcnRpZXMsIHNjb3BlKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob2sgPT09IHVuZGVmaW5lZCB8fCBvaykge1xuICAgICAgaWYgKC0tY291bnQgPD0gMCkge1xuICAgICAgICBpbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZm4obnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBFcnJvckNvbnN0cnVjdG9yID0gdmFsaWRhdG9yUHJvcGVydGllcy5FcnJvckNvbnN0cnVjdG9yIHx8IFZhbGlkYXRvckVycm9yO1xuICAgICAgZXJyID0gbmV3IEVycm9yQ29uc3RydWN0b3IodmFsaWRhdG9yUHJvcGVydGllcywgc2NvcGUpO1xuICAgICAgZXJyW3ZhbGlkYXRvckVycm9yU3ltYm9sXSA9IHRydWU7XG4gICAgICBpbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZuKGVycik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07XG5cblxuZnVuY3Rpb24gX3ZhbGlkYXRlKG9rLCB2YWxpZGF0b3JQcm9wZXJ0aWVzKSB7XG4gIGlmIChvayAhPT0gdW5kZWZpbmVkICYmICFvaykge1xuICAgIGNvbnN0IEVycm9yQ29uc3RydWN0b3IgPSB2YWxpZGF0b3JQcm9wZXJ0aWVzLkVycm9yQ29uc3RydWN0b3IgfHwgVmFsaWRhdG9yRXJyb3I7XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yQ29uc3RydWN0b3IodmFsaWRhdG9yUHJvcGVydGllcyk7XG4gICAgZXJyW3ZhbGlkYXRvckVycm9yU3ltYm9sXSA9IHRydWU7XG4gICAgcmV0dXJuIGVycjtcbiAgfVxufVxuXG4vKipcbiAqIFBlcmZvcm1zIGEgdmFsaWRhdGlvbiBvZiBgdmFsdWVgIHVzaW5nIHRoZSB2YWxpZGF0b3JzIGRlY2xhcmVkIGZvciB0aGlzIFNjaGVtYVR5cGUuXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIFRoaXMgbWV0aG9kIGlnbm9yZXMgdGhlIGFzeW5jaHJvbm91cyB2YWxpZGF0b3JzLlxuICpcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IHNjb3BlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucGF0aF1cbiAqIEByZXR1cm4ge01vbmdvb3NlRXJyb3J8bnVsbH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYVR5cGUucHJvdG90eXBlLmRvVmFsaWRhdGVTeW5jID0gZnVuY3Rpb24odmFsdWUsIHNjb3BlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHBhdGggPSB0aGlzLnBhdGg7XG4gIGNvbnN0IGNvdW50ID0gdGhpcy52YWxpZGF0b3JzLmxlbmd0aDtcblxuICBpZiAoIWNvdW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBsZXQgdmFsaWRhdG9ycyA9IHRoaXMudmFsaWRhdG9ycztcbiAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICBpZiAodGhpcy52YWxpZGF0b3JzLmxlbmd0aCAhPT0gMCAmJiB0aGlzLnZhbGlkYXRvcnNbMF0udHlwZSA9PT0gJ3JlcXVpcmVkJykge1xuICAgICAgdmFsaWRhdG9ycyA9IFt0aGlzLnZhbGlkYXRvcnNbMF1dO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBsZXQgZXJyID0gbnVsbDtcbiAgbGV0IGkgPSAwO1xuICBjb25zdCBsZW4gPSB2YWxpZGF0b3JzLmxlbmd0aDtcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgY29uc3QgdiA9IHZhbGlkYXRvcnNbaV07XG5cbiAgICBpZiAodiA9PT0gbnVsbCB8fCB0eXBlb2YgdiAhPT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbGlkYXRvciA9IHYudmFsaWRhdG9yO1xuICAgIGNvbnN0IHZhbGlkYXRvclByb3BlcnRpZXMgPSBpc1NpbXBsZVZhbGlkYXRvcih2KSA/IE9iamVjdC5hc3NpZ24oe30sIHYpIDogY2xvbmUodik7XG4gICAgdmFsaWRhdG9yUHJvcGVydGllcy5wYXRoID0gb3B0aW9ucyAmJiBvcHRpb25zLnBhdGggPyBvcHRpb25zLnBhdGggOiBwYXRoO1xuICAgIHZhbGlkYXRvclByb3BlcnRpZXMuZnVsbFBhdGggPSB0aGlzLiRmdWxsUGF0aDtcbiAgICB2YWxpZGF0b3JQcm9wZXJ0aWVzLnZhbHVlID0gdmFsdWU7XG4gICAgbGV0IG9rID0gZmFsc2U7XG5cbiAgICAvLyBTa2lwIGFueSBleHBsaWNpdCBhc3luYyB2YWxpZGF0b3JzLiBWYWxpZGF0b3JzIHRoYXQgcmV0dXJuIGEgcHJvbWlzZVxuICAgIC8vIHdpbGwgc3RpbGwgcnVuLCBidXQgd29uJ3QgdHJpZ2dlciBhbnkgZXJyb3JzLlxuICAgIGlmIChpc0FzeW5jRnVuY3Rpb24odmFsaWRhdG9yKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHZhbGlkYXRvciBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgZXJyID0gX3ZhbGlkYXRlKHZhbGlkYXRvci50ZXN0KHZhbHVlKSwgdmFsaWRhdG9yUHJvcGVydGllcyk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbGlkYXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh2YWxpZGF0b3JQcm9wZXJ0aWVzLnByb3BzUGFyYW1ldGVyKSB7XG4gICAgICAgIG9rID0gdmFsaWRhdG9yLmNhbGwoc2NvcGUsIHZhbHVlLCB2YWxpZGF0b3JQcm9wZXJ0aWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9rID0gdmFsaWRhdG9yLmNhbGwoc2NvcGUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgb2sgPSBmYWxzZTtcbiAgICAgIHZhbGlkYXRvclByb3BlcnRpZXMucmVhc29uID0gZXJyb3I7XG4gICAgfVxuXG4gICAgLy8gU2tpcCBhbnkgdmFsaWRhdG9ycyB0aGF0IHJldHVybiBhIHByb21pc2UsIHdlIGNhbid0IGhhbmRsZSB0aG9zZVxuICAgIC8vIHN5bmNocm9ub3VzbHlcbiAgICBpZiAob2sgIT0gbnVsbCAmJiB0eXBlb2Ygb2sudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGVyciA9IF92YWxpZGF0ZShvaywgdmFsaWRhdG9yUHJvcGVydGllcyk7XG4gICAgaWYgKGVycikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVycjtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB2YWx1ZSBpcyBhIHZhbGlkIFJlZmVyZW5jZS5cbiAqXG4gKiBAcGFyYW0ge1NjaGVtYVR5cGV9IHNlbGZcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluaXRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFUeXBlLl9pc1JlZiA9IGZ1bmN0aW9uKHNlbGYsIHZhbHVlLCBkb2MsIGluaXQpIHtcbiAgLy8gZmFzdCBwYXRoXG4gIGxldCByZWYgPSBpbml0ICYmIHNlbGYub3B0aW9ucyAmJiAoc2VsZi5vcHRpb25zLnJlZiB8fCBzZWxmLm9wdGlvbnMucmVmUGF0aCk7XG5cbiAgaWYgKCFyZWYgJiYgZG9jICYmIGRvYy4kX18gIT0gbnVsbCkge1xuICAgIC8vIGNoZWNrcyBmb3JcbiAgICAvLyAtIHRoaXMgcG9wdWxhdGVkIHdpdGggYWRob2MgbW9kZWwgYW5kIG5vIHJlZiB3YXMgc2V0IGluIHNjaGVtYSBPUlxuICAgIC8vIC0gc2V0dGluZyAvIHB1c2hpbmcgdmFsdWVzIGFmdGVyIHBvcHVsYXRpb25cbiAgICBjb25zdCBwYXRoID0gZG9jLiRfX2Z1bGxQYXRoKHNlbGYucGF0aCwgdHJ1ZSk7XG5cbiAgICBjb25zdCBvd25lciA9IGRvYy5vd25lckRvY3VtZW50KCk7XG4gICAgcmVmID0gKHBhdGggIT0gbnVsbCAmJiBvd25lci4kcG9wdWxhdGVkKHBhdGgpKSB8fCBkb2MuJHBvcHVsYXRlZChzZWxmLnBhdGgpO1xuICB9XG5cbiAgaWYgKHJlZikge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodmFsdWUpICYmIC8vIGJ1ZmZlcnMgYXJlIG9iamVjdHMgdG9vXG4gICAgICB2YWx1ZS5fYnNvbnR5cGUgIT09ICdCaW5hcnknIC8vIHJhdyBiaW5hcnkgdmFsdWUgZnJvbSB0aGUgZGJcbiAgICAgICYmIHV0aWxzLmlzT2JqZWN0KHZhbHVlKSAvLyBtaWdodCBoYXZlIGRlc2VsZWN0ZWQgX2lkIGluIHBvcHVsYXRpb24gcXVlcnlcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBpbml0O1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5fY2FzdFJlZiA9IGZ1bmN0aW9uIF9jYXN0UmVmKHZhbHVlLCBkb2MsIGluaXQpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAodmFsdWUuJF9fICE9IG51bGwpIHtcbiAgICB2YWx1ZS4kX18ud2FzUG9wdWxhdGVkID0gdmFsdWUuJF9fLndhc1BvcHVsYXRlZCB8fCB7IHZhbHVlOiB2YWx1ZS5faWQgfTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvLyBzZXR0aW5nIGEgcG9wdWxhdGVkIHBhdGhcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkgfHwgIXV0aWxzLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgIGlmIChpbml0KSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHRocm93IG5ldyBDYXN0RXJyb3IodGhpcy5pbnN0YW5jZSwgdmFsdWUsIHRoaXMucGF0aCwgbnVsbCwgdGhpcyk7XG4gIH1cblxuICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdXNlciBkaXJlY3RseSBzZXRzIGEgcG9wdWxhdGVkXG4gIC8vIHBhdGggdG8gYSBwbGFpbiBvYmplY3Q7IGNhc3QgdG8gdGhlIE1vZGVsIHVzZWQgaW5cbiAgLy8gdGhlIHBvcHVsYXRpb24gcXVlcnkuXG4gIGNvbnN0IHBhdGggPSBkb2MuJF9fZnVsbFBhdGgodGhpcy5wYXRoLCB0cnVlKTtcbiAgY29uc3Qgb3duZXIgPSBkb2Mub3duZXJEb2N1bWVudCgpO1xuICBjb25zdCBwb3AgPSBvd25lci4kcG9wdWxhdGVkKHBhdGgsIHRydWUpO1xuXG4gIGxldCByZXQgPSB2YWx1ZTtcbiAgaWYgKCFkb2MuJF9fLnBvcHVsYXRlZCB8fFxuICAgICFkb2MuJF9fLnBvcHVsYXRlZFtwYXRoXSB8fFxuICAgICFkb2MuJF9fLnBvcHVsYXRlZFtwYXRoXS5vcHRpb25zIHx8XG4gICAgIWRvYy4kX18ucG9wdWxhdGVkW3BhdGhdLm9wdGlvbnMub3B0aW9ucyB8fFxuICAgICFkb2MuJF9fLnBvcHVsYXRlZFtwYXRoXS5vcHRpb25zLm9wdGlvbnMubGVhbikge1xuICAgIHJldCA9IG5ldyBwb3Aub3B0aW9uc1twb3B1bGF0ZU1vZGVsU3ltYm9sXSh2YWx1ZSk7XG4gICAgcmV0LiRfXy53YXNQb3B1bGF0ZWQgPSB7IHZhbHVlOiByZXQuX2lkIH07XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBoYW5kbGVTaW5nbGUodmFsLCBjb250ZXh0KSB7XG4gIHJldHVybiB0aGlzLmNhc3RGb3JRdWVyeShudWxsLCB2YWwsIGNvbnRleHQpO1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGhhbmRsZUFycmF5KHZhbCwgY29udGV4dCkge1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuIFt0aGlzLmNhc3RGb3JRdWVyeShudWxsLCB2YWwsIGNvbnRleHQpXTtcbiAgfVxuICByZXR1cm4gdmFsLm1hcChmdW5jdGlvbihtKSB7XG4gICAgcmV0dXJuIF90aGlzLmNhc3RGb3JRdWVyeShudWxsLCBtLCBjb250ZXh0KTtcbiAgfSk7XG59XG5cbi8qKlxuICogSnVzdCBsaWtlIGhhbmRsZUFycmF5LCBleGNlcHQgYWxzbyBhbGxvd3MgYFtdYCBiZWNhdXNlIHN1cnByaXNpbmdseVxuICogYCRpbjogWzEsIFtdXWAgd29ya3MgZmluZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaGFuZGxlJGluKHZhbCwgY29udGV4dCkge1xuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuIFt0aGlzLmNhc3RGb3JRdWVyeShudWxsLCB2YWwsIGNvbnRleHQpXTtcbiAgfVxuICByZXR1cm4gdmFsLm1hcChmdW5jdGlvbihtKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobSkgJiYgbS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBtO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXMuY2FzdEZvclF1ZXJ5KG51bGwsIG0sIGNvbnRleHQpO1xuICB9KTtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS4kY29uZGl0aW9uYWxIYW5kbGVycyA9IHtcbiAgJGFsbDogaGFuZGxlQXJyYXksXG4gICRlcTogaGFuZGxlU2luZ2xlLFxuICAkaW46IGhhbmRsZSRpbixcbiAgJG5lOiBoYW5kbGVTaW5nbGUsXG4gICRuaW46IGhhbmRsZSRpbixcbiAgJGV4aXN0czogJGV4aXN0cyxcbiAgJHR5cGU6ICR0eXBlXG59O1xuXG4vKipcbiAqIENhc3QgdGhlIGdpdmVuIHZhbHVlIHdpdGggdGhlIGdpdmVuIG9wdGlvbmFsIHF1ZXJ5IG9wZXJhdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbJGNvbmRpdGlvbmFsXSBxdWVyeSBvcGVyYXRvciwgbGlrZSBgJGVxYCBvciBgJGluYFxuICogQHBhcmFtIHtBbnl9IHZhbFxuICogQHBhcmFtIHtRdWVyeX0gY29udGV4dFxuICogQHJldHVybiB7QW55fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUuY2FzdEZvclF1ZXJ5ID0gZnVuY3Rpb24oJGNvbmRpdGlvbmFsLCB2YWwsIGNvbnRleHQpIHtcbiAgbGV0IGhhbmRsZXI7XG4gIGlmICgkY29uZGl0aW9uYWwgIT0gbnVsbCkge1xuICAgIGhhbmRsZXIgPSB0aGlzLiRjb25kaXRpb25hbEhhbmRsZXJzWyRjb25kaXRpb25hbF07XG4gICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgdXNlICcgKyAkY29uZGl0aW9uYWwpO1xuICAgIH1cbiAgICByZXR1cm4gaGFuZGxlci5jYWxsKHRoaXMsIHZhbCwgY29udGV4dCk7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmFwcGx5U2V0dGVycyh2YWwsIGNvbnRleHQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgQ2FzdEVycm9yICYmIGVyci5wYXRoID09PSB0aGlzLnBhdGggJiYgdGhpcy4kZnVsbFBhdGggIT0gbnVsbCkge1xuICAgICAgZXJyLnBhdGggPSB0aGlzLiRmdWxsUGF0aDtcbiAgICB9XG4gICAgdGhyb3cgZXJyO1xuICB9XG59O1xuXG4vKipcbiAqIFNldCAmIEdldCB0aGUgYGNoZWNrUmVxdWlyZWRgIGZ1bmN0aW9uXG4gKiBPdmVycmlkZSB0aGUgZnVuY3Rpb24gdGhlIHJlcXVpcmVkIHZhbGlkYXRvciB1c2VzIHRvIGNoZWNrIHdoZXRoZXIgYSB2YWx1ZVxuICogcGFzc2VzIHRoZSBgcmVxdWlyZWRgIGNoZWNrLiBPdmVycmlkZSB0aGlzIG9uIHRoZSBpbmRpdmlkdWFsIFNjaGVtYVR5cGUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBVc2UgdGhpcyB0byBhbGxvdyBlbXB0eSBzdHJpbmdzIHRvIHBhc3MgdGhlIGByZXF1aXJlZGAgdmFsaWRhdG9yXG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLlR5cGVzLlN0cmluZy5jaGVja1JlcXVpcmVkKHYgPT4gdHlwZW9mIHYgPT09ICdzdHJpbmcnKTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dIElmIHNldCwgd2lsbCBvdmVyd3JpdGUgdGhlIGN1cnJlbnQgc2V0IGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGlucHV0IGBmbmAgb3IgdGhlIGFscmVhZHkgc2V0IGZ1bmN0aW9uXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgU2NoZW1hVHlwZVxuICogQGZ1bmN0aW9uIGNoZWNrUmVxdWlyZWRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hVHlwZS5jaGVja1JlcXVpcmVkID0gZnVuY3Rpb24oZm4pIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDApIHtcbiAgICB0aGlzLl9jaGVja1JlcXVpcmVkID0gZm47XG4gIH1cblxuICByZXR1cm4gdGhpcy5fY2hlY2tSZXF1aXJlZDtcbn07XG5cbi8qKlxuICogRGVmYXVsdCBjaGVjayBmb3IgaWYgdGhpcyBwYXRoIHNhdGlzZmllcyB0aGUgYHJlcXVpcmVkYCB2YWxpZGF0b3IuXG4gKlxuICogQHBhcmFtIHtBbnl9IHZhbFxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIHdoZW4gdGhlIHZhbHVlIGlzIG5vdCBgbnVsbGAsIGBmYWxzZWAgb3RoZXJ3aXNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFUeXBlLnByb3RvdHlwZS5jaGVja1JlcXVpcmVkID0gZnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB2YWwgIT0gbnVsbDtcbn07XG5cbi8qKlxuICogQ2xvbmUgdGhlIGN1cnJlbnQgU2NoZW1hVHlwZVxuICpcbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IFRoZSBjbG9uZWQgU2NoZW1hVHlwZSBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hVHlwZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucyk7XG4gIGNvbnN0IHNjaGVtYXR5cGUgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnBhdGgsIG9wdGlvbnMsIHRoaXMuaW5zdGFuY2UpO1xuICBzY2hlbWF0eXBlLnZhbGlkYXRvcnMgPSB0aGlzLnZhbGlkYXRvcnMuc2xpY2UoKTtcbiAgaWYgKHRoaXMucmVxdWlyZWRWYWxpZGF0b3IgIT09IHVuZGVmaW5lZCkgc2NoZW1hdHlwZS5yZXF1aXJlZFZhbGlkYXRvciA9IHRoaXMucmVxdWlyZWRWYWxpZGF0b3I7XG4gIGlmICh0aGlzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkKSBzY2hlbWF0eXBlLmRlZmF1bHRWYWx1ZSA9IHRoaXMuZGVmYXVsdFZhbHVlO1xuICBpZiAodGhpcy4kaW1tdXRhYmxlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5vcHRpb25zLmltbXV0YWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc2NoZW1hdHlwZS4kaW1tdXRhYmxlID0gdGhpcy4kaW1tdXRhYmxlO1xuXG4gICAgaGFuZGxlSW1tdXRhYmxlKHNjaGVtYXR5cGUpO1xuICB9XG4gIGlmICh0aGlzLl9pbmRleCAhPT0gdW5kZWZpbmVkKSBzY2hlbWF0eXBlLl9pbmRleCA9IHRoaXMuX2luZGV4O1xuICBpZiAodGhpcy5zZWxlY3RlZCAhPT0gdW5kZWZpbmVkKSBzY2hlbWF0eXBlLnNlbGVjdGVkID0gdGhpcy5zZWxlY3RlZDtcbiAgaWYgKHRoaXMuaXNSZXF1aXJlZCAhPT0gdW5kZWZpbmVkKSBzY2hlbWF0eXBlLmlzUmVxdWlyZWQgPSB0aGlzLmlzUmVxdWlyZWQ7XG4gIGlmICh0aGlzLm9yaWdpbmFsUmVxdWlyZWRWYWx1ZSAhPT0gdW5kZWZpbmVkKSBzY2hlbWF0eXBlLm9yaWdpbmFsUmVxdWlyZWRWYWx1ZSA9IHRoaXMub3JpZ2luYWxSZXF1aXJlZFZhbHVlO1xuICBzY2hlbWF0eXBlLmdldHRlcnMgPSB0aGlzLmdldHRlcnMuc2xpY2UoKTtcbiAgc2NoZW1hdHlwZS5zZXR0ZXJzID0gdGhpcy5zZXR0ZXJzLnNsaWNlKCk7XG4gIHJldHVybiBzY2hlbWF0eXBlO1xufTtcblxuLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBTY2hlbWFUeXBlO1xuXG5leHBvcnRzLkNhc3RFcnJvciA9IENhc3RFcnJvcjtcblxuZXhwb3J0cy5WYWxpZGF0b3JFcnJvciA9IFZhbGlkYXRvckVycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/schemaType.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/schema/array.js":
/*!************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/schema/array.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst $exists = __webpack_require__(/*! ./operators/exists */ \"../backend/node_modules/mongoose/lib/schema/operators/exists.js\");\nconst $type = __webpack_require__(/*! ./operators/type */ \"../backend/node_modules/mongoose/lib/schema/operators/type.js\");\nconst MongooseError = __webpack_require__(/*! ../error/mongooseError */ \"../backend/node_modules/mongoose/lib/error/mongooseError.js\");\nconst SchemaArrayOptions = __webpack_require__(/*! ../options/schemaArrayOptions */ \"../backend/node_modules/mongoose/lib/options/schemaArrayOptions.js\");\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"../backend/node_modules/mongoose/lib/schemaType.js\");\nconst CastError = SchemaType.CastError;\nconst Mixed = __webpack_require__(/*! ./mixed */ \"../backend/node_modules/mongoose/lib/schema/mixed.js\");\nconst arrayDepth = __webpack_require__(/*! ../helpers/arrayDepth */ \"../backend/node_modules/mongoose/lib/helpers/arrayDepth.js\");\nconst cast = __webpack_require__(/*! ../cast */ \"../backend/node_modules/mongoose/lib/cast.js\");\nconst clone = __webpack_require__(/*! ../helpers/clone */ \"../backend/node_modules/mongoose/lib/helpers/clone.js\");\nconst isOperator = __webpack_require__(/*! ../helpers/query/isOperator */ \"../backend/node_modules/mongoose/lib/helpers/query/isOperator.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst utils = __webpack_require__(/*! ../utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\nconst castToNumber = (__webpack_require__(/*! ./operators/helpers */ \"../backend/node_modules/mongoose/lib/schema/operators/helpers.js\").castToNumber);\nconst geospatial = __webpack_require__(/*! ./operators/geospatial */ \"../backend/node_modules/mongoose/lib/schema/operators/geospatial.js\");\nconst getDiscriminatorByValue = __webpack_require__(/*! ../helpers/discriminator/getDiscriminatorByValue */ \"../backend/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\n\nlet MongooseArray;\nlet EmbeddedDoc;\n\nconst isNestedArraySymbol = Symbol('mongoose#isNestedArray');\nconst emptyOpts = Object.freeze({});\n\n/**\n * Array SchemaType constructor\n *\n * @param {String} key\n * @param {SchemaType} cast\n * @param {Object} options\n * @param {Object} schemaOptions\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaArray(key, cast, options, schemaOptions) {\n  // lazy load\n  EmbeddedDoc || (EmbeddedDoc = (__webpack_require__(/*! ../types */ \"../backend/node_modules/mongoose/lib/types/index.js\").Embedded));\n\n  let typeKey = 'type';\n  if (schemaOptions && schemaOptions.typeKey) {\n    typeKey = schemaOptions.typeKey;\n  }\n  this.schemaOptions = schemaOptions;\n\n  if (cast) {\n    let castOptions = {};\n\n    if (utils.isPOJO(cast)) {\n      if (cast[typeKey]) {\n        // support { type: Woot }\n        castOptions = clone(cast); // do not alter user arguments\n        delete castOptions[typeKey];\n        cast = cast[typeKey];\n      } else {\n        cast = Mixed;\n      }\n    }\n\n    if (options != null && options.ref != null && castOptions.ref == null) {\n      castOptions.ref = options.ref;\n    }\n\n    if (cast === Object) {\n      cast = Mixed;\n    }\n\n    // support { type: 'String' }\n    const name = typeof cast === 'string'\n      ? cast\n      : utils.getFunctionName(cast);\n\n    const Types = __webpack_require__(/*! ./index.js */ \"../backend/node_modules/mongoose/lib/schema/index.js\");\n    const caster = Types.hasOwnProperty(name) ? Types[name] : cast;\n\n    this.casterConstructor = caster;\n\n    if (this.casterConstructor instanceof SchemaArray) {\n      this.casterConstructor[isNestedArraySymbol] = true;\n    }\n\n    if (typeof caster === 'function' &&\n        !caster.$isArraySubdocument &&\n        !caster.$isSchemaMap) {\n      const path = this.caster instanceof EmbeddedDoc ? null : key;\n      this.caster = new caster(path, castOptions);\n    } else {\n      this.caster = caster;\n      if (!(this.caster instanceof EmbeddedDoc)) {\n        this.caster.path = key;\n      }\n    }\n\n    this.$embeddedSchemaType = this.caster;\n  }\n\n  this.$isMongooseArray = true;\n\n  SchemaType.call(this, key, options, 'Array');\n\n  let defaultArr;\n  let fn;\n\n  if (this.defaultValue != null) {\n    defaultArr = this.defaultValue;\n    fn = typeof defaultArr === 'function';\n  }\n\n  if (!('defaultValue' in this) || this.defaultValue !== void 0) {\n    const defaultFn = function() {\n      // Leave it up to `cast()` to convert the array\n      return fn\n        ? defaultArr.call(this)\n        : defaultArr != null\n          ? [].concat(defaultArr)\n          : [];\n    };\n    defaultFn.$runBeforeSetters = !fn;\n    this.default(defaultFn);\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaArray.schemaName = 'Array';\n\n\n/**\n * Options for all arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @static\n * @api public\n */\n\nSchemaArray.options = { castNonArrays: true };\n\n/*!\n * ignore\n */\n\nSchemaArray.defaultOptions = {};\n\n/**\n * Sets a default option for all Array instances.\n *\n * #### Example:\n *\n *     // Make all Array instances have `required` of true by default.\n *     mongoose.Schema.Array.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: Array }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @api public\n */\nSchemaArray.set = SchemaType.set;\n\nSchemaArray.setters = [];\n\n/**\n * Attaches a getter for all Array instances\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaArray.get = SchemaType.get;\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaArray.prototype = Object.create(SchemaType.prototype);\nSchemaArray.prototype.constructor = SchemaArray;\nSchemaArray.prototype.OptionsConstructor = SchemaArrayOptions;\n\n/*!\n * ignore\n */\n\nSchemaArray._checkRequired = SchemaType.prototype.checkRequired;\n\n/**\n * Override the function the required validator uses to check whether an array\n * passes the `required` check.\n *\n * #### Example:\n *\n *     // Require non-empty array to pass `required` check\n *     mongoose.Schema.Types.Array.checkRequired(v => Array.isArray(v) && v.length);\n *\n *     const M = mongoose.model({ arr: { type: Array, required: true } });\n *     new M({ arr: [] }).validateSync(); // `null`, validation fails!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @api public\n */\n\nSchemaArray.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies the `required` validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaArray.prototype.checkRequired = function checkRequired(value, doc) {\n  if (typeof value === 'object' && SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ?\n    this.constructor.checkRequired() :\n    SchemaArray.checkRequired();\n\n  return _checkRequired(value);\n};\n\n/**\n * Adds an enum validator if this is an array of strings or numbers. Equivalent to\n * `SchemaString.prototype.enum()` or `SchemaNumber.prototype.enum()`\n *\n * @param {...String|Object} [args] enumeration values\n * @return {SchemaArray} this\n */\n\nSchemaArray.prototype.enum = function() {\n  let arr = this;\n  while (true) {\n    const instance = arr &&\n    arr.caster &&\n    arr.caster.instance;\n    if (instance === 'Array') {\n      arr = arr.caster;\n      continue;\n    }\n    if (instance !== 'String' && instance !== 'Number') {\n      throw new Error('`enum` can only be set on an array of strings or numbers ' +\n        ', not ' + instance);\n    }\n    break;\n  }\n\n  let enumArray = arguments;\n  if (!Array.isArray(arguments) && utils.isObject(arguments)) {\n    enumArray = utils.object.vals(enumArray);\n  }\n\n  arr.caster.enum.apply(arr.caster, enumArray);\n  return this;\n};\n\n/**\n * Overrides the getters application for the population special-case\n *\n * @param {Object} value\n * @param {Object} scope\n * @api private\n */\n\nSchemaArray.prototype.applyGetters = function(value, scope) {\n  if (scope != null && scope.$__ != null && scope.$populated(this.path)) {\n    // means the object id was populated\n    return value;\n  }\n\n  const ret = SchemaType.prototype.applyGetters.call(this, value, scope);\n  return ret;\n};\n\nSchemaArray.prototype._applySetters = function(value, scope, init, priorVal) {\n  if (this.casterConstructor.$isMongooseArray &&\n      SchemaArray.options.castNonArrays &&\n      !this[isNestedArraySymbol]) {\n    // Check nesting levels and wrap in array if necessary\n    let depth = 0;\n    let arr = this;\n    while (arr != null &&\n      arr.$isMongooseArray &&\n      !arr.$isMongooseDocumentArray) {\n      ++depth;\n      arr = arr.casterConstructor;\n    }\n\n    // No need to wrap empty arrays\n    if (value != null && value.length !== 0) {\n      const valueDepth = arrayDepth(value);\n      if (valueDepth.min === valueDepth.max && valueDepth.max < depth && valueDepth.containsNonArrayItem) {\n        for (let i = valueDepth.max; i < depth; ++i) {\n          value = [value];\n        }\n      }\n    }\n  }\n\n  return SchemaType.prototype._applySetters.call(this, value, scope, init, priorVal);\n};\n\n/**\n * Casts values for set().\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nSchemaArray.prototype.cast = function(value, doc, init, prev, options) {\n  // lazy load\n  MongooseArray || (MongooseArray = (__webpack_require__(/*! ../types */ \"../backend/node_modules/mongoose/lib/types/index.js\").Array));\n\n  let i;\n  let l;\n\n  if (Array.isArray(value)) {\n    const len = value.length;\n    if (!len && doc) {\n      const indexes = doc.schema.indexedPaths();\n\n      const arrayPath = this.path;\n      for (i = 0, l = indexes.length; i < l; ++i) {\n        const pathIndex = indexes[i][0][arrayPath];\n        if (pathIndex === '2dsphere' || pathIndex === '2d') {\n          return;\n        }\n      }\n\n      // Special case: if this index is on the parent of what looks like\n      // GeoJSON, skip setting the default to empty array re: #1668, #3233\n      const arrayGeojsonPath = this.path.endsWith('.coordinates') ?\n        this.path.substring(0, this.path.lastIndexOf('.')) : null;\n      if (arrayGeojsonPath != null) {\n        for (i = 0, l = indexes.length; i < l; ++i) {\n          const pathIndex = indexes[i][0][arrayGeojsonPath];\n          if (pathIndex === '2dsphere') {\n            return;\n          }\n        }\n      }\n    }\n\n    options = options || emptyOpts;\n\n    let rawValue = utils.isMongooseArray(value) ? value.__array : value;\n    let path = options.path || this.path;\n    if (options.arrayPathIndex != null) {\n      path += '.' + options.arrayPathIndex;\n    }\n    value = MongooseArray(rawValue, path, doc, this);\n    rawValue = value.__array;\n\n    if (init && doc != null && doc.$__ != null && doc.$populated(this.path)) {\n      return value;\n    }\n\n    const caster = this.caster;\n    const isMongooseArray = caster.$isMongooseArray;\n    if (caster && this.casterConstructor !== Mixed) {\n      try {\n        const len = rawValue.length;\n        for (i = 0; i < len; i++) {\n          const opts = {};\n          // Perf: creating `arrayPath` is expensive for large arrays.\n          // We only need `arrayPath` if this is a nested array, so\n          // skip if possible.\n          if (isMongooseArray) {\n            if (options.arrayPath != null) {\n              opts.arrayPathIndex = i;\n            } else if (caster._arrayParentPath != null) {\n              opts.arrayPathIndex = i;\n            }\n          }\n          rawValue[i] = caster.applySetters(rawValue[i], doc, init, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\n      }\n    }\n\n    return value;\n  }\n\n  const castNonArraysOption = this.options.castNonArrays != null ? this.options.castNonArrays : SchemaArray.options.castNonArrays;\n  if (init || castNonArraysOption) {\n    // gh-2442: if we're loading this from the db and its not an array, mark\n    // the whole array as modified.\n    if (!!doc && !!init) {\n      doc.markModified(this.path);\n    }\n    return this.cast([value], doc, init);\n  }\n\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype._castForPopulate = function _castForPopulate(value, doc) {\n  // lazy load\n  MongooseArray || (MongooseArray = (__webpack_require__(/*! ../types */ \"../backend/node_modules/mongoose/lib/types/index.js\").Array));\n\n  if (Array.isArray(value)) {\n    let i;\n    const rawValue = value.__array ? value.__array : value;\n    const len = rawValue.length;\n\n    const caster = this.caster;\n    if (caster && this.casterConstructor !== Mixed) {\n      try {\n        for (i = 0; i < len; i++) {\n          const opts = {};\n          // Perf: creating `arrayPath` is expensive for large arrays.\n          // We only need `arrayPath` if this is a nested array, so\n          // skip if possible.\n          if (caster.$isMongooseArray && caster._arrayParentPath != null) {\n            opts.arrayPathIndex = i;\n          }\n\n          rawValue[i] = caster.cast(rawValue[i], doc, false, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\n      }\n    }\n\n    return value;\n  }\n\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\n\nSchemaArray.prototype.$toObject = SchemaArray.prototype.toObject;\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype.discriminator = function(...args) {\n  let arr = this;\n  while (arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {\n    arr = arr.casterConstructor;\n    if (arr == null || typeof arr === 'function') {\n      throw new MongooseError('You can only add an embedded discriminator on ' +\n        'a document array, ' + this.path + ' is a plain array');\n    }\n  }\n  return arr.discriminator(...args);\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype.clone = function() {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.caster, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  return schematype;\n};\n\nSchemaArray.prototype._castForQuery = function(val, context) {\n  let Constructor = this.casterConstructor;\n\n  if (val &&\n      Constructor.discriminators &&\n      Constructor.schema &&\n      Constructor.schema.options &&\n      Constructor.schema.options.discriminatorKey) {\n    if (typeof val[Constructor.schema.options.discriminatorKey] === 'string' &&\n        Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]]) {\n      Constructor = Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]];\n    } else {\n      const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, val[Constructor.schema.options.discriminatorKey]);\n      if (constructorByValue) {\n        Constructor = constructorByValue;\n      }\n    }\n  }\n\n  const proto = this.casterConstructor.prototype;\n  const protoCastForQuery = proto && proto.castForQuery;\n  const protoCast = proto && proto.cast;\n  const constructorCastForQuery = Constructor.castForQuery;\n  const caster = this.caster;\n\n  if (Array.isArray(val)) {\n    this.setters.reverse().forEach(setter => {\n      val = setter.call(this, val, this);\n    });\n    val = val.map(function(v) {\n      if (utils.isObject(v) && v.$elemMatch) {\n        return v;\n      }\n      if (protoCastForQuery) {\n        v = protoCastForQuery.call(caster, null, v, context);\n        return v;\n      } else if (protoCast) {\n        v = protoCast.call(caster, v);\n        return v;\n      } else if (constructorCastForQuery) {\n        v = constructorCastForQuery.call(caster, null, v, context);\n        return v;\n      }\n      if (v != null) {\n        v = new Constructor(v);\n        return v;\n      }\n      return v;\n    });\n  } else if (protoCastForQuery) {\n    val = protoCastForQuery.call(caster, null, val, context);\n  } else if (protoCast) {\n    val = protoCast.call(caster, val);\n  } else if (constructorCastForQuery) {\n    val = constructorCastForQuery.call(caster, null, val, context);\n  } else if (val != null) {\n    val = new Constructor(val);\n  }\n\n  return val;\n};\n\n/**\n * Casts values for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaArray.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Array.');\n    }\n\n    return handler.call(this, val, context);\n  } else {\n    return this._castForQuery(val, context);\n  }\n};\n\nfunction cast$all(val, context) {\n  if (!Array.isArray(val)) {\n    val = [val];\n  }\n\n  val = val.map((v) => {\n    if (!utils.isObject(v)) {\n      return v;\n    }\n    if (v.$elemMatch != null) {\n      return { $elemMatch: cast(this.casterConstructor.schema, v.$elemMatch, null, this && this.$$context) };\n    }\n\n    const o = {};\n    o[this.path] = v;\n    return cast(this.casterConstructor.schema, o, null, this && this.$$context)[this.path];\n  }, this);\n\n  return this.castForQuery(null, val, context);\n}\n\nfunction cast$elemMatch(val, context) {\n  const keys = Object.keys(val);\n  const numKeys = keys.length;\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const value = val[key];\n    if (isOperator(key) && value != null) {\n      val[key] = this.castForQuery(key, value, context);\n    }\n  }\n\n  // Is this an embedded discriminator and is the discriminator key set?\n  // If so, use the discriminator schema. See gh-7449\n  const discriminatorKey = this &&\n    this.casterConstructor &&\n    this.casterConstructor.schema &&\n    this.casterConstructor.schema.options &&\n    this.casterConstructor.schema.options.discriminatorKey;\n  const discriminators = this &&\n  this.casterConstructor &&\n  this.casterConstructor.schema &&\n  this.casterConstructor.schema.discriminators || {};\n  if (discriminatorKey != null &&\n      val[discriminatorKey] != null &&\n      discriminators[val[discriminatorKey]] != null) {\n    return cast(discriminators[val[discriminatorKey]], val, null, this && this.$$context);\n  }\n  const schema = this.casterConstructor.schema ?? context.schema;\n  return cast(schema, val, null, this && this.$$context);\n}\n\nconst handle = SchemaArray.prototype.$conditionalHandlers = {};\n\nhandle.$all = cast$all;\nhandle.$options = String;\nhandle.$elemMatch = cast$elemMatch;\nhandle.$geoIntersects = geospatial.cast$geoIntersects;\nhandle.$or = createLogicalQueryOperatorHandler('$or');\nhandle.$and = createLogicalQueryOperatorHandler('$and');\nhandle.$nor = createLogicalQueryOperatorHandler('$nor');\n\nfunction createLogicalQueryOperatorHandler(op) {\n  return function logicalQueryOperatorHandler(val, context) {\n    if (!Array.isArray(val)) {\n      throw new TypeError('conditional ' + op + ' requires an array');\n    }\n\n    const ret = [];\n    for (const obj of val) {\n      ret.push(cast(this.casterConstructor.schema ?? context.schema, obj, null, this && this.$$context));\n    }\n\n    return ret;\n  };\n}\n\nhandle.$near =\nhandle.$nearSphere = geospatial.cast$near;\n\nhandle.$within =\nhandle.$geoWithin = geospatial.cast$within;\n\nhandle.$size =\nhandle.$minDistance =\nhandle.$maxDistance = castToNumber;\n\nhandle.$exists = $exists;\nhandle.$type = $type;\n\nhandle.$eq =\nhandle.$gt =\nhandle.$gte =\nhandle.$lt =\nhandle.$lte =\nhandle.$not =\nhandle.$regex =\nhandle.$ne = SchemaArray.prototype._castForQuery;\n\n// `$in` is special because you can also include an empty array in the query\n// like `$in: [1, []]`, see gh-5913\nhandle.$nin = SchemaType.prototype.$conditionalHandlers.$nin;\nhandle.$in = SchemaType.prototype.$conditionalHandlers.$in;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9hcnJheS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLG1CQUFPLENBQUMsMkZBQW9CO0FBQzVDLGNBQWMsbUJBQU8sQ0FBQyx1RkFBa0I7QUFDeEMsc0JBQXNCLG1CQUFPLENBQUMsMkZBQXdCO0FBQ3RELDJCQUEyQixtQkFBTyxDQUFDLHlHQUErQjtBQUNsRSxtQkFBbUIsbUJBQU8sQ0FBQyx5RUFBZTtBQUMxQztBQUNBLGNBQWMsbUJBQU8sQ0FBQyxxRUFBUztBQUMvQixtQkFBbUIsbUJBQU8sQ0FBQyx5RkFBdUI7QUFDbEQsYUFBYSxtQkFBTyxDQUFDLDZEQUFTO0FBQzlCLGNBQWMsbUJBQU8sQ0FBQywrRUFBa0I7QUFDeEMsbUJBQW1CLG1CQUFPLENBQUMscUdBQTZCO0FBQ3hELGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixjQUFjLG1CQUFPLENBQUMsK0RBQVU7QUFDaEMscUJBQXFCLGlJQUEyQztBQUNoRSxtQkFBbUIsbUJBQU8sQ0FBQyxtR0FBd0I7QUFDbkQsZ0NBQWdDLG1CQUFPLENBQUMsK0lBQWtEOztBQUUxRjtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MscUdBQTRCOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixtQkFBTyxDQUFD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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0Msa0dBQXlCOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9zY2hlbWEvYXJyYXkuanM/MTMxZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCAkZXhpc3RzID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvZXhpc3RzJyk7XG5jb25zdCAkdHlwZSA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL3R5cGUnKTtcbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci9tb25nb29zZUVycm9yJyk7XG5jb25zdCBTY2hlbWFBcnJheU9wdGlvbnMgPSByZXF1aXJlKCcuLi9vcHRpb25zL3NjaGVtYUFycmF5T3B0aW9ucycpO1xuY29uc3QgU2NoZW1hVHlwZSA9IHJlcXVpcmUoJy4uL3NjaGVtYVR5cGUnKTtcbmNvbnN0IENhc3RFcnJvciA9IFNjaGVtYVR5cGUuQ2FzdEVycm9yO1xuY29uc3QgTWl4ZWQgPSByZXF1aXJlKCcuL21peGVkJyk7XG5jb25zdCBhcnJheURlcHRoID0gcmVxdWlyZSgnLi4vaGVscGVycy9hcnJheURlcHRoJyk7XG5jb25zdCBjYXN0ID0gcmVxdWlyZSgnLi4vY2FzdCcpO1xuY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2Nsb25lJyk7XG5jb25zdCBpc09wZXJhdG9yID0gcmVxdWlyZSgnLi4vaGVscGVycy9xdWVyeS9pc09wZXJhdG9yJyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuY29uc3QgY2FzdFRvTnVtYmVyID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvaGVscGVycycpLmNhc3RUb051bWJlcjtcbmNvbnN0IGdlb3NwYXRpYWwgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9nZW9zcGF0aWFsJyk7XG5jb25zdCBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZGlzY3JpbWluYXRvci9nZXREaXNjcmltaW5hdG9yQnlWYWx1ZScpO1xuXG5sZXQgTW9uZ29vc2VBcnJheTtcbmxldCBFbWJlZGRlZERvYztcblxuY29uc3QgaXNOZXN0ZWRBcnJheVN5bWJvbCA9IFN5bWJvbCgnbW9uZ29vc2UjaXNOZXN0ZWRBcnJheScpO1xuY29uc3QgZW1wdHlPcHRzID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5cbi8qKlxuICogQXJyYXkgU2NoZW1hVHlwZSBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7U2NoZW1hVHlwZX0gY2FzdFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY2hlbWFPcHRpb25zXG4gKiBAaW5oZXJpdHMgU2NoZW1hVHlwZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTY2hlbWFBcnJheShrZXksIGNhc3QsIG9wdGlvbnMsIHNjaGVtYU9wdGlvbnMpIHtcbiAgLy8gbGF6eSBsb2FkXG4gIEVtYmVkZGVkRG9jIHx8IChFbWJlZGRlZERvYyA9IHJlcXVpcmUoJy4uL3R5cGVzJykuRW1iZWRkZWQpO1xuXG4gIGxldCB0eXBlS2V5ID0gJ3R5cGUnO1xuICBpZiAoc2NoZW1hT3B0aW9ucyAmJiBzY2hlbWFPcHRpb25zLnR5cGVLZXkpIHtcbiAgICB0eXBlS2V5ID0gc2NoZW1hT3B0aW9ucy50eXBlS2V5O1xuICB9XG4gIHRoaXMuc2NoZW1hT3B0aW9ucyA9IHNjaGVtYU9wdGlvbnM7XG5cbiAgaWYgKGNhc3QpIHtcbiAgICBsZXQgY2FzdE9wdGlvbnMgPSB7fTtcblxuICAgIGlmICh1dGlscy5pc1BPSk8oY2FzdCkpIHtcbiAgICAgIGlmIChjYXN0W3R5cGVLZXldKSB7XG4gICAgICAgIC8vIHN1cHBvcnQgeyB0eXBlOiBXb290IH1cbiAgICAgICAgY2FzdE9wdGlvbnMgPSBjbG9uZShjYXN0KTsgLy8gZG8gbm90IGFsdGVyIHVzZXIgYXJndW1lbnRzXG4gICAgICAgIGRlbGV0ZSBjYXN0T3B0aW9uc1t0eXBlS2V5XTtcbiAgICAgICAgY2FzdCA9IGNhc3RbdHlwZUtleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXN0ID0gTWl4ZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLnJlZiAhPSBudWxsICYmIGNhc3RPcHRpb25zLnJlZiA9PSBudWxsKSB7XG4gICAgICBjYXN0T3B0aW9ucy5yZWYgPSBvcHRpb25zLnJlZjtcbiAgICB9XG5cbiAgICBpZiAoY2FzdCA9PT0gT2JqZWN0KSB7XG4gICAgICBjYXN0ID0gTWl4ZWQ7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydCB7IHR5cGU6ICdTdHJpbmcnIH1cbiAgICBjb25zdCBuYW1lID0gdHlwZW9mIGNhc3QgPT09ICdzdHJpbmcnXG4gICAgICA/IGNhc3RcbiAgICAgIDogdXRpbHMuZ2V0RnVuY3Rpb25OYW1lKGNhc3QpO1xuXG4gICAgY29uc3QgVHlwZXMgPSByZXF1aXJlKCcuL2luZGV4LmpzJyk7XG4gICAgY29uc3QgY2FzdGVyID0gVHlwZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBUeXBlc1tuYW1lXSA6IGNhc3Q7XG5cbiAgICB0aGlzLmNhc3RlckNvbnN0cnVjdG9yID0gY2FzdGVyO1xuXG4gICAgaWYgKHRoaXMuY2FzdGVyQ29uc3RydWN0b3IgaW5zdGFuY2VvZiBTY2hlbWFBcnJheSkge1xuICAgICAgdGhpcy5jYXN0ZXJDb25zdHJ1Y3Rvcltpc05lc3RlZEFycmF5U3ltYm9sXSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjYXN0ZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgIWNhc3Rlci4kaXNBcnJheVN1YmRvY3VtZW50ICYmXG4gICAgICAgICFjYXN0ZXIuJGlzU2NoZW1hTWFwKSB7XG4gICAgICBjb25zdCBwYXRoID0gdGhpcy5jYXN0ZXIgaW5zdGFuY2VvZiBFbWJlZGRlZERvYyA/IG51bGwgOiBrZXk7XG4gICAgICB0aGlzLmNhc3RlciA9IG5ldyBjYXN0ZXIocGF0aCwgY2FzdE9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNhc3RlciA9IGNhc3RlcjtcbiAgICAgIGlmICghKHRoaXMuY2FzdGVyIGluc3RhbmNlb2YgRW1iZWRkZWREb2MpKSB7XG4gICAgICAgIHRoaXMuY2FzdGVyLnBhdGggPSBrZXk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy4kZW1iZWRkZWRTY2hlbWFUeXBlID0gdGhpcy5jYXN0ZXI7XG4gIH1cblxuICB0aGlzLiRpc01vbmdvb3NlQXJyYXkgPSB0cnVlO1xuXG4gIFNjaGVtYVR5cGUuY2FsbCh0aGlzLCBrZXksIG9wdGlvbnMsICdBcnJheScpO1xuXG4gIGxldCBkZWZhdWx0QXJyO1xuICBsZXQgZm47XG5cbiAgaWYgKHRoaXMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICBkZWZhdWx0QXJyID0gdGhpcy5kZWZhdWx0VmFsdWU7XG4gICAgZm4gPSB0eXBlb2YgZGVmYXVsdEFyciA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIGlmICghKCdkZWZhdWx0VmFsdWUnIGluIHRoaXMpIHx8IHRoaXMuZGVmYXVsdFZhbHVlICE9PSB2b2lkIDApIHtcbiAgICBjb25zdCBkZWZhdWx0Rm4gPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIExlYXZlIGl0IHVwIHRvIGBjYXN0KClgIHRvIGNvbnZlcnQgdGhlIGFycmF5XG4gICAgICByZXR1cm4gZm5cbiAgICAgICAgPyBkZWZhdWx0QXJyLmNhbGwodGhpcylcbiAgICAgICAgOiBkZWZhdWx0QXJyICE9IG51bGxcbiAgICAgICAgICA/IFtdLmNvbmNhdChkZWZhdWx0QXJyKVxuICAgICAgICAgIDogW107XG4gICAgfTtcbiAgICBkZWZhdWx0Rm4uJHJ1bkJlZm9yZVNldHRlcnMgPSAhZm47XG4gICAgdGhpcy5kZWZhdWx0KGRlZmF1bHRGbik7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIHNjaGVtYSB0eXBlJ3MgbmFtZSwgdG8gZGVmZW5kIGFnYWluc3QgbWluaWZpZXJzIHRoYXQgbWFuZ2xlXG4gKiBmdW5jdGlvbiBuYW1lcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5TY2hlbWFBcnJheS5zY2hlbWFOYW1lID0gJ0FycmF5JztcblxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGFsbCBhcnJheXMuXG4gKlxuICogLSBgY2FzdE5vbkFycmF5c2A6IGB0cnVlYCBieSBkZWZhdWx0LiBJZiBgZmFsc2VgLCBNb25nb29zZSB3aWxsIHRocm93IGEgQ2FzdEVycm9yIHdoZW4gYSB2YWx1ZSBpc24ndCBhbiBhcnJheS4gSWYgYHRydWVgLCBNb25nb29zZSB3aWxsIHdyYXAgdGhlIHByb3ZpZGVkIHZhbHVlIGluIGFuIGFycmF5IGJlZm9yZSBjYXN0aW5nLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hQXJyYXkub3B0aW9ucyA9IHsgY2FzdE5vbkFycmF5czogdHJ1ZSB9O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYUFycmF5LmRlZmF1bHRPcHRpb25zID0ge307XG5cbi8qKlxuICogU2V0cyBhIGRlZmF1bHQgb3B0aW9uIGZvciBhbGwgQXJyYXkgaW5zdGFuY2VzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTWFrZSBhbGwgQXJyYXkgaW5zdGFuY2VzIGhhdmUgYHJlcXVpcmVkYCBvZiB0cnVlIGJ5IGRlZmF1bHQuXG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLkFycmF5LnNldCgncmVxdWlyZWQnLCB0cnVlKTtcbiAqXG4gKiAgICAgY29uc3QgVXNlciA9IG1vbmdvb3NlLm1vZGVsKCdVc2VyJywgbmV3IFNjaGVtYSh7IHRlc3Q6IEFycmF5IH0pKTtcbiAqICAgICBuZXcgVXNlcih7IH0pLnZhbGlkYXRlU3luYygpLmVycm9ycy50ZXN0Lm1lc3NhZ2U7IC8vIFBhdGggYHRlc3RgIGlzIHJlcXVpcmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb24gVGhlIG9wdGlvbiB5b3UnZCBsaWtlIHRvIHNldCB0aGUgdmFsdWUgZm9yXG4gKiBAcGFyYW0ge0FueX0gdmFsdWUgdmFsdWUgZm9yIG9wdGlvblxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICogQGZ1bmN0aW9uIHNldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuU2NoZW1hQXJyYXkuc2V0ID0gU2NoZW1hVHlwZS5zZXQ7XG5cblNjaGVtYUFycmF5LnNldHRlcnMgPSBbXTtcblxuLyoqXG4gKiBBdHRhY2hlcyBhIGdldHRlciBmb3IgYWxsIEFycmF5IGluc3RhbmNlc1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlclxuICogQHJldHVybiB7dGhpc31cbiAqIEBmdW5jdGlvbiBnZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hQXJyYXkuZ2V0ID0gU2NoZW1hVHlwZS5nZXQ7XG5cbi8qIVxuICogSW5oZXJpdHMgZnJvbSBTY2hlbWFUeXBlLlxuICovXG5TY2hlbWFBcnJheS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNjaGVtYVR5cGUucHJvdG90eXBlKTtcblNjaGVtYUFycmF5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNjaGVtYUFycmF5O1xuU2NoZW1hQXJyYXkucHJvdG90eXBlLk9wdGlvbnNDb25zdHJ1Y3RvciA9IFNjaGVtYUFycmF5T3B0aW9ucztcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFBcnJheS5fY2hlY2tSZXF1aXJlZCA9IFNjaGVtYVR5cGUucHJvdG90eXBlLmNoZWNrUmVxdWlyZWQ7XG5cbi8qKlxuICogT3ZlcnJpZGUgdGhlIGZ1bmN0aW9uIHRoZSByZXF1aXJlZCB2YWxpZGF0b3IgdXNlcyB0byBjaGVjayB3aGV0aGVyIGFuIGFycmF5XG4gKiBwYXNzZXMgdGhlIGByZXF1aXJlZGAgY2hlY2suXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBSZXF1aXJlIG5vbi1lbXB0eSBhcnJheSB0byBwYXNzIGByZXF1aXJlZGAgY2hlY2tcbiAqICAgICBtb25nb29zZS5TY2hlbWEuVHlwZXMuQXJyYXkuY2hlY2tSZXF1aXJlZCh2ID0+IEFycmF5LmlzQXJyYXkodikgJiYgdi5sZW5ndGgpO1xuICpcbiAqICAgICBjb25zdCBNID0gbW9uZ29vc2UubW9kZWwoeyBhcnI6IHsgdHlwZTogQXJyYXksIHJlcXVpcmVkOiB0cnVlIH0gfSk7XG4gKiAgICAgbmV3IE0oeyBhcnI6IFtdIH0pLnZhbGlkYXRlU3luYygpOyAvLyBgbnVsbGAsIHZhbGlkYXRpb24gZmFpbHMhXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGZ1bmN0aW9uIGNoZWNrUmVxdWlyZWRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hQXJyYXkuY2hlY2tSZXF1aXJlZCA9IFNjaGVtYVR5cGUuY2hlY2tSZXF1aXJlZDtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgc2F0aXNmaWVzIHRoZSBgcmVxdWlyZWRgIHZhbGlkYXRvci5cbiAqXG4gKiBAcGFyYW0ge0FueX0gdmFsdWVcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvY1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hQXJyYXkucHJvdG90eXBlLmNoZWNrUmVxdWlyZWQgPSBmdW5jdGlvbiBjaGVja1JlcXVpcmVkKHZhbHVlLCBkb2MpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgU2NoZW1hVHlwZS5faXNSZWYodGhpcywgdmFsdWUsIGRvYywgdHJ1ZSkpIHtcbiAgICByZXR1cm4gISF2YWx1ZTtcbiAgfVxuXG4gIC8vIGByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHMoKWAgZG9lcyAqKm5vdCoqIGNvcHkgc3RhdGljIHByb3BlcnRpZXMsIGFuZFxuICAvLyBwbHVnaW5zIGxpa2UgbW9uZ29vc2UtZmxvYXQgdXNlIGBpbmhlcml0cygpYCBmb3IgcHJlLUVTNi5cbiAgY29uc3QgX2NoZWNrUmVxdWlyZWQgPSB0eXBlb2YgdGhpcy5jb25zdHJ1Y3Rvci5jaGVja1JlcXVpcmVkID09PSAnZnVuY3Rpb24nID9cbiAgICB0aGlzLmNvbnN0cnVjdG9yLmNoZWNrUmVxdWlyZWQoKSA6XG4gICAgU2NoZW1hQXJyYXkuY2hlY2tSZXF1aXJlZCgpO1xuXG4gIHJldHVybiBfY2hlY2tSZXF1aXJlZCh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEFkZHMgYW4gZW51bSB2YWxpZGF0b3IgaWYgdGhpcyBpcyBhbiBhcnJheSBvZiBzdHJpbmdzIG9yIG51bWJlcnMuIEVxdWl2YWxlbnQgdG9cbiAqIGBTY2hlbWFTdHJpbmcucHJvdG90eXBlLmVudW0oKWAgb3IgYFNjaGVtYU51bWJlci5wcm90b3R5cGUuZW51bSgpYFxuICpcbiAqIEBwYXJhbSB7Li4uU3RyaW5nfE9iamVjdH0gW2FyZ3NdIGVudW1lcmF0aW9uIHZhbHVlc1xuICogQHJldHVybiB7U2NoZW1hQXJyYXl9IHRoaXNcbiAqL1xuXG5TY2hlbWFBcnJheS5wcm90b3R5cGUuZW51bSA9IGZ1bmN0aW9uKCkge1xuICBsZXQgYXJyID0gdGhpcztcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGFyciAmJlxuICAgIGFyci5jYXN0ZXIgJiZcbiAgICBhcnIuY2FzdGVyLmluc3RhbmNlO1xuICAgIGlmIChpbnN0YW5jZSA9PT0gJ0FycmF5Jykge1xuICAgICAgYXJyID0gYXJyLmNhc3RlcjtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaW5zdGFuY2UgIT09ICdTdHJpbmcnICYmIGluc3RhbmNlICE9PSAnTnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgZW51bWAgY2FuIG9ubHkgYmUgc2V0IG9uIGFuIGFycmF5IG9mIHN0cmluZ3Mgb3IgbnVtYmVycyAnICtcbiAgICAgICAgJywgbm90ICcgKyBpbnN0YW5jZSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG5cbiAgbGV0IGVudW1BcnJheSA9IGFyZ3VtZW50cztcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFyZ3VtZW50cykgJiYgdXRpbHMuaXNPYmplY3QoYXJndW1lbnRzKSkge1xuICAgIGVudW1BcnJheSA9IHV0aWxzLm9iamVjdC52YWxzKGVudW1BcnJheSk7XG4gIH1cblxuICBhcnIuY2FzdGVyLmVudW0uYXBwbHkoYXJyLmNhc3RlciwgZW51bUFycmF5KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlcyB0aGUgZ2V0dGVycyBhcHBsaWNhdGlvbiBmb3IgdGhlIHBvcHVsYXRpb24gc3BlY2lhbC1jYXNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gc2NvcGVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYUFycmF5LnByb3RvdHlwZS5hcHBseUdldHRlcnMgPSBmdW5jdGlvbih2YWx1ZSwgc2NvcGUpIHtcbiAgaWYgKHNjb3BlICE9IG51bGwgJiYgc2NvcGUuJF9fICE9IG51bGwgJiYgc2NvcGUuJHBvcHVsYXRlZCh0aGlzLnBhdGgpKSB7XG4gICAgLy8gbWVhbnMgdGhlIG9iamVjdCBpZCB3YXMgcG9wdWxhdGVkXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgY29uc3QgcmV0ID0gU2NoZW1hVHlwZS5wcm90b3R5cGUuYXBwbHlHZXR0ZXJzLmNhbGwodGhpcywgdmFsdWUsIHNjb3BlKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cblNjaGVtYUFycmF5LnByb3RvdHlwZS5fYXBwbHlTZXR0ZXJzID0gZnVuY3Rpb24odmFsdWUsIHNjb3BlLCBpbml0LCBwcmlvclZhbCkge1xuICBpZiAodGhpcy5jYXN0ZXJDb25zdHJ1Y3Rvci4kaXNNb25nb29zZUFycmF5ICYmXG4gICAgICBTY2hlbWFBcnJheS5vcHRpb25zLmNhc3ROb25BcnJheXMgJiZcbiAgICAgICF0aGlzW2lzTmVzdGVkQXJyYXlTeW1ib2xdKSB7XG4gICAgLy8gQ2hlY2sgbmVzdGluZyBsZXZlbHMgYW5kIHdyYXAgaW4gYXJyYXkgaWYgbmVjZXNzYXJ5XG4gICAgbGV0IGRlcHRoID0gMDtcbiAgICBsZXQgYXJyID0gdGhpcztcbiAgICB3aGlsZSAoYXJyICE9IG51bGwgJiZcbiAgICAgIGFyci4kaXNNb25nb29zZUFycmF5ICYmXG4gICAgICAhYXJyLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSkge1xuICAgICAgKytkZXB0aDtcbiAgICAgIGFyciA9IGFyci5jYXN0ZXJDb25zdHJ1Y3RvcjtcbiAgICB9XG5cbiAgICAvLyBObyBuZWVkIHRvIHdyYXAgZW1wdHkgYXJyYXlzXG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUubGVuZ3RoICE9PSAwKSB7XG4gICAgICBjb25zdCB2YWx1ZURlcHRoID0gYXJyYXlEZXB0aCh2YWx1ZSk7XG4gICAgICBpZiAodmFsdWVEZXB0aC5taW4gPT09IHZhbHVlRGVwdGgubWF4ICYmIHZhbHVlRGVwdGgubWF4IDwgZGVwdGggJiYgdmFsdWVEZXB0aC5jb250YWluc05vbkFycmF5SXRlbSkge1xuICAgICAgICBmb3IgKGxldCBpID0gdmFsdWVEZXB0aC5tYXg7IGkgPCBkZXB0aDsgKytpKSB7XG4gICAgICAgICAgdmFsdWUgPSBbdmFsdWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFNjaGVtYVR5cGUucHJvdG90eXBlLl9hcHBseVNldHRlcnMuY2FsbCh0aGlzLCB2YWx1ZSwgc2NvcGUsIGluaXQsIHByaW9yVmFsKTtcbn07XG5cbi8qKlxuICogQ2FzdHMgdmFsdWVzIGZvciBzZXQoKS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvYyBkb2N1bWVudCB0aGF0IHRyaWdnZXJzIHRoZSBjYXN0aW5nXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluaXQgd2hldGhlciB0aGlzIGlzIGFuIGluaXRpYWxpemF0aW9uIGNhc3RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYUFycmF5LnByb3RvdHlwZS5jYXN0ID0gZnVuY3Rpb24odmFsdWUsIGRvYywgaW5pdCwgcHJldiwgb3B0aW9ucykge1xuICAvLyBsYXp5IGxvYWRcbiAgTW9uZ29vc2VBcnJheSB8fCAoTW9uZ29vc2VBcnJheSA9IHJlcXVpcmUoJy4uL3R5cGVzJykuQXJyYXkpO1xuXG4gIGxldCBpO1xuICBsZXQgbDtcblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBjb25zdCBsZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgaWYgKCFsZW4gJiYgZG9jKSB7XG4gICAgICBjb25zdCBpbmRleGVzID0gZG9jLnNjaGVtYS5pbmRleGVkUGF0aHMoKTtcblxuICAgICAgY29uc3QgYXJyYXlQYXRoID0gdGhpcy5wYXRoO1xuICAgICAgZm9yIChpID0gMCwgbCA9IGluZGV4ZXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHBhdGhJbmRleCA9IGluZGV4ZXNbaV1bMF1bYXJyYXlQYXRoXTtcbiAgICAgICAgaWYgKHBhdGhJbmRleCA9PT0gJzJkc3BoZXJlJyB8fCBwYXRoSW5kZXggPT09ICcyZCcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gU3BlY2lhbCBjYXNlOiBpZiB0aGlzIGluZGV4IGlzIG9uIHRoZSBwYXJlbnQgb2Ygd2hhdCBsb29rcyBsaWtlXG4gICAgICAvLyBHZW9KU09OLCBza2lwIHNldHRpbmcgdGhlIGRlZmF1bHQgdG8gZW1wdHkgYXJyYXkgcmU6ICMxNjY4LCAjMzIzM1xuICAgICAgY29uc3QgYXJyYXlHZW9qc29uUGF0aCA9IHRoaXMucGF0aC5lbmRzV2l0aCgnLmNvb3JkaW5hdGVzJykgP1xuICAgICAgICB0aGlzLnBhdGguc3Vic3RyaW5nKDAsIHRoaXMucGF0aC5sYXN0SW5kZXhPZignLicpKSA6IG51bGw7XG4gICAgICBpZiAoYXJyYXlHZW9qc29uUGF0aCAhPSBudWxsKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBpbmRleGVzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgIGNvbnN0IHBhdGhJbmRleCA9IGluZGV4ZXNbaV1bMF1bYXJyYXlHZW9qc29uUGF0aF07XG4gICAgICAgICAgaWYgKHBhdGhJbmRleCA9PT0gJzJkc3BoZXJlJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IGVtcHR5T3B0cztcblxuICAgIGxldCByYXdWYWx1ZSA9IHV0aWxzLmlzTW9uZ29vc2VBcnJheSh2YWx1ZSkgPyB2YWx1ZS5fX2FycmF5IDogdmFsdWU7XG4gICAgbGV0IHBhdGggPSBvcHRpb25zLnBhdGggfHwgdGhpcy5wYXRoO1xuICAgIGlmIChvcHRpb25zLmFycmF5UGF0aEluZGV4ICE9IG51bGwpIHtcbiAgICAgIHBhdGggKz0gJy4nICsgb3B0aW9ucy5hcnJheVBhdGhJbmRleDtcbiAgICB9XG4gICAgdmFsdWUgPSBNb25nb29zZUFycmF5KHJhd1ZhbHVlLCBwYXRoLCBkb2MsIHRoaXMpO1xuICAgIHJhd1ZhbHVlID0gdmFsdWUuX19hcnJheTtcblxuICAgIGlmIChpbml0ICYmIGRvYyAhPSBudWxsICYmIGRvYy4kX18gIT0gbnVsbCAmJiBkb2MuJHBvcHVsYXRlZCh0aGlzLnBhdGgpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgY29uc3QgY2FzdGVyID0gdGhpcy5jYXN0ZXI7XG4gICAgY29uc3QgaXNNb25nb29zZUFycmF5ID0gY2FzdGVyLiRpc01vbmdvb3NlQXJyYXk7XG4gICAgaWYgKGNhc3RlciAmJiB0aGlzLmNhc3RlckNvbnN0cnVjdG9yICE9PSBNaXhlZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbGVuID0gcmF3VmFsdWUubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBvcHRzID0ge307XG4gICAgICAgICAgLy8gUGVyZjogY3JlYXRpbmcgYGFycmF5UGF0aGAgaXMgZXhwZW5zaXZlIGZvciBsYXJnZSBhcnJheXMuXG4gICAgICAgICAgLy8gV2Ugb25seSBuZWVkIGBhcnJheVBhdGhgIGlmIHRoaXMgaXMgYSBuZXN0ZWQgYXJyYXksIHNvXG4gICAgICAgICAgLy8gc2tpcCBpZiBwb3NzaWJsZS5cbiAgICAgICAgICBpZiAoaXNNb25nb29zZUFycmF5KSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hcnJheVBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICBvcHRzLmFycmF5UGF0aEluZGV4ID0gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2FzdGVyLl9hcnJheVBhcmVudFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICBvcHRzLmFycmF5UGF0aEluZGV4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmF3VmFsdWVbaV0gPSBjYXN0ZXIuYXBwbHlTZXR0ZXJzKHJhd1ZhbHVlW2ldLCBkb2MsIGluaXQsIHZvaWQgMCwgb3B0cyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gcmV0aHJvd1xuICAgICAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdbJyArIGUua2luZCArICddJywgdXRpbC5pbnNwZWN0KHZhbHVlKSwgdGhpcy5wYXRoICsgJy4nICsgaSwgZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgY29uc3QgY2FzdE5vbkFycmF5c09wdGlvbiA9IHRoaXMub3B0aW9ucy5jYXN0Tm9uQXJyYXlzICE9IG51bGwgPyB0aGlzLm9wdGlvbnMuY2FzdE5vbkFycmF5cyA6IFNjaGVtYUFycmF5Lm9wdGlvbnMuY2FzdE5vbkFycmF5cztcbiAgaWYgKGluaXQgfHwgY2FzdE5vbkFycmF5c09wdGlvbikge1xuICAgIC8vIGdoLTI0NDI6IGlmIHdlJ3JlIGxvYWRpbmcgdGhpcyBmcm9tIHRoZSBkYiBhbmQgaXRzIG5vdCBhbiBhcnJheSwgbWFya1xuICAgIC8vIHRoZSB3aG9sZSBhcnJheSBhcyBtb2RpZmllZC5cbiAgICBpZiAoISFkb2MgJiYgISFpbml0KSB7XG4gICAgICBkb2MubWFya01vZGlmaWVkKHRoaXMucGF0aCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNhc3QoW3ZhbHVlXSwgZG9jLCBpbml0KTtcbiAgfVxuXG4gIHRocm93IG5ldyBDYXN0RXJyb3IoJ0FycmF5JywgdXRpbC5pbnNwZWN0KHZhbHVlKSwgdGhpcy5wYXRoLCBudWxsLCB0aGlzKTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hQXJyYXkucHJvdG90eXBlLl9jYXN0Rm9yUG9wdWxhdGUgPSBmdW5jdGlvbiBfY2FzdEZvclBvcHVsYXRlKHZhbHVlLCBkb2MpIHtcbiAgLy8gbGF6eSBsb2FkXG4gIE1vbmdvb3NlQXJyYXkgfHwgKE1vbmdvb3NlQXJyYXkgPSByZXF1aXJlKCcuLi90eXBlcycpLkFycmF5KTtcblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBsZXQgaTtcbiAgICBjb25zdCByYXdWYWx1ZSA9IHZhbHVlLl9fYXJyYXkgPyB2YWx1ZS5fX2FycmF5IDogdmFsdWU7XG4gICAgY29uc3QgbGVuID0gcmF3VmFsdWUubGVuZ3RoO1xuXG4gICAgY29uc3QgY2FzdGVyID0gdGhpcy5jYXN0ZXI7XG4gICAgaWYgKGNhc3RlciAmJiB0aGlzLmNhc3RlckNvbnN0cnVjdG9yICE9PSBNaXhlZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgb3B0cyA9IHt9O1xuICAgICAgICAgIC8vIFBlcmY6IGNyZWF0aW5nIGBhcnJheVBhdGhgIGlzIGV4cGVuc2l2ZSBmb3IgbGFyZ2UgYXJyYXlzLlxuICAgICAgICAgIC8vIFdlIG9ubHkgbmVlZCBgYXJyYXlQYXRoYCBpZiB0aGlzIGlzIGEgbmVzdGVkIGFycmF5LCBzb1xuICAgICAgICAgIC8vIHNraXAgaWYgcG9zc2libGUuXG4gICAgICAgICAgaWYgKGNhc3Rlci4kaXNNb25nb29zZUFycmF5ICYmIGNhc3Rlci5fYXJyYXlQYXJlbnRQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIG9wdHMuYXJyYXlQYXRoSW5kZXggPSBpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJhd1ZhbHVlW2ldID0gY2FzdGVyLmNhc3QocmF3VmFsdWVbaV0sIGRvYywgZmFsc2UsIHZvaWQgMCwgb3B0cyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gcmV0aHJvd1xuICAgICAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdbJyArIGUua2luZCArICddJywgdXRpbC5pbnNwZWN0KHZhbHVlKSwgdGhpcy5wYXRoICsgJy4nICsgaSwgZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgdGhyb3cgbmV3IENhc3RFcnJvcignQXJyYXknLCB1dGlsLmluc3BlY3QodmFsdWUpLCB0aGlzLnBhdGgsIG51bGwsIHRoaXMpO1xufTtcblxuU2NoZW1hQXJyYXkucHJvdG90eXBlLiR0b09iamVjdCA9IFNjaGVtYUFycmF5LnByb3RvdHlwZS50b09iamVjdDtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFBcnJheS5wcm90b3R5cGUuZGlzY3JpbWluYXRvciA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgbGV0IGFyciA9IHRoaXM7XG4gIHdoaWxlIChhcnIuJGlzTW9uZ29vc2VBcnJheSAmJiAhYXJyLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSkge1xuICAgIGFyciA9IGFyci5jYXN0ZXJDb25zdHJ1Y3RvcjtcbiAgICBpZiAoYXJyID09IG51bGwgfHwgdHlwZW9mIGFyciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IE1vbmdvb3NlRXJyb3IoJ1lvdSBjYW4gb25seSBhZGQgYW4gZW1iZWRkZWQgZGlzY3JpbWluYXRvciBvbiAnICtcbiAgICAgICAgJ2EgZG9jdW1lbnQgYXJyYXksICcgKyB0aGlzLnBhdGggKyAnIGlzIGEgcGxhaW4gYXJyYXknKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFyci5kaXNjcmltaW5hdG9yKC4uLmFyZ3MpO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFBcnJheS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucyk7XG4gIGNvbnN0IHNjaGVtYXR5cGUgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnBhdGgsIHRoaXMuY2FzdGVyLCBvcHRpb25zLCB0aGlzLnNjaGVtYU9wdGlvbnMpO1xuICBzY2hlbWF0eXBlLnZhbGlkYXRvcnMgPSB0aGlzLnZhbGlkYXRvcnMuc2xpY2UoKTtcbiAgaWYgKHRoaXMucmVxdWlyZWRWYWxpZGF0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgIHNjaGVtYXR5cGUucmVxdWlyZWRWYWxpZGF0b3IgPSB0aGlzLnJlcXVpcmVkVmFsaWRhdG9yO1xuICB9XG4gIHJldHVybiBzY2hlbWF0eXBlO1xufTtcblxuU2NoZW1hQXJyYXkucHJvdG90eXBlLl9jYXN0Rm9yUXVlcnkgPSBmdW5jdGlvbih2YWwsIGNvbnRleHQpIHtcbiAgbGV0IENvbnN0cnVjdG9yID0gdGhpcy5jYXN0ZXJDb25zdHJ1Y3RvcjtcblxuICBpZiAodmFsICYmXG4gICAgICBDb25zdHJ1Y3Rvci5kaXNjcmltaW5hdG9ycyAmJlxuICAgICAgQ29uc3RydWN0b3Iuc2NoZW1hICYmXG4gICAgICBDb25zdHJ1Y3Rvci5zY2hlbWEub3B0aW9ucyAmJlxuICAgICAgQ29uc3RydWN0b3Iuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleSkge1xuICAgIGlmICh0eXBlb2YgdmFsW0NvbnN0cnVjdG9yLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXldID09PSAnc3RyaW5nJyAmJlxuICAgICAgICBDb25zdHJ1Y3Rvci5kaXNjcmltaW5hdG9yc1t2YWxbQ29uc3RydWN0b3Iuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleV1dKSB7XG4gICAgICBDb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yLmRpc2NyaW1pbmF0b3JzW3ZhbFtDb25zdHJ1Y3Rvci5zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5XV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbnN0cnVjdG9yQnlWYWx1ZSA9IGdldERpc2NyaW1pbmF0b3JCeVZhbHVlKENvbnN0cnVjdG9yLmRpc2NyaW1pbmF0b3JzLCB2YWxbQ29uc3RydWN0b3Iuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleV0pO1xuICAgICAgaWYgKGNvbnN0cnVjdG9yQnlWYWx1ZSkge1xuICAgICAgICBDb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yQnlWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBwcm90byA9IHRoaXMuY2FzdGVyQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICBjb25zdCBwcm90b0Nhc3RGb3JRdWVyeSA9IHByb3RvICYmIHByb3RvLmNhc3RGb3JRdWVyeTtcbiAgY29uc3QgcHJvdG9DYXN0ID0gcHJvdG8gJiYgcHJvdG8uY2FzdDtcbiAgY29uc3QgY29uc3RydWN0b3JDYXN0Rm9yUXVlcnkgPSBDb25zdHJ1Y3Rvci5jYXN0Rm9yUXVlcnk7XG4gIGNvbnN0IGNhc3RlciA9IHRoaXMuY2FzdGVyO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICB0aGlzLnNldHRlcnMucmV2ZXJzZSgpLmZvckVhY2goc2V0dGVyID0+IHtcbiAgICAgIHZhbCA9IHNldHRlci5jYWxsKHRoaXMsIHZhbCwgdGhpcyk7XG4gICAgfSk7XG4gICAgdmFsID0gdmFsLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICBpZiAodXRpbHMuaXNPYmplY3QodikgJiYgdi4kZWxlbU1hdGNoKSB7XG4gICAgICAgIHJldHVybiB2O1xuICAgICAgfVxuICAgICAgaWYgKHByb3RvQ2FzdEZvclF1ZXJ5KSB7XG4gICAgICAgIHYgPSBwcm90b0Nhc3RGb3JRdWVyeS5jYWxsKGNhc3RlciwgbnVsbCwgdiwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB2O1xuICAgICAgfSBlbHNlIGlmIChwcm90b0Nhc3QpIHtcbiAgICAgICAgdiA9IHByb3RvQ2FzdC5jYWxsKGNhc3Rlciwgdik7XG4gICAgICAgIHJldHVybiB2O1xuICAgICAgfSBlbHNlIGlmIChjb25zdHJ1Y3RvckNhc3RGb3JRdWVyeSkge1xuICAgICAgICB2ID0gY29uc3RydWN0b3JDYXN0Rm9yUXVlcnkuY2FsbChjYXN0ZXIsIG51bGwsIHYsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH1cbiAgICAgIGlmICh2ICE9IG51bGwpIHtcbiAgICAgICAgdiA9IG5ldyBDb25zdHJ1Y3Rvcih2KTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9XG4gICAgICByZXR1cm4gdjtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChwcm90b0Nhc3RGb3JRdWVyeSkge1xuICAgIHZhbCA9IHByb3RvQ2FzdEZvclF1ZXJ5LmNhbGwoY2FzdGVyLCBudWxsLCB2YWwsIGNvbnRleHQpO1xuICB9IGVsc2UgaWYgKHByb3RvQ2FzdCkge1xuICAgIHZhbCA9IHByb3RvQ2FzdC5jYWxsKGNhc3RlciwgdmFsKTtcbiAgfSBlbHNlIGlmIChjb25zdHJ1Y3RvckNhc3RGb3JRdWVyeSkge1xuICAgIHZhbCA9IGNvbnN0cnVjdG9yQ2FzdEZvclF1ZXJ5LmNhbGwoY2FzdGVyLCBudWxsLCB2YWwsIGNvbnRleHQpO1xuICB9IGVsc2UgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgdmFsID0gbmV3IENvbnN0cnVjdG9yKHZhbCk7XG4gIH1cblxuICByZXR1cm4gdmFsO1xufTtcblxuLyoqXG4gKiBDYXN0cyB2YWx1ZXMgZm9yIHF1ZXJpZXMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9ICRjb25kaXRpb25hbFxuICogQHBhcmFtIHthbnl9IFt2YWx1ZV1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYUFycmF5LnByb3RvdHlwZS5jYXN0Rm9yUXVlcnkgPSBmdW5jdGlvbigkY29uZGl0aW9uYWwsIHZhbCwgY29udGV4dCkge1xuICBsZXQgaGFuZGxlcjtcblxuICBpZiAoJGNvbmRpdGlvbmFsICE9IG51bGwpIHtcbiAgICBoYW5kbGVyID0gdGhpcy4kY29uZGl0aW9uYWxIYW5kbGVyc1skY29uZGl0aW9uYWxdO1xuXG4gICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgdXNlICcgKyAkY29uZGl0aW9uYWwgKyAnIHdpdGggQXJyYXkuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhbmRsZXIuY2FsbCh0aGlzLCB2YWwsIGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLl9jYXN0Rm9yUXVlcnkodmFsLCBjb250ZXh0KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gY2FzdCRhbGwodmFsLCBjb250ZXh0KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgdmFsID0gW3ZhbF07XG4gIH1cblxuICB2YWwgPSB2YWwubWFwKCh2KSA9PiB7XG4gICAgaWYgKCF1dGlscy5pc09iamVjdCh2KSkge1xuICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIGlmICh2LiRlbGVtTWF0Y2ggIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHsgJGVsZW1NYXRjaDogY2FzdCh0aGlzLmNhc3RlckNvbnN0cnVjdG9yLnNjaGVtYSwgdi4kZWxlbU1hdGNoLCBudWxsLCB0aGlzICYmIHRoaXMuJCRjb250ZXh0KSB9O1xuICAgIH1cblxuICAgIGNvbnN0IG8gPSB7fTtcbiAgICBvW3RoaXMucGF0aF0gPSB2O1xuICAgIHJldHVybiBjYXN0KHRoaXMuY2FzdGVyQ29uc3RydWN0b3Iuc2NoZW1hLCBvLCBudWxsLCB0aGlzICYmIHRoaXMuJCRjb250ZXh0KVt0aGlzLnBhdGhdO1xuICB9LCB0aGlzKTtcblxuICByZXR1cm4gdGhpcy5jYXN0Rm9yUXVlcnkobnVsbCwgdmFsLCBjb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gY2FzdCRlbGVtTWF0Y2godmFsLCBjb250ZXh0KSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICBjb25zdCBudW1LZXlzID0ga2V5cy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtS2V5czsgKytpKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICBjb25zdCB2YWx1ZSA9IHZhbFtrZXldO1xuICAgIGlmIChpc09wZXJhdG9yKGtleSkgJiYgdmFsdWUgIT0gbnVsbCkge1xuICAgICAgdmFsW2tleV0gPSB0aGlzLmNhc3RGb3JRdWVyeShrZXksIHZhbHVlLCBjb250ZXh0KTtcbiAgICB9XG4gIH1cblxuICAvLyBJcyB0aGlzIGFuIGVtYmVkZGVkIGRpc2NyaW1pbmF0b3IgYW5kIGlzIHRoZSBkaXNjcmltaW5hdG9yIGtleSBzZXQ/XG4gIC8vIElmIHNvLCB1c2UgdGhlIGRpc2NyaW1pbmF0b3Igc2NoZW1hLiBTZWUgZ2gtNzQ0OVxuICBjb25zdCBkaXNjcmltaW5hdG9yS2V5ID0gdGhpcyAmJlxuICAgIHRoaXMuY2FzdGVyQ29uc3RydWN0b3IgJiZcbiAgICB0aGlzLmNhc3RlckNvbnN0cnVjdG9yLnNjaGVtYSAmJlxuICAgIHRoaXMuY2FzdGVyQ29uc3RydWN0b3Iuc2NoZW1hLm9wdGlvbnMgJiZcbiAgICB0aGlzLmNhc3RlckNvbnN0cnVjdG9yLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXk7XG4gIGNvbnN0IGRpc2NyaW1pbmF0b3JzID0gdGhpcyAmJlxuICB0aGlzLmNhc3RlckNvbnN0cnVjdG9yICYmXG4gIHRoaXMuY2FzdGVyQ29uc3RydWN0b3Iuc2NoZW1hICYmXG4gIHRoaXMuY2FzdGVyQ29uc3RydWN0b3Iuc2NoZW1hLmRpc2NyaW1pbmF0b3JzIHx8IHt9O1xuICBpZiAoZGlzY3JpbWluYXRvcktleSAhPSBudWxsICYmXG4gICAgICB2YWxbZGlzY3JpbWluYXRvcktleV0gIT0gbnVsbCAmJlxuICAgICAgZGlzY3JpbWluYXRvcnNbdmFsW2Rpc2NyaW1pbmF0b3JLZXldXSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIGNhc3QoZGlzY3JpbWluYXRvcnNbdmFsW2Rpc2NyaW1pbmF0b3JLZXldXSwgdmFsLCBudWxsLCB0aGlzICYmIHRoaXMuJCRjb250ZXh0KTtcbiAgfVxuICBjb25zdCBzY2hlbWEgPSB0aGlzLmNhc3RlckNvbnN0cnVjdG9yLnNjaGVtYSA/PyBjb250ZXh0LnNjaGVtYTtcbiAgcmV0dXJuIGNhc3Qoc2NoZW1hLCB2YWwsIG51bGwsIHRoaXMgJiYgdGhpcy4kJGNvbnRleHQpO1xufVxuXG5jb25zdCBoYW5kbGUgPSBTY2hlbWFBcnJheS5wcm90b3R5cGUuJGNvbmRpdGlvbmFsSGFuZGxlcnMgPSB7fTtcblxuaGFuZGxlLiRhbGwgPSBjYXN0JGFsbDtcbmhhbmRsZS4kb3B0aW9ucyA9IFN0cmluZztcbmhhbmRsZS4kZWxlbU1hdGNoID0gY2FzdCRlbGVtTWF0Y2g7XG5oYW5kbGUuJGdlb0ludGVyc2VjdHMgPSBnZW9zcGF0aWFsLmNhc3QkZ2VvSW50ZXJzZWN0cztcbmhhbmRsZS4kb3IgPSBjcmVhdGVMb2dpY2FsUXVlcnlPcGVyYXRvckhhbmRsZXIoJyRvcicpO1xuaGFuZGxlLiRhbmQgPSBjcmVhdGVMb2dpY2FsUXVlcnlPcGVyYXRvckhhbmRsZXIoJyRhbmQnKTtcbmhhbmRsZS4kbm9yID0gY3JlYXRlTG9naWNhbFF1ZXJ5T3BlcmF0b3JIYW5kbGVyKCckbm9yJyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvZ2ljYWxRdWVyeU9wZXJhdG9ySGFuZGxlcihvcCkge1xuICByZXR1cm4gZnVuY3Rpb24gbG9naWNhbFF1ZXJ5T3BlcmF0b3JIYW5kbGVyKHZhbCwgY29udGV4dCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjb25kaXRpb25hbCAnICsgb3AgKyAnIHJlcXVpcmVzIGFuIGFycmF5Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgcmV0ID0gW107XG4gICAgZm9yIChjb25zdCBvYmogb2YgdmFsKSB7XG4gICAgICByZXQucHVzaChjYXN0KHRoaXMuY2FzdGVyQ29uc3RydWN0b3Iuc2NoZW1hID8/IGNvbnRleHQuc2NoZW1hLCBvYmosIG51bGwsIHRoaXMgJiYgdGhpcy4kJGNvbnRleHQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9O1xufVxuXG5oYW5kbGUuJG5lYXIgPVxuaGFuZGxlLiRuZWFyU3BoZXJlID0gZ2Vvc3BhdGlhbC5jYXN0JG5lYXI7XG5cbmhhbmRsZS4kd2l0aGluID1cbmhhbmRsZS4kZ2VvV2l0aGluID0gZ2Vvc3BhdGlhbC5jYXN0JHdpdGhpbjtcblxuaGFuZGxlLiRzaXplID1cbmhhbmRsZS4kbWluRGlzdGFuY2UgPVxuaGFuZGxlLiRtYXhEaXN0YW5jZSA9IGNhc3RUb051bWJlcjtcblxuaGFuZGxlLiRleGlzdHMgPSAkZXhpc3RzO1xuaGFuZGxlLiR0eXBlID0gJHR5cGU7XG5cbmhhbmRsZS4kZXEgPVxuaGFuZGxlLiRndCA9XG5oYW5kbGUuJGd0ZSA9XG5oYW5kbGUuJGx0ID1cbmhhbmRsZS4kbHRlID1cbmhhbmRsZS4kbm90ID1cbmhhbmRsZS4kcmVnZXggPVxuaGFuZGxlLiRuZSA9IFNjaGVtYUFycmF5LnByb3RvdHlwZS5fY2FzdEZvclF1ZXJ5O1xuXG4vLyBgJGluYCBpcyBzcGVjaWFsIGJlY2F1c2UgeW91IGNhbiBhbHNvIGluY2x1ZGUgYW4gZW1wdHkgYXJyYXkgaW4gdGhlIHF1ZXJ5XG4vLyBsaWtlIGAkaW46IFsxLCBbXV1gLCBzZWUgZ2gtNTkxM1xuaGFuZGxlLiRuaW4gPSBTY2hlbWFUeXBlLnByb3RvdHlwZS4kY29uZGl0aW9uYWxIYW5kbGVycy4kbmluO1xuaGFuZGxlLiRpbiA9IFNjaGVtYVR5cGUucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzLiRpbjtcblxuLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYUFycmF5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/schema/array.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/schema/bigint.js":
/*!*************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/schema/bigint.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = __webpack_require__(/*! ../error/cast */ \"../backend/node_modules/mongoose/lib/error/cast.js\");\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"../backend/node_modules/mongoose/lib/schemaType.js\");\nconst castBigInt = __webpack_require__(/*! ../cast/bigint */ \"../backend/node_modules/mongoose/lib/cast/bigint.js\");\n\n/**\n * BigInt SchemaType constructor.\n *\n * @param {String} path\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaBigInt(path, options) {\n  SchemaType.call(this, path, options, 'BigInt');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaBigInt.schemaName = 'BigInt';\n\nSchemaBigInt.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaBigInt.prototype = Object.create(SchemaType.prototype);\nSchemaBigInt.prototype.constructor = SchemaBigInt;\n\n/*!\n * ignore\n */\n\nSchemaBigInt._cast = castBigInt;\n\n/**\n * Sets a default option for all BigInt instances.\n *\n * #### Example:\n *\n *     // Make all bigints required by default\n *     mongoose.Schema.BigInt.set('required', true);\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaBigInt.set = SchemaType.set;\n\nSchemaBigInt.setters = [];\n\n/**\n * Attaches a getter for all BigInt instances\n *\n * #### Example:\n *\n *     // Convert bigints to numbers\n *     mongoose.Schema.BigInt.get(v => v == null ? v : Number(v));\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaBigInt.get = SchemaType.get;\n\n/**\n * Get/set the function used to cast arbitrary values to booleans.\n *\n * #### Example:\n *\n *     // Make Mongoose cast empty string '' to false.\n *     const original = mongoose.Schema.BigInt.cast();\n *     mongoose.Schema.BigInt.cast(v => {\n *       if (v === '') {\n *         return false;\n *       }\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.Schema.BigInt.cast(false);\n *\n * @param {Function} caster\n * @return {Function}\n * @function get\n * @static\n * @api public\n */\n\nSchemaBigInt.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaBigInt._checkRequired = v => v != null;\n\n/**\n * Override the function the required validator uses to check whether a value\n * passes the `required` check.\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaBigInt.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator.\n *\n * @param {Any} value\n * @return {Boolean}\n * @api public\n */\n\nSchemaBigInt.prototype.checkRequired = function(value) {\n  return this.constructor._checkRequired(value);\n};\n\n/**\n * Casts to bigint\n *\n * @param {Object} value\n * @param {Object} model this value is optional\n * @api private\n */\n\nSchemaBigInt.prototype.cast = function(value) {\n  let castBigInt;\n  if (typeof this._castFunction === 'function') {\n    castBigInt = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castBigInt = this.constructor.cast();\n  } else {\n    castBigInt = SchemaBigInt.cast();\n  }\n\n  try {\n    return castBigInt(value);\n  } catch (error) {\n    throw new CastError('BigInt', value, this.path, error, this);\n  }\n};\n\n/*!\n * ignore\n */\n\nSchemaBigInt.$conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $lt: handleSingle,\n  $lte: handleSingle\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val, context) {\n  return this.castForQuery(null, val, context);\n}\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} val\n * @api private\n */\n\nSchemaBigInt.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = SchemaBigInt.$conditionalHandlers[$conditional];\n\n    if (handler) {\n      return handler.call(this, val);\n    }\n\n    return this.applySetters(null, val, context);\n  }\n\n  try {\n    return this.applySetters(val, context);\n  } catch (err) {\n    if (err instanceof CastError && err.path === this.path && this.$fullPath != null) {\n      err.path = this.$fullPath;\n    }\n    throw err;\n  }\n};\n\n/**\n *\n * @api private\n */\n\nSchemaBigInt.prototype._castNullish = function _castNullish(v) {\n  if (typeof v === 'undefined') {\n    return v;\n  }\n  const castBigInt = typeof this.constructor.cast === 'function' ?\n    this.constructor.cast() :\n    SchemaBigInt.cast();\n  if (castBigInt == null) {\n    return v;\n  }\n  return v;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaBigInt;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9iaWdpbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixtQkFBTyxDQUFDLHlFQUFlO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLHlFQUFlO0FBQzFDLG1CQUFtQixtQkFBTyxDQUFDLDJFQUFnQjs7QUFFM0M7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL2JpZ2ludC5qcz83YzUxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IENhc3RFcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL2Nhc3QnKTtcbmNvbnN0IFNjaGVtYVR5cGUgPSByZXF1aXJlKCcuLi9zY2hlbWFUeXBlJyk7XG5jb25zdCBjYXN0QmlnSW50ID0gcmVxdWlyZSgnLi4vY2FzdC9iaWdpbnQnKTtcblxuLyoqXG4gKiBCaWdJbnQgU2NoZW1hVHlwZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBpbmhlcml0cyBTY2hlbWFUeXBlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNjaGVtYUJpZ0ludChwYXRoLCBvcHRpb25zKSB7XG4gIFNjaGVtYVR5cGUuY2FsbCh0aGlzLCBwYXRoLCBvcHRpb25zLCAnQmlnSW50Jyk7XG59XG5cbi8qKlxuICogVGhpcyBzY2hlbWEgdHlwZSdzIG5hbWUsIHRvIGRlZmVuZCBhZ2FpbnN0IG1pbmlmaWVycyB0aGF0IG1hbmdsZVxuICogZnVuY3Rpb24gbmFtZXMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuU2NoZW1hQmlnSW50LnNjaGVtYU5hbWUgPSAnQmlnSW50JztcblxuU2NoZW1hQmlnSW50LmRlZmF1bHRPcHRpb25zID0ge307XG5cbi8qIVxuICogSW5oZXJpdHMgZnJvbSBTY2hlbWFUeXBlLlxuICovXG5TY2hlbWFCaWdJbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTY2hlbWFUeXBlLnByb3RvdHlwZSk7XG5TY2hlbWFCaWdJbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2NoZW1hQmlnSW50O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYUJpZ0ludC5fY2FzdCA9IGNhc3RCaWdJbnQ7XG5cbi8qKlxuICogU2V0cyBhIGRlZmF1bHQgb3B0aW9uIGZvciBhbGwgQmlnSW50IGluc3RhbmNlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1ha2UgYWxsIGJpZ2ludHMgcmVxdWlyZWQgYnkgZGVmYXVsdFxuICogICAgIG1vbmdvb3NlLlNjaGVtYS5CaWdJbnQuc2V0KCdyZXF1aXJlZCcsIHRydWUpO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb24gVGhlIG9wdGlvbiB5b3UnZCBsaWtlIHRvIHNldCB0aGUgdmFsdWUgZm9yXG4gKiBAcGFyYW0ge0FueX0gdmFsdWUgdmFsdWUgZm9yIG9wdGlvblxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICogQGZ1bmN0aW9uIHNldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFCaWdJbnQuc2V0ID0gU2NoZW1hVHlwZS5zZXQ7XG5cblNjaGVtYUJpZ0ludC5zZXR0ZXJzID0gW107XG5cbi8qKlxuICogQXR0YWNoZXMgYSBnZXR0ZXIgZm9yIGFsbCBCaWdJbnQgaW5zdGFuY2VzXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBDb252ZXJ0IGJpZ2ludHMgdG8gbnVtYmVyc1xuICogICAgIG1vbmdvb3NlLlNjaGVtYS5CaWdJbnQuZ2V0KHYgPT4gdiA9PSBudWxsID8gdiA6IE51bWJlcih2KSk7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyXG4gKiBAcmV0dXJuIHt0aGlzfVxuICogQGZ1bmN0aW9uIGdldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFCaWdJbnQuZ2V0ID0gU2NoZW1hVHlwZS5nZXQ7XG5cbi8qKlxuICogR2V0L3NldCB0aGUgZnVuY3Rpb24gdXNlZCB0byBjYXN0IGFyYml0cmFyeSB2YWx1ZXMgdG8gYm9vbGVhbnMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYWtlIE1vbmdvb3NlIGNhc3QgZW1wdHkgc3RyaW5nICcnIHRvIGZhbHNlLlxuICogICAgIGNvbnN0IG9yaWdpbmFsID0gbW9uZ29vc2UuU2NoZW1hLkJpZ0ludC5jYXN0KCk7XG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLkJpZ0ludC5jYXN0KHYgPT4ge1xuICogICAgICAgaWYgKHYgPT09ICcnKSB7XG4gKiAgICAgICAgIHJldHVybiBmYWxzZTtcbiAqICAgICAgIH1cbiAqICAgICAgIHJldHVybiBvcmlnaW5hbCh2KTtcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gT3IgZGlzYWJsZSBjYXN0aW5nIGVudGlyZWx5XG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLkJpZ0ludC5jYXN0KGZhbHNlKTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYXN0ZXJcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGZ1bmN0aW9uIGdldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFCaWdJbnQuY2FzdCA9IGZ1bmN0aW9uIGNhc3QoY2FzdGVyKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nhc3Q7XG4gIH1cbiAgaWYgKGNhc3RlciA9PT0gZmFsc2UpIHtcbiAgICBjYXN0ZXIgPSB0aGlzLl9kZWZhdWx0Q2FzdGVyO1xuICB9XG4gIHRoaXMuX2Nhc3QgPSBjYXN0ZXI7XG5cbiAgcmV0dXJuIHRoaXMuX2Nhc3Q7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYUJpZ0ludC5fY2hlY2tSZXF1aXJlZCA9IHYgPT4gdiAhPSBudWxsO1xuXG4vKipcbiAqIE92ZXJyaWRlIHRoZSBmdW5jdGlvbiB0aGUgcmVxdWlyZWQgdmFsaWRhdG9yIHVzZXMgdG8gY2hlY2sgd2hldGhlciBhIHZhbHVlXG4gKiBwYXNzZXMgdGhlIGByZXF1aXJlZGAgY2hlY2suXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGZ1bmN0aW9uIGNoZWNrUmVxdWlyZWRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hQmlnSW50LmNoZWNrUmVxdWlyZWQgPSBTY2hlbWFUeXBlLmNoZWNrUmVxdWlyZWQ7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIHNhdGlzZmllcyBhIHJlcXVpcmVkIHZhbGlkYXRvci5cbiAqXG4gKiBAcGFyYW0ge0FueX0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYUJpZ0ludC5wcm90b3R5cGUuY2hlY2tSZXF1aXJlZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLl9jaGVja1JlcXVpcmVkKHZhbHVlKTtcbn07XG5cbi8qKlxuICogQ2FzdHMgdG8gYmlnaW50XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gbW9kZWwgdGhpcyB2YWx1ZSBpcyBvcHRpb25hbFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hQmlnSW50LnByb3RvdHlwZS5jYXN0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgbGV0IGNhc3RCaWdJbnQ7XG4gIGlmICh0eXBlb2YgdGhpcy5fY2FzdEZ1bmN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FzdEJpZ0ludCA9IHRoaXMuX2Nhc3RGdW5jdGlvbjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5jb25zdHJ1Y3Rvci5jYXN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FzdEJpZ0ludCA9IHRoaXMuY29uc3RydWN0b3IuY2FzdCgpO1xuICB9IGVsc2Uge1xuICAgIGNhc3RCaWdJbnQgPSBTY2hlbWFCaWdJbnQuY2FzdCgpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gY2FzdEJpZ0ludCh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IENhc3RFcnJvcignQmlnSW50JywgdmFsdWUsIHRoaXMucGF0aCwgZXJyb3IsIHRoaXMpO1xuICB9XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYUJpZ0ludC4kY29uZGl0aW9uYWxIYW5kbGVycyA9IHtcbiAgLi4uU2NoZW1hVHlwZS5wcm90b3R5cGUuJGNvbmRpdGlvbmFsSGFuZGxlcnMsXG4gICRndDogaGFuZGxlU2luZ2xlLFxuICAkZ3RlOiBoYW5kbGVTaW5nbGUsXG4gICRsdDogaGFuZGxlU2luZ2xlLFxuICAkbHRlOiBoYW5kbGVTaW5nbGVcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gaGFuZGxlU2luZ2xlKHZhbCwgY29udGV4dCkge1xuICByZXR1cm4gdGhpcy5jYXN0Rm9yUXVlcnkobnVsbCwgdmFsLCBjb250ZXh0KTtcbn1cblxuLyoqXG4gKiBDYXN0cyBjb250ZW50cyBmb3IgcXVlcmllcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gJGNvbmRpdGlvbmFsXG4gKiBAcGFyYW0ge2FueX0gdmFsXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFCaWdJbnQucHJvdG90eXBlLmNhc3RGb3JRdWVyeSA9IGZ1bmN0aW9uKCRjb25kaXRpb25hbCwgdmFsLCBjb250ZXh0KSB7XG4gIGxldCBoYW5kbGVyO1xuICBpZiAoJGNvbmRpdGlvbmFsICE9IG51bGwpIHtcbiAgICBoYW5kbGVyID0gU2NoZW1hQmlnSW50LiRjb25kaXRpb25hbEhhbmRsZXJzWyRjb25kaXRpb25hbF07XG5cbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgcmV0dXJuIGhhbmRsZXIuY2FsbCh0aGlzLCB2YWwpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFwcGx5U2V0dGVycyhudWxsLCB2YWwsIGNvbnRleHQpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5hcHBseVNldHRlcnModmFsLCBjb250ZXh0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIENhc3RFcnJvciAmJiBlcnIucGF0aCA9PT0gdGhpcy5wYXRoICYmIHRoaXMuJGZ1bGxQYXRoICE9IG51bGwpIHtcbiAgICAgIGVyci5wYXRoID0gdGhpcy4kZnVsbFBhdGg7XG4gICAgfVxuICAgIHRocm93IGVycjtcbiAgfVxufTtcblxuLyoqXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hQmlnSW50LnByb3RvdHlwZS5fY2FzdE51bGxpc2ggPSBmdW5jdGlvbiBfY2FzdE51bGxpc2godikge1xuICBpZiAodHlwZW9mIHYgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHY7XG4gIH1cbiAgY29uc3QgY2FzdEJpZ0ludCA9IHR5cGVvZiB0aGlzLmNvbnN0cnVjdG9yLmNhc3QgPT09ICdmdW5jdGlvbicgP1xuICAgIHRoaXMuY29uc3RydWN0b3IuY2FzdCgpIDpcbiAgICBTY2hlbWFCaWdJbnQuY2FzdCgpO1xuICBpZiAoY2FzdEJpZ0ludCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHY7XG4gIH1cbiAgcmV0dXJuIHY7XG59O1xuXG4vKiFcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hQmlnSW50O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/schema/bigint.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/schema/boolean.js":
/*!**************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/schema/boolean.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = __webpack_require__(/*! ../error/cast */ \"../backend/node_modules/mongoose/lib/error/cast.js\");\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"../backend/node_modules/mongoose/lib/schemaType.js\");\nconst castBoolean = __webpack_require__(/*! ../cast/boolean */ \"../backend/node_modules/mongoose/lib/cast/boolean.js\");\n\n/**\n * Boolean SchemaType constructor.\n *\n * @param {String} path\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaBoolean(path, options) {\n  SchemaType.call(this, path, options, 'Boolean');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaBoolean.schemaName = 'Boolean';\n\nSchemaBoolean.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaBoolean.prototype = Object.create(SchemaType.prototype);\nSchemaBoolean.prototype.constructor = SchemaBoolean;\n\n/*!\n * ignore\n */\n\nSchemaBoolean._cast = castBoolean;\n\n/**\n * Sets a default option for all Boolean instances.\n *\n * #### Example:\n *\n *     // Make all booleans have `default` of false.\n *     mongoose.Schema.Boolean.set('default', false);\n *\n *     const Order = mongoose.model('Order', new Schema({ isPaid: Boolean }));\n *     new Order({ }).isPaid; // false\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaBoolean.set = SchemaType.set;\n\nSchemaBoolean.setters = [];\n\n/**\n * Attaches a getter for all Boolean instances\n *\n * #### Example:\n *\n *     mongoose.Schema.Boolean.get(v => v === true ? 'yes' : 'no');\n *\n *     const Order = mongoose.model('Order', new Schema({ isPaid: Boolean }));\n *     new Order({ isPaid: false }).isPaid; // 'no'\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaBoolean.get = SchemaType.get;\n\n/**\n * Get/set the function used to cast arbitrary values to booleans.\n *\n * #### Example:\n *\n *     // Make Mongoose cast empty string '' to false.\n *     const original = mongoose.Schema.Boolean.cast();\n *     mongoose.Schema.Boolean.cast(v => {\n *       if (v === '') {\n *         return false;\n *       }\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.Schema.Boolean.cast(false);\n *\n * @param {Function} caster\n * @return {Function}\n * @function get\n * @static\n * @api public\n */\n\nSchemaBoolean.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaBoolean._defaultCaster = v => {\n  if (v != null && typeof v !== 'boolean') {\n    throw new Error();\n  }\n  return v;\n};\n\n/*!\n * ignore\n */\n\nSchemaBoolean._checkRequired = v => v === true || v === false;\n\n/**\n * Override the function the required validator uses to check whether a boolean\n * passes the `required` check.\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaBoolean.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator. For a boolean\n * to satisfy a required validator, it must be strictly equal to true or to\n * false.\n *\n * @param {Any} value\n * @return {Boolean}\n * @api public\n */\n\nSchemaBoolean.prototype.checkRequired = function(value) {\n  return this.constructor._checkRequired(value);\n};\n\n/**\n * Configure which values get casted to `true`.\n *\n * #### Example:\n *\n *     const M = mongoose.model('Test', new Schema({ b: Boolean }));\n *     new M({ b: 'affirmative' }).b; // undefined\n *     mongoose.Schema.Boolean.convertToTrue.add('affirmative');\n *     new M({ b: 'affirmative' }).b; // true\n *\n * @property convertToTrue\n * @static\n * @memberOf SchemaBoolean\n * @type {Set}\n * @api public\n */\n\nObject.defineProperty(SchemaBoolean, 'convertToTrue', {\n  get: () => castBoolean.convertToTrue,\n  set: v => { castBoolean.convertToTrue = v; }\n});\n\n/**\n * Configure which values get casted to `false`.\n *\n * #### Example:\n *\n *     const M = mongoose.model('Test', new Schema({ b: Boolean }));\n *     new M({ b: 'nay' }).b; // undefined\n *     mongoose.Schema.Types.Boolean.convertToFalse.add('nay');\n *     new M({ b: 'nay' }).b; // false\n *\n * @property convertToFalse\n * @static\n * @memberOf SchemaBoolean\n * @type {Set}\n * @api public\n */\n\nObject.defineProperty(SchemaBoolean, 'convertToFalse', {\n  get: () => castBoolean.convertToFalse,\n  set: v => { castBoolean.convertToFalse = v; }\n});\n\n/**\n * Casts to boolean\n *\n * @param {Object} value\n * @param {Object} model this value is optional\n * @api private\n */\n\nSchemaBoolean.prototype.cast = function(value) {\n  let castBoolean;\n  if (typeof this._castFunction === 'function') {\n    castBoolean = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castBoolean = this.constructor.cast();\n  } else {\n    castBoolean = SchemaBoolean.cast();\n  }\n\n  try {\n    return castBoolean(value);\n  } catch (error) {\n    throw new CastError('Boolean', value, this.path, error, this);\n  }\n};\n\nSchemaBoolean.$conditionalHandlers = { ...SchemaType.prototype.$conditionalHandlers };\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} val\n * @api private\n */\n\nSchemaBoolean.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = SchemaBoolean.$conditionalHandlers[$conditional];\n\n    if (handler) {\n      return handler.call(this, val);\n    }\n\n    return this.applySetters(null, val, context);\n  }\n\n  try {\n    return this.applySetters(val, context);\n  } catch (err) {\n    if (err instanceof CastError && err.path === this.path && this.$fullPath != null) {\n      err.path = this.$fullPath;\n    }\n    throw err;\n  }\n};\n\n/**\n *\n * @api private\n */\n\nSchemaBoolean.prototype._castNullish = function _castNullish(v) {\n  if (typeof v === 'undefined') {\n    return v;\n  }\n  const castBoolean = typeof this.constructor.cast === 'function' ?\n    this.constructor.cast() :\n    SchemaBoolean.cast();\n  if (castBoolean == null) {\n    return v;\n  }\n  if (castBoolean.convertToFalse instanceof Set && castBoolean.convertToFalse.has(v)) {\n    return false;\n  }\n  if (castBoolean.convertToTrue instanceof Set && castBoolean.convertToTrue.has(v)) {\n    return true;\n  }\n  return v;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaBoolean;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9ib29sZWFuLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsbUJBQU8sQ0FBQyx5RUFBZTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyx5RUFBZTtBQUMxQyxvQkFBb0IsbUJBQU8sQ0FBQyw2RUFBaUI7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGlCQUFpQjtBQUMzRSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGlCQUFpQjtBQUMzRSxtQkFBbUIsZUFBZSxVQUFVO0FBQzVDO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxZQUFZO0FBQ2pFLGVBQWUsa0JBQWtCLEtBQUs7QUFDdEM7QUFDQSxlQUFlLGtCQUFrQixLQUFLO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsWUFBWTtBQUNqRSxlQUFlLFVBQVUsS0FBSztBQUM5QjtBQUNBLGVBQWUsVUFBVSxLQUFLO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL2Jvb2xlYW4uanM/MzFjMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG5jb25zdCBDYXN0RXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci9jYXN0Jyk7XG5jb25zdCBTY2hlbWFUeXBlID0gcmVxdWlyZSgnLi4vc2NoZW1hVHlwZScpO1xuY29uc3QgY2FzdEJvb2xlYW4gPSByZXF1aXJlKCcuLi9jYXN0L2Jvb2xlYW4nKTtcblxuLyoqXG4gKiBCb29sZWFuIFNjaGVtYVR5cGUgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAaW5oZXJpdHMgU2NoZW1hVHlwZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTY2hlbWFCb29sZWFuKHBhdGgsIG9wdGlvbnMpIHtcbiAgU2NoZW1hVHlwZS5jYWxsKHRoaXMsIHBhdGgsIG9wdGlvbnMsICdCb29sZWFuJyk7XG59XG5cbi8qKlxuICogVGhpcyBzY2hlbWEgdHlwZSdzIG5hbWUsIHRvIGRlZmVuZCBhZ2FpbnN0IG1pbmlmaWVycyB0aGF0IG1hbmdsZVxuICogZnVuY3Rpb24gbmFtZXMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuU2NoZW1hQm9vbGVhbi5zY2hlbWFOYW1lID0gJ0Jvb2xlYW4nO1xuXG5TY2hlbWFCb29sZWFuLmRlZmF1bHRPcHRpb25zID0ge307XG5cbi8qIVxuICogSW5oZXJpdHMgZnJvbSBTY2hlbWFUeXBlLlxuICovXG5TY2hlbWFCb29sZWFuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU2NoZW1hVHlwZS5wcm90b3R5cGUpO1xuU2NoZW1hQm9vbGVhbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTY2hlbWFCb29sZWFuO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYUJvb2xlYW4uX2Nhc3QgPSBjYXN0Qm9vbGVhbjtcblxuLyoqXG4gKiBTZXRzIGEgZGVmYXVsdCBvcHRpb24gZm9yIGFsbCBCb29sZWFuIGluc3RhbmNlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1ha2UgYWxsIGJvb2xlYW5zIGhhdmUgYGRlZmF1bHRgIG9mIGZhbHNlLlxuICogICAgIG1vbmdvb3NlLlNjaGVtYS5Cb29sZWFuLnNldCgnZGVmYXVsdCcsIGZhbHNlKTtcbiAqXG4gKiAgICAgY29uc3QgT3JkZXIgPSBtb25nb29zZS5tb2RlbCgnT3JkZXInLCBuZXcgU2NoZW1hKHsgaXNQYWlkOiBCb29sZWFuIH0pKTtcbiAqICAgICBuZXcgT3JkZXIoeyB9KS5pc1BhaWQ7IC8vIGZhbHNlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbiBUaGUgb3B0aW9uIHlvdSdkIGxpa2UgdG8gc2V0IHRoZSB2YWx1ZSBmb3JcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZSB2YWx1ZSBmb3Igb3B0aW9uXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gKiBAZnVuY3Rpb24gc2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYUJvb2xlYW4uc2V0ID0gU2NoZW1hVHlwZS5zZXQ7XG5cblNjaGVtYUJvb2xlYW4uc2V0dGVycyA9IFtdO1xuXG4vKipcbiAqIEF0dGFjaGVzIGEgZ2V0dGVyIGZvciBhbGwgQm9vbGVhbiBpbnN0YW5jZXNcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIG1vbmdvb3NlLlNjaGVtYS5Cb29sZWFuLmdldCh2ID0+IHYgPT09IHRydWUgPyAneWVzJyA6ICdubycpO1xuICpcbiAqICAgICBjb25zdCBPcmRlciA9IG1vbmdvb3NlLm1vZGVsKCdPcmRlcicsIG5ldyBTY2hlbWEoeyBpc1BhaWQ6IEJvb2xlYW4gfSkpO1xuICogICAgIG5ldyBPcmRlcih7IGlzUGFpZDogZmFsc2UgfSkuaXNQYWlkOyAvLyAnbm8nXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyXG4gKiBAcmV0dXJuIHt0aGlzfVxuICogQGZ1bmN0aW9uIGdldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFCb29sZWFuLmdldCA9IFNjaGVtYVR5cGUuZ2V0O1xuXG4vKipcbiAqIEdldC9zZXQgdGhlIGZ1bmN0aW9uIHVzZWQgdG8gY2FzdCBhcmJpdHJhcnkgdmFsdWVzIHRvIGJvb2xlYW5zLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTWFrZSBNb25nb29zZSBjYXN0IGVtcHR5IHN0cmluZyAnJyB0byBmYWxzZS5cbiAqICAgICBjb25zdCBvcmlnaW5hbCA9IG1vbmdvb3NlLlNjaGVtYS5Cb29sZWFuLmNhc3QoKTtcbiAqICAgICBtb25nb29zZS5TY2hlbWEuQm9vbGVhbi5jYXN0KHYgPT4ge1xuICogICAgICAgaWYgKHYgPT09ICcnKSB7XG4gKiAgICAgICAgIHJldHVybiBmYWxzZTtcbiAqICAgICAgIH1cbiAqICAgICAgIHJldHVybiBvcmlnaW5hbCh2KTtcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gT3IgZGlzYWJsZSBjYXN0aW5nIGVudGlyZWx5XG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLkJvb2xlYW4uY2FzdChmYWxzZSk7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FzdGVyXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBmdW5jdGlvbiBnZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hQm9vbGVhbi5jYXN0ID0gZnVuY3Rpb24gY2FzdChjYXN0ZXIpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5fY2FzdDtcbiAgfVxuICBpZiAoY2FzdGVyID09PSBmYWxzZSkge1xuICAgIGNhc3RlciA9IHRoaXMuX2RlZmF1bHRDYXN0ZXI7XG4gIH1cbiAgdGhpcy5fY2FzdCA9IGNhc3RlcjtcblxuICByZXR1cm4gdGhpcy5fY2FzdDtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hQm9vbGVhbi5fZGVmYXVsdENhc3RlciA9IHYgPT4ge1xuICBpZiAodiAhPSBudWxsICYmIHR5cGVvZiB2ICE9PSAnYm9vbGVhbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgfVxuICByZXR1cm4gdjtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hQm9vbGVhbi5fY2hlY2tSZXF1aXJlZCA9IHYgPT4gdiA9PT0gdHJ1ZSB8fCB2ID09PSBmYWxzZTtcblxuLyoqXG4gKiBPdmVycmlkZSB0aGUgZnVuY3Rpb24gdGhlIHJlcXVpcmVkIHZhbGlkYXRvciB1c2VzIHRvIGNoZWNrIHdoZXRoZXIgYSBib29sZWFuXG4gKiBwYXNzZXMgdGhlIGByZXF1aXJlZGAgY2hlY2suXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGZ1bmN0aW9uIGNoZWNrUmVxdWlyZWRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hQm9vbGVhbi5jaGVja1JlcXVpcmVkID0gU2NoZW1hVHlwZS5jaGVja1JlcXVpcmVkO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBzYXRpc2ZpZXMgYSByZXF1aXJlZCB2YWxpZGF0b3IuIEZvciBhIGJvb2xlYW5cbiAqIHRvIHNhdGlzZnkgYSByZXF1aXJlZCB2YWxpZGF0b3IsIGl0IG11c3QgYmUgc3RyaWN0bHkgZXF1YWwgdG8gdHJ1ZSBvciB0b1xuICogZmFsc2UuXG4gKlxuICogQHBhcmFtIHtBbnl9IHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFCb29sZWFuLnByb3RvdHlwZS5jaGVja1JlcXVpcmVkID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuX2NoZWNrUmVxdWlyZWQodmFsdWUpO1xufTtcblxuLyoqXG4gKiBDb25maWd1cmUgd2hpY2ggdmFsdWVzIGdldCBjYXN0ZWQgdG8gYHRydWVgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgTSA9IG1vbmdvb3NlLm1vZGVsKCdUZXN0JywgbmV3IFNjaGVtYSh7IGI6IEJvb2xlYW4gfSkpO1xuICogICAgIG5ldyBNKHsgYjogJ2FmZmlybWF0aXZlJyB9KS5iOyAvLyB1bmRlZmluZWRcbiAqICAgICBtb25nb29zZS5TY2hlbWEuQm9vbGVhbi5jb252ZXJ0VG9UcnVlLmFkZCgnYWZmaXJtYXRpdmUnKTtcbiAqICAgICBuZXcgTSh7IGI6ICdhZmZpcm1hdGl2ZScgfSkuYjsgLy8gdHJ1ZVxuICpcbiAqIEBwcm9wZXJ0eSBjb252ZXJ0VG9UcnVlXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgU2NoZW1hQm9vbGVhblxuICogQHR5cGUge1NldH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYUJvb2xlYW4sICdjb252ZXJ0VG9UcnVlJywge1xuICBnZXQ6ICgpID0+IGNhc3RCb29sZWFuLmNvbnZlcnRUb1RydWUsXG4gIHNldDogdiA9PiB7IGNhc3RCb29sZWFuLmNvbnZlcnRUb1RydWUgPSB2OyB9XG59KTtcblxuLyoqXG4gKiBDb25maWd1cmUgd2hpY2ggdmFsdWVzIGdldCBjYXN0ZWQgdG8gYGZhbHNlYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IE0gPSBtb25nb29zZS5tb2RlbCgnVGVzdCcsIG5ldyBTY2hlbWEoeyBiOiBCb29sZWFuIH0pKTtcbiAqICAgICBuZXcgTSh7IGI6ICduYXknIH0pLmI7IC8vIHVuZGVmaW5lZFxuICogICAgIG1vbmdvb3NlLlNjaGVtYS5UeXBlcy5Cb29sZWFuLmNvbnZlcnRUb0ZhbHNlLmFkZCgnbmF5Jyk7XG4gKiAgICAgbmV3IE0oeyBiOiAnbmF5JyB9KS5iOyAvLyBmYWxzZVxuICpcbiAqIEBwcm9wZXJ0eSBjb252ZXJ0VG9GYWxzZVxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIFNjaGVtYUJvb2xlYW5cbiAqIEB0eXBlIHtTZXR9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2hlbWFCb29sZWFuLCAnY29udmVydFRvRmFsc2UnLCB7XG4gIGdldDogKCkgPT4gY2FzdEJvb2xlYW4uY29udmVydFRvRmFsc2UsXG4gIHNldDogdiA9PiB7IGNhc3RCb29sZWFuLmNvbnZlcnRUb0ZhbHNlID0gdjsgfVxufSk7XG5cbi8qKlxuICogQ2FzdHMgdG8gYm9vbGVhblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IG1vZGVsIHRoaXMgdmFsdWUgaXMgb3B0aW9uYWxcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYUJvb2xlYW4ucHJvdG90eXBlLmNhc3QgPSBmdW5jdGlvbih2YWx1ZSkge1xuICBsZXQgY2FzdEJvb2xlYW47XG4gIGlmICh0eXBlb2YgdGhpcy5fY2FzdEZ1bmN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FzdEJvb2xlYW4gPSB0aGlzLl9jYXN0RnVuY3Rpb247XG4gIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuY29uc3RydWN0b3IuY2FzdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhc3RCb29sZWFuID0gdGhpcy5jb25zdHJ1Y3Rvci5jYXN0KCk7XG4gIH0gZWxzZSB7XG4gICAgY2FzdEJvb2xlYW4gPSBTY2hlbWFCb29sZWFuLmNhc3QoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGNhc3RCb29sZWFuKHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdCb29sZWFuJywgdmFsdWUsIHRoaXMucGF0aCwgZXJyb3IsIHRoaXMpO1xuICB9XG59O1xuXG5TY2hlbWFCb29sZWFuLiRjb25kaXRpb25hbEhhbmRsZXJzID0geyAuLi5TY2hlbWFUeXBlLnByb3RvdHlwZS4kY29uZGl0aW9uYWxIYW5kbGVycyB9O1xuXG4vKipcbiAqIENhc3RzIGNvbnRlbnRzIGZvciBxdWVyaWVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSAkY29uZGl0aW9uYWxcbiAqIEBwYXJhbSB7YW55fSB2YWxcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYUJvb2xlYW4ucHJvdG90eXBlLmNhc3RGb3JRdWVyeSA9IGZ1bmN0aW9uKCRjb25kaXRpb25hbCwgdmFsLCBjb250ZXh0KSB7XG4gIGxldCBoYW5kbGVyO1xuICBpZiAoJGNvbmRpdGlvbmFsICE9IG51bGwpIHtcbiAgICBoYW5kbGVyID0gU2NoZW1hQm9vbGVhbi4kY29uZGl0aW9uYWxIYW5kbGVyc1skY29uZGl0aW9uYWxdO1xuXG4gICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgdmFsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5hcHBseVNldHRlcnMobnVsbCwgdmFsLCBjb250ZXh0KTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuYXBwbHlTZXR0ZXJzKHZhbCwgY29udGV4dCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBDYXN0RXJyb3IgJiYgZXJyLnBhdGggPT09IHRoaXMucGF0aCAmJiB0aGlzLiRmdWxsUGF0aCAhPSBudWxsKSB7XG4gICAgICBlcnIucGF0aCA9IHRoaXMuJGZ1bGxQYXRoO1xuICAgIH1cbiAgICB0aHJvdyBlcnI7XG4gIH1cbn07XG5cbi8qKlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYUJvb2xlYW4ucHJvdG90eXBlLl9jYXN0TnVsbGlzaCA9IGZ1bmN0aW9uIF9jYXN0TnVsbGlzaCh2KSB7XG4gIGlmICh0eXBlb2YgdiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gdjtcbiAgfVxuICBjb25zdCBjYXN0Qm9vbGVhbiA9IHR5cGVvZiB0aGlzLmNvbnN0cnVjdG9yLmNhc3QgPT09ICdmdW5jdGlvbicgP1xuICAgIHRoaXMuY29uc3RydWN0b3IuY2FzdCgpIDpcbiAgICBTY2hlbWFCb29sZWFuLmNhc3QoKTtcbiAgaWYgKGNhc3RCb29sZWFuID09IG51bGwpIHtcbiAgICByZXR1cm4gdjtcbiAgfVxuICBpZiAoY2FzdEJvb2xlYW4uY29udmVydFRvRmFsc2UgaW5zdGFuY2VvZiBTZXQgJiYgY2FzdEJvb2xlYW4uY29udmVydFRvRmFsc2UuaGFzKHYpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChjYXN0Qm9vbGVhbi5jb252ZXJ0VG9UcnVlIGluc3RhbmNlb2YgU2V0ICYmIGNhc3RCb29sZWFuLmNvbnZlcnRUb1RydWUuaGFzKHYpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHY7XG59O1xuXG4vKiFcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hQm9vbGVhbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/schema/boolean.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/schema/buffer.js":
/*!*************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/schema/buffer.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseBuffer = __webpack_require__(/*! ../types/buffer */ \"../backend/node_modules/mongoose/lib/types/buffer.js\");\nconst SchemaBufferOptions = __webpack_require__(/*! ../options/schemaBufferOptions */ \"../backend/node_modules/mongoose/lib/options/schemaBufferOptions.js\");\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"../backend/node_modules/mongoose/lib/schemaType.js\");\nconst handleBitwiseOperator = __webpack_require__(/*! ./operators/bitwise */ \"../backend/node_modules/mongoose/lib/schema/operators/bitwise.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\n\nconst Binary = MongooseBuffer.Binary;\nconst CastError = SchemaType.CastError;\n\n/**\n * Buffer SchemaType constructor\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaBuffer(key, options) {\n  SchemaType.call(this, key, options, 'Buffer');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaBuffer.schemaName = 'Buffer';\n\nSchemaBuffer.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaBuffer.prototype = Object.create(SchemaType.prototype);\nSchemaBuffer.prototype.constructor = SchemaBuffer;\nSchemaBuffer.prototype.OptionsConstructor = SchemaBufferOptions;\n\n/*!\n * ignore\n */\n\nSchemaBuffer._checkRequired = v => !!(v && v.length);\n\n/**\n * Sets a default option for all Buffer instances.\n *\n * #### Example:\n *\n *     // Make all buffers have `required` of true by default.\n *     mongoose.Schema.Buffer.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: Buffer }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaBuffer.set = SchemaType.set;\n\nSchemaBuffer.setters = [];\n\n/**\n * Attaches a getter for all Buffer instances\n *\n * #### Example:\n *\n *     // Always convert to string when getting an ObjectId\n *     mongoose.Schema.Types.Buffer.get(v => v.toString('hex'));\n *\n *     const Model = mongoose.model('Test', new Schema({ buf: Buffer } }));\n *     typeof (new Model({ buf: Buffer.fromString('hello') }).buf); // 'string'\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaBuffer.get = SchemaType.get;\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * #### Example:\n *\n *     // Allow empty strings to pass `required` check\n *     mongoose.Schema.Types.String.checkRequired(v => v != null);\n *\n *     const M = mongoose.model({ buf: { type: Buffer, required: true } });\n *     new M({ buf: Buffer.from('') }).validateSync(); // validation passes!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaBuffer.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator. To satisfy a\n * required validator, a buffer must not be null or undefined and have\n * non-zero length.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaBuffer.prototype.checkRequired = function(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n  return this.constructor._checkRequired(value);\n};\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init\n * @api private\n */\n\nSchemaBuffer.prototype.cast = function(value, doc, init) {\n  let ret;\n  if (SchemaType._isRef(this, value, doc, init)) {\n    if (value && value.isMongooseBuffer) {\n      return value;\n    }\n\n    if (Buffer.isBuffer(value)) {\n      if (!value || !value.isMongooseBuffer) {\n        value = new MongooseBuffer(value, [this.path, doc]);\n        if (this.options.subtype != null) {\n          value._subtype = this.options.subtype;\n        }\n      }\n      return value;\n    }\n\n    if (value instanceof Binary) {\n      ret = new MongooseBuffer(value.value(true), [this.path, doc]);\n      if (typeof value.sub_type !== 'number') {\n        throw new CastError('Buffer', value, this.path, null, this);\n      }\n      ret._subtype = value.sub_type;\n      return ret;\n    }\n\n    if (value == null || utils.isNonBuiltinObject(value)) {\n      return this._castRef(value, doc, init);\n    }\n  }\n\n  // documents\n  if (value && value._id) {\n    value = value._id;\n  }\n\n  if (value && value.isMongooseBuffer) {\n    return value;\n  }\n\n  if (Buffer.isBuffer(value)) {\n    if (!value || !value.isMongooseBuffer) {\n      value = new MongooseBuffer(value, [this.path, doc]);\n      if (this.options.subtype != null) {\n        value._subtype = this.options.subtype;\n      }\n    }\n    return value;\n  }\n\n  if (value instanceof Binary) {\n    ret = new MongooseBuffer(value.value(true), [this.path, doc]);\n    if (typeof value.sub_type !== 'number') {\n      throw new CastError('Buffer', value, this.path, null, this);\n    }\n    ret._subtype = value.sub_type;\n    return ret;\n  }\n\n  if (value === null) {\n    return value;\n  }\n\n\n  const type = typeof value;\n  if (\n    type === 'string' || type === 'number' || Array.isArray(value) ||\n    (type === 'object' && value.type === 'Buffer' && Array.isArray(value.data)) // gh-6863\n  ) {\n    if (type === 'number') {\n      value = [value];\n    }\n    ret = new MongooseBuffer(value, [this.path, doc]);\n    if (this.options.subtype != null) {\n      ret._subtype = this.options.subtype;\n    }\n    return ret;\n  }\n\n  throw new CastError('Buffer', value, this.path, null, this);\n};\n\n/**\n * Sets the default [subtype](https://studio3t.com/whats-new/best-practices-uuid-mongodb/)\n * for this buffer. You can find a [list of allowed subtypes here](https://api.mongodb.com/python/current/api/bson/binary.html).\n *\n * #### Example:\n *\n *     const s = new Schema({ uuid: { type: Buffer, subtype: 4 });\n *     const M = db.model('M', s);\n *     const m = new M({ uuid: 'test string' });\n *     m.uuid._subtype; // 4\n *\n * @param {Number} subtype the default subtype\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaBuffer.prototype.subtype = function(subtype) {\n  this.options.subtype = subtype;\n  return this;\n};\n\n/*!\n * ignore\n */\nfunction handleSingle(val, context) {\n  return this.castForQuery(null, val, context);\n}\n\nSchemaBuffer.prototype.$conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers,\n  $bitsAllClear: handleBitwiseOperator,\n  $bitsAnyClear: handleBitwiseOperator,\n  $bitsAllSet: handleBitwiseOperator,\n  $bitsAnySet: handleBitwiseOperator,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $lt: handleSingle,\n  $lte: handleSingle\n};\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaBuffer.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Buffer.');\n    }\n    return handler.call(this, val);\n  }\n\n  let casted;\n  try {\n    casted = this.applySetters(val, context);\n  } catch (err) {\n    if (err instanceof CastError && err.path === this.path && this.$fullPath != null) {\n      err.path = this.$fullPath;\n    }\n    throw err;\n  }\n  return casted ? casted.toObject({ transform: false, virtuals: false }) : casted;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaBuffer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9idWZmZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVhOztBQUViLHVCQUF1QixtQkFBTyxDQUFDLDZFQUFpQjtBQUNoRCw0QkFBNEIsbUJBQU8sQ0FBQywyR0FBZ0M7QUFDcEUsbUJBQW1CLG1CQUFPLENBQUMseUVBQWU7QUFDMUMsOEJBQThCLG1CQUFPLENBQUMsNkZBQXFCO0FBQzNELGNBQWMsbUJBQU8sQ0FBQywrREFBVTs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGNBQWM7QUFDdEUsbUJBQW1CLHNDQUFzQztBQUN6RDtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsZUFBZTtBQUN4RSwyQkFBMkIsaUNBQWlDLFFBQVE7QUFDcEU7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPLGdDQUFnQztBQUN6RSxlQUFlLHNCQUFzQixrQkFBa0I7QUFDdkQ7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVEsMEJBQTBCO0FBQ2hFO0FBQ0EseUJBQXlCLHFCQUFxQjtBQUM5Qyx3QkFBd0I7QUFDeEI7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxtQ0FBbUM7QUFDdkU7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9idWZmZXIuanM/OTE2NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUJ1ZmZlciA9IHJlcXVpcmUoJy4uL3R5cGVzL2J1ZmZlcicpO1xuY29uc3QgU2NoZW1hQnVmZmVyT3B0aW9ucyA9IHJlcXVpcmUoJy4uL29wdGlvbnMvc2NoZW1hQnVmZmVyT3B0aW9ucycpO1xuY29uc3QgU2NoZW1hVHlwZSA9IHJlcXVpcmUoJy4uL3NjaGVtYVR5cGUnKTtcbmNvbnN0IGhhbmRsZUJpdHdpc2VPcGVyYXRvciA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL2JpdHdpc2UnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuY29uc3QgQmluYXJ5ID0gTW9uZ29vc2VCdWZmZXIuQmluYXJ5O1xuY29uc3QgQ2FzdEVycm9yID0gU2NoZW1hVHlwZS5DYXN0RXJyb3I7XG5cbi8qKlxuICogQnVmZmVyIFNjaGVtYVR5cGUgY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGluaGVyaXRzIFNjaGVtYVR5cGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU2NoZW1hQnVmZmVyKGtleSwgb3B0aW9ucykge1xuICBTY2hlbWFUeXBlLmNhbGwodGhpcywga2V5LCBvcHRpb25zLCAnQnVmZmVyJyk7XG59XG5cbi8qKlxuICogVGhpcyBzY2hlbWEgdHlwZSdzIG5hbWUsIHRvIGRlZmVuZCBhZ2FpbnN0IG1pbmlmaWVycyB0aGF0IG1hbmdsZVxuICogZnVuY3Rpb24gbmFtZXMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuU2NoZW1hQnVmZmVyLnNjaGVtYU5hbWUgPSAnQnVmZmVyJztcblxuU2NoZW1hQnVmZmVyLmRlZmF1bHRPcHRpb25zID0ge307XG5cbi8qIVxuICogSW5oZXJpdHMgZnJvbSBTY2hlbWFUeXBlLlxuICovXG5TY2hlbWFCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTY2hlbWFUeXBlLnByb3RvdHlwZSk7XG5TY2hlbWFCdWZmZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2NoZW1hQnVmZmVyO1xuU2NoZW1hQnVmZmVyLnByb3RvdHlwZS5PcHRpb25zQ29uc3RydWN0b3IgPSBTY2hlbWFCdWZmZXJPcHRpb25zO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYUJ1ZmZlci5fY2hlY2tSZXF1aXJlZCA9IHYgPT4gISEodiAmJiB2Lmxlbmd0aCk7XG5cbi8qKlxuICogU2V0cyBhIGRlZmF1bHQgb3B0aW9uIGZvciBhbGwgQnVmZmVyIGluc3RhbmNlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1ha2UgYWxsIGJ1ZmZlcnMgaGF2ZSBgcmVxdWlyZWRgIG9mIHRydWUgYnkgZGVmYXVsdC5cbiAqICAgICBtb25nb29zZS5TY2hlbWEuQnVmZmVyLnNldCgncmVxdWlyZWQnLCB0cnVlKTtcbiAqXG4gKiAgICAgY29uc3QgVXNlciA9IG1vbmdvb3NlLm1vZGVsKCdVc2VyJywgbmV3IFNjaGVtYSh7IHRlc3Q6IEJ1ZmZlciB9KSk7XG4gKiAgICAgbmV3IFVzZXIoeyB9KS52YWxpZGF0ZVN5bmMoKS5lcnJvcnMudGVzdC5tZXNzYWdlOyAvLyBQYXRoIGB0ZXN0YCBpcyByZXF1aXJlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9uIFRoZSBvcHRpb24geW91J2QgbGlrZSB0byBzZXQgdGhlIHZhbHVlIGZvclxuICogQHBhcmFtIHtBbnl9IHZhbHVlIHZhbHVlIGZvciBvcHRpb25cbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAqIEBmdW5jdGlvbiBzZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hQnVmZmVyLnNldCA9IFNjaGVtYVR5cGUuc2V0O1xuXG5TY2hlbWFCdWZmZXIuc2V0dGVycyA9IFtdO1xuXG4vKipcbiAqIEF0dGFjaGVzIGEgZ2V0dGVyIGZvciBhbGwgQnVmZmVyIGluc3RhbmNlc1xuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gQWx3YXlzIGNvbnZlcnQgdG8gc3RyaW5nIHdoZW4gZ2V0dGluZyBhbiBPYmplY3RJZFxuICogICAgIG1vbmdvb3NlLlNjaGVtYS5UeXBlcy5CdWZmZXIuZ2V0KHYgPT4gdi50b1N0cmluZygnaGV4JykpO1xuICpcbiAqICAgICBjb25zdCBNb2RlbCA9IG1vbmdvb3NlLm1vZGVsKCdUZXN0JywgbmV3IFNjaGVtYSh7IGJ1ZjogQnVmZmVyIH0gfSkpO1xuICogICAgIHR5cGVvZiAobmV3IE1vZGVsKHsgYnVmOiBCdWZmZXIuZnJvbVN0cmluZygnaGVsbG8nKSB9KS5idWYpOyAvLyAnc3RyaW5nJ1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlclxuICogQHJldHVybiB7dGhpc31cbiAqIEBmdW5jdGlvbiBnZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hQnVmZmVyLmdldCA9IFNjaGVtYVR5cGUuZ2V0O1xuXG4vKipcbiAqIE92ZXJyaWRlIHRoZSBmdW5jdGlvbiB0aGUgcmVxdWlyZWQgdmFsaWRhdG9yIHVzZXMgdG8gY2hlY2sgd2hldGhlciBhIHN0cmluZ1xuICogcGFzc2VzIHRoZSBgcmVxdWlyZWRgIGNoZWNrLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gQWxsb3cgZW1wdHkgc3RyaW5ncyB0byBwYXNzIGByZXF1aXJlZGAgY2hlY2tcbiAqICAgICBtb25nb29zZS5TY2hlbWEuVHlwZXMuU3RyaW5nLmNoZWNrUmVxdWlyZWQodiA9PiB2ICE9IG51bGwpO1xuICpcbiAqICAgICBjb25zdCBNID0gbW9uZ29vc2UubW9kZWwoeyBidWY6IHsgdHlwZTogQnVmZmVyLCByZXF1aXJlZDogdHJ1ZSB9IH0pO1xuICogICAgIG5ldyBNKHsgYnVmOiBCdWZmZXIuZnJvbSgnJykgfSkudmFsaWRhdGVTeW5jKCk7IC8vIHZhbGlkYXRpb24gcGFzc2VzIVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBmdW5jdGlvbiBjaGVja1JlcXVpcmVkXG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYUJ1ZmZlci5jaGVja1JlcXVpcmVkID0gU2NoZW1hVHlwZS5jaGVja1JlcXVpcmVkO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBzYXRpc2ZpZXMgYSByZXF1aXJlZCB2YWxpZGF0b3IuIFRvIHNhdGlzZnkgYVxuICogcmVxdWlyZWQgdmFsaWRhdG9yLCBhIGJ1ZmZlciBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCBhbmQgaGF2ZVxuICogbm9uLXplcm8gbGVuZ3RoLlxuICpcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZVxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFCdWZmZXIucHJvdG90eXBlLmNoZWNrUmVxdWlyZWQgPSBmdW5jdGlvbih2YWx1ZSwgZG9jKSB7XG4gIGlmIChTY2hlbWFUeXBlLl9pc1JlZih0aGlzLCB2YWx1ZSwgZG9jLCB0cnVlKSkge1xuICAgIHJldHVybiAhIXZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLl9jaGVja1JlcXVpcmVkKHZhbHVlKTtcbn07XG5cbi8qKlxuICogQ2FzdHMgY29udGVudHNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvYyBkb2N1bWVudCB0aGF0IHRyaWdnZXJzIHRoZSBjYXN0aW5nXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluaXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYUJ1ZmZlci5wcm90b3R5cGUuY2FzdCA9IGZ1bmN0aW9uKHZhbHVlLCBkb2MsIGluaXQpIHtcbiAgbGV0IHJldDtcbiAgaWYgKFNjaGVtYVR5cGUuX2lzUmVmKHRoaXMsIHZhbHVlLCBkb2MsIGluaXQpKSB7XG4gICAgaWYgKHZhbHVlICYmIHZhbHVlLmlzTW9uZ29vc2VCdWZmZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgaWYgKCF2YWx1ZSB8fCAhdmFsdWUuaXNNb25nb29zZUJ1ZmZlcikge1xuICAgICAgICB2YWx1ZSA9IG5ldyBNb25nb29zZUJ1ZmZlcih2YWx1ZSwgW3RoaXMucGF0aCwgZG9jXSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3VidHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgdmFsdWUuX3N1YnR5cGUgPSB0aGlzLm9wdGlvbnMuc3VidHlwZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJpbmFyeSkge1xuICAgICAgcmV0ID0gbmV3IE1vbmdvb3NlQnVmZmVyKHZhbHVlLnZhbHVlKHRydWUpLCBbdGhpcy5wYXRoLCBkb2NdKTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUuc3ViX3R5cGUgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJ0J1ZmZlcicsIHZhbHVlLCB0aGlzLnBhdGgsIG51bGwsIHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0Ll9zdWJ0eXBlID0gdmFsdWUuc3ViX3R5cGU7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHV0aWxzLmlzTm9uQnVpbHRpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYXN0UmVmKHZhbHVlLCBkb2MsIGluaXQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGRvY3VtZW50c1xuICBpZiAodmFsdWUgJiYgdmFsdWUuX2lkKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5faWQ7XG4gIH1cblxuICBpZiAodmFsdWUgJiYgdmFsdWUuaXNNb25nb29zZUJ1ZmZlcikge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgaWYgKCF2YWx1ZSB8fCAhdmFsdWUuaXNNb25nb29zZUJ1ZmZlcikge1xuICAgICAgdmFsdWUgPSBuZXcgTW9uZ29vc2VCdWZmZXIodmFsdWUsIFt0aGlzLnBhdGgsIGRvY10pO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdWJ0eXBlICE9IG51bGwpIHtcbiAgICAgICAgdmFsdWUuX3N1YnR5cGUgPSB0aGlzLm9wdGlvbnMuc3VidHlwZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQmluYXJ5KSB7XG4gICAgcmV0ID0gbmV3IE1vbmdvb3NlQnVmZmVyKHZhbHVlLnZhbHVlKHRydWUpLCBbdGhpcy5wYXRoLCBkb2NdKTtcbiAgICBpZiAodHlwZW9mIHZhbHVlLnN1Yl90eXBlICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IENhc3RFcnJvcignQnVmZmVyJywgdmFsdWUsIHRoaXMucGF0aCwgbnVsbCwgdGhpcyk7XG4gICAgfVxuICAgIHJldC5fc3VidHlwZSA9IHZhbHVlLnN1Yl90eXBlO1xuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuXG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGlmIChcbiAgICB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnbnVtYmVyJyB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSB8fFxuICAgICh0eXBlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KHZhbHVlLmRhdGEpKSAvLyBnaC02ODYzXG4gICkge1xuICAgIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgdmFsdWUgPSBbdmFsdWVdO1xuICAgIH1cbiAgICByZXQgPSBuZXcgTW9uZ29vc2VCdWZmZXIodmFsdWUsIFt0aGlzLnBhdGgsIGRvY10pO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuc3VidHlwZSAhPSBudWxsKSB7XG4gICAgICByZXQuX3N1YnR5cGUgPSB0aGlzLm9wdGlvbnMuc3VidHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIHRocm93IG5ldyBDYXN0RXJyb3IoJ0J1ZmZlcicsIHZhbHVlLCB0aGlzLnBhdGgsIG51bGwsIHRoaXMpO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBkZWZhdWx0IFtzdWJ0eXBlXShodHRwczovL3N0dWRpbzN0LmNvbS93aGF0cy1uZXcvYmVzdC1wcmFjdGljZXMtdXVpZC1tb25nb2RiLylcbiAqIGZvciB0aGlzIGJ1ZmZlci4gWW91IGNhbiBmaW5kIGEgW2xpc3Qgb2YgYWxsb3dlZCBzdWJ0eXBlcyBoZXJlXShodHRwczovL2FwaS5tb25nb2RiLmNvbS9weXRob24vY3VycmVudC9hcGkvYnNvbi9iaW5hcnkuaHRtbCkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IHV1aWQ6IHsgdHlwZTogQnVmZmVyLCBzdWJ0eXBlOiA0IH0pO1xuICogICAgIGNvbnN0IE0gPSBkYi5tb2RlbCgnTScsIHMpO1xuICogICAgIGNvbnN0IG0gPSBuZXcgTSh7IHV1aWQ6ICd0ZXN0IHN0cmluZycgfSk7XG4gKiAgICAgbS51dWlkLl9zdWJ0eXBlOyAvLyA0XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHN1YnR5cGUgdGhlIGRlZmF1bHQgc3VidHlwZVxuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFCdWZmZXIucHJvdG90eXBlLnN1YnR5cGUgPSBmdW5jdGlvbihzdWJ0eXBlKSB7XG4gIHRoaXMub3B0aW9ucy5zdWJ0eXBlID0gc3VidHlwZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5mdW5jdGlvbiBoYW5kbGVTaW5nbGUodmFsLCBjb250ZXh0KSB7XG4gIHJldHVybiB0aGlzLmNhc3RGb3JRdWVyeShudWxsLCB2YWwsIGNvbnRleHQpO1xufVxuXG5TY2hlbWFCdWZmZXIucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzID0ge1xuICAuLi5TY2hlbWFUeXBlLnByb3RvdHlwZS4kY29uZGl0aW9uYWxIYW5kbGVycyxcbiAgJGJpdHNBbGxDbGVhcjogaGFuZGxlQml0d2lzZU9wZXJhdG9yLFxuICAkYml0c0FueUNsZWFyOiBoYW5kbGVCaXR3aXNlT3BlcmF0b3IsXG4gICRiaXRzQWxsU2V0OiBoYW5kbGVCaXR3aXNlT3BlcmF0b3IsXG4gICRiaXRzQW55U2V0OiBoYW5kbGVCaXR3aXNlT3BlcmF0b3IsXG4gICRndDogaGFuZGxlU2luZ2xlLFxuICAkZ3RlOiBoYW5kbGVTaW5nbGUsXG4gICRsdDogaGFuZGxlU2luZ2xlLFxuICAkbHRlOiBoYW5kbGVTaW5nbGVcbn07XG5cbi8qKlxuICogQ2FzdHMgY29udGVudHMgZm9yIHF1ZXJpZXMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9ICRjb25kaXRpb25hbFxuICogQHBhcmFtIHthbnl9IFt2YWx1ZV1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYUJ1ZmZlci5wcm90b3R5cGUuY2FzdEZvclF1ZXJ5ID0gZnVuY3Rpb24oJGNvbmRpdGlvbmFsLCB2YWwsIGNvbnRleHQpIHtcbiAgbGV0IGhhbmRsZXI7XG4gIGlmICgkY29uZGl0aW9uYWwgIT0gbnVsbCkge1xuICAgIGhhbmRsZXIgPSB0aGlzLiRjb25kaXRpb25hbEhhbmRsZXJzWyRjb25kaXRpb25hbF07XG4gICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgdXNlICcgKyAkY29uZGl0aW9uYWwgKyAnIHdpdGggQnVmZmVyLicpO1xuICAgIH1cbiAgICByZXR1cm4gaGFuZGxlci5jYWxsKHRoaXMsIHZhbCk7XG4gIH1cblxuICBsZXQgY2FzdGVkO1xuICB0cnkge1xuICAgIGNhc3RlZCA9IHRoaXMuYXBwbHlTZXR0ZXJzKHZhbCwgY29udGV4dCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBDYXN0RXJyb3IgJiYgZXJyLnBhdGggPT09IHRoaXMucGF0aCAmJiB0aGlzLiRmdWxsUGF0aCAhPSBudWxsKSB7XG4gICAgICBlcnIucGF0aCA9IHRoaXMuJGZ1bGxQYXRoO1xuICAgIH1cbiAgICB0aHJvdyBlcnI7XG4gIH1cbiAgcmV0dXJuIGNhc3RlZCA/IGNhc3RlZC50b09iamVjdCh7IHRyYW5zZm9ybTogZmFsc2UsIHZpcnR1YWxzOiBmYWxzZSB9KSA6IGNhc3RlZDtcbn07XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFCdWZmZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/schema/buffer.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/schema/date.js":
/*!***********************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/schema/date.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module requirements.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ../error/index */ \"../backend/node_modules/mongoose/lib/error/index.js\");\nconst SchemaDateOptions = __webpack_require__(/*! ../options/schemaDateOptions */ \"../backend/node_modules/mongoose/lib/options/schemaDateOptions.js\");\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"../backend/node_modules/mongoose/lib/schemaType.js\");\nconst castDate = __webpack_require__(/*! ../cast/date */ \"../backend/node_modules/mongoose/lib/cast/date.js\");\nconst getConstructorName = __webpack_require__(/*! ../helpers/getConstructorName */ \"../backend/node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\n\nconst CastError = SchemaType.CastError;\n\n/**\n * Date SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaDate(key, options) {\n  SchemaType.call(this, key, options, 'Date');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaDate.schemaName = 'Date';\n\nSchemaDate.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaDate.prototype = Object.create(SchemaType.prototype);\nSchemaDate.prototype.constructor = SchemaDate;\nSchemaDate.prototype.OptionsConstructor = SchemaDateOptions;\n\n/*!\n * ignore\n */\n\nSchemaDate._cast = castDate;\n\n/**\n * Sets a default option for all Date instances.\n *\n * #### Example:\n *\n *     // Make all dates have `required` of true by default.\n *     mongoose.Schema.Date.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: Date }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaDate.set = SchemaType.set;\n\nSchemaDate.setters = [];\n\n/**\n * Attaches a getter for all Date instances\n *\n * #### Example:\n *\n *     // Always convert Dates to string\n *     mongoose.Date.get(v => v.toString());\n *\n *     const Model = mongoose.model('Test', new Schema({ date: { type: Date, default: () => new Date() } }));\n *     typeof (new Model({}).date); // 'string'\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaDate.get = SchemaType.get;\n\n/**\n * Get/set the function used to cast arbitrary values to dates.\n *\n * #### Example:\n *\n *     // Mongoose converts empty string '' into `null` for date types. You\n *     // can create a custom caster to disable it.\n *     const original = mongoose.Schema.Types.Date.cast();\n *     mongoose.Schema.Types.Date.cast(v => {\n *       assert.ok(v !== '');\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.Schema.Types.Date.cast(false);\n *\n * @param {Function} caster\n * @return {Function}\n * @function get\n * @static\n * @api public\n */\n\nSchemaDate.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaDate._defaultCaster = v => {\n  if (v != null && !(v instanceof Date)) {\n    throw new Error();\n  }\n  return v;\n};\n\n/**\n * Declares a TTL index (rounded to the nearest second) for _Date_ types only.\n *\n * This sets the `expireAfterSeconds` index option available in MongoDB >= 2.1.2.\n * This index type is only compatible with Date types.\n *\n * #### Example:\n *\n *     // expire in 24 hours\n *     new Schema({ createdAt: { type: Date, expires: 60*60*24 }});\n *\n * `expires` utilizes the `ms` module from [guille](https://github.com/guille/) allowing us to use a friendlier syntax:\n *\n * #### Example:\n *\n *     // expire in 24 hours\n *     new Schema({ createdAt: { type: Date, expires: '24h' }});\n *\n *     // expire in 1.5 hours\n *     new Schema({ createdAt: { type: Date, expires: '1.5h' }});\n *\n *     // expire in 7 days\n *     const schema = new Schema({ createdAt: Date });\n *     schema.path('createdAt').expires('7d');\n *\n * @param {Number|String} when\n * @added 3.0.0\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaDate.prototype.expires = function(when) {\n  if (getConstructorName(this._index) !== 'Object') {\n    this._index = {};\n  }\n\n  this._index.expires = when;\n  utils.expires(this._index);\n  return this;\n};\n\n/*!\n * ignore\n */\n\nSchemaDate._checkRequired = v => v instanceof Date;\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * #### Example:\n *\n *     // Allow empty strings to pass `required` check\n *     mongoose.Schema.Types.String.checkRequired(v => v != null);\n *\n *     const M = mongoose.model({ str: { type: String, required: true } });\n *     new M({ str: '' }).validateSync(); // `null`, validation passes!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaDate.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator. To satisfy\n * a required validator, the given value must be an instance of `Date`.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaDate.prototype.checkRequired = function(value, doc) {\n  if (typeof value === 'object' && SchemaType._isRef(this, value, doc, true)) {\n    return value != null;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ?\n    this.constructor.checkRequired() :\n    SchemaDate.checkRequired();\n  return _checkRequired(value);\n};\n\n/**\n * Sets a minimum date validator.\n *\n * #### Example:\n *\n *     const s = new Schema({ d: { type: Date, min: Date('1970-01-01') })\n *     const M = db.model('M', s)\n *     const m = new M({ d: Date('1969-12-31') })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.d = Date('2014-12-08');\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MIN} token which will be replaced with the invalid value\n *     const min = [Date('1970-01-01'), 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];\n *     const schema = new Schema({ d: { type: Date, min: min })\n *     const M = mongoose.model('M', schema);\n *     const s= new M({ d: Date('1969-12-31') });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `d` (1969-12-31) is before the limit (1970-01-01).\n *     })\n *\n * @param {Date} value minimum date\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaDate.prototype.min = function(value, message) {\n  if (this.minValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.minValidator;\n    }, this);\n  }\n\n  if (value) {\n    let msg = message || MongooseError.messages.Date.min;\n    if (typeof msg === 'string') {\n      msg = msg.replace(/{MIN}/, (value === Date.now ? 'Date.now()' : value.toString()));\n    }\n    const _this = this;\n    this.validators.push({\n      validator: this.minValidator = function(val) {\n        let _value = value;\n        if (typeof value === 'function' && value !== Date.now) {\n          _value = _value.call(this);\n        }\n        const min = (_value === Date.now ? _value() : _this.cast(_value));\n        return val === null || val.valueOf() >= min.valueOf();\n      },\n      message: msg,\n      type: 'min',\n      min: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Sets a maximum date validator.\n *\n * #### Example:\n *\n *     const s = new Schema({ d: { type: Date, max: Date('2014-01-01') })\n *     const M = db.model('M', s)\n *     const m = new M({ d: Date('2014-12-08') })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.d = Date('2013-12-31');\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MAX} token which will be replaced with the invalid value\n *     const max = [Date('2014-01-01'), 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];\n *     const schema = new Schema({ d: { type: Date, max: max })\n *     const M = mongoose.model('M', schema);\n *     const s= new M({ d: Date('2014-12-08') });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `d` (2014-12-08) exceeds the limit (2014-01-01).\n *     })\n *\n * @param {Date} maximum date\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaDate.prototype.max = function(value, message) {\n  if (this.maxValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.maxValidator;\n    }, this);\n  }\n\n  if (value) {\n    let msg = message || MongooseError.messages.Date.max;\n    if (typeof msg === 'string') {\n      msg = msg.replace(/{MAX}/, (value === Date.now ? 'Date.now()' : value.toString()));\n    }\n    const _this = this;\n    this.validators.push({\n      validator: this.maxValidator = function(val) {\n        let _value = value;\n        if (typeof _value === 'function' && _value !== Date.now) {\n          _value = _value.call(this);\n        }\n        const max = (_value === Date.now ? _value() : _this.cast(_value));\n        return val === null || val.valueOf() <= max.valueOf();\n      },\n      message: msg,\n      type: 'max',\n      max: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Casts to date\n *\n * @param {Object} value to cast\n * @api private\n */\n\nSchemaDate.prototype.cast = function(value) {\n  let castDate;\n  if (typeof this._castFunction === 'function') {\n    castDate = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castDate = this.constructor.cast();\n  } else {\n    castDate = SchemaDate.cast();\n  }\n\n  try {\n    return castDate(value);\n  } catch (error) {\n    throw new CastError('date', value, this.path, error, this);\n  }\n};\n\n/**\n * Date Query casting.\n *\n * @param {Any} val\n * @api private\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\nSchemaDate.prototype.$conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $lt: handleSingle,\n  $lte: handleSingle\n};\n\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaDate.prototype.castForQuery = function($conditional, val, context) {\n  if ($conditional == null) {\n    try {\n      return this.applySetters(val, context);\n    } catch (err) {\n      if (err instanceof CastError && err.path === this.path && this.$fullPath != null) {\n        err.path = this.$fullPath;\n      }\n      throw err;\n    }\n  }\n\n  const handler = this.$conditionalHandlers[$conditional];\n\n  if (!handler) {\n    throw new Error('Can\\'t use ' + $conditional + ' with Date.');\n  }\n\n  return handler.call(this, val);\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaDate;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9kYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixzQkFBc0IsbUJBQU8sQ0FBQywyRUFBZ0I7QUFDOUMsMEJBQTBCLG1CQUFPLENBQUMsdUdBQThCO0FBQ2hFLG1CQUFtQixtQkFBTyxDQUFDLHlFQUFlO0FBQzFDLGlCQUFpQixtQkFBTyxDQUFDLHVFQUFjO0FBQ3ZDLDJCQUEyQixtQkFBTyxDQUFDLHlHQUErQjtBQUNsRSxjQUFjLG1CQUFPLENBQUMsK0RBQVU7O0FBRWhDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsWUFBWTtBQUNwRSxtQkFBbUIsc0NBQXNDO0FBQ3pEO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxRQUFRLHlDQUF5QztBQUMxRywyQkFBMkIsU0FBUztBQUNwQztBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL2RhdGUuanM/MmYyNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvaW5kZXgnKTtcbmNvbnN0IFNjaGVtYURhdGVPcHRpb25zID0gcmVxdWlyZSgnLi4vb3B0aW9ucy9zY2hlbWFEYXRlT3B0aW9ucycpO1xuY29uc3QgU2NoZW1hVHlwZSA9IHJlcXVpcmUoJy4uL3NjaGVtYVR5cGUnKTtcbmNvbnN0IGNhc3REYXRlID0gcmVxdWlyZSgnLi4vY2FzdC9kYXRlJyk7XG5jb25zdCBnZXRDb25zdHJ1Y3Rvck5hbWUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2dldENvbnN0cnVjdG9yTmFtZScpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5jb25zdCBDYXN0RXJyb3IgPSBTY2hlbWFUeXBlLkNhc3RFcnJvcjtcblxuLyoqXG4gKiBEYXRlIFNjaGVtYVR5cGUgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBpbmhlcml0cyBTY2hlbWFUeXBlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNjaGVtYURhdGUoa2V5LCBvcHRpb25zKSB7XG4gIFNjaGVtYVR5cGUuY2FsbCh0aGlzLCBrZXksIG9wdGlvbnMsICdEYXRlJyk7XG59XG5cbi8qKlxuICogVGhpcyBzY2hlbWEgdHlwZSdzIG5hbWUsIHRvIGRlZmVuZCBhZ2FpbnN0IG1pbmlmaWVycyB0aGF0IG1hbmdsZVxuICogZnVuY3Rpb24gbmFtZXMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuU2NoZW1hRGF0ZS5zY2hlbWFOYW1lID0gJ0RhdGUnO1xuXG5TY2hlbWFEYXRlLmRlZmF1bHRPcHRpb25zID0ge307XG5cbi8qIVxuICogSW5oZXJpdHMgZnJvbSBTY2hlbWFUeXBlLlxuICovXG5TY2hlbWFEYXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU2NoZW1hVHlwZS5wcm90b3R5cGUpO1xuU2NoZW1hRGF0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTY2hlbWFEYXRlO1xuU2NoZW1hRGF0ZS5wcm90b3R5cGUuT3B0aW9uc0NvbnN0cnVjdG9yID0gU2NoZW1hRGF0ZU9wdGlvbnM7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hRGF0ZS5fY2FzdCA9IGNhc3REYXRlO1xuXG4vKipcbiAqIFNldHMgYSBkZWZhdWx0IG9wdGlvbiBmb3IgYWxsIERhdGUgaW5zdGFuY2VzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTWFrZSBhbGwgZGF0ZXMgaGF2ZSBgcmVxdWlyZWRgIG9mIHRydWUgYnkgZGVmYXVsdC5cbiAqICAgICBtb25nb29zZS5TY2hlbWEuRGF0ZS5zZXQoJ3JlcXVpcmVkJywgdHJ1ZSk7XG4gKlxuICogICAgIGNvbnN0IFVzZXIgPSBtb25nb29zZS5tb2RlbCgnVXNlcicsIG5ldyBTY2hlbWEoeyB0ZXN0OiBEYXRlIH0pKTtcbiAqICAgICBuZXcgVXNlcih7IH0pLnZhbGlkYXRlU3luYygpLmVycm9ycy50ZXN0Lm1lc3NhZ2U7IC8vIFBhdGggYHRlc3RgIGlzIHJlcXVpcmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb24gVGhlIG9wdGlvbiB5b3UnZCBsaWtlIHRvIHNldCB0aGUgdmFsdWUgZm9yXG4gKiBAcGFyYW0ge0FueX0gdmFsdWUgdmFsdWUgZm9yIG9wdGlvblxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICogQGZ1bmN0aW9uIHNldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFEYXRlLnNldCA9IFNjaGVtYVR5cGUuc2V0O1xuXG5TY2hlbWFEYXRlLnNldHRlcnMgPSBbXTtcblxuLyoqXG4gKiBBdHRhY2hlcyBhIGdldHRlciBmb3IgYWxsIERhdGUgaW5zdGFuY2VzXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBBbHdheXMgY29udmVydCBEYXRlcyB0byBzdHJpbmdcbiAqICAgICBtb25nb29zZS5EYXRlLmdldCh2ID0+IHYudG9TdHJpbmcoKSk7XG4gKlxuICogICAgIGNvbnN0IE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBuZXcgU2NoZW1hKHsgZGF0ZTogeyB0eXBlOiBEYXRlLCBkZWZhdWx0OiAoKSA9PiBuZXcgRGF0ZSgpIH0gfSkpO1xuICogICAgIHR5cGVvZiAobmV3IE1vZGVsKHt9KS5kYXRlKTsgLy8gJ3N0cmluZydcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAqIEByZXR1cm4ge3RoaXN9XG4gKiBAZnVuY3Rpb24gZ2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYURhdGUuZ2V0ID0gU2NoZW1hVHlwZS5nZXQ7XG5cbi8qKlxuICogR2V0L3NldCB0aGUgZnVuY3Rpb24gdXNlZCB0byBjYXN0IGFyYml0cmFyeSB2YWx1ZXMgdG8gZGF0ZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNb25nb29zZSBjb252ZXJ0cyBlbXB0eSBzdHJpbmcgJycgaW50byBgbnVsbGAgZm9yIGRhdGUgdHlwZXMuIFlvdVxuICogICAgIC8vIGNhbiBjcmVhdGUgYSBjdXN0b20gY2FzdGVyIHRvIGRpc2FibGUgaXQuXG4gKiAgICAgY29uc3Qgb3JpZ2luYWwgPSBtb25nb29zZS5TY2hlbWEuVHlwZXMuRGF0ZS5jYXN0KCk7XG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLlR5cGVzLkRhdGUuY2FzdCh2ID0+IHtcbiAqICAgICAgIGFzc2VydC5vayh2ICE9PSAnJyk7XG4gKiAgICAgICByZXR1cm4gb3JpZ2luYWwodik7XG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vIE9yIGRpc2FibGUgY2FzdGluZyBlbnRpcmVseVxuICogICAgIG1vbmdvb3NlLlNjaGVtYS5UeXBlcy5EYXRlLmNhc3QoZmFsc2UpO1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhc3RlclxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAZnVuY3Rpb24gZ2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYURhdGUuY2FzdCA9IGZ1bmN0aW9uIGNhc3QoY2FzdGVyKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nhc3Q7XG4gIH1cbiAgaWYgKGNhc3RlciA9PT0gZmFsc2UpIHtcbiAgICBjYXN0ZXIgPSB0aGlzLl9kZWZhdWx0Q2FzdGVyO1xuICB9XG4gIHRoaXMuX2Nhc3QgPSBjYXN0ZXI7XG5cbiAgcmV0dXJuIHRoaXMuX2Nhc3Q7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYURhdGUuX2RlZmF1bHRDYXN0ZXIgPSB2ID0+IHtcbiAgaWYgKHYgIT0gbnVsbCAmJiAhKHYgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigpO1xuICB9XG4gIHJldHVybiB2O1xufTtcblxuLyoqXG4gKiBEZWNsYXJlcyBhIFRUTCBpbmRleCAocm91bmRlZCB0byB0aGUgbmVhcmVzdCBzZWNvbmQpIGZvciBfRGF0ZV8gdHlwZXMgb25seS5cbiAqXG4gKiBUaGlzIHNldHMgdGhlIGBleHBpcmVBZnRlclNlY29uZHNgIGluZGV4IG9wdGlvbiBhdmFpbGFibGUgaW4gTW9uZ29EQiA+PSAyLjEuMi5cbiAqIFRoaXMgaW5kZXggdHlwZSBpcyBvbmx5IGNvbXBhdGlibGUgd2l0aCBEYXRlIHR5cGVzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gZXhwaXJlIGluIDI0IGhvdXJzXG4gKiAgICAgbmV3IFNjaGVtYSh7IGNyZWF0ZWRBdDogeyB0eXBlOiBEYXRlLCBleHBpcmVzOiA2MCo2MCoyNCB9fSk7XG4gKlxuICogYGV4cGlyZXNgIHV0aWxpemVzIHRoZSBgbXNgIG1vZHVsZSBmcm9tIFtndWlsbGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9ndWlsbGUvKSBhbGxvd2luZyB1cyB0byB1c2UgYSBmcmllbmRsaWVyIHN5bnRheDpcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIGV4cGlyZSBpbiAyNCBob3Vyc1xuICogICAgIG5ldyBTY2hlbWEoeyBjcmVhdGVkQXQ6IHsgdHlwZTogRGF0ZSwgZXhwaXJlczogJzI0aCcgfX0pO1xuICpcbiAqICAgICAvLyBleHBpcmUgaW4gMS41IGhvdXJzXG4gKiAgICAgbmV3IFNjaGVtYSh7IGNyZWF0ZWRBdDogeyB0eXBlOiBEYXRlLCBleHBpcmVzOiAnMS41aCcgfX0pO1xuICpcbiAqICAgICAvLyBleHBpcmUgaW4gNyBkYXlzXG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IGNyZWF0ZWRBdDogRGF0ZSB9KTtcbiAqICAgICBzY2hlbWEucGF0aCgnY3JlYXRlZEF0JykuZXhwaXJlcygnN2QnKTtcbiAqXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHdoZW5cbiAqIEBhZGRlZCAzLjAuMFxuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFEYXRlLnByb3RvdHlwZS5leHBpcmVzID0gZnVuY3Rpb24od2hlbikge1xuICBpZiAoZ2V0Q29uc3RydWN0b3JOYW1lKHRoaXMuX2luZGV4KSAhPT0gJ09iamVjdCcpIHtcbiAgICB0aGlzLl9pbmRleCA9IHt9O1xuICB9XG5cbiAgdGhpcy5faW5kZXguZXhwaXJlcyA9IHdoZW47XG4gIHV0aWxzLmV4cGlyZXModGhpcy5faW5kZXgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hRGF0ZS5fY2hlY2tSZXF1aXJlZCA9IHYgPT4gdiBpbnN0YW5jZW9mIERhdGU7XG5cbi8qKlxuICogT3ZlcnJpZGUgdGhlIGZ1bmN0aW9uIHRoZSByZXF1aXJlZCB2YWxpZGF0b3IgdXNlcyB0byBjaGVjayB3aGV0aGVyIGEgc3RyaW5nXG4gKiBwYXNzZXMgdGhlIGByZXF1aXJlZGAgY2hlY2suXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBBbGxvdyBlbXB0eSBzdHJpbmdzIHRvIHBhc3MgYHJlcXVpcmVkYCBjaGVja1xuICogICAgIG1vbmdvb3NlLlNjaGVtYS5UeXBlcy5TdHJpbmcuY2hlY2tSZXF1aXJlZCh2ID0+IHYgIT0gbnVsbCk7XG4gKlxuICogICAgIGNvbnN0IE0gPSBtb25nb29zZS5tb2RlbCh7IHN0cjogeyB0eXBlOiBTdHJpbmcsIHJlcXVpcmVkOiB0cnVlIH0gfSk7XG4gKiAgICAgbmV3IE0oeyBzdHI6ICcnIH0pLnZhbGlkYXRlU3luYygpOyAvLyBgbnVsbGAsIHZhbGlkYXRpb24gcGFzc2VzIVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBmdW5jdGlvbiBjaGVja1JlcXVpcmVkXG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYURhdGUuY2hlY2tSZXF1aXJlZCA9IFNjaGVtYVR5cGUuY2hlY2tSZXF1aXJlZDtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgc2F0aXNmaWVzIGEgcmVxdWlyZWQgdmFsaWRhdG9yLiBUbyBzYXRpc2Z5XG4gKiBhIHJlcXVpcmVkIHZhbGlkYXRvciwgdGhlIGdpdmVuIHZhbHVlIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgYERhdGVgLlxuICpcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZVxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFEYXRlLnByb3RvdHlwZS5jaGVja1JlcXVpcmVkID0gZnVuY3Rpb24odmFsdWUsIGRvYykge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBTY2hlbWFUeXBlLl9pc1JlZih0aGlzLCB2YWx1ZSwgZG9jLCB0cnVlKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPSBudWxsO1xuICB9XG5cbiAgLy8gYHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0cygpYCBkb2VzICoqbm90KiogY29weSBzdGF0aWMgcHJvcGVydGllcywgYW5kXG4gIC8vIHBsdWdpbnMgbGlrZSBtb25nb29zZS1mbG9hdCB1c2UgYGluaGVyaXRzKClgIGZvciBwcmUtRVM2LlxuICBjb25zdCBfY2hlY2tSZXF1aXJlZCA9IHR5cGVvZiB0aGlzLmNvbnN0cnVjdG9yLmNoZWNrUmVxdWlyZWQgPT09ICdmdW5jdGlvbicgP1xuICAgIHRoaXMuY29uc3RydWN0b3IuY2hlY2tSZXF1aXJlZCgpIDpcbiAgICBTY2hlbWFEYXRlLmNoZWNrUmVxdWlyZWQoKTtcbiAgcmV0dXJuIF9jaGVja1JlcXVpcmVkKHZhbHVlKTtcbn07XG5cbi8qKlxuICogU2V0cyBhIG1pbmltdW0gZGF0ZSB2YWxpZGF0b3IuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IGQ6IHsgdHlwZTogRGF0ZSwgbWluOiBEYXRlKCcxOTcwLTAxLTAxJykgfSlcbiAqICAgICBjb25zdCBNID0gZGIubW9kZWwoJ00nLCBzKVxuICogICAgIGNvbnN0IG0gPSBuZXcgTSh7IGQ6IERhdGUoJzE5NjktMTItMzEnKSB9KVxuICogICAgIG0uc2F2ZShmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgICBjb25zb2xlLmVycm9yKGVycikgLy8gdmFsaWRhdG9yIGVycm9yXG4gKiAgICAgICBtLmQgPSBEYXRlKCcyMDE0LTEyLTA4Jyk7XG4gKiAgICAgICBtLnNhdmUoKSAvLyBzdWNjZXNzXG4gKiAgICAgfSlcbiAqXG4gKiAgICAgLy8gY3VzdG9tIGVycm9yIG1lc3NhZ2VzXG4gKiAgICAgLy8gV2UgY2FuIGFsc28gdXNlIHRoZSBzcGVjaWFsIHtNSU59IHRva2VuIHdoaWNoIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGUgaW52YWxpZCB2YWx1ZVxuICogICAgIGNvbnN0IG1pbiA9IFtEYXRlKCcxOTcwLTAxLTAxJyksICdUaGUgdmFsdWUgb2YgcGF0aCBge1BBVEh9YCAoe1ZBTFVFfSkgaXMgYmVuZWF0aCB0aGUgbGltaXQgKHtNSU59KS4nXTtcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgZDogeyB0eXBlOiBEYXRlLCBtaW46IG1pbiB9KVxuICogICAgIGNvbnN0IE0gPSBtb25nb29zZS5tb2RlbCgnTScsIHNjaGVtYSk7XG4gKiAgICAgY29uc3Qgcz0gbmV3IE0oeyBkOiBEYXRlKCcxOTY5LTEyLTMxJykgfSk7XG4gKiAgICAgcy52YWxpZGF0ZShmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyhTdHJpbmcoZXJyKSkgLy8gVmFsaWRhdGlvbkVycm9yOiBUaGUgdmFsdWUgb2YgcGF0aCBgZGAgKDE5NjktMTItMzEpIGlzIGJlZm9yZSB0aGUgbGltaXQgKDE5NzAtMDEtMDEpLlxuICogICAgIH0pXG4gKlxuICogQHBhcmFtIHtEYXRlfSB2YWx1ZSBtaW5pbXVtIGRhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWVzc2FnZV0gb3B0aW9uYWwgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IHRoaXNcbiAqIEBzZWUgQ3VzdG9taXplZCBFcnJvciBNZXNzYWdlcyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2Vycm9yLmh0bWwjRXJyb3IubWVzc2FnZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hRGF0ZS5wcm90b3R5cGUubWluID0gZnVuY3Rpb24odmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKHRoaXMubWluVmFsaWRhdG9yKSB7XG4gICAgdGhpcy52YWxpZGF0b3JzID0gdGhpcy52YWxpZGF0b3JzLmZpbHRlcihmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gdi52YWxpZGF0b3IgIT09IHRoaXMubWluVmFsaWRhdG9yO1xuICAgIH0sIHRoaXMpO1xuICB9XG5cbiAgaWYgKHZhbHVlKSB7XG4gICAgbGV0IG1zZyA9IG1lc3NhZ2UgfHwgTW9uZ29vc2VFcnJvci5tZXNzYWdlcy5EYXRlLm1pbjtcbiAgICBpZiAodHlwZW9mIG1zZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG1zZyA9IG1zZy5yZXBsYWNlKC97TUlOfS8sICh2YWx1ZSA9PT0gRGF0ZS5ub3cgPyAnRGF0ZS5ub3coKScgOiB2YWx1ZS50b1N0cmluZygpKSk7XG4gICAgfVxuICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICB0aGlzLnZhbGlkYXRvcnMucHVzaCh7XG4gICAgICB2YWxpZGF0b3I6IHRoaXMubWluVmFsaWRhdG9yID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIGxldCBfdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZSAhPT0gRGF0ZS5ub3cpIHtcbiAgICAgICAgICBfdmFsdWUgPSBfdmFsdWUuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtaW4gPSAoX3ZhbHVlID09PSBEYXRlLm5vdyA/IF92YWx1ZSgpIDogX3RoaXMuY2FzdChfdmFsdWUpKTtcbiAgICAgICAgcmV0dXJuIHZhbCA9PT0gbnVsbCB8fCB2YWwudmFsdWVPZigpID49IG1pbi52YWx1ZU9mKCk7XG4gICAgICB9LFxuICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgdHlwZTogJ21pbicsXG4gICAgICBtaW46IHZhbHVlXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyBhIG1heGltdW0gZGF0ZSB2YWxpZGF0b3IuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IGQ6IHsgdHlwZTogRGF0ZSwgbWF4OiBEYXRlKCcyMDE0LTAxLTAxJykgfSlcbiAqICAgICBjb25zdCBNID0gZGIubW9kZWwoJ00nLCBzKVxuICogICAgIGNvbnN0IG0gPSBuZXcgTSh7IGQ6IERhdGUoJzIwMTQtMTItMDgnKSB9KVxuICogICAgIG0uc2F2ZShmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgICBjb25zb2xlLmVycm9yKGVycikgLy8gdmFsaWRhdG9yIGVycm9yXG4gKiAgICAgICBtLmQgPSBEYXRlKCcyMDEzLTEyLTMxJyk7XG4gKiAgICAgICBtLnNhdmUoKSAvLyBzdWNjZXNzXG4gKiAgICAgfSlcbiAqXG4gKiAgICAgLy8gY3VzdG9tIGVycm9yIG1lc3NhZ2VzXG4gKiAgICAgLy8gV2UgY2FuIGFsc28gdXNlIHRoZSBzcGVjaWFsIHtNQVh9IHRva2VuIHdoaWNoIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGUgaW52YWxpZCB2YWx1ZVxuICogICAgIGNvbnN0IG1heCA9IFtEYXRlKCcyMDE0LTAxLTAxJyksICdUaGUgdmFsdWUgb2YgcGF0aCBge1BBVEh9YCAoe1ZBTFVFfSkgZXhjZWVkcyB0aGUgbGltaXQgKHtNQVh9KS4nXTtcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgZDogeyB0eXBlOiBEYXRlLCBtYXg6IG1heCB9KVxuICogICAgIGNvbnN0IE0gPSBtb25nb29zZS5tb2RlbCgnTScsIHNjaGVtYSk7XG4gKiAgICAgY29uc3Qgcz0gbmV3IE0oeyBkOiBEYXRlKCcyMDE0LTEyLTA4JykgfSk7XG4gKiAgICAgcy52YWxpZGF0ZShmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyhTdHJpbmcoZXJyKSkgLy8gVmFsaWRhdGlvbkVycm9yOiBUaGUgdmFsdWUgb2YgcGF0aCBgZGAgKDIwMTQtMTItMDgpIGV4Y2VlZHMgdGhlIGxpbWl0ICgyMDE0LTAxLTAxKS5cbiAqICAgICB9KVxuICpcbiAqIEBwYXJhbSB7RGF0ZX0gbWF4aW11bSBkYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdIG9wdGlvbmFsIGN1c3RvbSBlcnJvciBtZXNzYWdlXG4gKiBAcmV0dXJuIHtTY2hlbWFUeXBlfSB0aGlzXG4gKiBAc2VlIEN1c3RvbWl6ZWQgRXJyb3IgTWVzc2FnZXMgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9lcnJvci5odG1sI0Vycm9yLm1lc3NhZ2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYURhdGUucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICh0aGlzLm1heFZhbGlkYXRvcikge1xuICAgIHRoaXMudmFsaWRhdG9ycyA9IHRoaXMudmFsaWRhdG9ycy5maWx0ZXIoZnVuY3Rpb24odikge1xuICAgICAgcmV0dXJuIHYudmFsaWRhdG9yICE9PSB0aGlzLm1heFZhbGlkYXRvcjtcbiAgICB9LCB0aGlzKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSkge1xuICAgIGxldCBtc2cgPSBtZXNzYWdlIHx8IE1vbmdvb3NlRXJyb3IubWVzc2FnZXMuRGF0ZS5tYXg7XG4gICAgaWYgKHR5cGVvZiBtc2cgPT09ICdzdHJpbmcnKSB7XG4gICAgICBtc2cgPSBtc2cucmVwbGFjZSgve01BWH0vLCAodmFsdWUgPT09IERhdGUubm93ID8gJ0RhdGUubm93KCknIDogdmFsdWUudG9TdHJpbmcoKSkpO1xuICAgIH1cbiAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy52YWxpZGF0b3JzLnB1c2goe1xuICAgICAgdmFsaWRhdG9yOiB0aGlzLm1heFZhbGlkYXRvciA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICBsZXQgX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgX3ZhbHVlID09PSAnZnVuY3Rpb24nICYmIF92YWx1ZSAhPT0gRGF0ZS5ub3cpIHtcbiAgICAgICAgICBfdmFsdWUgPSBfdmFsdWUuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXggPSAoX3ZhbHVlID09PSBEYXRlLm5vdyA/IF92YWx1ZSgpIDogX3RoaXMuY2FzdChfdmFsdWUpKTtcbiAgICAgICAgcmV0dXJuIHZhbCA9PT0gbnVsbCB8fCB2YWwudmFsdWVPZigpIDw9IG1heC52YWx1ZU9mKCk7XG4gICAgICB9LFxuICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgdHlwZTogJ21heCcsXG4gICAgICBtYXg6IHZhbHVlXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FzdHMgdG8gZGF0ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSB0byBjYXN0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFEYXRlLnByb3RvdHlwZS5jYXN0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgbGV0IGNhc3REYXRlO1xuICBpZiAodHlwZW9mIHRoaXMuX2Nhc3RGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhc3REYXRlID0gdGhpcy5fY2FzdEZ1bmN0aW9uO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLmNvbnN0cnVjdG9yLmNhc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYXN0RGF0ZSA9IHRoaXMuY29uc3RydWN0b3IuY2FzdCgpO1xuICB9IGVsc2Uge1xuICAgIGNhc3REYXRlID0gU2NoZW1hRGF0ZS5jYXN0KCk7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBjYXN0RGF0ZSh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IENhc3RFcnJvcignZGF0ZScsIHZhbHVlLCB0aGlzLnBhdGgsIGVycm9yLCB0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEYXRlIFF1ZXJ5IGNhc3RpbmcuXG4gKlxuICogQHBhcmFtIHtBbnl9IHZhbFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaGFuZGxlU2luZ2xlKHZhbCkge1xuICByZXR1cm4gdGhpcy5jYXN0KHZhbCk7XG59XG5cblNjaGVtYURhdGUucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzID0ge1xuICAuLi5TY2hlbWFUeXBlLnByb3RvdHlwZS4kY29uZGl0aW9uYWxIYW5kbGVycyxcbiAgJGd0OiBoYW5kbGVTaW5nbGUsXG4gICRndGU6IGhhbmRsZVNpbmdsZSxcbiAgJGx0OiBoYW5kbGVTaW5nbGUsXG4gICRsdGU6IGhhbmRsZVNpbmdsZVxufTtcblxuXG4vKipcbiAqIENhc3RzIGNvbnRlbnRzIGZvciBxdWVyaWVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSAkY29uZGl0aW9uYWxcbiAqIEBwYXJhbSB7YW55fSBbdmFsdWVdXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFEYXRlLnByb3RvdHlwZS5jYXN0Rm9yUXVlcnkgPSBmdW5jdGlvbigkY29uZGl0aW9uYWwsIHZhbCwgY29udGV4dCkge1xuICBpZiAoJGNvbmRpdGlvbmFsID09IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMuYXBwbHlTZXR0ZXJzKHZhbCwgY29udGV4dCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgQ2FzdEVycm9yICYmIGVyci5wYXRoID09PSB0aGlzLnBhdGggJiYgdGhpcy4kZnVsbFBhdGggIT0gbnVsbCkge1xuICAgICAgICBlcnIucGF0aCA9IHRoaXMuJGZ1bGxQYXRoO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGhhbmRsZXIgPSB0aGlzLiRjb25kaXRpb25hbEhhbmRsZXJzWyRjb25kaXRpb25hbF07XG5cbiAgaWYgKCFoYW5kbGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IHVzZSAnICsgJGNvbmRpdGlvbmFsICsgJyB3aXRoIERhdGUuJyk7XG4gIH1cblxuICByZXR1cm4gaGFuZGxlci5jYWxsKHRoaXMsIHZhbCk7XG59O1xuXG4vKiFcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hRGF0ZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/schema/date.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/schema/decimal128.js":
/*!*****************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/schema/decimal128.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"../backend/node_modules/mongoose/lib/schemaType.js\");\nconst CastError = SchemaType.CastError;\nconst castDecimal128 = __webpack_require__(/*! ../cast/decimal128 */ \"../backend/node_modules/mongoose/lib/cast/decimal128.js\");\nconst isBsonType = __webpack_require__(/*! ../helpers/isBsonType */ \"../backend/node_modules/mongoose/lib/helpers/isBsonType.js\");\n\n/**\n * Decimal128 SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaDecimal128(key, options) {\n  SchemaType.call(this, key, options, 'Decimal128');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaDecimal128.schemaName = 'Decimal128';\n\nSchemaDecimal128.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaDecimal128.prototype = Object.create(SchemaType.prototype);\nSchemaDecimal128.prototype.constructor = SchemaDecimal128;\n\n/*!\n * ignore\n */\n\nSchemaDecimal128._cast = castDecimal128;\n\n/**\n * Sets a default option for all Decimal128 instances.\n *\n * #### Example:\n *\n *     // Make all decimal 128s have `required` of true by default.\n *     mongoose.Schema.Decimal128.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: mongoose.Decimal128 }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaDecimal128.set = SchemaType.set;\n\nSchemaDecimal128.setters = [];\n\n/**\n * Attaches a getter for all Decimal128 instances\n *\n * #### Example:\n *\n *     // Automatically convert Decimal128s to Numbers\n *     mongoose.Schema.Decimal128.get(v => v == null ? v : Number(v));\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaDecimal128.get = SchemaType.get;\n\n/**\n * Get/set the function used to cast arbitrary values to decimals.\n *\n * #### Example:\n *\n *     // Make Mongoose only refuse to cast numbers as decimal128\n *     const original = mongoose.Schema.Types.Decimal128.cast();\n *     mongoose.Decimal128.cast(v => {\n *       assert.ok(typeof v !== 'number');\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.Decimal128.cast(false);\n *\n * @param {Function} [caster]\n * @return {Function}\n * @function get\n * @static\n * @api public\n */\n\nSchemaDecimal128.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaDecimal128._defaultCaster = v => {\n  if (v != null && !isBsonType(v, 'Decimal128')) {\n    throw new Error();\n  }\n  return v;\n};\n\n/*!\n * ignore\n */\n\nSchemaDecimal128._checkRequired = v => isBsonType(v, 'Decimal128');\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaDecimal128.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaDecimal128.prototype.checkRequired = function checkRequired(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ?\n    this.constructor.checkRequired() :\n    SchemaDecimal128.checkRequired();\n\n  return _checkRequired(value);\n};\n\n/**\n * Casts to Decimal128\n *\n * @param {Object} value\n * @param {Object} doc\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nSchemaDecimal128.prototype.cast = function(value, doc, init) {\n  if (SchemaType._isRef(this, value, doc, init)) {\n    if (isBsonType(value, 'Decimal128')) {\n      return value;\n    }\n\n    return this._castRef(value, doc, init);\n  }\n\n  let castDecimal128;\n  if (typeof this._castFunction === 'function') {\n    castDecimal128 = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castDecimal128 = this.constructor.cast();\n  } else {\n    castDecimal128 = SchemaDecimal128.cast();\n  }\n\n  try {\n    return castDecimal128(value);\n  } catch (error) {\n    throw new CastError('Decimal128', value, this.path, error, this);\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\nSchemaDecimal128.prototype.$conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $lt: handleSingle,\n  $lte: handleSingle\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaDecimal128;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9kZWNpbWFsMTI4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixtQkFBbUIsbUJBQU8sQ0FBQyx5RUFBZTtBQUMxQztBQUNBLHVCQUF1QixtQkFBTyxDQUFDLG1GQUFvQjtBQUNuRCxtQkFBbUIsbUJBQU8sQ0FBQyx5RkFBdUI7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELDJCQUEyQjtBQUNuRixtQkFBbUIsc0NBQXNDO0FBQ3pEO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL2RlY2ltYWwxMjguanM/MTEyNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBTY2hlbWFUeXBlID0gcmVxdWlyZSgnLi4vc2NoZW1hVHlwZScpO1xuY29uc3QgQ2FzdEVycm9yID0gU2NoZW1hVHlwZS5DYXN0RXJyb3I7XG5jb25zdCBjYXN0RGVjaW1hbDEyOCA9IHJlcXVpcmUoJy4uL2Nhc3QvZGVjaW1hbDEyOCcpO1xuY29uc3QgaXNCc29uVHlwZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvaXNCc29uVHlwZScpO1xuXG4vKipcbiAqIERlY2ltYWwxMjggU2NoZW1hVHlwZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGluaGVyaXRzIFNjaGVtYVR5cGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU2NoZW1hRGVjaW1hbDEyOChrZXksIG9wdGlvbnMpIHtcbiAgU2NoZW1hVHlwZS5jYWxsKHRoaXMsIGtleSwgb3B0aW9ucywgJ0RlY2ltYWwxMjgnKTtcbn1cblxuLyoqXG4gKiBUaGlzIHNjaGVtYSB0eXBlJ3MgbmFtZSwgdG8gZGVmZW5kIGFnYWluc3QgbWluaWZpZXJzIHRoYXQgbWFuZ2xlXG4gKiBmdW5jdGlvbiBuYW1lcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5TY2hlbWFEZWNpbWFsMTI4LnNjaGVtYU5hbWUgPSAnRGVjaW1hbDEyOCc7XG5cblNjaGVtYURlY2ltYWwxMjguZGVmYXVsdE9wdGlvbnMgPSB7fTtcblxuLyohXG4gKiBJbmhlcml0cyBmcm9tIFNjaGVtYVR5cGUuXG4gKi9cblNjaGVtYURlY2ltYWwxMjgucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTY2hlbWFUeXBlLnByb3RvdHlwZSk7XG5TY2hlbWFEZWNpbWFsMTI4LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNjaGVtYURlY2ltYWwxMjg7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hRGVjaW1hbDEyOC5fY2FzdCA9IGNhc3REZWNpbWFsMTI4O1xuXG4vKipcbiAqIFNldHMgYSBkZWZhdWx0IG9wdGlvbiBmb3IgYWxsIERlY2ltYWwxMjggaW5zdGFuY2VzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTWFrZSBhbGwgZGVjaW1hbCAxMjhzIGhhdmUgYHJlcXVpcmVkYCBvZiB0cnVlIGJ5IGRlZmF1bHQuXG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLkRlY2ltYWwxMjguc2V0KCdyZXF1aXJlZCcsIHRydWUpO1xuICpcbiAqICAgICBjb25zdCBVc2VyID0gbW9uZ29vc2UubW9kZWwoJ1VzZXInLCBuZXcgU2NoZW1hKHsgdGVzdDogbW9uZ29vc2UuRGVjaW1hbDEyOCB9KSk7XG4gKiAgICAgbmV3IFVzZXIoeyB9KS52YWxpZGF0ZVN5bmMoKS5lcnJvcnMudGVzdC5tZXNzYWdlOyAvLyBQYXRoIGB0ZXN0YCBpcyByZXF1aXJlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9uIFRoZSBvcHRpb24geW91J2QgbGlrZSB0byBzZXQgdGhlIHZhbHVlIGZvclxuICogQHBhcmFtIHtBbnl9IHZhbHVlIHZhbHVlIGZvciBvcHRpb25cbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAqIEBmdW5jdGlvbiBzZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hRGVjaW1hbDEyOC5zZXQgPSBTY2hlbWFUeXBlLnNldDtcblxuU2NoZW1hRGVjaW1hbDEyOC5zZXR0ZXJzID0gW107XG5cbi8qKlxuICogQXR0YWNoZXMgYSBnZXR0ZXIgZm9yIGFsbCBEZWNpbWFsMTI4IGluc3RhbmNlc1xuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gQXV0b21hdGljYWxseSBjb252ZXJ0IERlY2ltYWwxMjhzIHRvIE51bWJlcnNcbiAqICAgICBtb25nb29zZS5TY2hlbWEuRGVjaW1hbDEyOC5nZXQodiA9PiB2ID09IG51bGwgPyB2IDogTnVtYmVyKHYpKTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAqIEByZXR1cm4ge3RoaXN9XG4gKiBAZnVuY3Rpb24gZ2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYURlY2ltYWwxMjguZ2V0ID0gU2NoZW1hVHlwZS5nZXQ7XG5cbi8qKlxuICogR2V0L3NldCB0aGUgZnVuY3Rpb24gdXNlZCB0byBjYXN0IGFyYml0cmFyeSB2YWx1ZXMgdG8gZGVjaW1hbHMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYWtlIE1vbmdvb3NlIG9ubHkgcmVmdXNlIHRvIGNhc3QgbnVtYmVycyBhcyBkZWNpbWFsMTI4XG4gKiAgICAgY29uc3Qgb3JpZ2luYWwgPSBtb25nb29zZS5TY2hlbWEuVHlwZXMuRGVjaW1hbDEyOC5jYXN0KCk7XG4gKiAgICAgbW9uZ29vc2UuRGVjaW1hbDEyOC5jYXN0KHYgPT4ge1xuICogICAgICAgYXNzZXJ0Lm9rKHR5cGVvZiB2ICE9PSAnbnVtYmVyJyk7XG4gKiAgICAgICByZXR1cm4gb3JpZ2luYWwodik7XG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vIE9yIGRpc2FibGUgY2FzdGluZyBlbnRpcmVseVxuICogICAgIG1vbmdvb3NlLkRlY2ltYWwxMjguY2FzdChmYWxzZSk7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2Nhc3Rlcl1cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGZ1bmN0aW9uIGdldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFEZWNpbWFsMTI4LmNhc3QgPSBmdW5jdGlvbiBjYXN0KGNhc3Rlcikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzLl9jYXN0O1xuICB9XG4gIGlmIChjYXN0ZXIgPT09IGZhbHNlKSB7XG4gICAgY2FzdGVyID0gdGhpcy5fZGVmYXVsdENhc3RlcjtcbiAgfVxuICB0aGlzLl9jYXN0ID0gY2FzdGVyO1xuXG4gIHJldHVybiB0aGlzLl9jYXN0O1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFEZWNpbWFsMTI4Ll9kZWZhdWx0Q2FzdGVyID0gdiA9PiB7XG4gIGlmICh2ICE9IG51bGwgJiYgIWlzQnNvblR5cGUodiwgJ0RlY2ltYWwxMjgnKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigpO1xuICB9XG4gIHJldHVybiB2O1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFEZWNpbWFsMTI4Ll9jaGVja1JlcXVpcmVkID0gdiA9PiBpc0Jzb25UeXBlKHYsICdEZWNpbWFsMTI4Jyk7XG5cbi8qKlxuICogT3ZlcnJpZGUgdGhlIGZ1bmN0aW9uIHRoZSByZXF1aXJlZCB2YWxpZGF0b3IgdXNlcyB0byBjaGVjayB3aGV0aGVyIGEgc3RyaW5nXG4gKiBwYXNzZXMgdGhlIGByZXF1aXJlZGAgY2hlY2suXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGZ1bmN0aW9uIGNoZWNrUmVxdWlyZWRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hRGVjaW1hbDEyOC5jaGVja1JlcXVpcmVkID0gU2NoZW1hVHlwZS5jaGVja1JlcXVpcmVkO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBzYXRpc2ZpZXMgYSByZXF1aXJlZCB2YWxpZGF0b3IuXG4gKlxuICogQHBhcmFtIHtBbnl9IHZhbHVlXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBkb2NcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYURlY2ltYWwxMjgucHJvdG90eXBlLmNoZWNrUmVxdWlyZWQgPSBmdW5jdGlvbiBjaGVja1JlcXVpcmVkKHZhbHVlLCBkb2MpIHtcbiAgaWYgKFNjaGVtYVR5cGUuX2lzUmVmKHRoaXMsIHZhbHVlLCBkb2MsIHRydWUpKSB7XG4gICAgcmV0dXJuICEhdmFsdWU7XG4gIH1cblxuICAvLyBgcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzKClgIGRvZXMgKipub3QqKiBjb3B5IHN0YXRpYyBwcm9wZXJ0aWVzLCBhbmRcbiAgLy8gcGx1Z2lucyBsaWtlIG1vbmdvb3NlLWZsb2F0IHVzZSBgaW5oZXJpdHMoKWAgZm9yIHByZS1FUzYuXG4gIGNvbnN0IF9jaGVja1JlcXVpcmVkID0gdHlwZW9mIHRoaXMuY29uc3RydWN0b3IuY2hlY2tSZXF1aXJlZCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5jaGVja1JlcXVpcmVkKCkgOlxuICAgIFNjaGVtYURlY2ltYWwxMjguY2hlY2tSZXF1aXJlZCgpO1xuXG4gIHJldHVybiBfY2hlY2tSZXF1aXJlZCh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIENhc3RzIHRvIERlY2ltYWwxMjhcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2NcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5pdCB3aGV0aGVyIHRoaXMgaXMgYW4gaW5pdGlhbGl6YXRpb24gY2FzdFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hRGVjaW1hbDEyOC5wcm90b3R5cGUuY2FzdCA9IGZ1bmN0aW9uKHZhbHVlLCBkb2MsIGluaXQpIHtcbiAgaWYgKFNjaGVtYVR5cGUuX2lzUmVmKHRoaXMsIHZhbHVlLCBkb2MsIGluaXQpKSB7XG4gICAgaWYgKGlzQnNvblR5cGUodmFsdWUsICdEZWNpbWFsMTI4JykpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fY2FzdFJlZih2YWx1ZSwgZG9jLCBpbml0KTtcbiAgfVxuXG4gIGxldCBjYXN0RGVjaW1hbDEyODtcbiAgaWYgKHR5cGVvZiB0aGlzLl9jYXN0RnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYXN0RGVjaW1hbDEyOCA9IHRoaXMuX2Nhc3RGdW5jdGlvbjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5jb25zdHJ1Y3Rvci5jYXN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FzdERlY2ltYWwxMjggPSB0aGlzLmNvbnN0cnVjdG9yLmNhc3QoKTtcbiAgfSBlbHNlIHtcbiAgICBjYXN0RGVjaW1hbDEyOCA9IFNjaGVtYURlY2ltYWwxMjguY2FzdCgpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gY2FzdERlY2ltYWwxMjgodmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJ0RlY2ltYWwxMjgnLCB2YWx1ZSwgdGhpcy5wYXRoLCBlcnJvciwgdGhpcyk7XG4gIH1cbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gaGFuZGxlU2luZ2xlKHZhbCkge1xuICByZXR1cm4gdGhpcy5jYXN0KHZhbCk7XG59XG5cblNjaGVtYURlY2ltYWwxMjgucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzID0ge1xuICAuLi5TY2hlbWFUeXBlLnByb3RvdHlwZS4kY29uZGl0aW9uYWxIYW5kbGVycyxcbiAgJGd0OiBoYW5kbGVTaW5nbGUsXG4gICRndGU6IGhhbmRsZVNpbmdsZSxcbiAgJGx0OiBoYW5kbGVTaW5nbGUsXG4gICRsdGU6IGhhbmRsZVNpbmdsZVxufTtcblxuLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYURlY2ltYWwxMjg7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/schema/decimal128.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/schema/documentArray.js":
/*!********************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/schema/documentArray.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = __webpack_require__(/*! ../error/cast */ \"../backend/node_modules/mongoose/lib/error/cast.js\");\nconst DocumentArrayElement = __webpack_require__(/*! ./documentArrayElement */ \"../backend/node_modules/mongoose/lib/schema/documentArrayElement.js\");\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst SchemaArray = __webpack_require__(/*! ./array */ \"../backend/node_modules/mongoose/lib/schema/array.js\");\nconst SchemaDocumentArrayOptions =\n  __webpack_require__(/*! ../options/schemaDocumentArrayOptions */ \"../backend/node_modules/mongoose/lib/options/schemaDocumentArrayOptions.js\");\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"../backend/node_modules/mongoose/lib/schemaType.js\");\nconst discriminator = __webpack_require__(/*! ../helpers/model/discriminator */ \"../backend/node_modules/mongoose/lib/helpers/model/discriminator.js\");\nconst handleIdOption = __webpack_require__(/*! ../helpers/schema/handleIdOption */ \"../backend/node_modules/mongoose/lib/helpers/schema/handleIdOption.js\");\nconst handleSpreadDoc = __webpack_require__(/*! ../helpers/document/handleSpreadDoc */ \"../backend/node_modules/mongoose/lib/helpers/document/handleSpreadDoc.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\nconst getConstructor = __webpack_require__(/*! ../helpers/discriminator/getConstructor */ \"../backend/node_modules/mongoose/lib/helpers/discriminator/getConstructor.js\");\nconst InvalidSchemaOptionError = __webpack_require__(/*! ../error/invalidSchemaOption */ \"../backend/node_modules/mongoose/lib/error/invalidSchemaOption.js\");\n\nconst arrayAtomicsSymbol = (__webpack_require__(/*! ../helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsSymbol);\nconst arrayPathSymbol = (__webpack_require__(/*! ../helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").arrayPathSymbol);\nconst documentArrayParent = (__webpack_require__(/*! ../helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").documentArrayParent);\n\nlet MongooseDocumentArray;\nlet Subdocument;\n\n/**\n * SubdocsArray SchemaType constructor\n *\n * @param {String} key\n * @param {Schema} schema\n * @param {Object} options\n * @param {Object} schemaOptions\n * @inherits SchemaArray\n * @api public\n */\n\nfunction SchemaDocumentArray(key, schema, options, schemaOptions) {\n  if (schema.options && schema.options.timeseries) {\n    throw new InvalidSchemaOptionError(key, 'timeseries');\n  }\n  const schemaTypeIdOption = SchemaDocumentArray.defaultOptions &&\n    SchemaDocumentArray.defaultOptions._id;\n  if (schemaTypeIdOption != null) {\n    schemaOptions = schemaOptions || {};\n    schemaOptions._id = schemaTypeIdOption;\n  }\n\n  if (schemaOptions != null && schemaOptions._id != null) {\n    schema = handleIdOption(schema, schemaOptions);\n  } else if (options != null && options._id != null) {\n    schema = handleIdOption(schema, options);\n  }\n\n  const EmbeddedDocument = _createConstructor(schema, options);\n  EmbeddedDocument.prototype.$basePath = key;\n\n  SchemaArray.call(this, key, EmbeddedDocument, options);\n\n  this.schema = schema;\n  this.schemaOptions = schemaOptions || {};\n  this.$isMongooseDocumentArray = true;\n  this.Constructor = EmbeddedDocument;\n\n  EmbeddedDocument.base = schema.base;\n\n  const fn = this.defaultValue;\n\n  if (!('defaultValue' in this) || fn !== void 0) {\n    this.default(function() {\n      let arr = fn.call(this);\n      if (arr != null && !Array.isArray(arr)) {\n        arr = [arr];\n      }\n      // Leave it up to `cast()` to convert this to a documentarray\n      return arr;\n    });\n  }\n\n  const $parentSchemaType = this;\n  this.$embeddedSchemaType = new DocumentArrayElement(key + '.$', {\n    required: this &&\n      this.schemaOptions &&\n      this.schemaOptions.required || false,\n    $parentSchemaType\n  });\n\n  this.$embeddedSchemaType.caster = this.Constructor;\n  this.$embeddedSchemaType.schema = this.schema;\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaDocumentArray.schemaName = 'DocumentArray';\n\n/**\n * Options for all document arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @api public\n */\n\nSchemaDocumentArray.options = { castNonArrays: true };\n\n/*!\n * Inherits from SchemaArray.\n */\nSchemaDocumentArray.prototype = Object.create(SchemaArray.prototype);\nSchemaDocumentArray.prototype.constructor = SchemaDocumentArray;\nSchemaDocumentArray.prototype.OptionsConstructor = SchemaDocumentArrayOptions;\n\n/*!\n * ignore\n */\n\nfunction _createConstructor(schema, options, baseClass) {\n  Subdocument || (Subdocument = __webpack_require__(/*! ../types/arraySubdocument */ \"../backend/node_modules/mongoose/lib/types/arraySubdocument.js\"));\n\n  // compile an embedded document for this schema\n  function EmbeddedDocument() {\n    Subdocument.apply(this, arguments);\n    if (this.__parentArray == null || this.__parentArray.getArrayParent() == null) {\n      return;\n    }\n    this.$session(this.__parentArray.getArrayParent().$session());\n  }\n\n  schema._preCompile();\n\n  const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;\n  EmbeddedDocument.prototype = Object.create(proto);\n  EmbeddedDocument.prototype.$__setSchema(schema);\n  EmbeddedDocument.schema = schema;\n  EmbeddedDocument.prototype.constructor = EmbeddedDocument;\n  EmbeddedDocument.$isArraySubdocument = true;\n  EmbeddedDocument.events = new EventEmitter();\n  EmbeddedDocument.base = schema.base;\n\n  // apply methods\n  for (const i in schema.methods) {\n    EmbeddedDocument.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (const i in schema.statics) {\n    EmbeddedDocument[i] = schema.statics[i];\n  }\n\n  for (const i in EventEmitter.prototype) {\n    EmbeddedDocument[i] = EventEmitter.prototype[i];\n  }\n\n  EmbeddedDocument.options = options;\n\n  return EmbeddedDocument;\n}\n\n/**\n * Adds a discriminator to this document array.\n *\n * #### Example:\n *\n *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\n *     const schema = Schema({ shapes: [shapeSchema] });\n *\n *     const docArrayPath = parentSchema.path('shapes');\n *     docArrayPath.discriminator('Circle', Schema({ radius: Number }));\n *\n * @param {String} name\n * @param {Schema} schema fields to add to the schema for instances of this sub-class\n * @param {Object|string} [options] If string, same as `options.value`.\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @see discriminators https://mongoosejs.com/docs/discriminators.html\n * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model\n * @api public\n */\n\nSchemaDocumentArray.prototype.discriminator = function(name, schema, options) {\n  if (typeof name === 'function') {\n    name = utils.getFunctionName(name);\n  }\n\n  options = options || {};\n  const tiedValue = utils.isPOJO(options) ? options.value : options;\n  const clone = typeof options.clone === 'boolean' ? options.clone : true;\n\n  if (schema.instanceOfSchema && clone) {\n    schema = schema.clone();\n  }\n\n  schema = discriminator(this.casterConstructor, name, schema, tiedValue);\n\n  const EmbeddedDocument = _createConstructor(schema, null, this.casterConstructor);\n  EmbeddedDocument.baseCasterConstructor = this.casterConstructor;\n\n  try {\n    Object.defineProperty(EmbeddedDocument, 'name', {\n      value: name\n    });\n  } catch (error) {\n    // Ignore error, only happens on old versions of node\n  }\n\n  this.casterConstructor.discriminators[name] = EmbeddedDocument;\n\n  return this.casterConstructor.discriminators[name];\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc\n *\n * @api private\n */\n\nSchemaDocumentArray.prototype.doValidate = function(array, fn, scope, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = __webpack_require__(/*! ../types/documentArray */ \"../backend/node_modules/mongoose/lib/types/documentArray/index.js\"));\n\n  const _this = this;\n  try {\n    SchemaType.prototype.doValidate.call(this, array, cb, scope);\n  } catch (err) {\n    return fn(err);\n  }\n\n  function cb(err) {\n    if (err) {\n      return fn(err);\n    }\n\n    let count = array && array.length;\n    let error;\n\n    if (!count) {\n      return fn();\n    }\n    if (options && options.updateValidator) {\n      return fn();\n    }\n    if (!utils.isMongooseDocumentArray(array)) {\n      array = new MongooseDocumentArray(array, _this.path, scope);\n    }\n\n    // handle sparse arrays, do not use array.forEach which does not\n    // iterate over sparse elements yet reports array.length including\n    // them :(\n\n    function callback(err) {\n      if (err != null) {\n        error = err;\n      }\n      --count || fn(error);\n    }\n\n    for (let i = 0, len = count; i < len; ++i) {\n      // sidestep sparse entries\n      let doc = array[i];\n      if (doc == null) {\n        --count || fn(error);\n        continue;\n      }\n\n      // If you set the array index directly, the doc might not yet be\n      // a full fledged mongoose subdoc, so make it into one.\n      if (!(doc instanceof Subdocument)) {\n        const Constructor = getConstructor(_this.casterConstructor, array[i]);\n        doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n      }\n\n      if (options != null && options.validateModifiedOnly && !doc.$isModified()) {\n        --count || fn(error);\n        continue;\n      }\n\n      doc.$__validate(null, options, callback);\n    }\n  }\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc.\n *\n * #### Note:\n *\n * This method ignores the asynchronous validators.\n *\n * @return {MongooseError|undefined}\n * @api private\n */\n\nSchemaDocumentArray.prototype.doValidateSync = function(array, scope, options) {\n  const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);\n  if (schemaTypeError != null) {\n    return schemaTypeError;\n  }\n\n  const count = array && array.length;\n  let resultError = null;\n\n  if (!count) {\n    return;\n  }\n\n  // handle sparse arrays, do not use array.forEach which does not\n  // iterate over sparse elements yet reports array.length including\n  // them :(\n\n  for (let i = 0, len = count; i < len; ++i) {\n    // sidestep sparse entries\n    let doc = array[i];\n    if (!doc) {\n      continue;\n    }\n\n    // If you set the array index directly, the doc might not yet be\n    // a full fledged mongoose subdoc, so make it into one.\n    if (!(doc instanceof Subdocument)) {\n      const Constructor = getConstructor(this.casterConstructor, array[i]);\n      doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n    }\n\n    if (options != null && options.validateModifiedOnly && !doc.$isModified()) {\n      continue;\n    }\n\n    const subdocValidateError = doc.validateSync(options);\n\n    if (subdocValidateError && resultError == null) {\n      resultError = subdocValidateError;\n    }\n  }\n\n  return resultError;\n};\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.prototype.getDefault = function(scope, init, options) {\n  let ret = typeof this.defaultValue === 'function'\n    ? this.defaultValue.call(scope)\n    : this.defaultValue;\n\n  if (ret == null) {\n    return ret;\n  }\n\n  if (options && options.skipCast) {\n    return ret;\n  }\n\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = __webpack_require__(/*! ../types/documentArray */ \"../backend/node_modules/mongoose/lib/types/documentArray/index.js\"));\n\n  if (!Array.isArray(ret)) {\n    ret = [ret];\n  }\n\n  ret = new MongooseDocumentArray(ret, this.path, scope);\n\n  for (let i = 0; i < ret.length; ++i) {\n    const Constructor = getConstructor(this.casterConstructor, ret[i]);\n    const _subdoc = new Constructor({}, ret, undefined,\n      undefined, i);\n    _subdoc.$init(ret[i]);\n    _subdoc.isNew = true;\n\n    // Make sure all paths in the subdoc are set to `default` instead\n    // of `init` since we used `init`.\n    Object.assign(_subdoc.$__.activePaths.default, _subdoc.$__.activePaths.init);\n    _subdoc.$__.activePaths.init = {};\n\n    ret[i] = _subdoc;\n  }\n\n  return ret;\n};\n\nconst _toObjectOptions = Object.freeze({ transform: false, virtuals: false });\nconst initDocumentOptions = Object.freeze({ skipId: false, willInit: true });\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @param {Document} document that triggers the casting\n * @api private\n */\n\nSchemaDocumentArray.prototype.cast = function(value, doc, init, prev, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = __webpack_require__(/*! ../types/documentArray */ \"../backend/node_modules/mongoose/lib/types/documentArray/index.js\"));\n\n  // Skip casting if `value` is the same as the previous value, no need to cast. See gh-9266\n  if (value != null && value[arrayPathSymbol] != null && value === prev) {\n    return value;\n  }\n\n  let selected;\n  let subdoc;\n\n  options = options || {};\n\n  const path = options.path || this.path;\n\n  if (!Array.isArray(value)) {\n    if (!init && !SchemaDocumentArray.options.castNonArrays) {\n      throw new CastError('DocumentArray', value, this.path, null, this);\n    }\n    // gh-2442 mark whole array as modified if we're initializing a doc from\n    // the db and the path isn't an array in the document\n    if (!!doc && init) {\n      doc.markModified(path);\n    }\n    return this.cast([value], doc, init, prev, options);\n  }\n\n  // We need to create a new array, otherwise change tracking will\n  // update the old doc (gh-4449)\n  if (!options.skipDocumentArrayCast || utils.isMongooseDocumentArray(value)) {\n    value = new MongooseDocumentArray(value, path, doc);\n  }\n\n  if (prev != null) {\n    value[arrayAtomicsSymbol] = prev[arrayAtomicsSymbol] || {};\n  }\n\n  if (options.arrayPathIndex != null) {\n    value[arrayPathSymbol] = path + '.' + options.arrayPathIndex;\n  }\n\n  const rawArray = utils.isMongooseDocumentArray(value) ? value.__array : value;\n  const len = rawArray.length;\n\n  for (let i = 0; i < len; ++i) {\n    if (!rawArray[i]) {\n      continue;\n    }\n\n    const Constructor = getConstructor(this.casterConstructor, rawArray[i]);\n\n    const spreadDoc = handleSpreadDoc(rawArray[i], true);\n    if (rawArray[i] !== spreadDoc) {\n      rawArray[i] = spreadDoc;\n    }\n\n    if (rawArray[i] instanceof Subdocument) {\n      if (rawArray[i][documentArrayParent] !== doc) {\n        if (init) {\n          const subdoc = new Constructor(null, value, initDocumentOptions, selected, i);\n          rawArray[i] = subdoc.$init(rawArray[i]);\n        } else {\n          const subdoc = new Constructor(rawArray[i], value, undefined, undefined, i);\n          rawArray[i] = subdoc;\n        }\n      }\n      // Might not have the correct index yet, so ensure it does.\n      if (rawArray[i].__index == null) {\n        rawArray[i].$setIndex(i);\n      }\n    } else if (rawArray[i] != null) {\n      if (init) {\n        if (doc) {\n          selected || (selected = scopePaths(this, doc.$__.selected, init));\n        } else {\n          selected = true;\n        }\n\n        subdoc = new Constructor(null, value, initDocumentOptions, selected, i);\n        rawArray[i] = subdoc.$init(rawArray[i]);\n      } else {\n        if (prev && typeof prev.id === 'function') {\n          subdoc = prev.id(rawArray[i]._id);\n        }\n\n        if (prev && subdoc && utils.deepEqual(subdoc.toObject(_toObjectOptions), rawArray[i])) {\n          // handle resetting doc with existing id and same data\n          subdoc.set(rawArray[i]);\n          // if set() is hooked it will have no return value\n          // see gh-746\n          rawArray[i] = subdoc;\n        } else {\n          try {\n            subdoc = new Constructor(rawArray[i], value, undefined,\n              undefined, i);\n            // if set() is hooked it will have no return value\n            // see gh-746\n            rawArray[i] = subdoc;\n          } catch (error) {\n            throw new CastError('embedded', rawArray[i],\n              value[arrayPathSymbol], error, this);\n          }\n        }\n      }\n    }\n  }\n\n  return value;\n};\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.prototype.clone = function() {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.schema, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  schematype.Constructor.discriminators = Object.assign({},\n    this.Constructor.discriminators);\n  return schematype;\n};\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.prototype.applyGetters = function(value, scope) {\n  return SchemaType.prototype.applyGetters.call(this, value, scope);\n};\n\n/**\n * Scopes paths selected in a query to this array.\n * Necessary for proper default application of subdocument values.\n *\n * @param {DocumentArrayPath} array the array to scope `fields` paths\n * @param {Object|undefined} fields the root fields selected in the query\n * @param {Boolean|undefined} init if we are being created part of a query result\n * @api private\n */\n\nfunction scopePaths(array, fields, init) {\n  if (!(init && fields)) {\n    return undefined;\n  }\n\n  const path = array.path + '.';\n  const keys = Object.keys(fields);\n  let i = keys.length;\n  const selected = {};\n  let hasKeys;\n  let key;\n  let sub;\n\n  while (i--) {\n    key = keys[i];\n    if (key.startsWith(path)) {\n      sub = key.substring(path.length);\n      if (sub === '$') {\n        continue;\n      }\n      if (sub.startsWith('$.')) {\n        sub = sub.substring(2);\n      }\n      hasKeys || (hasKeys = true);\n      selected[sub] = fields[key];\n    }\n  }\n\n  return hasKeys && selected || undefined;\n}\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.defaultOptions = {};\n\n/**\n * Sets a default option for all DocumentArray instances.\n *\n * #### Example:\n *\n *     // Make all numbers have option `min` equal to 0.\n *     mongoose.Schema.DocumentArray.set('_id', false);\n *\n * @param {String} option The name of the option you'd like to set (e.g. trim, lowercase, etc...)\n * @param {Any} value The value of the option you'd like to set.\n * @return {void}\n * @function set\n * @static\n * @api public\n */\n\nSchemaDocumentArray.set = SchemaType.set;\n\nSchemaDocumentArray.setters = [];\n\n/**\n * Attaches a getter for all DocumentArrayPath instances\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaDocumentArray.get = SchemaType.get;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaDocumentArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9kb2N1bWVudEFycmF5LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsbUJBQU8sQ0FBQyx5RUFBZTtBQUN6Qyw2QkFBNkIsbUJBQU8sQ0FBQyxtR0FBd0I7QUFDN0QscUJBQXFCLDBEQUE4QjtBQUNuRCxvQkFBb0IsbUJBQU8sQ0FBQyxxRUFBUztBQUNyQztBQUNBLEVBQUUsbUJBQU8sQ0FBQyx5SEFBdUM7QUFDakQsbUJBQW1CLG1CQUFPLENBQUMseUVBQWU7QUFDMUMsc0JBQXNCLG1CQUFPLENBQUMsMkdBQWdDO0FBQzlELHVCQUF1QixtQkFBTyxDQUFDLCtHQUFrQztBQUNqRSx3QkFBd0IsbUJBQU8sQ0FBQyxxSEFBcUM7QUFDckUsY0FBYyxtQkFBTyxDQUFDLCtEQUFVO0FBQ2hDLHVCQUF1QixtQkFBTyxDQUFDLDZIQUF5QztBQUN4RSxpQ0FBaUMsbUJBQU8sQ0FBQyx1R0FBOEI7O0FBRXZFLDJCQUEyQiw2SEFBZ0Q7QUFDM0Usd0JBQXdCLDBIQUE2QztBQUNyRSw0QkFBNEIsOEhBQWlEOztBQUU3RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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Q0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9kb2N1bWVudEFycmF5LmpzPzgxNWIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgQ2FzdEVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvY2FzdCcpO1xuY29uc3QgRG9jdW1lbnRBcnJheUVsZW1lbnQgPSByZXF1aXJlKCcuL2RvY3VtZW50QXJyYXlFbGVtZW50Jyk7XG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5jb25zdCBTY2hlbWFBcnJheSA9IHJlcXVpcmUoJy4vYXJyYXknKTtcbmNvbnN0IFNjaGVtYURvY3VtZW50QXJyYXlPcHRpb25zID1cbiAgcmVxdWlyZSgnLi4vb3B0aW9ucy9zY2hlbWFEb2N1bWVudEFycmF5T3B0aW9ucycpO1xuY29uc3QgU2NoZW1hVHlwZSA9IHJlcXVpcmUoJy4uL3NjaGVtYVR5cGUnKTtcbmNvbnN0IGRpc2NyaW1pbmF0b3IgPSByZXF1aXJlKCcuLi9oZWxwZXJzL21vZGVsL2Rpc2NyaW1pbmF0b3InKTtcbmNvbnN0IGhhbmRsZUlkT3B0aW9uID0gcmVxdWlyZSgnLi4vaGVscGVycy9zY2hlbWEvaGFuZGxlSWRPcHRpb24nKTtcbmNvbnN0IGhhbmRsZVNwcmVhZERvYyA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG9jdW1lbnQvaGFuZGxlU3ByZWFkRG9jJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5jb25zdCBnZXRDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZGlzY3JpbWluYXRvci9nZXRDb25zdHJ1Y3RvcicpO1xuY29uc3QgSW52YWxpZFNjaGVtYU9wdGlvbkVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvaW52YWxpZFNjaGVtYU9wdGlvbicpO1xuXG5jb25zdCBhcnJheUF0b21pY3NTeW1ib2wgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3N5bWJvbHMnKS5hcnJheUF0b21pY3NTeW1ib2w7XG5jb25zdCBhcnJheVBhdGhTeW1ib2wgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3N5bWJvbHMnKS5hcnJheVBhdGhTeW1ib2w7XG5jb25zdCBkb2N1bWVudEFycmF5UGFyZW50ID0gcmVxdWlyZSgnLi4vaGVscGVycy9zeW1ib2xzJykuZG9jdW1lbnRBcnJheVBhcmVudDtcblxubGV0IE1vbmdvb3NlRG9jdW1lbnRBcnJheTtcbmxldCBTdWJkb2N1bWVudDtcblxuLyoqXG4gKiBTdWJkb2NzQXJyYXkgU2NoZW1hVHlwZSBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gc2NoZW1hT3B0aW9uc1xuICogQGluaGVyaXRzIFNjaGVtYUFycmF5XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNjaGVtYURvY3VtZW50QXJyYXkoa2V5LCBzY2hlbWEsIG9wdGlvbnMsIHNjaGVtYU9wdGlvbnMpIHtcbiAgaWYgKHNjaGVtYS5vcHRpb25zICYmIHNjaGVtYS5vcHRpb25zLnRpbWVzZXJpZXMpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFNjaGVtYU9wdGlvbkVycm9yKGtleSwgJ3RpbWVzZXJpZXMnKTtcbiAgfVxuICBjb25zdCBzY2hlbWFUeXBlSWRPcHRpb24gPSBTY2hlbWFEb2N1bWVudEFycmF5LmRlZmF1bHRPcHRpb25zICYmXG4gICAgU2NoZW1hRG9jdW1lbnRBcnJheS5kZWZhdWx0T3B0aW9ucy5faWQ7XG4gIGlmIChzY2hlbWFUeXBlSWRPcHRpb24gIT0gbnVsbCkge1xuICAgIHNjaGVtYU9wdGlvbnMgPSBzY2hlbWFPcHRpb25zIHx8IHt9O1xuICAgIHNjaGVtYU9wdGlvbnMuX2lkID0gc2NoZW1hVHlwZUlkT3B0aW9uO1xuICB9XG5cbiAgaWYgKHNjaGVtYU9wdGlvbnMgIT0gbnVsbCAmJiBzY2hlbWFPcHRpb25zLl9pZCAhPSBudWxsKSB7XG4gICAgc2NoZW1hID0gaGFuZGxlSWRPcHRpb24oc2NoZW1hLCBzY2hlbWFPcHRpb25zKTtcbiAgfSBlbHNlIGlmIChvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5faWQgIT0gbnVsbCkge1xuICAgIHNjaGVtYSA9IGhhbmRsZUlkT3B0aW9uKHNjaGVtYSwgb3B0aW9ucyk7XG4gIH1cblxuICBjb25zdCBFbWJlZGRlZERvY3VtZW50ID0gX2NyZWF0ZUNvbnN0cnVjdG9yKHNjaGVtYSwgb3B0aW9ucyk7XG4gIEVtYmVkZGVkRG9jdW1lbnQucHJvdG90eXBlLiRiYXNlUGF0aCA9IGtleTtcblxuICBTY2hlbWFBcnJheS5jYWxsKHRoaXMsIGtleSwgRW1iZWRkZWREb2N1bWVudCwgb3B0aW9ucyk7XG5cbiAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gIHRoaXMuc2NoZW1hT3B0aW9ucyA9IHNjaGVtYU9wdGlvbnMgfHwge307XG4gIHRoaXMuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5ID0gdHJ1ZTtcbiAgdGhpcy5Db25zdHJ1Y3RvciA9IEVtYmVkZGVkRG9jdW1lbnQ7XG5cbiAgRW1iZWRkZWREb2N1bWVudC5iYXNlID0gc2NoZW1hLmJhc2U7XG5cbiAgY29uc3QgZm4gPSB0aGlzLmRlZmF1bHRWYWx1ZTtcblxuICBpZiAoISgnZGVmYXVsdFZhbHVlJyBpbiB0aGlzKSB8fCBmbiAhPT0gdm9pZCAwKSB7XG4gICAgdGhpcy5kZWZhdWx0KGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGFyciA9IGZuLmNhbGwodGhpcyk7XG4gICAgICBpZiAoYXJyICE9IG51bGwgJiYgIUFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgICBhcnIgPSBbYXJyXTtcbiAgICAgIH1cbiAgICAgIC8vIExlYXZlIGl0IHVwIHRvIGBjYXN0KClgIHRvIGNvbnZlcnQgdGhpcyB0byBhIGRvY3VtZW50YXJyYXlcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSk7XG4gIH1cblxuICBjb25zdCAkcGFyZW50U2NoZW1hVHlwZSA9IHRoaXM7XG4gIHRoaXMuJGVtYmVkZGVkU2NoZW1hVHlwZSA9IG5ldyBEb2N1bWVudEFycmF5RWxlbWVudChrZXkgKyAnLiQnLCB7XG4gICAgcmVxdWlyZWQ6IHRoaXMgJiZcbiAgICAgIHRoaXMuc2NoZW1hT3B0aW9ucyAmJlxuICAgICAgdGhpcy5zY2hlbWFPcHRpb25zLnJlcXVpcmVkIHx8IGZhbHNlLFxuICAgICRwYXJlbnRTY2hlbWFUeXBlXG4gIH0pO1xuXG4gIHRoaXMuJGVtYmVkZGVkU2NoZW1hVHlwZS5jYXN0ZXIgPSB0aGlzLkNvbnN0cnVjdG9yO1xuICB0aGlzLiRlbWJlZGRlZFNjaGVtYVR5cGUuc2NoZW1hID0gdGhpcy5zY2hlbWE7XG59XG5cbi8qKlxuICogVGhpcyBzY2hlbWEgdHlwZSdzIG5hbWUsIHRvIGRlZmVuZCBhZ2FpbnN0IG1pbmlmaWVycyB0aGF0IG1hbmdsZVxuICogZnVuY3Rpb24gbmFtZXMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuU2NoZW1hRG9jdW1lbnRBcnJheS5zY2hlbWFOYW1lID0gJ0RvY3VtZW50QXJyYXknO1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGFsbCBkb2N1bWVudCBhcnJheXMuXG4gKlxuICogLSBgY2FzdE5vbkFycmF5c2A6IGB0cnVlYCBieSBkZWZhdWx0LiBJZiBgZmFsc2VgLCBNb25nb29zZSB3aWxsIHRocm93IGEgQ2FzdEVycm9yIHdoZW4gYSB2YWx1ZSBpc24ndCBhbiBhcnJheS4gSWYgYHRydWVgLCBNb25nb29zZSB3aWxsIHdyYXAgdGhlIHByb3ZpZGVkIHZhbHVlIGluIGFuIGFycmF5IGJlZm9yZSBjYXN0aW5nLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hRG9jdW1lbnRBcnJheS5vcHRpb25zID0geyBjYXN0Tm9uQXJyYXlzOiB0cnVlIH07XG5cbi8qIVxuICogSW5oZXJpdHMgZnJvbSBTY2hlbWFBcnJheS5cbiAqL1xuU2NoZW1hRG9jdW1lbnRBcnJheS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNjaGVtYUFycmF5LnByb3RvdHlwZSk7XG5TY2hlbWFEb2N1bWVudEFycmF5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNjaGVtYURvY3VtZW50QXJyYXk7XG5TY2hlbWFEb2N1bWVudEFycmF5LnByb3RvdHlwZS5PcHRpb25zQ29uc3RydWN0b3IgPSBTY2hlbWFEb2N1bWVudEFycmF5T3B0aW9ucztcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBfY3JlYXRlQ29uc3RydWN0b3Ioc2NoZW1hLCBvcHRpb25zLCBiYXNlQ2xhc3MpIHtcbiAgU3ViZG9jdW1lbnQgfHwgKFN1YmRvY3VtZW50ID0gcmVxdWlyZSgnLi4vdHlwZXMvYXJyYXlTdWJkb2N1bWVudCcpKTtcblxuICAvLyBjb21waWxlIGFuIGVtYmVkZGVkIGRvY3VtZW50IGZvciB0aGlzIHNjaGVtYVxuICBmdW5jdGlvbiBFbWJlZGRlZERvY3VtZW50KCkge1xuICAgIFN1YmRvY3VtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHRoaXMuX19wYXJlbnRBcnJheSA9PSBudWxsIHx8IHRoaXMuX19wYXJlbnRBcnJheS5nZXRBcnJheVBhcmVudCgpID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4kc2Vzc2lvbih0aGlzLl9fcGFyZW50QXJyYXkuZ2V0QXJyYXlQYXJlbnQoKS4kc2Vzc2lvbigpKTtcbiAgfVxuXG4gIHNjaGVtYS5fcHJlQ29tcGlsZSgpO1xuXG4gIGNvbnN0IHByb3RvID0gYmFzZUNsYXNzICE9IG51bGwgPyBiYXNlQ2xhc3MucHJvdG90eXBlIDogU3ViZG9jdW1lbnQucHJvdG90eXBlO1xuICBFbWJlZGRlZERvY3VtZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocHJvdG8pO1xuICBFbWJlZGRlZERvY3VtZW50LnByb3RvdHlwZS4kX19zZXRTY2hlbWEoc2NoZW1hKTtcbiAgRW1iZWRkZWREb2N1bWVudC5zY2hlbWEgPSBzY2hlbWE7XG4gIEVtYmVkZGVkRG9jdW1lbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRW1iZWRkZWREb2N1bWVudDtcbiAgRW1iZWRkZWREb2N1bWVudC4kaXNBcnJheVN1YmRvY3VtZW50ID0gdHJ1ZTtcbiAgRW1iZWRkZWREb2N1bWVudC5ldmVudHMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIEVtYmVkZGVkRG9jdW1lbnQuYmFzZSA9IHNjaGVtYS5iYXNlO1xuXG4gIC8vIGFwcGx5IG1ldGhvZHNcbiAgZm9yIChjb25zdCBpIGluIHNjaGVtYS5tZXRob2RzKSB7XG4gICAgRW1iZWRkZWREb2N1bWVudC5wcm90b3R5cGVbaV0gPSBzY2hlbWEubWV0aG9kc1tpXTtcbiAgfVxuXG4gIC8vIGFwcGx5IHN0YXRpY3NcbiAgZm9yIChjb25zdCBpIGluIHNjaGVtYS5zdGF0aWNzKSB7XG4gICAgRW1iZWRkZWREb2N1bWVudFtpXSA9IHNjaGVtYS5zdGF0aWNzW2ldO1xuICB9XG5cbiAgZm9yIChjb25zdCBpIGluIEV2ZW50RW1pdHRlci5wcm90b3R5cGUpIHtcbiAgICBFbWJlZGRlZERvY3VtZW50W2ldID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZVtpXTtcbiAgfVxuXG4gIEVtYmVkZGVkRG9jdW1lbnQub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgcmV0dXJuIEVtYmVkZGVkRG9jdW1lbnQ7XG59XG5cbi8qKlxuICogQWRkcyBhIGRpc2NyaW1pbmF0b3IgdG8gdGhpcyBkb2N1bWVudCBhcnJheS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHNoYXBlU2NoZW1hID0gU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0sIHsgZGlzY3JpbWluYXRvcktleTogJ2tpbmQnIH0pO1xuICogICAgIGNvbnN0IHNjaGVtYSA9IFNjaGVtYSh7IHNoYXBlczogW3NoYXBlU2NoZW1hXSB9KTtcbiAqXG4gKiAgICAgY29uc3QgZG9jQXJyYXlQYXRoID0gcGFyZW50U2NoZW1hLnBhdGgoJ3NoYXBlcycpO1xuICogICAgIGRvY0FycmF5UGF0aC5kaXNjcmltaW5hdG9yKCdDaXJjbGUnLCBTY2hlbWEoeyByYWRpdXM6IE51bWJlciB9KSk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWEgZmllbGRzIHRvIGFkZCB0byB0aGUgc2NoZW1hIGZvciBpbnN0YW5jZXMgb2YgdGhpcyBzdWItY2xhc3NcbiAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gW29wdGlvbnNdIElmIHN0cmluZywgc2FtZSBhcyBgb3B0aW9ucy52YWx1ZWAuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudmFsdWVdIHRoZSBzdHJpbmcgc3RvcmVkIGluIHRoZSBgZGlzY3JpbWluYXRvcktleWAgcHJvcGVydHkuIElmIG5vdCBzcGVjaWZpZWQsIE1vbmdvb3NlIHVzZXMgdGhlIGBuYW1lYCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNsb25lPXRydWVdIEJ5IGRlZmF1bHQsIGBkaXNjcmltaW5hdG9yKClgIGNsb25lcyB0aGUgZ2l2ZW4gYHNjaGVtYWAuIFNldCB0byBgZmFsc2VgIHRvIHNraXAgY2xvbmluZy5cbiAqIEBzZWUgZGlzY3JpbWluYXRvcnMgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2Rpc2NyaW1pbmF0b3JzLmh0bWxcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0aGUgY29uc3RydWN0b3IgTW9uZ29vc2Ugd2lsbCB1c2UgZm9yIGNyZWF0aW5nIGluc3RhbmNlcyBvZiB0aGlzIGRpc2NyaW1pbmF0b3IgbW9kZWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hRG9jdW1lbnRBcnJheS5wcm90b3R5cGUuZGlzY3JpbWluYXRvciA9IGZ1bmN0aW9uKG5hbWUsIHNjaGVtYSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG5hbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBuYW1lID0gdXRpbHMuZ2V0RnVuY3Rpb25OYW1lKG5hbWUpO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHRpZWRWYWx1ZSA9IHV0aWxzLmlzUE9KTyhvcHRpb25zKSA/IG9wdGlvbnMudmFsdWUgOiBvcHRpb25zO1xuICBjb25zdCBjbG9uZSA9IHR5cGVvZiBvcHRpb25zLmNsb25lID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmNsb25lIDogdHJ1ZTtcblxuICBpZiAoc2NoZW1hLmluc3RhbmNlT2ZTY2hlbWEgJiYgY2xvbmUpIHtcbiAgICBzY2hlbWEgPSBzY2hlbWEuY2xvbmUoKTtcbiAgfVxuXG4gIHNjaGVtYSA9IGRpc2NyaW1pbmF0b3IodGhpcy5jYXN0ZXJDb25zdHJ1Y3RvciwgbmFtZSwgc2NoZW1hLCB0aWVkVmFsdWUpO1xuXG4gIGNvbnN0IEVtYmVkZGVkRG9jdW1lbnQgPSBfY3JlYXRlQ29uc3RydWN0b3Ioc2NoZW1hLCBudWxsLCB0aGlzLmNhc3RlckNvbnN0cnVjdG9yKTtcbiAgRW1iZWRkZWREb2N1bWVudC5iYXNlQ2FzdGVyQ29uc3RydWN0b3IgPSB0aGlzLmNhc3RlckNvbnN0cnVjdG9yO1xuXG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVtYmVkZGVkRG9jdW1lbnQsICduYW1lJywge1xuICAgICAgdmFsdWU6IG5hbWVcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBJZ25vcmUgZXJyb3IsIG9ubHkgaGFwcGVucyBvbiBvbGQgdmVyc2lvbnMgb2Ygbm9kZVxuICB9XG5cbiAgdGhpcy5jYXN0ZXJDb25zdHJ1Y3Rvci5kaXNjcmltaW5hdG9yc1tuYW1lXSA9IEVtYmVkZGVkRG9jdW1lbnQ7XG5cbiAgcmV0dXJuIHRoaXMuY2FzdGVyQ29uc3RydWN0b3IuZGlzY3JpbWluYXRvcnNbbmFtZV07XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGxvY2FsIHZhbGlkYXRpb25zIGZpcnN0LCB0aGVuIHZhbGlkYXRpb25zIG9uIGVhY2ggZW1iZWRkZWQgZG9jXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hRG9jdW1lbnRBcnJheS5wcm90b3R5cGUuZG9WYWxpZGF0ZSA9IGZ1bmN0aW9uKGFycmF5LCBmbiwgc2NvcGUsIG9wdGlvbnMpIHtcbiAgLy8gbGF6eSBsb2FkXG4gIE1vbmdvb3NlRG9jdW1lbnRBcnJheSB8fCAoTW9uZ29vc2VEb2N1bWVudEFycmF5ID0gcmVxdWlyZSgnLi4vdHlwZXMvZG9jdW1lbnRBcnJheScpKTtcblxuICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gIHRyeSB7XG4gICAgU2NoZW1hVHlwZS5wcm90b3R5cGUuZG9WYWxpZGF0ZS5jYWxsKHRoaXMsIGFycmF5LCBjYiwgc2NvcGUpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZm4oZXJyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNiKGVycikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHJldHVybiBmbihlcnIpO1xuICAgIH1cblxuICAgIGxldCBjb3VudCA9IGFycmF5ICYmIGFycmF5Lmxlbmd0aDtcbiAgICBsZXQgZXJyb3I7XG5cbiAgICBpZiAoIWNvdW50KSB7XG4gICAgICByZXR1cm4gZm4oKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy51cGRhdGVWYWxpZGF0b3IpIHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH1cbiAgICBpZiAoIXV0aWxzLmlzTW9uZ29vc2VEb2N1bWVudEFycmF5KGFycmF5KSkge1xuICAgICAgYXJyYXkgPSBuZXcgTW9uZ29vc2VEb2N1bWVudEFycmF5KGFycmF5LCBfdGhpcy5wYXRoLCBzY29wZSk7XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIHNwYXJzZSBhcnJheXMsIGRvIG5vdCB1c2UgYXJyYXkuZm9yRWFjaCB3aGljaCBkb2VzIG5vdFxuICAgIC8vIGl0ZXJhdGUgb3ZlciBzcGFyc2UgZWxlbWVudHMgeWV0IHJlcG9ydHMgYXJyYXkubGVuZ3RoIGluY2x1ZGluZ1xuICAgIC8vIHRoZW0gOihcblxuICAgIGZ1bmN0aW9uIGNhbGxiYWNrKGVycikge1xuICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgfVxuICAgICAgLS1jb3VudCB8fCBmbihlcnJvcik7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNvdW50OyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIC8vIHNpZGVzdGVwIHNwYXJzZSBlbnRyaWVzXG4gICAgICBsZXQgZG9jID0gYXJyYXlbaV07XG4gICAgICBpZiAoZG9jID09IG51bGwpIHtcbiAgICAgICAgLS1jb3VudCB8fCBmbihlcnJvcik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB5b3Ugc2V0IHRoZSBhcnJheSBpbmRleCBkaXJlY3RseSwgdGhlIGRvYyBtaWdodCBub3QgeWV0IGJlXG4gICAgICAvLyBhIGZ1bGwgZmxlZGdlZCBtb25nb29zZSBzdWJkb2MsIHNvIG1ha2UgaXQgaW50byBvbmUuXG4gICAgICBpZiAoIShkb2MgaW5zdGFuY2VvZiBTdWJkb2N1bWVudCkpIHtcbiAgICAgICAgY29uc3QgQ29uc3RydWN0b3IgPSBnZXRDb25zdHJ1Y3RvcihfdGhpcy5jYXN0ZXJDb25zdHJ1Y3RvciwgYXJyYXlbaV0pO1xuICAgICAgICBkb2MgPSBhcnJheVtpXSA9IG5ldyBDb25zdHJ1Y3Rvcihkb2MsIGFycmF5LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy52YWxpZGF0ZU1vZGlmaWVkT25seSAmJiAhZG9jLiRpc01vZGlmaWVkKCkpIHtcbiAgICAgICAgLS1jb3VudCB8fCBmbihlcnJvcik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBkb2MuJF9fdmFsaWRhdGUobnVsbCwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBsb2NhbCB2YWxpZGF0aW9ucyBmaXJzdCwgdGhlbiB2YWxpZGF0aW9ucyBvbiBlYWNoIGVtYmVkZGVkIGRvYy5cbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogVGhpcyBtZXRob2QgaWdub3JlcyB0aGUgYXN5bmNocm9ub3VzIHZhbGlkYXRvcnMuXG4gKlxuICogQHJldHVybiB7TW9uZ29vc2VFcnJvcnx1bmRlZmluZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFEb2N1bWVudEFycmF5LnByb3RvdHlwZS5kb1ZhbGlkYXRlU3luYyA9IGZ1bmN0aW9uKGFycmF5LCBzY29wZSwgb3B0aW9ucykge1xuICBjb25zdCBzY2hlbWFUeXBlRXJyb3IgPSBTY2hlbWFUeXBlLnByb3RvdHlwZS5kb1ZhbGlkYXRlU3luYy5jYWxsKHRoaXMsIGFycmF5LCBzY29wZSk7XG4gIGlmIChzY2hlbWFUeXBlRXJyb3IgIT0gbnVsbCkge1xuICAgIHJldHVybiBzY2hlbWFUeXBlRXJyb3I7XG4gIH1cblxuICBjb25zdCBjb3VudCA9IGFycmF5ICYmIGFycmF5Lmxlbmd0aDtcbiAgbGV0IHJlc3VsdEVycm9yID0gbnVsbDtcblxuICBpZiAoIWNvdW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gaGFuZGxlIHNwYXJzZSBhcnJheXMsIGRvIG5vdCB1c2UgYXJyYXkuZm9yRWFjaCB3aGljaCBkb2VzIG5vdFxuICAvLyBpdGVyYXRlIG92ZXIgc3BhcnNlIGVsZW1lbnRzIHlldCByZXBvcnRzIGFycmF5Lmxlbmd0aCBpbmNsdWRpbmdcbiAgLy8gdGhlbSA6KFxuXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjb3VudDsgaSA8IGxlbjsgKytpKSB7XG4gICAgLy8gc2lkZXN0ZXAgc3BhcnNlIGVudHJpZXNcbiAgICBsZXQgZG9jID0gYXJyYXlbaV07XG4gICAgaWYgKCFkb2MpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIElmIHlvdSBzZXQgdGhlIGFycmF5IGluZGV4IGRpcmVjdGx5LCB0aGUgZG9jIG1pZ2h0IG5vdCB5ZXQgYmVcbiAgICAvLyBhIGZ1bGwgZmxlZGdlZCBtb25nb29zZSBzdWJkb2MsIHNvIG1ha2UgaXQgaW50byBvbmUuXG4gICAgaWYgKCEoZG9jIGluc3RhbmNlb2YgU3ViZG9jdW1lbnQpKSB7XG4gICAgICBjb25zdCBDb25zdHJ1Y3RvciA9IGdldENvbnN0cnVjdG9yKHRoaXMuY2FzdGVyQ29uc3RydWN0b3IsIGFycmF5W2ldKTtcbiAgICAgIGRvYyA9IGFycmF5W2ldID0gbmV3IENvbnN0cnVjdG9yKGRvYywgYXJyYXksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBpKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMudmFsaWRhdGVNb2RpZmllZE9ubHkgJiYgIWRvYy4kaXNNb2RpZmllZCgpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBzdWJkb2NWYWxpZGF0ZUVycm9yID0gZG9jLnZhbGlkYXRlU3luYyhvcHRpb25zKTtcblxuICAgIGlmIChzdWJkb2NWYWxpZGF0ZUVycm9yICYmIHJlc3VsdEVycm9yID09IG51bGwpIHtcbiAgICAgIHJlc3VsdEVycm9yID0gc3ViZG9jVmFsaWRhdGVFcnJvcjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0RXJyb3I7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYURvY3VtZW50QXJyYXkucHJvdG90eXBlLmdldERlZmF1bHQgPSBmdW5jdGlvbihzY29wZSwgaW5pdCwgb3B0aW9ucykge1xuICBsZXQgcmV0ID0gdHlwZW9mIHRoaXMuZGVmYXVsdFZhbHVlID09PSAnZnVuY3Rpb24nXG4gICAgPyB0aGlzLmRlZmF1bHRWYWx1ZS5jYWxsKHNjb3BlKVxuICAgIDogdGhpcy5kZWZhdWx0VmFsdWU7XG5cbiAgaWYgKHJldCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc2tpcENhc3QpIHtcbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gbGF6eSBsb2FkXG4gIE1vbmdvb3NlRG9jdW1lbnRBcnJheSB8fCAoTW9uZ29vc2VEb2N1bWVudEFycmF5ID0gcmVxdWlyZSgnLi4vdHlwZXMvZG9jdW1lbnRBcnJheScpKTtcblxuICBpZiAoIUFycmF5LmlzQXJyYXkocmV0KSkge1xuICAgIHJldCA9IFtyZXRdO1xuICB9XG5cbiAgcmV0ID0gbmV3IE1vbmdvb3NlRG9jdW1lbnRBcnJheShyZXQsIHRoaXMucGF0aCwgc2NvcGUpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgQ29uc3RydWN0b3IgPSBnZXRDb25zdHJ1Y3Rvcih0aGlzLmNhc3RlckNvbnN0cnVjdG9yLCByZXRbaV0pO1xuICAgIGNvbnN0IF9zdWJkb2MgPSBuZXcgQ29uc3RydWN0b3Ioe30sIHJldCwgdW5kZWZpbmVkLFxuICAgICAgdW5kZWZpbmVkLCBpKTtcbiAgICBfc3ViZG9jLiRpbml0KHJldFtpXSk7XG4gICAgX3N1YmRvYy5pc05ldyA9IHRydWU7XG5cbiAgICAvLyBNYWtlIHN1cmUgYWxsIHBhdGhzIGluIHRoZSBzdWJkb2MgYXJlIHNldCB0byBgZGVmYXVsdGAgaW5zdGVhZFxuICAgIC8vIG9mIGBpbml0YCBzaW5jZSB3ZSB1c2VkIGBpbml0YC5cbiAgICBPYmplY3QuYXNzaWduKF9zdWJkb2MuJF9fLmFjdGl2ZVBhdGhzLmRlZmF1bHQsIF9zdWJkb2MuJF9fLmFjdGl2ZVBhdGhzLmluaXQpO1xuICAgIF9zdWJkb2MuJF9fLmFjdGl2ZVBhdGhzLmluaXQgPSB7fTtcblxuICAgIHJldFtpXSA9IF9zdWJkb2M7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuY29uc3QgX3RvT2JqZWN0T3B0aW9ucyA9IE9iamVjdC5mcmVlemUoeyB0cmFuc2Zvcm06IGZhbHNlLCB2aXJ0dWFsczogZmFsc2UgfSk7XG5jb25zdCBpbml0RG9jdW1lbnRPcHRpb25zID0gT2JqZWN0LmZyZWV6ZSh7IHNraXBJZDogZmFsc2UsIHdpbGxJbml0OiB0cnVlIH0pO1xuXG4vKipcbiAqIENhc3RzIGNvbnRlbnRzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBkb2N1bWVudCB0aGF0IHRyaWdnZXJzIHRoZSBjYXN0aW5nXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFEb2N1bWVudEFycmF5LnByb3RvdHlwZS5jYXN0ID0gZnVuY3Rpb24odmFsdWUsIGRvYywgaW5pdCwgcHJldiwgb3B0aW9ucykge1xuICAvLyBsYXp5IGxvYWRcbiAgTW9uZ29vc2VEb2N1bWVudEFycmF5IHx8IChNb25nb29zZURvY3VtZW50QXJyYXkgPSByZXF1aXJlKCcuLi90eXBlcy9kb2N1bWVudEFycmF5JykpO1xuXG4gIC8vIFNraXAgY2FzdGluZyBpZiBgdmFsdWVgIGlzIHRoZSBzYW1lIGFzIHRoZSBwcmV2aW91cyB2YWx1ZSwgbm8gbmVlZCB0byBjYXN0LiBTZWUgZ2gtOTI2NlxuICBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZVthcnJheVBhdGhTeW1ib2xdICE9IG51bGwgJiYgdmFsdWUgPT09IHByZXYpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBsZXQgc2VsZWN0ZWQ7XG4gIGxldCBzdWJkb2M7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgY29uc3QgcGF0aCA9IG9wdGlvbnMucGF0aCB8fCB0aGlzLnBhdGg7XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGlmICghaW5pdCAmJiAhU2NoZW1hRG9jdW1lbnRBcnJheS5vcHRpb25zLmNhc3ROb25BcnJheXMpIHtcbiAgICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJ0RvY3VtZW50QXJyYXknLCB2YWx1ZSwgdGhpcy5wYXRoLCBudWxsLCB0aGlzKTtcbiAgICB9XG4gICAgLy8gZ2gtMjQ0MiBtYXJrIHdob2xlIGFycmF5IGFzIG1vZGlmaWVkIGlmIHdlJ3JlIGluaXRpYWxpemluZyBhIGRvYyBmcm9tXG4gICAgLy8gdGhlIGRiIGFuZCB0aGUgcGF0aCBpc24ndCBhbiBhcnJheSBpbiB0aGUgZG9jdW1lbnRcbiAgICBpZiAoISFkb2MgJiYgaW5pdCkge1xuICAgICAgZG9jLm1hcmtNb2RpZmllZChwYXRoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2FzdChbdmFsdWVdLCBkb2MsIGluaXQsIHByZXYsIG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gV2UgbmVlZCB0byBjcmVhdGUgYSBuZXcgYXJyYXksIG90aGVyd2lzZSBjaGFuZ2UgdHJhY2tpbmcgd2lsbFxuICAvLyB1cGRhdGUgdGhlIG9sZCBkb2MgKGdoLTQ0NDkpXG4gIGlmICghb3B0aW9ucy5za2lwRG9jdW1lbnRBcnJheUNhc3QgfHwgdXRpbHMuaXNNb25nb29zZURvY3VtZW50QXJyYXkodmFsdWUpKSB7XG4gICAgdmFsdWUgPSBuZXcgTW9uZ29vc2VEb2N1bWVudEFycmF5KHZhbHVlLCBwYXRoLCBkb2MpO1xuICB9XG5cbiAgaWYgKHByZXYgIT0gbnVsbCkge1xuICAgIHZhbHVlW2FycmF5QXRvbWljc1N5bWJvbF0gPSBwcmV2W2FycmF5QXRvbWljc1N5bWJvbF0gfHwge307XG4gIH1cblxuICBpZiAob3B0aW9ucy5hcnJheVBhdGhJbmRleCAhPSBudWxsKSB7XG4gICAgdmFsdWVbYXJyYXlQYXRoU3ltYm9sXSA9IHBhdGggKyAnLicgKyBvcHRpb25zLmFycmF5UGF0aEluZGV4O1xuICB9XG5cbiAgY29uc3QgcmF3QXJyYXkgPSB1dGlscy5pc01vbmdvb3NlRG9jdW1lbnRBcnJheSh2YWx1ZSkgPyB2YWx1ZS5fX2FycmF5IDogdmFsdWU7XG4gIGNvbnN0IGxlbiA9IHJhd0FycmF5Lmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKCFyYXdBcnJheVtpXSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgQ29uc3RydWN0b3IgPSBnZXRDb25zdHJ1Y3Rvcih0aGlzLmNhc3RlckNvbnN0cnVjdG9yLCByYXdBcnJheVtpXSk7XG5cbiAgICBjb25zdCBzcHJlYWREb2MgPSBoYW5kbGVTcHJlYWREb2MocmF3QXJyYXlbaV0sIHRydWUpO1xuICAgIGlmIChyYXdBcnJheVtpXSAhPT0gc3ByZWFkRG9jKSB7XG4gICAgICByYXdBcnJheVtpXSA9IHNwcmVhZERvYztcbiAgICB9XG5cbiAgICBpZiAocmF3QXJyYXlbaV0gaW5zdGFuY2VvZiBTdWJkb2N1bWVudCkge1xuICAgICAgaWYgKHJhd0FycmF5W2ldW2RvY3VtZW50QXJyYXlQYXJlbnRdICE9PSBkb2MpIHtcbiAgICAgICAgaWYgKGluaXQpIHtcbiAgICAgICAgICBjb25zdCBzdWJkb2MgPSBuZXcgQ29uc3RydWN0b3IobnVsbCwgdmFsdWUsIGluaXREb2N1bWVudE9wdGlvbnMsIHNlbGVjdGVkLCBpKTtcbiAgICAgICAgICByYXdBcnJheVtpXSA9IHN1YmRvYy4kaW5pdChyYXdBcnJheVtpXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qgc3ViZG9jID0gbmV3IENvbnN0cnVjdG9yKHJhd0FycmF5W2ldLCB2YWx1ZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGkpO1xuICAgICAgICAgIHJhd0FycmF5W2ldID0gc3ViZG9jO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBNaWdodCBub3QgaGF2ZSB0aGUgY29ycmVjdCBpbmRleCB5ZXQsIHNvIGVuc3VyZSBpdCBkb2VzLlxuICAgICAgaWYgKHJhd0FycmF5W2ldLl9faW5kZXggPT0gbnVsbCkge1xuICAgICAgICByYXdBcnJheVtpXS4kc2V0SW5kZXgoaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyYXdBcnJheVtpXSAhPSBudWxsKSB7XG4gICAgICBpZiAoaW5pdCkge1xuICAgICAgICBpZiAoZG9jKSB7XG4gICAgICAgICAgc2VsZWN0ZWQgfHwgKHNlbGVjdGVkID0gc2NvcGVQYXRocyh0aGlzLCBkb2MuJF9fLnNlbGVjdGVkLCBpbml0KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgc3ViZG9jID0gbmV3IENvbnN0cnVjdG9yKG51bGwsIHZhbHVlLCBpbml0RG9jdW1lbnRPcHRpb25zLCBzZWxlY3RlZCwgaSk7XG4gICAgICAgIHJhd0FycmF5W2ldID0gc3ViZG9jLiRpbml0KHJhd0FycmF5W2ldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcmV2ICYmIHR5cGVvZiBwcmV2LmlkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgc3ViZG9jID0gcHJldi5pZChyYXdBcnJheVtpXS5faWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXYgJiYgc3ViZG9jICYmIHV0aWxzLmRlZXBFcXVhbChzdWJkb2MudG9PYmplY3QoX3RvT2JqZWN0T3B0aW9ucyksIHJhd0FycmF5W2ldKSkge1xuICAgICAgICAgIC8vIGhhbmRsZSByZXNldHRpbmcgZG9jIHdpdGggZXhpc3RpbmcgaWQgYW5kIHNhbWUgZGF0YVxuICAgICAgICAgIHN1YmRvYy5zZXQocmF3QXJyYXlbaV0pO1xuICAgICAgICAgIC8vIGlmIHNldCgpIGlzIGhvb2tlZCBpdCB3aWxsIGhhdmUgbm8gcmV0dXJuIHZhbHVlXG4gICAgICAgICAgLy8gc2VlIGdoLTc0NlxuICAgICAgICAgIHJhd0FycmF5W2ldID0gc3ViZG9jO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdWJkb2MgPSBuZXcgQ29uc3RydWN0b3IocmF3QXJyYXlbaV0sIHZhbHVlLCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIHVuZGVmaW5lZCwgaSk7XG4gICAgICAgICAgICAvLyBpZiBzZXQoKSBpcyBob29rZWQgaXQgd2lsbCBoYXZlIG5vIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgLy8gc2VlIGdoLTc0NlxuICAgICAgICAgICAgcmF3QXJyYXlbaV0gPSBzdWJkb2M7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJ2VtYmVkZGVkJywgcmF3QXJyYXlbaV0sXG4gICAgICAgICAgICAgIHZhbHVlW2FycmF5UGF0aFN5bWJvbF0sIGVycm9yLCB0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYURvY3VtZW50QXJyYXkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpO1xuICBjb25zdCBzY2hlbWF0eXBlID0gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5wYXRoLCB0aGlzLnNjaGVtYSwgb3B0aW9ucywgdGhpcy5zY2hlbWFPcHRpb25zKTtcbiAgc2NoZW1hdHlwZS52YWxpZGF0b3JzID0gdGhpcy52YWxpZGF0b3JzLnNsaWNlKCk7XG4gIGlmICh0aGlzLnJlcXVpcmVkVmFsaWRhdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICBzY2hlbWF0eXBlLnJlcXVpcmVkVmFsaWRhdG9yID0gdGhpcy5yZXF1aXJlZFZhbGlkYXRvcjtcbiAgfVxuICBzY2hlbWF0eXBlLkNvbnN0cnVjdG9yLmRpc2NyaW1pbmF0b3JzID0gT2JqZWN0LmFzc2lnbih7fSxcbiAgICB0aGlzLkNvbnN0cnVjdG9yLmRpc2NyaW1pbmF0b3JzKTtcbiAgcmV0dXJuIHNjaGVtYXR5cGU7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYURvY3VtZW50QXJyYXkucHJvdG90eXBlLmFwcGx5R2V0dGVycyA9IGZ1bmN0aW9uKHZhbHVlLCBzY29wZSkge1xuICByZXR1cm4gU2NoZW1hVHlwZS5wcm90b3R5cGUuYXBwbHlHZXR0ZXJzLmNhbGwodGhpcywgdmFsdWUsIHNjb3BlKTtcbn07XG5cbi8qKlxuICogU2NvcGVzIHBhdGhzIHNlbGVjdGVkIGluIGEgcXVlcnkgdG8gdGhpcyBhcnJheS5cbiAqIE5lY2Vzc2FyeSBmb3IgcHJvcGVyIGRlZmF1bHQgYXBwbGljYXRpb24gb2Ygc3ViZG9jdW1lbnQgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7RG9jdW1lbnRBcnJheVBhdGh9IGFycmF5IHRoZSBhcnJheSB0byBzY29wZSBgZmllbGRzYCBwYXRoc1xuICogQHBhcmFtIHtPYmplY3R8dW5kZWZpbmVkfSBmaWVsZHMgdGhlIHJvb3QgZmllbGRzIHNlbGVjdGVkIGluIHRoZSBxdWVyeVxuICogQHBhcmFtIHtCb29sZWFufHVuZGVmaW5lZH0gaW5pdCBpZiB3ZSBhcmUgYmVpbmcgY3JlYXRlZCBwYXJ0IG9mIGEgcXVlcnkgcmVzdWx0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzY29wZVBhdGhzKGFycmF5LCBmaWVsZHMsIGluaXQpIHtcbiAgaWYgKCEoaW5pdCAmJiBmaWVsZHMpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IHBhdGggPSBhcnJheS5wYXRoICsgJy4nO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZmllbGRzKTtcbiAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcbiAgY29uc3Qgc2VsZWN0ZWQgPSB7fTtcbiAgbGV0IGhhc0tleXM7XG4gIGxldCBrZXk7XG4gIGxldCBzdWI7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgaWYgKGtleS5zdGFydHNXaXRoKHBhdGgpKSB7XG4gICAgICBzdWIgPSBrZXkuc3Vic3RyaW5nKHBhdGgubGVuZ3RoKTtcbiAgICAgIGlmIChzdWIgPT09ICckJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdWIuc3RhcnRzV2l0aCgnJC4nKSkge1xuICAgICAgICBzdWIgPSBzdWIuc3Vic3RyaW5nKDIpO1xuICAgICAgfVxuICAgICAgaGFzS2V5cyB8fCAoaGFzS2V5cyA9IHRydWUpO1xuICAgICAgc2VsZWN0ZWRbc3ViXSA9IGZpZWxkc1trZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBoYXNLZXlzICYmIHNlbGVjdGVkIHx8IHVuZGVmaW5lZDtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFEb2N1bWVudEFycmF5LmRlZmF1bHRPcHRpb25zID0ge307XG5cbi8qKlxuICogU2V0cyBhIGRlZmF1bHQgb3B0aW9uIGZvciBhbGwgRG9jdW1lbnRBcnJheSBpbnN0YW5jZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYWtlIGFsbCBudW1iZXJzIGhhdmUgb3B0aW9uIGBtaW5gIGVxdWFsIHRvIDAuXG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLkRvY3VtZW50QXJyYXkuc2V0KCdfaWQnLCBmYWxzZSk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbiBUaGUgbmFtZSBvZiB0aGUgb3B0aW9uIHlvdSdkIGxpa2UgdG8gc2V0IChlLmcuIHRyaW0sIGxvd2VyY2FzZSwgZXRjLi4uKVxuICogQHBhcmFtIHtBbnl9IHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgb3B0aW9uIHlvdSdkIGxpa2UgdG8gc2V0LlxuICogQHJldHVybiB7dm9pZH1cbiAqIEBmdW5jdGlvbiBzZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hRG9jdW1lbnRBcnJheS5zZXQgPSBTY2hlbWFUeXBlLnNldDtcblxuU2NoZW1hRG9jdW1lbnRBcnJheS5zZXR0ZXJzID0gW107XG5cbi8qKlxuICogQXR0YWNoZXMgYSBnZXR0ZXIgZm9yIGFsbCBEb2N1bWVudEFycmF5UGF0aCBpbnN0YW5jZXNcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAqIEByZXR1cm4ge3RoaXN9XG4gKiBAZnVuY3Rpb24gZ2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYURvY3VtZW50QXJyYXkuZ2V0ID0gU2NoZW1hVHlwZS5nZXQ7XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFEb2N1bWVudEFycmF5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/schema/documentArray.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/schema/documentArrayElement.js":
/*!***************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/schema/documentArrayElement.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseError = __webpack_require__(/*! ../error/mongooseError */ \"../backend/node_modules/mongoose/lib/error/mongooseError.js\");\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"../backend/node_modules/mongoose/lib/schemaType.js\");\nconst SchemaSubdocument = __webpack_require__(/*! ./subdocument */ \"../backend/node_modules/mongoose/lib/schema/subdocument.js\");\nconst getConstructor = __webpack_require__(/*! ../helpers/discriminator/getConstructor */ \"../backend/node_modules/mongoose/lib/helpers/discriminator/getConstructor.js\");\n\n/**\n * DocumentArrayElement SchemaType constructor.\n *\n * @param {String} path\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaDocumentArrayElement(path, options) {\n  this.$parentSchemaType = options && options.$parentSchemaType;\n  if (!this.$parentSchemaType) {\n    throw new MongooseError('Cannot create DocumentArrayElement schematype without a parent');\n  }\n  delete options.$parentSchemaType;\n\n  SchemaType.call(this, path, options, 'DocumentArrayElement');\n\n  this.$isMongooseDocumentArrayElement = true;\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaDocumentArrayElement.schemaName = 'DocumentArrayElement';\n\nSchemaDocumentArrayElement.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaDocumentArrayElement.prototype = Object.create(SchemaType.prototype);\nSchemaDocumentArrayElement.prototype.constructor = SchemaDocumentArrayElement;\n\n/**\n * Casts `val` for DocumentArrayElement.\n *\n * @param {Object} value to cast\n * @api private\n */\n\nSchemaDocumentArrayElement.prototype.cast = function(...args) {\n  return this.$parentSchemaType.cast(...args)[0];\n};\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $cond\n * @param {any} [val]\n * @api private\n */\n\nSchemaDocumentArrayElement.prototype.doValidate = function(value, fn, scope, options) {\n  const Constructor = getConstructor(this.caster, value);\n\n  if (value && !(value instanceof Constructor)) {\n    value = new Constructor(value, scope, null, null, options && options.index != null ? options.index : null);\n  }\n\n  return SchemaSubdocument.prototype.doValidate.call(this, value, fn, scope, options);\n};\n\n/**\n * Clone the current SchemaType\n *\n * @return {DocumentArrayElement} The cloned instance\n * @api private\n */\n\nSchemaDocumentArrayElement.prototype.clone = function() {\n  this.options.$parentSchemaType = this.$parentSchemaType;\n  const ret = SchemaType.prototype.clone.apply(this, arguments);\n  delete this.options.$parentSchemaType;\n\n  ret.caster = this.caster;\n  ret.schema = this.schema;\n\n  return ret;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaDocumentArrayElement;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9kb2N1bWVudEFycmF5RWxlbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsMkZBQXdCO0FBQ3RELG1CQUFtQixtQkFBTyxDQUFDLHlFQUFlO0FBQzFDLDBCQUEwQixtQkFBTyxDQUFDLGlGQUFlO0FBQ2pELHVCQUF1QixtQkFBTyxDQUFDLDZIQUF5Qzs7QUFFeEU7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9kb2N1bWVudEFycmF5RWxlbWVudC5qcz8zYTY4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvci9tb25nb29zZUVycm9yJyk7XG5jb25zdCBTY2hlbWFUeXBlID0gcmVxdWlyZSgnLi4vc2NoZW1hVHlwZScpO1xuY29uc3QgU2NoZW1hU3ViZG9jdW1lbnQgPSByZXF1aXJlKCcuL3N1YmRvY3VtZW50Jyk7XG5jb25zdCBnZXRDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZGlzY3JpbWluYXRvci9nZXRDb25zdHJ1Y3RvcicpO1xuXG4vKipcbiAqIERvY3VtZW50QXJyYXlFbGVtZW50IFNjaGVtYVR5cGUgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAaW5oZXJpdHMgU2NoZW1hVHlwZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTY2hlbWFEb2N1bWVudEFycmF5RWxlbWVudChwYXRoLCBvcHRpb25zKSB7XG4gIHRoaXMuJHBhcmVudFNjaGVtYVR5cGUgPSBvcHRpb25zICYmIG9wdGlvbnMuJHBhcmVudFNjaGVtYVR5cGU7XG4gIGlmICghdGhpcy4kcGFyZW50U2NoZW1hVHlwZSkge1xuICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdDYW5ub3QgY3JlYXRlIERvY3VtZW50QXJyYXlFbGVtZW50IHNjaGVtYXR5cGUgd2l0aG91dCBhIHBhcmVudCcpO1xuICB9XG4gIGRlbGV0ZSBvcHRpb25zLiRwYXJlbnRTY2hlbWFUeXBlO1xuXG4gIFNjaGVtYVR5cGUuY2FsbCh0aGlzLCBwYXRoLCBvcHRpb25zLCAnRG9jdW1lbnRBcnJheUVsZW1lbnQnKTtcblxuICB0aGlzLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheUVsZW1lbnQgPSB0cnVlO1xufVxuXG4vKipcbiAqIFRoaXMgc2NoZW1hIHR5cGUncyBuYW1lLCB0byBkZWZlbmQgYWdhaW5zdCBtaW5pZmllcnMgdGhhdCBtYW5nbGVcbiAqIGZ1bmN0aW9uIG5hbWVzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblNjaGVtYURvY3VtZW50QXJyYXlFbGVtZW50LnNjaGVtYU5hbWUgPSAnRG9jdW1lbnRBcnJheUVsZW1lbnQnO1xuXG5TY2hlbWFEb2N1bWVudEFycmF5RWxlbWVudC5kZWZhdWx0T3B0aW9ucyA9IHt9O1xuXG4vKiFcbiAqIEluaGVyaXRzIGZyb20gU2NoZW1hVHlwZS5cbiAqL1xuU2NoZW1hRG9jdW1lbnRBcnJheUVsZW1lbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTY2hlbWFUeXBlLnByb3RvdHlwZSk7XG5TY2hlbWFEb2N1bWVudEFycmF5RWxlbWVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTY2hlbWFEb2N1bWVudEFycmF5RWxlbWVudDtcblxuLyoqXG4gKiBDYXN0cyBgdmFsYCBmb3IgRG9jdW1lbnRBcnJheUVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIHRvIGNhc3RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYURvY3VtZW50QXJyYXlFbGVtZW50LnByb3RvdHlwZS5jYXN0ID0gZnVuY3Rpb24oLi4uYXJncykge1xuICByZXR1cm4gdGhpcy4kcGFyZW50U2NoZW1hVHlwZS5jYXN0KC4uLmFyZ3MpWzBdO1xufTtcblxuLyoqXG4gKiBDYXN0cyBjb250ZW50cyBmb3IgcXVlcmllcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gJGNvbmRcbiAqIEBwYXJhbSB7YW55fSBbdmFsXVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hRG9jdW1lbnRBcnJheUVsZW1lbnQucHJvdG90eXBlLmRvVmFsaWRhdGUgPSBmdW5jdGlvbih2YWx1ZSwgZm4sIHNjb3BlLCBvcHRpb25zKSB7XG4gIGNvbnN0IENvbnN0cnVjdG9yID0gZ2V0Q29uc3RydWN0b3IodGhpcy5jYXN0ZXIsIHZhbHVlKTtcblxuICBpZiAodmFsdWUgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHZhbHVlID0gbmV3IENvbnN0cnVjdG9yKHZhbHVlLCBzY29wZSwgbnVsbCwgbnVsbCwgb3B0aW9ucyAmJiBvcHRpb25zLmluZGV4ICE9IG51bGwgPyBvcHRpb25zLmluZGV4IDogbnVsbCk7XG4gIH1cblxuICByZXR1cm4gU2NoZW1hU3ViZG9jdW1lbnQucHJvdG90eXBlLmRvVmFsaWRhdGUuY2FsbCh0aGlzLCB2YWx1ZSwgZm4sIHNjb3BlLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQ2xvbmUgdGhlIGN1cnJlbnQgU2NoZW1hVHlwZVxuICpcbiAqIEByZXR1cm4ge0RvY3VtZW50QXJyYXlFbGVtZW50fSBUaGUgY2xvbmVkIGluc3RhbmNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFEb2N1bWVudEFycmF5RWxlbWVudC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5vcHRpb25zLiRwYXJlbnRTY2hlbWFUeXBlID0gdGhpcy4kcGFyZW50U2NoZW1hVHlwZTtcbiAgY29uc3QgcmV0ID0gU2NoZW1hVHlwZS5wcm90b3R5cGUuY2xvbmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgZGVsZXRlIHRoaXMub3B0aW9ucy4kcGFyZW50U2NoZW1hVHlwZTtcblxuICByZXQuY2FzdGVyID0gdGhpcy5jYXN0ZXI7XG4gIHJldC5zY2hlbWEgPSB0aGlzLnNjaGVtYTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuLyohXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjaGVtYURvY3VtZW50QXJyYXlFbGVtZW50O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/schema/documentArrayElement.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/schema/index.js":
/*!************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/schema/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Module exports.\n */\n\n\n\nexports.Array = __webpack_require__(/*! ./array */ \"../backend/node_modules/mongoose/lib/schema/array.js\");\nexports.BigInt = __webpack_require__(/*! ./bigint */ \"../backend/node_modules/mongoose/lib/schema/bigint.js\");\nexports.Boolean = __webpack_require__(/*! ./boolean */ \"../backend/node_modules/mongoose/lib/schema/boolean.js\");\nexports.Buffer = __webpack_require__(/*! ./buffer */ \"../backend/node_modules/mongoose/lib/schema/buffer.js\");\nexports.Date = __webpack_require__(/*! ./date */ \"../backend/node_modules/mongoose/lib/schema/date.js\");\nexports.Decimal128 = exports.Decimal = __webpack_require__(/*! ./decimal128 */ \"../backend/node_modules/mongoose/lib/schema/decimal128.js\");\nexports.DocumentArray = __webpack_require__(/*! ./documentArray */ \"../backend/node_modules/mongoose/lib/schema/documentArray.js\");\nexports.Map = __webpack_require__(/*! ./map */ \"../backend/node_modules/mongoose/lib/schema/map.js\");\nexports.Mixed = __webpack_require__(/*! ./mixed */ \"../backend/node_modules/mongoose/lib/schema/mixed.js\");\nexports.Number = __webpack_require__(/*! ./number */ \"../backend/node_modules/mongoose/lib/schema/number.js\");\nexports.ObjectId = __webpack_require__(/*! ./objectId */ \"../backend/node_modules/mongoose/lib/schema/objectId.js\");\nexports.String = __webpack_require__(/*! ./string */ \"../backend/node_modules/mongoose/lib/schema/string.js\");\nexports.Subdocument = __webpack_require__(/*! ./subdocument */ \"../backend/node_modules/mongoose/lib/schema/subdocument.js\");\nexports.UUID = __webpack_require__(/*! ./uuid */ \"../backend/node_modules/mongoose/lib/schema/uuid.js\");\n\n// alias\n\nexports.Oid = exports.ObjectId;\nexports.Object = exports.Mixed;\nexports.Bool = exports.Boolean;\nexports.ObjectID = exports.ObjectId;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLDBHQUFrQztBQUNsQyw2R0FBb0M7QUFDcEMsZ0hBQXNDO0FBQ3RDLDZHQUFvQztBQUNwQyx1R0FBZ0M7QUFDaEMsa0JBQWtCLEdBQUcsc0hBQXlDO0FBQzlELGtJQUFrRDtBQUNsRCxvR0FBOEI7QUFDOUIsMEdBQWtDO0FBQ2xDLDZHQUFvQztBQUNwQyxtSEFBd0M7QUFDeEMsNkdBQW9DO0FBQ3BDLDRIQUE4QztBQUM5Qyx1R0FBZ0M7O0FBRWhDOztBQUVBLFdBQVc7QUFDWCxjQUFjO0FBQ2QsWUFBWTtBQUNaLGdCQUFnQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9zY2hlbWEvaW5kZXguanM/YjMxZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLkFycmF5ID0gcmVxdWlyZSgnLi9hcnJheScpO1xuZXhwb3J0cy5CaWdJbnQgPSByZXF1aXJlKCcuL2JpZ2ludCcpO1xuZXhwb3J0cy5Cb29sZWFuID0gcmVxdWlyZSgnLi9ib29sZWFuJyk7XG5leHBvcnRzLkJ1ZmZlciA9IHJlcXVpcmUoJy4vYnVmZmVyJyk7XG5leHBvcnRzLkRhdGUgPSByZXF1aXJlKCcuL2RhdGUnKTtcbmV4cG9ydHMuRGVjaW1hbDEyOCA9IGV4cG9ydHMuRGVjaW1hbCA9IHJlcXVpcmUoJy4vZGVjaW1hbDEyOCcpO1xuZXhwb3J0cy5Eb2N1bWVudEFycmF5ID0gcmVxdWlyZSgnLi9kb2N1bWVudEFycmF5Jyk7XG5leHBvcnRzLk1hcCA9IHJlcXVpcmUoJy4vbWFwJyk7XG5leHBvcnRzLk1peGVkID0gcmVxdWlyZSgnLi9taXhlZCcpO1xuZXhwb3J0cy5OdW1iZXIgPSByZXF1aXJlKCcuL251bWJlcicpO1xuZXhwb3J0cy5PYmplY3RJZCA9IHJlcXVpcmUoJy4vb2JqZWN0SWQnKTtcbmV4cG9ydHMuU3RyaW5nID0gcmVxdWlyZSgnLi9zdHJpbmcnKTtcbmV4cG9ydHMuU3ViZG9jdW1lbnQgPSByZXF1aXJlKCcuL3N1YmRvY3VtZW50Jyk7XG5leHBvcnRzLlVVSUQgPSByZXF1aXJlKCcuL3V1aWQnKTtcblxuLy8gYWxpYXNcblxuZXhwb3J0cy5PaWQgPSBleHBvcnRzLk9iamVjdElkO1xuZXhwb3J0cy5PYmplY3QgPSBleHBvcnRzLk1peGVkO1xuZXhwb3J0cy5Cb29sID0gZXhwb3J0cy5Cb29sZWFuO1xuZXhwb3J0cy5PYmplY3RJRCA9IGV4cG9ydHMuT2JqZWN0SWQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/schema/index.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/schema/map.js":
/*!**********************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/schema/map.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nconst MongooseMap = __webpack_require__(/*! ../types/map */ \"../backend/node_modules/mongoose/lib/types/map.js\");\nconst SchemaMapOptions = __webpack_require__(/*! ../options/schemaMapOptions */ \"../backend/node_modules/mongoose/lib/options/schemaMapOptions.js\");\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"../backend/node_modules/mongoose/lib/schemaType.js\");\n/*!\n * ignore\n */\n\nclass SchemaMap extends SchemaType {\n  constructor(key, options) {\n    super(key, options, 'Map');\n    this.$isSchemaMap = true;\n  }\n\n  set(option, value) {\n    return SchemaType.set(option, value);\n  }\n\n  cast(val, doc, init) {\n    if (val instanceof MongooseMap) {\n      return val;\n    }\n\n    const path = this.path;\n\n    if (init) {\n      const map = new MongooseMap({}, path, doc, this.$__schemaType);\n\n      if (val instanceof global.Map) {\n        for (const key of val.keys()) {\n          let _val = val.get(key);\n          if (_val == null) {\n            _val = map.$__schemaType._castNullish(_val);\n          } else {\n            _val = map.$__schemaType.cast(_val, doc, true, null, { path: path + '.' + key });\n          }\n          map.$init(key, _val);\n        }\n      } else {\n        for (const key of Object.keys(val)) {\n          let _val = val[key];\n          if (_val == null) {\n            _val = map.$__schemaType._castNullish(_val);\n          } else {\n            _val = map.$__schemaType.cast(_val, doc, true, null, { path: path + '.' + key });\n          }\n          map.$init(key, _val);\n        }\n      }\n\n      return map;\n    }\n\n    return new MongooseMap(val, path, doc, this.$__schemaType);\n  }\n\n  clone() {\n    const schematype = super.clone();\n\n    if (this.$__schemaType != null) {\n      schematype.$__schemaType = this.$__schemaType.clone();\n    }\n    return schematype;\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaMap.schemaName = 'Map';\n\nSchemaMap.prototype.OptionsConstructor = SchemaMapOptions;\n\nSchemaMap.defaultOptions = {};\n\nmodule.exports = SchemaMap;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9tYXAuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixtQkFBTyxDQUFDLHVFQUFjO0FBQzFDLHlCQUF5QixtQkFBTyxDQUFDLHFHQUE2QjtBQUM5RCxtQkFBbUIsbUJBQU8sQ0FBQyx5RUFBZTtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osbUVBQW1FLHdCQUF3QjtBQUMzRjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osbUVBQW1FLHdCQUF3QjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL21hcC5qcz84YWI5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5jb25zdCBNb25nb29zZU1hcCA9IHJlcXVpcmUoJy4uL3R5cGVzL21hcCcpO1xuY29uc3QgU2NoZW1hTWFwT3B0aW9ucyA9IHJlcXVpcmUoJy4uL29wdGlvbnMvc2NoZW1hTWFwT3B0aW9ucycpO1xuY29uc3QgU2NoZW1hVHlwZSA9IHJlcXVpcmUoJy4uL3NjaGVtYVR5cGUnKTtcbi8qIVxuICogaWdub3JlXG4gKi9cblxuY2xhc3MgU2NoZW1hTWFwIGV4dGVuZHMgU2NoZW1hVHlwZSB7XG4gIGNvbnN0cnVjdG9yKGtleSwgb3B0aW9ucykge1xuICAgIHN1cGVyKGtleSwgb3B0aW9ucywgJ01hcCcpO1xuICAgIHRoaXMuJGlzU2NoZW1hTWFwID0gdHJ1ZTtcbiAgfVxuXG4gIHNldChvcHRpb24sIHZhbHVlKSB7XG4gICAgcmV0dXJuIFNjaGVtYVR5cGUuc2V0KG9wdGlvbiwgdmFsdWUpO1xuICB9XG5cbiAgY2FzdCh2YWwsIGRvYywgaW5pdCkge1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBNb25nb29zZU1hcCkge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBjb25zdCBwYXRoID0gdGhpcy5wYXRoO1xuXG4gICAgaWYgKGluaXQpIHtcbiAgICAgIGNvbnN0IG1hcCA9IG5ldyBNb25nb29zZU1hcCh7fSwgcGF0aCwgZG9jLCB0aGlzLiRfX3NjaGVtYVR5cGUpO1xuXG4gICAgICBpZiAodmFsIGluc3RhbmNlb2YgZ2xvYmFsLk1hcCkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB2YWwua2V5cygpKSB7XG4gICAgICAgICAgbGV0IF92YWwgPSB2YWwuZ2V0KGtleSk7XG4gICAgICAgICAgaWYgKF92YWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgX3ZhbCA9IG1hcC4kX19zY2hlbWFUeXBlLl9jYXN0TnVsbGlzaChfdmFsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3ZhbCA9IG1hcC4kX19zY2hlbWFUeXBlLmNhc3QoX3ZhbCwgZG9jLCB0cnVlLCBudWxsLCB7IHBhdGg6IHBhdGggKyAnLicgKyBrZXkgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hcC4kaW5pdChrZXksIF92YWwpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh2YWwpKSB7XG4gICAgICAgICAgbGV0IF92YWwgPSB2YWxba2V5XTtcbiAgICAgICAgICBpZiAoX3ZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICBfdmFsID0gbWFwLiRfX3NjaGVtYVR5cGUuX2Nhc3ROdWxsaXNoKF92YWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfdmFsID0gbWFwLiRfX3NjaGVtYVR5cGUuY2FzdChfdmFsLCBkb2MsIHRydWUsIG51bGwsIHsgcGF0aDogcGF0aCArICcuJyArIGtleSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWFwLiRpbml0KGtleSwgX3ZhbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE1vbmdvb3NlTWFwKHZhbCwgcGF0aCwgZG9jLCB0aGlzLiRfX3NjaGVtYVR5cGUpO1xuICB9XG5cbiAgY2xvbmUoKSB7XG4gICAgY29uc3Qgc2NoZW1hdHlwZSA9IHN1cGVyLmNsb25lKCk7XG5cbiAgICBpZiAodGhpcy4kX19zY2hlbWFUeXBlICE9IG51bGwpIHtcbiAgICAgIHNjaGVtYXR5cGUuJF9fc2NoZW1hVHlwZSA9IHRoaXMuJF9fc2NoZW1hVHlwZS5jbG9uZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc2NoZW1hdHlwZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgc2NoZW1hIHR5cGUncyBuYW1lLCB0byBkZWZlbmQgYWdhaW5zdCBtaW5pZmllcnMgdGhhdCBtYW5nbGVcbiAqIGZ1bmN0aW9uIG5hbWVzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblNjaGVtYU1hcC5zY2hlbWFOYW1lID0gJ01hcCc7XG5cblNjaGVtYU1hcC5wcm90b3R5cGUuT3B0aW9uc0NvbnN0cnVjdG9yID0gU2NoZW1hTWFwT3B0aW9ucztcblxuU2NoZW1hTWFwLmRlZmF1bHRPcHRpb25zID0ge307XG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hTWFwO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/schema/map.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/schema/mixed.js":
/*!************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/schema/mixed.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"../backend/node_modules/mongoose/lib/schemaType.js\");\nconst symbols = __webpack_require__(/*! ./symbols */ \"../backend/node_modules/mongoose/lib/schema/symbols.js\");\nconst isObject = __webpack_require__(/*! ../helpers/isObject */ \"../backend/node_modules/mongoose/lib/helpers/isObject.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\n\n/**\n * Mixed SchemaType constructor.\n *\n * @param {String} path\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaMixed(path, options) {\n  if (options && options.default) {\n    const def = options.default;\n    if (Array.isArray(def) && def.length === 0) {\n      // make sure empty array defaults are handled\n      options.default = Array;\n    } else if (!options.shared && isObject(def) && Object.keys(def).length === 0) {\n      // prevent odd \"shared\" objects between documents\n      options.default = function() {\n        return {};\n      };\n    }\n  }\n\n  SchemaType.call(this, path, options, 'Mixed');\n\n  this[symbols.schemaMixedSymbol] = true;\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaMixed.schemaName = 'Mixed';\n\nSchemaMixed.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaMixed.prototype = Object.create(SchemaType.prototype);\nSchemaMixed.prototype.constructor = SchemaMixed;\n\n/**\n * Attaches a getter for all Mixed paths.\n *\n * #### Example:\n *\n *     // Hide the 'hidden' path\n *     mongoose.Schema.Mixed.get(v => Object.assign({}, v, { hidden: null }));\n *\n *     const Model = mongoose.model('Test', new Schema({ test: {} }));\n *     new Model({ test: { hidden: 'Secret!' } }).test.hidden; // null\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaMixed.get = SchemaType.get;\n\n/**\n * Sets a default option for all Mixed instances.\n *\n * #### Example:\n *\n *     // Make all mixed instances have `required` of true by default.\n *     mongoose.Schema.Mixed.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: mongoose.Mixed }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaMixed.set = SchemaType.set;\n\nSchemaMixed.setters = [];\n\n/**\n * Casts `val` for Mixed.\n *\n * _this is a no-op_\n *\n * @param {Object} value to cast\n * @api private\n */\n\nSchemaMixed.prototype.cast = function(val) {\n  if (val instanceof Error) {\n    return utils.errorToPOJO(val);\n  }\n  return val;\n};\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $cond\n * @param {any} [val]\n * @api private\n */\n\nSchemaMixed.prototype.castForQuery = function($cond, val) {\n  return val;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaMixed;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9taXhlZC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsbUJBQW1CLG1CQUFPLENBQUMseUVBQWU7QUFDMUMsZ0JBQWdCLG1CQUFPLENBQUMseUVBQVc7QUFDbkMsaUJBQWlCLG1CQUFPLENBQUMscUZBQXFCO0FBQzlDLGNBQWMsbUJBQU8sQ0FBQywrREFBVTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELE9BQU8sY0FBYztBQUMzRTtBQUNBLHlEQUF5RCxVQUFVO0FBQ25FLG1CQUFtQixRQUFRLHFCQUFxQixlQUFlO0FBQy9EO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHNCQUFzQjtBQUM5RSxtQkFBbUIsc0NBQXNDO0FBQ3pEO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9zY2hlbWEvbWl4ZWQuanM/ZWMwOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBTY2hlbWFUeXBlID0gcmVxdWlyZSgnLi4vc2NoZW1hVHlwZScpO1xuY29uc3Qgc3ltYm9scyA9IHJlcXVpcmUoJy4vc3ltYm9scycpO1xuY29uc3QgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2lzT2JqZWN0Jyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qKlxuICogTWl4ZWQgU2NoZW1hVHlwZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBpbmhlcml0cyBTY2hlbWFUeXBlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNjaGVtYU1peGVkKHBhdGgsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5kZWZhdWx0KSB7XG4gICAgY29uc3QgZGVmID0gb3B0aW9ucy5kZWZhdWx0O1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRlZikgJiYgZGVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gbWFrZSBzdXJlIGVtcHR5IGFycmF5IGRlZmF1bHRzIGFyZSBoYW5kbGVkXG4gICAgICBvcHRpb25zLmRlZmF1bHQgPSBBcnJheTtcbiAgICB9IGVsc2UgaWYgKCFvcHRpb25zLnNoYXJlZCAmJiBpc09iamVjdChkZWYpICYmIE9iamVjdC5rZXlzKGRlZikubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBwcmV2ZW50IG9kZCBcInNoYXJlZFwiIG9iamVjdHMgYmV0d2VlbiBkb2N1bWVudHNcbiAgICAgIG9wdGlvbnMuZGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIFNjaGVtYVR5cGUuY2FsbCh0aGlzLCBwYXRoLCBvcHRpb25zLCAnTWl4ZWQnKTtcblxuICB0aGlzW3N5bWJvbHMuc2NoZW1hTWl4ZWRTeW1ib2xdID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBUaGlzIHNjaGVtYSB0eXBlJ3MgbmFtZSwgdG8gZGVmZW5kIGFnYWluc3QgbWluaWZpZXJzIHRoYXQgbWFuZ2xlXG4gKiBmdW5jdGlvbiBuYW1lcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5TY2hlbWFNaXhlZC5zY2hlbWFOYW1lID0gJ01peGVkJztcblxuU2NoZW1hTWl4ZWQuZGVmYXVsdE9wdGlvbnMgPSB7fTtcblxuLyohXG4gKiBJbmhlcml0cyBmcm9tIFNjaGVtYVR5cGUuXG4gKi9cblNjaGVtYU1peGVkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU2NoZW1hVHlwZS5wcm90b3R5cGUpO1xuU2NoZW1hTWl4ZWQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2NoZW1hTWl4ZWQ7XG5cbi8qKlxuICogQXR0YWNoZXMgYSBnZXR0ZXIgZm9yIGFsbCBNaXhlZCBwYXRocy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIEhpZGUgdGhlICdoaWRkZW4nIHBhdGhcbiAqICAgICBtb25nb29zZS5TY2hlbWEuTWl4ZWQuZ2V0KHYgPT4gT2JqZWN0LmFzc2lnbih7fSwgdiwgeyBoaWRkZW46IG51bGwgfSkpO1xuICpcbiAqICAgICBjb25zdCBNb2RlbCA9IG1vbmdvb3NlLm1vZGVsKCdUZXN0JywgbmV3IFNjaGVtYSh7IHRlc3Q6IHt9IH0pKTtcbiAqICAgICBuZXcgTW9kZWwoeyB0ZXN0OiB7IGhpZGRlbjogJ1NlY3JldCEnIH0gfSkudGVzdC5oaWRkZW47IC8vIG51bGxcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAqIEByZXR1cm4ge3RoaXN9XG4gKiBAZnVuY3Rpb24gZ2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYU1peGVkLmdldCA9IFNjaGVtYVR5cGUuZ2V0O1xuXG4vKipcbiAqIFNldHMgYSBkZWZhdWx0IG9wdGlvbiBmb3IgYWxsIE1peGVkIGluc3RhbmNlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1ha2UgYWxsIG1peGVkIGluc3RhbmNlcyBoYXZlIGByZXF1aXJlZGAgb2YgdHJ1ZSBieSBkZWZhdWx0LlxuICogICAgIG1vbmdvb3NlLlNjaGVtYS5NaXhlZC5zZXQoJ3JlcXVpcmVkJywgdHJ1ZSk7XG4gKlxuICogICAgIGNvbnN0IFVzZXIgPSBtb25nb29zZS5tb2RlbCgnVXNlcicsIG5ldyBTY2hlbWEoeyB0ZXN0OiBtb25nb29zZS5NaXhlZCB9KSk7XG4gKiAgICAgbmV3IFVzZXIoeyB9KS52YWxpZGF0ZVN5bmMoKS5lcnJvcnMudGVzdC5tZXNzYWdlOyAvLyBQYXRoIGB0ZXN0YCBpcyByZXF1aXJlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9uIFRoZSBvcHRpb24geW91J2QgbGlrZSB0byBzZXQgdGhlIHZhbHVlIGZvclxuICogQHBhcmFtIHtBbnl9IHZhbHVlIHZhbHVlIGZvciBvcHRpb25cbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAqIEBmdW5jdGlvbiBzZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hTWl4ZWQuc2V0ID0gU2NoZW1hVHlwZS5zZXQ7XG5cblNjaGVtYU1peGVkLnNldHRlcnMgPSBbXTtcblxuLyoqXG4gKiBDYXN0cyBgdmFsYCBmb3IgTWl4ZWQuXG4gKlxuICogX3RoaXMgaXMgYSBuby1vcF9cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgdG8gY2FzdFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hTWl4ZWQucHJvdG90eXBlLmNhc3QgPSBmdW5jdGlvbih2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgcmV0dXJuIHV0aWxzLmVycm9yVG9QT0pPKHZhbCk7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG5cbi8qKlxuICogQ2FzdHMgY29udGVudHMgZm9yIHF1ZXJpZXMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9ICRjb25kXG4gKiBAcGFyYW0ge2FueX0gW3ZhbF1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYU1peGVkLnByb3RvdHlwZS5jYXN0Rm9yUXVlcnkgPSBmdW5jdGlvbigkY29uZCwgdmFsKSB7XG4gIHJldHVybiB2YWw7XG59O1xuXG4vKiFcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hTWl4ZWQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/schema/mixed.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/schema/number.js":
/*!*************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/schema/number.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module requirements.\n */\n\nconst MongooseError = __webpack_require__(/*! ../error/index */ \"../backend/node_modules/mongoose/lib/error/index.js\");\nconst SchemaNumberOptions = __webpack_require__(/*! ../options/schemaNumberOptions */ \"../backend/node_modules/mongoose/lib/options/schemaNumberOptions.js\");\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"../backend/node_modules/mongoose/lib/schemaType.js\");\nconst castNumber = __webpack_require__(/*! ../cast/number */ \"../backend/node_modules/mongoose/lib/cast/number.js\");\nconst handleBitwiseOperator = __webpack_require__(/*! ./operators/bitwise */ \"../backend/node_modules/mongoose/lib/schema/operators/bitwise.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\n\nconst CastError = SchemaType.CastError;\n\n/**\n * Number SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaNumber(key, options) {\n  SchemaType.call(this, key, options, 'Number');\n}\n\n/**\n * Attaches a getter for all Number instances.\n *\n * #### Example:\n *\n *     // Make all numbers round down\n *     mongoose.Number.get(function(v) { return Math.floor(v); });\n *\n *     const Model = mongoose.model('Test', new Schema({ test: Number }));\n *     new Model({ test: 3.14 }).test; // 3\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaNumber.get = SchemaType.get;\n\n/**\n * Sets a default option for all Number instances.\n *\n * #### Example:\n *\n *     // Make all numbers have option `min` equal to 0.\n *     mongoose.Schema.Number.set('min', 0);\n *\n *     const Order = mongoose.model('Order', new Schema({ amount: Number }));\n *     new Order({ amount: -10 }).validateSync().errors.amount.message; // Path `amount` must be larger than 0.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaNumber.set = SchemaType.set;\n\nSchemaNumber.setters = [];\n\n/*!\n * ignore\n */\n\nSchemaNumber._cast = castNumber;\n\n/**\n * Get/set the function used to cast arbitrary values to numbers.\n *\n * #### Example:\n *\n *     // Make Mongoose cast empty strings '' to 0 for paths declared as numbers\n *     const original = mongoose.Number.cast();\n *     mongoose.Number.cast(v => {\n *       if (v === '') { return 0; }\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.Number.cast(false);\n *\n * @param {Function} caster\n * @return {Function}\n * @function get\n * @static\n * @api public\n */\n\nSchemaNumber.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaNumber._defaultCaster = v => {\n  if (typeof v !== 'number') {\n    throw new Error();\n  }\n  return v;\n};\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaNumber.schemaName = 'Number';\n\nSchemaNumber.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaNumber.prototype = Object.create(SchemaType.prototype);\nSchemaNumber.prototype.constructor = SchemaNumber;\nSchemaNumber.prototype.OptionsConstructor = SchemaNumberOptions;\n\n/*!\n * ignore\n */\n\nSchemaNumber._checkRequired = v => typeof v === 'number' || v instanceof Number;\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaNumber.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaNumber.prototype.checkRequired = function checkRequired(value, doc) {\n  if (typeof value === 'object' && SchemaType._isRef(this, value, doc, true)) {\n    return value != null;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ?\n    this.constructor.checkRequired() :\n    SchemaNumber.checkRequired();\n\n  return _checkRequired(value);\n};\n\n/**\n * Sets a minimum number validator.\n *\n * #### Example:\n *\n *     const s = new Schema({ n: { type: Number, min: 10 })\n *     const M = db.model('M', s)\n *     const m = new M({ n: 9 })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.n = 10;\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MIN} token which will be replaced with the invalid value\n *     const min = [10, 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];\n *     const schema = new Schema({ n: { type: Number, min: min })\n *     const M = mongoose.model('Measurement', schema);\n *     const s= new M({ n: 4 });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `n` (4) is beneath the limit (10).\n *     })\n *\n * @param {Number} value minimum number\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaNumber.prototype.min = function(value, message) {\n  if (this.minValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.minValidator;\n    }, this);\n  }\n\n  if (value !== null && value !== undefined) {\n    let msg = message || MongooseError.messages.Number.min;\n    msg = msg.replace(/{MIN}/, value);\n    this.validators.push({\n      validator: this.minValidator = function(v) {\n        return v == null || v >= value;\n      },\n      message: msg,\n      type: 'min',\n      min: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Sets a maximum number validator.\n *\n * #### Example:\n *\n *     const s = new Schema({ n: { type: Number, max: 10 })\n *     const M = db.model('M', s)\n *     const m = new M({ n: 11 })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.n = 10;\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MAX} token which will be replaced with the invalid value\n *     const max = [10, 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];\n *     const schema = new Schema({ n: { type: Number, max: max })\n *     const M = mongoose.model('Measurement', schema);\n *     const s= new M({ n: 4 });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `n` (4) exceeds the limit (10).\n *     })\n *\n * @param {Number} maximum number\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaNumber.prototype.max = function(value, message) {\n  if (this.maxValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.maxValidator;\n    }, this);\n  }\n\n  if (value !== null && value !== undefined) {\n    let msg = message || MongooseError.messages.Number.max;\n    msg = msg.replace(/{MAX}/, value);\n    this.validators.push({\n      validator: this.maxValidator = function(v) {\n        return v == null || v <= value;\n      },\n      message: msg,\n      type: 'max',\n      max: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Sets a enum validator\n *\n * #### Example:\n *\n *     const s = new Schema({ n: { type: Number, enum: [1, 2, 3] });\n *     const M = db.model('M', s);\n *\n *     const m = new M({ n: 4 });\n *     await m.save(); // throws validation error\n *\n *     m.n = 3;\n *     await m.save(); // succeeds\n *\n * @param {Array} values allowed values\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaNumber.prototype.enum = function(values, message) {\n  if (this.enumValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.enumValidator;\n    }, this);\n  }\n\n\n  if (!Array.isArray(values)) {\n    const isObjectSyntax = utils.isPOJO(values) && values.values != null;\n    if (isObjectSyntax) {\n      message = values.message;\n      values = values.values;\n    } else if (typeof values === 'number') {\n      values = Array.prototype.slice.call(arguments);\n      message = null;\n    }\n\n    if (utils.isPOJO(values)) {\n      values = Object.values(values);\n    }\n    message = message || MongooseError.messages.Number.enum;\n  }\n\n  message = message == null ? MongooseError.messages.Number.enum : message;\n\n  this.enumValidator = v => v == null || values.indexOf(v) !== -1;\n  this.validators.push({\n    validator: this.enumValidator,\n    message: message,\n    type: 'enum',\n    enumValues: values\n  });\n\n  return this;\n};\n\n/**\n * Casts to number\n *\n * @param {Object} value value to cast\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init\n * @api private\n */\n\nSchemaNumber.prototype.cast = function(value, doc, init) {\n  if (typeof value !== 'number' && SchemaType._isRef(this, value, doc, init)) {\n    if (value == null || utils.isNonBuiltinObject(value)) {\n      return this._castRef(value, doc, init);\n    }\n  }\n\n  const val = value && typeof value._id !== 'undefined' ?\n    value._id : // documents\n    value;\n\n  let castNumber;\n  if (typeof this._castFunction === 'function') {\n    castNumber = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castNumber = this.constructor.cast();\n  } else {\n    castNumber = SchemaNumber.cast();\n  }\n\n  try {\n    return castNumber(val);\n  } catch (err) {\n    throw new CastError('Number', val, this.path, err, this);\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\nfunction handleArray(val) {\n  const _this = this;\n  if (!Array.isArray(val)) {\n    return [this.cast(val)];\n  }\n  return val.map(function(m) {\n    return _this.cast(m);\n  });\n}\n\nSchemaNumber.prototype.$conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers,\n  $bitsAllClear: handleBitwiseOperator,\n  $bitsAnyClear: handleBitwiseOperator,\n  $bitsAllSet: handleBitwiseOperator,\n  $bitsAnySet: handleBitwiseOperator,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $lt: handleSingle,\n  $lte: handleSingle,\n  $mod: handleArray\n};\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaNumber.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new CastError('number', val, this.path, null, this);\n    }\n    return handler.call(this, val, context);\n  }\n\n  try {\n    val = this.applySetters(val, context);\n  } catch (err) {\n    if (err instanceof CastError && err.path === this.path && this.$fullPath != null) {\n      err.path = this.$fullPath;\n    }\n    throw err;\n  }\n\n  return val;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaNumber;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9udW1iZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixtQkFBTyxDQUFDLDJFQUFnQjtBQUM5Qyw0QkFBNEIsbUJBQU8sQ0FBQywyR0FBZ0M7QUFDcEUsbUJBQW1CLG1CQUFPLENBQUMseUVBQWU7QUFDMUMsbUJBQW1CLG1CQUFPLENBQUMsMkVBQWdCO0FBQzNDLDhCQUE4QixtQkFBTyxDQUFDLDZGQUFxQjtBQUMzRCxjQUFjLG1CQUFPLENBQUMsK0RBQVU7O0FBRWhDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsdUJBQXVCO0FBQ2hFO0FBQ0EseURBQXlELGNBQWM7QUFDdkUsbUJBQW1CLFlBQVksUUFBUTtBQUN2QztBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxnQkFBZ0I7QUFDMUUsbUJBQW1CLGFBQWEsd0NBQXdDO0FBQ3hFO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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Q0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9zY2hlbWEvbnVtYmVyLmpzPzc1MjkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxuY29uc3QgTW9uZ29vc2VFcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL2luZGV4Jyk7XG5jb25zdCBTY2hlbWFOdW1iZXJPcHRpb25zID0gcmVxdWlyZSgnLi4vb3B0aW9ucy9zY2hlbWFOdW1iZXJPcHRpb25zJyk7XG5jb25zdCBTY2hlbWFUeXBlID0gcmVxdWlyZSgnLi4vc2NoZW1hVHlwZScpO1xuY29uc3QgY2FzdE51bWJlciA9IHJlcXVpcmUoJy4uL2Nhc3QvbnVtYmVyJyk7XG5jb25zdCBoYW5kbGVCaXR3aXNlT3BlcmF0b3IgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9iaXR3aXNlJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmNvbnN0IENhc3RFcnJvciA9IFNjaGVtYVR5cGUuQ2FzdEVycm9yO1xuXG4vKipcbiAqIE51bWJlciBTY2hlbWFUeXBlIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAaW5oZXJpdHMgU2NoZW1hVHlwZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTY2hlbWFOdW1iZXIoa2V5LCBvcHRpb25zKSB7XG4gIFNjaGVtYVR5cGUuY2FsbCh0aGlzLCBrZXksIG9wdGlvbnMsICdOdW1iZXInKTtcbn1cblxuLyoqXG4gKiBBdHRhY2hlcyBhIGdldHRlciBmb3IgYWxsIE51bWJlciBpbnN0YW5jZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYWtlIGFsbCBudW1iZXJzIHJvdW5kIGRvd25cbiAqICAgICBtb25nb29zZS5OdW1iZXIuZ2V0KGZ1bmN0aW9uKHYpIHsgcmV0dXJuIE1hdGguZmxvb3Iodik7IH0pO1xuICpcbiAqICAgICBjb25zdCBNb2RlbCA9IG1vbmdvb3NlLm1vZGVsKCdUZXN0JywgbmV3IFNjaGVtYSh7IHRlc3Q6IE51bWJlciB9KSk7XG4gKiAgICAgbmV3IE1vZGVsKHsgdGVzdDogMy4xNCB9KS50ZXN0OyAvLyAzXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyXG4gKiBAcmV0dXJuIHt0aGlzfVxuICogQGZ1bmN0aW9uIGdldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFOdW1iZXIuZ2V0ID0gU2NoZW1hVHlwZS5nZXQ7XG5cbi8qKlxuICogU2V0cyBhIGRlZmF1bHQgb3B0aW9uIGZvciBhbGwgTnVtYmVyIGluc3RhbmNlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1ha2UgYWxsIG51bWJlcnMgaGF2ZSBvcHRpb24gYG1pbmAgZXF1YWwgdG8gMC5cbiAqICAgICBtb25nb29zZS5TY2hlbWEuTnVtYmVyLnNldCgnbWluJywgMCk7XG4gKlxuICogICAgIGNvbnN0IE9yZGVyID0gbW9uZ29vc2UubW9kZWwoJ09yZGVyJywgbmV3IFNjaGVtYSh7IGFtb3VudDogTnVtYmVyIH0pKTtcbiAqICAgICBuZXcgT3JkZXIoeyBhbW91bnQ6IC0xMCB9KS52YWxpZGF0ZVN5bmMoKS5lcnJvcnMuYW1vdW50Lm1lc3NhZ2U7IC8vIFBhdGggYGFtb3VudGAgbXVzdCBiZSBsYXJnZXIgdGhhbiAwLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb24gVGhlIG9wdGlvbiB5b3UnZCBsaWtlIHRvIHNldCB0aGUgdmFsdWUgZm9yXG4gKiBAcGFyYW0ge0FueX0gdmFsdWUgdmFsdWUgZm9yIG9wdGlvblxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICogQGZ1bmN0aW9uIHNldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFOdW1iZXIuc2V0ID0gU2NoZW1hVHlwZS5zZXQ7XG5cblNjaGVtYU51bWJlci5zZXR0ZXJzID0gW107XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hTnVtYmVyLl9jYXN0ID0gY2FzdE51bWJlcjtcblxuLyoqXG4gKiBHZXQvc2V0IHRoZSBmdW5jdGlvbiB1c2VkIHRvIGNhc3QgYXJiaXRyYXJ5IHZhbHVlcyB0byBudW1iZXJzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTWFrZSBNb25nb29zZSBjYXN0IGVtcHR5IHN0cmluZ3MgJycgdG8gMCBmb3IgcGF0aHMgZGVjbGFyZWQgYXMgbnVtYmVyc1xuICogICAgIGNvbnN0IG9yaWdpbmFsID0gbW9uZ29vc2UuTnVtYmVyLmNhc3QoKTtcbiAqICAgICBtb25nb29zZS5OdW1iZXIuY2FzdCh2ID0+IHtcbiAqICAgICAgIGlmICh2ID09PSAnJykgeyByZXR1cm4gMDsgfVxuICogICAgICAgcmV0dXJuIG9yaWdpbmFsKHYpO1xuICogICAgIH0pO1xuICpcbiAqICAgICAvLyBPciBkaXNhYmxlIGNhc3RpbmcgZW50aXJlbHlcbiAqICAgICBtb25nb29zZS5OdW1iZXIuY2FzdChmYWxzZSk7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FzdGVyXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBmdW5jdGlvbiBnZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hTnVtYmVyLmNhc3QgPSBmdW5jdGlvbiBjYXN0KGNhc3Rlcikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzLl9jYXN0O1xuICB9XG4gIGlmIChjYXN0ZXIgPT09IGZhbHNlKSB7XG4gICAgY2FzdGVyID0gdGhpcy5fZGVmYXVsdENhc3RlcjtcbiAgfVxuICB0aGlzLl9jYXN0ID0gY2FzdGVyO1xuXG4gIHJldHVybiB0aGlzLl9jYXN0O1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFOdW1iZXIuX2RlZmF1bHRDYXN0ZXIgPSB2ID0+IHtcbiAgaWYgKHR5cGVvZiB2ICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBFcnJvcigpO1xuICB9XG4gIHJldHVybiB2O1xufTtcblxuLyoqXG4gKiBUaGlzIHNjaGVtYSB0eXBlJ3MgbmFtZSwgdG8gZGVmZW5kIGFnYWluc3QgbWluaWZpZXJzIHRoYXQgbWFuZ2xlXG4gKiBmdW5jdGlvbiBuYW1lcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5TY2hlbWFOdW1iZXIuc2NoZW1hTmFtZSA9ICdOdW1iZXInO1xuXG5TY2hlbWFOdW1iZXIuZGVmYXVsdE9wdGlvbnMgPSB7fTtcblxuLyohXG4gKiBJbmhlcml0cyBmcm9tIFNjaGVtYVR5cGUuXG4gKi9cblNjaGVtYU51bWJlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNjaGVtYVR5cGUucHJvdG90eXBlKTtcblNjaGVtYU51bWJlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTY2hlbWFOdW1iZXI7XG5TY2hlbWFOdW1iZXIucHJvdG90eXBlLk9wdGlvbnNDb25zdHJ1Y3RvciA9IFNjaGVtYU51bWJlck9wdGlvbnM7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hTnVtYmVyLl9jaGVja1JlcXVpcmVkID0gdiA9PiB0eXBlb2YgdiA9PT0gJ251bWJlcicgfHwgdiBpbnN0YW5jZW9mIE51bWJlcjtcblxuLyoqXG4gKiBPdmVycmlkZSB0aGUgZnVuY3Rpb24gdGhlIHJlcXVpcmVkIHZhbGlkYXRvciB1c2VzIHRvIGNoZWNrIHdoZXRoZXIgYSBzdHJpbmdcbiAqIHBhc3NlcyB0aGUgYHJlcXVpcmVkYCBjaGVjay5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAZnVuY3Rpb24gY2hlY2tSZXF1aXJlZFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFOdW1iZXIuY2hlY2tSZXF1aXJlZCA9IFNjaGVtYVR5cGUuY2hlY2tSZXF1aXJlZDtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgc2F0aXNmaWVzIGEgcmVxdWlyZWQgdmFsaWRhdG9yLlxuICpcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZVxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFOdW1iZXIucHJvdG90eXBlLmNoZWNrUmVxdWlyZWQgPSBmdW5jdGlvbiBjaGVja1JlcXVpcmVkKHZhbHVlLCBkb2MpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgU2NoZW1hVHlwZS5faXNSZWYodGhpcywgdmFsdWUsIGRvYywgdHJ1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUgIT0gbnVsbDtcbiAgfVxuXG4gIC8vIGByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHMoKWAgZG9lcyAqKm5vdCoqIGNvcHkgc3RhdGljIHByb3BlcnRpZXMsIGFuZFxuICAvLyBwbHVnaW5zIGxpa2UgbW9uZ29vc2UtZmxvYXQgdXNlIGBpbmhlcml0cygpYCBmb3IgcHJlLUVTNi5cbiAgY29uc3QgX2NoZWNrUmVxdWlyZWQgPSB0eXBlb2YgdGhpcy5jb25zdHJ1Y3Rvci5jaGVja1JlcXVpcmVkID09PSAnZnVuY3Rpb24nID9cbiAgICB0aGlzLmNvbnN0cnVjdG9yLmNoZWNrUmVxdWlyZWQoKSA6XG4gICAgU2NoZW1hTnVtYmVyLmNoZWNrUmVxdWlyZWQoKTtcblxuICByZXR1cm4gX2NoZWNrUmVxdWlyZWQodmFsdWUpO1xufTtcblxuLyoqXG4gKiBTZXRzIGEgbWluaW11bSBudW1iZXIgdmFsaWRhdG9yLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoeyBuOiB7IHR5cGU6IE51bWJlciwgbWluOiAxMCB9KVxuICogICAgIGNvbnN0IE0gPSBkYi5tb2RlbCgnTScsIHMpXG4gKiAgICAgY29uc3QgbSA9IG5ldyBNKHsgbjogOSB9KVxuICogICAgIG0uc2F2ZShmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgICBjb25zb2xlLmVycm9yKGVycikgLy8gdmFsaWRhdG9yIGVycm9yXG4gKiAgICAgICBtLm4gPSAxMDtcbiAqICAgICAgIG0uc2F2ZSgpIC8vIHN1Y2Nlc3NcbiAqICAgICB9KVxuICpcbiAqICAgICAvLyBjdXN0b20gZXJyb3IgbWVzc2FnZXNcbiAqICAgICAvLyBXZSBjYW4gYWxzbyB1c2UgdGhlIHNwZWNpYWwge01JTn0gdG9rZW4gd2hpY2ggd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoZSBpbnZhbGlkIHZhbHVlXG4gKiAgICAgY29uc3QgbWluID0gWzEwLCAnVGhlIHZhbHVlIG9mIHBhdGggYHtQQVRIfWAgKHtWQUxVRX0pIGlzIGJlbmVhdGggdGhlIGxpbWl0ICh7TUlOfSkuJ107XG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IG46IHsgdHlwZTogTnVtYmVyLCBtaW46IG1pbiB9KVxuICogICAgIGNvbnN0IE0gPSBtb25nb29zZS5tb2RlbCgnTWVhc3VyZW1lbnQnLCBzY2hlbWEpO1xuICogICAgIGNvbnN0IHM9IG5ldyBNKHsgbjogNCB9KTtcbiAqICAgICBzLnZhbGlkYXRlKGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKFN0cmluZyhlcnIpKSAvLyBWYWxpZGF0aW9uRXJyb3I6IFRoZSB2YWx1ZSBvZiBwYXRoIGBuYCAoNCkgaXMgYmVuZWF0aCB0aGUgbGltaXQgKDEwKS5cbiAqICAgICB9KVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBtaW5pbXVtIG51bWJlclxuICogQHBhcmFtIHtTdHJpbmd9IFttZXNzYWdlXSBvcHRpb25hbCBjdXN0b20gZXJyb3IgbWVzc2FnZVxuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICogQHNlZSBDdXN0b21pemVkIEVycm9yIE1lc3NhZ2VzIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZXJyb3IuaHRtbCNFcnJvci5tZXNzYWdlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFOdW1iZXIucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICh0aGlzLm1pblZhbGlkYXRvcikge1xuICAgIHRoaXMudmFsaWRhdG9ycyA9IHRoaXMudmFsaWRhdG9ycy5maWx0ZXIoZnVuY3Rpb24odikge1xuICAgICAgcmV0dXJuIHYudmFsaWRhdG9yICE9PSB0aGlzLm1pblZhbGlkYXRvcjtcbiAgICB9LCB0aGlzKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbGV0IG1zZyA9IG1lc3NhZ2UgfHwgTW9uZ29vc2VFcnJvci5tZXNzYWdlcy5OdW1iZXIubWluO1xuICAgIG1zZyA9IG1zZy5yZXBsYWNlKC97TUlOfS8sIHZhbHVlKTtcbiAgICB0aGlzLnZhbGlkYXRvcnMucHVzaCh7XG4gICAgICB2YWxpZGF0b3I6IHRoaXMubWluVmFsaWRhdG9yID0gZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gdiA9PSBudWxsIHx8IHYgPj0gdmFsdWU7XG4gICAgICB9LFxuICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgdHlwZTogJ21pbicsXG4gICAgICBtaW46IHZhbHVlXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyBhIG1heGltdW0gbnVtYmVyIHZhbGlkYXRvci5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgbjogeyB0eXBlOiBOdW1iZXIsIG1heDogMTAgfSlcbiAqICAgICBjb25zdCBNID0gZGIubW9kZWwoJ00nLCBzKVxuICogICAgIGNvbnN0IG0gPSBuZXcgTSh7IG46IDExIH0pXG4gKiAgICAgbS5zYXZlKGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKSAvLyB2YWxpZGF0b3IgZXJyb3JcbiAqICAgICAgIG0ubiA9IDEwO1xuICogICAgICAgbS5zYXZlKCkgLy8gc3VjY2Vzc1xuICogICAgIH0pXG4gKlxuICogICAgIC8vIGN1c3RvbSBlcnJvciBtZXNzYWdlc1xuICogICAgIC8vIFdlIGNhbiBhbHNvIHVzZSB0aGUgc3BlY2lhbCB7TUFYfSB0b2tlbiB3aGljaCB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhlIGludmFsaWQgdmFsdWVcbiAqICAgICBjb25zdCBtYXggPSBbMTAsICdUaGUgdmFsdWUgb2YgcGF0aCBge1BBVEh9YCAoe1ZBTFVFfSkgZXhjZWVkcyB0aGUgbGltaXQgKHtNQVh9KS4nXTtcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgbjogeyB0eXBlOiBOdW1iZXIsIG1heDogbWF4IH0pXG4gKiAgICAgY29uc3QgTSA9IG1vbmdvb3NlLm1vZGVsKCdNZWFzdXJlbWVudCcsIHNjaGVtYSk7XG4gKiAgICAgY29uc3Qgcz0gbmV3IE0oeyBuOiA0IH0pO1xuICogICAgIHMudmFsaWRhdGUoZnVuY3Rpb24gKGVycikge1xuICogICAgICAgY29uc29sZS5sb2coU3RyaW5nKGVycikpIC8vIFZhbGlkYXRpb25FcnJvcjogVGhlIHZhbHVlIG9mIHBhdGggYG5gICg0KSBleGNlZWRzIHRoZSBsaW1pdCAoMTApLlxuICogICAgIH0pXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heGltdW0gbnVtYmVyXG4gKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdIG9wdGlvbmFsIGN1c3RvbSBlcnJvciBtZXNzYWdlXG4gKiBAcmV0dXJuIHtTY2hlbWFUeXBlfSB0aGlzXG4gKiBAc2VlIEN1c3RvbWl6ZWQgRXJyb3IgTWVzc2FnZXMgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9lcnJvci5odG1sI0Vycm9yLm1lc3NhZ2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYU51bWJlci5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24odmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKHRoaXMubWF4VmFsaWRhdG9yKSB7XG4gICAgdGhpcy52YWxpZGF0b3JzID0gdGhpcy52YWxpZGF0b3JzLmZpbHRlcihmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gdi52YWxpZGF0b3IgIT09IHRoaXMubWF4VmFsaWRhdG9yO1xuICAgIH0sIHRoaXMpO1xuICB9XG5cbiAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBsZXQgbXNnID0gbWVzc2FnZSB8fCBNb25nb29zZUVycm9yLm1lc3NhZ2VzLk51bWJlci5tYXg7XG4gICAgbXNnID0gbXNnLnJlcGxhY2UoL3tNQVh9LywgdmFsdWUpO1xuICAgIHRoaXMudmFsaWRhdG9ycy5wdXNoKHtcbiAgICAgIHZhbGlkYXRvcjogdGhpcy5tYXhWYWxpZGF0b3IgPSBmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiB2ID09IG51bGwgfHwgdiA8PSB2YWx1ZTtcbiAgICAgIH0sXG4gICAgICBtZXNzYWdlOiBtc2csXG4gICAgICB0eXBlOiAnbWF4JyxcbiAgICAgIG1heDogdmFsdWVcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIGEgZW51bSB2YWxpZGF0b3JcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgbjogeyB0eXBlOiBOdW1iZXIsIGVudW06IFsxLCAyLCAzXSB9KTtcbiAqICAgICBjb25zdCBNID0gZGIubW9kZWwoJ00nLCBzKTtcbiAqXG4gKiAgICAgY29uc3QgbSA9IG5ldyBNKHsgbjogNCB9KTtcbiAqICAgICBhd2FpdCBtLnNhdmUoKTsgLy8gdGhyb3dzIHZhbGlkYXRpb24gZXJyb3JcbiAqXG4gKiAgICAgbS5uID0gMztcbiAqICAgICBhd2FpdCBtLnNhdmUoKTsgLy8gc3VjY2VlZHNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgYWxsb3dlZCB2YWx1ZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWVzc2FnZV0gb3B0aW9uYWwgY3VzdG9tIGVycm9yIG1lc3NhZ2VcbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IHRoaXNcbiAqIEBzZWUgQ3VzdG9taXplZCBFcnJvciBNZXNzYWdlcyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2Vycm9yLmh0bWwjRXJyb3IubWVzc2FnZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hTnVtYmVyLnByb3RvdHlwZS5lbnVtID0gZnVuY3Rpb24odmFsdWVzLCBtZXNzYWdlKSB7XG4gIGlmICh0aGlzLmVudW1WYWxpZGF0b3IpIHtcbiAgICB0aGlzLnZhbGlkYXRvcnMgPSB0aGlzLnZhbGlkYXRvcnMuZmlsdGVyKGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiB2LnZhbGlkYXRvciAhPT0gdGhpcy5lbnVtVmFsaWRhdG9yO1xuICAgIH0sIHRoaXMpO1xuICB9XG5cblxuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgIGNvbnN0IGlzT2JqZWN0U3ludGF4ID0gdXRpbHMuaXNQT0pPKHZhbHVlcykgJiYgdmFsdWVzLnZhbHVlcyAhPSBudWxsO1xuICAgIGlmIChpc09iamVjdFN5bnRheCkge1xuICAgICAgbWVzc2FnZSA9IHZhbHVlcy5tZXNzYWdlO1xuICAgICAgdmFsdWVzID0gdmFsdWVzLnZhbHVlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZXMgPT09ICdudW1iZXInKSB7XG4gICAgICB2YWx1ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgbWVzc2FnZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzLmlzUE9KTyh2YWx1ZXMpKSB7XG4gICAgICB2YWx1ZXMgPSBPYmplY3QudmFsdWVzKHZhbHVlcyk7XG4gICAgfVxuICAgIG1lc3NhZ2UgPSBtZXNzYWdlIHx8IE1vbmdvb3NlRXJyb3IubWVzc2FnZXMuTnVtYmVyLmVudW07XG4gIH1cblxuICBtZXNzYWdlID0gbWVzc2FnZSA9PSBudWxsID8gTW9uZ29vc2VFcnJvci5tZXNzYWdlcy5OdW1iZXIuZW51bSA6IG1lc3NhZ2U7XG5cbiAgdGhpcy5lbnVtVmFsaWRhdG9yID0gdiA9PiB2ID09IG51bGwgfHwgdmFsdWVzLmluZGV4T2YodikgIT09IC0xO1xuICB0aGlzLnZhbGlkYXRvcnMucHVzaCh7XG4gICAgdmFsaWRhdG9yOiB0aGlzLmVudW1WYWxpZGF0b3IsXG4gICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICB0eXBlOiAnZW51bScsXG4gICAgZW51bVZhbHVlczogdmFsdWVzXG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYXN0cyB0byBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgdmFsdWUgdG8gY2FzdFxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jIGRvY3VtZW50IHRoYXQgdHJpZ2dlcnMgdGhlIGNhc3RpbmdcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5pdFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hTnVtYmVyLnByb3RvdHlwZS5jYXN0ID0gZnVuY3Rpb24odmFsdWUsIGRvYywgaW5pdCkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyAmJiBTY2hlbWFUeXBlLl9pc1JlZih0aGlzLCB2YWx1ZSwgZG9jLCBpbml0KSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHV0aWxzLmlzTm9uQnVpbHRpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYXN0UmVmKHZhbHVlLCBkb2MsIGluaXQpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHZhbCA9IHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5faWQgIT09ICd1bmRlZmluZWQnID9cbiAgICB2YWx1ZS5faWQgOiAvLyBkb2N1bWVudHNcbiAgICB2YWx1ZTtcblxuICBsZXQgY2FzdE51bWJlcjtcbiAgaWYgKHR5cGVvZiB0aGlzLl9jYXN0RnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYXN0TnVtYmVyID0gdGhpcy5fY2FzdEZ1bmN0aW9uO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLmNvbnN0cnVjdG9yLmNhc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYXN0TnVtYmVyID0gdGhpcy5jb25zdHJ1Y3Rvci5jYXN0KCk7XG4gIH0gZWxzZSB7XG4gICAgY2FzdE51bWJlciA9IFNjaGVtYU51bWJlci5jYXN0KCk7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBjYXN0TnVtYmVyKHZhbCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJ051bWJlcicsIHZhbCwgdGhpcy5wYXRoLCBlcnIsIHRoaXMpO1xuICB9XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGhhbmRsZVNpbmdsZSh2YWwpIHtcbiAgcmV0dXJuIHRoaXMuY2FzdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVBcnJheSh2YWwpIHtcbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHJldHVybiBbdGhpcy5jYXN0KHZhbCldO1xuICB9XG4gIHJldHVybiB2YWwubWFwKGZ1bmN0aW9uKG0pIHtcbiAgICByZXR1cm4gX3RoaXMuY2FzdChtKTtcbiAgfSk7XG59XG5cblNjaGVtYU51bWJlci5wcm90b3R5cGUuJGNvbmRpdGlvbmFsSGFuZGxlcnMgPSB7XG4gIC4uLlNjaGVtYVR5cGUucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzLFxuICAkYml0c0FsbENsZWFyOiBoYW5kbGVCaXR3aXNlT3BlcmF0b3IsXG4gICRiaXRzQW55Q2xlYXI6IGhhbmRsZUJpdHdpc2VPcGVyYXRvcixcbiAgJGJpdHNBbGxTZXQ6IGhhbmRsZUJpdHdpc2VPcGVyYXRvcixcbiAgJGJpdHNBbnlTZXQ6IGhhbmRsZUJpdHdpc2VPcGVyYXRvcixcbiAgJGd0OiBoYW5kbGVTaW5nbGUsXG4gICRndGU6IGhhbmRsZVNpbmdsZSxcbiAgJGx0OiBoYW5kbGVTaW5nbGUsXG4gICRsdGU6IGhhbmRsZVNpbmdsZSxcbiAgJG1vZDogaGFuZGxlQXJyYXlcbn07XG5cbi8qKlxuICogQ2FzdHMgY29udGVudHMgZm9yIHF1ZXJpZXMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9ICRjb25kaXRpb25hbFxuICogQHBhcmFtIHthbnl9IFt2YWx1ZV1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYU51bWJlci5wcm90b3R5cGUuY2FzdEZvclF1ZXJ5ID0gZnVuY3Rpb24oJGNvbmRpdGlvbmFsLCB2YWwsIGNvbnRleHQpIHtcbiAgbGV0IGhhbmRsZXI7XG4gIGlmICgkY29uZGl0aW9uYWwgIT0gbnVsbCkge1xuICAgIGhhbmRsZXIgPSB0aGlzLiRjb25kaXRpb25hbEhhbmRsZXJzWyRjb25kaXRpb25hbF07XG4gICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKCdudW1iZXInLCB2YWwsIHRoaXMucGF0aCwgbnVsbCwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgdmFsLCBjb250ZXh0KTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgdmFsID0gdGhpcy5hcHBseVNldHRlcnModmFsLCBjb250ZXh0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIENhc3RFcnJvciAmJiBlcnIucGF0aCA9PT0gdGhpcy5wYXRoICYmIHRoaXMuJGZ1bGxQYXRoICE9IG51bGwpIHtcbiAgICAgIGVyci5wYXRoID0gdGhpcy4kZnVsbFBhdGg7XG4gICAgfVxuICAgIHRocm93IGVycjtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59O1xuXG4vKiFcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hTnVtYmVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/schema/number.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/schema/objectId.js":
/*!***************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/schema/objectId.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst SchemaObjectIdOptions = __webpack_require__(/*! ../options/schemaObjectIdOptions */ \"../backend/node_modules/mongoose/lib/options/schemaObjectIdOptions.js\");\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"../backend/node_modules/mongoose/lib/schemaType.js\");\nconst castObjectId = __webpack_require__(/*! ../cast/objectid */ \"../backend/node_modules/mongoose/lib/cast/objectid.js\");\nconst getConstructorName = __webpack_require__(/*! ../helpers/getConstructorName */ \"../backend/node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst oid = __webpack_require__(/*! ../types/objectid */ \"../backend/node_modules/mongoose/lib/types/objectid.js\");\nconst isBsonType = __webpack_require__(/*! ../helpers/isBsonType */ \"../backend/node_modules/mongoose/lib/helpers/isBsonType.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\n\nconst CastError = SchemaType.CastError;\nlet Document;\n\n/**\n * ObjectId SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaObjectId(key, options) {\n  const isKeyHexStr = typeof key === 'string' && key.length === 24 && /^[a-f0-9]+$/i.test(key);\n  const suppressWarning = options && options.suppressWarning;\n  if ((isKeyHexStr || typeof key === 'undefined') && !suppressWarning) {\n    utils.warn('mongoose: To create a new ObjectId please try ' +\n      '`Mongoose.Types.ObjectId` instead of using ' +\n      '`Mongoose.Schema.ObjectId`. Set the `suppressWarning` option if ' +\n      'you\\'re trying to create a hex char path in your schema.');\n  }\n  SchemaType.call(this, key, options, 'ObjectId');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaObjectId.schemaName = 'ObjectId';\n\nSchemaObjectId.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaObjectId.prototype = Object.create(SchemaType.prototype);\nSchemaObjectId.prototype.constructor = SchemaObjectId;\nSchemaObjectId.prototype.OptionsConstructor = SchemaObjectIdOptions;\n\n/**\n * Attaches a getter for all ObjectId instances\n *\n * #### Example:\n *\n *     // Always convert to string when getting an ObjectId\n *     mongoose.ObjectId.get(v => v.toString());\n *\n *     const Model = mongoose.model('Test', new Schema({}));\n *     typeof (new Model({})._id); // 'string'\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaObjectId.get = SchemaType.get;\n\n/**\n * Sets a default option for all ObjectId instances.\n *\n * #### Example:\n *\n *     // Make all object ids have option `required` equal to true.\n *     mongoose.Schema.ObjectId.set('required', true);\n *\n *     const Order = mongoose.model('Order', new Schema({ userId: ObjectId }));\n *     new Order({ }).validateSync().errors.userId.message; // Path `userId` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaObjectId.set = SchemaType.set;\n\nSchemaObjectId.setters = [];\n\n/**\n * Adds an auto-generated ObjectId default if turnOn is true.\n * @param {Boolean} turnOn auto generated ObjectId defaults\n * @api public\n * @return {SchemaType} this\n */\n\nSchemaObjectId.prototype.auto = function(turnOn) {\n  if (turnOn) {\n    this.default(defaultId);\n    this.set(resetId);\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nSchemaObjectId._checkRequired = v => isBsonType(v, 'ObjectId');\n\n/*!\n * ignore\n */\n\nSchemaObjectId._cast = castObjectId;\n\n/**\n * Get/set the function used to cast arbitrary values to objectids.\n *\n * #### Example:\n *\n *     // Make Mongoose only try to cast length 24 strings. By default, any 12\n *     // char string is a valid ObjectId.\n *     const original = mongoose.ObjectId.cast();\n *     mongoose.ObjectId.cast(v => {\n *       assert.ok(typeof v !== 'string' || v.length === 24);\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.ObjectId.cast(false);\n *\n * @param {Function} caster\n * @return {Function}\n * @function get\n * @static\n * @api public\n */\n\nSchemaObjectId.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaObjectId._defaultCaster = v => {\n  if (!(isBsonType(v, 'ObjectId'))) {\n    throw new Error(v + ' is not an instance of ObjectId');\n  }\n  return v;\n};\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * #### Example:\n *\n *     // Allow empty strings to pass `required` check\n *     mongoose.Schema.Types.String.checkRequired(v => v != null);\n *\n *     const M = mongoose.model({ str: { type: String, required: true } });\n *     new M({ str: '' }).validateSync(); // `null`, validation passes!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaObjectId.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaObjectId.prototype.checkRequired = function checkRequired(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ?\n    this.constructor.checkRequired() :\n    SchemaObjectId.checkRequired();\n\n  return _checkRequired(value);\n};\n\n/**\n * Casts to ObjectId\n *\n * @param {Object} value\n * @param {Object} doc\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nSchemaObjectId.prototype.cast = function(value, doc, init) {\n  if (!(isBsonType(value, 'ObjectId')) && SchemaType._isRef(this, value, doc, init)) {\n    // wait! we may need to cast this to a document\n    if ((getConstructorName(value) || '').toLowerCase() === 'objectid') {\n      return new oid(value.toHexString());\n    }\n\n    if (value == null || utils.isNonBuiltinObject(value)) {\n      return this._castRef(value, doc, init);\n    }\n  }\n\n  let castObjectId;\n  if (typeof this._castFunction === 'function') {\n    castObjectId = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castObjectId = this.constructor.cast();\n  } else {\n    castObjectId = SchemaObjectId.cast();\n  }\n\n  try {\n    return castObjectId(value);\n  } catch (error) {\n    throw new CastError('ObjectId', value, this.path, error, this);\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\nSchemaObjectId.prototype.$conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $lt: handleSingle,\n  $lte: handleSingle\n};\n\n/*!\n * ignore\n */\n\nfunction defaultId() {\n  return new oid();\n}\n\ndefaultId.$runBeforeSetters = true;\n\nfunction resetId(v) {\n  Document || (Document = __webpack_require__(/*! ../document */ \"../backend/node_modules/mongoose/lib/document.js\"));\n\n  if (this instanceof Document) {\n    if (v === void 0) {\n      const _v = new oid();\n      return _v;\n    }\n  }\n\n  return v;\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaObjectId;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9vYmplY3RJZC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsOEJBQThCLG1CQUFPLENBQUMsK0dBQWtDO0FBQ3hFLG1CQUFtQixtQkFBTyxDQUFDLHlFQUFlO0FBQzFDLHFCQUFxQixtQkFBTyxDQUFDLCtFQUFrQjtBQUMvQywyQkFBMkIsbUJBQU8sQ0FBQyx5R0FBK0I7QUFDbEUsWUFBWSxtQkFBTyxDQUFDLGlGQUFtQjtBQUN2QyxtQkFBbUIsbUJBQU8sQ0FBQyx5RkFBdUI7QUFDbEQsY0FBYyxtQkFBTyxDQUFDLCtEQUFVOztBQUVoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsa0JBQWtCO0FBQzVFLG9CQUFvQix3Q0FBd0M7QUFDNUQ7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPLGdDQUFnQztBQUN6RSxlQUFlLFNBQVMsa0JBQWtCO0FBQzFDO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwwQkFBMEIsbUJBQU8sQ0FBQyxxRUFBYTs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9vYmplY3RJZC5qcz9iOWI5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IFNjaGVtYU9iamVjdElkT3B0aW9ucyA9IHJlcXVpcmUoJy4uL29wdGlvbnMvc2NoZW1hT2JqZWN0SWRPcHRpb25zJyk7XG5jb25zdCBTY2hlbWFUeXBlID0gcmVxdWlyZSgnLi4vc2NoZW1hVHlwZScpO1xuY29uc3QgY2FzdE9iamVjdElkID0gcmVxdWlyZSgnLi4vY2FzdC9vYmplY3RpZCcpO1xuY29uc3QgZ2V0Q29uc3RydWN0b3JOYW1lID0gcmVxdWlyZSgnLi4vaGVscGVycy9nZXRDb25zdHJ1Y3Rvck5hbWUnKTtcbmNvbnN0IG9pZCA9IHJlcXVpcmUoJy4uL3R5cGVzL29iamVjdGlkJyk7XG5jb25zdCBpc0Jzb25UeXBlID0gcmVxdWlyZSgnLi4vaGVscGVycy9pc0Jzb25UeXBlJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmNvbnN0IENhc3RFcnJvciA9IFNjaGVtYVR5cGUuQ2FzdEVycm9yO1xubGV0IERvY3VtZW50O1xuXG4vKipcbiAqIE9iamVjdElkIFNjaGVtYVR5cGUgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBpbmhlcml0cyBTY2hlbWFUeXBlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNjaGVtYU9iamVjdElkKGtleSwgb3B0aW9ucykge1xuICBjb25zdCBpc0tleUhleFN0ciA9IHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleS5sZW5ndGggPT09IDI0ICYmIC9eW2EtZjAtOV0rJC9pLnRlc3Qoa2V5KTtcbiAgY29uc3Qgc3VwcHJlc3NXYXJuaW5nID0gb3B0aW9ucyAmJiBvcHRpb25zLnN1cHByZXNzV2FybmluZztcbiAgaWYgKChpc0tleUhleFN0ciB8fCB0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJykgJiYgIXN1cHByZXNzV2FybmluZykge1xuICAgIHV0aWxzLndhcm4oJ21vbmdvb3NlOiBUbyBjcmVhdGUgYSBuZXcgT2JqZWN0SWQgcGxlYXNlIHRyeSAnICtcbiAgICAgICdgTW9uZ29vc2UuVHlwZXMuT2JqZWN0SWRgIGluc3RlYWQgb2YgdXNpbmcgJyArXG4gICAgICAnYE1vbmdvb3NlLlNjaGVtYS5PYmplY3RJZGAuIFNldCB0aGUgYHN1cHByZXNzV2FybmluZ2Agb3B0aW9uIGlmICcgK1xuICAgICAgJ3lvdVxcJ3JlIHRyeWluZyB0byBjcmVhdGUgYSBoZXggY2hhciBwYXRoIGluIHlvdXIgc2NoZW1hLicpO1xuICB9XG4gIFNjaGVtYVR5cGUuY2FsbCh0aGlzLCBrZXksIG9wdGlvbnMsICdPYmplY3RJZCcpO1xufVxuXG4vKipcbiAqIFRoaXMgc2NoZW1hIHR5cGUncyBuYW1lLCB0byBkZWZlbmQgYWdhaW5zdCBtaW5pZmllcnMgdGhhdCBtYW5nbGVcbiAqIGZ1bmN0aW9uIG5hbWVzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblNjaGVtYU9iamVjdElkLnNjaGVtYU5hbWUgPSAnT2JqZWN0SWQnO1xuXG5TY2hlbWFPYmplY3RJZC5kZWZhdWx0T3B0aW9ucyA9IHt9O1xuXG4vKiFcbiAqIEluaGVyaXRzIGZyb20gU2NoZW1hVHlwZS5cbiAqL1xuU2NoZW1hT2JqZWN0SWQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTY2hlbWFUeXBlLnByb3RvdHlwZSk7XG5TY2hlbWFPYmplY3RJZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTY2hlbWFPYmplY3RJZDtcblNjaGVtYU9iamVjdElkLnByb3RvdHlwZS5PcHRpb25zQ29uc3RydWN0b3IgPSBTY2hlbWFPYmplY3RJZE9wdGlvbnM7XG5cbi8qKlxuICogQXR0YWNoZXMgYSBnZXR0ZXIgZm9yIGFsbCBPYmplY3RJZCBpbnN0YW5jZXNcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIEFsd2F5cyBjb252ZXJ0IHRvIHN0cmluZyB3aGVuIGdldHRpbmcgYW4gT2JqZWN0SWRcbiAqICAgICBtb25nb29zZS5PYmplY3RJZC5nZXQodiA9PiB2LnRvU3RyaW5nKCkpO1xuICpcbiAqICAgICBjb25zdCBNb2RlbCA9IG1vbmdvb3NlLm1vZGVsKCdUZXN0JywgbmV3IFNjaGVtYSh7fSkpO1xuICogICAgIHR5cGVvZiAobmV3IE1vZGVsKHt9KS5faWQpOyAvLyAnc3RyaW5nJ1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlclxuICogQHJldHVybiB7dGhpc31cbiAqIEBmdW5jdGlvbiBnZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hT2JqZWN0SWQuZ2V0ID0gU2NoZW1hVHlwZS5nZXQ7XG5cbi8qKlxuICogU2V0cyBhIGRlZmF1bHQgb3B0aW9uIGZvciBhbGwgT2JqZWN0SWQgaW5zdGFuY2VzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTWFrZSBhbGwgb2JqZWN0IGlkcyBoYXZlIG9wdGlvbiBgcmVxdWlyZWRgIGVxdWFsIHRvIHRydWUuXG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLk9iamVjdElkLnNldCgncmVxdWlyZWQnLCB0cnVlKTtcbiAqXG4gKiAgICAgY29uc3QgT3JkZXIgPSBtb25nb29zZS5tb2RlbCgnT3JkZXInLCBuZXcgU2NoZW1hKHsgdXNlcklkOiBPYmplY3RJZCB9KSk7XG4gKiAgICAgbmV3IE9yZGVyKHsgfSkudmFsaWRhdGVTeW5jKCkuZXJyb3JzLnVzZXJJZC5tZXNzYWdlOyAvLyBQYXRoIGB1c2VySWRgIGlzIHJlcXVpcmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb24gVGhlIG9wdGlvbiB5b3UnZCBsaWtlIHRvIHNldCB0aGUgdmFsdWUgZm9yXG4gKiBAcGFyYW0ge0FueX0gdmFsdWUgdmFsdWUgZm9yIG9wdGlvblxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICogQGZ1bmN0aW9uIHNldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFPYmplY3RJZC5zZXQgPSBTY2hlbWFUeXBlLnNldDtcblxuU2NoZW1hT2JqZWN0SWQuc2V0dGVycyA9IFtdO1xuXG4vKipcbiAqIEFkZHMgYW4gYXV0by1nZW5lcmF0ZWQgT2JqZWN0SWQgZGVmYXVsdCBpZiB0dXJuT24gaXMgdHJ1ZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdHVybk9uIGF1dG8gZ2VuZXJhdGVkIE9iamVjdElkIGRlZmF1bHRzXG4gKiBAYXBpIHB1YmxpY1xuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICovXG5cblNjaGVtYU9iamVjdElkLnByb3RvdHlwZS5hdXRvID0gZnVuY3Rpb24odHVybk9uKSB7XG4gIGlmICh0dXJuT24pIHtcbiAgICB0aGlzLmRlZmF1bHQoZGVmYXVsdElkKTtcbiAgICB0aGlzLnNldChyZXNldElkKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFPYmplY3RJZC5fY2hlY2tSZXF1aXJlZCA9IHYgPT4gaXNCc29uVHlwZSh2LCAnT2JqZWN0SWQnKTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFPYmplY3RJZC5fY2FzdCA9IGNhc3RPYmplY3RJZDtcblxuLyoqXG4gKiBHZXQvc2V0IHRoZSBmdW5jdGlvbiB1c2VkIHRvIGNhc3QgYXJiaXRyYXJ5IHZhbHVlcyB0byBvYmplY3RpZHMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYWtlIE1vbmdvb3NlIG9ubHkgdHJ5IHRvIGNhc3QgbGVuZ3RoIDI0IHN0cmluZ3MuIEJ5IGRlZmF1bHQsIGFueSAxMlxuICogICAgIC8vIGNoYXIgc3RyaW5nIGlzIGEgdmFsaWQgT2JqZWN0SWQuXG4gKiAgICAgY29uc3Qgb3JpZ2luYWwgPSBtb25nb29zZS5PYmplY3RJZC5jYXN0KCk7XG4gKiAgICAgbW9uZ29vc2UuT2JqZWN0SWQuY2FzdCh2ID0+IHtcbiAqICAgICAgIGFzc2VydC5vayh0eXBlb2YgdiAhPT0gJ3N0cmluZycgfHwgdi5sZW5ndGggPT09IDI0KTtcbiAqICAgICAgIHJldHVybiBvcmlnaW5hbCh2KTtcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gT3IgZGlzYWJsZSBjYXN0aW5nIGVudGlyZWx5XG4gKiAgICAgbW9uZ29vc2UuT2JqZWN0SWQuY2FzdChmYWxzZSk7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FzdGVyXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBmdW5jdGlvbiBnZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hT2JqZWN0SWQuY2FzdCA9IGZ1bmN0aW9uIGNhc3QoY2FzdGVyKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nhc3Q7XG4gIH1cbiAgaWYgKGNhc3RlciA9PT0gZmFsc2UpIHtcbiAgICBjYXN0ZXIgPSB0aGlzLl9kZWZhdWx0Q2FzdGVyO1xuICB9XG4gIHRoaXMuX2Nhc3QgPSBjYXN0ZXI7XG5cbiAgcmV0dXJuIHRoaXMuX2Nhc3Q7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYU9iamVjdElkLl9kZWZhdWx0Q2FzdGVyID0gdiA9PiB7XG4gIGlmICghKGlzQnNvblR5cGUodiwgJ09iamVjdElkJykpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHYgKyAnIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBPYmplY3RJZCcpO1xuICB9XG4gIHJldHVybiB2O1xufTtcblxuLyoqXG4gKiBPdmVycmlkZSB0aGUgZnVuY3Rpb24gdGhlIHJlcXVpcmVkIHZhbGlkYXRvciB1c2VzIHRvIGNoZWNrIHdoZXRoZXIgYSBzdHJpbmdcbiAqIHBhc3NlcyB0aGUgYHJlcXVpcmVkYCBjaGVjay5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIEFsbG93IGVtcHR5IHN0cmluZ3MgdG8gcGFzcyBgcmVxdWlyZWRgIGNoZWNrXG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLlR5cGVzLlN0cmluZy5jaGVja1JlcXVpcmVkKHYgPT4gdiAhPSBudWxsKTtcbiAqXG4gKiAgICAgY29uc3QgTSA9IG1vbmdvb3NlLm1vZGVsKHsgc3RyOiB7IHR5cGU6IFN0cmluZywgcmVxdWlyZWQ6IHRydWUgfSB9KTtcbiAqICAgICBuZXcgTSh7IHN0cjogJycgfSkudmFsaWRhdGVTeW5jKCk7IC8vIGBudWxsYCwgdmFsaWRhdGlvbiBwYXNzZXMhXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGZ1bmN0aW9uIGNoZWNrUmVxdWlyZWRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hT2JqZWN0SWQuY2hlY2tSZXF1aXJlZCA9IFNjaGVtYVR5cGUuY2hlY2tSZXF1aXJlZDtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgc2F0aXNmaWVzIGEgcmVxdWlyZWQgdmFsaWRhdG9yLlxuICpcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZVxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFPYmplY3RJZC5wcm90b3R5cGUuY2hlY2tSZXF1aXJlZCA9IGZ1bmN0aW9uIGNoZWNrUmVxdWlyZWQodmFsdWUsIGRvYykge1xuICBpZiAoU2NoZW1hVHlwZS5faXNSZWYodGhpcywgdmFsdWUsIGRvYywgdHJ1ZSkpIHtcbiAgICByZXR1cm4gISF2YWx1ZTtcbiAgfVxuXG4gIC8vIGByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHMoKWAgZG9lcyAqKm5vdCoqIGNvcHkgc3RhdGljIHByb3BlcnRpZXMsIGFuZFxuICAvLyBwbHVnaW5zIGxpa2UgbW9uZ29vc2UtZmxvYXQgdXNlIGBpbmhlcml0cygpYCBmb3IgcHJlLUVTNi5cbiAgY29uc3QgX2NoZWNrUmVxdWlyZWQgPSB0eXBlb2YgdGhpcy5jb25zdHJ1Y3Rvci5jaGVja1JlcXVpcmVkID09PSAnZnVuY3Rpb24nID9cbiAgICB0aGlzLmNvbnN0cnVjdG9yLmNoZWNrUmVxdWlyZWQoKSA6XG4gICAgU2NoZW1hT2JqZWN0SWQuY2hlY2tSZXF1aXJlZCgpO1xuXG4gIHJldHVybiBfY2hlY2tSZXF1aXJlZCh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIENhc3RzIHRvIE9iamVjdElkXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gZG9jXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluaXQgd2hldGhlciB0aGlzIGlzIGFuIGluaXRpYWxpemF0aW9uIGNhc3RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYU9iamVjdElkLnByb3RvdHlwZS5jYXN0ID0gZnVuY3Rpb24odmFsdWUsIGRvYywgaW5pdCkge1xuICBpZiAoIShpc0Jzb25UeXBlKHZhbHVlLCAnT2JqZWN0SWQnKSkgJiYgU2NoZW1hVHlwZS5faXNSZWYodGhpcywgdmFsdWUsIGRvYywgaW5pdCkpIHtcbiAgICAvLyB3YWl0ISB3ZSBtYXkgbmVlZCB0byBjYXN0IHRoaXMgdG8gYSBkb2N1bWVudFxuICAgIGlmICgoZ2V0Q29uc3RydWN0b3JOYW1lKHZhbHVlKSB8fCAnJykudG9Mb3dlckNhc2UoKSA9PT0gJ29iamVjdGlkJykge1xuICAgICAgcmV0dXJuIG5ldyBvaWQodmFsdWUudG9IZXhTdHJpbmcoKSk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdXRpbHMuaXNOb25CdWlsdGluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Nhc3RSZWYodmFsdWUsIGRvYywgaW5pdCk7XG4gICAgfVxuICB9XG5cbiAgbGV0IGNhc3RPYmplY3RJZDtcbiAgaWYgKHR5cGVvZiB0aGlzLl9jYXN0RnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYXN0T2JqZWN0SWQgPSB0aGlzLl9jYXN0RnVuY3Rpb247XG4gIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuY29uc3RydWN0b3IuY2FzdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhc3RPYmplY3RJZCA9IHRoaXMuY29uc3RydWN0b3IuY2FzdCgpO1xuICB9IGVsc2Uge1xuICAgIGNhc3RPYmplY3RJZCA9IFNjaGVtYU9iamVjdElkLmNhc3QoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGNhc3RPYmplY3RJZCh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IENhc3RFcnJvcignT2JqZWN0SWQnLCB2YWx1ZSwgdGhpcy5wYXRoLCBlcnJvciwgdGhpcyk7XG4gIH1cbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gaGFuZGxlU2luZ2xlKHZhbCkge1xuICByZXR1cm4gdGhpcy5jYXN0KHZhbCk7XG59XG5cblNjaGVtYU9iamVjdElkLnByb3RvdHlwZS4kY29uZGl0aW9uYWxIYW5kbGVycyA9IHtcbiAgLi4uU2NoZW1hVHlwZS5wcm90b3R5cGUuJGNvbmRpdGlvbmFsSGFuZGxlcnMsXG4gICRndDogaGFuZGxlU2luZ2xlLFxuICAkZ3RlOiBoYW5kbGVTaW5nbGUsXG4gICRsdDogaGFuZGxlU2luZ2xlLFxuICAkbHRlOiBoYW5kbGVTaW5nbGVcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gZGVmYXVsdElkKCkge1xuICByZXR1cm4gbmV3IG9pZCgpO1xufVxuXG5kZWZhdWx0SWQuJHJ1bkJlZm9yZVNldHRlcnMgPSB0cnVlO1xuXG5mdW5jdGlvbiByZXNldElkKHYpIHtcbiAgRG9jdW1lbnQgfHwgKERvY3VtZW50ID0gcmVxdWlyZSgnLi4vZG9jdW1lbnQnKSk7XG5cbiAgaWYgKHRoaXMgaW5zdGFuY2VvZiBEb2N1bWVudCkge1xuICAgIGlmICh2ID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IF92ID0gbmV3IG9pZCgpO1xuICAgICAgcmV0dXJuIF92O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2O1xufVxuXG4vKiFcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hT2JqZWN0SWQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/schema/objectId.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/schema/operators/bitwise.js":
/*!************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/schema/operators/bitwise.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module requirements.\n */\n\n\n\nconst CastError = __webpack_require__(/*! ../../error/cast */ \"../backend/node_modules/mongoose/lib/error/cast.js\");\n\n/*!\n * ignore\n */\n\nfunction handleBitwiseOperator(val) {\n  const _this = this;\n  if (Array.isArray(val)) {\n    return val.map(function(v) {\n      return _castNumber(_this.path, v);\n    });\n  } else if (Buffer.isBuffer(val)) {\n    return val;\n  }\n  // Assume trying to cast to number\n  return _castNumber(_this.path, val);\n}\n\n/*!\n * ignore\n */\n\nfunction _castNumber(path, num) {\n  const v = Number(num);\n  if (isNaN(v)) {\n    throw new CastError('number', num, path);\n  }\n  return v;\n}\n\nmodule.exports = handleBitwiseOperator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9vcGVyYXRvcnMvYml0d2lzZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsa0JBQWtCLG1CQUFPLENBQUMsNEVBQWtCOztBQUU1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL29wZXJhdG9ycy9iaXR3aXNlLmpzPzg0Y2IiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgQ2FzdEVycm9yID0gcmVxdWlyZSgnLi4vLi4vZXJyb3IvY2FzdCcpO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGhhbmRsZUJpdHdpc2VPcGVyYXRvcih2YWwpIHtcbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuIHZhbC5tYXAoZnVuY3Rpb24odikge1xuICAgICAgcmV0dXJuIF9jYXN0TnVtYmVyKF90aGlzLnBhdGgsIHYpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICAvLyBBc3N1bWUgdHJ5aW5nIHRvIGNhc3QgdG8gbnVtYmVyXG4gIHJldHVybiBfY2FzdE51bWJlcihfdGhpcy5wYXRoLCB2YWwpO1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9jYXN0TnVtYmVyKHBhdGgsIG51bSkge1xuICBjb25zdCB2ID0gTnVtYmVyKG51bSk7XG4gIGlmIChpc05hTih2KSkge1xuICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJ251bWJlcicsIG51bSwgcGF0aCk7XG4gIH1cbiAgcmV0dXJuIHY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFuZGxlQml0d2lzZU9wZXJhdG9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/schema/operators/bitwise.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/schema/operators/exists.js":
/*!***********************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/schema/operators/exists.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst castBoolean = __webpack_require__(/*! ../../cast/boolean */ \"../backend/node_modules/mongoose/lib/cast/boolean.js\");\n\n/*!\n * ignore\n */\n\nmodule.exports = function(val) {\n  const path = this != null ? this.path : null;\n  return castBoolean(val, path);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9vcGVyYXRvcnMvZXhpc3RzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLG9CQUFvQixtQkFBTyxDQUFDLGdGQUFvQjs7QUFFaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9vcGVyYXRvcnMvZXhpc3RzLmpzPzkwNWMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjYXN0Qm9vbGVhbiA9IHJlcXVpcmUoJy4uLy4uL2Nhc3QvYm9vbGVhbicpO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsKSB7XG4gIGNvbnN0IHBhdGggPSB0aGlzICE9IG51bGwgPyB0aGlzLnBhdGggOiBudWxsO1xuICByZXR1cm4gY2FzdEJvb2xlYW4odmFsLCBwYXRoKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/schema/operators/exists.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/schema/operators/geospatial.js":
/*!***************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/schema/operators/geospatial.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module requirements.\n */\n\n\n\nconst castArraysOfNumbers = (__webpack_require__(/*! ./helpers */ \"../backend/node_modules/mongoose/lib/schema/operators/helpers.js\").castArraysOfNumbers);\nconst castToNumber = (__webpack_require__(/*! ./helpers */ \"../backend/node_modules/mongoose/lib/schema/operators/helpers.js\").castToNumber);\n\n/*!\n * ignore\n */\n\nexports.cast$geoIntersects = cast$geoIntersects;\nexports.cast$near = cast$near;\nexports.cast$within = cast$within;\n\nfunction cast$near(val) {\n  const SchemaArray = __webpack_require__(/*! ../array */ \"../backend/node_modules/mongoose/lib/schema/array.js\");\n\n  if (Array.isArray(val)) {\n    castArraysOfNumbers(val, this);\n    return val;\n  }\n\n  _castMinMaxDistance(this, val);\n\n  if (val && val.$geometry) {\n    return cast$geometry(val, this);\n  }\n\n  if (!Array.isArray(val)) {\n    throw new TypeError('$near must be either an array or an object ' +\n      'with a $geometry property');\n  }\n\n  return SchemaArray.prototype.castForQuery.call(this, null, val);\n}\n\nfunction cast$geometry(val, self) {\n  switch (val.$geometry.type) {\n    case 'Polygon':\n    case 'LineString':\n    case 'Point':\n      castArraysOfNumbers(val.$geometry.coordinates, self);\n      break;\n    default:\n      // ignore unknowns\n      break;\n  }\n\n  _castMinMaxDistance(self, val);\n\n  return val;\n}\n\nfunction cast$within(val) {\n  _castMinMaxDistance(this, val);\n\n  if (val.$box || val.$polygon) {\n    const type = val.$box ? '$box' : '$polygon';\n    val[type].forEach(arr => {\n      if (!Array.isArray(arr)) {\n        const msg = 'Invalid $within $box argument. '\n            + 'Expected an array, received ' + arr;\n        throw new TypeError(msg);\n      }\n      arr.forEach((v, i) => {\n        arr[i] = castToNumber.call(this, v);\n      });\n    });\n  } else if (val.$center || val.$centerSphere) {\n    const type = val.$center ? '$center' : '$centerSphere';\n    val[type].forEach((item, i) => {\n      if (Array.isArray(item)) {\n        item.forEach((v, j) => {\n          item[j] = castToNumber.call(this, v);\n        });\n      } else {\n        val[type][i] = castToNumber.call(this, item);\n      }\n    });\n  } else if (val.$geometry) {\n    cast$geometry(val, this);\n  }\n\n  return val;\n}\n\nfunction cast$geoIntersects(val) {\n  const geo = val.$geometry;\n  if (!geo) {\n    return;\n  }\n\n  cast$geometry(val, this);\n  return val;\n}\n\nfunction _castMinMaxDistance(self, val) {\n  if (val.$maxDistance) {\n    val.$maxDistance = castToNumber.call(self, val.$maxDistance);\n  }\n  if (val.$minDistance) {\n    val.$minDistance = castToNumber.call(self, val.$minDistance);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9vcGVyYXRvcnMvZ2Vvc3BhdGlhbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsNEJBQTRCLDhIQUF3QztBQUNwRSxxQkFBcUIsdUhBQWlDOztBQUV0RDtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCLGlCQUFpQjtBQUNqQixtQkFBbUI7O0FBRW5CO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsc0VBQVU7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL29wZXJhdG9ycy9nZW9zcGF0aWFsLmpzPzBiNGMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgY2FzdEFycmF5c09mTnVtYmVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpLmNhc3RBcnJheXNPZk51bWJlcnM7XG5jb25zdCBjYXN0VG9OdW1iZXIgPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5jYXN0VG9OdW1iZXI7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZXhwb3J0cy5jYXN0JGdlb0ludGVyc2VjdHMgPSBjYXN0JGdlb0ludGVyc2VjdHM7XG5leHBvcnRzLmNhc3QkbmVhciA9IGNhc3QkbmVhcjtcbmV4cG9ydHMuY2FzdCR3aXRoaW4gPSBjYXN0JHdpdGhpbjtcblxuZnVuY3Rpb24gY2FzdCRuZWFyKHZhbCkge1xuICBjb25zdCBTY2hlbWFBcnJheSA9IHJlcXVpcmUoJy4uL2FycmF5Jyk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIGNhc3RBcnJheXNPZk51bWJlcnModmFsLCB0aGlzKTtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgX2Nhc3RNaW5NYXhEaXN0YW5jZSh0aGlzLCB2YWwpO1xuXG4gIGlmICh2YWwgJiYgdmFsLiRnZW9tZXRyeSkge1xuICAgIHJldHVybiBjYXN0JGdlb21ldHJ5KHZhbCwgdGhpcyk7XG4gIH1cblxuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJyRuZWFyIG11c3QgYmUgZWl0aGVyIGFuIGFycmF5IG9yIGFuIG9iamVjdCAnICtcbiAgICAgICd3aXRoIGEgJGdlb21ldHJ5IHByb3BlcnR5Jyk7XG4gIH1cblxuICByZXR1cm4gU2NoZW1hQXJyYXkucHJvdG90eXBlLmNhc3RGb3JRdWVyeS5jYWxsKHRoaXMsIG51bGwsIHZhbCk7XG59XG5cbmZ1bmN0aW9uIGNhc3QkZ2VvbWV0cnkodmFsLCBzZWxmKSB7XG4gIHN3aXRjaCAodmFsLiRnZW9tZXRyeS50eXBlKSB7XG4gICAgY2FzZSAnUG9seWdvbic6XG4gICAgY2FzZSAnTGluZVN0cmluZyc6XG4gICAgY2FzZSAnUG9pbnQnOlxuICAgICAgY2FzdEFycmF5c09mTnVtYmVycyh2YWwuJGdlb21ldHJ5LmNvb3JkaW5hdGVzLCBzZWxmKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBpZ25vcmUgdW5rbm93bnNcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgX2Nhc3RNaW5NYXhEaXN0YW5jZShzZWxmLCB2YWwpO1xuXG4gIHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIGNhc3Qkd2l0aGluKHZhbCkge1xuICBfY2FzdE1pbk1heERpc3RhbmNlKHRoaXMsIHZhbCk7XG5cbiAgaWYgKHZhbC4kYm94IHx8IHZhbC4kcG9seWdvbikge1xuICAgIGNvbnN0IHR5cGUgPSB2YWwuJGJveCA/ICckYm94JyA6ICckcG9seWdvbic7XG4gICAgdmFsW3R5cGVdLmZvckVhY2goYXJyID0+IHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9ICdJbnZhbGlkICR3aXRoaW4gJGJveCBhcmd1bWVudC4gJ1xuICAgICAgICAgICAgKyAnRXhwZWN0ZWQgYW4gYXJyYXksIHJlY2VpdmVkICcgKyBhcnI7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIGFyci5mb3JFYWNoKCh2LCBpKSA9PiB7XG4gICAgICAgIGFycltpXSA9IGNhc3RUb051bWJlci5jYWxsKHRoaXMsIHYpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodmFsLiRjZW50ZXIgfHwgdmFsLiRjZW50ZXJTcGhlcmUpIHtcbiAgICBjb25zdCB0eXBlID0gdmFsLiRjZW50ZXIgPyAnJGNlbnRlcicgOiAnJGNlbnRlclNwaGVyZSc7XG4gICAgdmFsW3R5cGVdLmZvckVhY2goKGl0ZW0sIGkpID0+IHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgIGl0ZW0uZm9yRWFjaCgodiwgaikgPT4ge1xuICAgICAgICAgIGl0ZW1bal0gPSBjYXN0VG9OdW1iZXIuY2FsbCh0aGlzLCB2KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWxbdHlwZV1baV0gPSBjYXN0VG9OdW1iZXIuY2FsbCh0aGlzLCBpdGVtKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIGlmICh2YWwuJGdlb21ldHJ5KSB7XG4gICAgY2FzdCRnZW9tZXRyeSh2YWwsIHRoaXMpO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gY2FzdCRnZW9JbnRlcnNlY3RzKHZhbCkge1xuICBjb25zdCBnZW8gPSB2YWwuJGdlb21ldHJ5O1xuICBpZiAoIWdlbykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNhc3QkZ2VvbWV0cnkodmFsLCB0aGlzKTtcbiAgcmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gX2Nhc3RNaW5NYXhEaXN0YW5jZShzZWxmLCB2YWwpIHtcbiAgaWYgKHZhbC4kbWF4RGlzdGFuY2UpIHtcbiAgICB2YWwuJG1heERpc3RhbmNlID0gY2FzdFRvTnVtYmVyLmNhbGwoc2VsZiwgdmFsLiRtYXhEaXN0YW5jZSk7XG4gIH1cbiAgaWYgKHZhbC4kbWluRGlzdGFuY2UpIHtcbiAgICB2YWwuJG1pbkRpc3RhbmNlID0gY2FzdFRvTnVtYmVyLmNhbGwoc2VsZiwgdmFsLiRtaW5EaXN0YW5jZSk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/schema/operators/geospatial.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/schema/operators/helpers.js":
/*!************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/schema/operators/helpers.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module requirements.\n */\n\nconst SchemaNumber = __webpack_require__(/*! ../number */ \"../backend/node_modules/mongoose/lib/schema/number.js\");\n\n/*!\n * ignore\n */\n\nexports.castToNumber = castToNumber;\nexports.castArraysOfNumbers = castArraysOfNumbers;\n\n/*!\n * ignore\n */\n\nfunction castToNumber(val) {\n  return SchemaNumber.cast()(val);\n}\n\nfunction castArraysOfNumbers(arr, self) {\n  arr.forEach(function(v, i) {\n    if (Array.isArray(v)) {\n      castArraysOfNumbers(v, self);\n    } else {\n      arr[i] = castToNumber.call(self, v);\n    }\n  });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9vcGVyYXRvcnMvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLG1CQUFPLENBQUMsd0VBQVc7O0FBRXhDO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEIsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL29wZXJhdG9ycy9oZWxwZXJzLmpzPzM3Y2IiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxuY29uc3QgU2NoZW1hTnVtYmVyID0gcmVxdWlyZSgnLi4vbnVtYmVyJyk7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZXhwb3J0cy5jYXN0VG9OdW1iZXIgPSBjYXN0VG9OdW1iZXI7XG5leHBvcnRzLmNhc3RBcnJheXNPZk51bWJlcnMgPSBjYXN0QXJyYXlzT2ZOdW1iZXJzO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGNhc3RUb051bWJlcih2YWwpIHtcbiAgcmV0dXJuIFNjaGVtYU51bWJlci5jYXN0KCkodmFsKTtcbn1cblxuZnVuY3Rpb24gY2FzdEFycmF5c09mTnVtYmVycyhhcnIsIHNlbGYpIHtcbiAgYXJyLmZvckVhY2goZnVuY3Rpb24odiwgaSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICBjYXN0QXJyYXlzT2ZOdW1iZXJzKHYsIHNlbGYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcnJbaV0gPSBjYXN0VG9OdW1iZXIuY2FsbChzZWxmLCB2KTtcbiAgICB9XG4gIH0pO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/schema/operators/helpers.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/schema/operators/text.js":
/*!*********************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/schema/operators/text.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst CastError = __webpack_require__(/*! ../../error/cast */ \"../backend/node_modules/mongoose/lib/error/cast.js\");\nconst castBoolean = __webpack_require__(/*! ../../cast/boolean */ \"../backend/node_modules/mongoose/lib/cast/boolean.js\");\nconst castString = __webpack_require__(/*! ../../cast/string */ \"../backend/node_modules/mongoose/lib/cast/string.js\");\n\n/**\n * Casts val to an object suitable for `$text`. Throws an error if the object\n * can't be casted.\n *\n * @param {Any} val value to cast\n * @param {String} [path] path to associate with any errors that occured\n * @return {Object} casted object\n * @see https://www.mongodb.com/docs/manual/reference/operator/query/text/\n * @api private\n */\n\nmodule.exports = function(val, path) {\n  if (val == null || typeof val !== 'object') {\n    throw new CastError('$text', val, path);\n  }\n\n  if (val.$search != null) {\n    val.$search = castString(val.$search, path + '.$search');\n  }\n  if (val.$language != null) {\n    val.$language = castString(val.$language, path + '.$language');\n  }\n  if (val.$caseSensitive != null) {\n    val.$caseSensitive = castBoolean(val.$caseSensitive,\n      path + '.$castSensitive');\n  }\n  if (val.$diacriticSensitive != null) {\n    val.$diacriticSensitive = castBoolean(val.$diacriticSensitive,\n      path + '.$diacriticSensitive');\n  }\n\n  return val;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9vcGVyYXRvcnMvdGV4dC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixrQkFBa0IsbUJBQU8sQ0FBQyw0RUFBa0I7QUFDNUMsb0JBQW9CLG1CQUFPLENBQUMsZ0ZBQW9CO0FBQ2hELG1CQUFtQixtQkFBTyxDQUFDLDhFQUFtQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9vcGVyYXRvcnMvdGV4dC5qcz8wYzBmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQ2FzdEVycm9yID0gcmVxdWlyZSgnLi4vLi4vZXJyb3IvY2FzdCcpO1xuY29uc3QgY2FzdEJvb2xlYW4gPSByZXF1aXJlKCcuLi8uLi9jYXN0L2Jvb2xlYW4nKTtcbmNvbnN0IGNhc3RTdHJpbmcgPSByZXF1aXJlKCcuLi8uLi9jYXN0L3N0cmluZycpO1xuXG4vKipcbiAqIENhc3RzIHZhbCB0byBhbiBvYmplY3Qgc3VpdGFibGUgZm9yIGAkdGV4dGAuIFRocm93cyBhbiBlcnJvciBpZiB0aGUgb2JqZWN0XG4gKiBjYW4ndCBiZSBjYXN0ZWQuXG4gKlxuICogQHBhcmFtIHtBbnl9IHZhbCB2YWx1ZSB0byBjYXN0XG4gKiBAcGFyYW0ge1N0cmluZ30gW3BhdGhdIHBhdGggdG8gYXNzb2NpYXRlIHdpdGggYW55IGVycm9ycyB0aGF0IG9jY3VyZWRcbiAqIEByZXR1cm4ge09iamVjdH0gY2FzdGVkIG9iamVjdFxuICogQHNlZSBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvcXVlcnkvdGV4dC9cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBwYXRoKSB7XG4gIGlmICh2YWwgPT0gbnVsbCB8fCB0eXBlb2YgdmFsICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJyR0ZXh0JywgdmFsLCBwYXRoKTtcbiAgfVxuXG4gIGlmICh2YWwuJHNlYXJjaCAhPSBudWxsKSB7XG4gICAgdmFsLiRzZWFyY2ggPSBjYXN0U3RyaW5nKHZhbC4kc2VhcmNoLCBwYXRoICsgJy4kc2VhcmNoJyk7XG4gIH1cbiAgaWYgKHZhbC4kbGFuZ3VhZ2UgIT0gbnVsbCkge1xuICAgIHZhbC4kbGFuZ3VhZ2UgPSBjYXN0U3RyaW5nKHZhbC4kbGFuZ3VhZ2UsIHBhdGggKyAnLiRsYW5ndWFnZScpO1xuICB9XG4gIGlmICh2YWwuJGNhc2VTZW5zaXRpdmUgIT0gbnVsbCkge1xuICAgIHZhbC4kY2FzZVNlbnNpdGl2ZSA9IGNhc3RCb29sZWFuKHZhbC4kY2FzZVNlbnNpdGl2ZSxcbiAgICAgIHBhdGggKyAnLiRjYXN0U2Vuc2l0aXZlJyk7XG4gIH1cbiAgaWYgKHZhbC4kZGlhY3JpdGljU2Vuc2l0aXZlICE9IG51bGwpIHtcbiAgICB2YWwuJGRpYWNyaXRpY1NlbnNpdGl2ZSA9IGNhc3RCb29sZWFuKHZhbC4kZGlhY3JpdGljU2Vuc2l0aXZlLFxuICAgICAgcGF0aCArICcuJGRpYWNyaXRpY1NlbnNpdGl2ZScpO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/schema/operators/text.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/schema/operators/type.js":
/*!*********************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/schema/operators/type.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*!\n * ignore\n */\n\nmodule.exports = function(val) {\n  if (Array.isArray(val)) {\n    if (!val.every(v => typeof v === 'number' || typeof v === 'string')) {\n      throw new Error('$type array values must be strings or numbers');\n    }\n    return val;\n  }\n\n  if (typeof val !== 'number' && typeof val !== 'string') {\n    throw new Error('$type parameter must be number, string, or array of numbers and strings');\n  }\n\n  return val;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9vcGVyYXRvcnMvdHlwZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL29wZXJhdG9ycy90eXBlLmpzPzFhNzAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICBpZiAoIXZhbC5ldmVyeSh2ID0+IHR5cGVvZiB2ID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdiA9PT0gJ3N0cmluZycpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJyR0eXBlIGFycmF5IHZhbHVlcyBtdXN0IGJlIHN0cmluZ3Mgb3IgbnVtYmVycycpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInICYmIHR5cGVvZiB2YWwgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCckdHlwZSBwYXJhbWV0ZXIgbXVzdCBiZSBudW1iZXIsIHN0cmluZywgb3IgYXJyYXkgb2YgbnVtYmVycyBhbmQgc3RyaW5ncycpO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/schema/operators/type.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/schema/string.js":
/*!*************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/schema/string.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"../backend/node_modules/mongoose/lib/schemaType.js\");\nconst MongooseError = __webpack_require__(/*! ../error/index */ \"../backend/node_modules/mongoose/lib/error/index.js\");\nconst SchemaStringOptions = __webpack_require__(/*! ../options/schemaStringOptions */ \"../backend/node_modules/mongoose/lib/options/schemaStringOptions.js\");\nconst castString = __webpack_require__(/*! ../cast/string */ \"../backend/node_modules/mongoose/lib/cast/string.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\nconst isBsonType = __webpack_require__(/*! ../helpers/isBsonType */ \"../backend/node_modules/mongoose/lib/helpers/isBsonType.js\");\n\nconst CastError = SchemaType.CastError;\n\n/**\n * String SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaString(key, options) {\n  this.enumValues = [];\n  this.regExp = null;\n  SchemaType.call(this, key, options, 'String');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaString.schemaName = 'String';\n\nSchemaString.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaString.prototype = Object.create(SchemaType.prototype);\nSchemaString.prototype.constructor = SchemaString;\nObject.defineProperty(SchemaString.prototype, 'OptionsConstructor', {\n  configurable: false,\n  enumerable: false,\n  writable: false,\n  value: SchemaStringOptions\n});\n\n/*!\n * ignore\n */\n\nSchemaString._cast = castString;\n\n/**\n * Get/set the function used to cast arbitrary values to strings.\n *\n * #### Example:\n *\n *     // Throw an error if you pass in an object. Normally, Mongoose allows\n *     // objects with custom `toString()` functions.\n *     const original = mongoose.Schema.Types.String.cast();\n *     mongoose.Schema.Types.String.cast(v => {\n *       assert.ok(v == null || typeof v !== 'object');\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.Schema.Types.String.cast(false);\n *\n * @param {Function} caster\n * @return {Function}\n * @function get\n * @static\n * @api public\n */\n\nSchemaString.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaString._defaultCaster = v => {\n  if (v != null && typeof v !== 'string') {\n    throw new Error();\n  }\n  return v;\n};\n\n/**\n * Attaches a getter for all String instances.\n *\n * #### Example:\n *\n *     // Make all numbers round down\n *     mongoose.Schema.String.get(v => v.toLowerCase());\n *\n *     const Model = mongoose.model('Test', new Schema({ test: String }));\n *     new Model({ test: 'FOO' }).test; // 'foo'\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaString.get = SchemaType.get;\n\n/**\n * Sets a default option for all String instances.\n *\n * #### Example:\n *\n *     // Make all strings have option `trim` equal to true.\n *     mongoose.Schema.String.set('trim', true);\n *\n *     const User = mongoose.model('User', new Schema({ name: String }));\n *     new User({ name: '   John Doe   ' }).name; // 'John Doe'\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaString.set = SchemaType.set;\n\nSchemaString.setters = [];\n\n/*!\n * ignore\n */\n\nSchemaString._checkRequired = v => (v instanceof String || typeof v === 'string') && v.length;\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * #### Example:\n *\n *     // Allow empty strings to pass `required` check\n *     mongoose.Schema.Types.String.checkRequired(v => v != null);\n *\n *     const M = mongoose.model({ str: { type: String, required: true } });\n *     new M({ str: '' }).validateSync(); // `null`, validation passes!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaString.checkRequired = SchemaType.checkRequired;\n\n/**\n * Adds an enum validator\n *\n * #### Example:\n *\n *     const states = ['opening', 'open', 'closing', 'closed']\n *     const s = new Schema({ state: { type: String, enum: states }})\n *     const M = db.model('M', s)\n *     const m = new M({ state: 'invalid' })\n *     m.save(function (err) {\n *       console.error(String(err)) // ValidationError: `invalid` is not a valid enum value for path `state`.\n *       m.state = 'open'\n *       m.save(callback) // success\n *     })\n *\n *     // or with custom error messages\n *     const enum = {\n *       values: ['opening', 'open', 'closing', 'closed'],\n *       message: 'enum validator failed for path `{PATH}` with value `{VALUE}`'\n *     }\n *     const s = new Schema({ state: { type: String, enum: enum })\n *     const M = db.model('M', s)\n *     const m = new M({ state: 'invalid' })\n *     m.save(function (err) {\n *       console.error(String(err)) // ValidationError: enum validator failed for path `state` with value `invalid`\n *       m.state = 'open'\n *       m.save(callback) // success\n *     })\n *\n * @param {...String|Object} [args] enumeration values\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @see Enums in JavaScript https://masteringjs.io/tutorials/fundamentals/enum\n * @api public\n */\n\nSchemaString.prototype.enum = function() {\n  if (this.enumValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.enumValidator;\n    }, this);\n    this.enumValidator = false;\n  }\n\n  if (arguments[0] === void 0 || arguments[0] === false) {\n    return this;\n  }\n\n  let values;\n  let errorMessage;\n\n  if (utils.isObject(arguments[0])) {\n    if (Array.isArray(arguments[0].values)) {\n      values = arguments[0].values;\n      errorMessage = arguments[0].message;\n    } else {\n      values = utils.object.vals(arguments[0]);\n      errorMessage = MongooseError.messages.String.enum;\n    }\n  } else {\n    values = arguments;\n    errorMessage = MongooseError.messages.String.enum;\n  }\n\n  for (const value of values) {\n    if (value !== undefined) {\n      this.enumValues.push(this.cast(value));\n    }\n  }\n\n  const vals = this.enumValues;\n  this.enumValidator = function(v) {\n    return null == v || ~vals.indexOf(v);\n  };\n  this.validators.push({\n    validator: this.enumValidator,\n    message: errorMessage,\n    type: 'enum',\n    enumValues: vals\n  });\n\n  return this;\n};\n\n/**\n * Adds a lowercase [setter](https://mongoosejs.com/docs/api/schematype.html#SchemaType.prototype.set()).\n *\n * #### Example:\n *\n *     const s = new Schema({ email: { type: String, lowercase: true }})\n *     const M = db.model('M', s);\n *     const m = new M({ email: 'SomeEmail@example.COM' });\n *     console.log(m.email) // someemail@example.com\n *     M.find({ email: 'SomeEmail@example.com' }); // Queries by 'someemail@example.com'\n *\n * Note that `lowercase` does **not** affect regular expression queries:\n *\n * #### Example:\n *\n *     // Still queries for documents whose `email` matches the regular\n *     // expression /SomeEmail/. Mongoose does **not** convert the RegExp\n *     // to lowercase.\n *     M.find({ email: /SomeEmail/ });\n *\n * @api public\n * @return {SchemaType} this\n */\n\nSchemaString.prototype.lowercase = function(shouldApply) {\n  if (arguments.length > 0 && !shouldApply) {\n    return this;\n  }\n  return this.set(v => {\n    if (typeof v !== 'string') {\n      v = this.cast(v);\n    }\n    if (v) {\n      return v.toLowerCase();\n    }\n    return v;\n  });\n};\n\n/**\n * Adds an uppercase [setter](https://mongoosejs.com/docs/api/schematype.html#SchemaType.prototype.set()).\n *\n * #### Example:\n *\n *     const s = new Schema({ caps: { type: String, uppercase: true }})\n *     const M = db.model('M', s);\n *     const m = new M({ caps: 'an example' });\n *     console.log(m.caps) // AN EXAMPLE\n *     M.find({ caps: 'an example' }) // Matches documents where caps = 'AN EXAMPLE'\n *\n * Note that `uppercase` does **not** affect regular expression queries:\n *\n * #### Example:\n *\n *     // Mongoose does **not** convert the RegExp to uppercase.\n *     M.find({ email: /an example/ });\n *\n * @api public\n * @return {SchemaType} this\n */\n\nSchemaString.prototype.uppercase = function(shouldApply) {\n  if (arguments.length > 0 && !shouldApply) {\n    return this;\n  }\n  return this.set(v => {\n    if (typeof v !== 'string') {\n      v = this.cast(v);\n    }\n    if (v) {\n      return v.toUpperCase();\n    }\n    return v;\n  });\n};\n\n/**\n * Adds a trim [setter](https://mongoosejs.com/docs/api/schematype.html#SchemaType.prototype.set()).\n *\n * The string value will be [trimmed](https://masteringjs.io/tutorials/fundamentals/trim-string) when set.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: { type: String, trim: true }});\n *     const M = db.model('M', s);\n *     const string = ' some name ';\n *     console.log(string.length); // 11\n *     const m = new M({ name: string });\n *     console.log(m.name.length); // 9\n *\n *     // Equivalent to `findOne({ name: string.trim() })`\n *     M.findOne({ name: string });\n *\n * Note that `trim` does **not** affect regular expression queries:\n *\n * #### Example:\n *\n *     // Mongoose does **not** trim whitespace from the RegExp.\n *     M.find({ name: / some name / });\n *\n * @api public\n * @return {SchemaType} this\n */\n\nSchemaString.prototype.trim = function(shouldTrim) {\n  if (arguments.length > 0 && !shouldTrim) {\n    return this;\n  }\n  return this.set(v => {\n    if (typeof v !== 'string') {\n      v = this.cast(v);\n    }\n    if (v) {\n      return v.trim();\n    }\n    return v;\n  });\n};\n\n/**\n * Sets a minimum length validator.\n *\n * #### Example:\n *\n *     const schema = new Schema({ postalCode: { type: String, minlength: 5 })\n *     const Address = db.model('Address', schema)\n *     const address = new Address({ postalCode: '9512' })\n *     address.save(function (err) {\n *       console.error(err) // validator error\n *       address.postalCode = '95125';\n *       address.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MINLENGTH} token which will be replaced with the minimum allowed length\n *     const minlength = [5, 'The value of path `{PATH}` (`{VALUE}`) is shorter than the minimum allowed length ({MINLENGTH}).'];\n *     const schema = new Schema({ postalCode: { type: String, minlength: minlength })\n *     const Address = mongoose.model('Address', schema);\n *     const address = new Address({ postalCode: '9512' });\n *     address.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `postalCode` (`9512`) is shorter than the minimum length (5).\n *     })\n *\n * @param {Number} value minimum string length\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaString.prototype.minlength = function(value, message) {\n  if (this.minlengthValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.minlengthValidator;\n    }, this);\n  }\n\n  if (value !== null && value !== undefined) {\n    let msg = message || MongooseError.messages.String.minlength;\n    msg = msg.replace(/{MINLENGTH}/, value);\n    this.validators.push({\n      validator: this.minlengthValidator = function(v) {\n        return v === null || v.length >= value;\n      },\n      message: msg,\n      type: 'minlength',\n      minlength: value\n    });\n  }\n\n  return this;\n};\n\nSchemaString.prototype.minLength = SchemaString.prototype.minlength;\n\n/**\n * Sets a maximum length validator.\n *\n * #### Example:\n *\n *     const schema = new Schema({ postalCode: { type: String, maxlength: 9 })\n *     const Address = db.model('Address', schema)\n *     const address = new Address({ postalCode: '9512512345' })\n *     address.save(function (err) {\n *       console.error(err) // validator error\n *       address.postalCode = '95125';\n *       address.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MAXLENGTH} token which will be replaced with the maximum allowed length\n *     const maxlength = [9, 'The value of path `{PATH}` (`{VALUE}`) exceeds the maximum allowed length ({MAXLENGTH}).'];\n *     const schema = new Schema({ postalCode: { type: String, maxlength: maxlength })\n *     const Address = mongoose.model('Address', schema);\n *     const address = new Address({ postalCode: '9512512345' });\n *     address.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `postalCode` (`9512512345`) exceeds the maximum allowed length (9).\n *     })\n *\n * @param {Number} value maximum string length\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaString.prototype.maxlength = function(value, message) {\n  if (this.maxlengthValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.maxlengthValidator;\n    }, this);\n  }\n\n  if (value !== null && value !== undefined) {\n    let msg = message || MongooseError.messages.String.maxlength;\n    msg = msg.replace(/{MAXLENGTH}/, value);\n    this.validators.push({\n      validator: this.maxlengthValidator = function(v) {\n        return v === null || v.length <= value;\n      },\n      message: msg,\n      type: 'maxlength',\n      maxlength: value\n    });\n  }\n\n  return this;\n};\n\nSchemaString.prototype.maxLength = SchemaString.prototype.maxlength;\n\n/**\n * Sets a regexp validator.\n *\n * Any value that does not pass `regExp`.test(val) will fail validation.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: { type: String, match: /^a/ }})\n *     const M = db.model('M', s)\n *     const m = new M({ name: 'I am invalid' })\n *     m.validate(function (err) {\n *       console.error(String(err)) // \"ValidationError: Path `name` is invalid (I am invalid).\"\n *       m.name = 'apples'\n *       m.validate(function (err) {\n *         assert.ok(err) // success\n *       })\n *     })\n *\n *     // using a custom error message\n *     const match = [ /\\.html$/, \"That file doesn't end in .html ({VALUE})\" ];\n *     const s = new Schema({ file: { type: String, match: match }})\n *     const M = db.model('M', s);\n *     const m = new M({ file: 'invalid' });\n *     m.validate(function (err) {\n *       console.log(String(err)) // \"ValidationError: That file doesn't end in .html (invalid)\"\n *     })\n *\n * Empty strings, `undefined`, and `null` values always pass the match validator. If you require these values, enable the `required` validator also.\n *\n *     const s = new Schema({ name: { type: String, match: /^a/, required: true }})\n *\n * @param {RegExp} regExp regular expression to test against\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaString.prototype.match = function match(regExp, message) {\n  // yes, we allow multiple match validators\n\n  const msg = message || MongooseError.messages.String.match;\n\n  const matchValidator = function(v) {\n    if (!regExp) {\n      return false;\n    }\n\n    // In case RegExp happens to have `/g` flag set, we need to reset the\n    // `lastIndex`, otherwise `match` will intermittently fail.\n    regExp.lastIndex = 0;\n\n    const ret = ((v != null && v !== '')\n      ? regExp.test(v)\n      : true);\n    return ret;\n  };\n\n  this.validators.push({\n    validator: matchValidator,\n    message: msg,\n    type: 'regexp',\n    regexp: regExp\n  });\n  return this;\n};\n\n/**\n * Check if the given value satisfies the `required` validator. The value is\n * considered valid if it is a string (that is, not `null` or `undefined`) and\n * has positive length. The `required` validator **will** fail for empty\n * strings.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaString.prototype.checkRequired = function checkRequired(value, doc) {\n  if (typeof value === 'object' && SchemaType._isRef(this, value, doc, true)) {\n    return value != null;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ?\n    this.constructor.checkRequired() :\n    SchemaString.checkRequired();\n\n  return _checkRequired(value);\n};\n\n/**\n * Casts to String\n *\n * @api private\n */\n\nSchemaString.prototype.cast = function(value, doc, init) {\n  if (typeof value !== 'string' && SchemaType._isRef(this, value, doc, init)) {\n    return this._castRef(value, doc, init);\n  }\n\n  let castString;\n  if (typeof this._castFunction === 'function') {\n    castString = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castString = this.constructor.cast();\n  } else {\n    castString = SchemaString.cast();\n  }\n\n  try {\n    return castString(value);\n  } catch (error) {\n    throw new CastError('string', value, this.path, null, this);\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val, context) {\n  return this.castForQuery(null, val, context);\n}\n\n/*!\n * ignore\n */\n\nfunction handleArray(val, context) {\n  const _this = this;\n  if (!Array.isArray(val)) {\n    return [this.castForQuery(null, val, context)];\n  }\n  return val.map(function(m) {\n    return _this.castForQuery(null, m, context);\n  });\n}\n\n/*!\n * ignore\n */\n\nfunction handleSingleNoSetters(val) {\n  if (val == null) {\n    return this._castNullish(val);\n  }\n\n  return this.cast(val, this);\n}\n\nconst $conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers,\n  $all: handleArray,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $lt: handleSingle,\n  $lte: handleSingle,\n  $options: handleSingleNoSetters,\n  $regex: function handle$regex(val) {\n    if (Object.prototype.toString.call(val) === '[object RegExp]') {\n      return val;\n    }\n\n    return handleSingleNoSetters.call(this, val);\n  },\n  $not: handleSingle\n};\n\nObject.defineProperty(SchemaString.prototype, '$conditionalHandlers', {\n  configurable: false,\n  enumerable: false,\n  writable: false,\n  value: Object.freeze($conditionalHandlers)\n});\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [val]\n * @api private\n */\n\nSchemaString.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with String.');\n    }\n    return handler.call(this, val, context);\n  }\n\n  if (Object.prototype.toString.call(val) === '[object RegExp]' || isBsonType(val, 'BSONRegExp')) {\n    return val;\n  }\n\n  try {\n    return this.applySetters(val, context);\n  } catch (err) {\n    if (err instanceof CastError && err.path === this.path && this.$fullPath != null) {\n      err.path = this.$fullPath;\n    }\n    throw err;\n  }\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaString;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9zdHJpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixtQkFBTyxDQUFDLHlFQUFlO0FBQzFDLHNCQUFzQixtQkFBTyxDQUFDLDJFQUFnQjtBQUM5Qyw0QkFBNEIsbUJBQU8sQ0FBQywyR0FBZ0M7QUFDcEUsbUJBQW1CLG1CQUFPLENBQUMsMkVBQWdCO0FBQzNDLGNBQWMsbUJBQU8sQ0FBQywrREFBVTtBQUNoQyxtQkFBbUIsbUJBQU8sQ0FBQyx5RkFBdUI7O0FBRWxEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGNBQWM7QUFDdkUsbUJBQW1CLGFBQWEsUUFBUTtBQUN4QztBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FB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Q0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL3N0cmluZy5qcz8xZWUxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbmNvbnN0IFNjaGVtYVR5cGUgPSByZXF1aXJlKCcuLi9zY2hlbWFUeXBlJyk7XG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvaW5kZXgnKTtcbmNvbnN0IFNjaGVtYVN0cmluZ09wdGlvbnMgPSByZXF1aXJlKCcuLi9vcHRpb25zL3NjaGVtYVN0cmluZ09wdGlvbnMnKTtcbmNvbnN0IGNhc3RTdHJpbmcgPSByZXF1aXJlKCcuLi9jYXN0L3N0cmluZycpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuY29uc3QgaXNCc29uVHlwZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvaXNCc29uVHlwZScpO1xuXG5jb25zdCBDYXN0RXJyb3IgPSBTY2hlbWFUeXBlLkNhc3RFcnJvcjtcblxuLyoqXG4gKiBTdHJpbmcgU2NoZW1hVHlwZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGluaGVyaXRzIFNjaGVtYVR5cGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU2NoZW1hU3RyaW5nKGtleSwgb3B0aW9ucykge1xuICB0aGlzLmVudW1WYWx1ZXMgPSBbXTtcbiAgdGhpcy5yZWdFeHAgPSBudWxsO1xuICBTY2hlbWFUeXBlLmNhbGwodGhpcywga2V5LCBvcHRpb25zLCAnU3RyaW5nJyk7XG59XG5cbi8qKlxuICogVGhpcyBzY2hlbWEgdHlwZSdzIG5hbWUsIHRvIGRlZmVuZCBhZ2FpbnN0IG1pbmlmaWVycyB0aGF0IG1hbmdsZVxuICogZnVuY3Rpb24gbmFtZXMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuU2NoZW1hU3RyaW5nLnNjaGVtYU5hbWUgPSAnU3RyaW5nJztcblxuU2NoZW1hU3RyaW5nLmRlZmF1bHRPcHRpb25zID0ge307XG5cbi8qIVxuICogSW5oZXJpdHMgZnJvbSBTY2hlbWFUeXBlLlxuICovXG5TY2hlbWFTdHJpbmcucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTY2hlbWFUeXBlLnByb3RvdHlwZSk7XG5TY2hlbWFTdHJpbmcucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2NoZW1hU3RyaW5nO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVN0cmluZy5wcm90b3R5cGUsICdPcHRpb25zQ29uc3RydWN0b3InLCB7XG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICB3cml0YWJsZTogZmFsc2UsXG4gIHZhbHVlOiBTY2hlbWFTdHJpbmdPcHRpb25zXG59KTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFTdHJpbmcuX2Nhc3QgPSBjYXN0U3RyaW5nO1xuXG4vKipcbiAqIEdldC9zZXQgdGhlIGZ1bmN0aW9uIHVzZWQgdG8gY2FzdCBhcmJpdHJhcnkgdmFsdWVzIHRvIHN0cmluZ3MuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBUaHJvdyBhbiBlcnJvciBpZiB5b3UgcGFzcyBpbiBhbiBvYmplY3QuIE5vcm1hbGx5LCBNb25nb29zZSBhbGxvd3NcbiAqICAgICAvLyBvYmplY3RzIHdpdGggY3VzdG9tIGB0b1N0cmluZygpYCBmdW5jdGlvbnMuXG4gKiAgICAgY29uc3Qgb3JpZ2luYWwgPSBtb25nb29zZS5TY2hlbWEuVHlwZXMuU3RyaW5nLmNhc3QoKTtcbiAqICAgICBtb25nb29zZS5TY2hlbWEuVHlwZXMuU3RyaW5nLmNhc3QodiA9PiB7XG4gKiAgICAgICBhc3NlcnQub2sodiA9PSBudWxsIHx8IHR5cGVvZiB2ICE9PSAnb2JqZWN0Jyk7XG4gKiAgICAgICByZXR1cm4gb3JpZ2luYWwodik7XG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vIE9yIGRpc2FibGUgY2FzdGluZyBlbnRpcmVseVxuICogICAgIG1vbmdvb3NlLlNjaGVtYS5UeXBlcy5TdHJpbmcuY2FzdChmYWxzZSk7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FzdGVyXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBmdW5jdGlvbiBnZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hU3RyaW5nLmNhc3QgPSBmdW5jdGlvbiBjYXN0KGNhc3Rlcikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzLl9jYXN0O1xuICB9XG4gIGlmIChjYXN0ZXIgPT09IGZhbHNlKSB7XG4gICAgY2FzdGVyID0gdGhpcy5fZGVmYXVsdENhc3RlcjtcbiAgfVxuICB0aGlzLl9jYXN0ID0gY2FzdGVyO1xuXG4gIHJldHVybiB0aGlzLl9jYXN0O1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFTdHJpbmcuX2RlZmF1bHRDYXN0ZXIgPSB2ID0+IHtcbiAgaWYgKHYgIT0gbnVsbCAmJiB0eXBlb2YgdiAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgfVxuICByZXR1cm4gdjtcbn07XG5cbi8qKlxuICogQXR0YWNoZXMgYSBnZXR0ZXIgZm9yIGFsbCBTdHJpbmcgaW5zdGFuY2VzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTWFrZSBhbGwgbnVtYmVycyByb3VuZCBkb3duXG4gKiAgICAgbW9uZ29vc2UuU2NoZW1hLlN0cmluZy5nZXQodiA9PiB2LnRvTG93ZXJDYXNlKCkpO1xuICpcbiAqICAgICBjb25zdCBNb2RlbCA9IG1vbmdvb3NlLm1vZGVsKCdUZXN0JywgbmV3IFNjaGVtYSh7IHRlc3Q6IFN0cmluZyB9KSk7XG4gKiAgICAgbmV3IE1vZGVsKHsgdGVzdDogJ0ZPTycgfSkudGVzdDsgLy8gJ2ZvbydcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAqIEByZXR1cm4ge3RoaXN9XG4gKiBAZnVuY3Rpb24gZ2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVN0cmluZy5nZXQgPSBTY2hlbWFUeXBlLmdldDtcblxuLyoqXG4gKiBTZXRzIGEgZGVmYXVsdCBvcHRpb24gZm9yIGFsbCBTdHJpbmcgaW5zdGFuY2VzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTWFrZSBhbGwgc3RyaW5ncyBoYXZlIG9wdGlvbiBgdHJpbWAgZXF1YWwgdG8gdHJ1ZS5cbiAqICAgICBtb25nb29zZS5TY2hlbWEuU3RyaW5nLnNldCgndHJpbScsIHRydWUpO1xuICpcbiAqICAgICBjb25zdCBVc2VyID0gbW9uZ29vc2UubW9kZWwoJ1VzZXInLCBuZXcgU2NoZW1hKHsgbmFtZTogU3RyaW5nIH0pKTtcbiAqICAgICBuZXcgVXNlcih7IG5hbWU6ICcgICBKb2huIERvZSAgICcgfSkubmFtZTsgLy8gJ0pvaG4gRG9lJ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb24gVGhlIG9wdGlvbiB5b3UnZCBsaWtlIHRvIHNldCB0aGUgdmFsdWUgZm9yXG4gKiBAcGFyYW0ge0FueX0gdmFsdWUgdmFsdWUgZm9yIG9wdGlvblxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICogQGZ1bmN0aW9uIHNldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFTdHJpbmcuc2V0ID0gU2NoZW1hVHlwZS5zZXQ7XG5cblNjaGVtYVN0cmluZy5zZXR0ZXJzID0gW107XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hU3RyaW5nLl9jaGVja1JlcXVpcmVkID0gdiA9PiAodiBpbnN0YW5jZW9mIFN0cmluZyB8fCB0eXBlb2YgdiA9PT0gJ3N0cmluZycpICYmIHYubGVuZ3RoO1xuXG4vKipcbiAqIE92ZXJyaWRlIHRoZSBmdW5jdGlvbiB0aGUgcmVxdWlyZWQgdmFsaWRhdG9yIHVzZXMgdG8gY2hlY2sgd2hldGhlciBhIHN0cmluZ1xuICogcGFzc2VzIHRoZSBgcmVxdWlyZWRgIGNoZWNrLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gQWxsb3cgZW1wdHkgc3RyaW5ncyB0byBwYXNzIGByZXF1aXJlZGAgY2hlY2tcbiAqICAgICBtb25nb29zZS5TY2hlbWEuVHlwZXMuU3RyaW5nLmNoZWNrUmVxdWlyZWQodiA9PiB2ICE9IG51bGwpO1xuICpcbiAqICAgICBjb25zdCBNID0gbW9uZ29vc2UubW9kZWwoeyBzdHI6IHsgdHlwZTogU3RyaW5nLCByZXF1aXJlZDogdHJ1ZSB9IH0pO1xuICogICAgIG5ldyBNKHsgc3RyOiAnJyB9KS52YWxpZGF0ZVN5bmMoKTsgLy8gYG51bGxgLCB2YWxpZGF0aW9uIHBhc3NlcyFcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAZnVuY3Rpb24gY2hlY2tSZXF1aXJlZFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFTdHJpbmcuY2hlY2tSZXF1aXJlZCA9IFNjaGVtYVR5cGUuY2hlY2tSZXF1aXJlZDtcblxuLyoqXG4gKiBBZGRzIGFuIGVudW0gdmFsaWRhdG9yXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzdGF0ZXMgPSBbJ29wZW5pbmcnLCAnb3BlbicsICdjbG9zaW5nJywgJ2Nsb3NlZCddXG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoeyBzdGF0ZTogeyB0eXBlOiBTdHJpbmcsIGVudW06IHN0YXRlcyB9fSlcbiAqICAgICBjb25zdCBNID0gZGIubW9kZWwoJ00nLCBzKVxuICogICAgIGNvbnN0IG0gPSBuZXcgTSh7IHN0YXRlOiAnaW52YWxpZCcgfSlcbiAqICAgICBtLnNhdmUoZnVuY3Rpb24gKGVycikge1xuICogICAgICAgY29uc29sZS5lcnJvcihTdHJpbmcoZXJyKSkgLy8gVmFsaWRhdGlvbkVycm9yOiBgaW52YWxpZGAgaXMgbm90IGEgdmFsaWQgZW51bSB2YWx1ZSBmb3IgcGF0aCBgc3RhdGVgLlxuICogICAgICAgbS5zdGF0ZSA9ICdvcGVuJ1xuICogICAgICAgbS5zYXZlKGNhbGxiYWNrKSAvLyBzdWNjZXNzXG4gKiAgICAgfSlcbiAqXG4gKiAgICAgLy8gb3Igd2l0aCBjdXN0b20gZXJyb3IgbWVzc2FnZXNcbiAqICAgICBjb25zdCBlbnVtID0ge1xuICogICAgICAgdmFsdWVzOiBbJ29wZW5pbmcnLCAnb3BlbicsICdjbG9zaW5nJywgJ2Nsb3NlZCddLFxuICogICAgICAgbWVzc2FnZTogJ2VudW0gdmFsaWRhdG9yIGZhaWxlZCBmb3IgcGF0aCBge1BBVEh9YCB3aXRoIHZhbHVlIGB7VkFMVUV9YCdcbiAqICAgICB9XG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoeyBzdGF0ZTogeyB0eXBlOiBTdHJpbmcsIGVudW06IGVudW0gfSlcbiAqICAgICBjb25zdCBNID0gZGIubW9kZWwoJ00nLCBzKVxuICogICAgIGNvbnN0IG0gPSBuZXcgTSh7IHN0YXRlOiAnaW52YWxpZCcgfSlcbiAqICAgICBtLnNhdmUoZnVuY3Rpb24gKGVycikge1xuICogICAgICAgY29uc29sZS5lcnJvcihTdHJpbmcoZXJyKSkgLy8gVmFsaWRhdGlvbkVycm9yOiBlbnVtIHZhbGlkYXRvciBmYWlsZWQgZm9yIHBhdGggYHN0YXRlYCB3aXRoIHZhbHVlIGBpbnZhbGlkYFxuICogICAgICAgbS5zdGF0ZSA9ICdvcGVuJ1xuICogICAgICAgbS5zYXZlKGNhbGxiYWNrKSAvLyBzdWNjZXNzXG4gKiAgICAgfSlcbiAqXG4gKiBAcGFyYW0gey4uLlN0cmluZ3xPYmplY3R9IFthcmdzXSBlbnVtZXJhdGlvbiB2YWx1ZXNcbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IHRoaXNcbiAqIEBzZWUgQ3VzdG9taXplZCBFcnJvciBNZXNzYWdlcyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2Vycm9yLmh0bWwjRXJyb3IubWVzc2FnZXNcbiAqIEBzZWUgRW51bXMgaW4gSmF2YVNjcmlwdCBodHRwczovL21hc3RlcmluZ2pzLmlvL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvZW51bVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFTdHJpbmcucHJvdG90eXBlLmVudW0gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuZW51bVZhbGlkYXRvcikge1xuICAgIHRoaXMudmFsaWRhdG9ycyA9IHRoaXMudmFsaWRhdG9ycy5maWx0ZXIoZnVuY3Rpb24odikge1xuICAgICAgcmV0dXJuIHYudmFsaWRhdG9yICE9PSB0aGlzLmVudW1WYWxpZGF0b3I7XG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5lbnVtVmFsaWRhdG9yID0gZmFsc2U7XG4gIH1cblxuICBpZiAoYXJndW1lbnRzWzBdID09PSB2b2lkIDAgfHwgYXJndW1lbnRzWzBdID09PSBmYWxzZSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGV0IHZhbHVlcztcbiAgbGV0IGVycm9yTWVzc2FnZTtcblxuICBpZiAodXRpbHMuaXNPYmplY3QoYXJndW1lbnRzWzBdKSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXS52YWx1ZXMpKSB7XG4gICAgICB2YWx1ZXMgPSBhcmd1bWVudHNbMF0udmFsdWVzO1xuICAgICAgZXJyb3JNZXNzYWdlID0gYXJndW1lbnRzWzBdLm1lc3NhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlcyA9IHV0aWxzLm9iamVjdC52YWxzKGFyZ3VtZW50c1swXSk7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBNb25nb29zZUVycm9yLm1lc3NhZ2VzLlN0cmluZy5lbnVtO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZXMgPSBhcmd1bWVudHM7XG4gICAgZXJyb3JNZXNzYWdlID0gTW9uZ29vc2VFcnJvci5tZXNzYWdlcy5TdHJpbmcuZW51bTtcbiAgfVxuXG4gIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZW51bVZhbHVlcy5wdXNoKHRoaXMuY2FzdCh2YWx1ZSkpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHZhbHMgPSB0aGlzLmVudW1WYWx1ZXM7XG4gIHRoaXMuZW51bVZhbGlkYXRvciA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gbnVsbCA9PSB2IHx8IH52YWxzLmluZGV4T2Yodik7XG4gIH07XG4gIHRoaXMudmFsaWRhdG9ycy5wdXNoKHtcbiAgICB2YWxpZGF0b3I6IHRoaXMuZW51bVZhbGlkYXRvcixcbiAgICBtZXNzYWdlOiBlcnJvck1lc3NhZ2UsXG4gICAgdHlwZTogJ2VudW0nLFxuICAgIGVudW1WYWx1ZXM6IHZhbHNcbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBsb3dlcmNhc2UgW3NldHRlcl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9zY2hlbWF0eXBlLmh0bWwjU2NoZW1hVHlwZS5wcm90b3R5cGUuc2V0KCkpLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoeyBlbWFpbDogeyB0eXBlOiBTdHJpbmcsIGxvd2VyY2FzZTogdHJ1ZSB9fSlcbiAqICAgICBjb25zdCBNID0gZGIubW9kZWwoJ00nLCBzKTtcbiAqICAgICBjb25zdCBtID0gbmV3IE0oeyBlbWFpbDogJ1NvbWVFbWFpbEBleGFtcGxlLkNPTScgfSk7XG4gKiAgICAgY29uc29sZS5sb2cobS5lbWFpbCkgLy8gc29tZWVtYWlsQGV4YW1wbGUuY29tXG4gKiAgICAgTS5maW5kKHsgZW1haWw6ICdTb21lRW1haWxAZXhhbXBsZS5jb20nIH0pOyAvLyBRdWVyaWVzIGJ5ICdzb21lZW1haWxAZXhhbXBsZS5jb20nXG4gKlxuICogTm90ZSB0aGF0IGBsb3dlcmNhc2VgIGRvZXMgKipub3QqKiBhZmZlY3QgcmVndWxhciBleHByZXNzaW9uIHF1ZXJpZXM6XG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBTdGlsbCBxdWVyaWVzIGZvciBkb2N1bWVudHMgd2hvc2UgYGVtYWlsYCBtYXRjaGVzIHRoZSByZWd1bGFyXG4gKiAgICAgLy8gZXhwcmVzc2lvbiAvU29tZUVtYWlsLy4gTW9uZ29vc2UgZG9lcyAqKm5vdCoqIGNvbnZlcnQgdGhlIFJlZ0V4cFxuICogICAgIC8vIHRvIGxvd2VyY2FzZS5cbiAqICAgICBNLmZpbmQoeyBlbWFpbDogL1NvbWVFbWFpbC8gfSk7XG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IHRoaXNcbiAqL1xuXG5TY2hlbWFTdHJpbmcucHJvdG90eXBlLmxvd2VyY2FzZSA9IGZ1bmN0aW9uKHNob3VsZEFwcGx5KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCAmJiAhc2hvdWxkQXBwbHkpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZXR1cm4gdGhpcy5zZXQodiA9PiB7XG4gICAgaWYgKHR5cGVvZiB2ICE9PSAnc3RyaW5nJykge1xuICAgICAgdiA9IHRoaXMuY2FzdCh2KTtcbiAgICB9XG4gICAgaWYgKHYpIHtcbiAgICAgIHJldHVybiB2LnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIHJldHVybiB2O1xuICB9KTtcbn07XG5cbi8qKlxuICogQWRkcyBhbiB1cHBlcmNhc2UgW3NldHRlcl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9zY2hlbWF0eXBlLmh0bWwjU2NoZW1hVHlwZS5wcm90b3R5cGUuc2V0KCkpLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoeyBjYXBzOiB7IHR5cGU6IFN0cmluZywgdXBwZXJjYXNlOiB0cnVlIH19KVxuICogICAgIGNvbnN0IE0gPSBkYi5tb2RlbCgnTScsIHMpO1xuICogICAgIGNvbnN0IG0gPSBuZXcgTSh7IGNhcHM6ICdhbiBleGFtcGxlJyB9KTtcbiAqICAgICBjb25zb2xlLmxvZyhtLmNhcHMpIC8vIEFOIEVYQU1QTEVcbiAqICAgICBNLmZpbmQoeyBjYXBzOiAnYW4gZXhhbXBsZScgfSkgLy8gTWF0Y2hlcyBkb2N1bWVudHMgd2hlcmUgY2FwcyA9ICdBTiBFWEFNUExFJ1xuICpcbiAqIE5vdGUgdGhhdCBgdXBwZXJjYXNlYCBkb2VzICoqbm90KiogYWZmZWN0IHJlZ3VsYXIgZXhwcmVzc2lvbiBxdWVyaWVzOlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTW9uZ29vc2UgZG9lcyAqKm5vdCoqIGNvbnZlcnQgdGhlIFJlZ0V4cCB0byB1cHBlcmNhc2UuXG4gKiAgICAgTS5maW5kKHsgZW1haWw6IC9hbiBleGFtcGxlLyB9KTtcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICovXG5cblNjaGVtYVN0cmluZy5wcm90b3R5cGUudXBwZXJjYXNlID0gZnVuY3Rpb24oc2hvdWxkQXBwbHkpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwICYmICFzaG91bGRBcHBseSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJldHVybiB0aGlzLnNldCh2ID0+IHtcbiAgICBpZiAodHlwZW9mIHYgIT09ICdzdHJpbmcnKSB7XG4gICAgICB2ID0gdGhpcy5jYXN0KHYpO1xuICAgIH1cbiAgICBpZiAodikge1xuICAgICAgcmV0dXJuIHYudG9VcHBlckNhc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgdHJpbSBbc2V0dGVyXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL3NjaGVtYXR5cGUuaHRtbCNTY2hlbWFUeXBlLnByb3RvdHlwZS5zZXQoKSkuXG4gKlxuICogVGhlIHN0cmluZyB2YWx1ZSB3aWxsIGJlIFt0cmltbWVkXShodHRwczovL21hc3RlcmluZ2pzLmlvL3R1dG9yaWFscy9mdW5kYW1lbnRhbHMvdHJpbS1zdHJpbmcpIHdoZW4gc2V0LlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgcyA9IG5ldyBTY2hlbWEoeyBuYW1lOiB7IHR5cGU6IFN0cmluZywgdHJpbTogdHJ1ZSB9fSk7XG4gKiAgICAgY29uc3QgTSA9IGRiLm1vZGVsKCdNJywgcyk7XG4gKiAgICAgY29uc3Qgc3RyaW5nID0gJyBzb21lIG5hbWUgJztcbiAqICAgICBjb25zb2xlLmxvZyhzdHJpbmcubGVuZ3RoKTsgLy8gMTFcbiAqICAgICBjb25zdCBtID0gbmV3IE0oeyBuYW1lOiBzdHJpbmcgfSk7XG4gKiAgICAgY29uc29sZS5sb2cobS5uYW1lLmxlbmd0aCk7IC8vIDlcbiAqXG4gKiAgICAgLy8gRXF1aXZhbGVudCB0byBgZmluZE9uZSh7IG5hbWU6IHN0cmluZy50cmltKCkgfSlgXG4gKiAgICAgTS5maW5kT25lKHsgbmFtZTogc3RyaW5nIH0pO1xuICpcbiAqIE5vdGUgdGhhdCBgdHJpbWAgZG9lcyAqKm5vdCoqIGFmZmVjdCByZWd1bGFyIGV4cHJlc3Npb24gcXVlcmllczpcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1vbmdvb3NlIGRvZXMgKipub3QqKiB0cmltIHdoaXRlc3BhY2UgZnJvbSB0aGUgUmVnRXhwLlxuICogICAgIE0uZmluZCh7IG5hbWU6IC8gc29tZSBuYW1lIC8gfSk7XG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEByZXR1cm4ge1NjaGVtYVR5cGV9IHRoaXNcbiAqL1xuXG5TY2hlbWFTdHJpbmcucHJvdG90eXBlLnRyaW0gPSBmdW5jdGlvbihzaG91bGRUcmltKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCAmJiAhc2hvdWxkVHJpbSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJldHVybiB0aGlzLnNldCh2ID0+IHtcbiAgICBpZiAodHlwZW9mIHYgIT09ICdzdHJpbmcnKSB7XG4gICAgICB2ID0gdGhpcy5jYXN0KHYpO1xuICAgIH1cbiAgICBpZiAodikge1xuICAgICAgcmV0dXJuIHYudHJpbSgpO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFNldHMgYSBtaW5pbXVtIGxlbmd0aCB2YWxpZGF0b3IuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgcG9zdGFsQ29kZTogeyB0eXBlOiBTdHJpbmcsIG1pbmxlbmd0aDogNSB9KVxuICogICAgIGNvbnN0IEFkZHJlc3MgPSBkYi5tb2RlbCgnQWRkcmVzcycsIHNjaGVtYSlcbiAqICAgICBjb25zdCBhZGRyZXNzID0gbmV3IEFkZHJlc3MoeyBwb3N0YWxDb2RlOiAnOTUxMicgfSlcbiAqICAgICBhZGRyZXNzLnNhdmUoZnVuY3Rpb24gKGVycikge1xuICogICAgICAgY29uc29sZS5lcnJvcihlcnIpIC8vIHZhbGlkYXRvciBlcnJvclxuICogICAgICAgYWRkcmVzcy5wb3N0YWxDb2RlID0gJzk1MTI1JztcbiAqICAgICAgIGFkZHJlc3Muc2F2ZSgpIC8vIHN1Y2Nlc3NcbiAqICAgICB9KVxuICpcbiAqICAgICAvLyBjdXN0b20gZXJyb3IgbWVzc2FnZXNcbiAqICAgICAvLyBXZSBjYW4gYWxzbyB1c2UgdGhlIHNwZWNpYWwge01JTkxFTkdUSH0gdG9rZW4gd2hpY2ggd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoZSBtaW5pbXVtIGFsbG93ZWQgbGVuZ3RoXG4gKiAgICAgY29uc3QgbWlubGVuZ3RoID0gWzUsICdUaGUgdmFsdWUgb2YgcGF0aCBge1BBVEh9YCAoYHtWQUxVRX1gKSBpcyBzaG9ydGVyIHRoYW4gdGhlIG1pbmltdW0gYWxsb3dlZCBsZW5ndGggKHtNSU5MRU5HVEh9KS4nXTtcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgcG9zdGFsQ29kZTogeyB0eXBlOiBTdHJpbmcsIG1pbmxlbmd0aDogbWlubGVuZ3RoIH0pXG4gKiAgICAgY29uc3QgQWRkcmVzcyA9IG1vbmdvb3NlLm1vZGVsKCdBZGRyZXNzJywgc2NoZW1hKTtcbiAqICAgICBjb25zdCBhZGRyZXNzID0gbmV3IEFkZHJlc3MoeyBwb3N0YWxDb2RlOiAnOTUxMicgfSk7XG4gKiAgICAgYWRkcmVzcy52YWxpZGF0ZShmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyhTdHJpbmcoZXJyKSkgLy8gVmFsaWRhdGlvbkVycm9yOiBUaGUgdmFsdWUgb2YgcGF0aCBgcG9zdGFsQ29kZWAgKGA5NTEyYCkgaXMgc2hvcnRlciB0aGFuIHRoZSBtaW5pbXVtIGxlbmd0aCAoNSkuXG4gKiAgICAgfSlcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgbWluaW11bSBzdHJpbmcgbGVuZ3RoXG4gKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdIG9wdGlvbmFsIGN1c3RvbSBlcnJvciBtZXNzYWdlXG4gKiBAcmV0dXJuIHtTY2hlbWFUeXBlfSB0aGlzXG4gKiBAc2VlIEN1c3RvbWl6ZWQgRXJyb3IgTWVzc2FnZXMgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9lcnJvci5odG1sI0Vycm9yLm1lc3NhZ2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVN0cmluZy5wcm90b3R5cGUubWlubGVuZ3RoID0gZnVuY3Rpb24odmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKHRoaXMubWlubGVuZ3RoVmFsaWRhdG9yKSB7XG4gICAgdGhpcy52YWxpZGF0b3JzID0gdGhpcy52YWxpZGF0b3JzLmZpbHRlcihmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gdi52YWxpZGF0b3IgIT09IHRoaXMubWlubGVuZ3RoVmFsaWRhdG9yO1xuICAgIH0sIHRoaXMpO1xuICB9XG5cbiAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBsZXQgbXNnID0gbWVzc2FnZSB8fCBNb25nb29zZUVycm9yLm1lc3NhZ2VzLlN0cmluZy5taW5sZW5ndGg7XG4gICAgbXNnID0gbXNnLnJlcGxhY2UoL3tNSU5MRU5HVEh9LywgdmFsdWUpO1xuICAgIHRoaXMudmFsaWRhdG9ycy5wdXNoKHtcbiAgICAgIHZhbGlkYXRvcjogdGhpcy5taW5sZW5ndGhWYWxpZGF0b3IgPSBmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiB2ID09PSBudWxsIHx8IHYubGVuZ3RoID49IHZhbHVlO1xuICAgICAgfSxcbiAgICAgIG1lc3NhZ2U6IG1zZyxcbiAgICAgIHR5cGU6ICdtaW5sZW5ndGgnLFxuICAgICAgbWlubGVuZ3RoOiB2YWx1ZVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5TY2hlbWFTdHJpbmcucHJvdG90eXBlLm1pbkxlbmd0aCA9IFNjaGVtYVN0cmluZy5wcm90b3R5cGUubWlubGVuZ3RoO1xuXG4vKipcbiAqIFNldHMgYSBtYXhpbXVtIGxlbmd0aCB2YWxpZGF0b3IuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHsgcG9zdGFsQ29kZTogeyB0eXBlOiBTdHJpbmcsIG1heGxlbmd0aDogOSB9KVxuICogICAgIGNvbnN0IEFkZHJlc3MgPSBkYi5tb2RlbCgnQWRkcmVzcycsIHNjaGVtYSlcbiAqICAgICBjb25zdCBhZGRyZXNzID0gbmV3IEFkZHJlc3MoeyBwb3N0YWxDb2RlOiAnOTUxMjUxMjM0NScgfSlcbiAqICAgICBhZGRyZXNzLnNhdmUoZnVuY3Rpb24gKGVycikge1xuICogICAgICAgY29uc29sZS5lcnJvcihlcnIpIC8vIHZhbGlkYXRvciBlcnJvclxuICogICAgICAgYWRkcmVzcy5wb3N0YWxDb2RlID0gJzk1MTI1JztcbiAqICAgICAgIGFkZHJlc3Muc2F2ZSgpIC8vIHN1Y2Nlc3NcbiAqICAgICB9KVxuICpcbiAqICAgICAvLyBjdXN0b20gZXJyb3IgbWVzc2FnZXNcbiAqICAgICAvLyBXZSBjYW4gYWxzbyB1c2UgdGhlIHNwZWNpYWwge01BWExFTkdUSH0gdG9rZW4gd2hpY2ggd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoZSBtYXhpbXVtIGFsbG93ZWQgbGVuZ3RoXG4gKiAgICAgY29uc3QgbWF4bGVuZ3RoID0gWzksICdUaGUgdmFsdWUgb2YgcGF0aCBge1BBVEh9YCAoYHtWQUxVRX1gKSBleGNlZWRzIHRoZSBtYXhpbXVtIGFsbG93ZWQgbGVuZ3RoICh7TUFYTEVOR1RIfSkuJ107XG4gKiAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYSh7IHBvc3RhbENvZGU6IHsgdHlwZTogU3RyaW5nLCBtYXhsZW5ndGg6IG1heGxlbmd0aCB9KVxuICogICAgIGNvbnN0IEFkZHJlc3MgPSBtb25nb29zZS5tb2RlbCgnQWRkcmVzcycsIHNjaGVtYSk7XG4gKiAgICAgY29uc3QgYWRkcmVzcyA9IG5ldyBBZGRyZXNzKHsgcG9zdGFsQ29kZTogJzk1MTI1MTIzNDUnIH0pO1xuICogICAgIGFkZHJlc3MudmFsaWRhdGUoZnVuY3Rpb24gKGVycikge1xuICogICAgICAgY29uc29sZS5sb2coU3RyaW5nKGVycikpIC8vIFZhbGlkYXRpb25FcnJvcjogVGhlIHZhbHVlIG9mIHBhdGggYHBvc3RhbENvZGVgIChgOTUxMjUxMjM0NWApIGV4Y2VlZHMgdGhlIG1heGltdW0gYWxsb3dlZCBsZW5ndGggKDkpLlxuICogICAgIH0pXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIG1heGltdW0gc3RyaW5nIGxlbmd0aFxuICogQHBhcmFtIHtTdHJpbmd9IFttZXNzYWdlXSBvcHRpb25hbCBjdXN0b20gZXJyb3IgbWVzc2FnZVxuICogQHJldHVybiB7U2NoZW1hVHlwZX0gdGhpc1xuICogQHNlZSBDdXN0b21pemVkIEVycm9yIE1lc3NhZ2VzIGh0dHBzOi8vbW9uZ29vc2Vqcy5jb20vZG9jcy9hcGkvZXJyb3IuaHRtbCNFcnJvci5tZXNzYWdlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFTdHJpbmcucHJvdG90eXBlLm1heGxlbmd0aCA9IGZ1bmN0aW9uKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICh0aGlzLm1heGxlbmd0aFZhbGlkYXRvcikge1xuICAgIHRoaXMudmFsaWRhdG9ycyA9IHRoaXMudmFsaWRhdG9ycy5maWx0ZXIoZnVuY3Rpb24odikge1xuICAgICAgcmV0dXJuIHYudmFsaWRhdG9yICE9PSB0aGlzLm1heGxlbmd0aFZhbGlkYXRvcjtcbiAgICB9LCB0aGlzKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbGV0IG1zZyA9IG1lc3NhZ2UgfHwgTW9uZ29vc2VFcnJvci5tZXNzYWdlcy5TdHJpbmcubWF4bGVuZ3RoO1xuICAgIG1zZyA9IG1zZy5yZXBsYWNlKC97TUFYTEVOR1RIfS8sIHZhbHVlKTtcbiAgICB0aGlzLnZhbGlkYXRvcnMucHVzaCh7XG4gICAgICB2YWxpZGF0b3I6IHRoaXMubWF4bGVuZ3RoVmFsaWRhdG9yID0gZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gdiA9PT0gbnVsbCB8fCB2Lmxlbmd0aCA8PSB2YWx1ZTtcbiAgICAgIH0sXG4gICAgICBtZXNzYWdlOiBtc2csXG4gICAgICB0eXBlOiAnbWF4bGVuZ3RoJyxcbiAgICAgIG1heGxlbmd0aDogdmFsdWVcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuU2NoZW1hU3RyaW5nLnByb3RvdHlwZS5tYXhMZW5ndGggPSBTY2hlbWFTdHJpbmcucHJvdG90eXBlLm1heGxlbmd0aDtcblxuLyoqXG4gKiBTZXRzIGEgcmVnZXhwIHZhbGlkYXRvci5cbiAqXG4gKiBBbnkgdmFsdWUgdGhhdCBkb2VzIG5vdCBwYXNzIGByZWdFeHBgLnRlc3QodmFsKSB3aWxsIGZhaWwgdmFsaWRhdGlvbi5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgbmFtZTogeyB0eXBlOiBTdHJpbmcsIG1hdGNoOiAvXmEvIH19KVxuICogICAgIGNvbnN0IE0gPSBkYi5tb2RlbCgnTScsIHMpXG4gKiAgICAgY29uc3QgbSA9IG5ldyBNKHsgbmFtZTogJ0kgYW0gaW52YWxpZCcgfSlcbiAqICAgICBtLnZhbGlkYXRlKGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICAgIGNvbnNvbGUuZXJyb3IoU3RyaW5nKGVycikpIC8vIFwiVmFsaWRhdGlvbkVycm9yOiBQYXRoIGBuYW1lYCBpcyBpbnZhbGlkIChJIGFtIGludmFsaWQpLlwiXG4gKiAgICAgICBtLm5hbWUgPSAnYXBwbGVzJ1xuICogICAgICAgbS52YWxpZGF0ZShmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgICAgIGFzc2VydC5vayhlcnIpIC8vIHN1Y2Nlc3NcbiAqICAgICAgIH0pXG4gKiAgICAgfSlcbiAqXG4gKiAgICAgLy8gdXNpbmcgYSBjdXN0b20gZXJyb3IgbWVzc2FnZVxuICogICAgIGNvbnN0IG1hdGNoID0gWyAvXFwuaHRtbCQvLCBcIlRoYXQgZmlsZSBkb2Vzbid0IGVuZCBpbiAuaHRtbCAoe1ZBTFVFfSlcIiBdO1xuICogICAgIGNvbnN0IHMgPSBuZXcgU2NoZW1hKHsgZmlsZTogeyB0eXBlOiBTdHJpbmcsIG1hdGNoOiBtYXRjaCB9fSlcbiAqICAgICBjb25zdCBNID0gZGIubW9kZWwoJ00nLCBzKTtcbiAqICAgICBjb25zdCBtID0gbmV3IE0oeyBmaWxlOiAnaW52YWxpZCcgfSk7XG4gKiAgICAgbS52YWxpZGF0ZShmdW5jdGlvbiAoZXJyKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZyhTdHJpbmcoZXJyKSkgLy8gXCJWYWxpZGF0aW9uRXJyb3I6IFRoYXQgZmlsZSBkb2Vzbid0IGVuZCBpbiAuaHRtbCAoaW52YWxpZClcIlxuICogICAgIH0pXG4gKlxuICogRW1wdHkgc3RyaW5ncywgYHVuZGVmaW5lZGAsIGFuZCBgbnVsbGAgdmFsdWVzIGFsd2F5cyBwYXNzIHRoZSBtYXRjaCB2YWxpZGF0b3IuIElmIHlvdSByZXF1aXJlIHRoZXNlIHZhbHVlcywgZW5hYmxlIHRoZSBgcmVxdWlyZWRgIHZhbGlkYXRvciBhbHNvLlxuICpcbiAqICAgICBjb25zdCBzID0gbmV3IFNjaGVtYSh7IG5hbWU6IHsgdHlwZTogU3RyaW5nLCBtYXRjaDogL15hLywgcmVxdWlyZWQ6IHRydWUgfX0pXG4gKlxuICogQHBhcmFtIHtSZWdFeHB9IHJlZ0V4cCByZWd1bGFyIGV4cHJlc3Npb24gdG8gdGVzdCBhZ2FpbnN0XG4gKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdIG9wdGlvbmFsIGN1c3RvbSBlcnJvciBtZXNzYWdlXG4gKiBAcmV0dXJuIHtTY2hlbWFUeXBlfSB0aGlzXG4gKiBAc2VlIEN1c3RvbWl6ZWQgRXJyb3IgTWVzc2FnZXMgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9lcnJvci5odG1sI0Vycm9yLm1lc3NhZ2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVN0cmluZy5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiBtYXRjaChyZWdFeHAsIG1lc3NhZ2UpIHtcbiAgLy8geWVzLCB3ZSBhbGxvdyBtdWx0aXBsZSBtYXRjaCB2YWxpZGF0b3JzXG5cbiAgY29uc3QgbXNnID0gbWVzc2FnZSB8fCBNb25nb29zZUVycm9yLm1lc3NhZ2VzLlN0cmluZy5tYXRjaDtcblxuICBjb25zdCBtYXRjaFZhbGlkYXRvciA9IGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAoIXJlZ0V4cCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEluIGNhc2UgUmVnRXhwIGhhcHBlbnMgdG8gaGF2ZSBgL2dgIGZsYWcgc2V0LCB3ZSBuZWVkIHRvIHJlc2V0IHRoZVxuICAgIC8vIGBsYXN0SW5kZXhgLCBvdGhlcndpc2UgYG1hdGNoYCB3aWxsIGludGVybWl0dGVudGx5IGZhaWwuXG4gICAgcmVnRXhwLmxhc3RJbmRleCA9IDA7XG5cbiAgICBjb25zdCByZXQgPSAoKHYgIT0gbnVsbCAmJiB2ICE9PSAnJylcbiAgICAgID8gcmVnRXhwLnRlc3QodilcbiAgICAgIDogdHJ1ZSk7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICB0aGlzLnZhbGlkYXRvcnMucHVzaCh7XG4gICAgdmFsaWRhdG9yOiBtYXRjaFZhbGlkYXRvcixcbiAgICBtZXNzYWdlOiBtc2csXG4gICAgdHlwZTogJ3JlZ2V4cCcsXG4gICAgcmVnZXhwOiByZWdFeHBcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgc2F0aXNmaWVzIHRoZSBgcmVxdWlyZWRgIHZhbGlkYXRvci4gVGhlIHZhbHVlIGlzXG4gKiBjb25zaWRlcmVkIHZhbGlkIGlmIGl0IGlzIGEgc3RyaW5nICh0aGF0IGlzLCBub3QgYG51bGxgIG9yIGB1bmRlZmluZWRgKSBhbmRcbiAqIGhhcyBwb3NpdGl2ZSBsZW5ndGguIFRoZSBgcmVxdWlyZWRgIHZhbGlkYXRvciAqKndpbGwqKiBmYWlsIGZvciBlbXB0eVxuICogc3RyaW5ncy5cbiAqXG4gKiBAcGFyYW0ge0FueX0gdmFsdWVcbiAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvY1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hU3RyaW5nLnByb3RvdHlwZS5jaGVja1JlcXVpcmVkID0gZnVuY3Rpb24gY2hlY2tSZXF1aXJlZCh2YWx1ZSwgZG9jKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIFNjaGVtYVR5cGUuX2lzUmVmKHRoaXMsIHZhbHVlLCBkb2MsIHRydWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9IG51bGw7XG4gIH1cblxuICAvLyBgcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzKClgIGRvZXMgKipub3QqKiBjb3B5IHN0YXRpYyBwcm9wZXJ0aWVzLCBhbmRcbiAgLy8gcGx1Z2lucyBsaWtlIG1vbmdvb3NlLWZsb2F0IHVzZSBgaW5oZXJpdHMoKWAgZm9yIHByZS1FUzYuXG4gIGNvbnN0IF9jaGVja1JlcXVpcmVkID0gdHlwZW9mIHRoaXMuY29uc3RydWN0b3IuY2hlY2tSZXF1aXJlZCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5jaGVja1JlcXVpcmVkKCkgOlxuICAgIFNjaGVtYVN0cmluZy5jaGVja1JlcXVpcmVkKCk7XG5cbiAgcmV0dXJuIF9jaGVja1JlcXVpcmVkKHZhbHVlKTtcbn07XG5cbi8qKlxuICogQ2FzdHMgdG8gU3RyaW5nXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hU3RyaW5nLnByb3RvdHlwZS5jYXN0ID0gZnVuY3Rpb24odmFsdWUsIGRvYywgaW5pdCkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiBTY2hlbWFUeXBlLl9pc1JlZih0aGlzLCB2YWx1ZSwgZG9jLCBpbml0KSkge1xuICAgIHJldHVybiB0aGlzLl9jYXN0UmVmKHZhbHVlLCBkb2MsIGluaXQpO1xuICB9XG5cbiAgbGV0IGNhc3RTdHJpbmc7XG4gIGlmICh0eXBlb2YgdGhpcy5fY2FzdEZ1bmN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FzdFN0cmluZyA9IHRoaXMuX2Nhc3RGdW5jdGlvbjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5jb25zdHJ1Y3Rvci5jYXN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FzdFN0cmluZyA9IHRoaXMuY29uc3RydWN0b3IuY2FzdCgpO1xuICB9IGVsc2Uge1xuICAgIGNhc3RTdHJpbmcgPSBTY2hlbWFTdHJpbmcuY2FzdCgpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gY2FzdFN0cmluZyh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IENhc3RFcnJvcignc3RyaW5nJywgdmFsdWUsIHRoaXMucGF0aCwgbnVsbCwgdGhpcyk7XG4gIH1cbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gaGFuZGxlU2luZ2xlKHZhbCwgY29udGV4dCkge1xuICByZXR1cm4gdGhpcy5jYXN0Rm9yUXVlcnkobnVsbCwgdmFsLCBjb250ZXh0KTtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5mdW5jdGlvbiBoYW5kbGVBcnJheSh2YWwsIGNvbnRleHQpIHtcbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHJldHVybiBbdGhpcy5jYXN0Rm9yUXVlcnkobnVsbCwgdmFsLCBjb250ZXh0KV07XG4gIH1cbiAgcmV0dXJuIHZhbC5tYXAoZnVuY3Rpb24obSkge1xuICAgIHJldHVybiBfdGhpcy5jYXN0Rm9yUXVlcnkobnVsbCwgbSwgY29udGV4dCk7XG4gIH0pO1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGhhbmRsZVNpbmdsZU5vU2V0dGVycyh2YWwpIHtcbiAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nhc3ROdWxsaXNoKHZhbCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jYXN0KHZhbCwgdGhpcyk7XG59XG5cbmNvbnN0ICRjb25kaXRpb25hbEhhbmRsZXJzID0ge1xuICAuLi5TY2hlbWFUeXBlLnByb3RvdHlwZS4kY29uZGl0aW9uYWxIYW5kbGVycyxcbiAgJGFsbDogaGFuZGxlQXJyYXksXG4gICRndDogaGFuZGxlU2luZ2xlLFxuICAkZ3RlOiBoYW5kbGVTaW5nbGUsXG4gICRsdDogaGFuZGxlU2luZ2xlLFxuICAkbHRlOiBoYW5kbGVTaW5nbGUsXG4gICRvcHRpb25zOiBoYW5kbGVTaW5nbGVOb1NldHRlcnMsXG4gICRyZWdleDogZnVuY3Rpb24gaGFuZGxlJHJlZ2V4KHZhbCkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhbmRsZVNpbmdsZU5vU2V0dGVycy5jYWxsKHRoaXMsIHZhbCk7XG4gIH0sXG4gICRub3Q6IGhhbmRsZVNpbmdsZVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjaGVtYVN0cmluZy5wcm90b3R5cGUsICckY29uZGl0aW9uYWxIYW5kbGVycycsIHtcbiAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIHdyaXRhYmxlOiBmYWxzZSxcbiAgdmFsdWU6IE9iamVjdC5mcmVlemUoJGNvbmRpdGlvbmFsSGFuZGxlcnMpXG59KTtcblxuLyoqXG4gKiBDYXN0cyBjb250ZW50cyBmb3IgcXVlcmllcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gJGNvbmRpdGlvbmFsXG4gKiBAcGFyYW0ge2FueX0gW3ZhbF1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYVN0cmluZy5wcm90b3R5cGUuY2FzdEZvclF1ZXJ5ID0gZnVuY3Rpb24oJGNvbmRpdGlvbmFsLCB2YWwsIGNvbnRleHQpIHtcbiAgbGV0IGhhbmRsZXI7XG4gIGlmICgkY29uZGl0aW9uYWwgIT0gbnVsbCkge1xuICAgIGhhbmRsZXIgPSB0aGlzLiRjb25kaXRpb25hbEhhbmRsZXJzWyRjb25kaXRpb25hbF07XG4gICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgdXNlICcgKyAkY29uZGl0aW9uYWwgKyAnIHdpdGggU3RyaW5nLicpO1xuICAgIH1cbiAgICByZXR1cm4gaGFuZGxlci5jYWxsKHRoaXMsIHZhbCwgY29udGV4dCk7XG4gIH1cblxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nIHx8IGlzQnNvblR5cGUodmFsLCAnQlNPTlJlZ0V4cCcpKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuYXBwbHlTZXR0ZXJzKHZhbCwgY29udGV4dCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBDYXN0RXJyb3IgJiYgZXJyLnBhdGggPT09IHRoaXMucGF0aCAmJiB0aGlzLiRmdWxsUGF0aCAhPSBudWxsKSB7XG4gICAgICBlcnIucGF0aCA9IHRoaXMuJGZ1bGxQYXRoO1xuICAgIH1cbiAgICB0aHJvdyBlcnI7XG4gIH1cbn07XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFTdHJpbmc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/schema/string.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/schema/subdocument.js":
/*!******************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/schema/subdocument.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = __webpack_require__(/*! ../error/cast */ \"../backend/node_modules/mongoose/lib/error/cast.js\");\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst ObjectExpectedError = __webpack_require__(/*! ../error/objectExpected */ \"../backend/node_modules/mongoose/lib/error/objectExpected.js\");\nconst SchemaSubdocumentOptions = __webpack_require__(/*! ../options/schemaSubdocumentOptions */ \"../backend/node_modules/mongoose/lib/options/schemaSubdocumentOptions.js\");\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"../backend/node_modules/mongoose/lib/schemaType.js\");\nconst applyDefaults = __webpack_require__(/*! ../helpers/document/applyDefaults */ \"../backend/node_modules/mongoose/lib/helpers/document/applyDefaults.js\");\nconst $exists = __webpack_require__(/*! ./operators/exists */ \"../backend/node_modules/mongoose/lib/schema/operators/exists.js\");\nconst castToNumber = (__webpack_require__(/*! ./operators/helpers */ \"../backend/node_modules/mongoose/lib/schema/operators/helpers.js\").castToNumber);\nconst discriminator = __webpack_require__(/*! ../helpers/model/discriminator */ \"../backend/node_modules/mongoose/lib/helpers/model/discriminator.js\");\nconst geospatial = __webpack_require__(/*! ./operators/geospatial */ \"../backend/node_modules/mongoose/lib/schema/operators/geospatial.js\");\nconst getConstructor = __webpack_require__(/*! ../helpers/discriminator/getConstructor */ \"../backend/node_modules/mongoose/lib/helpers/discriminator/getConstructor.js\");\nconst handleIdOption = __webpack_require__(/*! ../helpers/schema/handleIdOption */ \"../backend/node_modules/mongoose/lib/helpers/schema/handleIdOption.js\");\nconst internalToObjectOptions = (__webpack_require__(/*! ../options */ \"../backend/node_modules/mongoose/lib/options.js\").internalToObjectOptions);\nconst isExclusive = __webpack_require__(/*! ../helpers/projection/isExclusive */ \"../backend/node_modules/mongoose/lib/helpers/projection/isExclusive.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\nconst InvalidSchemaOptionError = __webpack_require__(/*! ../error/invalidSchemaOption */ \"../backend/node_modules/mongoose/lib/error/invalidSchemaOption.js\");\n\nlet SubdocumentType;\n\nmodule.exports = SchemaSubdocument;\n\n/**\n * Single nested subdocument SchemaType constructor.\n *\n * @param {Schema} schema\n * @param {String} path\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaSubdocument(schema, path, options) {\n  if (schema.options.timeseries) {\n    throw new InvalidSchemaOptionError(path, 'timeseries');\n  }\n  const schemaTypeIdOption = SchemaSubdocument.defaultOptions &&\n    SchemaSubdocument.defaultOptions._id;\n  if (schemaTypeIdOption != null) {\n    options = options || {};\n    options._id = schemaTypeIdOption;\n  }\n\n  schema = handleIdOption(schema, options);\n\n  this.caster = _createConstructor(schema, null, options);\n  this.caster.path = path;\n  this.caster.prototype.$basePath = path;\n  this.schema = schema;\n  this.$isSingleNested = true;\n  this.base = schema.base;\n  SchemaType.call(this, path, options, 'Embedded');\n}\n\n/*!\n * ignore\n */\n\nSchemaSubdocument.prototype = Object.create(SchemaType.prototype);\nSchemaSubdocument.prototype.constructor = SchemaSubdocument;\nSchemaSubdocument.prototype.OptionsConstructor = SchemaSubdocumentOptions;\n\n/*!\n * ignore\n */\n\nfunction _createConstructor(schema, baseClass, options) {\n  // lazy load\n  SubdocumentType || (SubdocumentType = __webpack_require__(/*! ../types/subdocument */ \"../backend/node_modules/mongoose/lib/types/subdocument.js\"));\n\n  const _embedded = function SingleNested(value, path, parent) {\n    this.$__parent = parent;\n    SubdocumentType.apply(this, arguments);\n\n    if (parent == null) {\n      return;\n    }\n    this.$session(parent.$session());\n  };\n\n  schema._preCompile();\n\n  const proto = baseClass != null ? baseClass.prototype : SubdocumentType.prototype;\n  _embedded.prototype = Object.create(proto);\n  _embedded.prototype.$__setSchema(schema);\n  _embedded.prototype.constructor = _embedded;\n  _embedded.$__required = options?.required;\n  _embedded.base = schema.base;\n  _embedded.schema = schema;\n  _embedded.$isSingleNested = true;\n  _embedded.events = new EventEmitter();\n  _embedded.prototype.toBSON = function() {\n    return this.toObject(internalToObjectOptions);\n  };\n\n  // apply methods\n  for (const i in schema.methods) {\n    _embedded.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (const i in schema.statics) {\n    _embedded[i] = schema.statics[i];\n  }\n\n  for (const i in EventEmitter.prototype) {\n    _embedded[i] = EventEmitter.prototype[i];\n  }\n\n  return _embedded;\n}\n\n/**\n * Special case for when users use a common location schema to represent\n * locations for use with $geoWithin.\n * https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/\n *\n * @param {Object} val\n * @api private\n */\n\nSchemaSubdocument.prototype.$conditionalHandlers.$geoWithin = function handle$geoWithin(val, context) {\n  return { $geometry: this.castForQuery(null, val.$geometry, context) };\n};\n\n/*!\n * ignore\n */\n\nSchemaSubdocument.prototype.$conditionalHandlers.$near =\nSchemaSubdocument.prototype.$conditionalHandlers.$nearSphere = geospatial.cast$near;\n\nSchemaSubdocument.prototype.$conditionalHandlers.$within =\nSchemaSubdocument.prototype.$conditionalHandlers.$geoWithin = geospatial.cast$within;\n\nSchemaSubdocument.prototype.$conditionalHandlers.$geoIntersects =\n  geospatial.cast$geoIntersects;\n\nSchemaSubdocument.prototype.$conditionalHandlers.$minDistance = castToNumber;\nSchemaSubdocument.prototype.$conditionalHandlers.$maxDistance = castToNumber;\n\nSchemaSubdocument.prototype.$conditionalHandlers.$exists = $exists;\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @api private\n */\n\nSchemaSubdocument.prototype.cast = function(val, doc, init, priorVal, options) {\n  if (val && val.$isSingleNested && val.parent === doc) {\n    return val;\n  }\n\n  if (val != null && (typeof val !== 'object' || Array.isArray(val))) {\n    throw new ObjectExpectedError(this.path, val);\n  }\n\n  const discriminatorKeyPath = this.schema.path(this.schema.options.discriminatorKey);\n  const defaultDiscriminatorValue = discriminatorKeyPath == null ? null : discriminatorKeyPath.getDefault(doc);\n  const Constructor = getConstructor(this.caster, val, defaultDiscriminatorValue);\n\n  let subdoc;\n\n  // Only pull relevant selected paths and pull out the base path\n  const parentSelected = doc && doc.$__ && doc.$__.selected;\n  const path = this.path;\n  const selected = parentSelected == null ? null : Object.keys(parentSelected).reduce((obj, key) => {\n    if (key.startsWith(path + '.')) {\n      obj = obj || {};\n      obj[key.substring(path.length + 1)] = parentSelected[key];\n    }\n    return obj;\n  }, null);\n  if (init) {\n    subdoc = new Constructor(void 0, selected, doc, false, { defaults: false });\n    delete subdoc.$__.defaults;\n    subdoc.$init(val);\n    const exclude = isExclusive(selected);\n    applyDefaults(subdoc, selected, exclude);\n  } else {\n    options = Object.assign({}, options, { priorDoc: priorVal });\n    if (Object.keys(val).length === 0) {\n      return new Constructor({}, selected, doc, undefined, options);\n    }\n\n    return new Constructor(val, selected, doc, undefined, options);\n  }\n\n  return subdoc;\n};\n\n/**\n * Casts contents for query\n *\n * @param {string} [$conditional] optional query operator (like `$eq` or `$in`)\n * @param {any} value\n * @api private\n */\n\nSchemaSubdocument.prototype.castForQuery = function($conditional, val, context, options) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional);\n    }\n    return handler.call(this, val);\n  }\n  if (val == null) {\n    return val;\n  }\n\n  const Constructor = getConstructor(this.caster, val);\n  if (val instanceof Constructor) {\n    return val;\n  }\n\n  if (this.options.runSetters) {\n    val = this._applySetters(val, context);\n  }\n\n  const overrideStrict = options != null && options.strict != null ?\n    options.strict :\n    void 0;\n\n  try {\n    val = new Constructor(val, overrideStrict);\n  } catch (error) {\n    // Make sure we always wrap in a CastError (gh-6803)\n    if (!(error instanceof CastError)) {\n      throw new CastError('Embedded', val, this.path, error, this);\n    }\n    throw error;\n  }\n  return val;\n};\n\n/**\n * Async validation on this single nested doc.\n *\n * @api private\n */\n\nSchemaSubdocument.prototype.doValidate = function(value, fn, scope, options) {\n  const Constructor = getConstructor(this.caster, value);\n\n  if (value && !(value instanceof Constructor)) {\n    value = new Constructor(value, null, (scope != null && scope.$__ != null) ? scope : null);\n  }\n\n  if (options && options.skipSchemaValidators) {\n    if (!value) {\n      return fn(null);\n    }\n    return value.validate().then(() => fn(null), err => fn(err));\n  }\n\n  SchemaType.prototype.doValidate.call(this, value, function(error) {\n    if (error) {\n      return fn(error);\n    }\n    if (!value) {\n      return fn(null);\n    }\n\n    value.validate().then(() => fn(null), err => fn(err));\n  }, scope, options);\n};\n\n/**\n * Synchronously validate this single nested doc\n *\n * @api private\n */\n\nSchemaSubdocument.prototype.doValidateSync = function(value, scope, options) {\n  if (!options || !options.skipSchemaValidators) {\n    const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, value, scope);\n    if (schemaTypeError) {\n      return schemaTypeError;\n    }\n  }\n  if (!value) {\n    return;\n  }\n  return value.validateSync();\n};\n\n/**\n * Adds a discriminator to this single nested subdocument.\n *\n * #### Example:\n *\n *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\n *     const schema = Schema({ shape: shapeSchema });\n *\n *     const singleNestedPath = parentSchema.path('shape');\n *     singleNestedPath.discriminator('Circle', Schema({ radius: Number }));\n *\n * @param {String} name\n * @param {Schema} schema fields to add to the schema for instances of this sub-class\n * @param {Object|string} [options] If string, same as `options.value`.\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model\n * @see discriminators https://mongoosejs.com/docs/discriminators.html\n * @api public\n */\n\nSchemaSubdocument.prototype.discriminator = function(name, schema, options) {\n  options = options || {};\n  const value = utils.isPOJO(options) ? options.value : options;\n  const clone = typeof options.clone === 'boolean'\n    ? options.clone\n    : true;\n\n  if (schema.instanceOfSchema && clone) {\n    schema = schema.clone();\n  }\n\n  schema = discriminator(this.caster, name, schema, value, null, null, options.overwriteExisting);\n\n  this.caster.discriminators[name] = _createConstructor(schema, this.caster);\n\n  return this.caster.discriminators[name];\n};\n\n/*!\n * ignore\n */\n\nSchemaSubdocument.defaultOptions = {};\n\n/**\n * Sets a default option for all Subdocument instances.\n *\n * #### Example:\n *\n *     // Make all numbers have option `min` equal to 0.\n *     mongoose.Schema.Subdocument.set('required', true);\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {void}\n * @function set\n * @static\n * @api public\n */\n\nSchemaSubdocument.set = SchemaType.set;\n\nSchemaSubdocument.setters = [];\n\n/**\n * Attaches a getter for all Subdocument instances\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaSubdocument.get = SchemaType.get;\n\n/*!\n * ignore\n */\n\nSchemaSubdocument.prototype.toJSON = function toJSON() {\n  return { path: this.path, options: this.options };\n};\n\n/*!\n * ignore\n */\n\nSchemaSubdocument.prototype.clone = function() {\n  const schematype = new this.constructor(\n    this.schema,\n    this.path,\n    { ...this.options, _skipApplyDiscriminators: true }\n  );\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  schematype.caster.discriminators = Object.assign({}, this.caster.discriminators);\n  return schematype;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9zdWJkb2N1bWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLG1CQUFPLENBQUMseUVBQWU7QUFDekMscUJBQXFCLDBEQUE4QjtBQUNuRCw0QkFBNEIsbUJBQU8sQ0FBQyw2RkFBeUI7QUFDN0QsaUNBQWlDLG1CQUFPLENBQUMscUhBQXFDO0FBQzlFLG1CQUFtQixtQkFBTyxDQUFDLHlFQUFlO0FBQzFDLHNCQUFzQixtQkFBTyxDQUFDLGlIQUFtQztBQUNqRSxnQkFBZ0IsbUJBQU8sQ0FBQywyRkFBb0I7QUFDNUMscUJBQXFCLGlJQUEyQztBQUNoRSxzQkFBc0IsbUJBQU8sQ0FBQywyR0FBZ0M7QUFDOUQsbUJBQW1CLG1CQUFPLENBQUMsbUdBQXdCO0FBQ25ELHVCQUF1QixtQkFBTyxDQUFDLDZIQUF5QztBQUN4RSx1QkFBdUIsbUJBQU8sQ0FBQywrR0FBa0M7QUFDakUsZ0NBQWdDLGtIQUE2QztBQUM3RSxvQkFBb0IsbUJBQU8sQ0FBQyxpSEFBbUM7QUFDL0QsY0FBYyxtQkFBTyxDQUFDLCtEQUFVO0FBQ2hDLGlDQUFpQyxtQkFBTyxDQUFDLHVHQUE4Qjs7QUFFdkU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxtQkFBTyxDQUFDLHVGQUFzQjs7QUFFdEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDZEQUE2RCxpQkFBaUI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osOEJBQThCLGFBQWEsb0JBQW9CO0FBQy9EO0FBQ0EsK0JBQStCO0FBQy9COztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYyxJQUFJLDBCQUEwQjtBQUNoRiwrQkFBK0Isb0JBQW9CO0FBQ25EO0FBQ0E7QUFDQSx5REFBeUQsZ0JBQWdCO0FBQ3pFO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvc2NoZW1hL3N1YmRvY3VtZW50LmpzP2FkOTkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgQ2FzdEVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvY2FzdCcpO1xuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuY29uc3QgT2JqZWN0RXhwZWN0ZWRFcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL29iamVjdEV4cGVjdGVkJyk7XG5jb25zdCBTY2hlbWFTdWJkb2N1bWVudE9wdGlvbnMgPSByZXF1aXJlKCcuLi9vcHRpb25zL3NjaGVtYVN1YmRvY3VtZW50T3B0aW9ucycpO1xuY29uc3QgU2NoZW1hVHlwZSA9IHJlcXVpcmUoJy4uL3NjaGVtYVR5cGUnKTtcbmNvbnN0IGFwcGx5RGVmYXVsdHMgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RvY3VtZW50L2FwcGx5RGVmYXVsdHMnKTtcbmNvbnN0ICRleGlzdHMgPSByZXF1aXJlKCcuL29wZXJhdG9ycy9leGlzdHMnKTtcbmNvbnN0IGNhc3RUb051bWJlciA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL2hlbHBlcnMnKS5jYXN0VG9OdW1iZXI7XG5jb25zdCBkaXNjcmltaW5hdG9yID0gcmVxdWlyZSgnLi4vaGVscGVycy9tb2RlbC9kaXNjcmltaW5hdG9yJyk7XG5jb25zdCBnZW9zcGF0aWFsID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMvZ2Vvc3BhdGlhbCcpO1xuY29uc3QgZ2V0Q29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2Rpc2NyaW1pbmF0b3IvZ2V0Q29uc3RydWN0b3InKTtcbmNvbnN0IGhhbmRsZUlkT3B0aW9uID0gcmVxdWlyZSgnLi4vaGVscGVycy9zY2hlbWEvaGFuZGxlSWRPcHRpb24nKTtcbmNvbnN0IGludGVybmFsVG9PYmplY3RPcHRpb25zID0gcmVxdWlyZSgnLi4vb3B0aW9ucycpLmludGVybmFsVG9PYmplY3RPcHRpb25zO1xuY29uc3QgaXNFeGNsdXNpdmUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3Byb2plY3Rpb24vaXNFeGNsdXNpdmUnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbmNvbnN0IEludmFsaWRTY2hlbWFPcHRpb25FcnJvciA9IHJlcXVpcmUoJy4uL2Vycm9yL2ludmFsaWRTY2hlbWFPcHRpb24nKTtcblxubGV0IFN1YmRvY3VtZW50VHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFTdWJkb2N1bWVudDtcblxuLyoqXG4gKiBTaW5nbGUgbmVzdGVkIHN1YmRvY3VtZW50IFNjaGVtYVR5cGUgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAaW5oZXJpdHMgU2NoZW1hVHlwZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTY2hlbWFTdWJkb2N1bWVudChzY2hlbWEsIHBhdGgsIG9wdGlvbnMpIHtcbiAgaWYgKHNjaGVtYS5vcHRpb25zLnRpbWVzZXJpZXMpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFNjaGVtYU9wdGlvbkVycm9yKHBhdGgsICd0aW1lc2VyaWVzJyk7XG4gIH1cbiAgY29uc3Qgc2NoZW1hVHlwZUlkT3B0aW9uID0gU2NoZW1hU3ViZG9jdW1lbnQuZGVmYXVsdE9wdGlvbnMgJiZcbiAgICBTY2hlbWFTdWJkb2N1bWVudC5kZWZhdWx0T3B0aW9ucy5faWQ7XG4gIGlmIChzY2hlbWFUeXBlSWRPcHRpb24gIT0gbnVsbCkge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMuX2lkID0gc2NoZW1hVHlwZUlkT3B0aW9uO1xuICB9XG5cbiAgc2NoZW1hID0gaGFuZGxlSWRPcHRpb24oc2NoZW1hLCBvcHRpb25zKTtcblxuICB0aGlzLmNhc3RlciA9IF9jcmVhdGVDb25zdHJ1Y3RvcihzY2hlbWEsIG51bGwsIG9wdGlvbnMpO1xuICB0aGlzLmNhc3Rlci5wYXRoID0gcGF0aDtcbiAgdGhpcy5jYXN0ZXIucHJvdG90eXBlLiRiYXNlUGF0aCA9IHBhdGg7XG4gIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICB0aGlzLiRpc1NpbmdsZU5lc3RlZCA9IHRydWU7XG4gIHRoaXMuYmFzZSA9IHNjaGVtYS5iYXNlO1xuICBTY2hlbWFUeXBlLmNhbGwodGhpcywgcGF0aCwgb3B0aW9ucywgJ0VtYmVkZGVkJyk7XG59XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hU3ViZG9jdW1lbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTY2hlbWFUeXBlLnByb3RvdHlwZSk7XG5TY2hlbWFTdWJkb2N1bWVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTY2hlbWFTdWJkb2N1bWVudDtcblNjaGVtYVN1YmRvY3VtZW50LnByb3RvdHlwZS5PcHRpb25zQ29uc3RydWN0b3IgPSBTY2hlbWFTdWJkb2N1bWVudE9wdGlvbnM7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2NyZWF0ZUNvbnN0cnVjdG9yKHNjaGVtYSwgYmFzZUNsYXNzLCBvcHRpb25zKSB7XG4gIC8vIGxhenkgbG9hZFxuICBTdWJkb2N1bWVudFR5cGUgfHwgKFN1YmRvY3VtZW50VHlwZSA9IHJlcXVpcmUoJy4uL3R5cGVzL3N1YmRvY3VtZW50JykpO1xuXG4gIGNvbnN0IF9lbWJlZGRlZCA9IGZ1bmN0aW9uIFNpbmdsZU5lc3RlZCh2YWx1ZSwgcGF0aCwgcGFyZW50KSB7XG4gICAgdGhpcy4kX19wYXJlbnQgPSBwYXJlbnQ7XG4gICAgU3ViZG9jdW1lbnRUeXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBpZiAocGFyZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4kc2Vzc2lvbihwYXJlbnQuJHNlc3Npb24oKSk7XG4gIH07XG5cbiAgc2NoZW1hLl9wcmVDb21waWxlKCk7XG5cbiAgY29uc3QgcHJvdG8gPSBiYXNlQ2xhc3MgIT0gbnVsbCA/IGJhc2VDbGFzcy5wcm90b3R5cGUgOiBTdWJkb2N1bWVudFR5cGUucHJvdG90eXBlO1xuICBfZW1iZWRkZWQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwcm90byk7XG4gIF9lbWJlZGRlZC5wcm90b3R5cGUuJF9fc2V0U2NoZW1hKHNjaGVtYSk7XG4gIF9lbWJlZGRlZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBfZW1iZWRkZWQ7XG4gIF9lbWJlZGRlZC4kX19yZXF1aXJlZCA9IG9wdGlvbnM/LnJlcXVpcmVkO1xuICBfZW1iZWRkZWQuYmFzZSA9IHNjaGVtYS5iYXNlO1xuICBfZW1iZWRkZWQuc2NoZW1hID0gc2NoZW1hO1xuICBfZW1iZWRkZWQuJGlzU2luZ2xlTmVzdGVkID0gdHJ1ZTtcbiAgX2VtYmVkZGVkLmV2ZW50cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgX2VtYmVkZGVkLnByb3RvdHlwZS50b0JTT04gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50b09iamVjdChpbnRlcm5hbFRvT2JqZWN0T3B0aW9ucyk7XG4gIH07XG5cbiAgLy8gYXBwbHkgbWV0aG9kc1xuICBmb3IgKGNvbnN0IGkgaW4gc2NoZW1hLm1ldGhvZHMpIHtcbiAgICBfZW1iZWRkZWQucHJvdG90eXBlW2ldID0gc2NoZW1hLm1ldGhvZHNbaV07XG4gIH1cblxuICAvLyBhcHBseSBzdGF0aWNzXG4gIGZvciAoY29uc3QgaSBpbiBzY2hlbWEuc3RhdGljcykge1xuICAgIF9lbWJlZGRlZFtpXSA9IHNjaGVtYS5zdGF0aWNzW2ldO1xuICB9XG5cbiAgZm9yIChjb25zdCBpIGluIEV2ZW50RW1pdHRlci5wcm90b3R5cGUpIHtcbiAgICBfZW1iZWRkZWRbaV0gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlW2ldO1xuICB9XG5cbiAgcmV0dXJuIF9lbWJlZGRlZDtcbn1cblxuLyoqXG4gKiBTcGVjaWFsIGNhc2UgZm9yIHdoZW4gdXNlcnMgdXNlIGEgY29tbW9uIGxvY2F0aW9uIHNjaGVtYSB0byByZXByZXNlbnRcbiAqIGxvY2F0aW9ucyBmb3IgdXNlIHdpdGggJGdlb1dpdGhpbi5cbiAqIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9xdWVyeS9nZW9XaXRoaW4vXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hU3ViZG9jdW1lbnQucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzLiRnZW9XaXRoaW4gPSBmdW5jdGlvbiBoYW5kbGUkZ2VvV2l0aGluKHZhbCwgY29udGV4dCkge1xuICByZXR1cm4geyAkZ2VvbWV0cnk6IHRoaXMuY2FzdEZvclF1ZXJ5KG51bGwsIHZhbC4kZ2VvbWV0cnksIGNvbnRleHQpIH07XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblNjaGVtYVN1YmRvY3VtZW50LnByb3RvdHlwZS4kY29uZGl0aW9uYWxIYW5kbGVycy4kbmVhciA9XG5TY2hlbWFTdWJkb2N1bWVudC5wcm90b3R5cGUuJGNvbmRpdGlvbmFsSGFuZGxlcnMuJG5lYXJTcGhlcmUgPSBnZW9zcGF0aWFsLmNhc3QkbmVhcjtcblxuU2NoZW1hU3ViZG9jdW1lbnQucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzLiR3aXRoaW4gPVxuU2NoZW1hU3ViZG9jdW1lbnQucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzLiRnZW9XaXRoaW4gPSBnZW9zcGF0aWFsLmNhc3Qkd2l0aGluO1xuXG5TY2hlbWFTdWJkb2N1bWVudC5wcm90b3R5cGUuJGNvbmRpdGlvbmFsSGFuZGxlcnMuJGdlb0ludGVyc2VjdHMgPVxuICBnZW9zcGF0aWFsLmNhc3QkZ2VvSW50ZXJzZWN0cztcblxuU2NoZW1hU3ViZG9jdW1lbnQucHJvdG90eXBlLiRjb25kaXRpb25hbEhhbmRsZXJzLiRtaW5EaXN0YW5jZSA9IGNhc3RUb051bWJlcjtcblNjaGVtYVN1YmRvY3VtZW50LnByb3RvdHlwZS4kY29uZGl0aW9uYWxIYW5kbGVycy4kbWF4RGlzdGFuY2UgPSBjYXN0VG9OdW1iZXI7XG5cblNjaGVtYVN1YmRvY3VtZW50LnByb3RvdHlwZS4kY29uZGl0aW9uYWxIYW5kbGVycy4kZXhpc3RzID0gJGV4aXN0cztcblxuLyoqXG4gKiBDYXN0cyBjb250ZW50c1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hU3ViZG9jdW1lbnQucHJvdG90eXBlLmNhc3QgPSBmdW5jdGlvbih2YWwsIGRvYywgaW5pdCwgcHJpb3JWYWwsIG9wdGlvbnMpIHtcbiAgaWYgKHZhbCAmJiB2YWwuJGlzU2luZ2xlTmVzdGVkICYmIHZhbC5wYXJlbnQgPT09IGRvYykge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBpZiAodmFsICE9IG51bGwgJiYgKHR5cGVvZiB2YWwgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkodmFsKSkpIHtcbiAgICB0aHJvdyBuZXcgT2JqZWN0RXhwZWN0ZWRFcnJvcih0aGlzLnBhdGgsIHZhbCk7XG4gIH1cblxuICBjb25zdCBkaXNjcmltaW5hdG9yS2V5UGF0aCA9IHRoaXMuc2NoZW1hLnBhdGgodGhpcy5zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5KTtcbiAgY29uc3QgZGVmYXVsdERpc2NyaW1pbmF0b3JWYWx1ZSA9IGRpc2NyaW1pbmF0b3JLZXlQYXRoID09IG51bGwgPyBudWxsIDogZGlzY3JpbWluYXRvcktleVBhdGguZ2V0RGVmYXVsdChkb2MpO1xuICBjb25zdCBDb25zdHJ1Y3RvciA9IGdldENvbnN0cnVjdG9yKHRoaXMuY2FzdGVyLCB2YWwsIGRlZmF1bHREaXNjcmltaW5hdG9yVmFsdWUpO1xuXG4gIGxldCBzdWJkb2M7XG5cbiAgLy8gT25seSBwdWxsIHJlbGV2YW50IHNlbGVjdGVkIHBhdGhzIGFuZCBwdWxsIG91dCB0aGUgYmFzZSBwYXRoXG4gIGNvbnN0IHBhcmVudFNlbGVjdGVkID0gZG9jICYmIGRvYy4kX18gJiYgZG9jLiRfXy5zZWxlY3RlZDtcbiAgY29uc3QgcGF0aCA9IHRoaXMucGF0aDtcbiAgY29uc3Qgc2VsZWN0ZWQgPSBwYXJlbnRTZWxlY3RlZCA9PSBudWxsID8gbnVsbCA6IE9iamVjdC5rZXlzKHBhcmVudFNlbGVjdGVkKS5yZWR1Y2UoKG9iaiwga2V5KSA9PiB7XG4gICAgaWYgKGtleS5zdGFydHNXaXRoKHBhdGggKyAnLicpKSB7XG4gICAgICBvYmogPSBvYmogfHwge307XG4gICAgICBvYmpba2V5LnN1YnN0cmluZyhwYXRoLmxlbmd0aCArIDEpXSA9IHBhcmVudFNlbGVjdGVkW2tleV07XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH0sIG51bGwpO1xuICBpZiAoaW5pdCkge1xuICAgIHN1YmRvYyA9IG5ldyBDb25zdHJ1Y3Rvcih2b2lkIDAsIHNlbGVjdGVkLCBkb2MsIGZhbHNlLCB7IGRlZmF1bHRzOiBmYWxzZSB9KTtcbiAgICBkZWxldGUgc3ViZG9jLiRfXy5kZWZhdWx0cztcbiAgICBzdWJkb2MuJGluaXQodmFsKTtcbiAgICBjb25zdCBleGNsdWRlID0gaXNFeGNsdXNpdmUoc2VsZWN0ZWQpO1xuICAgIGFwcGx5RGVmYXVsdHMoc3ViZG9jLCBzZWxlY3RlZCwgZXhjbHVkZSk7XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHsgcHJpb3JEb2M6IHByaW9yVmFsIH0pO1xuICAgIGlmIChPYmplY3Qua2V5cyh2YWwpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih7fSwgc2VsZWN0ZWQsIGRvYywgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHZhbCwgc2VsZWN0ZWQsIGRvYywgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiBzdWJkb2M7XG59O1xuXG4vKipcbiAqIENhc3RzIGNvbnRlbnRzIGZvciBxdWVyeVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbJGNvbmRpdGlvbmFsXSBvcHRpb25hbCBxdWVyeSBvcGVyYXRvciAobGlrZSBgJGVxYCBvciBgJGluYClcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU2NoZW1hU3ViZG9jdW1lbnQucHJvdG90eXBlLmNhc3RGb3JRdWVyeSA9IGZ1bmN0aW9uKCRjb25kaXRpb25hbCwgdmFsLCBjb250ZXh0LCBvcHRpb25zKSB7XG4gIGxldCBoYW5kbGVyO1xuICBpZiAoJGNvbmRpdGlvbmFsICE9IG51bGwpIHtcbiAgICBoYW5kbGVyID0gdGhpcy4kY29uZGl0aW9uYWxIYW5kbGVyc1skY29uZGl0aW9uYWxdO1xuICAgIGlmICghaGFuZGxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IHVzZSAnICsgJGNvbmRpdGlvbmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhbmRsZXIuY2FsbCh0aGlzLCB2YWwpO1xuICB9XG4gIGlmICh2YWwgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBjb25zdCBDb25zdHJ1Y3RvciA9IGdldENvbnN0cnVjdG9yKHRoaXMuY2FzdGVyLCB2YWwpO1xuICBpZiAodmFsIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5ydW5TZXR0ZXJzKSB7XG4gICAgdmFsID0gdGhpcy5fYXBwbHlTZXR0ZXJzKHZhbCwgY29udGV4dCk7XG4gIH1cblxuICBjb25zdCBvdmVycmlkZVN0cmljdCA9IG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLnN0cmljdCAhPSBudWxsID9cbiAgICBvcHRpb25zLnN0cmljdCA6XG4gICAgdm9pZCAwO1xuXG4gIHRyeSB7XG4gICAgdmFsID0gbmV3IENvbnN0cnVjdG9yKHZhbCwgb3ZlcnJpZGVTdHJpY3QpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIE1ha2Ugc3VyZSB3ZSBhbHdheXMgd3JhcCBpbiBhIENhc3RFcnJvciAoZ2gtNjgwMylcbiAgICBpZiAoIShlcnJvciBpbnN0YW5jZW9mIENhc3RFcnJvcikpIHtcbiAgICAgIHRocm93IG5ldyBDYXN0RXJyb3IoJ0VtYmVkZGVkJywgdmFsLCB0aGlzLnBhdGgsIGVycm9yLCB0aGlzKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG5cbi8qKlxuICogQXN5bmMgdmFsaWRhdGlvbiBvbiB0aGlzIHNpbmdsZSBuZXN0ZWQgZG9jLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYVN1YmRvY3VtZW50LnByb3RvdHlwZS5kb1ZhbGlkYXRlID0gZnVuY3Rpb24odmFsdWUsIGZuLCBzY29wZSwgb3B0aW9ucykge1xuICBjb25zdCBDb25zdHJ1Y3RvciA9IGdldENvbnN0cnVjdG9yKHRoaXMuY2FzdGVyLCB2YWx1ZSk7XG5cbiAgaWYgKHZhbHVlICYmICEodmFsdWUgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB2YWx1ZSA9IG5ldyBDb25zdHJ1Y3Rvcih2YWx1ZSwgbnVsbCwgKHNjb3BlICE9IG51bGwgJiYgc2NvcGUuJF9fICE9IG51bGwpID8gc2NvcGUgOiBudWxsKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc2tpcFNjaGVtYVZhbGlkYXRvcnMpIHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gZm4obnVsbCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS52YWxpZGF0ZSgpLnRoZW4oKCkgPT4gZm4obnVsbCksIGVyciA9PiBmbihlcnIpKTtcbiAgfVxuXG4gIFNjaGVtYVR5cGUucHJvdG90eXBlLmRvVmFsaWRhdGUuY2FsbCh0aGlzLCB2YWx1ZSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBmbihlcnJvcik7XG4gICAgfVxuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiBmbihudWxsKTtcbiAgICB9XG5cbiAgICB2YWx1ZS52YWxpZGF0ZSgpLnRoZW4oKCkgPT4gZm4obnVsbCksIGVyciA9PiBmbihlcnIpKTtcbiAgfSwgc2NvcGUsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBTeW5jaHJvbm91c2x5IHZhbGlkYXRlIHRoaXMgc2luZ2xlIG5lc3RlZCBkb2NcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TY2hlbWFTdWJkb2N1bWVudC5wcm90b3R5cGUuZG9WYWxpZGF0ZVN5bmMgPSBmdW5jdGlvbih2YWx1ZSwgc2NvcGUsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLnNraXBTY2hlbWFWYWxpZGF0b3JzKSB7XG4gICAgY29uc3Qgc2NoZW1hVHlwZUVycm9yID0gU2NoZW1hVHlwZS5wcm90b3R5cGUuZG9WYWxpZGF0ZVN5bmMuY2FsbCh0aGlzLCB2YWx1ZSwgc2NvcGUpO1xuICAgIGlmIChzY2hlbWFUeXBlRXJyb3IpIHtcbiAgICAgIHJldHVybiBzY2hlbWFUeXBlRXJyb3I7XG4gICAgfVxuICB9XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmV0dXJuIHZhbHVlLnZhbGlkYXRlU3luYygpO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgZGlzY3JpbWluYXRvciB0byB0aGlzIHNpbmdsZSBuZXN0ZWQgc3ViZG9jdW1lbnQuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBzaGFwZVNjaGVtYSA9IFNjaGVtYSh7IG5hbWU6IFN0cmluZyB9LCB7IGRpc2NyaW1pbmF0b3JLZXk6ICdraW5kJyB9KTtcbiAqICAgICBjb25zdCBzY2hlbWEgPSBTY2hlbWEoeyBzaGFwZTogc2hhcGVTY2hlbWEgfSk7XG4gKlxuICogICAgIGNvbnN0IHNpbmdsZU5lc3RlZFBhdGggPSBwYXJlbnRTY2hlbWEucGF0aCgnc2hhcGUnKTtcbiAqICAgICBzaW5nbGVOZXN0ZWRQYXRoLmRpc2NyaW1pbmF0b3IoJ0NpcmNsZScsIFNjaGVtYSh7IHJhZGl1czogTnVtYmVyIH0pKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYSBmaWVsZHMgdG8gYWRkIHRvIHRoZSBzY2hlbWEgZm9yIGluc3RhbmNlcyBvZiB0aGlzIHN1Yi1jbGFzc1xuICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBbb3B0aW9uc10gSWYgc3RyaW5nLCBzYW1lIGFzIGBvcHRpb25zLnZhbHVlYC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy52YWx1ZV0gdGhlIHN0cmluZyBzdG9yZWQgaW4gdGhlIGBkaXNjcmltaW5hdG9yS2V5YCBwcm9wZXJ0eS4gSWYgbm90IHNwZWNpZmllZCwgTW9uZ29vc2UgdXNlcyB0aGUgYG5hbWVgIHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2xvbmU9dHJ1ZV0gQnkgZGVmYXVsdCwgYGRpc2NyaW1pbmF0b3IoKWAgY2xvbmVzIHRoZSBnaXZlbiBgc2NoZW1hYC4gU2V0IHRvIGBmYWxzZWAgdG8gc2tpcCBjbG9uaW5nLlxuICogQHJldHVybiB7RnVuY3Rpb259IHRoZSBjb25zdHJ1Y3RvciBNb25nb29zZSB3aWxsIHVzZSBmb3IgY3JlYXRpbmcgaW5zdGFuY2VzIG9mIHRoaXMgZGlzY3JpbWluYXRvciBtb2RlbFxuICogQHNlZSBkaXNjcmltaW5hdG9ycyBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvZGlzY3JpbWluYXRvcnMuaHRtbFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFTdWJkb2N1bWVudC5wcm90b3R5cGUuZGlzY3JpbWluYXRvciA9IGZ1bmN0aW9uKG5hbWUsIHNjaGVtYSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgdmFsdWUgPSB1dGlscy5pc1BPSk8ob3B0aW9ucykgPyBvcHRpb25zLnZhbHVlIDogb3B0aW9ucztcbiAgY29uc3QgY2xvbmUgPSB0eXBlb2Ygb3B0aW9ucy5jbG9uZSA9PT0gJ2Jvb2xlYW4nXG4gICAgPyBvcHRpb25zLmNsb25lXG4gICAgOiB0cnVlO1xuXG4gIGlmIChzY2hlbWEuaW5zdGFuY2VPZlNjaGVtYSAmJiBjbG9uZSkge1xuICAgIHNjaGVtYSA9IHNjaGVtYS5jbG9uZSgpO1xuICB9XG5cbiAgc2NoZW1hID0gZGlzY3JpbWluYXRvcih0aGlzLmNhc3RlciwgbmFtZSwgc2NoZW1hLCB2YWx1ZSwgbnVsbCwgbnVsbCwgb3B0aW9ucy5vdmVyd3JpdGVFeGlzdGluZyk7XG5cbiAgdGhpcy5jYXN0ZXIuZGlzY3JpbWluYXRvcnNbbmFtZV0gPSBfY3JlYXRlQ29uc3RydWN0b3Ioc2NoZW1hLCB0aGlzLmNhc3Rlcik7XG5cbiAgcmV0dXJuIHRoaXMuY2FzdGVyLmRpc2NyaW1pbmF0b3JzW25hbWVdO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFTdWJkb2N1bWVudC5kZWZhdWx0T3B0aW9ucyA9IHt9O1xuXG4vKipcbiAqIFNldHMgYSBkZWZhdWx0IG9wdGlvbiBmb3IgYWxsIFN1YmRvY3VtZW50IGluc3RhbmNlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE1ha2UgYWxsIG51bWJlcnMgaGF2ZSBvcHRpb24gYG1pbmAgZXF1YWwgdG8gMC5cbiAqICAgICBtb25nb29zZS5TY2hlbWEuU3ViZG9jdW1lbnQuc2V0KCdyZXF1aXJlZCcsIHRydWUpO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb24gVGhlIG9wdGlvbiB5b3UnZCBsaWtlIHRvIHNldCB0aGUgdmFsdWUgZm9yXG4gKiBAcGFyYW0ge0FueX0gdmFsdWUgdmFsdWUgZm9yIG9wdGlvblxuICogQHJldHVybiB7dm9pZH1cbiAqIEBmdW5jdGlvbiBzZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hU3ViZG9jdW1lbnQuc2V0ID0gU2NoZW1hVHlwZS5zZXQ7XG5cblNjaGVtYVN1YmRvY3VtZW50LnNldHRlcnMgPSBbXTtcblxuLyoqXG4gKiBBdHRhY2hlcyBhIGdldHRlciBmb3IgYWxsIFN1YmRvY3VtZW50IGluc3RhbmNlc1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGdldHRlclxuICogQHJldHVybiB7dGhpc31cbiAqIEBmdW5jdGlvbiBnZXRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hU3ViZG9jdW1lbnQuZ2V0ID0gU2NoZW1hVHlwZS5nZXQ7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hU3ViZG9jdW1lbnQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgcmV0dXJuIHsgcGF0aDogdGhpcy5wYXRoLCBvcHRpb25zOiB0aGlzLm9wdGlvbnMgfTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hU3ViZG9jdW1lbnQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IHNjaGVtYXR5cGUgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihcbiAgICB0aGlzLnNjaGVtYSxcbiAgICB0aGlzLnBhdGgsXG4gICAgeyAuLi50aGlzLm9wdGlvbnMsIF9za2lwQXBwbHlEaXNjcmltaW5hdG9yczogdHJ1ZSB9XG4gICk7XG4gIHNjaGVtYXR5cGUudmFsaWRhdG9ycyA9IHRoaXMudmFsaWRhdG9ycy5zbGljZSgpO1xuICBpZiAodGhpcy5yZXF1aXJlZFZhbGlkYXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2NoZW1hdHlwZS5yZXF1aXJlZFZhbGlkYXRvciA9IHRoaXMucmVxdWlyZWRWYWxpZGF0b3I7XG4gIH1cbiAgc2NoZW1hdHlwZS5jYXN0ZXIuZGlzY3JpbWluYXRvcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNhc3Rlci5kaXNjcmltaW5hdG9ycyk7XG4gIHJldHVybiBzY2hlbWF0eXBlO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/schema/subdocument.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/schema/symbols.js":
/*!**************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/schema/symbols.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.schemaMixedSymbol = Symbol.for('mongoose:schema_mixed');\n\nexports.builtInMiddleware = Symbol.for('mongoose:built-in-middleware');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9zeW1ib2xzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHlCQUF5Qjs7QUFFekIseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS9zeW1ib2xzLmpzP2ZmMmYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLnNjaGVtYU1peGVkU3ltYm9sID0gU3ltYm9sLmZvcignbW9uZ29vc2U6c2NoZW1hX21peGVkJyk7XG5cbmV4cG9ydHMuYnVpbHRJbk1pZGRsZXdhcmUgPSBTeW1ib2wuZm9yKCdtb25nb29zZTpidWlsdC1pbi1taWRkbGV3YXJlJyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/schema/symbols.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/schema/uuid.js":
/*!***********************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/schema/uuid.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst MongooseBuffer = __webpack_require__(/*! ../types/buffer */ \"../backend/node_modules/mongoose/lib/types/buffer.js\");\nconst SchemaType = __webpack_require__(/*! ../schemaType */ \"../backend/node_modules/mongoose/lib/schemaType.js\");\nconst CastError = SchemaType.CastError;\nconst utils = __webpack_require__(/*! ../utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\nconst handleBitwiseOperator = __webpack_require__(/*! ./operators/bitwise */ \"../backend/node_modules/mongoose/lib/schema/operators/bitwise.js\");\n\nconst UUID_FORMAT = /[0-9a-f]{8}-[0-9a-f]{4}-[0-9][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}/i;\nconst Binary = MongooseBuffer.Binary;\n\n/**\n * Helper function to convert the input hex-string to a buffer\n * @param {String} hex The hex string to convert\n * @returns {Buffer} The hex as buffer\n * @api private\n */\n\nfunction hex2buffer(hex) {\n  // use buffer built-in function to convert from hex-string to buffer\n  const buff = hex != null && Buffer.from(hex, 'hex');\n  return buff;\n}\n\n/**\n * Helper function to convert the buffer input to a string\n * @param {Buffer} buf The buffer to convert to a hex-string\n * @returns {String} The buffer as a hex-string\n * @api private\n */\n\nfunction binary2hex(buf) {\n  // use buffer built-in function to convert from buffer to hex-string\n  const hex = buf != null && buf.toString('hex');\n  return hex;\n}\n\n/**\n * Convert a String to Binary\n * @param {String} uuidStr The value to process\n * @returns {MongooseBuffer} The binary to store\n * @api private\n */\n\nfunction stringToBinary(uuidStr) {\n  // Protect against undefined & throwing err\n  if (typeof uuidStr !== 'string') uuidStr = '';\n  const hex = uuidStr.replace(/[{}-]/g, ''); // remove extra characters\n  const bytes = hex2buffer(hex);\n  const buff = new MongooseBuffer(bytes);\n  buff._subtype = 4;\n\n  return buff;\n}\n\n/**\n * Convert binary to a uuid string\n * @param {Buffer|Binary|String} uuidBin The value to process\n * @returns {String} The completed uuid-string\n * @api private\n */\nfunction binaryToString(uuidBin) {\n  // i(hasezoey) dont quite know why, but \"uuidBin\" may sometimes also be the already processed string\n  let hex;\n  if (typeof uuidBin !== 'string' && uuidBin != null) {\n    hex = binary2hex(uuidBin);\n    const uuidStr = hex.substring(0, 8) + '-' + hex.substring(8, 8 + 4) + '-' + hex.substring(12, 12 + 4) + '-' + hex.substring(16, 16 + 4) + '-' + hex.substring(20, 20 + 12);\n    return uuidStr;\n  }\n  return uuidBin;\n}\n\n/**\n * UUIDv1 SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaUUID(key, options) {\n  SchemaType.call(this, key, options, 'UUID');\n  this.getters.push(function(value) {\n    // For populated\n    if (value != null && value.$__ != null) {\n      return value;\n    }\n    return binaryToString(value);\n  });\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaUUID.schemaName = 'UUID';\n\nSchemaUUID.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaUUID.prototype = Object.create(SchemaType.prototype);\nSchemaUUID.prototype.constructor = SchemaUUID;\n\n/*!\n * ignore\n */\n\nSchemaUUID._cast = function(value) {\n  if (value == null) {\n    return value;\n  }\n\n  function newBuffer(initbuff) {\n    const buff = new MongooseBuffer(initbuff);\n    buff._subtype = 4;\n    return buff;\n  }\n\n  if (typeof value === 'string') {\n    if (UUID_FORMAT.test(value)) {\n      return stringToBinary(value);\n    } else {\n      throw new CastError(SchemaUUID.schemaName, value, this.path);\n    }\n  }\n\n  if (Buffer.isBuffer(value)) {\n    return newBuffer(value);\n  }\n\n  if (value instanceof Binary) {\n    return newBuffer(value.value(true));\n  }\n\n  // Re: gh-647 and gh-3030, we're ok with casting using `toString()`\n  // **unless** its the default Object.toString, because \"[object Object]\"\n  // doesn't really qualify as useful data\n  if (value.toString && value.toString !== Object.prototype.toString) {\n    if (UUID_FORMAT.test(value.toString())) {\n      return stringToBinary(value.toString());\n    }\n  }\n\n  throw new CastError(SchemaUUID.schemaName, value, this.path);\n};\n\n/**\n * Attaches a getter for all UUID instances.\n *\n * #### Example:\n *\n *     // Note that `v` is a string by default\n *     mongoose.Schema.UUID.get(v => v.toUpperCase());\n *\n *     const Model = mongoose.model('Test', new Schema({ test: 'UUID' }));\n *     new Model({ test: uuid.v4() }).test; // UUID with all uppercase\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaUUID.get = SchemaType.get;\n\n/**\n * Sets a default option for all UUID instances.\n *\n * #### Example:\n *\n *     // Make all UUIDs have `required` of true by default.\n *     mongoose.Schema.UUID.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: mongoose.UUID }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaUUID.set = SchemaType.set;\n\nSchemaUUID.setters = [];\n\n/**\n * Get/set the function used to cast arbitrary values to UUIDs.\n *\n * #### Example:\n *\n *     // Make Mongoose refuse to cast UUIDs with 0 length\n *     const original = mongoose.Schema.Types.UUID.cast();\n *     mongoose.UUID.cast(v => {\n *       assert.ok(typeof v === \"string\" && v.length > 0);\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.UUID.cast(false);\n *\n * @param {Function} [caster]\n * @return {Function}\n * @function get\n * @static\n * @api public\n */\n\nSchemaUUID.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaUUID._checkRequired = v => v != null;\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaUUID.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator.\n *\n * @param {Any} value\n * @return {Boolean}\n * @api public\n */\n\nSchemaUUID.prototype.checkRequired = function checkRequired(value) {\n  if (Buffer.isBuffer(value)) {\n    value = binaryToString(value);\n  }\n  return value != null && UUID_FORMAT.test(value);\n};\n\n/**\n * Casts to UUID\n *\n * @param {Object} value\n * @param {Object} doc\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nSchemaUUID.prototype.cast = function(value, doc, init) {\n  if (utils.isNonBuiltinObject(value) &&\n      SchemaType._isRef(this, value, doc, init)) {\n    return this._castRef(value, doc, init);\n  }\n\n  let castFn;\n  if (typeof this._castFunction === 'function') {\n    castFn = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castFn = this.constructor.cast();\n  } else {\n    castFn = SchemaUUID.cast();\n  }\n\n  try {\n    return castFn(value);\n  } catch (error) {\n    throw new CastError(SchemaUUID.schemaName, value, this.path, error, this);\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\n/*!\n * ignore\n */\n\nfunction handleArray(val) {\n  return val.map((m) => {\n    return this.cast(m);\n  });\n}\n\nSchemaUUID.prototype.$conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers,\n  $bitsAllClear: handleBitwiseOperator,\n  $bitsAnyClear: handleBitwiseOperator,\n  $bitsAllSet: handleBitwiseOperator,\n  $bitsAnySet: handleBitwiseOperator,\n  $all: handleArray,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $in: handleArray,\n  $lt: handleSingle,\n  $lte: handleSingle,\n  $ne: handleSingle,\n  $nin: handleArray\n};\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} val\n * @api private\n */\n\nSchemaUUID.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler)\n      throw new Error('Can\\'t use ' + $conditional + ' with UUID.');\n    return handler.call(this, val, context);\n  }\n\n  try {\n    return this.applySetters(val, context);\n  } catch (err) {\n    if (err instanceof CastError && err.path === this.path && this.$fullPath != null) {\n      err.path = this.$fullPath;\n    }\n    throw err;\n  }\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaUUID;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS91dWlkLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYix1QkFBdUIsbUJBQU8sQ0FBQyw2RUFBaUI7QUFDaEQsbUJBQW1CLG1CQUFPLENBQUMseUVBQWU7QUFDMUM7QUFDQSxjQUFjLG1CQUFPLENBQUMsK0RBQVU7QUFDaEMsOEJBQThCLG1CQUFPLENBQUMsNkZBQXFCOztBQUUzRCw4QkFBOEIsRUFBRSxVQUFVLEVBQUUsZUFBZSxFQUFFLGdCQUFnQixFQUFFLFVBQVUsR0FBRztBQUM1Rjs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsV0FBVztBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakMsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGNBQWM7QUFDdkUsbUJBQW1CLGlCQUFpQixRQUFRO0FBQzVDO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHFCQUFxQjtBQUM3RSxtQkFBbUIsc0NBQXNDO0FBQ3pEO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3NjaGVtYS91dWlkLmpzPzYxYWEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgTW9uZ29vc2VCdWZmZXIgPSByZXF1aXJlKCcuLi90eXBlcy9idWZmZXInKTtcbmNvbnN0IFNjaGVtYVR5cGUgPSByZXF1aXJlKCcuLi9zY2hlbWFUeXBlJyk7XG5jb25zdCBDYXN0RXJyb3IgPSBTY2hlbWFUeXBlLkNhc3RFcnJvcjtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbmNvbnN0IGhhbmRsZUJpdHdpc2VPcGVyYXRvciA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzL2JpdHdpc2UnKTtcblxuY29uc3QgVVVJRF9GT1JNQVQgPSAvWzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzAtOV1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn0vaTtcbmNvbnN0IEJpbmFyeSA9IE1vbmdvb3NlQnVmZmVyLkJpbmFyeTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCB0aGUgaW5wdXQgaGV4LXN0cmluZyB0byBhIGJ1ZmZlclxuICogQHBhcmFtIHtTdHJpbmd9IGhleCBUaGUgaGV4IHN0cmluZyB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7QnVmZmVyfSBUaGUgaGV4IGFzIGJ1ZmZlclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaGV4MmJ1ZmZlcihoZXgpIHtcbiAgLy8gdXNlIGJ1ZmZlciBidWlsdC1pbiBmdW5jdGlvbiB0byBjb252ZXJ0IGZyb20gaGV4LXN0cmluZyB0byBidWZmZXJcbiAgY29uc3QgYnVmZiA9IGhleCAhPSBudWxsICYmIEJ1ZmZlci5mcm9tKGhleCwgJ2hleCcpO1xuICByZXR1cm4gYnVmZjtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCB0aGUgYnVmZmVyIGlucHV0IHRvIGEgc3RyaW5nXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmIFRoZSBidWZmZXIgdG8gY29udmVydCB0byBhIGhleC1zdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBidWZmZXIgYXMgYSBoZXgtc3RyaW5nXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBiaW5hcnkyaGV4KGJ1Zikge1xuICAvLyB1c2UgYnVmZmVyIGJ1aWx0LWluIGZ1bmN0aW9uIHRvIGNvbnZlcnQgZnJvbSBidWZmZXIgdG8gaGV4LXN0cmluZ1xuICBjb25zdCBoZXggPSBidWYgIT0gbnVsbCAmJiBidWYudG9TdHJpbmcoJ2hleCcpO1xuICByZXR1cm4gaGV4O1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSBTdHJpbmcgdG8gQmluYXJ5XG4gKiBAcGFyYW0ge1N0cmluZ30gdXVpZFN0ciBUaGUgdmFsdWUgdG8gcHJvY2Vzc1xuICogQHJldHVybnMge01vbmdvb3NlQnVmZmVyfSBUaGUgYmluYXJ5IHRvIHN0b3JlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzdHJpbmdUb0JpbmFyeSh1dWlkU3RyKSB7XG4gIC8vIFByb3RlY3QgYWdhaW5zdCB1bmRlZmluZWQgJiB0aHJvd2luZyBlcnJcbiAgaWYgKHR5cGVvZiB1dWlkU3RyICE9PSAnc3RyaW5nJykgdXVpZFN0ciA9ICcnO1xuICBjb25zdCBoZXggPSB1dWlkU3RyLnJlcGxhY2UoL1t7fS1dL2csICcnKTsgLy8gcmVtb3ZlIGV4dHJhIGNoYXJhY3RlcnNcbiAgY29uc3QgYnl0ZXMgPSBoZXgyYnVmZmVyKGhleCk7XG4gIGNvbnN0IGJ1ZmYgPSBuZXcgTW9uZ29vc2VCdWZmZXIoYnl0ZXMpO1xuICBidWZmLl9zdWJ0eXBlID0gNDtcblxuICByZXR1cm4gYnVmZjtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGJpbmFyeSB0byBhIHV1aWQgc3RyaW5nXG4gKiBAcGFyYW0ge0J1ZmZlcnxCaW5hcnl8U3RyaW5nfSB1dWlkQmluIFRoZSB2YWx1ZSB0byBwcm9jZXNzXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgY29tcGxldGVkIHV1aWQtc3RyaW5nXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYmluYXJ5VG9TdHJpbmcodXVpZEJpbikge1xuICAvLyBpKGhhc2V6b2V5KSBkb250IHF1aXRlIGtub3cgd2h5LCBidXQgXCJ1dWlkQmluXCIgbWF5IHNvbWV0aW1lcyBhbHNvIGJlIHRoZSBhbHJlYWR5IHByb2Nlc3NlZCBzdHJpbmdcbiAgbGV0IGhleDtcbiAgaWYgKHR5cGVvZiB1dWlkQmluICE9PSAnc3RyaW5nJyAmJiB1dWlkQmluICE9IG51bGwpIHtcbiAgICBoZXggPSBiaW5hcnkyaGV4KHV1aWRCaW4pO1xuICAgIGNvbnN0IHV1aWRTdHIgPSBoZXguc3Vic3RyaW5nKDAsIDgpICsgJy0nICsgaGV4LnN1YnN0cmluZyg4LCA4ICsgNCkgKyAnLScgKyBoZXguc3Vic3RyaW5nKDEyLCAxMiArIDQpICsgJy0nICsgaGV4LnN1YnN0cmluZygxNiwgMTYgKyA0KSArICctJyArIGhleC5zdWJzdHJpbmcoMjAsIDIwICsgMTIpO1xuICAgIHJldHVybiB1dWlkU3RyO1xuICB9XG4gIHJldHVybiB1dWlkQmluO1xufVxuXG4vKipcbiAqIFVVSUR2MSBTY2hlbWFUeXBlIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAaW5oZXJpdHMgU2NoZW1hVHlwZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTY2hlbWFVVUlEKGtleSwgb3B0aW9ucykge1xuICBTY2hlbWFUeXBlLmNhbGwodGhpcywga2V5LCBvcHRpb25zLCAnVVVJRCcpO1xuICB0aGlzLmdldHRlcnMucHVzaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIC8vIEZvciBwb3B1bGF0ZWRcbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZS4kX18gIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYmluYXJ5VG9TdHJpbmcodmFsdWUpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBUaGlzIHNjaGVtYSB0eXBlJ3MgbmFtZSwgdG8gZGVmZW5kIGFnYWluc3QgbWluaWZpZXJzIHRoYXQgbWFuZ2xlXG4gKiBmdW5jdGlvbiBuYW1lcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5TY2hlbWFVVUlELnNjaGVtYU5hbWUgPSAnVVVJRCc7XG5cblNjaGVtYVVVSUQuZGVmYXVsdE9wdGlvbnMgPSB7fTtcblxuLyohXG4gKiBJbmhlcml0cyBmcm9tIFNjaGVtYVR5cGUuXG4gKi9cblNjaGVtYVVVSUQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTY2hlbWFUeXBlLnByb3RvdHlwZSk7XG5TY2hlbWFVVUlELnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNjaGVtYVVVSUQ7XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU2NoZW1hVVVJRC5fY2FzdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gbmV3QnVmZmVyKGluaXRidWZmKSB7XG4gICAgY29uc3QgYnVmZiA9IG5ldyBNb25nb29zZUJ1ZmZlcihpbml0YnVmZik7XG4gICAgYnVmZi5fc3VidHlwZSA9IDQ7XG4gICAgcmV0dXJuIGJ1ZmY7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChVVUlEX0ZPUk1BVC50ZXN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHN0cmluZ1RvQmluYXJ5KHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IENhc3RFcnJvcihTY2hlbWFVVUlELnNjaGVtYU5hbWUsIHZhbHVlLCB0aGlzLnBhdGgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgcmV0dXJuIG5ld0J1ZmZlcih2YWx1ZSk7XG4gIH1cblxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBCaW5hcnkpIHtcbiAgICByZXR1cm4gbmV3QnVmZmVyKHZhbHVlLnZhbHVlKHRydWUpKTtcbiAgfVxuXG4gIC8vIFJlOiBnaC02NDcgYW5kIGdoLTMwMzAsIHdlJ3JlIG9rIHdpdGggY2FzdGluZyB1c2luZyBgdG9TdHJpbmcoKWBcbiAgLy8gKip1bmxlc3MqKiBpdHMgdGhlIGRlZmF1bHQgT2JqZWN0LnRvU3RyaW5nLCBiZWNhdXNlIFwiW29iamVjdCBPYmplY3RdXCJcbiAgLy8gZG9lc24ndCByZWFsbHkgcXVhbGlmeSBhcyB1c2VmdWwgZGF0YVxuICBpZiAodmFsdWUudG9TdHJpbmcgJiYgdmFsdWUudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpIHtcbiAgICBpZiAoVVVJRF9GT1JNQVQudGVzdCh2YWx1ZS50b1N0cmluZygpKSkge1xuICAgICAgcmV0dXJuIHN0cmluZ1RvQmluYXJ5KHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBDYXN0RXJyb3IoU2NoZW1hVVVJRC5zY2hlbWFOYW1lLCB2YWx1ZSwgdGhpcy5wYXRoKTtcbn07XG5cbi8qKlxuICogQXR0YWNoZXMgYSBnZXR0ZXIgZm9yIGFsbCBVVUlEIGluc3RhbmNlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIE5vdGUgdGhhdCBgdmAgaXMgYSBzdHJpbmcgYnkgZGVmYXVsdFxuICogICAgIG1vbmdvb3NlLlNjaGVtYS5VVUlELmdldCh2ID0+IHYudG9VcHBlckNhc2UoKSk7XG4gKlxuICogICAgIGNvbnN0IE1vZGVsID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBuZXcgU2NoZW1hKHsgdGVzdDogJ1VVSUQnIH0pKTtcbiAqICAgICBuZXcgTW9kZWwoeyB0ZXN0OiB1dWlkLnY0KCkgfSkudGVzdDsgLy8gVVVJRCB3aXRoIGFsbCB1cHBlcmNhc2VcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAqIEByZXR1cm4ge3RoaXN9XG4gKiBAZnVuY3Rpb24gZ2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVVVSUQuZ2V0ID0gU2NoZW1hVHlwZS5nZXQ7XG5cbi8qKlxuICogU2V0cyBhIGRlZmF1bHQgb3B0aW9uIGZvciBhbGwgVVVJRCBpbnN0YW5jZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBNYWtlIGFsbCBVVUlEcyBoYXZlIGByZXF1aXJlZGAgb2YgdHJ1ZSBieSBkZWZhdWx0LlxuICogICAgIG1vbmdvb3NlLlNjaGVtYS5VVUlELnNldCgncmVxdWlyZWQnLCB0cnVlKTtcbiAqXG4gKiAgICAgY29uc3QgVXNlciA9IG1vbmdvb3NlLm1vZGVsKCdVc2VyJywgbmV3IFNjaGVtYSh7IHRlc3Q6IG1vbmdvb3NlLlVVSUQgfSkpO1xuICogICAgIG5ldyBVc2VyKHsgfSkudmFsaWRhdGVTeW5jKCkuZXJyb3JzLnRlc3QubWVzc2FnZTsgLy8gUGF0aCBgdGVzdGAgaXMgcmVxdWlyZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbiBUaGUgb3B0aW9uIHlvdSdkIGxpa2UgdG8gc2V0IHRoZSB2YWx1ZSBmb3JcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZSB2YWx1ZSBmb3Igb3B0aW9uXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gKiBAZnVuY3Rpb24gc2V0XG4gKiBAc3RhdGljXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNjaGVtYVVVSUQuc2V0ID0gU2NoZW1hVHlwZS5zZXQ7XG5cblNjaGVtYVVVSUQuc2V0dGVycyA9IFtdO1xuXG4vKipcbiAqIEdldC9zZXQgdGhlIGZ1bmN0aW9uIHVzZWQgdG8gY2FzdCBhcmJpdHJhcnkgdmFsdWVzIHRvIFVVSURzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gTWFrZSBNb25nb29zZSByZWZ1c2UgdG8gY2FzdCBVVUlEcyB3aXRoIDAgbGVuZ3RoXG4gKiAgICAgY29uc3Qgb3JpZ2luYWwgPSBtb25nb29zZS5TY2hlbWEuVHlwZXMuVVVJRC5jYXN0KCk7XG4gKiAgICAgbW9uZ29vc2UuVVVJRC5jYXN0KHYgPT4ge1xuICogICAgICAgYXNzZXJ0Lm9rKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiICYmIHYubGVuZ3RoID4gMCk7XG4gKiAgICAgICByZXR1cm4gb3JpZ2luYWwodik7XG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vIE9yIGRpc2FibGUgY2FzdGluZyBlbnRpcmVseVxuICogICAgIG1vbmdvb3NlLlVVSUQuY2FzdChmYWxzZSk7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2Nhc3Rlcl1cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGZ1bmN0aW9uIGdldFxuICogQHN0YXRpY1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFVVUlELmNhc3QgPSBmdW5jdGlvbiBjYXN0KGNhc3Rlcikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzLl9jYXN0O1xuICB9XG4gIGlmIChjYXN0ZXIgPT09IGZhbHNlKSB7XG4gICAgY2FzdGVyID0gdGhpcy5fZGVmYXVsdENhc3RlcjtcbiAgfVxuICB0aGlzLl9jYXN0ID0gY2FzdGVyO1xuXG4gIHJldHVybiB0aGlzLl9jYXN0O1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TY2hlbWFVVUlELl9jaGVja1JlcXVpcmVkID0gdiA9PiB2ICE9IG51bGw7XG5cbi8qKlxuICogT3ZlcnJpZGUgdGhlIGZ1bmN0aW9uIHRoZSByZXF1aXJlZCB2YWxpZGF0b3IgdXNlcyB0byBjaGVjayB3aGV0aGVyIGEgc3RyaW5nXG4gKiBwYXNzZXMgdGhlIGByZXF1aXJlZGAgY2hlY2suXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGZ1bmN0aW9uIGNoZWNrUmVxdWlyZWRcbiAqIEBzdGF0aWNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU2NoZW1hVVVJRC5jaGVja1JlcXVpcmVkID0gU2NoZW1hVHlwZS5jaGVja1JlcXVpcmVkO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBzYXRpc2ZpZXMgYSByZXF1aXJlZCB2YWxpZGF0b3IuXG4gKlxuICogQHBhcmFtIHtBbnl9IHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5TY2hlbWFVVUlELnByb3RvdHlwZS5jaGVja1JlcXVpcmVkID0gZnVuY3Rpb24gY2hlY2tSZXF1aXJlZCh2YWx1ZSkge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgIHZhbHVlID0gYmluYXJ5VG9TdHJpbmcodmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIFVVSURfRk9STUFULnRlc3QodmFsdWUpO1xufTtcblxuLyoqXG4gKiBDYXN0cyB0byBVVUlEXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gZG9jXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluaXQgd2hldGhlciB0aGlzIGlzIGFuIGluaXRpYWxpemF0aW9uIGNhc3RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYVVVSUQucHJvdG90eXBlLmNhc3QgPSBmdW5jdGlvbih2YWx1ZSwgZG9jLCBpbml0KSB7XG4gIGlmICh1dGlscy5pc05vbkJ1aWx0aW5PYmplY3QodmFsdWUpICYmXG4gICAgICBTY2hlbWFUeXBlLl9pc1JlZih0aGlzLCB2YWx1ZSwgZG9jLCBpbml0KSkge1xuICAgIHJldHVybiB0aGlzLl9jYXN0UmVmKHZhbHVlLCBkb2MsIGluaXQpO1xuICB9XG5cbiAgbGV0IGNhc3RGbjtcbiAgaWYgKHR5cGVvZiB0aGlzLl9jYXN0RnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYXN0Rm4gPSB0aGlzLl9jYXN0RnVuY3Rpb247XG4gIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuY29uc3RydWN0b3IuY2FzdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhc3RGbiA9IHRoaXMuY29uc3RydWN0b3IuY2FzdCgpO1xuICB9IGVsc2Uge1xuICAgIGNhc3RGbiA9IFNjaGVtYVVVSUQuY2FzdCgpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gY2FzdEZuKHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgQ2FzdEVycm9yKFNjaGVtYVVVSUQuc2NoZW1hTmFtZSwgdmFsdWUsIHRoaXMucGF0aCwgZXJyb3IsIHRoaXMpO1xuICB9XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGhhbmRsZVNpbmdsZSh2YWwpIHtcbiAgcmV0dXJuIHRoaXMuY2FzdCh2YWwpO1xufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIGhhbmRsZUFycmF5KHZhbCkge1xuICByZXR1cm4gdmFsLm1hcCgobSkgPT4ge1xuICAgIHJldHVybiB0aGlzLmNhc3QobSk7XG4gIH0pO1xufVxuXG5TY2hlbWFVVUlELnByb3RvdHlwZS4kY29uZGl0aW9uYWxIYW5kbGVycyA9IHtcbiAgLi4uU2NoZW1hVHlwZS5wcm90b3R5cGUuJGNvbmRpdGlvbmFsSGFuZGxlcnMsXG4gICRiaXRzQWxsQ2xlYXI6IGhhbmRsZUJpdHdpc2VPcGVyYXRvcixcbiAgJGJpdHNBbnlDbGVhcjogaGFuZGxlQml0d2lzZU9wZXJhdG9yLFxuICAkYml0c0FsbFNldDogaGFuZGxlQml0d2lzZU9wZXJhdG9yLFxuICAkYml0c0FueVNldDogaGFuZGxlQml0d2lzZU9wZXJhdG9yLFxuICAkYWxsOiBoYW5kbGVBcnJheSxcbiAgJGd0OiBoYW5kbGVTaW5nbGUsXG4gICRndGU6IGhhbmRsZVNpbmdsZSxcbiAgJGluOiBoYW5kbGVBcnJheSxcbiAgJGx0OiBoYW5kbGVTaW5nbGUsXG4gICRsdGU6IGhhbmRsZVNpbmdsZSxcbiAgJG5lOiBoYW5kbGVTaW5nbGUsXG4gICRuaW46IGhhbmRsZUFycmF5XG59O1xuXG4vKipcbiAqIENhc3RzIGNvbnRlbnRzIGZvciBxdWVyaWVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSAkY29uZGl0aW9uYWxcbiAqIEBwYXJhbSB7YW55fSB2YWxcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNjaGVtYVVVSUQucHJvdG90eXBlLmNhc3RGb3JRdWVyeSA9IGZ1bmN0aW9uKCRjb25kaXRpb25hbCwgdmFsLCBjb250ZXh0KSB7XG4gIGxldCBoYW5kbGVyO1xuICBpZiAoJGNvbmRpdGlvbmFsICE9IG51bGwpIHtcbiAgICBoYW5kbGVyID0gdGhpcy4kY29uZGl0aW9uYWxIYW5kbGVyc1skY29uZGl0aW9uYWxdO1xuICAgIGlmICghaGFuZGxlcilcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCB1c2UgJyArICRjb25kaXRpb25hbCArICcgd2l0aCBVVUlELicpO1xuICAgIHJldHVybiBoYW5kbGVyLmNhbGwodGhpcywgdmFsLCBjb250ZXh0KTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIHRoaXMuYXBwbHlTZXR0ZXJzKHZhbCwgY29udGV4dCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBDYXN0RXJyb3IgJiYgZXJyLnBhdGggPT09IHRoaXMucGF0aCAmJiB0aGlzLiRmdWxsUGF0aCAhPSBudWxsKSB7XG4gICAgICBlcnIucGF0aCA9IHRoaXMuJGZ1bGxQYXRoO1xuICAgIH1cbiAgICB0aHJvdyBlcnI7XG4gIH1cbn07XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFVVUlEO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/schema/uuid.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/stateMachine.js":
/*!************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/stateMachine.js ***!
  \************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Module dependencies.\n */\n\n\n\nconst utils = __webpack_require__(/*! ./utils */ \"../backend/node_modules/mongoose/lib/utils.js\"); // eslint-disable-line no-unused-vars\n\n/**\n * StateMachine represents a minimal `interface` for the\n * constructors it builds via StateMachine.ctor(...).\n *\n * @api private\n */\n\nconst StateMachine = module.exports = exports = function StateMachine() {\n};\n\n/**\n * StateMachine.ctor('state1', 'state2', ...)\n * A factory method for subclassing StateMachine.\n * The arguments are a list of states. For each state,\n * the constructor's prototype gets state transition\n * methods named after each state. These transition methods\n * place their path argument into the given state.\n *\n * @param {String} state\n * @param {String} [state]\n * @return {Function} subclass constructor\n * @api private\n */\n\nStateMachine.ctor = function() {\n  const states = [...arguments];\n\n  const ctor = function() {\n    StateMachine.apply(this, arguments);\n    this.paths = {};\n    this.states = {};\n  };\n\n  ctor.prototype = new StateMachine();\n\n  ctor.prototype.stateNames = states;\n\n  states.forEach(function(state) {\n    // Changes the `path`'s state to `state`.\n    ctor.prototype[state] = function(path) {\n      this._changeState(path, state);\n    };\n  });\n\n  return ctor;\n};\n\n/**\n * This function is wrapped by the state change functions:\n *\n * - `require(path)`\n * - `modify(path)`\n * - `init(path)`\n *\n * @api private\n */\n\nStateMachine.prototype._changeState = function _changeState(path, nextState) {\n  const prevState = this.paths[path];\n  if (prevState === nextState) {\n    return;\n  }\n  const prevBucket = this.states[prevState];\n  if (prevBucket) delete prevBucket[path];\n\n  this.paths[path] = nextState;\n  this.states[nextState] = this.states[nextState] || {};\n  this.states[nextState][path] = true;\n};\n\n/*!\n * ignore\n */\n\nStateMachine.prototype.clear = function clear(state) {\n  if (this.states[state] == null) {\n    return;\n  }\n  const keys = Object.keys(this.states[state]);\n  let i = keys.length;\n  let path;\n\n  while (i--) {\n    path = keys[i];\n    delete this.states[state][path];\n    delete this.paths[path];\n  }\n};\n\n/*!\n * ignore\n */\n\nStateMachine.prototype.clearPath = function clearPath(path) {\n  const state = this.paths[path];\n  if (!state) {\n    return;\n  }\n  delete this.paths[path];\n  delete this.states[state][path];\n};\n\n/**\n * Gets the paths for the given state, or empty object `{}` if none.\n * @api private\n */\n\nStateMachine.prototype.getStatePaths = function getStatePaths(state) {\n  if (this.states[state] != null) {\n    return this.states[state];\n  }\n  return {};\n};\n\n/**\n * Checks to see if at least one path is in the states passed in via `arguments`\n * e.g., this.some('required', 'inited')\n *\n * @param {String} state that we want to check for.\n * @api private\n */\n\nStateMachine.prototype.some = function some() {\n  const _this = this;\n  const what = arguments.length ? arguments : this.stateNames;\n  return Array.prototype.some.call(what, function(state) {\n    if (_this.states[state] == null) {\n      return false;\n    }\n    return Object.keys(_this.states[state]).length;\n  });\n};\n\n/**\n * This function builds the functions that get assigned to `forEach` and `map`,\n * since both of those methods share a lot of the same logic.\n *\n * @param {String} iterMethod is either 'forEach' or 'map'\n * @return {Function}\n * @api private\n */\n\nStateMachine.prototype._iter = function _iter(iterMethod) {\n  return function() {\n    let states = [...arguments];\n    const callback = states.pop();\n\n    if (!states.length) states = this.stateNames;\n\n    const _this = this;\n\n    const paths = states.reduce(function(paths, state) {\n      if (_this.states[state] == null) {\n        return paths;\n      }\n      return paths.concat(Object.keys(_this.states[state]));\n    }, []);\n\n    return paths[iterMethod](function(path, i, paths) {\n      return callback(path, i, paths);\n    });\n  };\n};\n\n/**\n * Iterates over the paths that belong to one of the parameter states.\n *\n * The function profile can look like:\n * this.forEach(state1, fn);         // iterates over all paths in state1\n * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2\n * this.forEach(fn);                 // iterates over all paths in all states\n *\n * @param {String} [state]\n * @param {String} [state]\n * @param {Function} callback\n * @api private\n */\n\nStateMachine.prototype.forEach = function forEach() {\n  this.forEach = this._iter('forEach');\n  return this.forEach.apply(this, arguments);\n};\n\n/**\n * Maps over the paths that belong to one of the parameter states.\n *\n * The function profile can look like:\n * this.forEach(state1, fn);         // iterates over all paths in state1\n * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2\n * this.forEach(fn);                 // iterates over all paths in all states\n *\n * @param {String} [state]\n * @param {String} [state]\n * @param {Function} callback\n * @return {Array}\n * @api private\n */\n\nStateMachine.prototype.map = function map() {\n  this.map = this._iter('map');\n  return this.map.apply(this, arguments);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3N0YXRlTWFjaGluZS5qcyIsIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyw4REFBUyxHQUFHOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFVBQVU7QUFDdEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQyxxQ0FBcUM7QUFDckM7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQyxxQ0FBcUM7QUFDckM7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi9zdGF0ZU1hY2hpbmUuanM/ZDFkNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbi8qKlxuICogU3RhdGVNYWNoaW5lIHJlcHJlc2VudHMgYSBtaW5pbWFsIGBpbnRlcmZhY2VgIGZvciB0aGVcbiAqIGNvbnN0cnVjdG9ycyBpdCBidWlsZHMgdmlhIFN0YXRlTWFjaGluZS5jdG9yKC4uLikuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuY29uc3QgU3RhdGVNYWNoaW5lID0gbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZnVuY3Rpb24gU3RhdGVNYWNoaW5lKCkge1xufTtcblxuLyoqXG4gKiBTdGF0ZU1hY2hpbmUuY3Rvcignc3RhdGUxJywgJ3N0YXRlMicsIC4uLilcbiAqIEEgZmFjdG9yeSBtZXRob2QgZm9yIHN1YmNsYXNzaW5nIFN0YXRlTWFjaGluZS5cbiAqIFRoZSBhcmd1bWVudHMgYXJlIGEgbGlzdCBvZiBzdGF0ZXMuIEZvciBlYWNoIHN0YXRlLFxuICogdGhlIGNvbnN0cnVjdG9yJ3MgcHJvdG90eXBlIGdldHMgc3RhdGUgdHJhbnNpdGlvblxuICogbWV0aG9kcyBuYW1lZCBhZnRlciBlYWNoIHN0YXRlLiBUaGVzZSB0cmFuc2l0aW9uIG1ldGhvZHNcbiAqIHBsYWNlIHRoZWlyIHBhdGggYXJndW1lbnQgaW50byB0aGUgZ2l2ZW4gc3RhdGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gW3N0YXRlXVxuICogQHJldHVybiB7RnVuY3Rpb259IHN1YmNsYXNzIGNvbnN0cnVjdG9yXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TdGF0ZU1hY2hpbmUuY3RvciA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBzdGF0ZXMgPSBbLi4uYXJndW1lbnRzXTtcblxuICBjb25zdCBjdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgU3RhdGVNYWNoaW5lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5wYXRocyA9IHt9O1xuICAgIHRoaXMuc3RhdGVzID0ge307XG4gIH07XG5cbiAgY3Rvci5wcm90b3R5cGUgPSBuZXcgU3RhdGVNYWNoaW5lKCk7XG5cbiAgY3Rvci5wcm90b3R5cGUuc3RhdGVOYW1lcyA9IHN0YXRlcztcblxuICBzdGF0ZXMuZm9yRWFjaChmdW5jdGlvbihzdGF0ZSkge1xuICAgIC8vIENoYW5nZXMgdGhlIGBwYXRoYCdzIHN0YXRlIHRvIGBzdGF0ZWAuXG4gICAgY3Rvci5wcm90b3R5cGVbc3RhdGVdID0gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgdGhpcy5fY2hhbmdlU3RhdGUocGF0aCwgc3RhdGUpO1xuICAgIH07XG4gIH0pO1xuXG4gIHJldHVybiBjdG9yO1xufTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHdyYXBwZWQgYnkgdGhlIHN0YXRlIGNoYW5nZSBmdW5jdGlvbnM6XG4gKlxuICogLSBgcmVxdWlyZShwYXRoKWBcbiAqIC0gYG1vZGlmeShwYXRoKWBcbiAqIC0gYGluaXQocGF0aClgXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU3RhdGVNYWNoaW5lLnByb3RvdHlwZS5fY2hhbmdlU3RhdGUgPSBmdW5jdGlvbiBfY2hhbmdlU3RhdGUocGF0aCwgbmV4dFN0YXRlKSB7XG4gIGNvbnN0IHByZXZTdGF0ZSA9IHRoaXMucGF0aHNbcGF0aF07XG4gIGlmIChwcmV2U3RhdGUgPT09IG5leHRTdGF0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwcmV2QnVja2V0ID0gdGhpcy5zdGF0ZXNbcHJldlN0YXRlXTtcbiAgaWYgKHByZXZCdWNrZXQpIGRlbGV0ZSBwcmV2QnVja2V0W3BhdGhdO1xuXG4gIHRoaXMucGF0aHNbcGF0aF0gPSBuZXh0U3RhdGU7XG4gIHRoaXMuc3RhdGVzW25leHRTdGF0ZV0gPSB0aGlzLnN0YXRlc1tuZXh0U3RhdGVdIHx8IHt9O1xuICB0aGlzLnN0YXRlc1tuZXh0U3RhdGVdW3BhdGhdID0gdHJ1ZTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU3RhdGVNYWNoaW5lLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKHN0YXRlKSB7XG4gIGlmICh0aGlzLnN0YXRlc1tzdGF0ZV0gPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5zdGF0ZXNbc3RhdGVdKTtcbiAgbGV0IGkgPSBrZXlzLmxlbmd0aDtcbiAgbGV0IHBhdGg7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIHBhdGggPSBrZXlzW2ldO1xuICAgIGRlbGV0ZSB0aGlzLnN0YXRlc1tzdGF0ZV1bcGF0aF07XG4gICAgZGVsZXRlIHRoaXMucGF0aHNbcGF0aF07XG4gIH1cbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU3RhdGVNYWNoaW5lLnByb3RvdHlwZS5jbGVhclBhdGggPSBmdW5jdGlvbiBjbGVhclBhdGgocGF0aCkge1xuICBjb25zdCBzdGF0ZSA9IHRoaXMucGF0aHNbcGF0aF07XG4gIGlmICghc3RhdGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZGVsZXRlIHRoaXMucGF0aHNbcGF0aF07XG4gIGRlbGV0ZSB0aGlzLnN0YXRlc1tzdGF0ZV1bcGF0aF07XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIHBhdGhzIGZvciB0aGUgZ2l2ZW4gc3RhdGUsIG9yIGVtcHR5IG9iamVjdCBge31gIGlmIG5vbmUuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TdGF0ZU1hY2hpbmUucHJvdG90eXBlLmdldFN0YXRlUGF0aHMgPSBmdW5jdGlvbiBnZXRTdGF0ZVBhdGhzKHN0YXRlKSB7XG4gIGlmICh0aGlzLnN0YXRlc1tzdGF0ZV0gIT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlc1tzdGF0ZV07XG4gIH1cbiAgcmV0dXJuIHt9O1xufTtcblxuLyoqXG4gKiBDaGVja3MgdG8gc2VlIGlmIGF0IGxlYXN0IG9uZSBwYXRoIGlzIGluIHRoZSBzdGF0ZXMgcGFzc2VkIGluIHZpYSBgYXJndW1lbnRzYFxuICogZS5nLiwgdGhpcy5zb21lKCdyZXF1aXJlZCcsICdpbml0ZWQnKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdGF0ZSB0aGF0IHdlIHdhbnQgdG8gY2hlY2sgZm9yLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU3RhdGVNYWNoaW5lLnByb3RvdHlwZS5zb21lID0gZnVuY3Rpb24gc29tZSgpIHtcbiAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICBjb25zdCB3aGF0ID0gYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50cyA6IHRoaXMuc3RhdGVOYW1lcztcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zb21lLmNhbGwod2hhdCwgZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBpZiAoX3RoaXMuc3RhdGVzW3N0YXRlXSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyhfdGhpcy5zdGF0ZXNbc3RhdGVdKS5sZW5ndGg7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGJ1aWxkcyB0aGUgZnVuY3Rpb25zIHRoYXQgZ2V0IGFzc2lnbmVkIHRvIGBmb3JFYWNoYCBhbmQgYG1hcGAsXG4gKiBzaW5jZSBib3RoIG9mIHRob3NlIG1ldGhvZHMgc2hhcmUgYSBsb3Qgb2YgdGhlIHNhbWUgbG9naWMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGl0ZXJNZXRob2QgaXMgZWl0aGVyICdmb3JFYWNoJyBvciAnbWFwJ1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TdGF0ZU1hY2hpbmUucHJvdG90eXBlLl9pdGVyID0gZnVuY3Rpb24gX2l0ZXIoaXRlck1ldGhvZCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgbGV0IHN0YXRlcyA9IFsuLi5hcmd1bWVudHNdO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gc3RhdGVzLnBvcCgpO1xuXG4gICAgaWYgKCFzdGF0ZXMubGVuZ3RoKSBzdGF0ZXMgPSB0aGlzLnN0YXRlTmFtZXM7XG5cbiAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG5cbiAgICBjb25zdCBwYXRocyA9IHN0YXRlcy5yZWR1Y2UoZnVuY3Rpb24ocGF0aHMsIHN0YXRlKSB7XG4gICAgICBpZiAoX3RoaXMuc3RhdGVzW3N0YXRlXSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBwYXRocztcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXRocy5jb25jYXQoT2JqZWN0LmtleXMoX3RoaXMuc3RhdGVzW3N0YXRlXSkpO1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiBwYXRoc1tpdGVyTWV0aG9kXShmdW5jdGlvbihwYXRoLCBpLCBwYXRocykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHBhdGgsIGksIHBhdGhzKTtcbiAgICB9KTtcbiAgfTtcbn07XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciB0aGUgcGF0aHMgdGhhdCBiZWxvbmcgdG8gb25lIG9mIHRoZSBwYXJhbWV0ZXIgc3RhdGVzLlxuICpcbiAqIFRoZSBmdW5jdGlvbiBwcm9maWxlIGNhbiBsb29rIGxpa2U6XG4gKiB0aGlzLmZvckVhY2goc3RhdGUxLCBmbik7ICAgICAgICAgLy8gaXRlcmF0ZXMgb3ZlciBhbGwgcGF0aHMgaW4gc3RhdGUxXG4gKiB0aGlzLmZvckVhY2goc3RhdGUxLCBzdGF0ZTIsIGZuKTsgLy8gaXRlcmF0ZXMgb3ZlciBhbGwgcGF0aHMgaW4gc3RhdGUxIG9yIHN0YXRlMlxuICogdGhpcy5mb3JFYWNoKGZuKTsgICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGVzIG92ZXIgYWxsIHBhdGhzIGluIGFsbCBzdGF0ZXNcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3N0YXRlXVxuICogQHBhcmFtIHtTdHJpbmd9IFtzdGF0ZV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5TdGF0ZU1hY2hpbmUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKCkge1xuICB0aGlzLmZvckVhY2ggPSB0aGlzLl9pdGVyKCdmb3JFYWNoJyk7XG4gIHJldHVybiB0aGlzLmZvckVhY2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogTWFwcyBvdmVyIHRoZSBwYXRocyB0aGF0IGJlbG9uZyB0byBvbmUgb2YgdGhlIHBhcmFtZXRlciBzdGF0ZXMuXG4gKlxuICogVGhlIGZ1bmN0aW9uIHByb2ZpbGUgY2FuIGxvb2sgbGlrZTpcbiAqIHRoaXMuZm9yRWFjaChzdGF0ZTEsIGZuKTsgICAgICAgICAvLyBpdGVyYXRlcyBvdmVyIGFsbCBwYXRocyBpbiBzdGF0ZTFcbiAqIHRoaXMuZm9yRWFjaChzdGF0ZTEsIHN0YXRlMiwgZm4pOyAvLyBpdGVyYXRlcyBvdmVyIGFsbCBwYXRocyBpbiBzdGF0ZTEgb3Igc3RhdGUyXG4gKiB0aGlzLmZvckVhY2goZm4pOyAgICAgICAgICAgICAgICAgLy8gaXRlcmF0ZXMgb3ZlciBhbGwgcGF0aHMgaW4gYWxsIHN0YXRlc1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc3RhdGVdXG4gKiBAcGFyYW0ge1N0cmluZ30gW3N0YXRlXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU3RhdGVNYWNoaW5lLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBtYXAoKSB7XG4gIHRoaXMubWFwID0gdGhpcy5faXRlcignbWFwJyk7XG4gIHJldHVybiB0aGlzLm1hcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/stateMachine.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/types/arraySubdocument.js":
/*!**********************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/types/arraySubdocument.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Subdocument = __webpack_require__(/*! ./subdocument */ \"../backend/node_modules/mongoose/lib/types/subdocument.js\");\nconst utils = __webpack_require__(/*! ../utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\n\nconst documentArrayParent = (__webpack_require__(/*! ../helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").documentArrayParent);\n\n/**\n * A constructor.\n *\n * @param {Object} obj js object returned from the db\n * @param {MongooseDocumentArray} parentArr the parent array of this document\n * @param {Boolean} skipId\n * @param {Object} fields\n * @param {Number} index\n * @inherits Document\n * @api private\n */\n\nfunction ArraySubdocument(obj, parentArr, skipId, fields, index) {\n  if (utils.isMongooseDocumentArray(parentArr)) {\n    this.__parentArray = parentArr;\n    this[documentArrayParent] = parentArr.$parent();\n  } else {\n    this.__parentArray = undefined;\n    this[documentArrayParent] = undefined;\n  }\n  this.$setIndex(index);\n  this.$__parent = this[documentArrayParent];\n\n  let options;\n  if (typeof skipId === 'object' && skipId != null) {\n    options = { isNew: true, ...skipId };\n    skipId = undefined;\n  } else {\n    options = { isNew: true };\n  }\n\n  Subdocument.call(this, obj, fields, this[documentArrayParent], skipId, options);\n}\n\n/*!\n * Inherit from Subdocument\n */\nArraySubdocument.prototype = Object.create(Subdocument.prototype);\nArraySubdocument.prototype.constructor = ArraySubdocument;\n\nObject.defineProperty(ArraySubdocument.prototype, '$isSingleNested', {\n  configurable: false,\n  writable: false,\n  value: false\n});\n\nObject.defineProperty(ArraySubdocument.prototype, '$isDocumentArrayElement', {\n  configurable: false,\n  writable: false,\n  value: true\n});\n\nfor (const i in EventEmitter.prototype) {\n  ArraySubdocument[i] = EventEmitter.prototype[i];\n}\n\n/*!\n * ignore\n */\n\nArraySubdocument.prototype.$setIndex = function(index) {\n  this.__index = index;\n\n  if (this.$__ != null && this.$__.validationError != null) {\n    const keys = Object.keys(this.$__.validationError.errors);\n    for (const key of keys) {\n      this.invalidate(key, this.$__.validationError.errors[key]);\n    }\n  }\n};\n\n/*!\n * ignore\n */\n\nArraySubdocument.prototype.populate = function() {\n  throw new Error('Mongoose does not support calling populate() on nested ' +\n    'docs. Instead of `doc.arr[0].populate(\"path\")`, use ' +\n    '`doc.populate(\"arr.0.path\")`');\n};\n\n/*!\n * ignore\n */\n\nArraySubdocument.prototype.$__removeFromParent = function() {\n  const _id = this._doc._id;\n  if (!_id) {\n    throw new Error('For your own good, Mongoose does not know ' +\n      'how to remove an ArraySubdocument that has no _id');\n  }\n  this.__parentArray.pull({ _id: _id });\n};\n\n/**\n * Returns the full path to this document. If optional `path` is passed, it is appended to the full path.\n *\n * @param {String} [path]\n * @param {Boolean} [skipIndex] Skip adding the array index. For example `arr.foo` instead of `arr.0.foo`.\n * @return {String}\n * @api private\n * @method $__fullPath\n * @memberOf ArraySubdocument\n * @instance\n */\n\nArraySubdocument.prototype.$__fullPath = function(path, skipIndex) {\n  if (this.__index == null) {\n    return null;\n  }\n  if (!this.$__.fullPath) {\n    this.ownerDocument();\n  }\n\n  if (skipIndex) {\n    return path ?\n      this.$__.fullPath + '.' + path :\n      this.$__.fullPath;\n  }\n\n  return path ?\n    this.$__.fullPath + '.' + this.__index + '.' + path :\n    this.$__.fullPath + '.' + this.__index;\n};\n\n/**\n * Given a path relative to this document, return the path relative\n * to the top-level document.\n * @method $__pathRelativeToParent\n * @memberOf ArraySubdocument\n * @instance\n * @api private\n */\n\nArraySubdocument.prototype.$__pathRelativeToParent = function(path, skipIndex) {\n  if (this.__index == null || (!this.__parentArray || !this.__parentArray.$path)) {\n    return null;\n  }\n  if (skipIndex) {\n    return path == null ? this.__parentArray.$path() : this.__parentArray.$path() + '.' + path;\n  }\n  if (path == null) {\n    return this.__parentArray.$path() + '.' + this.__index;\n  }\n  return this.__parentArray.$path() + '.' + this.__index + '.' + path;\n};\n\n/**\n * Returns this sub-documents parent document.\n * @method $parent\n * @memberOf ArraySubdocument\n * @instance\n * @api public\n */\n\nArraySubdocument.prototype.$parent = function() {\n  return this[documentArrayParent];\n};\n\n/**\n * Returns this subdocument's parent array.\n *\n * #### Example:\n *\n *     const Test = mongoose.model('Test', new Schema({\n *       docArr: [{ name: String }]\n *     }));\n *     const doc = new Test({ docArr: [{ name: 'test subdoc' }] });\n *\n *     doc.docArr[0].parentArray() === doc.docArr; // true\n *\n * @api public\n * @method parentArray\n * @returns DocumentArray\n */\n\nArraySubdocument.prototype.parentArray = function() {\n  return this.__parentArray;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = ArraySubdocument;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL2FycmF5U3ViZG9jdW1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVhOztBQUViLHFCQUFxQiwwREFBOEI7QUFDbkQsb0JBQW9CLG1CQUFPLENBQUMsZ0ZBQWU7QUFDM0MsY0FBYyxtQkFBTyxDQUFDLCtEQUFVOztBQUVoQyw0QkFBNEIsOEhBQWlEOztBQUU3RTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLElBQUk7QUFDSixnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDLFFBQVE7QUFDUiw4QkFBOEIsV0FBVyxxQkFBcUIsR0FBRztBQUNqRTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdHlwZXMvYXJyYXlTdWJkb2N1bWVudC5qcz8xZDYxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbmNvbnN0IFN1YmRvY3VtZW50ID0gcmVxdWlyZSgnLi9zdWJkb2N1bWVudCcpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5jb25zdCBkb2N1bWVudEFycmF5UGFyZW50ID0gcmVxdWlyZSgnLi4vaGVscGVycy9zeW1ib2xzJykuZG9jdW1lbnRBcnJheVBhcmVudDtcblxuLyoqXG4gKiBBIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoganMgb2JqZWN0IHJldHVybmVkIGZyb20gdGhlIGRiXG4gKiBAcGFyYW0ge01vbmdvb3NlRG9jdW1lbnRBcnJheX0gcGFyZW50QXJyIHRoZSBwYXJlbnQgYXJyYXkgb2YgdGhpcyBkb2N1bWVudFxuICogQHBhcmFtIHtCb29sZWFufSBza2lwSWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBmaWVsZHNcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICogQGluaGVyaXRzIERvY3VtZW50XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBBcnJheVN1YmRvY3VtZW50KG9iaiwgcGFyZW50QXJyLCBza2lwSWQsIGZpZWxkcywgaW5kZXgpIHtcbiAgaWYgKHV0aWxzLmlzTW9uZ29vc2VEb2N1bWVudEFycmF5KHBhcmVudEFycikpIHtcbiAgICB0aGlzLl9fcGFyZW50QXJyYXkgPSBwYXJlbnRBcnI7XG4gICAgdGhpc1tkb2N1bWVudEFycmF5UGFyZW50XSA9IHBhcmVudEFyci4kcGFyZW50KCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fX3BhcmVudEFycmF5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXNbZG9jdW1lbnRBcnJheVBhcmVudF0gPSB1bmRlZmluZWQ7XG4gIH1cbiAgdGhpcy4kc2V0SW5kZXgoaW5kZXgpO1xuICB0aGlzLiRfX3BhcmVudCA9IHRoaXNbZG9jdW1lbnRBcnJheVBhcmVudF07XG5cbiAgbGV0IG9wdGlvbnM7XG4gIGlmICh0eXBlb2Ygc2tpcElkID09PSAnb2JqZWN0JyAmJiBza2lwSWQgIT0gbnVsbCkge1xuICAgIG9wdGlvbnMgPSB7IGlzTmV3OiB0cnVlLCAuLi5za2lwSWQgfTtcbiAgICBza2lwSWQgPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucyA9IHsgaXNOZXc6IHRydWUgfTtcbiAgfVxuXG4gIFN1YmRvY3VtZW50LmNhbGwodGhpcywgb2JqLCBmaWVsZHMsIHRoaXNbZG9jdW1lbnRBcnJheVBhcmVudF0sIHNraXBJZCwgb3B0aW9ucyk7XG59XG5cbi8qIVxuICogSW5oZXJpdCBmcm9tIFN1YmRvY3VtZW50XG4gKi9cbkFycmF5U3ViZG9jdW1lbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdWJkb2N1bWVudC5wcm90b3R5cGUpO1xuQXJyYXlTdWJkb2N1bWVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBcnJheVN1YmRvY3VtZW50O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQXJyYXlTdWJkb2N1bWVudC5wcm90b3R5cGUsICckaXNTaW5nbGVOZXN0ZWQnLCB7XG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIHdyaXRhYmxlOiBmYWxzZSxcbiAgdmFsdWU6IGZhbHNlXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5U3ViZG9jdW1lbnQucHJvdG90eXBlLCAnJGlzRG9jdW1lbnRBcnJheUVsZW1lbnQnLCB7XG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIHdyaXRhYmxlOiBmYWxzZSxcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5mb3IgKGNvbnN0IGkgaW4gRXZlbnRFbWl0dGVyLnByb3RvdHlwZSkge1xuICBBcnJheVN1YmRvY3VtZW50W2ldID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZVtpXTtcbn1cblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5BcnJheVN1YmRvY3VtZW50LnByb3RvdHlwZS4kc2V0SW5kZXggPSBmdW5jdGlvbihpbmRleCkge1xuICB0aGlzLl9faW5kZXggPSBpbmRleDtcblxuICBpZiAodGhpcy4kX18gIT0gbnVsbCAmJiB0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3IgIT0gbnVsbCkge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3IuZXJyb3JzKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICB0aGlzLmludmFsaWRhdGUoa2V5LCB0aGlzLiRfXy52YWxpZGF0aW9uRXJyb3IuZXJyb3JzW2tleV0pO1xuICAgIH1cbiAgfVxufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5BcnJheVN1YmRvY3VtZW50LnByb3RvdHlwZS5wb3B1bGF0ZSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ01vbmdvb3NlIGRvZXMgbm90IHN1cHBvcnQgY2FsbGluZyBwb3B1bGF0ZSgpIG9uIG5lc3RlZCAnICtcbiAgICAnZG9jcy4gSW5zdGVhZCBvZiBgZG9jLmFyclswXS5wb3B1bGF0ZShcInBhdGhcIilgLCB1c2UgJyArXG4gICAgJ2Bkb2MucG9wdWxhdGUoXCJhcnIuMC5wYXRoXCIpYCcpO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5BcnJheVN1YmRvY3VtZW50LnByb3RvdHlwZS4kX19yZW1vdmVGcm9tUGFyZW50ID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IF9pZCA9IHRoaXMuX2RvYy5faWQ7XG4gIGlmICghX2lkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGb3IgeW91ciBvd24gZ29vZCwgTW9uZ29vc2UgZG9lcyBub3Qga25vdyAnICtcbiAgICAgICdob3cgdG8gcmVtb3ZlIGFuIEFycmF5U3ViZG9jdW1lbnQgdGhhdCBoYXMgbm8gX2lkJyk7XG4gIH1cbiAgdGhpcy5fX3BhcmVudEFycmF5LnB1bGwoeyBfaWQ6IF9pZCB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZnVsbCBwYXRoIHRvIHRoaXMgZG9jdW1lbnQuIElmIG9wdGlvbmFsIGBwYXRoYCBpcyBwYXNzZWQsIGl0IGlzIGFwcGVuZGVkIHRvIHRoZSBmdWxsIHBhdGguXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwYXRoXVxuICogQHBhcmFtIHtCb29sZWFufSBbc2tpcEluZGV4XSBTa2lwIGFkZGluZyB0aGUgYXJyYXkgaW5kZXguIEZvciBleGFtcGxlIGBhcnIuZm9vYCBpbnN0ZWFkIG9mIGBhcnIuMC5mb29gLlxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKiBAbWV0aG9kICRfX2Z1bGxQYXRoXG4gKiBAbWVtYmVyT2YgQXJyYXlTdWJkb2N1bWVudFxuICogQGluc3RhbmNlXG4gKi9cblxuQXJyYXlTdWJkb2N1bWVudC5wcm90b3R5cGUuJF9fZnVsbFBhdGggPSBmdW5jdGlvbihwYXRoLCBza2lwSW5kZXgpIHtcbiAgaWYgKHRoaXMuX19pbmRleCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKCF0aGlzLiRfXy5mdWxsUGF0aCkge1xuICAgIHRoaXMub3duZXJEb2N1bWVudCgpO1xuICB9XG5cbiAgaWYgKHNraXBJbmRleCkge1xuICAgIHJldHVybiBwYXRoID9cbiAgICAgIHRoaXMuJF9fLmZ1bGxQYXRoICsgJy4nICsgcGF0aCA6XG4gICAgICB0aGlzLiRfXy5mdWxsUGF0aDtcbiAgfVxuXG4gIHJldHVybiBwYXRoID9cbiAgICB0aGlzLiRfXy5mdWxsUGF0aCArICcuJyArIHRoaXMuX19pbmRleCArICcuJyArIHBhdGggOlxuICAgIHRoaXMuJF9fLmZ1bGxQYXRoICsgJy4nICsgdGhpcy5fX2luZGV4O1xufTtcblxuLyoqXG4gKiBHaXZlbiBhIHBhdGggcmVsYXRpdmUgdG8gdGhpcyBkb2N1bWVudCwgcmV0dXJuIHRoZSBwYXRoIHJlbGF0aXZlXG4gKiB0byB0aGUgdG9wLWxldmVsIGRvY3VtZW50LlxuICogQG1ldGhvZCAkX19wYXRoUmVsYXRpdmVUb1BhcmVudFxuICogQG1lbWJlck9mIEFycmF5U3ViZG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQXJyYXlTdWJkb2N1bWVudC5wcm90b3R5cGUuJF9fcGF0aFJlbGF0aXZlVG9QYXJlbnQgPSBmdW5jdGlvbihwYXRoLCBza2lwSW5kZXgpIHtcbiAgaWYgKHRoaXMuX19pbmRleCA9PSBudWxsIHx8ICghdGhpcy5fX3BhcmVudEFycmF5IHx8ICF0aGlzLl9fcGFyZW50QXJyYXkuJHBhdGgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHNraXBJbmRleCkge1xuICAgIHJldHVybiBwYXRoID09IG51bGwgPyB0aGlzLl9fcGFyZW50QXJyYXkuJHBhdGgoKSA6IHRoaXMuX19wYXJlbnRBcnJheS4kcGF0aCgpICsgJy4nICsgcGF0aDtcbiAgfVxuICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuX19wYXJlbnRBcnJheS4kcGF0aCgpICsgJy4nICsgdGhpcy5fX2luZGV4O1xuICB9XG4gIHJldHVybiB0aGlzLl9fcGFyZW50QXJyYXkuJHBhdGgoKSArICcuJyArIHRoaXMuX19pbmRleCArICcuJyArIHBhdGg7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBzdWItZG9jdW1lbnRzIHBhcmVudCBkb2N1bWVudC5cbiAqIEBtZXRob2QgJHBhcmVudFxuICogQG1lbWJlck9mIEFycmF5U3ViZG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5BcnJheVN1YmRvY3VtZW50LnByb3RvdHlwZS4kcGFyZW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzW2RvY3VtZW50QXJyYXlQYXJlbnRdO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgc3ViZG9jdW1lbnQncyBwYXJlbnQgYXJyYXkuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBUZXN0ID0gbW9uZ29vc2UubW9kZWwoJ1Rlc3QnLCBuZXcgU2NoZW1hKHtcbiAqICAgICAgIGRvY0FycjogW3sgbmFtZTogU3RyaW5nIH1dXG4gKiAgICAgfSkpO1xuICogICAgIGNvbnN0IGRvYyA9IG5ldyBUZXN0KHsgZG9jQXJyOiBbeyBuYW1lOiAndGVzdCBzdWJkb2MnIH1dIH0pO1xuICpcbiAqICAgICBkb2MuZG9jQXJyWzBdLnBhcmVudEFycmF5KCkgPT09IGRvYy5kb2NBcnI7IC8vIHRydWVcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCBwYXJlbnRBcnJheVxuICogQHJldHVybnMgRG9jdW1lbnRBcnJheVxuICovXG5cbkFycmF5U3ViZG9jdW1lbnQucHJvdG90eXBlLnBhcmVudEFycmF5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9fcGFyZW50QXJyYXk7XG59O1xuXG4vKiFcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXlTdWJkb2N1bWVudDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/types/arraySubdocument.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/types/array/index.js":
/*!*****************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/types/array/index.js ***!
  \*****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst Document = __webpack_require__(/*! ../../document */ \"../backend/node_modules/mongoose/lib/document.js\");\nconst mongooseArrayMethods = __webpack_require__(/*! ./methods */ \"../backend/node_modules/mongoose/lib/types/array/methods/index.js\");\n\nconst arrayAtomicsSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsSymbol);\nconst arrayAtomicsBackupSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsBackupSymbol);\nconst arrayParentSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").arrayParentSymbol);\nconst arrayPathSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").arrayPathSymbol);\nconst arraySchemaSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").arraySchemaSymbol);\n\n/**\n * Mongoose Array constructor.\n *\n * #### Note:\n *\n * _Values always have to be passed to the constructor to initialize, otherwise `MongooseArray#push` will mark the array as modified._\n *\n * @param {Array} values\n * @param {String} path\n * @param {Document} doc parent document\n * @api private\n * @inherits Array https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array\n * @see https://bit.ly/f6CnZU\n */\nconst _basePush = Array.prototype.push;\nconst numberRE = /^\\d+$/;\n\nfunction MongooseArray(values, path, doc, schematype) {\n  let __array;\n\n  if (Array.isArray(values)) {\n    const len = values.length;\n\n    // Perf optimizations for small arrays: much faster to use `...` than `for` + `push`,\n    // but large arrays may cause stack overflows. And for arrays of length 0/1, just\n    // modifying the array is faster. Seems small, but adds up when you have a document\n    // with thousands of nested arrays.\n    if (len === 0) {\n      __array = new Array();\n    } else if (len === 1) {\n      __array = new Array(1);\n      __array[0] = values[0];\n    } else if (len < 10000) {\n      __array = new Array();\n      _basePush.apply(__array, values);\n    } else {\n      __array = new Array();\n      for (let i = 0; i < len; ++i) {\n        _basePush.call(__array, values[i]);\n      }\n    }\n  } else {\n    __array = [];\n  }\n\n  const internals = {\n    [arrayAtomicsSymbol]: {},\n    [arrayAtomicsBackupSymbol]: void 0,\n    [arrayPathSymbol]: path,\n    [arraySchemaSymbol]: schematype,\n    [arrayParentSymbol]: void 0,\n    isMongooseArray: true,\n    isMongooseArrayProxy: true,\n    __array: __array\n  };\n\n  if (values && values[arrayAtomicsSymbol] != null) {\n    internals[arrayAtomicsSymbol] = values[arrayAtomicsSymbol];\n  }\n\n  // Because doc comes from the context of another function, doc === global\n  // can happen if there was a null somewhere up the chain (see #3020)\n  // RB Jun 17, 2015 updated to check for presence of expected paths instead\n  // to make more proof against unusual node environments\n  if (doc != null && doc instanceof Document) {\n    internals[arrayParentSymbol] = doc;\n    internals[arraySchemaSymbol] = schematype || doc.schema.path(path);\n  }\n\n  const proxy = new Proxy(__array, {\n    get: function(target, prop) {\n      if (internals.hasOwnProperty(prop)) {\n        return internals[prop];\n      }\n      if (mongooseArrayMethods.hasOwnProperty(prop)) {\n        return mongooseArrayMethods[prop];\n      }\n      if (typeof prop === 'string' && numberRE.test(prop) && schematype?.$embeddedSchemaType != null) {\n        return schematype.$embeddedSchemaType.applyGetters(__array[prop], doc);\n      }\n\n      return __array[prop];\n    },\n    set: function(target, prop, value) {\n      if (typeof prop === 'string' && numberRE.test(prop)) {\n        mongooseArrayMethods.set.call(proxy, prop, value, false);\n      } else if (internals.hasOwnProperty(prop)) {\n        internals[prop] = value;\n      } else {\n        __array[prop] = value;\n      }\n\n      return true;\n    }\n  });\n\n  return proxy;\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = MongooseArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL2FycmF5L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixpQkFBaUIsbUJBQU8sQ0FBQyx3RUFBZ0I7QUFDekMsNkJBQTZCLG1CQUFPLENBQUMsb0ZBQVc7O0FBRWhELDJCQUEyQixnSUFBbUQ7QUFDOUUsaUNBQWlDLHNJQUF5RDtBQUMxRiwwQkFBMEIsK0hBQWtEO0FBQzVFLHdCQUF3Qiw2SEFBZ0Q7QUFDeEUsMEJBQTBCLCtIQUFrRDs7QUFFNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdHlwZXMvYXJyYXkvaW5kZXguanM/ZmJiZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBEb2N1bWVudCA9IHJlcXVpcmUoJy4uLy4uL2RvY3VtZW50Jyk7XG5jb25zdCBtb25nb29zZUFycmF5TWV0aG9kcyA9IHJlcXVpcmUoJy4vbWV0aG9kcycpO1xuXG5jb25zdCBhcnJheUF0b21pY3NTeW1ib2wgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXJzL3N5bWJvbHMnKS5hcnJheUF0b21pY3NTeW1ib2w7XG5jb25zdCBhcnJheUF0b21pY3NCYWNrdXBTeW1ib2wgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXJzL3N5bWJvbHMnKS5hcnJheUF0b21pY3NCYWNrdXBTeW1ib2w7XG5jb25zdCBhcnJheVBhcmVudFN5bWJvbCA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvc3ltYm9scycpLmFycmF5UGFyZW50U3ltYm9sO1xuY29uc3QgYXJyYXlQYXRoU3ltYm9sID0gcmVxdWlyZSgnLi4vLi4vaGVscGVycy9zeW1ib2xzJykuYXJyYXlQYXRoU3ltYm9sO1xuY29uc3QgYXJyYXlTY2hlbWFTeW1ib2wgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXJzL3N5bWJvbHMnKS5hcnJheVNjaGVtYVN5bWJvbDtcblxuLyoqXG4gKiBNb25nb29zZSBBcnJheSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogX1ZhbHVlcyBhbHdheXMgaGF2ZSB0byBiZSBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yIHRvIGluaXRpYWxpemUsIG90aGVyd2lzZSBgTW9uZ29vc2VBcnJheSNwdXNoYCB3aWxsIG1hcmsgdGhlIGFycmF5IGFzIG1vZGlmaWVkLl9cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBkb2MgcGFyZW50IGRvY3VtZW50XG4gKiBAYXBpIHByaXZhdGVcbiAqIEBpbmhlcml0cyBBcnJheSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheVxuICogQHNlZSBodHRwczovL2JpdC5seS9mNkNuWlVcbiAqL1xuY29uc3QgX2Jhc2VQdXNoID0gQXJyYXkucHJvdG90eXBlLnB1c2g7XG5jb25zdCBudW1iZXJSRSA9IC9eXFxkKyQvO1xuXG5mdW5jdGlvbiBNb25nb29zZUFycmF5KHZhbHVlcywgcGF0aCwgZG9jLCBzY2hlbWF0eXBlKSB7XG4gIGxldCBfX2FycmF5O1xuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICBjb25zdCBsZW4gPSB2YWx1ZXMubGVuZ3RoO1xuXG4gICAgLy8gUGVyZiBvcHRpbWl6YXRpb25zIGZvciBzbWFsbCBhcnJheXM6IG11Y2ggZmFzdGVyIHRvIHVzZSBgLi4uYCB0aGFuIGBmb3JgICsgYHB1c2hgLFxuICAgIC8vIGJ1dCBsYXJnZSBhcnJheXMgbWF5IGNhdXNlIHN0YWNrIG92ZXJmbG93cy4gQW5kIGZvciBhcnJheXMgb2YgbGVuZ3RoIDAvMSwganVzdFxuICAgIC8vIG1vZGlmeWluZyB0aGUgYXJyYXkgaXMgZmFzdGVyLiBTZWVtcyBzbWFsbCwgYnV0IGFkZHMgdXAgd2hlbiB5b3UgaGF2ZSBhIGRvY3VtZW50XG4gICAgLy8gd2l0aCB0aG91c2FuZHMgb2YgbmVzdGVkIGFycmF5cy5cbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICBfX2FycmF5ID0gbmV3IEFycmF5KCk7XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDEpIHtcbiAgICAgIF9fYXJyYXkgPSBuZXcgQXJyYXkoMSk7XG4gICAgICBfX2FycmF5WzBdID0gdmFsdWVzWzBdO1xuICAgIH0gZWxzZSBpZiAobGVuIDwgMTAwMDApIHtcbiAgICAgIF9fYXJyYXkgPSBuZXcgQXJyYXkoKTtcbiAgICAgIF9iYXNlUHVzaC5hcHBseShfX2FycmF5LCB2YWx1ZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfX2FycmF5ID0gbmV3IEFycmF5KCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIF9iYXNlUHVzaC5jYWxsKF9fYXJyYXksIHZhbHVlc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIF9fYXJyYXkgPSBbXTtcbiAgfVxuXG4gIGNvbnN0IGludGVybmFscyA9IHtcbiAgICBbYXJyYXlBdG9taWNzU3ltYm9sXToge30sXG4gICAgW2FycmF5QXRvbWljc0JhY2t1cFN5bWJvbF06IHZvaWQgMCxcbiAgICBbYXJyYXlQYXRoU3ltYm9sXTogcGF0aCxcbiAgICBbYXJyYXlTY2hlbWFTeW1ib2xdOiBzY2hlbWF0eXBlLFxuICAgIFthcnJheVBhcmVudFN5bWJvbF06IHZvaWQgMCxcbiAgICBpc01vbmdvb3NlQXJyYXk6IHRydWUsXG4gICAgaXNNb25nb29zZUFycmF5UHJveHk6IHRydWUsXG4gICAgX19hcnJheTogX19hcnJheVxuICB9O1xuXG4gIGlmICh2YWx1ZXMgJiYgdmFsdWVzW2FycmF5QXRvbWljc1N5bWJvbF0gIT0gbnVsbCkge1xuICAgIGludGVybmFsc1thcnJheUF0b21pY3NTeW1ib2xdID0gdmFsdWVzW2FycmF5QXRvbWljc1N5bWJvbF07XG4gIH1cblxuICAvLyBCZWNhdXNlIGRvYyBjb21lcyBmcm9tIHRoZSBjb250ZXh0IG9mIGFub3RoZXIgZnVuY3Rpb24sIGRvYyA9PT0gZ2xvYmFsXG4gIC8vIGNhbiBoYXBwZW4gaWYgdGhlcmUgd2FzIGEgbnVsbCBzb21ld2hlcmUgdXAgdGhlIGNoYWluIChzZWUgIzMwMjApXG4gIC8vIFJCIEp1biAxNywgMjAxNSB1cGRhdGVkIHRvIGNoZWNrIGZvciBwcmVzZW5jZSBvZiBleHBlY3RlZCBwYXRocyBpbnN0ZWFkXG4gIC8vIHRvIG1ha2UgbW9yZSBwcm9vZiBhZ2FpbnN0IHVudXN1YWwgbm9kZSBlbnZpcm9ubWVudHNcbiAgaWYgKGRvYyAhPSBudWxsICYmIGRvYyBpbnN0YW5jZW9mIERvY3VtZW50KSB7XG4gICAgaW50ZXJuYWxzW2FycmF5UGFyZW50U3ltYm9sXSA9IGRvYztcbiAgICBpbnRlcm5hbHNbYXJyYXlTY2hlbWFTeW1ib2xdID0gc2NoZW1hdHlwZSB8fCBkb2Muc2NoZW1hLnBhdGgocGF0aCk7XG4gIH1cblxuICBjb25zdCBwcm94eSA9IG5ldyBQcm94eShfX2FycmF5LCB7XG4gICAgZ2V0OiBmdW5jdGlvbih0YXJnZXQsIHByb3ApIHtcbiAgICAgIGlmIChpbnRlcm5hbHMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFsc1twcm9wXTtcbiAgICAgIH1cbiAgICAgIGlmIChtb25nb29zZUFycmF5TWV0aG9kcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICByZXR1cm4gbW9uZ29vc2VBcnJheU1ldGhvZHNbcHJvcF07XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnICYmIG51bWJlclJFLnRlc3QocHJvcCkgJiYgc2NoZW1hdHlwZT8uJGVtYmVkZGVkU2NoZW1hVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWF0eXBlLiRlbWJlZGRlZFNjaGVtYVR5cGUuYXBwbHlHZXR0ZXJzKF9fYXJyYXlbcHJvcF0sIGRvYyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfX2FycmF5W3Byb3BdO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnICYmIG51bWJlclJFLnRlc3QocHJvcCkpIHtcbiAgICAgICAgbW9uZ29vc2VBcnJheU1ldGhvZHMuc2V0LmNhbGwocHJveHksIHByb3AsIHZhbHVlLCBmYWxzZSk7XG4gICAgICB9IGVsc2UgaWYgKGludGVybmFscy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICBpbnRlcm5hbHNbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9fYXJyYXlbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcHJveHk7XG59XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gTW9uZ29vc2VBcnJheTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/types/array/index.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/types/array/isMongooseArray.js":
/*!***************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/types/array/isMongooseArray.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.isMongooseArray = function(mongooseArray) {\n  return Array.isArray(mongooseArray) && mongooseArray.isMongooseArray;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL2FycmF5L2lzTW9uZ29vc2VBcnJheS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYix1QkFBdUI7QUFDdkI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi90eXBlcy9hcnJheS9pc01vbmdvb3NlQXJyYXkuanM/ODQwYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuaXNNb25nb29zZUFycmF5ID0gZnVuY3Rpb24obW9uZ29vc2VBcnJheSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShtb25nb29zZUFycmF5KSAmJiBtb25nb29zZUFycmF5LmlzTW9uZ29vc2VBcnJheTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/types/array/isMongooseArray.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/types/array/methods/index.js":
/*!*************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/types/array/methods/index.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Document = __webpack_require__(/*! ../../../document */ \"../backend/node_modules/mongoose/lib/document.js\");\nconst ArraySubdocument = __webpack_require__(/*! ../../arraySubdocument */ \"../backend/node_modules/mongoose/lib/types/arraySubdocument.js\");\nconst MongooseError = __webpack_require__(/*! ../../../error/mongooseError */ \"../backend/node_modules/mongoose/lib/error/mongooseError.js\");\nconst cleanModifiedSubpaths = __webpack_require__(/*! ../../../helpers/document/cleanModifiedSubpaths */ \"../backend/node_modules/mongoose/lib/helpers/document/cleanModifiedSubpaths.js\");\nconst clone = __webpack_require__(/*! ../../../helpers/clone */ \"../backend/node_modules/mongoose/lib/helpers/clone.js\");\nconst internalToObjectOptions = (__webpack_require__(/*! ../../../options */ \"../backend/node_modules/mongoose/lib/options.js\").internalToObjectOptions);\nconst mpath = __webpack_require__(/*! mpath */ \"../backend/node_modules/mpath/index.js\");\nconst utils = __webpack_require__(/*! ../../../utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\nconst isBsonType = __webpack_require__(/*! ../../../helpers/isBsonType */ \"../backend/node_modules/mongoose/lib/helpers/isBsonType.js\");\n\nconst arrayAtomicsSymbol = (__webpack_require__(/*! ../../../helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsSymbol);\nconst arrayParentSymbol = (__webpack_require__(/*! ../../../helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").arrayParentSymbol);\nconst arrayPathSymbol = (__webpack_require__(/*! ../../../helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").arrayPathSymbol);\nconst arraySchemaSymbol = (__webpack_require__(/*! ../../../helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").arraySchemaSymbol);\nconst populateModelSymbol = (__webpack_require__(/*! ../../../helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").populateModelSymbol);\nconst slicedSymbol = Symbol('mongoose#Array#sliced');\n\nconst _basePush = Array.prototype.push;\n\n/*!\n * ignore\n */\n\nconst methods = {\n  /**\n   * Depopulates stored atomic operation values as necessary for direct insertion to MongoDB.\n   *\n   * If no atomics exist, we return all array values after conversion.\n   *\n   * @return {Array}\n   * @method $__getAtomics\n   * @memberOf MongooseArray\n   * @instance\n   * @api private\n   */\n\n  $__getAtomics() {\n    const ret = [];\n    const keys = Object.keys(this[arrayAtomicsSymbol] || {});\n    let i = keys.length;\n\n    const opts = Object.assign({}, internalToObjectOptions, { _isNested: true });\n\n    if (i === 0) {\n      ret[0] = ['$set', this.toObject(opts)];\n      return ret;\n    }\n\n    while (i--) {\n      const op = keys[i];\n      let val = this[arrayAtomicsSymbol][op];\n\n      // the atomic values which are arrays are not MongooseArrays. we\n      // need to convert their elements as if they were MongooseArrays\n      // to handle populated arrays versus DocumentArrays properly.\n      if (utils.isMongooseObject(val)) {\n        val = val.toObject(opts);\n      } else if (Array.isArray(val)) {\n        val = this.toObject.call(val, opts);\n      } else if (val != null && Array.isArray(val.$each)) {\n        val.$each = this.toObject.call(val.$each, opts);\n      } else if (val != null && typeof val.valueOf === 'function') {\n        val = val.valueOf();\n      }\n\n      if (op === '$addToSet') {\n        val = { $each: val };\n      }\n\n      ret.push([op, val]);\n    }\n\n    return ret;\n  },\n\n  /*!\n   * ignore\n   */\n\n  $atomics() {\n    return this[arrayAtomicsSymbol];\n  },\n\n  /*!\n   * ignore\n   */\n\n  $parent() {\n    return this[arrayParentSymbol];\n  },\n\n  /*!\n   * ignore\n   */\n\n  $path() {\n    return this[arrayPathSymbol];\n  },\n\n  /**\n   * Atomically shifts the array at most one time per document `save()`.\n   *\n   * #### Note:\n   *\n   * _Calling this multiple times on an array before saving sends the same command as calling it once._\n   * _This update is implemented using the MongoDB [$pop](https://www.mongodb.com/docs/manual/reference/operator/update/pop/) method which enforces this restriction._\n   *\n   *      doc.array = [1,2,3];\n   *\n   *      const shifted = doc.array.$shift();\n   *      console.log(shifted); // 1\n   *      console.log(doc.array); // [2,3]\n   *\n   *      // no affect\n   *      shifted = doc.array.$shift();\n   *      console.log(doc.array); // [2,3]\n   *\n   *      doc.save(function (err) {\n   *        if (err) return handleError(err);\n   *\n   *        // we saved, now $shift works again\n   *        shifted = doc.array.$shift();\n   *        console.log(shifted ); // 2\n   *        console.log(doc.array); // [3]\n   *      })\n   *\n   * @api public\n   * @memberOf MongooseArray\n   * @instance\n   * @method $shift\n   * @see mongodb https://www.mongodb.com/docs/manual/reference/operator/update/pop/\n   */\n\n  $shift() {\n    this._registerAtomic('$pop', -1);\n    this._markModified();\n\n    // only allow shifting once\n    const __array = this.__array;\n    if (__array._shifted) {\n      return;\n    }\n    __array._shifted = true;\n\n    return [].shift.call(__array);\n  },\n\n  /**\n   * Pops the array atomically at most one time per document `save()`.\n   *\n   * #### NOTE:\n   *\n   * _Calling this multiple times on an array before saving sends the same command as calling it once._\n   * _This update is implemented using the MongoDB [$pop](https://www.mongodb.com/docs/manual/reference/operator/update/pop/) method which enforces this restriction._\n   *\n   *      doc.array = [1,2,3];\n   *\n   *      const popped = doc.array.$pop();\n   *      console.log(popped); // 3\n   *      console.log(doc.array); // [1,2]\n   *\n   *      // no affect\n   *      popped = doc.array.$pop();\n   *      console.log(doc.array); // [1,2]\n   *\n   *      doc.save(function (err) {\n   *        if (err) return handleError(err);\n   *\n   *        // we saved, now $pop works again\n   *        popped = doc.array.$pop();\n   *        console.log(popped); // 2\n   *        console.log(doc.array); // [1]\n   *      })\n   *\n   * @api public\n   * @method $pop\n   * @memberOf MongooseArray\n   * @instance\n   * @see mongodb https://www.mongodb.com/docs/manual/reference/operator/update/pop/\n   * @method $pop\n   * @memberOf MongooseArray\n   */\n\n  $pop() {\n    this._registerAtomic('$pop', 1);\n    this._markModified();\n\n    // only allow popping once\n    if (this._popped) {\n      return;\n    }\n    this._popped = true;\n\n    return [].pop.call(this);\n  },\n\n  /*!\n   * ignore\n   */\n\n  $schema() {\n    return this[arraySchemaSymbol];\n  },\n\n  /**\n   * Casts a member based on this arrays schema.\n   *\n   * @param {any} value\n   * @return value the casted value\n   * @method _cast\n   * @api private\n   * @memberOf MongooseArray\n   */\n\n  _cast(value) {\n    let populated = false;\n    let Model;\n\n    const parent = this[arrayParentSymbol];\n    if (parent) {\n      populated = parent.$populated(this[arrayPathSymbol], true);\n    }\n\n    if (populated && value !== null && value !== undefined) {\n      // cast to the populated Models schema\n      Model = populated.options[populateModelSymbol];\n      if (Model == null) {\n        throw new MongooseError('No populated model found for path `' + this[arrayPathSymbol] + '`. This is likely a bug in Mongoose, please report an issue on github.com/Automattic/mongoose.');\n      }\n\n      // only objects are permitted so we can safely assume that\n      // non-objects are to be interpreted as _id\n      if (Buffer.isBuffer(value) ||\n          isBsonType(value, 'ObjectId') || !utils.isObject(value)) {\n        value = { _id: value };\n      }\n\n      // gh-2399\n      // we should cast model only when it's not a discriminator\n      const isDisc = value.schema && value.schema.discriminatorMapping &&\n          value.schema.discriminatorMapping.key !== undefined;\n      if (!isDisc) {\n        value = new Model(value);\n      }\n      return this[arraySchemaSymbol].caster.applySetters(value, parent, true);\n    }\n\n    return this[arraySchemaSymbol].caster.applySetters(value, parent, false);\n  },\n\n  /**\n   * Internal helper for .map()\n   *\n   * @api private\n   * @return {Number}\n   * @method _mapCast\n   * @memberOf MongooseArray\n   */\n\n  _mapCast(val, index) {\n    return this._cast(val, this.length + index);\n  },\n\n  /**\n   * Marks this array as modified.\n   *\n   * If it bubbles up from an embedded document change, then it takes the following arguments (otherwise, takes 0 arguments)\n   *\n   * @param {ArraySubdocument} subdoc the embedded doc that invoked this method on the Array\n   * @param {String} embeddedPath the path which changed in the subdoc\n   * @method _markModified\n   * @api private\n   * @memberOf MongooseArray\n   */\n\n  _markModified(elem) {\n    const parent = this[arrayParentSymbol];\n    let dirtyPath;\n\n    if (parent) {\n      dirtyPath = this[arrayPathSymbol];\n\n      if (arguments.length) {\n        dirtyPath = dirtyPath + '.' + elem;\n      }\n\n      if (dirtyPath != null && dirtyPath.endsWith('.$')) {\n        return this;\n      }\n\n      parent.markModified(dirtyPath, arguments.length !== 0 ? elem : parent);\n    }\n\n    return this;\n  },\n\n  /**\n   * Register an atomic operation with the parent.\n   *\n   * @param {Array} op operation\n   * @param {any} val\n   * @method _registerAtomic\n   * @api private\n   * @memberOf MongooseArray\n   */\n\n  _registerAtomic(op, val) {\n    if (this[slicedSymbol]) {\n      return;\n    }\n    if (op === '$set') {\n      // $set takes precedence over all other ops.\n      // mark entire array modified.\n      this[arrayAtomicsSymbol] = { $set: val };\n      cleanModifiedSubpaths(this[arrayParentSymbol], this[arrayPathSymbol]);\n      this._markModified();\n      return this;\n    }\n\n    const atomics = this[arrayAtomicsSymbol];\n\n    // reset pop/shift after save\n    if (op === '$pop' && !('$pop' in atomics)) {\n      const _this = this;\n      this[arrayParentSymbol].once('save', function() {\n        _this._popped = _this._shifted = null;\n      });\n    }\n\n    // check for impossible $atomic combos (Mongo denies more than one\n    // $atomic op on a single path\n    if (atomics.$set || Object.keys(atomics).length && !(op in atomics)) {\n      // a different op was previously registered.\n      // save the entire thing.\n      this[arrayAtomicsSymbol] = { $set: this };\n      return this;\n    }\n\n    let selector;\n\n    if (op === '$pullAll' || op === '$addToSet') {\n      atomics[op] || (atomics[op] = []);\n      atomics[op] = atomics[op].concat(val);\n    } else if (op === '$pullDocs') {\n      const pullOp = atomics['$pull'] || (atomics['$pull'] = {});\n      if (val[0] instanceof ArraySubdocument) {\n        selector = pullOp['$or'] || (pullOp['$or'] = []);\n        Array.prototype.push.apply(selector, val.map(v => {\n          return v.toObject({\n            transform: (doc, ret) => {\n              if (v == null || v.$__ == null) {\n                return ret;\n              }\n\n              Object.keys(v.$__.activePaths.getStatePaths('default')).forEach(path => {\n                mpath.unset(path, ret);\n\n                _minimizePath(ret, path);\n              });\n\n              return ret;\n            },\n            virtuals: false\n          });\n        }));\n      } else {\n        selector = pullOp['_id'] || (pullOp['_id'] = { $in: [] });\n        selector['$in'] = selector['$in'].concat(val);\n      }\n    } else if (op === '$push') {\n      atomics.$push = atomics.$push || { $each: [] };\n      if (val != null && utils.hasUserDefinedProperty(val, '$each')) {\n        atomics.$push = val;\n      } else {\n        if (val.length === 1) {\n          atomics.$push.$each.push(val[0]);\n        } else if (val.length < 10000) {\n          atomics.$push.$each.push(...val);\n        } else {\n          for (const v of val) {\n            atomics.$push.$each.push(v);\n          }\n        }\n      }\n    } else {\n      atomics[op] = val;\n    }\n\n    return this;\n  },\n\n  /**\n   * Adds values to the array if not already present.\n   *\n   * #### Example:\n   *\n   *     console.log(doc.array) // [2,3,4]\n   *     const added = doc.array.addToSet(4,5);\n   *     console.log(doc.array) // [2,3,4,5]\n   *     console.log(added)     // [5]\n   *\n   * @param {...any} [args]\n   * @return {Array} the values that were added\n   * @memberOf MongooseArray\n   * @api public\n   * @method addToSet\n   */\n\n  addToSet() {\n    _checkManualPopulation(this, arguments);\n\n    const values = [].map.call(arguments, this._mapCast, this);\n    const added = [];\n    let type = '';\n    if (values[0] instanceof ArraySubdocument) {\n      type = 'doc';\n    } else if (values[0] instanceof Date) {\n      type = 'date';\n    } else if (isBsonType(values[0], 'ObjectId')) {\n      type = 'ObjectId';\n    }\n\n    const rawValues = utils.isMongooseArray(values) ? values.__array : values;\n    const rawArray = utils.isMongooseArray(this) ? this.__array : this;\n\n    rawValues.forEach(function(v) {\n      let found;\n      const val = +v;\n      switch (type) {\n        case 'doc':\n          found = this.some(function(doc) {\n            return doc.equals(v);\n          });\n          break;\n        case 'date':\n          found = this.some(function(d) {\n            return +d === val;\n          });\n          break;\n        case 'ObjectId':\n          found = this.find(o => o.toString() === v.toString());\n          break;\n        default:\n          found = ~this.indexOf(v);\n          break;\n      }\n\n      if (!found) {\n        this._markModified();\n        rawArray.push(v);\n        this._registerAtomic('$addToSet', v);\n        [].push.call(added, v);\n      }\n    }, this);\n\n    return added;\n  },\n\n  /**\n   * Returns the number of pending atomic operations to send to the db for this array.\n   *\n   * @api private\n   * @return {Number}\n   * @method hasAtomics\n   * @memberOf MongooseArray\n   */\n\n  hasAtomics() {\n    if (!utils.isPOJO(this[arrayAtomicsSymbol])) {\n      return 0;\n    }\n\n    return Object.keys(this[arrayAtomicsSymbol]).length;\n  },\n\n  /**\n   * Return whether or not the `obj` is included in the array.\n   *\n   * @param {Object} obj the item to check\n   * @param {Number} fromIndex\n   * @return {Boolean}\n   * @api public\n   * @method includes\n   * @memberOf MongooseArray\n   */\n\n  includes(obj, fromIndex) {\n    const ret = this.indexOf(obj, fromIndex);\n    return ret !== -1;\n  },\n\n  /**\n   * Return the index of `obj` or `-1` if not found.\n   *\n   * @param {Object} obj the item to look for\n   * @param {Number} fromIndex\n   * @return {Number}\n   * @api public\n   * @method indexOf\n   * @memberOf MongooseArray\n   */\n\n  indexOf(obj, fromIndex) {\n    if (isBsonType(obj, 'ObjectId')) {\n      obj = obj.toString();\n    }\n\n    fromIndex = fromIndex == null ? 0 : fromIndex;\n    const len = this.length;\n    for (let i = fromIndex; i < len; ++i) {\n      if (obj == this[i]) {\n        return i;\n      }\n    }\n    return -1;\n  },\n\n  /**\n   * Helper for console.log\n   *\n   * @api public\n   * @method inspect\n   * @memberOf MongooseArray\n   */\n\n  inspect() {\n    return JSON.stringify(this);\n  },\n\n  /**\n   * Pushes items to the array non-atomically.\n   *\n   * #### Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @param {...any} [args]\n   * @api public\n   * @method nonAtomicPush\n   * @memberOf MongooseArray\n   */\n\n  nonAtomicPush() {\n    const values = [].map.call(arguments, this._mapCast, this);\n    this._markModified();\n    const ret = [].push.apply(this, values);\n    this._registerAtomic('$set', this);\n    return ret;\n  },\n\n  /**\n   * Wraps [`Array#pop`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/pop) with proper change tracking.\n   *\n   * #### Note:\n   *\n   * _marks the entire array as modified which will pass the entire thing to $set potentially overwriting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @see MongooseArray#$pop https://mongoosejs.com/docs/api/array.html#MongooseArray.prototype.$pop()\n   * @api public\n   * @method pop\n   * @memberOf MongooseArray\n   */\n\n  pop() {\n    this._markModified();\n    const ret = [].pop.call(this);\n    this._registerAtomic('$set', this);\n    return ret;\n  },\n\n  /**\n   * Pulls items from the array atomically. Equality is determined by casting\n   * the provided value to an embedded document and comparing using\n   * [the `Document.equals()` function.](https://mongoosejs.com/docs/api/document.html#Document.prototype.equals())\n   *\n   * #### Example:\n   *\n   *     doc.array.pull(ObjectId)\n   *     doc.array.pull({ _id: 'someId' })\n   *     doc.array.pull(36)\n   *     doc.array.pull('tag 1', 'tag 2')\n   *\n   * To remove a document from a subdocument array we may pass an object with a matching `_id`.\n   *\n   *     doc.subdocs.push({ _id: 4815162342 })\n   *     doc.subdocs.pull({ _id: 4815162342 }) // removed\n   *\n   * Or we may passing the _id directly and let mongoose take care of it.\n   *\n   *     doc.subdocs.push({ _id: 4815162342 })\n   *     doc.subdocs.pull(4815162342); // works\n   *\n   * The first pull call will result in a atomic operation on the database, if pull is called repeatedly without saving the document, a $set operation is used on the complete array instead, overwriting possible changes that happened on the database in the meantime.\n   *\n   * @param {...any} [args]\n   * @see mongodb https://www.mongodb.com/docs/manual/reference/operator/update/pull/\n   * @api public\n   * @method pull\n   * @memberOf MongooseArray\n   */\n\n  pull() {\n    const values = [].map.call(arguments, (v, i) => this._cast(v, i, { defaults: false }), this);\n    const cur = this[arrayParentSymbol].get(this[arrayPathSymbol]);\n    let i = cur.length;\n    let mem;\n    this._markModified();\n\n    while (i--) {\n      mem = cur[i];\n      if (mem instanceof Document) {\n        const some = values.some(function(v) {\n          return mem.equals(v);\n        });\n        if (some) {\n          [].splice.call(cur, i, 1);\n        }\n      } else if (~cur.indexOf.call(values, mem)) {\n        [].splice.call(cur, i, 1);\n      }\n    }\n\n    if (values[0] instanceof ArraySubdocument) {\n      this._registerAtomic('$pullDocs', values.map(function(v) {\n        const _id = v.$__getValue('_id');\n        if (_id === undefined || v.$isDefault('_id')) {\n          return v;\n        }\n        return _id;\n      }));\n    } else {\n      this._registerAtomic('$pullAll', values);\n    }\n\n\n    // Might have modified child paths and then pulled, like\n    // `doc.children[1].name = 'test';` followed by\n    // `doc.children.remove(doc.children[0]);`. In this case we fall back\n    // to a `$set` on the whole array. See #3511\n    if (cleanModifiedSubpaths(this[arrayParentSymbol], this[arrayPathSymbol]) > 0) {\n      this._registerAtomic('$set', this);\n    }\n\n    return this;\n  },\n\n  /**\n   * Wraps [`Array#push`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/push) with proper change tracking.\n   *\n   * #### Example:\n   *\n   *     const schema = Schema({ nums: [Number] });\n   *     const Model = mongoose.model('Test', schema);\n   *\n   *     const doc = await Model.create({ nums: [3, 4] });\n   *     doc.nums.push(5); // Add 5 to the end of the array\n   *     await doc.save();\n   *\n   *     // You can also pass an object with `$each` as the\n   *     // first parameter to use MongoDB's `$position`\n   *     doc.nums.push({\n   *       $each: [1, 2],\n   *       $position: 0\n   *     });\n   *     doc.nums; // [1, 2, 3, 4, 5]\n   *\n   * @param {...Object} [args]\n   * @api public\n   * @method push\n   * @memberOf MongooseArray\n   */\n\n  push() {\n    let values = arguments;\n    let atomic = values;\n    const isOverwrite = values[0] != null &&\n      utils.hasUserDefinedProperty(values[0], '$each');\n    const arr = utils.isMongooseArray(this) ? this.__array : this;\n    if (isOverwrite) {\n      atomic = values[0];\n      values = values[0].$each;\n    }\n\n    if (this[arraySchemaSymbol] == null) {\n      return _basePush.apply(this, values);\n    }\n\n    _checkManualPopulation(this, values);\n\n    values = [].map.call(values, this._mapCast, this);\n    let ret;\n    const atomics = this[arrayAtomicsSymbol];\n    this._markModified();\n    if (isOverwrite) {\n      atomic.$each = values;\n\n      if ((atomics.$push && atomics.$push.$each && atomics.$push.$each.length || 0) !== 0 &&\n          atomics.$push.$position != atomic.$position) {\n        if (atomic.$position != null) {\n          [].splice.apply(arr, [atomic.$position, 0].concat(values));\n          ret = arr.length;\n        } else {\n          ret = [].push.apply(arr, values);\n        }\n\n        this._registerAtomic('$set', this);\n      } else if (atomic.$position != null) {\n        [].splice.apply(arr, [atomic.$position, 0].concat(values));\n        ret = this.length;\n      } else {\n        ret = [].push.apply(arr, values);\n      }\n    } else {\n      atomic = values;\n      ret = _basePush.apply(arr, values);\n    }\n\n    this._registerAtomic('$push', atomic);\n    return ret;\n  },\n\n  /**\n   * Alias of [pull](https://mongoosejs.com/docs/api/array.html#MongooseArray.prototype.pull())\n   *\n   * @see MongooseArray#pull https://mongoosejs.com/docs/api/array.html#MongooseArray.prototype.pull()\n   * @see mongodb https://www.mongodb.com/docs/manual/reference/operator/update/pull/\n   * @api public\n   * @memberOf MongooseArray\n   * @instance\n   * @method remove\n   */\n\n  remove() {\n    return this.pull.apply(this, arguments);\n  },\n\n  /**\n   * Sets the casted `val` at index `i` and marks the array modified.\n   *\n   * #### Example:\n   *\n   *     // given documents based on the following\n   *     const Doc = mongoose.model('Doc', new Schema({ array: [Number] }));\n   *\n   *     const doc = new Doc({ array: [2,3,4] })\n   *\n   *     console.log(doc.array) // [2,3,4]\n   *\n   *     doc.array.set(1,\"5\");\n   *     console.log(doc.array); // [2,5,4] // properly cast to number\n   *     doc.save() // the change is saved\n   *\n   *     // VS not using array#set\n   *     doc.array[1] = \"5\";\n   *     console.log(doc.array); // [2,\"5\",4] // no casting\n   *     doc.save() // change is not saved\n   *\n   * @return {Array} this\n   * @api public\n   * @method set\n   * @memberOf MongooseArray\n   */\n\n  set(i, val, skipModified) {\n    const arr = this.__array;\n    if (skipModified) {\n      arr[i] = val;\n      return this;\n    }\n    const value = methods._cast.call(this, val, i);\n    methods._markModified.call(this, i);\n    arr[i] = value;\n    return this;\n  },\n\n  /**\n   * Wraps [`Array#shift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.\n   *\n   * #### Example:\n   *\n   *     doc.array = [2,3];\n   *     const res = doc.array.shift();\n   *     console.log(res) // 2\n   *     console.log(doc.array) // [3]\n   *\n   * #### Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method shift\n   * @memberOf MongooseArray\n   */\n\n  shift() {\n    const arr = utils.isMongooseArray(this) ? this.__array : this;\n    this._markModified();\n    const ret = [].shift.call(arr);\n    this._registerAtomic('$set', this);\n    return ret;\n  },\n\n  /**\n   * Wraps [`Array#sort`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort) with proper change tracking.\n   *\n   * #### Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method sort\n   * @memberOf MongooseArray\n   * @see MasteringJS: Array sort https://masteringjs.io/tutorials/fundamentals/array-sort\n   */\n\n  sort() {\n    const arr = utils.isMongooseArray(this) ? this.__array : this;\n    const ret = [].sort.apply(arr, arguments);\n    this._registerAtomic('$set', this);\n    return ret;\n  },\n\n  /**\n   * Wraps [`Array#splice`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice) with proper change tracking and casting.\n   *\n   * #### Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method splice\n   * @memberOf MongooseArray\n   * @see MasteringJS: Array splice https://masteringjs.io/tutorials/fundamentals/array-splice\n   */\n\n  splice() {\n    let ret;\n    const arr = utils.isMongooseArray(this) ? this.__array : this;\n\n    this._markModified();\n    _checkManualPopulation(this, Array.prototype.slice.call(arguments, 2));\n\n    if (arguments.length) {\n      let vals;\n      if (this[arraySchemaSymbol] == null) {\n        vals = arguments;\n      } else {\n        vals = [];\n        for (let i = 0; i < arguments.length; ++i) {\n          vals[i] = i < 2 ?\n            arguments[i] :\n            this._cast(arguments[i], arguments[0] + (i - 2));\n        }\n      }\n\n      ret = [].splice.apply(arr, vals);\n      this._registerAtomic('$set', this);\n    }\n\n    return ret;\n  },\n\n  /*!\n   * ignore\n   */\n\n  toBSON() {\n    return this.toObject(internalToObjectOptions);\n  },\n\n  /**\n   * Returns a native js Array.\n   *\n   * @param {Object} options\n   * @return {Array}\n   * @api public\n   * @method toObject\n   * @memberOf MongooseArray\n   */\n\n  toObject(options) {\n    const arr = utils.isMongooseArray(this) ? this.__array : this;\n    if (options && options.depopulate) {\n      options = clone(options);\n      options._isNested = true;\n      // Ensure return value is a vanilla array, because in Node.js 6+ `map()`\n      // is smart enough to use the inherited array's constructor.\n      return [].concat(arr).map(function(doc) {\n        return doc instanceof Document\n          ? doc.toObject(options)\n          : doc;\n      });\n    }\n\n    return [].concat(arr);\n  },\n\n  $toObject() {\n    return this.constructor.prototype.toObject.apply(this, arguments);\n  },\n  /**\n   * Wraps [`Array#unshift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.\n   *\n   * #### Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwriting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method unshift\n   * @memberOf MongooseArray\n   */\n\n  unshift() {\n    _checkManualPopulation(this, arguments);\n\n    let values;\n    if (this[arraySchemaSymbol] == null) {\n      values = arguments;\n    } else {\n      values = [].map.call(arguments, this._cast, this);\n    }\n\n    const arr = utils.isMongooseArray(this) ? this.__array : this;\n    this._markModified();\n    [].unshift.apply(arr, values);\n    this._registerAtomic('$set', this);\n    return this.length;\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction _isAllSubdocs(docs, ref) {\n  if (!ref) {\n    return false;\n  }\n\n  for (const arg of docs) {\n    if (arg == null) {\n      return false;\n    }\n    const model = arg.constructor;\n    if (!(arg instanceof Document) ||\n      (model.modelName !== ref && model.baseModelName !== ref)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/*!\n * Minimize _just_ empty objects along the path chain specified\n * by `parts`, ignoring all other paths. Useful in cases where\n * you want to minimize after unsetting a path.\n *\n * #### Example:\n *\n *     const obj = { foo: { bar: { baz: {} } }, a: {} };\n *     _minimizePath(obj, 'foo.bar.baz');\n *     obj; // { a: {} }\n */\n\nfunction _minimizePath(obj, parts, i) {\n  if (typeof parts === 'string') {\n    if (parts.indexOf('.') === -1) {\n      return;\n    }\n\n    parts = mpath.stringToParts(parts);\n  }\n  i = i || 0;\n  if (i >= parts.length) {\n    return;\n  }\n  if (obj == null || typeof obj !== 'object') {\n    return;\n  }\n\n  _minimizePath(obj[parts[0]], parts, i + 1);\n  if (obj[parts[0]] != null && typeof obj[parts[0]] === 'object' && Object.keys(obj[parts[0]]).length === 0) {\n    delete obj[parts[0]];\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _checkManualPopulation(arr, docs) {\n  const ref = arr == null ?\n    null :\n    arr[arraySchemaSymbol] && arr[arraySchemaSymbol].caster && arr[arraySchemaSymbol].caster.options && arr[arraySchemaSymbol].caster.options.ref || null;\n  if (arr.length === 0 &&\n      docs.length !== 0) {\n    if (_isAllSubdocs(docs, ref)) {\n      arr[arrayParentSymbol].$populated(arr[arrayPathSymbol], [], {\n        [populateModelSymbol]: docs[0].constructor\n      });\n    }\n  }\n}\n\nconst returnVanillaArrayMethods = [\n  'filter',\n  'flat',\n  'flatMap',\n  'map',\n  'slice'\n];\nfor (const method of returnVanillaArrayMethods) {\n  if (Array.prototype[method] == null) {\n    continue;\n  }\n\n  methods[method] = function() {\n    const _arr = utils.isMongooseArray(this) ? this.__array : this;\n    const arr = [].concat(_arr);\n\n    return arr[method].apply(arr, arguments);\n  };\n}\n\nmodule.exports = methods;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL2FycmF5L21ldGhvZHMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsaUJBQWlCLG1CQUFPLENBQUMsMkVBQW1CO0FBQzVDLHlCQUF5QixtQkFBTyxDQUFDLDhGQUF3QjtBQUN6RCxzQkFBc0IsbUJBQU8sQ0FBQyxpR0FBOEI7QUFDNUQsOEJBQThCLG1CQUFPLENBQUMsdUlBQWlEO0FBQ3ZGLGNBQWMsbUJBQU8sQ0FBQyxxRkFBd0I7QUFDOUMsZ0NBQWdDLHdIQUFtRDtBQUNuRixjQUFjLG1CQUFPLENBQUMscURBQU87QUFDN0IsY0FBYyxtQkFBTyxDQUFDLHFFQUFnQjtBQUN0QyxtQkFBbUIsbUJBQU8sQ0FBQywrRkFBNkI7O0FBRXhELDJCQUEyQixtSUFBc0Q7QUFDakYsMEJBQTBCLGtJQUFxRDtBQUMvRSx3QkFBd0IsZ0lBQW1EO0FBQzNFLDBCQUEwQixrSUFBcUQ7QUFDL0UsNEJBQTRCLG9JQUF1RDtBQUNuRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDs7QUFFQSxpQ0FBaUMsNkJBQTZCLGlCQUFpQjs7QUFFL0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtB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QTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTyxPQUFPLFdBQVc7QUFDOUM7QUFDQSxZQUFZLEtBQUs7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdHlwZXMvYXJyYXkvbWV0aG9kcy9pbmRleC5qcz8wNDIxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRG9jdW1lbnQgPSByZXF1aXJlKCcuLi8uLi8uLi9kb2N1bWVudCcpO1xuY29uc3QgQXJyYXlTdWJkb2N1bWVudCA9IHJlcXVpcmUoJy4uLy4uL2FycmF5U3ViZG9jdW1lbnQnKTtcbmNvbnN0IE1vbmdvb3NlRXJyb3IgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvci9tb25nb29zZUVycm9yJyk7XG5jb25zdCBjbGVhbk1vZGlmaWVkU3VicGF0aHMgPSByZXF1aXJlKCcuLi8uLi8uLi9oZWxwZXJzL2RvY3VtZW50L2NsZWFuTW9kaWZpZWRTdWJwYXRocycpO1xuY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuLi8uLi8uLi9oZWxwZXJzL2Nsb25lJyk7XG5jb25zdCBpbnRlcm5hbFRvT2JqZWN0T3B0aW9ucyA9IHJlcXVpcmUoJy4uLy4uLy4uL29wdGlvbnMnKS5pbnRlcm5hbFRvT2JqZWN0T3B0aW9ucztcbmNvbnN0IG1wYXRoID0gcmVxdWlyZSgnbXBhdGgnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IGlzQnNvblR5cGUgPSByZXF1aXJlKCcuLi8uLi8uLi9oZWxwZXJzL2lzQnNvblR5cGUnKTtcblxuY29uc3QgYXJyYXlBdG9taWNzU3ltYm9sID0gcmVxdWlyZSgnLi4vLi4vLi4vaGVscGVycy9zeW1ib2xzJykuYXJyYXlBdG9taWNzU3ltYm9sO1xuY29uc3QgYXJyYXlQYXJlbnRTeW1ib2wgPSByZXF1aXJlKCcuLi8uLi8uLi9oZWxwZXJzL3N5bWJvbHMnKS5hcnJheVBhcmVudFN5bWJvbDtcbmNvbnN0IGFycmF5UGF0aFN5bWJvbCA9IHJlcXVpcmUoJy4uLy4uLy4uL2hlbHBlcnMvc3ltYm9scycpLmFycmF5UGF0aFN5bWJvbDtcbmNvbnN0IGFycmF5U2NoZW1hU3ltYm9sID0gcmVxdWlyZSgnLi4vLi4vLi4vaGVscGVycy9zeW1ib2xzJykuYXJyYXlTY2hlbWFTeW1ib2w7XG5jb25zdCBwb3B1bGF0ZU1vZGVsU3ltYm9sID0gcmVxdWlyZSgnLi4vLi4vLi4vaGVscGVycy9zeW1ib2xzJykucG9wdWxhdGVNb2RlbFN5bWJvbDtcbmNvbnN0IHNsaWNlZFN5bWJvbCA9IFN5bWJvbCgnbW9uZ29vc2UjQXJyYXkjc2xpY2VkJyk7XG5cbmNvbnN0IF9iYXNlUHVzaCA9IEFycmF5LnByb3RvdHlwZS5wdXNoO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmNvbnN0IG1ldGhvZHMgPSB7XG4gIC8qKlxuICAgKiBEZXBvcHVsYXRlcyBzdG9yZWQgYXRvbWljIG9wZXJhdGlvbiB2YWx1ZXMgYXMgbmVjZXNzYXJ5IGZvciBkaXJlY3QgaW5zZXJ0aW9uIHRvIE1vbmdvREIuXG4gICAqXG4gICAqIElmIG5vIGF0b21pY3MgZXhpc3QsIHdlIHJldHVybiBhbGwgYXJyYXkgdmFsdWVzIGFmdGVyIGNvbnZlcnNpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKiBAbWV0aG9kICRfX2dldEF0b21pY3NcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlQXJyYXlcbiAgICogQGluc3RhbmNlXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICAkX19nZXRBdG9taWNzKCkge1xuICAgIGNvbnN0IHJldCA9IFtdO1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzW2FycmF5QXRvbWljc1N5bWJvbF0gfHwge30pO1xuICAgIGxldCBpID0ga2V5cy5sZW5ndGg7XG5cbiAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgaW50ZXJuYWxUb09iamVjdE9wdGlvbnMsIHsgX2lzTmVzdGVkOiB0cnVlIH0pO1xuXG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIHJldFswXSA9IFsnJHNldCcsIHRoaXMudG9PYmplY3Qob3B0cyldO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjb25zdCBvcCA9IGtleXNbaV07XG4gICAgICBsZXQgdmFsID0gdGhpc1thcnJheUF0b21pY3NTeW1ib2xdW29wXTtcblxuICAgICAgLy8gdGhlIGF0b21pYyB2YWx1ZXMgd2hpY2ggYXJlIGFycmF5cyBhcmUgbm90IE1vbmdvb3NlQXJyYXlzLiB3ZVxuICAgICAgLy8gbmVlZCB0byBjb252ZXJ0IHRoZWlyIGVsZW1lbnRzIGFzIGlmIHRoZXkgd2VyZSBNb25nb29zZUFycmF5c1xuICAgICAgLy8gdG8gaGFuZGxlIHBvcHVsYXRlZCBhcnJheXMgdmVyc3VzIERvY3VtZW50QXJyYXlzIHByb3Blcmx5LlxuICAgICAgaWYgKHV0aWxzLmlzTW9uZ29vc2VPYmplY3QodmFsKSkge1xuICAgICAgICB2YWwgPSB2YWwudG9PYmplY3Qob3B0cyk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICB2YWwgPSB0aGlzLnRvT2JqZWN0LmNhbGwodmFsLCBvcHRzKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsICE9IG51bGwgJiYgQXJyYXkuaXNBcnJheSh2YWwuJGVhY2gpKSB7XG4gICAgICAgIHZhbC4kZWFjaCA9IHRoaXMudG9PYmplY3QuY2FsbCh2YWwuJGVhY2gsIG9wdHMpO1xuICAgICAgfSBlbHNlIGlmICh2YWwgIT0gbnVsbCAmJiB0eXBlb2YgdmFsLnZhbHVlT2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsID0gdmFsLnZhbHVlT2YoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wID09PSAnJGFkZFRvU2V0Jykge1xuICAgICAgICB2YWwgPSB7ICRlYWNoOiB2YWwgfTtcbiAgICAgIH1cblxuICAgICAgcmV0LnB1c2goW29wLCB2YWxdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIC8qIVxuICAgKiBpZ25vcmVcbiAgICovXG5cbiAgJGF0b21pY3MoKSB7XG4gICAgcmV0dXJuIHRoaXNbYXJyYXlBdG9taWNzU3ltYm9sXTtcbiAgfSxcblxuICAvKiFcbiAgICogaWdub3JlXG4gICAqL1xuXG4gICRwYXJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXNbYXJyYXlQYXJlbnRTeW1ib2xdO1xuICB9LFxuXG4gIC8qIVxuICAgKiBpZ25vcmVcbiAgICovXG5cbiAgJHBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXNbYXJyYXlQYXRoU3ltYm9sXTtcbiAgfSxcblxuICAvKipcbiAgICogQXRvbWljYWxseSBzaGlmdHMgdGhlIGFycmF5IGF0IG1vc3Qgb25lIHRpbWUgcGVyIGRvY3VtZW50IGBzYXZlKClgLlxuICAgKlxuICAgKiAjIyMjIE5vdGU6XG4gICAqXG4gICAqIF9DYWxsaW5nIHRoaXMgbXVsdGlwbGUgdGltZXMgb24gYW4gYXJyYXkgYmVmb3JlIHNhdmluZyBzZW5kcyB0aGUgc2FtZSBjb21tYW5kIGFzIGNhbGxpbmcgaXQgb25jZS5fXG4gICAqIF9UaGlzIHVwZGF0ZSBpcyBpbXBsZW1lbnRlZCB1c2luZyB0aGUgTW9uZ29EQiBbJHBvcF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3VwZGF0ZS9wb3AvKSBtZXRob2Qgd2hpY2ggZW5mb3JjZXMgdGhpcyByZXN0cmljdGlvbi5fXG4gICAqXG4gICAqICAgICAgZG9jLmFycmF5ID0gWzEsMiwzXTtcbiAgICpcbiAgICogICAgICBjb25zdCBzaGlmdGVkID0gZG9jLmFycmF5LiRzaGlmdCgpO1xuICAgKiAgICAgIGNvbnNvbGUubG9nKHNoaWZ0ZWQpOyAvLyAxXG4gICAqICAgICAgY29uc29sZS5sb2coZG9jLmFycmF5KTsgLy8gWzIsM11cbiAgICpcbiAgICogICAgICAvLyBubyBhZmZlY3RcbiAgICogICAgICBzaGlmdGVkID0gZG9jLmFycmF5LiRzaGlmdCgpO1xuICAgKiAgICAgIGNvbnNvbGUubG9nKGRvYy5hcnJheSk7IC8vIFsyLDNdXG4gICAqXG4gICAqICAgICAgZG9jLnNhdmUoZnVuY3Rpb24gKGVycikge1xuICAgKiAgICAgICAgaWYgKGVycikgcmV0dXJuIGhhbmRsZUVycm9yKGVycik7XG4gICAqXG4gICAqICAgICAgICAvLyB3ZSBzYXZlZCwgbm93ICRzaGlmdCB3b3JrcyBhZ2FpblxuICAgKiAgICAgICAgc2hpZnRlZCA9IGRvYy5hcnJheS4kc2hpZnQoKTtcbiAgICogICAgICAgIGNvbnNvbGUubG9nKHNoaWZ0ZWQgKTsgLy8gMlxuICAgKiAgICAgICAgY29uc29sZS5sb2coZG9jLmFycmF5KTsgLy8gWzNdXG4gICAqICAgICAgfSlcbiAgICpcbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlQXJyYXlcbiAgICogQGluc3RhbmNlXG4gICAqIEBtZXRob2QgJHNoaWZ0XG4gICAqIEBzZWUgbW9uZ29kYiBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvdXBkYXRlL3BvcC9cbiAgICovXG5cbiAgJHNoaWZ0KCkge1xuICAgIHRoaXMuX3JlZ2lzdGVyQXRvbWljKCckcG9wJywgLTEpO1xuICAgIHRoaXMuX21hcmtNb2RpZmllZCgpO1xuXG4gICAgLy8gb25seSBhbGxvdyBzaGlmdGluZyBvbmNlXG4gICAgY29uc3QgX19hcnJheSA9IHRoaXMuX19hcnJheTtcbiAgICBpZiAoX19hcnJheS5fc2hpZnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBfX2FycmF5Ll9zaGlmdGVkID0gdHJ1ZTtcblxuICAgIHJldHVybiBbXS5zaGlmdC5jYWxsKF9fYXJyYXkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQb3BzIHRoZSBhcnJheSBhdG9taWNhbGx5IGF0IG1vc3Qgb25lIHRpbWUgcGVyIGRvY3VtZW50IGBzYXZlKClgLlxuICAgKlxuICAgKiAjIyMjIE5PVEU6XG4gICAqXG4gICAqIF9DYWxsaW5nIHRoaXMgbXVsdGlwbGUgdGltZXMgb24gYW4gYXJyYXkgYmVmb3JlIHNhdmluZyBzZW5kcyB0aGUgc2FtZSBjb21tYW5kIGFzIGNhbGxpbmcgaXQgb25jZS5fXG4gICAqIF9UaGlzIHVwZGF0ZSBpcyBpbXBsZW1lbnRlZCB1c2luZyB0aGUgTW9uZ29EQiBbJHBvcF0oaHR0cHM6Ly93d3cubW9uZ29kYi5jb20vZG9jcy9tYW51YWwvcmVmZXJlbmNlL29wZXJhdG9yL3VwZGF0ZS9wb3AvKSBtZXRob2Qgd2hpY2ggZW5mb3JjZXMgdGhpcyByZXN0cmljdGlvbi5fXG4gICAqXG4gICAqICAgICAgZG9jLmFycmF5ID0gWzEsMiwzXTtcbiAgICpcbiAgICogICAgICBjb25zdCBwb3BwZWQgPSBkb2MuYXJyYXkuJHBvcCgpO1xuICAgKiAgICAgIGNvbnNvbGUubG9nKHBvcHBlZCk7IC8vIDNcbiAgICogICAgICBjb25zb2xlLmxvZyhkb2MuYXJyYXkpOyAvLyBbMSwyXVxuICAgKlxuICAgKiAgICAgIC8vIG5vIGFmZmVjdFxuICAgKiAgICAgIHBvcHBlZCA9IGRvYy5hcnJheS4kcG9wKCk7XG4gICAqICAgICAgY29uc29sZS5sb2coZG9jLmFycmF5KTsgLy8gWzEsMl1cbiAgICpcbiAgICogICAgICBkb2Muc2F2ZShmdW5jdGlvbiAoZXJyKSB7XG4gICAqICAgICAgICBpZiAoZXJyKSByZXR1cm4gaGFuZGxlRXJyb3IoZXJyKTtcbiAgICpcbiAgICogICAgICAgIC8vIHdlIHNhdmVkLCBub3cgJHBvcCB3b3JrcyBhZ2FpblxuICAgKiAgICAgICAgcG9wcGVkID0gZG9jLmFycmF5LiRwb3AoKTtcbiAgICogICAgICAgIGNvbnNvbGUubG9nKHBvcHBlZCk7IC8vIDJcbiAgICogICAgICAgIGNvbnNvbGUubG9nKGRvYy5hcnJheSk7IC8vIFsxXVxuICAgKiAgICAgIH0pXG4gICAqXG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZXRob2QgJHBvcFxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKiBAaW5zdGFuY2VcbiAgICogQHNlZSBtb25nb2RiIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci91cGRhdGUvcG9wL1xuICAgKiBAbWV0aG9kICRwb3BcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlQXJyYXlcbiAgICovXG5cbiAgJHBvcCgpIHtcbiAgICB0aGlzLl9yZWdpc3RlckF0b21pYygnJHBvcCcsIDEpO1xuICAgIHRoaXMuX21hcmtNb2RpZmllZCgpO1xuXG4gICAgLy8gb25seSBhbGxvdyBwb3BwaW5nIG9uY2VcbiAgICBpZiAodGhpcy5fcG9wcGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3BvcHBlZCA9IHRydWU7XG5cbiAgICByZXR1cm4gW10ucG9wLmNhbGwodGhpcyk7XG4gIH0sXG5cbiAgLyohXG4gICAqIGlnbm9yZVxuICAgKi9cblxuICAkc2NoZW1hKCkge1xuICAgIHJldHVybiB0aGlzW2FycmF5U2NoZW1hU3ltYm9sXTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FzdHMgYSBtZW1iZXIgYmFzZWQgb24gdGhpcyBhcnJheXMgc2NoZW1hLlxuICAgKlxuICAgKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAgICogQHJldHVybiB2YWx1ZSB0aGUgY2FzdGVkIHZhbHVlXG4gICAqIEBtZXRob2QgX2Nhc3RcbiAgICogQGFwaSBwcml2YXRlXG4gICAqIEBtZW1iZXJPZiBNb25nb29zZUFycmF5XG4gICAqL1xuXG4gIF9jYXN0KHZhbHVlKSB7XG4gICAgbGV0IHBvcHVsYXRlZCA9IGZhbHNlO1xuICAgIGxldCBNb2RlbDtcblxuICAgIGNvbnN0IHBhcmVudCA9IHRoaXNbYXJyYXlQYXJlbnRTeW1ib2xdO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIHBvcHVsYXRlZCA9IHBhcmVudC4kcG9wdWxhdGVkKHRoaXNbYXJyYXlQYXRoU3ltYm9sXSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHBvcHVsYXRlZCAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBjYXN0IHRvIHRoZSBwb3B1bGF0ZWQgTW9kZWxzIHNjaGVtYVxuICAgICAgTW9kZWwgPSBwb3B1bGF0ZWQub3B0aW9uc1twb3B1bGF0ZU1vZGVsU3ltYm9sXTtcbiAgICAgIGlmIChNb2RlbCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKCdObyBwb3B1bGF0ZWQgbW9kZWwgZm91bmQgZm9yIHBhdGggYCcgKyB0aGlzW2FycmF5UGF0aFN5bWJvbF0gKyAnYC4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gTW9uZ29vc2UsIHBsZWFzZSByZXBvcnQgYW4gaXNzdWUgb24gZ2l0aHViLmNvbS9BdXRvbWF0dGljL21vbmdvb3NlLicpO1xuICAgICAgfVxuXG4gICAgICAvLyBvbmx5IG9iamVjdHMgYXJlIHBlcm1pdHRlZCBzbyB3ZSBjYW4gc2FmZWx5IGFzc3VtZSB0aGF0XG4gICAgICAvLyBub24tb2JqZWN0cyBhcmUgdG8gYmUgaW50ZXJwcmV0ZWQgYXMgX2lkXG4gICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSB8fFxuICAgICAgICAgIGlzQnNvblR5cGUodmFsdWUsICdPYmplY3RJZCcpIHx8ICF1dGlscy5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB7IF9pZDogdmFsdWUgfTtcbiAgICAgIH1cblxuICAgICAgLy8gZ2gtMjM5OVxuICAgICAgLy8gd2Ugc2hvdWxkIGNhc3QgbW9kZWwgb25seSB3aGVuIGl0J3Mgbm90IGEgZGlzY3JpbWluYXRvclxuICAgICAgY29uc3QgaXNEaXNjID0gdmFsdWUuc2NoZW1hICYmIHZhbHVlLnNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZyAmJlxuICAgICAgICAgIHZhbHVlLnNjaGVtYS5kaXNjcmltaW5hdG9yTWFwcGluZy5rZXkgIT09IHVuZGVmaW5lZDtcbiAgICAgIGlmICghaXNEaXNjKSB7XG4gICAgICAgIHZhbHVlID0gbmV3IE1vZGVsKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzW2FycmF5U2NoZW1hU3ltYm9sXS5jYXN0ZXIuYXBwbHlTZXR0ZXJzKHZhbHVlLCBwYXJlbnQsIHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzW2FycmF5U2NoZW1hU3ltYm9sXS5jYXN0ZXIuYXBwbHlTZXR0ZXJzKHZhbHVlLCBwYXJlbnQsIGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICogSW50ZXJuYWwgaGVscGVyIGZvciAubWFwKClcbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICogQG1ldGhvZCBfbWFwQ2FzdFxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKi9cblxuICBfbWFwQ2FzdCh2YWwsIGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nhc3QodmFsLCB0aGlzLmxlbmd0aCArIGluZGV4KTtcbiAgfSxcblxuICAvKipcbiAgICogTWFya3MgdGhpcyBhcnJheSBhcyBtb2RpZmllZC5cbiAgICpcbiAgICogSWYgaXQgYnViYmxlcyB1cCBmcm9tIGFuIGVtYmVkZGVkIGRvY3VtZW50IGNoYW5nZSwgdGhlbiBpdCB0YWtlcyB0aGUgZm9sbG93aW5nIGFyZ3VtZW50cyAob3RoZXJ3aXNlLCB0YWtlcyAwIGFyZ3VtZW50cylcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheVN1YmRvY3VtZW50fSBzdWJkb2MgdGhlIGVtYmVkZGVkIGRvYyB0aGF0IGludm9rZWQgdGhpcyBtZXRob2Qgb24gdGhlIEFycmF5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBlbWJlZGRlZFBhdGggdGhlIHBhdGggd2hpY2ggY2hhbmdlZCBpbiB0aGUgc3ViZG9jXG4gICAqIEBtZXRob2QgX21hcmtNb2RpZmllZFxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlQXJyYXlcbiAgICovXG5cbiAgX21hcmtNb2RpZmllZChlbGVtKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpc1thcnJheVBhcmVudFN5bWJvbF07XG4gICAgbGV0IGRpcnR5UGF0aDtcblxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIGRpcnR5UGF0aCA9IHRoaXNbYXJyYXlQYXRoU3ltYm9sXTtcblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgZGlydHlQYXRoID0gZGlydHlQYXRoICsgJy4nICsgZWxlbTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpcnR5UGF0aCAhPSBudWxsICYmIGRpcnR5UGF0aC5lbmRzV2l0aCgnLiQnKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgcGFyZW50Lm1hcmtNb2RpZmllZChkaXJ0eVBhdGgsIGFyZ3VtZW50cy5sZW5ndGggIT09IDAgPyBlbGVtIDogcGFyZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogUmVnaXN0ZXIgYW4gYXRvbWljIG9wZXJhdGlvbiB3aXRoIHRoZSBwYXJlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IG9wIG9wZXJhdGlvblxuICAgKiBAcGFyYW0ge2FueX0gdmFsXG4gICAqIEBtZXRob2QgX3JlZ2lzdGVyQXRvbWljXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKi9cblxuICBfcmVnaXN0ZXJBdG9taWMob3AsIHZhbCkge1xuICAgIGlmICh0aGlzW3NsaWNlZFN5bWJvbF0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG9wID09PSAnJHNldCcpIHtcbiAgICAgIC8vICRzZXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGFsbCBvdGhlciBvcHMuXG4gICAgICAvLyBtYXJrIGVudGlyZSBhcnJheSBtb2RpZmllZC5cbiAgICAgIHRoaXNbYXJyYXlBdG9taWNzU3ltYm9sXSA9IHsgJHNldDogdmFsIH07XG4gICAgICBjbGVhbk1vZGlmaWVkU3VicGF0aHModGhpc1thcnJheVBhcmVudFN5bWJvbF0sIHRoaXNbYXJyYXlQYXRoU3ltYm9sXSk7XG4gICAgICB0aGlzLl9tYXJrTW9kaWZpZWQoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNvbnN0IGF0b21pY3MgPSB0aGlzW2FycmF5QXRvbWljc1N5bWJvbF07XG5cbiAgICAvLyByZXNldCBwb3Avc2hpZnQgYWZ0ZXIgc2F2ZVxuICAgIGlmIChvcCA9PT0gJyRwb3AnICYmICEoJyRwb3AnIGluIGF0b21pY3MpKSB7XG4gICAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgICB0aGlzW2FycmF5UGFyZW50U3ltYm9sXS5vbmNlKCdzYXZlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIF90aGlzLl9wb3BwZWQgPSBfdGhpcy5fc2hpZnRlZCA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBmb3IgaW1wb3NzaWJsZSAkYXRvbWljIGNvbWJvcyAoTW9uZ28gZGVuaWVzIG1vcmUgdGhhbiBvbmVcbiAgICAvLyAkYXRvbWljIG9wIG9uIGEgc2luZ2xlIHBhdGhcbiAgICBpZiAoYXRvbWljcy4kc2V0IHx8IE9iamVjdC5rZXlzKGF0b21pY3MpLmxlbmd0aCAmJiAhKG9wIGluIGF0b21pY3MpKSB7XG4gICAgICAvLyBhIGRpZmZlcmVudCBvcCB3YXMgcHJldmlvdXNseSByZWdpc3RlcmVkLlxuICAgICAgLy8gc2F2ZSB0aGUgZW50aXJlIHRoaW5nLlxuICAgICAgdGhpc1thcnJheUF0b21pY3NTeW1ib2xdID0geyAkc2V0OiB0aGlzIH07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBsZXQgc2VsZWN0b3I7XG5cbiAgICBpZiAob3AgPT09ICckcHVsbEFsbCcgfHwgb3AgPT09ICckYWRkVG9TZXQnKSB7XG4gICAgICBhdG9taWNzW29wXSB8fCAoYXRvbWljc1tvcF0gPSBbXSk7XG4gICAgICBhdG9taWNzW29wXSA9IGF0b21pY3Nbb3BdLmNvbmNhdCh2YWwpO1xuICAgIH0gZWxzZSBpZiAob3AgPT09ICckcHVsbERvY3MnKSB7XG4gICAgICBjb25zdCBwdWxsT3AgPSBhdG9taWNzWyckcHVsbCddIHx8IChhdG9taWNzWyckcHVsbCddID0ge30pO1xuICAgICAgaWYgKHZhbFswXSBpbnN0YW5jZW9mIEFycmF5U3ViZG9jdW1lbnQpIHtcbiAgICAgICAgc2VsZWN0b3IgPSBwdWxsT3BbJyRvciddIHx8IChwdWxsT3BbJyRvciddID0gW10pO1xuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShzZWxlY3RvciwgdmFsLm1hcCh2ID0+IHtcbiAgICAgICAgICByZXR1cm4gdi50b09iamVjdCh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IChkb2MsIHJldCkgPT4ge1xuICAgICAgICAgICAgICBpZiAodiA9PSBudWxsIHx8IHYuJF9fID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgT2JqZWN0LmtleXModi4kX18uYWN0aXZlUGF0aHMuZ2V0U3RhdGVQYXRocygnZGVmYXVsdCcpKS5mb3JFYWNoKHBhdGggPT4ge1xuICAgICAgICAgICAgICAgIG1wYXRoLnVuc2V0KHBhdGgsIHJldCk7XG5cbiAgICAgICAgICAgICAgICBfbWluaW1pemVQYXRoKHJldCwgcGF0aCk7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlydHVhbHM6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGVjdG9yID0gcHVsbE9wWydfaWQnXSB8fCAocHVsbE9wWydfaWQnXSA9IHsgJGluOiBbXSB9KTtcbiAgICAgICAgc2VsZWN0b3JbJyRpbiddID0gc2VsZWN0b3JbJyRpbiddLmNvbmNhdCh2YWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3AgPT09ICckcHVzaCcpIHtcbiAgICAgIGF0b21pY3MuJHB1c2ggPSBhdG9taWNzLiRwdXNoIHx8IHsgJGVhY2g6IFtdIH07XG4gICAgICBpZiAodmFsICE9IG51bGwgJiYgdXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eSh2YWwsICckZWFjaCcpKSB7XG4gICAgICAgIGF0b21pY3MuJHB1c2ggPSB2YWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGF0b21pY3MuJHB1c2guJGVhY2gucHVzaCh2YWxbMF0pO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbC5sZW5ndGggPCAxMDAwMCkge1xuICAgICAgICAgIGF0b21pY3MuJHB1c2guJGVhY2gucHVzaCguLi52YWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB2YWwpIHtcbiAgICAgICAgICAgIGF0b21pY3MuJHB1c2guJGVhY2gucHVzaCh2KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXRvbWljc1tvcF0gPSB2YWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZHMgdmFsdWVzIHRvIHRoZSBhcnJheSBpZiBub3QgYWxyZWFkeSBwcmVzZW50LlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqXG4gICAqICAgICBjb25zb2xlLmxvZyhkb2MuYXJyYXkpIC8vIFsyLDMsNF1cbiAgICogICAgIGNvbnN0IGFkZGVkID0gZG9jLmFycmF5LmFkZFRvU2V0KDQsNSk7XG4gICAqICAgICBjb25zb2xlLmxvZyhkb2MuYXJyYXkpIC8vIFsyLDMsNCw1XVxuICAgKiAgICAgY29uc29sZS5sb2coYWRkZWQpICAgICAvLyBbNV1cbiAgICpcbiAgICogQHBhcmFtIHsuLi5hbnl9IFthcmdzXVxuICAgKiBAcmV0dXJuIHtBcnJheX0gdGhlIHZhbHVlcyB0aGF0IHdlcmUgYWRkZWRcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlQXJyYXlcbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1ldGhvZCBhZGRUb1NldFxuICAgKi9cblxuICBhZGRUb1NldCgpIHtcbiAgICBfY2hlY2tNYW51YWxQb3B1bGF0aW9uKHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBjb25zdCB2YWx1ZXMgPSBbXS5tYXAuY2FsbChhcmd1bWVudHMsIHRoaXMuX21hcENhc3QsIHRoaXMpO1xuICAgIGNvbnN0IGFkZGVkID0gW107XG4gICAgbGV0IHR5cGUgPSAnJztcbiAgICBpZiAodmFsdWVzWzBdIGluc3RhbmNlb2YgQXJyYXlTdWJkb2N1bWVudCkge1xuICAgICAgdHlwZSA9ICdkb2MnO1xuICAgIH0gZWxzZSBpZiAodmFsdWVzWzBdIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgdHlwZSA9ICdkYXRlJztcbiAgICB9IGVsc2UgaWYgKGlzQnNvblR5cGUodmFsdWVzWzBdLCAnT2JqZWN0SWQnKSkge1xuICAgICAgdHlwZSA9ICdPYmplY3RJZCc7XG4gICAgfVxuXG4gICAgY29uc3QgcmF3VmFsdWVzID0gdXRpbHMuaXNNb25nb29zZUFycmF5KHZhbHVlcykgPyB2YWx1ZXMuX19hcnJheSA6IHZhbHVlcztcbiAgICBjb25zdCByYXdBcnJheSA9IHV0aWxzLmlzTW9uZ29vc2VBcnJheSh0aGlzKSA/IHRoaXMuX19hcnJheSA6IHRoaXM7XG5cbiAgICByYXdWYWx1ZXMuZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgICBsZXQgZm91bmQ7XG4gICAgICBjb25zdCB2YWwgPSArdjtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdkb2MnOlxuICAgICAgICAgIGZvdW5kID0gdGhpcy5zb21lKGZ1bmN0aW9uKGRvYykge1xuICAgICAgICAgICAgcmV0dXJuIGRvYy5lcXVhbHModik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgIGZvdW5kID0gdGhpcy5zb21lKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiArZCA9PT0gdmFsO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdPYmplY3RJZCc6XG4gICAgICAgICAgZm91bmQgPSB0aGlzLmZpbmQobyA9PiBvLnRvU3RyaW5nKCkgPT09IHYudG9TdHJpbmcoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZm91bmQgPSB+dGhpcy5pbmRleE9mKHYpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgIHRoaXMuX21hcmtNb2RpZmllZCgpO1xuICAgICAgICByYXdBcnJheS5wdXNoKHYpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckF0b21pYygnJGFkZFRvU2V0Jywgdik7XG4gICAgICAgIFtdLnB1c2guY2FsbChhZGRlZCwgdik7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG5cbiAgICByZXR1cm4gYWRkZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBwZW5kaW5nIGF0b21pYyBvcGVyYXRpb25zIHRvIHNlbmQgdG8gdGhlIGRiIGZvciB0aGlzIGFycmF5LlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKiBAbWV0aG9kIGhhc0F0b21pY3NcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlQXJyYXlcbiAgICovXG5cbiAgaGFzQXRvbWljcygpIHtcbiAgICBpZiAoIXV0aWxzLmlzUE9KTyh0aGlzW2FycmF5QXRvbWljc1N5bWJvbF0pKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpc1thcnJheUF0b21pY3NTeW1ib2xdKS5sZW5ndGg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIG9yIG5vdCB0aGUgYG9iamAgaXMgaW5jbHVkZWQgaW4gdGhlIGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIHRoZSBpdGVtIHRvIGNoZWNrXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcm9tSW5kZXhcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1ldGhvZCBpbmNsdWRlc1xuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKi9cblxuICBpbmNsdWRlcyhvYmosIGZyb21JbmRleCkge1xuICAgIGNvbnN0IHJldCA9IHRoaXMuaW5kZXhPZihvYmosIGZyb21JbmRleCk7XG4gICAgcmV0dXJuIHJldCAhPT0gLTE7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgaW5kZXggb2YgYG9iamAgb3IgYC0xYCBpZiBub3QgZm91bmQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogdGhlIGl0ZW0gdG8gbG9vayBmb3JcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyb21JbmRleFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZXRob2QgaW5kZXhPZlxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKi9cblxuICBpbmRleE9mKG9iaiwgZnJvbUluZGV4KSB7XG4gICAgaWYgKGlzQnNvblR5cGUob2JqLCAnT2JqZWN0SWQnKSkge1xuICAgICAgb2JqID0gb2JqLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgZnJvbUluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogZnJvbUluZGV4O1xuICAgIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSBmcm9tSW5kZXg7IGkgPCBsZW47ICsraSkge1xuICAgICAgaWYgKG9iaiA9PSB0aGlzW2ldKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhlbHBlciBmb3IgY29uc29sZS5sb2dcbiAgICpcbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1ldGhvZCBpbnNwZWN0XG4gICAqIEBtZW1iZXJPZiBNb25nb29zZUFycmF5XG4gICAqL1xuXG4gIGluc3BlY3QoKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQdXNoZXMgaXRlbXMgdG8gdGhlIGFycmF5IG5vbi1hdG9taWNhbGx5LlxuICAgKlxuICAgKiAjIyMjIE5vdGU6XG4gICAqXG4gICAqIF9tYXJrcyB0aGUgZW50aXJlIGFycmF5IGFzIG1vZGlmaWVkLCB3aGljaCBpZiBzYXZlZCwgd2lsbCBzdG9yZSBpdCBhcyBhIGAkc2V0YCBvcGVyYXRpb24sIHBvdGVudGlhbGx5IG92ZXJ3cml0dGluZyBhbnkgY2hhbmdlcyB0aGF0IGhhcHBlbiBiZXR3ZWVuIHdoZW4geW91IHJldHJpZXZlZCB0aGUgb2JqZWN0IGFuZCB3aGVuIHlvdSBzYXZlIGl0Ll9cbiAgICpcbiAgICogQHBhcmFtIHsuLi5hbnl9IFthcmdzXVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWV0aG9kIG5vbkF0b21pY1B1c2hcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlQXJyYXlcbiAgICovXG5cbiAgbm9uQXRvbWljUHVzaCgpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXS5tYXAuY2FsbChhcmd1bWVudHMsIHRoaXMuX21hcENhc3QsIHRoaXMpO1xuICAgIHRoaXMuX21hcmtNb2RpZmllZCgpO1xuICAgIGNvbnN0IHJldCA9IFtdLnB1c2guYXBwbHkodGhpcywgdmFsdWVzKTtcbiAgICB0aGlzLl9yZWdpc3RlckF0b21pYygnJHNldCcsIHRoaXMpO1xuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdyYXBzIFtgQXJyYXkjcG9wYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvcG9wKSB3aXRoIHByb3BlciBjaGFuZ2UgdHJhY2tpbmcuXG4gICAqXG4gICAqICMjIyMgTm90ZTpcbiAgICpcbiAgICogX21hcmtzIHRoZSBlbnRpcmUgYXJyYXkgYXMgbW9kaWZpZWQgd2hpY2ggd2lsbCBwYXNzIHRoZSBlbnRpcmUgdGhpbmcgdG8gJHNldCBwb3RlbnRpYWxseSBvdmVyd3JpdGluZyBhbnkgY2hhbmdlcyB0aGF0IGhhcHBlbiBiZXR3ZWVuIHdoZW4geW91IHJldHJpZXZlZCB0aGUgb2JqZWN0IGFuZCB3aGVuIHlvdSBzYXZlIGl0Ll9cbiAgICpcbiAgICogQHNlZSBNb25nb29zZUFycmF5IyRwb3AgaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9hcnJheS5odG1sI01vbmdvb3NlQXJyYXkucHJvdG90eXBlLiRwb3AoKVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWV0aG9kIHBvcFxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKi9cblxuICBwb3AoKSB7XG4gICAgdGhpcy5fbWFya01vZGlmaWVkKCk7XG4gICAgY29uc3QgcmV0ID0gW10ucG9wLmNhbGwodGhpcyk7XG4gICAgdGhpcy5fcmVnaXN0ZXJBdG9taWMoJyRzZXQnLCB0aGlzKTtcbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBQdWxscyBpdGVtcyBmcm9tIHRoZSBhcnJheSBhdG9taWNhbGx5LiBFcXVhbGl0eSBpcyBkZXRlcm1pbmVkIGJ5IGNhc3RpbmdcbiAgICogdGhlIHByb3ZpZGVkIHZhbHVlIHRvIGFuIGVtYmVkZGVkIGRvY3VtZW50IGFuZCBjb21wYXJpbmcgdXNpbmdcbiAgICogW3RoZSBgRG9jdW1lbnQuZXF1YWxzKClgIGZ1bmN0aW9uLl0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9kb2N1bWVudC5odG1sI0RvY3VtZW50LnByb3RvdHlwZS5lcXVhbHMoKSlcbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKlxuICAgKiAgICAgZG9jLmFycmF5LnB1bGwoT2JqZWN0SWQpXG4gICAqICAgICBkb2MuYXJyYXkucHVsbCh7IF9pZDogJ3NvbWVJZCcgfSlcbiAgICogICAgIGRvYy5hcnJheS5wdWxsKDM2KVxuICAgKiAgICAgZG9jLmFycmF5LnB1bGwoJ3RhZyAxJywgJ3RhZyAyJylcbiAgICpcbiAgICogVG8gcmVtb3ZlIGEgZG9jdW1lbnQgZnJvbSBhIHN1YmRvY3VtZW50IGFycmF5IHdlIG1heSBwYXNzIGFuIG9iamVjdCB3aXRoIGEgbWF0Y2hpbmcgYF9pZGAuXG4gICAqXG4gICAqICAgICBkb2Muc3ViZG9jcy5wdXNoKHsgX2lkOiA0ODE1MTYyMzQyIH0pXG4gICAqICAgICBkb2Muc3ViZG9jcy5wdWxsKHsgX2lkOiA0ODE1MTYyMzQyIH0pIC8vIHJlbW92ZWRcbiAgICpcbiAgICogT3Igd2UgbWF5IHBhc3NpbmcgdGhlIF9pZCBkaXJlY3RseSBhbmQgbGV0IG1vbmdvb3NlIHRha2UgY2FyZSBvZiBpdC5cbiAgICpcbiAgICogICAgIGRvYy5zdWJkb2NzLnB1c2goeyBfaWQ6IDQ4MTUxNjIzNDIgfSlcbiAgICogICAgIGRvYy5zdWJkb2NzLnB1bGwoNDgxNTE2MjM0Mik7IC8vIHdvcmtzXG4gICAqXG4gICAqIFRoZSBmaXJzdCBwdWxsIGNhbGwgd2lsbCByZXN1bHQgaW4gYSBhdG9taWMgb3BlcmF0aW9uIG9uIHRoZSBkYXRhYmFzZSwgaWYgcHVsbCBpcyBjYWxsZWQgcmVwZWF0ZWRseSB3aXRob3V0IHNhdmluZyB0aGUgZG9jdW1lbnQsIGEgJHNldCBvcGVyYXRpb24gaXMgdXNlZCBvbiB0aGUgY29tcGxldGUgYXJyYXkgaW5zdGVhZCwgb3ZlcndyaXRpbmcgcG9zc2libGUgY2hhbmdlcyB0aGF0IGhhcHBlbmVkIG9uIHRoZSBkYXRhYmFzZSBpbiB0aGUgbWVhbnRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7Li4uYW55fSBbYXJnc11cbiAgICogQHNlZSBtb25nb2RiIGh0dHBzOi8vd3d3Lm1vbmdvZGIuY29tL2RvY3MvbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci91cGRhdGUvcHVsbC9cbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1ldGhvZCBwdWxsXG4gICAqIEBtZW1iZXJPZiBNb25nb29zZUFycmF5XG4gICAqL1xuXG4gIHB1bGwoKSB7XG4gICAgY29uc3QgdmFsdWVzID0gW10ubWFwLmNhbGwoYXJndW1lbnRzLCAodiwgaSkgPT4gdGhpcy5fY2FzdCh2LCBpLCB7IGRlZmF1bHRzOiBmYWxzZSB9KSwgdGhpcyk7XG4gICAgY29uc3QgY3VyID0gdGhpc1thcnJheVBhcmVudFN5bWJvbF0uZ2V0KHRoaXNbYXJyYXlQYXRoU3ltYm9sXSk7XG4gICAgbGV0IGkgPSBjdXIubGVuZ3RoO1xuICAgIGxldCBtZW07XG4gICAgdGhpcy5fbWFya01vZGlmaWVkKCk7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBtZW0gPSBjdXJbaV07XG4gICAgICBpZiAobWVtIGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICAgICAgY29uc3Qgc29tZSA9IHZhbHVlcy5zb21lKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4gbWVtLmVxdWFscyh2KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzb21lKSB7XG4gICAgICAgICAgW10uc3BsaWNlLmNhbGwoY3VyLCBpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh+Y3VyLmluZGV4T2YuY2FsbCh2YWx1ZXMsIG1lbSkpIHtcbiAgICAgICAgW10uc3BsaWNlLmNhbGwoY3VyLCBpLCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmFsdWVzWzBdIGluc3RhbmNlb2YgQXJyYXlTdWJkb2N1bWVudCkge1xuICAgICAgdGhpcy5fcmVnaXN0ZXJBdG9taWMoJyRwdWxsRG9jcycsIHZhbHVlcy5tYXAoZnVuY3Rpb24odikge1xuICAgICAgICBjb25zdCBfaWQgPSB2LiRfX2dldFZhbHVlKCdfaWQnKTtcbiAgICAgICAgaWYgKF9pZCA9PT0gdW5kZWZpbmVkIHx8IHYuJGlzRGVmYXVsdCgnX2lkJykpIHtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2lkO1xuICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZWdpc3RlckF0b21pYygnJHB1bGxBbGwnLCB2YWx1ZXMpO1xuICAgIH1cblxuXG4gICAgLy8gTWlnaHQgaGF2ZSBtb2RpZmllZCBjaGlsZCBwYXRocyBhbmQgdGhlbiBwdWxsZWQsIGxpa2VcbiAgICAvLyBgZG9jLmNoaWxkcmVuWzFdLm5hbWUgPSAndGVzdCc7YCBmb2xsb3dlZCBieVxuICAgIC8vIGBkb2MuY2hpbGRyZW4ucmVtb3ZlKGRvYy5jaGlsZHJlblswXSk7YC4gSW4gdGhpcyBjYXNlIHdlIGZhbGwgYmFja1xuICAgIC8vIHRvIGEgYCRzZXRgIG9uIHRoZSB3aG9sZSBhcnJheS4gU2VlICMzNTExXG4gICAgaWYgKGNsZWFuTW9kaWZpZWRTdWJwYXRocyh0aGlzW2FycmF5UGFyZW50U3ltYm9sXSwgdGhpc1thcnJheVBhdGhTeW1ib2xdKSA+IDApIHtcbiAgICAgIHRoaXMuX3JlZ2lzdGVyQXRvbWljKCckc2V0JywgdGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdyYXBzIFtgQXJyYXkjcHVzaGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3B1c2gpIHdpdGggcHJvcGVyIGNoYW5nZSB0cmFja2luZy5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKlxuICAgKiAgICAgY29uc3Qgc2NoZW1hID0gU2NoZW1hKHsgbnVtczogW051bWJlcl0gfSk7XG4gICAqICAgICBjb25zdCBNb2RlbCA9IG1vbmdvb3NlLm1vZGVsKCdUZXN0Jywgc2NoZW1hKTtcbiAgICpcbiAgICogICAgIGNvbnN0IGRvYyA9IGF3YWl0IE1vZGVsLmNyZWF0ZSh7IG51bXM6IFszLCA0XSB9KTtcbiAgICogICAgIGRvYy5udW1zLnB1c2goNSk7IC8vIEFkZCA1IHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5XG4gICAqICAgICBhd2FpdCBkb2Muc2F2ZSgpO1xuICAgKlxuICAgKiAgICAgLy8gWW91IGNhbiBhbHNvIHBhc3MgYW4gb2JqZWN0IHdpdGggYCRlYWNoYCBhcyB0aGVcbiAgICogICAgIC8vIGZpcnN0IHBhcmFtZXRlciB0byB1c2UgTW9uZ29EQidzIGAkcG9zaXRpb25gXG4gICAqICAgICBkb2MubnVtcy5wdXNoKHtcbiAgICogICAgICAgJGVhY2g6IFsxLCAyXSxcbiAgICogICAgICAgJHBvc2l0aW9uOiAwXG4gICAqICAgICB9KTtcbiAgICogICAgIGRvYy5udW1zOyAvLyBbMSwgMiwgMywgNCwgNV1cbiAgICpcbiAgICogQHBhcmFtIHsuLi5PYmplY3R9IFthcmdzXVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWV0aG9kIHB1c2hcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlQXJyYXlcbiAgICovXG5cbiAgcHVzaCgpIHtcbiAgICBsZXQgdmFsdWVzID0gYXJndW1lbnRzO1xuICAgIGxldCBhdG9taWMgPSB2YWx1ZXM7XG4gICAgY29uc3QgaXNPdmVyd3JpdGUgPSB2YWx1ZXNbMF0gIT0gbnVsbCAmJlxuICAgICAgdXRpbHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eSh2YWx1ZXNbMF0sICckZWFjaCcpO1xuICAgIGNvbnN0IGFyciA9IHV0aWxzLmlzTW9uZ29vc2VBcnJheSh0aGlzKSA/IHRoaXMuX19hcnJheSA6IHRoaXM7XG4gICAgaWYgKGlzT3ZlcndyaXRlKSB7XG4gICAgICBhdG9taWMgPSB2YWx1ZXNbMF07XG4gICAgICB2YWx1ZXMgPSB2YWx1ZXNbMF0uJGVhY2g7XG4gICAgfVxuXG4gICAgaWYgKHRoaXNbYXJyYXlTY2hlbWFTeW1ib2xdID09IG51bGwpIHtcbiAgICAgIHJldHVybiBfYmFzZVB1c2guYXBwbHkodGhpcywgdmFsdWVzKTtcbiAgICB9XG5cbiAgICBfY2hlY2tNYW51YWxQb3B1bGF0aW9uKHRoaXMsIHZhbHVlcyk7XG5cbiAgICB2YWx1ZXMgPSBbXS5tYXAuY2FsbCh2YWx1ZXMsIHRoaXMuX21hcENhc3QsIHRoaXMpO1xuICAgIGxldCByZXQ7XG4gICAgY29uc3QgYXRvbWljcyA9IHRoaXNbYXJyYXlBdG9taWNzU3ltYm9sXTtcbiAgICB0aGlzLl9tYXJrTW9kaWZpZWQoKTtcbiAgICBpZiAoaXNPdmVyd3JpdGUpIHtcbiAgICAgIGF0b21pYy4kZWFjaCA9IHZhbHVlcztcblxuICAgICAgaWYgKChhdG9taWNzLiRwdXNoICYmIGF0b21pY3MuJHB1c2guJGVhY2ggJiYgYXRvbWljcy4kcHVzaC4kZWFjaC5sZW5ndGggfHwgMCkgIT09IDAgJiZcbiAgICAgICAgICBhdG9taWNzLiRwdXNoLiRwb3NpdGlvbiAhPSBhdG9taWMuJHBvc2l0aW9uKSB7XG4gICAgICAgIGlmIChhdG9taWMuJHBvc2l0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICBbXS5zcGxpY2UuYXBwbHkoYXJyLCBbYXRvbWljLiRwb3NpdGlvbiwgMF0uY29uY2F0KHZhbHVlcykpO1xuICAgICAgICAgIHJldCA9IGFyci5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0ID0gW10ucHVzaC5hcHBseShhcnIsIHZhbHVlcyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yZWdpc3RlckF0b21pYygnJHNldCcsIHRoaXMpO1xuICAgICAgfSBlbHNlIGlmIChhdG9taWMuJHBvc2l0aW9uICE9IG51bGwpIHtcbiAgICAgICAgW10uc3BsaWNlLmFwcGx5KGFyciwgW2F0b21pYy4kcG9zaXRpb24sIDBdLmNvbmNhdCh2YWx1ZXMpKTtcbiAgICAgICAgcmV0ID0gdGhpcy5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBbXS5wdXNoLmFwcGx5KGFyciwgdmFsdWVzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXRvbWljID0gdmFsdWVzO1xuICAgICAgcmV0ID0gX2Jhc2VQdXNoLmFwcGx5KGFyciwgdmFsdWVzKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZWdpc3RlckF0b21pYygnJHB1c2gnLCBhdG9taWMpO1xuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFsaWFzIG9mIFtwdWxsXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2FycmF5Lmh0bWwjTW9uZ29vc2VBcnJheS5wcm90b3R5cGUucHVsbCgpKVxuICAgKlxuICAgKiBAc2VlIE1vbmdvb3NlQXJyYXkjcHVsbCBodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvYXBpL2FycmF5Lmh0bWwjTW9uZ29vc2VBcnJheS5wcm90b3R5cGUucHVsbCgpXG4gICAqIEBzZWUgbW9uZ29kYiBodHRwczovL3d3dy5tb25nb2RiLmNvbS9kb2NzL21hbnVhbC9yZWZlcmVuY2Uvb3BlcmF0b3IvdXBkYXRlL3B1bGwvXG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZW1iZXJPZiBNb25nb29zZUFycmF5XG4gICAqIEBpbnN0YW5jZVxuICAgKiBAbWV0aG9kIHJlbW92ZVxuICAgKi9cblxuICByZW1vdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucHVsbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjYXN0ZWQgYHZhbGAgYXQgaW5kZXggYGlgIGFuZCBtYXJrcyB0aGUgYXJyYXkgbW9kaWZpZWQuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICpcbiAgICogICAgIC8vIGdpdmVuIGRvY3VtZW50cyBiYXNlZCBvbiB0aGUgZm9sbG93aW5nXG4gICAqICAgICBjb25zdCBEb2MgPSBtb25nb29zZS5tb2RlbCgnRG9jJywgbmV3IFNjaGVtYSh7IGFycmF5OiBbTnVtYmVyXSB9KSk7XG4gICAqXG4gICAqICAgICBjb25zdCBkb2MgPSBuZXcgRG9jKHsgYXJyYXk6IFsyLDMsNF0gfSlcbiAgICpcbiAgICogICAgIGNvbnNvbGUubG9nKGRvYy5hcnJheSkgLy8gWzIsMyw0XVxuICAgKlxuICAgKiAgICAgZG9jLmFycmF5LnNldCgxLFwiNVwiKTtcbiAgICogICAgIGNvbnNvbGUubG9nKGRvYy5hcnJheSk7IC8vIFsyLDUsNF0gLy8gcHJvcGVybHkgY2FzdCB0byBudW1iZXJcbiAgICogICAgIGRvYy5zYXZlKCkgLy8gdGhlIGNoYW5nZSBpcyBzYXZlZFxuICAgKlxuICAgKiAgICAgLy8gVlMgbm90IHVzaW5nIGFycmF5I3NldFxuICAgKiAgICAgZG9jLmFycmF5WzFdID0gXCI1XCI7XG4gICAqICAgICBjb25zb2xlLmxvZyhkb2MuYXJyYXkpOyAvLyBbMixcIjVcIiw0XSAvLyBubyBjYXN0aW5nXG4gICAqICAgICBkb2Muc2F2ZSgpIC8vIGNoYW5nZSBpcyBub3Qgc2F2ZWRcbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9IHRoaXNcbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1ldGhvZCBzZXRcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlQXJyYXlcbiAgICovXG5cbiAgc2V0KGksIHZhbCwgc2tpcE1vZGlmaWVkKSB7XG4gICAgY29uc3QgYXJyID0gdGhpcy5fX2FycmF5O1xuICAgIGlmIChza2lwTW9kaWZpZWQpIHtcbiAgICAgIGFycltpXSA9IHZhbDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IG1ldGhvZHMuX2Nhc3QuY2FsbCh0aGlzLCB2YWwsIGkpO1xuICAgIG1ldGhvZHMuX21hcmtNb2RpZmllZC5jYWxsKHRoaXMsIGkpO1xuICAgIGFycltpXSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXcmFwcyBbYEFycmF5I3NoaWZ0YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvdW5zaGlmdCkgd2l0aCBwcm9wZXIgY2hhbmdlIHRyYWNraW5nLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqXG4gICAqICAgICBkb2MuYXJyYXkgPSBbMiwzXTtcbiAgICogICAgIGNvbnN0IHJlcyA9IGRvYy5hcnJheS5zaGlmdCgpO1xuICAgKiAgICAgY29uc29sZS5sb2cocmVzKSAvLyAyXG4gICAqICAgICBjb25zb2xlLmxvZyhkb2MuYXJyYXkpIC8vIFszXVxuICAgKlxuICAgKiAjIyMjIE5vdGU6XG4gICAqXG4gICAqIF9tYXJrcyB0aGUgZW50aXJlIGFycmF5IGFzIG1vZGlmaWVkLCB3aGljaCBpZiBzYXZlZCwgd2lsbCBzdG9yZSBpdCBhcyBhIGAkc2V0YCBvcGVyYXRpb24sIHBvdGVudGlhbGx5IG92ZXJ3cml0dGluZyBhbnkgY2hhbmdlcyB0aGF0IGhhcHBlbiBiZXR3ZWVuIHdoZW4geW91IHJldHJpZXZlZCB0aGUgb2JqZWN0IGFuZCB3aGVuIHlvdSBzYXZlIGl0Ll9cbiAgICpcbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1ldGhvZCBzaGlmdFxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKi9cblxuICBzaGlmdCgpIHtcbiAgICBjb25zdCBhcnIgPSB1dGlscy5pc01vbmdvb3NlQXJyYXkodGhpcykgPyB0aGlzLl9fYXJyYXkgOiB0aGlzO1xuICAgIHRoaXMuX21hcmtNb2RpZmllZCgpO1xuICAgIGNvbnN0IHJldCA9IFtdLnNoaWZ0LmNhbGwoYXJyKTtcbiAgICB0aGlzLl9yZWdpc3RlckF0b21pYygnJHNldCcsIHRoaXMpO1xuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdyYXBzIFtgQXJyYXkjc29ydGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvcnQpIHdpdGggcHJvcGVyIGNoYW5nZSB0cmFja2luZy5cbiAgICpcbiAgICogIyMjIyBOb3RlOlxuICAgKlxuICAgKiBfbWFya3MgdGhlIGVudGlyZSBhcnJheSBhcyBtb2RpZmllZCwgd2hpY2ggaWYgc2F2ZWQsIHdpbGwgc3RvcmUgaXQgYXMgYSBgJHNldGAgb3BlcmF0aW9uLCBwb3RlbnRpYWxseSBvdmVyd3JpdHRpbmcgYW55IGNoYW5nZXMgdGhhdCBoYXBwZW4gYmV0d2VlbiB3aGVuIHlvdSByZXRyaWV2ZWQgdGhlIG9iamVjdCBhbmQgd2hlbiB5b3Ugc2F2ZSBpdC5fXG4gICAqXG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZXRob2Qgc29ydFxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKiBAc2VlIE1hc3RlcmluZ0pTOiBBcnJheSBzb3J0IGh0dHBzOi8vbWFzdGVyaW5nanMuaW8vdHV0b3JpYWxzL2Z1bmRhbWVudGFscy9hcnJheS1zb3J0XG4gICAqL1xuXG4gIHNvcnQoKSB7XG4gICAgY29uc3QgYXJyID0gdXRpbHMuaXNNb25nb29zZUFycmF5KHRoaXMpID8gdGhpcy5fX2FycmF5IDogdGhpcztcbiAgICBjb25zdCByZXQgPSBbXS5zb3J0LmFwcGx5KGFyciwgYXJndW1lbnRzKTtcbiAgICB0aGlzLl9yZWdpc3RlckF0b21pYygnJHNldCcsIHRoaXMpO1xuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdyYXBzIFtgQXJyYXkjc3BsaWNlYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc3BsaWNlKSB3aXRoIHByb3BlciBjaGFuZ2UgdHJhY2tpbmcgYW5kIGNhc3RpbmcuXG4gICAqXG4gICAqICMjIyMgTm90ZTpcbiAgICpcbiAgICogX21hcmtzIHRoZSBlbnRpcmUgYXJyYXkgYXMgbW9kaWZpZWQsIHdoaWNoIGlmIHNhdmVkLCB3aWxsIHN0b3JlIGl0IGFzIGEgYCRzZXRgIG9wZXJhdGlvbiwgcG90ZW50aWFsbHkgb3ZlcndyaXR0aW5nIGFueSBjaGFuZ2VzIHRoYXQgaGFwcGVuIGJldHdlZW4gd2hlbiB5b3UgcmV0cmlldmVkIHRoZSBvYmplY3QgYW5kIHdoZW4geW91IHNhdmUgaXQuX1xuICAgKlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWV0aG9kIHNwbGljZVxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKiBAc2VlIE1hc3RlcmluZ0pTOiBBcnJheSBzcGxpY2UgaHR0cHM6Ly9tYXN0ZXJpbmdqcy5pby90dXRvcmlhbHMvZnVuZGFtZW50YWxzL2FycmF5LXNwbGljZVxuICAgKi9cblxuICBzcGxpY2UoKSB7XG4gICAgbGV0IHJldDtcbiAgICBjb25zdCBhcnIgPSB1dGlscy5pc01vbmdvb3NlQXJyYXkodGhpcykgPyB0aGlzLl9fYXJyYXkgOiB0aGlzO1xuXG4gICAgdGhpcy5fbWFya01vZGlmaWVkKCk7XG4gICAgX2NoZWNrTWFudWFsUG9wdWxhdGlvbih0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpKTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBsZXQgdmFscztcbiAgICAgIGlmICh0aGlzW2FycmF5U2NoZW1hU3ltYm9sXSA9PSBudWxsKSB7XG4gICAgICAgIHZhbHMgPSBhcmd1bWVudHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWxzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFsc1tpXSA9IGkgPCAyID9cbiAgICAgICAgICAgIGFyZ3VtZW50c1tpXSA6XG4gICAgICAgICAgICB0aGlzLl9jYXN0KGFyZ3VtZW50c1tpXSwgYXJndW1lbnRzWzBdICsgKGkgLSAyKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0ID0gW10uc3BsaWNlLmFwcGx5KGFyciwgdmFscyk7XG4gICAgICB0aGlzLl9yZWdpc3RlckF0b21pYygnJHNldCcsIHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgLyohXG4gICAqIGlnbm9yZVxuICAgKi9cblxuICB0b0JTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9PYmplY3QoaW50ZXJuYWxUb09iamVjdE9wdGlvbnMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmF0aXZlIGpzIEFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1ldGhvZCB0b09iamVjdFxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VBcnJheVxuICAgKi9cblxuICB0b09iamVjdChvcHRpb25zKSB7XG4gICAgY29uc3QgYXJyID0gdXRpbHMuaXNNb25nb29zZUFycmF5KHRoaXMpID8gdGhpcy5fX2FycmF5IDogdGhpcztcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmRlcG9wdWxhdGUpIHtcbiAgICAgIG9wdGlvbnMgPSBjbG9uZShvcHRpb25zKTtcbiAgICAgIG9wdGlvbnMuX2lzTmVzdGVkID0gdHJ1ZTtcbiAgICAgIC8vIEVuc3VyZSByZXR1cm4gdmFsdWUgaXMgYSB2YW5pbGxhIGFycmF5LCBiZWNhdXNlIGluIE5vZGUuanMgNisgYG1hcCgpYFxuICAgICAgLy8gaXMgc21hcnQgZW5vdWdoIHRvIHVzZSB0aGUgaW5oZXJpdGVkIGFycmF5J3MgY29uc3RydWN0b3IuXG4gICAgICByZXR1cm4gW10uY29uY2F0KGFycikubWFwKGZ1bmN0aW9uKGRvYykge1xuICAgICAgICByZXR1cm4gZG9jIGluc3RhbmNlb2YgRG9jdW1lbnRcbiAgICAgICAgICA/IGRvYy50b09iamVjdChvcHRpb25zKVxuICAgICAgICAgIDogZG9jO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdLmNvbmNhdChhcnIpO1xuICB9LFxuXG4gICR0b09iamVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUudG9PYmplY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSxcbiAgLyoqXG4gICAqIFdyYXBzIFtgQXJyYXkjdW5zaGlmdGBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3Vuc2hpZnQpIHdpdGggcHJvcGVyIGNoYW5nZSB0cmFja2luZy5cbiAgICpcbiAgICogIyMjIyBOb3RlOlxuICAgKlxuICAgKiBfbWFya3MgdGhlIGVudGlyZSBhcnJheSBhcyBtb2RpZmllZCwgd2hpY2ggaWYgc2F2ZWQsIHdpbGwgc3RvcmUgaXQgYXMgYSBgJHNldGAgb3BlcmF0aW9uLCBwb3RlbnRpYWxseSBvdmVyd3JpdGluZyBhbnkgY2hhbmdlcyB0aGF0IGhhcHBlbiBiZXR3ZWVuIHdoZW4geW91IHJldHJpZXZlZCB0aGUgb2JqZWN0IGFuZCB3aGVuIHlvdSBzYXZlIGl0Ll9cbiAgICpcbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1ldGhvZCB1bnNoaWZ0XG4gICAqIEBtZW1iZXJPZiBNb25nb29zZUFycmF5XG4gICAqL1xuXG4gIHVuc2hpZnQoKSB7XG4gICAgX2NoZWNrTWFudWFsUG9wdWxhdGlvbih0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgbGV0IHZhbHVlcztcbiAgICBpZiAodGhpc1thcnJheVNjaGVtYVN5bWJvbF0gPT0gbnVsbCkge1xuICAgICAgdmFsdWVzID0gYXJndW1lbnRzO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZXMgPSBbXS5tYXAuY2FsbChhcmd1bWVudHMsIHRoaXMuX2Nhc3QsIHRoaXMpO1xuICAgIH1cblxuICAgIGNvbnN0IGFyciA9IHV0aWxzLmlzTW9uZ29vc2VBcnJheSh0aGlzKSA/IHRoaXMuX19hcnJheSA6IHRoaXM7XG4gICAgdGhpcy5fbWFya01vZGlmaWVkKCk7XG4gICAgW10udW5zaGlmdC5hcHBseShhcnIsIHZhbHVlcyk7XG4gICAgdGhpcy5fcmVnaXN0ZXJBdG9taWMoJyRzZXQnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gIH1cbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZnVuY3Rpb24gX2lzQWxsU3ViZG9jcyhkb2NzLCByZWYpIHtcbiAgaWYgKCFyZWYpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGNvbnN0IGFyZyBvZiBkb2NzKSB7XG4gICAgaWYgKGFyZyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG1vZGVsID0gYXJnLmNvbnN0cnVjdG9yO1xuICAgIGlmICghKGFyZyBpbnN0YW5jZW9mIERvY3VtZW50KSB8fFxuICAgICAgKG1vZGVsLm1vZGVsTmFtZSAhPT0gcmVmICYmIG1vZGVsLmJhc2VNb2RlbE5hbWUgIT09IHJlZikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyohXG4gKiBNaW5pbWl6ZSBfanVzdF8gZW1wdHkgb2JqZWN0cyBhbG9uZyB0aGUgcGF0aCBjaGFpbiBzcGVjaWZpZWRcbiAqIGJ5IGBwYXJ0c2AsIGlnbm9yaW5nIGFsbCBvdGhlciBwYXRocy4gVXNlZnVsIGluIGNhc2VzIHdoZXJlXG4gKiB5b3Ugd2FudCB0byBtaW5pbWl6ZSBhZnRlciB1bnNldHRpbmcgYSBwYXRoLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgb2JqID0geyBmb286IHsgYmFyOiB7IGJhejoge30gfSB9LCBhOiB7fSB9O1xuICogICAgIF9taW5pbWl6ZVBhdGgob2JqLCAnZm9vLmJhci5iYXonKTtcbiAqICAgICBvYmo7IC8vIHsgYToge30gfVxuICovXG5cbmZ1bmN0aW9uIF9taW5pbWl6ZVBhdGgob2JqLCBwYXJ0cywgaSkge1xuICBpZiAodHlwZW9mIHBhcnRzID09PSAnc3RyaW5nJykge1xuICAgIGlmIChwYXJ0cy5pbmRleE9mKCcuJykgPT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcGFydHMgPSBtcGF0aC5zdHJpbmdUb1BhcnRzKHBhcnRzKTtcbiAgfVxuICBpID0gaSB8fCAwO1xuICBpZiAoaSA+PSBwYXJ0cy5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG9iaiA9PSBudWxsIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgX21pbmltaXplUGF0aChvYmpbcGFydHNbMF1dLCBwYXJ0cywgaSArIDEpO1xuICBpZiAob2JqW3BhcnRzWzBdXSAhPSBudWxsICYmIHR5cGVvZiBvYmpbcGFydHNbMF1dID09PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cyhvYmpbcGFydHNbMF1dKS5sZW5ndGggPT09IDApIHtcbiAgICBkZWxldGUgb2JqW3BhcnRzWzBdXTtcbiAgfVxufVxuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmZ1bmN0aW9uIF9jaGVja01hbnVhbFBvcHVsYXRpb24oYXJyLCBkb2NzKSB7XG4gIGNvbnN0IHJlZiA9IGFyciA9PSBudWxsID9cbiAgICBudWxsIDpcbiAgICBhcnJbYXJyYXlTY2hlbWFTeW1ib2xdICYmIGFyclthcnJheVNjaGVtYVN5bWJvbF0uY2FzdGVyICYmIGFyclthcnJheVNjaGVtYVN5bWJvbF0uY2FzdGVyLm9wdGlvbnMgJiYgYXJyW2FycmF5U2NoZW1hU3ltYm9sXS5jYXN0ZXIub3B0aW9ucy5yZWYgfHwgbnVsbDtcbiAgaWYgKGFyci5sZW5ndGggPT09IDAgJiZcbiAgICAgIGRvY3MubGVuZ3RoICE9PSAwKSB7XG4gICAgaWYgKF9pc0FsbFN1YmRvY3MoZG9jcywgcmVmKSkge1xuICAgICAgYXJyW2FycmF5UGFyZW50U3ltYm9sXS4kcG9wdWxhdGVkKGFyclthcnJheVBhdGhTeW1ib2xdLCBbXSwge1xuICAgICAgICBbcG9wdWxhdGVNb2RlbFN5bWJvbF06IGRvY3NbMF0uY29uc3RydWN0b3JcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCByZXR1cm5WYW5pbGxhQXJyYXlNZXRob2RzID0gW1xuICAnZmlsdGVyJyxcbiAgJ2ZsYXQnLFxuICAnZmxhdE1hcCcsXG4gICdtYXAnLFxuICAnc2xpY2UnXG5dO1xuZm9yIChjb25zdCBtZXRob2Qgb2YgcmV0dXJuVmFuaWxsYUFycmF5TWV0aG9kcykge1xuICBpZiAoQXJyYXkucHJvdG90eXBlW21ldGhvZF0gPT0gbnVsbCkge1xuICAgIGNvbnRpbnVlO1xuICB9XG5cbiAgbWV0aG9kc1ttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgX2FyciA9IHV0aWxzLmlzTW9uZ29vc2VBcnJheSh0aGlzKSA/IHRoaXMuX19hcnJheSA6IHRoaXM7XG4gICAgY29uc3QgYXJyID0gW10uY29uY2F0KF9hcnIpO1xuXG4gICAgcmV0dXJuIGFyclttZXRob2RdLmFwcGx5KGFyciwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZXRob2RzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/types/array/methods/index.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/types/buffer.js":
/*!************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/types/buffer.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*!\n * Module dependencies.\n */\n\n\n\nconst Binary = (__webpack_require__(/*! bson */ \"../backend/node_modules/bson/lib/bson.cjs\").Binary);\nconst utils = __webpack_require__(/*! ../utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\n\n/**\n * Mongoose Buffer constructor.\n *\n * Values always have to be passed to the constructor to initialize.\n *\n * @param {Buffer} value\n * @param {String} encode\n * @param {Number} offset\n * @api private\n * @inherits Buffer https://nodejs.org/api/buffer.html\n * @see https://bit.ly/f6CnZU\n */\n\nfunction MongooseBuffer(value, encode, offset) {\n  let val = value;\n  if (value == null) {\n    val = 0;\n  }\n\n  let encoding;\n  let path;\n  let doc;\n\n  if (Array.isArray(encode)) {\n    // internal casting\n    path = encode[0];\n    doc = encode[1];\n  } else {\n    encoding = encode;\n  }\n\n  let buf;\n  if (typeof val === 'number' || val instanceof Number) {\n    buf = Buffer.alloc(val);\n  } else { // string, array or object { type: 'Buffer', data: [...] }\n    buf = Buffer.from(val, encoding, offset);\n  }\n  utils.decorate(buf, MongooseBuffer.mixin);\n  buf.isMongooseBuffer = true;\n\n  // make sure these internal props don't show up in Object.keys()\n  buf[MongooseBuffer.pathSymbol] = path;\n  buf[parentSymbol] = doc;\n\n  buf._subtype = 0;\n  return buf;\n}\n\nconst pathSymbol = Symbol.for('mongoose#Buffer#_path');\nconst parentSymbol = Symbol.for('mongoose#Buffer#_parent');\nMongooseBuffer.pathSymbol = pathSymbol;\n\n/*!\n * Inherit from Buffer.\n */\n\nMongooseBuffer.mixin = {\n\n  /**\n   * Default subtype for the Binary representing this Buffer\n   *\n   * @api private\n   * @property _subtype\n   * @memberOf MongooseBuffer.mixin\n   * @static\n   */\n\n  _subtype: undefined,\n\n  /**\n   * Marks this buffer as modified.\n   *\n   * @api private\n   * @method _markModified\n   * @memberOf MongooseBuffer.mixin\n   * @static\n   */\n\n  _markModified: function() {\n    const parent = this[parentSymbol];\n\n    if (parent) {\n      parent.markModified(this[MongooseBuffer.pathSymbol]);\n    }\n    return this;\n  },\n\n  /**\n   * Writes the buffer.\n   *\n   * @api public\n   * @method write\n   * @memberOf MongooseBuffer.mixin\n   * @static\n   */\n\n  write: function() {\n    const written = Buffer.prototype.write.apply(this, arguments);\n\n    if (written > 0) {\n      this._markModified();\n    }\n\n    return written;\n  },\n\n  /**\n   * Copies the buffer.\n   *\n   * #### Note:\n   *\n   * `Buffer#copy` does not mark `target` as modified so you must copy from a `MongooseBuffer` for it to work as expected. This is a work around since `copy` modifies the target, not this.\n   *\n   * @return {Number} The number of bytes copied.\n   * @param {Buffer} target\n   * @method copy\n   * @memberOf MongooseBuffer.mixin\n   * @static\n   */\n\n  copy: function(target) {\n    const ret = Buffer.prototype.copy.apply(this, arguments);\n\n    if (target && target.isMongooseBuffer) {\n      target._markModified();\n    }\n\n    return ret;\n  }\n};\n\n/*!\n * Compile other Buffer methods marking this buffer as modified.\n */\n\nutils.each(\n  [\n    // node < 0.5\n    'writeUInt8', 'writeUInt16', 'writeUInt32', 'writeInt8', 'writeInt16', 'writeInt32',\n    'writeFloat', 'writeDouble', 'fill',\n    'utf8Write', 'binaryWrite', 'asciiWrite', 'set',\n\n    // node >= 0.5\n    'writeUInt16LE', 'writeUInt16BE', 'writeUInt32LE', 'writeUInt32BE',\n    'writeInt16LE', 'writeInt16BE', 'writeInt32LE', 'writeInt32BE', 'writeFloatLE', 'writeFloatBE', 'writeDoubleLE', 'writeDoubleBE']\n  , function(method) {\n    if (!Buffer.prototype[method]) {\n      return;\n    }\n    MongooseBuffer.mixin[method] = function() {\n      const ret = Buffer.prototype[method].apply(this, arguments);\n      this._markModified();\n      return ret;\n    };\n  });\n\n/**\n * Converts this buffer to its Binary type representation.\n *\n * #### SubTypes:\n *\n *     const bson = require('bson')\n *     bson.BSON_BINARY_SUBTYPE_DEFAULT\n *     bson.BSON_BINARY_SUBTYPE_FUNCTION\n *     bson.BSON_BINARY_SUBTYPE_BYTE_ARRAY\n *     bson.BSON_BINARY_SUBTYPE_UUID\n *     bson.BSON_BINARY_SUBTYPE_MD5\n *     bson.BSON_BINARY_SUBTYPE_USER_DEFINED\n *     doc.buffer.toObject(bson.BSON_BINARY_SUBTYPE_USER_DEFINED);\n *\n * @see bsonspec https://bsonspec.org/#/specification\n * @param {Hex} [subtype]\n * @return {Binary}\n * @api public\n * @method toObject\n * @memberOf MongooseBuffer\n */\n\nMongooseBuffer.mixin.toObject = function(options) {\n  const subtype = typeof options === 'number'\n    ? options\n    : (this._subtype || 0);\n  return new Binary(Buffer.from(this), subtype);\n};\n\nMongooseBuffer.mixin.$toObject = MongooseBuffer.mixin.toObject;\n\n/**\n * Converts this buffer for storage in MongoDB, including subtype\n *\n * @return {Binary}\n * @api public\n * @method toBSON\n * @memberOf MongooseBuffer\n */\n\nMongooseBuffer.mixin.toBSON = function() {\n  return new Binary(this, this._subtype || 0);\n};\n\n/**\n * Determines if this buffer is equals to `other` buffer\n *\n * @param {Buffer} other\n * @return {Boolean}\n * @method equals\n * @memberOf MongooseBuffer\n */\n\nMongooseBuffer.mixin.equals = function(other) {\n  if (!Buffer.isBuffer(other)) {\n    return false;\n  }\n\n  if (this.length !== other.length) {\n    return false;\n  }\n\n  for (let i = 0; i < this.length; ++i) {\n    if (this[i] !== other[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Sets the subtype option and marks the buffer modified.\n *\n * #### SubTypes:\n *\n *     const bson = require('bson')\n *     bson.BSON_BINARY_SUBTYPE_DEFAULT\n *     bson.BSON_BINARY_SUBTYPE_FUNCTION\n *     bson.BSON_BINARY_SUBTYPE_BYTE_ARRAY\n *     bson.BSON_BINARY_SUBTYPE_UUID\n *     bson.BSON_BINARY_SUBTYPE_MD5\n *     bson.BSON_BINARY_SUBTYPE_USER_DEFINED\n *\n *     doc.buffer.subtype(bson.BSON_BINARY_SUBTYPE_UUID);\n *\n * @see bsonspec https://bsonspec.org/#/specification\n * @param {Hex} subtype\n * @api public\n * @method subtype\n * @memberOf MongooseBuffer\n */\n\nMongooseBuffer.mixin.subtype = function(subtype) {\n  if (typeof subtype !== 'number') {\n    throw new TypeError('Invalid subtype. Expected a number');\n  }\n\n  if (this._subtype !== subtype) {\n    this._markModified();\n  }\n\n  this._subtype = subtype;\n};\n\n/*!\n * Module exports.\n */\n\nMongooseBuffer.Binary = Binary;\n\nmodule.exports = MongooseBuffer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL2J1ZmZlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsZUFBZSxxRkFBc0I7QUFDckMsY0FBYyxtQkFBTyxDQUFDLCtEQUFVOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLE9BQU8sNkJBQTZCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi90eXBlcy9idWZmZXIuanM/ZjdmOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCaW5hcnkgPSByZXF1aXJlKCdic29uJykuQmluYXJ5O1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIE1vbmdvb3NlIEJ1ZmZlciBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBWYWx1ZXMgYWx3YXlzIGhhdmUgdG8gYmUgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3RvciB0byBpbml0aWFsaXplLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSB2YWx1ZVxuICogQHBhcmFtIHtTdHJpbmd9IGVuY29kZVxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldFxuICogQGFwaSBwcml2YXRlXG4gKiBAaW5oZXJpdHMgQnVmZmVyIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvYnVmZmVyLmh0bWxcbiAqIEBzZWUgaHR0cHM6Ly9iaXQubHkvZjZDblpVXG4gKi9cblxuZnVuY3Rpb24gTW9uZ29vc2VCdWZmZXIodmFsdWUsIGVuY29kZSwgb2Zmc2V0KSB7XG4gIGxldCB2YWwgPSB2YWx1ZTtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB2YWwgPSAwO1xuICB9XG5cbiAgbGV0IGVuY29kaW5nO1xuICBsZXQgcGF0aDtcbiAgbGV0IGRvYztcblxuICBpZiAoQXJyYXkuaXNBcnJheShlbmNvZGUpKSB7XG4gICAgLy8gaW50ZXJuYWwgY2FzdGluZ1xuICAgIHBhdGggPSBlbmNvZGVbMF07XG4gICAgZG9jID0gZW5jb2RlWzFdO1xuICB9IGVsc2Uge1xuICAgIGVuY29kaW5nID0gZW5jb2RlO1xuICB9XG5cbiAgbGV0IGJ1ZjtcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInIHx8IHZhbCBpbnN0YW5jZW9mIE51bWJlcikge1xuICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvYyh2YWwpO1xuICB9IGVsc2UgeyAvLyBzdHJpbmcsIGFycmF5IG9yIG9iamVjdCB7IHR5cGU6ICdCdWZmZXInLCBkYXRhOiBbLi4uXSB9XG4gICAgYnVmID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZywgb2Zmc2V0KTtcbiAgfVxuICB1dGlscy5kZWNvcmF0ZShidWYsIE1vbmdvb3NlQnVmZmVyLm1peGluKTtcbiAgYnVmLmlzTW9uZ29vc2VCdWZmZXIgPSB0cnVlO1xuXG4gIC8vIG1ha2Ugc3VyZSB0aGVzZSBpbnRlcm5hbCBwcm9wcyBkb24ndCBzaG93IHVwIGluIE9iamVjdC5rZXlzKClcbiAgYnVmW01vbmdvb3NlQnVmZmVyLnBhdGhTeW1ib2xdID0gcGF0aDtcbiAgYnVmW3BhcmVudFN5bWJvbF0gPSBkb2M7XG5cbiAgYnVmLl9zdWJ0eXBlID0gMDtcbiAgcmV0dXJuIGJ1Zjtcbn1cblxuY29uc3QgcGF0aFN5bWJvbCA9IFN5bWJvbC5mb3IoJ21vbmdvb3NlI0J1ZmZlciNfcGF0aCcpO1xuY29uc3QgcGFyZW50U3ltYm9sID0gU3ltYm9sLmZvcignbW9uZ29vc2UjQnVmZmVyI19wYXJlbnQnKTtcbk1vbmdvb3NlQnVmZmVyLnBhdGhTeW1ib2wgPSBwYXRoU3ltYm9sO1xuXG4vKiFcbiAqIEluaGVyaXQgZnJvbSBCdWZmZXIuXG4gKi9cblxuTW9uZ29vc2VCdWZmZXIubWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgc3VidHlwZSBmb3IgdGhlIEJpbmFyeSByZXByZXNlbnRpbmcgdGhpcyBCdWZmZXJcbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqIEBwcm9wZXJ0eSBfc3VidHlwZVxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VCdWZmZXIubWl4aW5cbiAgICogQHN0YXRpY1xuICAgKi9cblxuICBfc3VidHlwZTogdW5kZWZpbmVkLFxuXG4gIC8qKlxuICAgKiBNYXJrcyB0aGlzIGJ1ZmZlciBhcyBtb2RpZmllZC5cbiAgICpcbiAgICogQGFwaSBwcml2YXRlXG4gICAqIEBtZXRob2QgX21hcmtNb2RpZmllZFxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VCdWZmZXIubWl4aW5cbiAgICogQHN0YXRpY1xuICAgKi9cblxuICBfbWFya01vZGlmaWVkOiBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzW3BhcmVudFN5bWJvbF07XG5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBwYXJlbnQubWFya01vZGlmaWVkKHRoaXNbTW9uZ29vc2VCdWZmZXIucGF0aFN5bWJvbF0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogV3JpdGVzIHRoZSBidWZmZXIuXG4gICAqXG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZXRob2Qgd3JpdGVcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlQnVmZmVyLm1peGluXG4gICAqIEBzdGF0aWNcbiAgICovXG5cbiAgd3JpdGU6IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IHdyaXR0ZW4gPSBCdWZmZXIucHJvdG90eXBlLndyaXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBpZiAod3JpdHRlbiA+IDApIHtcbiAgICAgIHRoaXMuX21hcmtNb2RpZmllZCgpO1xuICAgIH1cblxuICAgIHJldHVybiB3cml0dGVuO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIGJ1ZmZlci5cbiAgICpcbiAgICogIyMjIyBOb3RlOlxuICAgKlxuICAgKiBgQnVmZmVyI2NvcHlgIGRvZXMgbm90IG1hcmsgYHRhcmdldGAgYXMgbW9kaWZpZWQgc28geW91IG11c3QgY29weSBmcm9tIGEgYE1vbmdvb3NlQnVmZmVyYCBmb3IgaXQgdG8gd29yayBhcyBleHBlY3RlZC4gVGhpcyBpcyBhIHdvcmsgYXJvdW5kIHNpbmNlIGBjb3B5YCBtb2RpZmllcyB0aGUgdGFyZ2V0LCBub3QgdGhpcy5cbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgbnVtYmVyIG9mIGJ5dGVzIGNvcGllZC5cbiAgICogQHBhcmFtIHtCdWZmZXJ9IHRhcmdldFxuICAgKiBAbWV0aG9kIGNvcHlcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlQnVmZmVyLm1peGluXG4gICAqIEBzdGF0aWNcbiAgICovXG5cbiAgY29weTogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgY29uc3QgcmV0ID0gQnVmZmVyLnByb3RvdHlwZS5jb3B5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBpZiAodGFyZ2V0ICYmIHRhcmdldC5pc01vbmdvb3NlQnVmZmVyKSB7XG4gICAgICB0YXJnZXQuX21hcmtNb2RpZmllZCgpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH1cbn07XG5cbi8qIVxuICogQ29tcGlsZSBvdGhlciBCdWZmZXIgbWV0aG9kcyBtYXJraW5nIHRoaXMgYnVmZmVyIGFzIG1vZGlmaWVkLlxuICovXG5cbnV0aWxzLmVhY2goXG4gIFtcbiAgICAvLyBub2RlIDwgMC41XG4gICAgJ3dyaXRlVUludDgnLCAnd3JpdGVVSW50MTYnLCAnd3JpdGVVSW50MzInLCAnd3JpdGVJbnQ4JywgJ3dyaXRlSW50MTYnLCAnd3JpdGVJbnQzMicsXG4gICAgJ3dyaXRlRmxvYXQnLCAnd3JpdGVEb3VibGUnLCAnZmlsbCcsXG4gICAgJ3V0ZjhXcml0ZScsICdiaW5hcnlXcml0ZScsICdhc2NpaVdyaXRlJywgJ3NldCcsXG5cbiAgICAvLyBub2RlID49IDAuNVxuICAgICd3cml0ZVVJbnQxNkxFJywgJ3dyaXRlVUludDE2QkUnLCAnd3JpdGVVSW50MzJMRScsICd3cml0ZVVJbnQzMkJFJyxcbiAgICAnd3JpdGVJbnQxNkxFJywgJ3dyaXRlSW50MTZCRScsICd3cml0ZUludDMyTEUnLCAnd3JpdGVJbnQzMkJFJywgJ3dyaXRlRmxvYXRMRScsICd3cml0ZUZsb2F0QkUnLCAnd3JpdGVEb3VibGVMRScsICd3cml0ZURvdWJsZUJFJ11cbiAgLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgICBpZiAoIUJ1ZmZlci5wcm90b3R5cGVbbWV0aG9kXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBNb25nb29zZUJ1ZmZlci5taXhpblttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCByZXQgPSBCdWZmZXIucHJvdG90eXBlW21ldGhvZF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMuX21hcmtNb2RpZmllZCgpO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICB9KTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGJ1ZmZlciB0byBpdHMgQmluYXJ5IHR5cGUgcmVwcmVzZW50YXRpb24uXG4gKlxuICogIyMjIyBTdWJUeXBlczpcbiAqXG4gKiAgICAgY29uc3QgYnNvbiA9IHJlcXVpcmUoJ2Jzb24nKVxuICogICAgIGJzb24uQlNPTl9CSU5BUllfU1VCVFlQRV9ERUZBVUxUXG4gKiAgICAgYnNvbi5CU09OX0JJTkFSWV9TVUJUWVBFX0ZVTkNUSU9OXG4gKiAgICAgYnNvbi5CU09OX0JJTkFSWV9TVUJUWVBFX0JZVEVfQVJSQVlcbiAqICAgICBic29uLkJTT05fQklOQVJZX1NVQlRZUEVfVVVJRFxuICogICAgIGJzb24uQlNPTl9CSU5BUllfU1VCVFlQRV9NRDVcbiAqICAgICBic29uLkJTT05fQklOQVJZX1NVQlRZUEVfVVNFUl9ERUZJTkVEXG4gKiAgICAgZG9jLmJ1ZmZlci50b09iamVjdChic29uLkJTT05fQklOQVJZX1NVQlRZUEVfVVNFUl9ERUZJTkVEKTtcbiAqXG4gKiBAc2VlIGJzb25zcGVjIGh0dHBzOi8vYnNvbnNwZWMub3JnLyMvc3BlY2lmaWNhdGlvblxuICogQHBhcmFtIHtIZXh9IFtzdWJ0eXBlXVxuICogQHJldHVybiB7QmluYXJ5fVxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgdG9PYmplY3RcbiAqIEBtZW1iZXJPZiBNb25nb29zZUJ1ZmZlclxuICovXG5cbk1vbmdvb3NlQnVmZmVyLm1peGluLnRvT2JqZWN0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBjb25zdCBzdWJ0eXBlID0gdHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInXG4gICAgPyBvcHRpb25zXG4gICAgOiAodGhpcy5fc3VidHlwZSB8fCAwKTtcbiAgcmV0dXJuIG5ldyBCaW5hcnkoQnVmZmVyLmZyb20odGhpcyksIHN1YnR5cGUpO1xufTtcblxuTW9uZ29vc2VCdWZmZXIubWl4aW4uJHRvT2JqZWN0ID0gTW9uZ29vc2VCdWZmZXIubWl4aW4udG9PYmplY3Q7XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBidWZmZXIgZm9yIHN0b3JhZ2UgaW4gTW9uZ29EQiwgaW5jbHVkaW5nIHN1YnR5cGVcbiAqXG4gKiBAcmV0dXJuIHtCaW5hcnl9XG4gKiBAYXBpIHB1YmxpY1xuICogQG1ldGhvZCB0b0JTT05cbiAqIEBtZW1iZXJPZiBNb25nb29zZUJ1ZmZlclxuICovXG5cbk1vbmdvb3NlQnVmZmVyLm1peGluLnRvQlNPTiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IEJpbmFyeSh0aGlzLCB0aGlzLl9zdWJ0eXBlIHx8IDApO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoaXMgYnVmZmVyIGlzIGVxdWFscyB0byBgb3RoZXJgIGJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBvdGhlclxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBtZXRob2QgZXF1YWxzXG4gKiBAbWVtYmVyT2YgTW9uZ29vc2VCdWZmZXJcbiAqL1xuXG5Nb25nb29zZUJ1ZmZlci5taXhpbi5lcXVhbHMgPSBmdW5jdGlvbihvdGhlcikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihvdGhlcikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5sZW5ndGggIT09IG90aGVyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7ICsraSkge1xuICAgIGlmICh0aGlzW2ldICE9PSBvdGhlcltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBzdWJ0eXBlIG9wdGlvbiBhbmQgbWFya3MgdGhlIGJ1ZmZlciBtb2RpZmllZC5cbiAqXG4gKiAjIyMjIFN1YlR5cGVzOlxuICpcbiAqICAgICBjb25zdCBic29uID0gcmVxdWlyZSgnYnNvbicpXG4gKiAgICAgYnNvbi5CU09OX0JJTkFSWV9TVUJUWVBFX0RFRkFVTFRcbiAqICAgICBic29uLkJTT05fQklOQVJZX1NVQlRZUEVfRlVOQ1RJT05cbiAqICAgICBic29uLkJTT05fQklOQVJZX1NVQlRZUEVfQllURV9BUlJBWVxuICogICAgIGJzb24uQlNPTl9CSU5BUllfU1VCVFlQRV9VVUlEXG4gKiAgICAgYnNvbi5CU09OX0JJTkFSWV9TVUJUWVBFX01ENVxuICogICAgIGJzb24uQlNPTl9CSU5BUllfU1VCVFlQRV9VU0VSX0RFRklORURcbiAqXG4gKiAgICAgZG9jLmJ1ZmZlci5zdWJ0eXBlKGJzb24uQlNPTl9CSU5BUllfU1VCVFlQRV9VVUlEKTtcbiAqXG4gKiBAc2VlIGJzb25zcGVjIGh0dHBzOi8vYnNvbnNwZWMub3JnLyMvc3BlY2lmaWNhdGlvblxuICogQHBhcmFtIHtIZXh9IHN1YnR5cGVcbiAqIEBhcGkgcHVibGljXG4gKiBAbWV0aG9kIHN1YnR5cGVcbiAqIEBtZW1iZXJPZiBNb25nb29zZUJ1ZmZlclxuICovXG5cbk1vbmdvb3NlQnVmZmVyLm1peGluLnN1YnR5cGUgPSBmdW5jdGlvbihzdWJ0eXBlKSB7XG4gIGlmICh0eXBlb2Ygc3VidHlwZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHN1YnR5cGUuIEV4cGVjdGVkIGEgbnVtYmVyJyk7XG4gIH1cblxuICBpZiAodGhpcy5fc3VidHlwZSAhPT0gc3VidHlwZSkge1xuICAgIHRoaXMuX21hcmtNb2RpZmllZCgpO1xuICB9XG5cbiAgdGhpcy5fc3VidHlwZSA9IHN1YnR5cGU7XG59O1xuXG4vKiFcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbk1vbmdvb3NlQnVmZmVyLkJpbmFyeSA9IEJpbmFyeTtcblxubW9kdWxlLmV4cG9ydHMgPSBNb25nb29zZUJ1ZmZlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/types/buffer.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/types/decimal128.js":
/*!****************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/types/decimal128.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * Decimal128 type constructor\n *\n * #### Example:\n *\n *     const id = new mongoose.Types.Decimal128('3.1415');\n *\n * @constructor Decimal128\n */\n\n\n\nmodule.exports = __webpack_require__(/*! bson */ \"../backend/node_modules/bson/lib/bson.cjs\").Decimal128;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL2RlY2ltYWwxMjguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLHdHQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi90eXBlcy9kZWNpbWFsMTI4LmpzPzQzYzYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBEZWNpbWFsMTI4IHR5cGUgY29uc3RydWN0b3JcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGlkID0gbmV3IG1vbmdvb3NlLlR5cGVzLkRlY2ltYWwxMjgoJzMuMTQxNScpO1xuICpcbiAqIEBjb25zdHJ1Y3RvciBEZWNpbWFsMTI4XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2Jzb24nKS5EZWNpbWFsMTI4O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/types/decimal128.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/types/documentArray/index.js":
/*!*************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/types/documentArray/index.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst ArrayMethods = __webpack_require__(/*! ../array/methods */ \"../backend/node_modules/mongoose/lib/types/array/methods/index.js\");\nconst DocumentArrayMethods = __webpack_require__(/*! ./methods */ \"../backend/node_modules/mongoose/lib/types/documentArray/methods/index.js\");\nconst Document = __webpack_require__(/*! ../../document */ \"../backend/node_modules/mongoose/lib/document.js\");\n\nconst arrayAtomicsSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsSymbol);\nconst arrayAtomicsBackupSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").arrayAtomicsBackupSymbol);\nconst arrayParentSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").arrayParentSymbol);\nconst arrayPathSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").arrayPathSymbol);\nconst arraySchemaSymbol = (__webpack_require__(/*! ../../helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").arraySchemaSymbol);\n\nconst _basePush = Array.prototype.push;\nconst numberRE = /^\\d+$/;\n/**\n * DocumentArray constructor\n *\n * @param {Array} values\n * @param {String} path the path to this array\n * @param {Document} doc parent document\n * @api private\n * @return {MongooseDocumentArray}\n * @inherits MongooseArray\n * @see https://bit.ly/f6CnZU\n */\n\nfunction MongooseDocumentArray(values, path, doc) {\n  const __array = [];\n\n  const internals = {\n    [arrayAtomicsSymbol]: {},\n    [arrayAtomicsBackupSymbol]: void 0,\n    [arrayPathSymbol]: path,\n    [arraySchemaSymbol]: void 0,\n    [arrayParentSymbol]: void 0\n  };\n\n  if (Array.isArray(values)) {\n    if (values[arrayPathSymbol] === path &&\n        values[arrayParentSymbol] === doc) {\n      internals[arrayAtomicsSymbol] = Object.assign({}, values[arrayAtomicsSymbol]);\n    }\n    values.forEach(v => {\n      _basePush.call(__array, v);\n    });\n  }\n  internals[arrayPathSymbol] = path;\n  internals.__array = __array;\n\n  // Because doc comes from the context of another function, doc === global\n  // can happen if there was a null somewhere up the chain (see #3020 && #3034)\n  // RB Jun 17, 2015 updated to check for presence of expected paths instead\n  // to make more proof against unusual node environments\n  if (doc && doc instanceof Document) {\n    internals[arrayParentSymbol] = doc;\n    internals[arraySchemaSymbol] = doc.$__schema.path(path);\n\n    // `schema.path()` doesn't drill into nested arrays properly yet, see\n    // gh-6398, gh-6602. This is a workaround because nested arrays are\n    // always plain non-document arrays, so once you get to a document array\n    // nesting is done. Matryoshka code.\n    while (internals[arraySchemaSymbol] != null &&\n        internals[arraySchemaSymbol].$isMongooseArray &&\n        !internals[arraySchemaSymbol].$isMongooseDocumentArray) {\n      internals[arraySchemaSymbol] = internals[arraySchemaSymbol].casterConstructor;\n    }\n  }\n\n  const proxy = new Proxy(__array, {\n    get: function(target, prop) {\n      if (prop === 'isMongooseArray' ||\n          prop === 'isMongooseArrayProxy' ||\n          prop === 'isMongooseDocumentArray' ||\n          prop === 'isMongooseDocumentArrayProxy') {\n        return true;\n      }\n      if (internals.hasOwnProperty(prop)) {\n        return internals[prop];\n      }\n      if (DocumentArrayMethods.hasOwnProperty(prop)) {\n        return DocumentArrayMethods[prop];\n      }\n      if (ArrayMethods.hasOwnProperty(prop)) {\n        return ArrayMethods[prop];\n      }\n\n      return __array[prop];\n    },\n    set: function(target, prop, value) {\n      if (typeof prop === 'string' && numberRE.test(prop)) {\n        DocumentArrayMethods.set.call(proxy, prop, value, false);\n      } else if (internals.hasOwnProperty(prop)) {\n        internals[prop] = value;\n      } else {\n        __array[prop] = value;\n      }\n\n      return true;\n    }\n  });\n\n  return proxy;\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = MongooseDocumentArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL2RvY3VtZW50QXJyYXkvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixtQkFBTyxDQUFDLDJGQUFrQjtBQUMvQyw2QkFBNkIsbUJBQU8sQ0FBQyw0RkFBVztBQUNoRCxpQkFBaUIsbUJBQU8sQ0FBQyx3RUFBZ0I7O0FBRXpDLDJCQUEyQixnSUFBbUQ7QUFDOUUsaUNBQWlDLHNJQUF5RDtBQUMxRiwwQkFBMEIsK0hBQWtEO0FBQzVFLHdCQUF3Qiw2SEFBZ0Q7QUFDeEUsMEJBQTBCLCtIQUFrRDs7QUFFNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi90eXBlcy9kb2N1bWVudEFycmF5L2luZGV4LmpzPzdhY2MiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgQXJyYXlNZXRob2RzID0gcmVxdWlyZSgnLi4vYXJyYXkvbWV0aG9kcycpO1xuY29uc3QgRG9jdW1lbnRBcnJheU1ldGhvZHMgPSByZXF1aXJlKCcuL21ldGhvZHMnKTtcbmNvbnN0IERvY3VtZW50ID0gcmVxdWlyZSgnLi4vLi4vZG9jdW1lbnQnKTtcblxuY29uc3QgYXJyYXlBdG9taWNzU3ltYm9sID0gcmVxdWlyZSgnLi4vLi4vaGVscGVycy9zeW1ib2xzJykuYXJyYXlBdG9taWNzU3ltYm9sO1xuY29uc3QgYXJyYXlBdG9taWNzQmFja3VwU3ltYm9sID0gcmVxdWlyZSgnLi4vLi4vaGVscGVycy9zeW1ib2xzJykuYXJyYXlBdG9taWNzQmFja3VwU3ltYm9sO1xuY29uc3QgYXJyYXlQYXJlbnRTeW1ib2wgPSByZXF1aXJlKCcuLi8uLi9oZWxwZXJzL3N5bWJvbHMnKS5hcnJheVBhcmVudFN5bWJvbDtcbmNvbnN0IGFycmF5UGF0aFN5bWJvbCA9IHJlcXVpcmUoJy4uLy4uL2hlbHBlcnMvc3ltYm9scycpLmFycmF5UGF0aFN5bWJvbDtcbmNvbnN0IGFycmF5U2NoZW1hU3ltYm9sID0gcmVxdWlyZSgnLi4vLi4vaGVscGVycy9zeW1ib2xzJykuYXJyYXlTY2hlbWFTeW1ib2w7XG5cbmNvbnN0IF9iYXNlUHVzaCA9IEFycmF5LnByb3RvdHlwZS5wdXNoO1xuY29uc3QgbnVtYmVyUkUgPSAvXlxcZCskLztcbi8qKlxuICogRG9jdW1lbnRBcnJheSBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlc1xuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdGhlIHBhdGggdG8gdGhpcyBhcnJheVxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jIHBhcmVudCBkb2N1bWVudFxuICogQGFwaSBwcml2YXRlXG4gKiBAcmV0dXJuIHtNb25nb29zZURvY3VtZW50QXJyYXl9XG4gKiBAaW5oZXJpdHMgTW9uZ29vc2VBcnJheVxuICogQHNlZSBodHRwczovL2JpdC5seS9mNkNuWlVcbiAqL1xuXG5mdW5jdGlvbiBNb25nb29zZURvY3VtZW50QXJyYXkodmFsdWVzLCBwYXRoLCBkb2MpIHtcbiAgY29uc3QgX19hcnJheSA9IFtdO1xuXG4gIGNvbnN0IGludGVybmFscyA9IHtcbiAgICBbYXJyYXlBdG9taWNzU3ltYm9sXToge30sXG4gICAgW2FycmF5QXRvbWljc0JhY2t1cFN5bWJvbF06IHZvaWQgMCxcbiAgICBbYXJyYXlQYXRoU3ltYm9sXTogcGF0aCxcbiAgICBbYXJyYXlTY2hlbWFTeW1ib2xdOiB2b2lkIDAsXG4gICAgW2FycmF5UGFyZW50U3ltYm9sXTogdm9pZCAwXG4gIH07XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgIGlmICh2YWx1ZXNbYXJyYXlQYXRoU3ltYm9sXSA9PT0gcGF0aCAmJlxuICAgICAgICB2YWx1ZXNbYXJyYXlQYXJlbnRTeW1ib2xdID09PSBkb2MpIHtcbiAgICAgIGludGVybmFsc1thcnJheUF0b21pY3NTeW1ib2xdID0gT2JqZWN0LmFzc2lnbih7fSwgdmFsdWVzW2FycmF5QXRvbWljc1N5bWJvbF0pO1xuICAgIH1cbiAgICB2YWx1ZXMuZm9yRWFjaCh2ID0+IHtcbiAgICAgIF9iYXNlUHVzaC5jYWxsKF9fYXJyYXksIHYpO1xuICAgIH0pO1xuICB9XG4gIGludGVybmFsc1thcnJheVBhdGhTeW1ib2xdID0gcGF0aDtcbiAgaW50ZXJuYWxzLl9fYXJyYXkgPSBfX2FycmF5O1xuXG4gIC8vIEJlY2F1c2UgZG9jIGNvbWVzIGZyb20gdGhlIGNvbnRleHQgb2YgYW5vdGhlciBmdW5jdGlvbiwgZG9jID09PSBnbG9iYWxcbiAgLy8gY2FuIGhhcHBlbiBpZiB0aGVyZSB3YXMgYSBudWxsIHNvbWV3aGVyZSB1cCB0aGUgY2hhaW4gKHNlZSAjMzAyMCAmJiAjMzAzNClcbiAgLy8gUkIgSnVuIDE3LCAyMDE1IHVwZGF0ZWQgdG8gY2hlY2sgZm9yIHByZXNlbmNlIG9mIGV4cGVjdGVkIHBhdGhzIGluc3RlYWRcbiAgLy8gdG8gbWFrZSBtb3JlIHByb29mIGFnYWluc3QgdW51c3VhbCBub2RlIGVudmlyb25tZW50c1xuICBpZiAoZG9jICYmIGRvYyBpbnN0YW5jZW9mIERvY3VtZW50KSB7XG4gICAgaW50ZXJuYWxzW2FycmF5UGFyZW50U3ltYm9sXSA9IGRvYztcbiAgICBpbnRlcm5hbHNbYXJyYXlTY2hlbWFTeW1ib2xdID0gZG9jLiRfX3NjaGVtYS5wYXRoKHBhdGgpO1xuXG4gICAgLy8gYHNjaGVtYS5wYXRoKClgIGRvZXNuJ3QgZHJpbGwgaW50byBuZXN0ZWQgYXJyYXlzIHByb3Blcmx5IHlldCwgc2VlXG4gICAgLy8gZ2gtNjM5OCwgZ2gtNjYwMi4gVGhpcyBpcyBhIHdvcmthcm91bmQgYmVjYXVzZSBuZXN0ZWQgYXJyYXlzIGFyZVxuICAgIC8vIGFsd2F5cyBwbGFpbiBub24tZG9jdW1lbnQgYXJyYXlzLCBzbyBvbmNlIHlvdSBnZXQgdG8gYSBkb2N1bWVudCBhcnJheVxuICAgIC8vIG5lc3RpbmcgaXMgZG9uZS4gTWF0cnlvc2hrYSBjb2RlLlxuICAgIHdoaWxlIChpbnRlcm5hbHNbYXJyYXlTY2hlbWFTeW1ib2xdICE9IG51bGwgJiZcbiAgICAgICAgaW50ZXJuYWxzW2FycmF5U2NoZW1hU3ltYm9sXS4kaXNNb25nb29zZUFycmF5ICYmXG4gICAgICAgICFpbnRlcm5hbHNbYXJyYXlTY2hlbWFTeW1ib2xdLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSkge1xuICAgICAgaW50ZXJuYWxzW2FycmF5U2NoZW1hU3ltYm9sXSA9IGludGVybmFsc1thcnJheVNjaGVtYVN5bWJvbF0uY2FzdGVyQ29uc3RydWN0b3I7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkoX19hcnJheSwge1xuICAgIGdldDogZnVuY3Rpb24odGFyZ2V0LCBwcm9wKSB7XG4gICAgICBpZiAocHJvcCA9PT0gJ2lzTW9uZ29vc2VBcnJheScgfHxcbiAgICAgICAgICBwcm9wID09PSAnaXNNb25nb29zZUFycmF5UHJveHknIHx8XG4gICAgICAgICAgcHJvcCA9PT0gJ2lzTW9uZ29vc2VEb2N1bWVudEFycmF5JyB8fFxuICAgICAgICAgIHByb3AgPT09ICdpc01vbmdvb3NlRG9jdW1lbnRBcnJheVByb3h5Jykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpbnRlcm5hbHMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFsc1twcm9wXTtcbiAgICAgIH1cbiAgICAgIGlmIChEb2N1bWVudEFycmF5TWV0aG9kcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICByZXR1cm4gRG9jdW1lbnRBcnJheU1ldGhvZHNbcHJvcF07XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXlNZXRob2RzLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIHJldHVybiBBcnJheU1ldGhvZHNbcHJvcF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfX2FycmF5W3Byb3BdO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnICYmIG51bWJlclJFLnRlc3QocHJvcCkpIHtcbiAgICAgICAgRG9jdW1lbnRBcnJheU1ldGhvZHMuc2V0LmNhbGwocHJveHksIHByb3AsIHZhbHVlLCBmYWxzZSk7XG4gICAgICB9IGVsc2UgaWYgKGludGVybmFscy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICBpbnRlcm5hbHNbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9fYXJyYXlbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcHJveHk7XG59XG5cbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBNb25nb29zZURvY3VtZW50QXJyYXk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/types/documentArray/index.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/types/documentArray/isMongooseDocumentArray.js":
/*!*******************************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/types/documentArray/isMongooseDocumentArray.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.isMongooseDocumentArray = function(mongooseDocumentArray) {\n  return Array.isArray(mongooseDocumentArray) && mongooseDocumentArray.isMongooseDocumentArray;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL2RvY3VtZW50QXJyYXkvaXNNb25nb29zZURvY3VtZW50QXJyYXkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsK0JBQStCO0FBQy9CO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdHlwZXMvZG9jdW1lbnRBcnJheS9pc01vbmdvb3NlRG9jdW1lbnRBcnJheS5qcz82YTBjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5pc01vbmdvb3NlRG9jdW1lbnRBcnJheSA9IGZ1bmN0aW9uKG1vbmdvb3NlRG9jdW1lbnRBcnJheSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShtb25nb29zZURvY3VtZW50QXJyYXkpICYmIG1vbmdvb3NlRG9jdW1lbnRBcnJheS5pc01vbmdvb3NlRG9jdW1lbnRBcnJheTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/types/documentArray/isMongooseDocumentArray.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/types/documentArray/methods/index.js":
/*!*********************************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/types/documentArray/methods/index.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst ArrayMethods = __webpack_require__(/*! ../../array/methods */ \"../backend/node_modules/mongoose/lib/types/array/methods/index.js\");\nconst Document = __webpack_require__(/*! ../../../document */ \"../backend/node_modules/mongoose/lib/document.js\");\nconst castObjectId = __webpack_require__(/*! ../../../cast/objectid */ \"../backend/node_modules/mongoose/lib/cast/objectid.js\");\nconst getDiscriminatorByValue = __webpack_require__(/*! ../../../helpers/discriminator/getDiscriminatorByValue */ \"../backend/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js\");\nconst internalToObjectOptions = (__webpack_require__(/*! ../../../options */ \"../backend/node_modules/mongoose/lib/options.js\").internalToObjectOptions);\nconst utils = __webpack_require__(/*! ../../../utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\nconst isBsonType = __webpack_require__(/*! ../../../helpers/isBsonType */ \"../backend/node_modules/mongoose/lib/helpers/isBsonType.js\");\n\nconst arrayParentSymbol = (__webpack_require__(/*! ../../../helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").arrayParentSymbol);\nconst arrayPathSymbol = (__webpack_require__(/*! ../../../helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").arrayPathSymbol);\nconst arraySchemaSymbol = (__webpack_require__(/*! ../../../helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").arraySchemaSymbol);\nconst documentArrayParent = (__webpack_require__(/*! ../../../helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").documentArrayParent);\n\nconst _baseToString = Array.prototype.toString;\n\nconst methods = {\n  /*!\n   * ignore\n   */\n\n  toBSON() {\n    return this.toObject(internalToObjectOptions);\n  },\n\n  toString() {\n    return _baseToString.call(this.__array.map(subdoc => {\n      if (subdoc != null && subdoc.$__ != null) {\n        return subdoc.toString();\n      }\n      return subdoc;\n    }));\n  },\n\n  /*!\n   * ignore\n   */\n\n  getArrayParent() {\n    return this[arrayParentSymbol];\n  },\n\n  /**\n   * Overrides MongooseArray#cast\n   *\n   * @method _cast\n   * @api private\n   * @memberOf MongooseDocumentArray\n   */\n\n  _cast(value, index, options) {\n    if (this[arraySchemaSymbol] == null) {\n      return value;\n    }\n    let Constructor = this[arraySchemaSymbol].casterConstructor;\n    const isInstance = Constructor.$isMongooseDocumentArray ?\n      utils.isMongooseDocumentArray(value) :\n      value instanceof Constructor;\n    if (isInstance ||\n        // Hack re: #5001, see #5005\n        (value && value.constructor && value.constructor.baseCasterConstructor === Constructor)) {\n      if (!(value[documentArrayParent] && value.__parentArray)) {\n        // value may have been created using array.create()\n        value[documentArrayParent] = this[arrayParentSymbol];\n        value.__parentArray = this;\n      }\n      value.$setIndex(index);\n      return value;\n    }\n\n    if (value === undefined || value === null) {\n      return null;\n    }\n\n    // handle cast('string') or cast(ObjectId) etc.\n    // only objects are permitted so we can safely assume that\n    // non-objects are to be interpreted as _id\n    if (Buffer.isBuffer(value) ||\n        isBsonType(value, 'ObjectId') || !utils.isObject(value)) {\n      value = { _id: value };\n    }\n\n    if (value &&\n        Constructor.discriminators &&\n        Constructor.schema &&\n        Constructor.schema.options &&\n        Constructor.schema.options.discriminatorKey) {\n      if (typeof value[Constructor.schema.options.discriminatorKey] === 'string' &&\n          Constructor.discriminators[value[Constructor.schema.options.discriminatorKey]]) {\n        Constructor = Constructor.discriminators[value[Constructor.schema.options.discriminatorKey]];\n      } else {\n        const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, value[Constructor.schema.options.discriminatorKey]);\n        if (constructorByValue) {\n          Constructor = constructorByValue;\n        }\n      }\n    }\n\n    if (Constructor.$isMongooseDocumentArray) {\n      return Constructor.cast(value, this, undefined, undefined, index);\n    }\n    const ret = new Constructor(value, this, options, undefined, index);\n    ret.isNew = true;\n    return ret;\n  },\n\n  /**\n   * Searches array items for the first document with a matching _id.\n   *\n   * #### Example:\n   *\n   *     const embeddedDoc = m.array.id(some_id);\n   *\n   * @return {EmbeddedDocument|null} the subdocument or null if not found.\n   * @param {ObjectId|String|Number|Buffer} id\n   * @TODO cast to the _id based on schema for proper comparison\n   * @method id\n   * @api public\n   * @memberOf MongooseDocumentArray\n   */\n\n  id(id) {\n    let casted;\n    let sid;\n    let _id;\n\n    try {\n      casted = castObjectId(id).toString();\n    } catch (e) {\n      casted = null;\n    }\n\n    for (const val of this) {\n      if (!val) {\n        continue;\n      }\n\n      _id = val.get('_id');\n\n      if (_id === null || typeof _id === 'undefined') {\n        continue;\n      } else if (_id instanceof Document) {\n        sid || (sid = String(id));\n        if (sid == _id._id) {\n          return val;\n        }\n      } else if (!isBsonType(id, 'ObjectId') && !isBsonType(_id, 'ObjectId')) {\n        if (id == _id || utils.deepEqual(id, _id)) {\n          return val;\n        }\n      } else if (casted == _id) {\n        return val;\n      }\n    }\n\n    return null;\n  },\n\n  /**\n   * Returns a native js Array of plain js objects\n   *\n   * #### Note:\n   *\n   * _Each sub-document is converted to a plain object by calling its `#toObject` method._\n   *\n   * @param {Object} [options] optional options to pass to each documents `toObject` method call during conversion\n   * @return {Array}\n   * @method toObject\n   * @api public\n   * @memberOf MongooseDocumentArray\n   */\n\n  toObject(options) {\n    // `[].concat` coerces the return value into a vanilla JS array, rather\n    // than a Mongoose array.\n    return [].concat(this.map(function(doc) {\n      if (doc == null) {\n        return null;\n      }\n      if (typeof doc.toObject !== 'function') {\n        return doc;\n      }\n      return doc.toObject(options);\n    }));\n  },\n\n  $toObject() {\n    return this.constructor.prototype.toObject.apply(this, arguments);\n  },\n\n  /**\n   * Wraps [`Array#push`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/push) with proper change tracking.\n   *\n   * @param {...Object} [args]\n   * @api public\n   * @method push\n   * @memberOf MongooseDocumentArray\n   */\n\n  push() {\n    const ret = ArrayMethods.push.apply(this, arguments);\n\n    _updateParentPopulated(this);\n\n    return ret;\n  },\n\n  /**\n   * Pulls items from the array atomically.\n   *\n   * @param {...Object} [args]\n   * @api public\n   * @method pull\n   * @memberOf MongooseDocumentArray\n   */\n\n  pull() {\n    const ret = ArrayMethods.pull.apply(this, arguments);\n\n    _updateParentPopulated(this);\n\n    return ret;\n  },\n\n  /**\n   * Wraps [`Array#shift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.\n   * @api private\n   */\n\n  shift() {\n    const ret = ArrayMethods.shift.apply(this, arguments);\n\n    _updateParentPopulated(this);\n\n    return ret;\n  },\n\n  /**\n   * Wraps [`Array#splice`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice) with proper change tracking and casting.\n   * @api private\n   */\n\n  splice() {\n    const ret = ArrayMethods.splice.apply(this, arguments);\n\n    _updateParentPopulated(this);\n\n    return ret;\n  },\n\n  /**\n   * Helper for console.log\n   *\n   * @method inspect\n   * @api public\n   * @memberOf MongooseDocumentArray\n   */\n\n  inspect() {\n    return this.toObject();\n  },\n\n  /**\n   * Creates a subdocument casted to this schema.\n   *\n   * This is the same subdocument constructor used for casting.\n   *\n   * @param {Object} obj the value to cast to this arrays SubDocument schema\n   * @method create\n   * @api public\n   * @memberOf MongooseDocumentArray\n   */\n\n  create(obj) {\n    let Constructor = this[arraySchemaSymbol].casterConstructor;\n    if (obj &&\n        Constructor.discriminators &&\n        Constructor.schema &&\n        Constructor.schema.options &&\n        Constructor.schema.options.discriminatorKey) {\n      if (typeof obj[Constructor.schema.options.discriminatorKey] === 'string' &&\n          Constructor.discriminators[obj[Constructor.schema.options.discriminatorKey]]) {\n        Constructor = Constructor.discriminators[obj[Constructor.schema.options.discriminatorKey]];\n      } else {\n        const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, obj[Constructor.schema.options.discriminatorKey]);\n        if (constructorByValue) {\n          Constructor = constructorByValue;\n        }\n      }\n    }\n\n    return new Constructor(obj, this);\n  },\n\n  /*!\n   * ignore\n   */\n\n  notify(event) {\n    const _this = this;\n    return function notify(val, _arr) {\n      _arr = _arr || _this;\n      let i = _arr.length;\n      while (i--) {\n        if (_arr[i] == null) {\n          continue;\n        }\n        switch (event) {\n          // only swap for save event for now, we may change this to all event types later\n          case 'save':\n            val = _this[i];\n            break;\n          default:\n            // NO-OP\n            break;\n        }\n\n        if (utils.isMongooseArray(_arr[i])) {\n          notify(val, _arr[i]);\n        } else if (_arr[i]) {\n          _arr[i].emit(event, val);\n        }\n      }\n    };\n  },\n\n  set(i, val, skipModified) {\n    const arr = this.__array;\n    if (skipModified) {\n      arr[i] = val;\n      return this;\n    }\n    const value = methods._cast.call(this, val, i);\n    methods._markModified.call(this, i);\n    arr[i] = value;\n    return this;\n  },\n\n  _markModified(elem, embeddedPath) {\n    const parent = this[arrayParentSymbol];\n    let dirtyPath;\n\n    if (parent) {\n      dirtyPath = this[arrayPathSymbol];\n\n      if (arguments.length) {\n        if (embeddedPath != null) {\n          // an embedded doc bubbled up the change\n          const index = elem.__index;\n          dirtyPath = dirtyPath + '.' + index + '.' + embeddedPath;\n        } else {\n          // directly set an index\n          dirtyPath = dirtyPath + '.' + elem;\n        }\n      }\n\n      if (dirtyPath != null && dirtyPath.endsWith('.$')) {\n        return this;\n      }\n\n      parent.markModified(dirtyPath, arguments.length !== 0 ? elem : parent);\n    }\n\n    return this;\n  }\n};\n\nmodule.exports = methods;\n\n/**\n * If this is a document array, each element may contain single\n * populated paths, so we need to modify the top-level document's\n * populated cache. See gh-8247, gh-8265.\n * @param {Array} arr\n * @api private\n */\n\nfunction _updateParentPopulated(arr) {\n  const parent = arr[arrayParentSymbol];\n  if (!parent || parent.$__.populated == null) return;\n\n  const populatedPaths = Object.keys(parent.$__.populated).\n    filter(p => p.startsWith(arr[arrayPathSymbol] + '.'));\n\n  for (const path of populatedPaths) {\n    const remnant = path.slice((arr[arrayPathSymbol] + '.').length);\n    if (!Array.isArray(parent.$__.populated[path].value)) {\n      continue;\n    }\n\n    parent.$__.populated[path].value = arr.map(val => val.$populated(remnant));\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL2RvY3VtZW50QXJyYXkvbWV0aG9kcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixxQkFBcUIsbUJBQU8sQ0FBQyw4RkFBcUI7QUFDbEQsaUJBQWlCLG1CQUFPLENBQUMsMkVBQW1CO0FBQzVDLHFCQUFxQixtQkFBTyxDQUFDLHFGQUF3QjtBQUNyRCxnQ0FBZ0MsbUJBQU8sQ0FBQyxxSkFBd0Q7QUFDaEcsZ0NBQWdDLHdIQUFtRDtBQUNuRixjQUFjLG1CQUFPLENBQUMscUVBQWdCO0FBQ3RDLG1CQUFtQixtQkFBTyxDQUFDLCtGQUE2Qjs7QUFFeEQsMEJBQTBCLGtJQUFxRDtBQUMvRSx3QkFBd0IsZ0lBQW1EO0FBQzNFLDBCQUEwQixrSUFBcUQ7QUFDL0UsNEJBQTRCLG9JQUF1RDs7QUFFbkY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQyxhQUFhLCtCQUErQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi90eXBlcy9kb2N1bWVudEFycmF5L21ldGhvZHMvaW5kZXguanM/NjE2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFycmF5TWV0aG9kcyA9IHJlcXVpcmUoJy4uLy4uL2FycmF5L21ldGhvZHMnKTtcbmNvbnN0IERvY3VtZW50ID0gcmVxdWlyZSgnLi4vLi4vLi4vZG9jdW1lbnQnKTtcbmNvbnN0IGNhc3RPYmplY3RJZCA9IHJlcXVpcmUoJy4uLy4uLy4uL2Nhc3Qvb2JqZWN0aWQnKTtcbmNvbnN0IGdldERpc2NyaW1pbmF0b3JCeVZhbHVlID0gcmVxdWlyZSgnLi4vLi4vLi4vaGVscGVycy9kaXNjcmltaW5hdG9yL2dldERpc2NyaW1pbmF0b3JCeVZhbHVlJyk7XG5jb25zdCBpbnRlcm5hbFRvT2JqZWN0T3B0aW9ucyA9IHJlcXVpcmUoJy4uLy4uLy4uL29wdGlvbnMnKS5pbnRlcm5hbFRvT2JqZWN0T3B0aW9ucztcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbHMnKTtcbmNvbnN0IGlzQnNvblR5cGUgPSByZXF1aXJlKCcuLi8uLi8uLi9oZWxwZXJzL2lzQnNvblR5cGUnKTtcblxuY29uc3QgYXJyYXlQYXJlbnRTeW1ib2wgPSByZXF1aXJlKCcuLi8uLi8uLi9oZWxwZXJzL3N5bWJvbHMnKS5hcnJheVBhcmVudFN5bWJvbDtcbmNvbnN0IGFycmF5UGF0aFN5bWJvbCA9IHJlcXVpcmUoJy4uLy4uLy4uL2hlbHBlcnMvc3ltYm9scycpLmFycmF5UGF0aFN5bWJvbDtcbmNvbnN0IGFycmF5U2NoZW1hU3ltYm9sID0gcmVxdWlyZSgnLi4vLi4vLi4vaGVscGVycy9zeW1ib2xzJykuYXJyYXlTY2hlbWFTeW1ib2w7XG5jb25zdCBkb2N1bWVudEFycmF5UGFyZW50ID0gcmVxdWlyZSgnLi4vLi4vLi4vaGVscGVycy9zeW1ib2xzJykuZG9jdW1lbnRBcnJheVBhcmVudDtcblxuY29uc3QgX2Jhc2VUb1N0cmluZyA9IEFycmF5LnByb3RvdHlwZS50b1N0cmluZztcblxuY29uc3QgbWV0aG9kcyA9IHtcbiAgLyohXG4gICAqIGlnbm9yZVxuICAgKi9cblxuICB0b0JTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9PYmplY3QoaW50ZXJuYWxUb09iamVjdE9wdGlvbnMpO1xuICB9LFxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBfYmFzZVRvU3RyaW5nLmNhbGwodGhpcy5fX2FycmF5Lm1hcChzdWJkb2MgPT4ge1xuICAgICAgaWYgKHN1YmRvYyAhPSBudWxsICYmIHN1YmRvYy4kX18gIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc3ViZG9jLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3ViZG9jO1xuICAgIH0pKTtcbiAgfSxcblxuICAvKiFcbiAgICogaWdub3JlXG4gICAqL1xuXG4gIGdldEFycmF5UGFyZW50KCkge1xuICAgIHJldHVybiB0aGlzW2FycmF5UGFyZW50U3ltYm9sXTtcbiAgfSxcblxuICAvKipcbiAgICogT3ZlcnJpZGVzIE1vbmdvb3NlQXJyYXkjY2FzdFxuICAgKlxuICAgKiBAbWV0aG9kIF9jYXN0XG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VEb2N1bWVudEFycmF5XG4gICAqL1xuXG4gIF9jYXN0KHZhbHVlLCBpbmRleCwgb3B0aW9ucykge1xuICAgIGlmICh0aGlzW2FycmF5U2NoZW1hU3ltYm9sXSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGxldCBDb25zdHJ1Y3RvciA9IHRoaXNbYXJyYXlTY2hlbWFTeW1ib2xdLmNhc3RlckNvbnN0cnVjdG9yO1xuICAgIGNvbnN0IGlzSW5zdGFuY2UgPSBDb25zdHJ1Y3Rvci4kaXNNb25nb29zZURvY3VtZW50QXJyYXkgP1xuICAgICAgdXRpbHMuaXNNb25nb29zZURvY3VtZW50QXJyYXkodmFsdWUpIDpcbiAgICAgIHZhbHVlIGluc3RhbmNlb2YgQ29uc3RydWN0b3I7XG4gICAgaWYgKGlzSW5zdGFuY2UgfHxcbiAgICAgICAgLy8gSGFjayByZTogIzUwMDEsIHNlZSAjNTAwNVxuICAgICAgICAodmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IuYmFzZUNhc3RlckNvbnN0cnVjdG9yID09PSBDb25zdHJ1Y3RvcikpIHtcbiAgICAgIGlmICghKHZhbHVlW2RvY3VtZW50QXJyYXlQYXJlbnRdICYmIHZhbHVlLl9fcGFyZW50QXJyYXkpKSB7XG4gICAgICAgIC8vIHZhbHVlIG1heSBoYXZlIGJlZW4gY3JlYXRlZCB1c2luZyBhcnJheS5jcmVhdGUoKVxuICAgICAgICB2YWx1ZVtkb2N1bWVudEFycmF5UGFyZW50XSA9IHRoaXNbYXJyYXlQYXJlbnRTeW1ib2xdO1xuICAgICAgICB2YWx1ZS5fX3BhcmVudEFycmF5ID0gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhbHVlLiRzZXRJbmRleChpbmRleCk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIGhhbmRsZSBjYXN0KCdzdHJpbmcnKSBvciBjYXN0KE9iamVjdElkKSBldGMuXG4gICAgLy8gb25seSBvYmplY3RzIGFyZSBwZXJtaXR0ZWQgc28gd2UgY2FuIHNhZmVseSBhc3N1bWUgdGhhdFxuICAgIC8vIG5vbi1vYmplY3RzIGFyZSB0byBiZSBpbnRlcnByZXRlZCBhcyBfaWRcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSB8fFxuICAgICAgICBpc0Jzb25UeXBlKHZhbHVlLCAnT2JqZWN0SWQnKSB8fCAhdXRpbHMuaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHsgX2lkOiB2YWx1ZSB9O1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICBDb25zdHJ1Y3Rvci5kaXNjcmltaW5hdG9ycyAmJlxuICAgICAgICBDb25zdHJ1Y3Rvci5zY2hlbWEgJiZcbiAgICAgICAgQ29uc3RydWN0b3Iuc2NoZW1hLm9wdGlvbnMgJiZcbiAgICAgICAgQ29uc3RydWN0b3Iuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZVtDb25zdHJ1Y3Rvci5zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5XSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICBDb25zdHJ1Y3Rvci5kaXNjcmltaW5hdG9yc1t2YWx1ZVtDb25zdHJ1Y3Rvci5zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5XV0pIHtcbiAgICAgICAgQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3Rvci5kaXNjcmltaW5hdG9yc1t2YWx1ZVtDb25zdHJ1Y3Rvci5zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5XV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb25zdHJ1Y3RvckJ5VmFsdWUgPSBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZShDb25zdHJ1Y3Rvci5kaXNjcmltaW5hdG9ycywgdmFsdWVbQ29uc3RydWN0b3Iuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleV0pO1xuICAgICAgICBpZiAoY29uc3RydWN0b3JCeVZhbHVlKSB7XG4gICAgICAgICAgQ29uc3RydWN0b3IgPSBjb25zdHJ1Y3RvckJ5VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoQ29uc3RydWN0b3IuJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB7XG4gICAgICByZXR1cm4gQ29uc3RydWN0b3IuY2FzdCh2YWx1ZSwgdGhpcywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGluZGV4KTtcbiAgICB9XG4gICAgY29uc3QgcmV0ID0gbmV3IENvbnN0cnVjdG9yKHZhbHVlLCB0aGlzLCBvcHRpb25zLCB1bmRlZmluZWQsIGluZGV4KTtcbiAgICByZXQuaXNOZXcgPSB0cnVlO1xuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNlYXJjaGVzIGFycmF5IGl0ZW1zIGZvciB0aGUgZmlyc3QgZG9jdW1lbnQgd2l0aCBhIG1hdGNoaW5nIF9pZC5cbiAgICpcbiAgICogIyMjIyBFeGFtcGxlOlxuICAgKlxuICAgKiAgICAgY29uc3QgZW1iZWRkZWREb2MgPSBtLmFycmF5LmlkKHNvbWVfaWQpO1xuICAgKlxuICAgKiBAcmV0dXJuIHtFbWJlZGRlZERvY3VtZW50fG51bGx9IHRoZSBzdWJkb2N1bWVudCBvciBudWxsIGlmIG5vdCBmb3VuZC5cbiAgICogQHBhcmFtIHtPYmplY3RJZHxTdHJpbmd8TnVtYmVyfEJ1ZmZlcn0gaWRcbiAgICogQFRPRE8gY2FzdCB0byB0aGUgX2lkIGJhc2VkIG9uIHNjaGVtYSBmb3IgcHJvcGVyIGNvbXBhcmlzb25cbiAgICogQG1ldGhvZCBpZFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VEb2N1bWVudEFycmF5XG4gICAqL1xuXG4gIGlkKGlkKSB7XG4gICAgbGV0IGNhc3RlZDtcbiAgICBsZXQgc2lkO1xuICAgIGxldCBfaWQ7XG5cbiAgICB0cnkge1xuICAgICAgY2FzdGVkID0gY2FzdE9iamVjdElkKGlkKS50b1N0cmluZygpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNhc3RlZCA9IG51bGw7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcykge1xuICAgICAgaWYgKCF2YWwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIF9pZCA9IHZhbC5nZXQoJ19pZCcpO1xuXG4gICAgICBpZiAoX2lkID09PSBudWxsIHx8IHR5cGVvZiBfaWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChfaWQgaW5zdGFuY2VvZiBEb2N1bWVudCkge1xuICAgICAgICBzaWQgfHwgKHNpZCA9IFN0cmluZyhpZCkpO1xuICAgICAgICBpZiAoc2lkID09IF9pZC5faWQpIHtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFpc0Jzb25UeXBlKGlkLCAnT2JqZWN0SWQnKSAmJiAhaXNCc29uVHlwZShfaWQsICdPYmplY3RJZCcpKSB7XG4gICAgICAgIGlmIChpZCA9PSBfaWQgfHwgdXRpbHMuZGVlcEVxdWFsKGlkLCBfaWQpKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjYXN0ZWQgPT0gX2lkKSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuYXRpdmUganMgQXJyYXkgb2YgcGxhaW4ganMgb2JqZWN0c1xuICAgKlxuICAgKiAjIyMjIE5vdGU6XG4gICAqXG4gICAqIF9FYWNoIHN1Yi1kb2N1bWVudCBpcyBjb252ZXJ0ZWQgdG8gYSBwbGFpbiBvYmplY3QgYnkgY2FsbGluZyBpdHMgYCN0b09iamVjdGAgbWV0aG9kLl9cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25hbCBvcHRpb25zIHRvIHBhc3MgdG8gZWFjaCBkb2N1bWVudHMgYHRvT2JqZWN0YCBtZXRob2QgY2FsbCBkdXJpbmcgY29udmVyc2lvblxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICogQG1ldGhvZCB0b09iamVjdFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VEb2N1bWVudEFycmF5XG4gICAqL1xuXG4gIHRvT2JqZWN0KG9wdGlvbnMpIHtcbiAgICAvLyBgW10uY29uY2F0YCBjb2VyY2VzIHRoZSByZXR1cm4gdmFsdWUgaW50byBhIHZhbmlsbGEgSlMgYXJyYXksIHJhdGhlclxuICAgIC8vIHRoYW4gYSBNb25nb29zZSBhcnJheS5cbiAgICByZXR1cm4gW10uY29uY2F0KHRoaXMubWFwKGZ1bmN0aW9uKGRvYykge1xuICAgICAgaWYgKGRvYyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBkb2MudG9PYmplY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGRvYztcbiAgICAgIH1cbiAgICAgIHJldHVybiBkb2MudG9PYmplY3Qob3B0aW9ucyk7XG4gICAgfSkpO1xuICB9LFxuXG4gICR0b09iamVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUudG9PYmplY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSxcblxuICAvKipcbiAgICogV3JhcHMgW2BBcnJheSNwdXNoYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvcHVzaCkgd2l0aCBwcm9wZXIgY2hhbmdlIHRyYWNraW5nLlxuICAgKlxuICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW2FyZ3NdXG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZXRob2QgcHVzaFxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VEb2N1bWVudEFycmF5XG4gICAqL1xuXG4gIHB1c2goKSB7XG4gICAgY29uc3QgcmV0ID0gQXJyYXlNZXRob2RzLnB1c2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIF91cGRhdGVQYXJlbnRQb3B1bGF0ZWQodGhpcyk7XG5cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBQdWxscyBpdGVtcyBmcm9tIHRoZSBhcnJheSBhdG9taWNhbGx5LlxuICAgKlxuICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW2FyZ3NdXG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZXRob2QgcHVsbFxuICAgKiBAbWVtYmVyT2YgTW9uZ29vc2VEb2N1bWVudEFycmF5XG4gICAqL1xuXG4gIHB1bGwoKSB7XG4gICAgY29uc3QgcmV0ID0gQXJyYXlNZXRob2RzLnB1bGwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIF91cGRhdGVQYXJlbnRQb3B1bGF0ZWQodGhpcyk7XG5cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBXcmFwcyBbYEFycmF5I3NoaWZ0YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvdW5zaGlmdCkgd2l0aCBwcm9wZXIgY2hhbmdlIHRyYWNraW5nLlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgc2hpZnQoKSB7XG4gICAgY29uc3QgcmV0ID0gQXJyYXlNZXRob2RzLnNoaWZ0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBfdXBkYXRlUGFyZW50UG9wdWxhdGVkKHRoaXMpO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICAvKipcbiAgICogV3JhcHMgW2BBcnJheSNzcGxpY2VgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zcGxpY2UpIHdpdGggcHJvcGVyIGNoYW5nZSB0cmFja2luZyBhbmQgY2FzdGluZy5cbiAgICogQGFwaSBwcml2YXRlXG4gICAqL1xuXG4gIHNwbGljZSgpIHtcbiAgICBjb25zdCByZXQgPSBBcnJheU1ldGhvZHMuc3BsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBfdXBkYXRlUGFyZW50UG9wdWxhdGVkKHRoaXMpO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICAvKipcbiAgICogSGVscGVyIGZvciBjb25zb2xlLmxvZ1xuICAgKlxuICAgKiBAbWV0aG9kIGluc3BlY3RcbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlRG9jdW1lbnRBcnJheVxuICAgKi9cblxuICBpbnNwZWN0KCkge1xuICAgIHJldHVybiB0aGlzLnRvT2JqZWN0KCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzdWJkb2N1bWVudCBjYXN0ZWQgdG8gdGhpcyBzY2hlbWEuXG4gICAqXG4gICAqIFRoaXMgaXMgdGhlIHNhbWUgc3ViZG9jdW1lbnQgY29uc3RydWN0b3IgdXNlZCBmb3IgY2FzdGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iaiB0aGUgdmFsdWUgdG8gY2FzdCB0byB0aGlzIGFycmF5cyBTdWJEb2N1bWVudCBzY2hlbWFcbiAgICogQG1ldGhvZCBjcmVhdGVcbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1lbWJlck9mIE1vbmdvb3NlRG9jdW1lbnRBcnJheVxuICAgKi9cblxuICBjcmVhdGUob2JqKSB7XG4gICAgbGV0IENvbnN0cnVjdG9yID0gdGhpc1thcnJheVNjaGVtYVN5bWJvbF0uY2FzdGVyQ29uc3RydWN0b3I7XG4gICAgaWYgKG9iaiAmJlxuICAgICAgICBDb25zdHJ1Y3Rvci5kaXNjcmltaW5hdG9ycyAmJlxuICAgICAgICBDb25zdHJ1Y3Rvci5zY2hlbWEgJiZcbiAgICAgICAgQ29uc3RydWN0b3Iuc2NoZW1hLm9wdGlvbnMgJiZcbiAgICAgICAgQ29uc3RydWN0b3Iuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleSkge1xuICAgICAgaWYgKHR5cGVvZiBvYmpbQ29uc3RydWN0b3Iuc2NoZW1hLm9wdGlvbnMuZGlzY3JpbWluYXRvcktleV0gPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgQ29uc3RydWN0b3IuZGlzY3JpbWluYXRvcnNbb2JqW0NvbnN0cnVjdG9yLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXldXSkge1xuICAgICAgICBDb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yLmRpc2NyaW1pbmF0b3JzW29ialtDb25zdHJ1Y3Rvci5zY2hlbWEub3B0aW9ucy5kaXNjcmltaW5hdG9yS2V5XV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb25zdHJ1Y3RvckJ5VmFsdWUgPSBnZXREaXNjcmltaW5hdG9yQnlWYWx1ZShDb25zdHJ1Y3Rvci5kaXNjcmltaW5hdG9ycywgb2JqW0NvbnN0cnVjdG9yLnNjaGVtYS5vcHRpb25zLmRpc2NyaW1pbmF0b3JLZXldKTtcbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yQnlWYWx1ZSkge1xuICAgICAgICAgIENvbnN0cnVjdG9yID0gY29uc3RydWN0b3JCeVZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihvYmosIHRoaXMpO1xuICB9LFxuXG4gIC8qIVxuICAgKiBpZ25vcmVcbiAgICovXG5cbiAgbm90aWZ5KGV2ZW50KSB7XG4gICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbiBub3RpZnkodmFsLCBfYXJyKSB7XG4gICAgICBfYXJyID0gX2FyciB8fCBfdGhpcztcbiAgICAgIGxldCBpID0gX2Fyci5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGlmIChfYXJyW2ldID09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGV2ZW50KSB7XG4gICAgICAgICAgLy8gb25seSBzd2FwIGZvciBzYXZlIGV2ZW50IGZvciBub3csIHdlIG1heSBjaGFuZ2UgdGhpcyB0byBhbGwgZXZlbnQgdHlwZXMgbGF0ZXJcbiAgICAgICAgICBjYXNlICdzYXZlJzpcbiAgICAgICAgICAgIHZhbCA9IF90aGlzW2ldO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIE5PLU9QXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1dGlscy5pc01vbmdvb3NlQXJyYXkoX2FycltpXSkpIHtcbiAgICAgICAgICBub3RpZnkodmFsLCBfYXJyW2ldKTtcbiAgICAgICAgfSBlbHNlIGlmIChfYXJyW2ldKSB7XG4gICAgICAgICAgX2FycltpXS5lbWl0KGV2ZW50LCB2YWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSxcblxuICBzZXQoaSwgdmFsLCBza2lwTW9kaWZpZWQpIHtcbiAgICBjb25zdCBhcnIgPSB0aGlzLl9fYXJyYXk7XG4gICAgaWYgKHNraXBNb2RpZmllZCkge1xuICAgICAgYXJyW2ldID0gdmFsO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gbWV0aG9kcy5fY2FzdC5jYWxsKHRoaXMsIHZhbCwgaSk7XG4gICAgbWV0aG9kcy5fbWFya01vZGlmaWVkLmNhbGwodGhpcywgaSk7XG4gICAgYXJyW2ldID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgX21hcmtNb2RpZmllZChlbGVtLCBlbWJlZGRlZFBhdGgpIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzW2FycmF5UGFyZW50U3ltYm9sXTtcbiAgICBsZXQgZGlydHlQYXRoO1xuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgZGlydHlQYXRoID0gdGhpc1thcnJheVBhdGhTeW1ib2xdO1xuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBpZiAoZW1iZWRkZWRQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBhbiBlbWJlZGRlZCBkb2MgYnViYmxlZCB1cCB0aGUgY2hhbmdlXG4gICAgICAgICAgY29uc3QgaW5kZXggPSBlbGVtLl9faW5kZXg7XG4gICAgICAgICAgZGlydHlQYXRoID0gZGlydHlQYXRoICsgJy4nICsgaW5kZXggKyAnLicgKyBlbWJlZGRlZFBhdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZGlyZWN0bHkgc2V0IGFuIGluZGV4XG4gICAgICAgICAgZGlydHlQYXRoID0gZGlydHlQYXRoICsgJy4nICsgZWxlbTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZGlydHlQYXRoICE9IG51bGwgJiYgZGlydHlQYXRoLmVuZHNXaXRoKCcuJCcpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBwYXJlbnQubWFya01vZGlmaWVkKGRpcnR5UGF0aCwgYXJndW1lbnRzLmxlbmd0aCAhPT0gMCA/IGVsZW0gOiBwYXJlbnQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1ldGhvZHM7XG5cbi8qKlxuICogSWYgdGhpcyBpcyBhIGRvY3VtZW50IGFycmF5LCBlYWNoIGVsZW1lbnQgbWF5IGNvbnRhaW4gc2luZ2xlXG4gKiBwb3B1bGF0ZWQgcGF0aHMsIHNvIHdlIG5lZWQgdG8gbW9kaWZ5IHRoZSB0b3AtbGV2ZWwgZG9jdW1lbnQnc1xuICogcG9wdWxhdGVkIGNhY2hlLiBTZWUgZ2gtODI0NywgZ2gtODI2NS5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gX3VwZGF0ZVBhcmVudFBvcHVsYXRlZChhcnIpIHtcbiAgY29uc3QgcGFyZW50ID0gYXJyW2FycmF5UGFyZW50U3ltYm9sXTtcbiAgaWYgKCFwYXJlbnQgfHwgcGFyZW50LiRfXy5wb3B1bGF0ZWQgPT0gbnVsbCkgcmV0dXJuO1xuXG4gIGNvbnN0IHBvcHVsYXRlZFBhdGhzID0gT2JqZWN0LmtleXMocGFyZW50LiRfXy5wb3B1bGF0ZWQpLlxuICAgIGZpbHRlcihwID0+IHAuc3RhcnRzV2l0aChhcnJbYXJyYXlQYXRoU3ltYm9sXSArICcuJykpO1xuXG4gIGZvciAoY29uc3QgcGF0aCBvZiBwb3B1bGF0ZWRQYXRocykge1xuICAgIGNvbnN0IHJlbW5hbnQgPSBwYXRoLnNsaWNlKChhcnJbYXJyYXlQYXRoU3ltYm9sXSArICcuJykubGVuZ3RoKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFyZW50LiRfXy5wb3B1bGF0ZWRbcGF0aF0udmFsdWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBwYXJlbnQuJF9fLnBvcHVsYXRlZFtwYXRoXS52YWx1ZSA9IGFyci5tYXAodmFsID0+IHZhbC4kcG9wdWxhdGVkKHJlbW5hbnQpKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/types/documentArray/methods/index.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/types/index.js":
/*!***********************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/types/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n/*!\n * Module exports.\n */\n\n\n\nexports.Array = __webpack_require__(/*! ./array */ \"../backend/node_modules/mongoose/lib/types/array/index.js\");\nexports.Buffer = __webpack_require__(/*! ./buffer */ \"../backend/node_modules/mongoose/lib/types/buffer.js\");\n\nexports.Document = // @deprecate\nexports.Embedded = __webpack_require__(/*! ./arraySubdocument */ \"../backend/node_modules/mongoose/lib/types/arraySubdocument.js\");\n\nexports.DocumentArray = __webpack_require__(/*! ./documentArray */ \"../backend/node_modules/mongoose/lib/types/documentArray/index.js\");\nexports.Decimal128 = __webpack_require__(/*! ./decimal128 */ \"../backend/node_modules/mongoose/lib/types/decimal128.js\");\nexports.ObjectId = __webpack_require__(/*! ./objectid */ \"../backend/node_modules/mongoose/lib/types/objectid.js\");\n\nexports.Map = __webpack_require__(/*! ./map */ \"../backend/node_modules/mongoose/lib/types/map.js\");\n\nexports.Subdocument = __webpack_require__(/*! ./subdocument */ \"../backend/node_modules/mongoose/lib/types/subdocument.js\");\n\nexports.UUID = __webpack_require__(/*! ./uuid */ \"../backend/node_modules/mongoose/lib/types/uuid.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsK0dBQWtDO0FBQ2xDLDRHQUFvQzs7QUFFcEMsZ0JBQWdCO0FBQ2hCLGtJQUFnRDs7QUFFaEQsdUlBQWtEO0FBQ2xELHdIQUE0QztBQUM1QyxrSEFBd0M7O0FBRXhDLG1HQUE4Qjs7QUFFOUIsMkhBQThDOztBQUU5QyxzR0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdHlwZXMvaW5kZXguanM/ZTQwZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qIVxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLkFycmF5ID0gcmVxdWlyZSgnLi9hcnJheScpO1xuZXhwb3J0cy5CdWZmZXIgPSByZXF1aXJlKCcuL2J1ZmZlcicpO1xuXG5leHBvcnRzLkRvY3VtZW50ID0gLy8gQGRlcHJlY2F0ZVxuZXhwb3J0cy5FbWJlZGRlZCA9IHJlcXVpcmUoJy4vYXJyYXlTdWJkb2N1bWVudCcpO1xuXG5leHBvcnRzLkRvY3VtZW50QXJyYXkgPSByZXF1aXJlKCcuL2RvY3VtZW50QXJyYXknKTtcbmV4cG9ydHMuRGVjaW1hbDEyOCA9IHJlcXVpcmUoJy4vZGVjaW1hbDEyOCcpO1xuZXhwb3J0cy5PYmplY3RJZCA9IHJlcXVpcmUoJy4vb2JqZWN0aWQnKTtcblxuZXhwb3J0cy5NYXAgPSByZXF1aXJlKCcuL21hcCcpO1xuXG5leHBvcnRzLlN1YmRvY3VtZW50ID0gcmVxdWlyZSgnLi9zdWJkb2N1bWVudCcpO1xuXG5leHBvcnRzLlVVSUQgPSByZXF1aXJlKCcuL3V1aWQnKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/types/index.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/types/map.js":
/*!*********************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/types/map.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Mixed = __webpack_require__(/*! ../schema/mixed */ \"../backend/node_modules/mongoose/lib/schema/mixed.js\");\nconst MongooseError = __webpack_require__(/*! ../error/mongooseError */ \"../backend/node_modules/mongoose/lib/error/mongooseError.js\");\nconst clone = __webpack_require__(/*! ../helpers/clone */ \"../backend/node_modules/mongoose/lib/helpers/clone.js\");\nconst deepEqual = (__webpack_require__(/*! ../utils */ \"../backend/node_modules/mongoose/lib/utils.js\").deepEqual);\nconst getConstructorName = __webpack_require__(/*! ../helpers/getConstructorName */ \"../backend/node_modules/mongoose/lib/helpers/getConstructorName.js\");\nconst handleSpreadDoc = __webpack_require__(/*! ../helpers/document/handleSpreadDoc */ \"../backend/node_modules/mongoose/lib/helpers/document/handleSpreadDoc.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst specialProperties = __webpack_require__(/*! ../helpers/specialProperties */ \"../backend/node_modules/mongoose/lib/helpers/specialProperties.js\");\nconst isBsonType = __webpack_require__(/*! ../helpers/isBsonType */ \"../backend/node_modules/mongoose/lib/helpers/isBsonType.js\");\n\nconst populateModelSymbol = (__webpack_require__(/*! ../helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").populateModelSymbol);\n\n/*!\n * ignore\n */\n\nclass MongooseMap extends Map {\n  constructor(v, path, doc, schemaType) {\n    if (getConstructorName(v) === 'Object') {\n      v = Object.keys(v).reduce((arr, key) => arr.concat([[key, v[key]]]), []);\n    }\n    super(v);\n    this.$__parent = doc != null && doc.$__ != null ? doc : null;\n    this.$__path = path;\n    this.$__schemaType = schemaType == null ? new Mixed(path) : schemaType;\n\n    this.$__runDeferred();\n  }\n\n  $init(key, value) {\n    checkValidKey(key);\n\n    super.set(key, value);\n\n    if (value != null && value.$isSingleNested) {\n      value.$basePath = this.$__path + '.' + key;\n    }\n  }\n\n  $__set(key, value) {\n    super.set(key, value);\n  }\n\n  /**\n   * Overwrites native Map's `get()` function to support Mongoose getters.\n   *\n   * @api public\n   * @method get\n   * @memberOf Map\n   */\n\n  get(key, options) {\n    if (isBsonType(key, 'ObjectId')) {\n      key = key.toString();\n    }\n\n    options = options || {};\n    if (options.getters === false) {\n      return super.get(key);\n    }\n    return this.$__schemaType.applyGetters(super.get(key), this.$__parent);\n  }\n\n  /**\n   * Overwrites native Map's `set()` function to support setters, `populate()`,\n   * and change tracking. Note that Mongoose maps _only_ support strings and\n   * ObjectIds as keys.\n   *\n   * #### Example:\n   *\n   *     doc.myMap.set('test', 42); // works\n   *     doc.myMap.set({ obj: 42 }, 42); // Throws \"Mongoose maps only support string keys\"\n   *\n   * @api public\n   * @method set\n   * @memberOf Map\n   */\n\n  set(key, value) {\n    if (isBsonType(key, 'ObjectId')) {\n      key = key.toString();\n    }\n\n    checkValidKey(key);\n    value = handleSpreadDoc(value);\n\n    // Weird, but because you can't assign to `this` before calling `super()`\n    // you can't get access to `$__schemaType` to cast in the initial call to\n    // `set()` from the `super()` constructor.\n\n    if (this.$__schemaType == null) {\n      this.$__deferred = this.$__deferred || [];\n      this.$__deferred.push({ key: key, value: value });\n      return;\n    }\n\n    let _fullPath;\n    const parent = this.$__parent;\n    const populated = parent != null && parent.$__ && parent.$__.populated ?\n      parent.$populated(fullPath.call(this), true) || parent.$populated(this.$__path, true) :\n      null;\n    const priorVal = this.get(key);\n\n    if (populated != null) {\n      if (this.$__schemaType.$isSingleNested) {\n        throw new MongooseError(\n          'Cannot manually populate single nested subdoc underneath Map ' +\n          `at path \"${this.$__path}\". Try using an array instead of a Map.`\n        );\n      }\n      if (Array.isArray(value) && this.$__schemaType.$isMongooseArray) {\n        value = value.map(v => {\n          if (v.$__ == null) {\n            v = new populated.options[populateModelSymbol](v);\n          }\n          // Doesn't support single nested \"in-place\" populate\n          v.$__.wasPopulated = { value: v._id };\n          return v;\n        });\n      } else {\n        if (value.$__ == null) {\n          value = new populated.options[populateModelSymbol](value);\n        }\n        // Doesn't support single nested \"in-place\" populate\n        value.$__.wasPopulated = { value: value._id };\n      }\n    } else {\n      try {\n        const options = this.$__schemaType.$isMongooseDocumentArray || this.$__schemaType.$isSingleNested ?\n          { path: fullPath.call(this) } :\n          null;\n        value = this.$__schemaType.applySetters(\n          value,\n          this.$__parent,\n          false,\n          this.get(key),\n          options\n        );\n      } catch (error) {\n        if (this.$__parent != null && this.$__parent.$__ != null) {\n          this.$__parent.invalidate(fullPath.call(this), error);\n          return;\n        }\n        throw error;\n      }\n    }\n\n    super.set(key, value);\n\n    if (parent != null && parent.$__ != null && !deepEqual(value, priorVal)) {\n      parent.markModified(fullPath.call(this));\n    }\n\n    // Delay calculating full path unless absolutely necessary, because string\n    // concatenation is a bottleneck re: #13171\n    function fullPath() {\n      if (_fullPath) {\n        return _fullPath;\n      }\n      _fullPath = this.$__path + '.' + key;\n      return _fullPath;\n    }\n  }\n\n  /**\n   * Overwrites native Map's `clear()` function to support change tracking.\n   *\n   * @api public\n   * @method clear\n   * @memberOf Map\n   */\n\n  clear() {\n    super.clear();\n    const parent = this.$__parent;\n    if (parent != null) {\n      parent.markModified(this.$__path);\n    }\n  }\n\n  /**\n   * Overwrites native Map's `delete()` function to support change tracking.\n   *\n   * @api public\n   * @method delete\n   * @memberOf Map\n   */\n\n  delete(key) {\n    if (isBsonType(key, 'ObjectId')) {\n      key = key.toString();\n    }\n\n    this.set(key, undefined);\n    return super.delete(key);\n  }\n\n  /**\n   * Converts this map to a native JavaScript Map so the MongoDB driver can serialize it.\n   *\n   * @api public\n   * @method toBSON\n   * @memberOf Map\n   */\n\n  toBSON() {\n    return new Map(this);\n  }\n\n  toObject(options) {\n    if (options && options.flattenMaps) {\n      const ret = {};\n      const keys = this.keys();\n      for (const key of keys) {\n        ret[key] = clone(this.get(key), options);\n      }\n      return ret;\n    }\n\n    return new Map(this);\n  }\n\n  $toObject() {\n    return this.constructor.prototype.toObject.apply(this, arguments);\n  }\n\n  /**\n   * Converts this map to a native JavaScript Map for `JSON.stringify()`. Set\n   * the `flattenMaps` option to convert this map to a POJO instead.\n   *\n   * #### Example:\n   *\n   *     doc.myMap.toJSON() instanceof Map; // true\n   *     doc.myMap.toJSON({ flattenMaps: true }) instanceof Map; // false\n   *\n   * @api public\n   * @method toJSON\n   * @param {Object} [options]\n   * @param {Boolean} [options.flattenMaps=false] set to `true` to convert the map to a POJO rather than a native JavaScript map\n   * @memberOf Map\n   */\n\n  toJSON(options) {\n    if (typeof (options && options.flattenMaps) === 'boolean' ? options.flattenMaps : true) {\n      const ret = {};\n      const keys = this.keys();\n      for (const key of keys) {\n        ret[key] = clone(this.get(key), options);\n      }\n      return ret;\n    }\n\n    return new Map(this);\n  }\n\n  inspect() {\n    return new Map(this);\n  }\n\n  $__runDeferred() {\n    if (!this.$__deferred) {\n      return;\n    }\n\n    for (const keyValueObject of this.$__deferred) {\n      this.set(keyValueObject.key, keyValueObject.value);\n    }\n\n    this.$__deferred = null;\n  }\n}\n\nif (util.inspect.custom) {\n  Object.defineProperty(MongooseMap.prototype, util.inspect.custom, {\n    enumerable: false,\n    writable: false,\n    configurable: false,\n    value: MongooseMap.prototype.inspect\n  });\n}\n\nObject.defineProperty(MongooseMap.prototype, '$__set', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\n\nObject.defineProperty(MongooseMap.prototype, '$__parent', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\n\nObject.defineProperty(MongooseMap.prototype, '$__path', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\n\nObject.defineProperty(MongooseMap.prototype, '$__schemaType', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\n\n/**\n * Set to `true` for all Mongoose map instances\n *\n * @api public\n * @property $isMongooseMap\n * @memberOf MongooseMap\n * @instance\n */\n\nObject.defineProperty(MongooseMap.prototype, '$isMongooseMap', {\n  enumerable: false,\n  writable: false,\n  configurable: false,\n  value: true\n});\n\nObject.defineProperty(MongooseMap.prototype, '$__deferredCalls', {\n  enumerable: false,\n  writable: false,\n  configurable: false,\n  value: true\n});\n\n/**\n * Since maps are stored as objects under the hood, keys must be strings\n * and can't contain any invalid characters\n * @param {String} key\n * @api private\n */\n\nfunction checkValidKey(key) {\n  const keyType = typeof key;\n  if (keyType !== 'string') {\n    throw new TypeError(`Mongoose maps only support string keys, got ${keyType}`);\n  }\n  if (key.startsWith('$')) {\n    throw new Error(`Mongoose maps do not support keys that start with \"$\", got \"${key}\"`);\n  }\n  if (key.includes('.')) {\n    throw new Error(`Mongoose maps do not support keys that contain \".\", got \"${key}\"`);\n  }\n  if (specialProperties.has(key)) {\n    throw new Error(`Mongoose maps do not support reserved key name \"${key}\"`);\n  }\n}\n\nmodule.exports = MongooseMap;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL21hcC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsNkVBQWlCO0FBQ3ZDLHNCQUFzQixtQkFBTyxDQUFDLDJGQUF3QjtBQUN0RCxjQUFjLG1CQUFPLENBQUMsK0VBQWtCO0FBQ3hDLGtCQUFrQixnR0FBNkI7QUFDL0MsMkJBQTJCLG1CQUFPLENBQUMseUdBQStCO0FBQ2xFLHdCQUF3QixtQkFBTyxDQUFDLHFIQUFxQztBQUNyRSxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsMEJBQTBCLG1CQUFPLENBQUMsdUdBQThCO0FBQ2hFLG1CQUFtQixtQkFBTyxDQUFDLHlGQUF1Qjs7QUFFbEQsNEJBQTRCLDhIQUFpRDs7QUFFN0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyx5QkFBeUIsU0FBUyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4Qix3QkFBd0I7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLDRCQUE0QixtQkFBbUIsa0JBQWtCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLFFBQVE7QUFDL0U7QUFDQTtBQUNBLG1GQUFtRixJQUFJO0FBQ3ZGO0FBQ0E7QUFDQSxnRkFBZ0YsSUFBSTtBQUNwRjtBQUNBO0FBQ0EsdUVBQXVFLElBQUk7QUFDM0U7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi90eXBlcy9tYXAuanM/ZDFlMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IE1peGVkID0gcmVxdWlyZSgnLi4vc2NoZW1hL21peGVkJyk7XG5jb25zdCBNb25nb29zZUVycm9yID0gcmVxdWlyZSgnLi4vZXJyb3IvbW9uZ29vc2VFcnJvcicpO1xuY29uc3QgY2xvbmUgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2Nsb25lJyk7XG5jb25zdCBkZWVwRXF1YWwgPSByZXF1aXJlKCcuLi91dGlscycpLmRlZXBFcXVhbDtcbmNvbnN0IGdldENvbnN0cnVjdG9yTmFtZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZ2V0Q29uc3RydWN0b3JOYW1lJyk7XG5jb25zdCBoYW5kbGVTcHJlYWREb2MgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2RvY3VtZW50L2hhbmRsZVNwcmVhZERvYycpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IHNwZWNpYWxQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vaGVscGVycy9zcGVjaWFsUHJvcGVydGllcycpO1xuY29uc3QgaXNCc29uVHlwZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvaXNCc29uVHlwZScpO1xuXG5jb25zdCBwb3B1bGF0ZU1vZGVsU3ltYm9sID0gcmVxdWlyZSgnLi4vaGVscGVycy9zeW1ib2xzJykucG9wdWxhdGVNb2RlbFN5bWJvbDtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5jbGFzcyBNb25nb29zZU1hcCBleHRlbmRzIE1hcCB7XG4gIGNvbnN0cnVjdG9yKHYsIHBhdGgsIGRvYywgc2NoZW1hVHlwZSkge1xuICAgIGlmIChnZXRDb25zdHJ1Y3Rvck5hbWUodikgPT09ICdPYmplY3QnKSB7XG4gICAgICB2ID0gT2JqZWN0LmtleXModikucmVkdWNlKChhcnIsIGtleSkgPT4gYXJyLmNvbmNhdChbW2tleSwgdltrZXldXV0pLCBbXSk7XG4gICAgfVxuICAgIHN1cGVyKHYpO1xuICAgIHRoaXMuJF9fcGFyZW50ID0gZG9jICE9IG51bGwgJiYgZG9jLiRfXyAhPSBudWxsID8gZG9jIDogbnVsbDtcbiAgICB0aGlzLiRfX3BhdGggPSBwYXRoO1xuICAgIHRoaXMuJF9fc2NoZW1hVHlwZSA9IHNjaGVtYVR5cGUgPT0gbnVsbCA/IG5ldyBNaXhlZChwYXRoKSA6IHNjaGVtYVR5cGU7XG5cbiAgICB0aGlzLiRfX3J1bkRlZmVycmVkKCk7XG4gIH1cblxuICAkaW5pdChrZXksIHZhbHVlKSB7XG4gICAgY2hlY2tWYWxpZEtleShrZXkpO1xuXG4gICAgc3VwZXIuc2V0KGtleSwgdmFsdWUpO1xuXG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUuJGlzU2luZ2xlTmVzdGVkKSB7XG4gICAgICB2YWx1ZS4kYmFzZVBhdGggPSB0aGlzLiRfX3BhdGggKyAnLicgKyBrZXk7XG4gICAgfVxuICB9XG5cbiAgJF9fc2V0KGtleSwgdmFsdWUpIHtcbiAgICBzdXBlci5zZXQoa2V5LCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogT3ZlcndyaXRlcyBuYXRpdmUgTWFwJ3MgYGdldCgpYCBmdW5jdGlvbiB0byBzdXBwb3J0IE1vbmdvb3NlIGdldHRlcnMuXG4gICAqXG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZXRob2QgZ2V0XG4gICAqIEBtZW1iZXJPZiBNYXBcbiAgICovXG5cbiAgZ2V0KGtleSwgb3B0aW9ucykge1xuICAgIGlmIChpc0Jzb25UeXBlKGtleSwgJ09iamVjdElkJykpIHtcbiAgICAgIGtleSA9IGtleS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmIChvcHRpb25zLmdldHRlcnMgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gc3VwZXIuZ2V0KGtleSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiRfX3NjaGVtYVR5cGUuYXBwbHlHZXR0ZXJzKHN1cGVyLmdldChrZXkpLCB0aGlzLiRfX3BhcmVudCk7XG4gIH1cblxuICAvKipcbiAgICogT3ZlcndyaXRlcyBuYXRpdmUgTWFwJ3MgYHNldCgpYCBmdW5jdGlvbiB0byBzdXBwb3J0IHNldHRlcnMsIGBwb3B1bGF0ZSgpYCxcbiAgICogYW5kIGNoYW5nZSB0cmFja2luZy4gTm90ZSB0aGF0IE1vbmdvb3NlIG1hcHMgX29ubHlfIHN1cHBvcnQgc3RyaW5ncyBhbmRcbiAgICogT2JqZWN0SWRzIGFzIGtleXMuXG4gICAqXG4gICAqICMjIyMgRXhhbXBsZTpcbiAgICpcbiAgICogICAgIGRvYy5teU1hcC5zZXQoJ3Rlc3QnLCA0Mik7IC8vIHdvcmtzXG4gICAqICAgICBkb2MubXlNYXAuc2V0KHsgb2JqOiA0MiB9LCA0Mik7IC8vIFRocm93cyBcIk1vbmdvb3NlIG1hcHMgb25seSBzdXBwb3J0IHN0cmluZyBrZXlzXCJcbiAgICpcbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1ldGhvZCBzZXRcbiAgICogQG1lbWJlck9mIE1hcFxuICAgKi9cblxuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIGlmIChpc0Jzb25UeXBlKGtleSwgJ09iamVjdElkJykpIHtcbiAgICAgIGtleSA9IGtleS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGNoZWNrVmFsaWRLZXkoa2V5KTtcbiAgICB2YWx1ZSA9IGhhbmRsZVNwcmVhZERvYyh2YWx1ZSk7XG5cbiAgICAvLyBXZWlyZCwgYnV0IGJlY2F1c2UgeW91IGNhbid0IGFzc2lnbiB0byBgdGhpc2AgYmVmb3JlIGNhbGxpbmcgYHN1cGVyKClgXG4gICAgLy8geW91IGNhbid0IGdldCBhY2Nlc3MgdG8gYCRfX3NjaGVtYVR5cGVgIHRvIGNhc3QgaW4gdGhlIGluaXRpYWwgY2FsbCB0b1xuICAgIC8vIGBzZXQoKWAgZnJvbSB0aGUgYHN1cGVyKClgIGNvbnN0cnVjdG9yLlxuXG4gICAgaWYgKHRoaXMuJF9fc2NoZW1hVHlwZSA9PSBudWxsKSB7XG4gICAgICB0aGlzLiRfX2RlZmVycmVkID0gdGhpcy4kX19kZWZlcnJlZCB8fCBbXTtcbiAgICAgIHRoaXMuJF9fZGVmZXJyZWQucHVzaCh7IGtleToga2V5LCB2YWx1ZTogdmFsdWUgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IF9mdWxsUGF0aDtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLiRfX3BhcmVudDtcbiAgICBjb25zdCBwb3B1bGF0ZWQgPSBwYXJlbnQgIT0gbnVsbCAmJiBwYXJlbnQuJF9fICYmIHBhcmVudC4kX18ucG9wdWxhdGVkID9cbiAgICAgIHBhcmVudC4kcG9wdWxhdGVkKGZ1bGxQYXRoLmNhbGwodGhpcyksIHRydWUpIHx8IHBhcmVudC4kcG9wdWxhdGVkKHRoaXMuJF9fcGF0aCwgdHJ1ZSkgOlxuICAgICAgbnVsbDtcbiAgICBjb25zdCBwcmlvclZhbCA9IHRoaXMuZ2V0KGtleSk7XG5cbiAgICBpZiAocG9wdWxhdGVkICE9IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLiRfX3NjaGVtYVR5cGUuJGlzU2luZ2xlTmVzdGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBNb25nb29zZUVycm9yKFxuICAgICAgICAgICdDYW5ub3QgbWFudWFsbHkgcG9wdWxhdGUgc2luZ2xlIG5lc3RlZCBzdWJkb2MgdW5kZXJuZWF0aCBNYXAgJyArXG4gICAgICAgICAgYGF0IHBhdGggXCIke3RoaXMuJF9fcGF0aH1cIi4gVHJ5IHVzaW5nIGFuIGFycmF5IGluc3RlYWQgb2YgYSBNYXAuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHRoaXMuJF9fc2NoZW1hVHlwZS4kaXNNb25nb29zZUFycmF5KSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUubWFwKHYgPT4ge1xuICAgICAgICAgIGlmICh2LiRfXyA9PSBudWxsKSB7XG4gICAgICAgICAgICB2ID0gbmV3IHBvcHVsYXRlZC5vcHRpb25zW3BvcHVsYXRlTW9kZWxTeW1ib2xdKHYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBEb2Vzbid0IHN1cHBvcnQgc2luZ2xlIG5lc3RlZCBcImluLXBsYWNlXCIgcG9wdWxhdGVcbiAgICAgICAgICB2LiRfXy53YXNQb3B1bGF0ZWQgPSB7IHZhbHVlOiB2Ll9pZCB9O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2YWx1ZS4kX18gPT0gbnVsbCkge1xuICAgICAgICAgIHZhbHVlID0gbmV3IHBvcHVsYXRlZC5vcHRpb25zW3BvcHVsYXRlTW9kZWxTeW1ib2xdKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEb2Vzbid0IHN1cHBvcnQgc2luZ2xlIG5lc3RlZCBcImluLXBsYWNlXCIgcG9wdWxhdGVcbiAgICAgICAgdmFsdWUuJF9fLndhc1BvcHVsYXRlZCA9IHsgdmFsdWU6IHZhbHVlLl9pZCB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy4kX19zY2hlbWFUeXBlLiRpc01vbmdvb3NlRG9jdW1lbnRBcnJheSB8fCB0aGlzLiRfX3NjaGVtYVR5cGUuJGlzU2luZ2xlTmVzdGVkID9cbiAgICAgICAgICB7IHBhdGg6IGZ1bGxQYXRoLmNhbGwodGhpcykgfSA6XG4gICAgICAgICAgbnVsbDtcbiAgICAgICAgdmFsdWUgPSB0aGlzLiRfX3NjaGVtYVR5cGUuYXBwbHlTZXR0ZXJzKFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIHRoaXMuJF9fcGFyZW50LFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIHRoaXMuZ2V0KGtleSksXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKHRoaXMuJF9fcGFyZW50ICE9IG51bGwgJiYgdGhpcy4kX19wYXJlbnQuJF9fICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLiRfX3BhcmVudC5pbnZhbGlkYXRlKGZ1bGxQYXRoLmNhbGwodGhpcyksIGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3VwZXIuc2V0KGtleSwgdmFsdWUpO1xuXG4gICAgaWYgKHBhcmVudCAhPSBudWxsICYmIHBhcmVudC4kX18gIT0gbnVsbCAmJiAhZGVlcEVxdWFsKHZhbHVlLCBwcmlvclZhbCkpIHtcbiAgICAgIHBhcmVudC5tYXJrTW9kaWZpZWQoZnVsbFBhdGguY2FsbCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLy8gRGVsYXkgY2FsY3VsYXRpbmcgZnVsbCBwYXRoIHVubGVzcyBhYnNvbHV0ZWx5IG5lY2Vzc2FyeSwgYmVjYXVzZSBzdHJpbmdcbiAgICAvLyBjb25jYXRlbmF0aW9uIGlzIGEgYm90dGxlbmVjayByZTogIzEzMTcxXG4gICAgZnVuY3Rpb24gZnVsbFBhdGgoKSB7XG4gICAgICBpZiAoX2Z1bGxQYXRoKSB7XG4gICAgICAgIHJldHVybiBfZnVsbFBhdGg7XG4gICAgICB9XG4gICAgICBfZnVsbFBhdGggPSB0aGlzLiRfX3BhdGggKyAnLicgKyBrZXk7XG4gICAgICByZXR1cm4gX2Z1bGxQYXRoO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVyd3JpdGVzIG5hdGl2ZSBNYXAncyBgY2xlYXIoKWAgZnVuY3Rpb24gdG8gc3VwcG9ydCBjaGFuZ2UgdHJhY2tpbmcuXG4gICAqXG4gICAqIEBhcGkgcHVibGljXG4gICAqIEBtZXRob2QgY2xlYXJcbiAgICogQG1lbWJlck9mIE1hcFxuICAgKi9cblxuICBjbGVhcigpIHtcbiAgICBzdXBlci5jbGVhcigpO1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuJF9fcGFyZW50O1xuICAgIGlmIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgcGFyZW50Lm1hcmtNb2RpZmllZCh0aGlzLiRfX3BhdGgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVyd3JpdGVzIG5hdGl2ZSBNYXAncyBgZGVsZXRlKClgIGZ1bmN0aW9uIHRvIHN1cHBvcnQgY2hhbmdlIHRyYWNraW5nLlxuICAgKlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWV0aG9kIGRlbGV0ZVxuICAgKiBAbWVtYmVyT2YgTWFwXG4gICAqL1xuXG4gIGRlbGV0ZShrZXkpIHtcbiAgICBpZiAoaXNCc29uVHlwZShrZXksICdPYmplY3RJZCcpKSB7XG4gICAgICBrZXkgPSBrZXkudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldChrZXksIHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIHN1cGVyLmRlbGV0ZShrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoaXMgbWFwIHRvIGEgbmF0aXZlIEphdmFTY3JpcHQgTWFwIHNvIHRoZSBNb25nb0RCIGRyaXZlciBjYW4gc2VyaWFsaXplIGl0LlxuICAgKlxuICAgKiBAYXBpIHB1YmxpY1xuICAgKiBAbWV0aG9kIHRvQlNPTlxuICAgKiBAbWVtYmVyT2YgTWFwXG4gICAqL1xuXG4gIHRvQlNPTigpIHtcbiAgICByZXR1cm4gbmV3IE1hcCh0aGlzKTtcbiAgfVxuXG4gIHRvT2JqZWN0KG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmZsYXR0ZW5NYXBzKSB7XG4gICAgICBjb25zdCByZXQgPSB7fTtcbiAgICAgIGNvbnN0IGtleXMgPSB0aGlzLmtleXMoKTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgcmV0W2tleV0gPSBjbG9uZSh0aGlzLmdldChrZXkpLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBNYXAodGhpcyk7XG4gIH1cblxuICAkdG9PYmplY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLnRvT2JqZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhpcyBtYXAgdG8gYSBuYXRpdmUgSmF2YVNjcmlwdCBNYXAgZm9yIGBKU09OLnN0cmluZ2lmeSgpYC4gU2V0XG4gICAqIHRoZSBgZmxhdHRlbk1hcHNgIG9wdGlvbiB0byBjb252ZXJ0IHRoaXMgbWFwIHRvIGEgUE9KTyBpbnN0ZWFkLlxuICAgKlxuICAgKiAjIyMjIEV4YW1wbGU6XG4gICAqXG4gICAqICAgICBkb2MubXlNYXAudG9KU09OKCkgaW5zdGFuY2VvZiBNYXA7IC8vIHRydWVcbiAgICogICAgIGRvYy5teU1hcC50b0pTT04oeyBmbGF0dGVuTWFwczogdHJ1ZSB9KSBpbnN0YW5jZW9mIE1hcDsgLy8gZmFsc2VcbiAgICpcbiAgICogQGFwaSBwdWJsaWNcbiAgICogQG1ldGhvZCB0b0pTT05cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZsYXR0ZW5NYXBzPWZhbHNlXSBzZXQgdG8gYHRydWVgIHRvIGNvbnZlcnQgdGhlIG1hcCB0byBhIFBPSk8gcmF0aGVyIHRoYW4gYSBuYXRpdmUgSmF2YVNjcmlwdCBtYXBcbiAgICogQG1lbWJlck9mIE1hcFxuICAgKi9cblxuICB0b0pTT04ob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgKG9wdGlvbnMgJiYgb3B0aW9ucy5mbGF0dGVuTWFwcykgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuZmxhdHRlbk1hcHMgOiB0cnVlKSB7XG4gICAgICBjb25zdCByZXQgPSB7fTtcbiAgICAgIGNvbnN0IGtleXMgPSB0aGlzLmtleXMoKTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgcmV0W2tleV0gPSBjbG9uZSh0aGlzLmdldChrZXkpLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBNYXAodGhpcyk7XG4gIH1cblxuICBpbnNwZWN0KCkge1xuICAgIHJldHVybiBuZXcgTWFwKHRoaXMpO1xuICB9XG5cbiAgJF9fcnVuRGVmZXJyZWQoKSB7XG4gICAgaWYgKCF0aGlzLiRfX2RlZmVycmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBrZXlWYWx1ZU9iamVjdCBvZiB0aGlzLiRfX2RlZmVycmVkKSB7XG4gICAgICB0aGlzLnNldChrZXlWYWx1ZU9iamVjdC5rZXksIGtleVZhbHVlT2JqZWN0LnZhbHVlKTtcbiAgICB9XG5cbiAgICB0aGlzLiRfX2RlZmVycmVkID0gbnVsbDtcbiAgfVxufVxuXG5pZiAodXRpbC5pbnNwZWN0LmN1c3RvbSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9uZ29vc2VNYXAucHJvdG90eXBlLCB1dGlsLmluc3BlY3QuY3VzdG9tLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IE1vbmdvb3NlTWFwLnByb3RvdHlwZS5pbnNwZWN0XG4gIH0pO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTW9uZ29vc2VNYXAucHJvdG90eXBlLCAnJF9fc2V0Jywge1xuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogZmFsc2Vcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTW9uZ29vc2VNYXAucHJvdG90eXBlLCAnJF9fcGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogZmFsc2Vcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTW9uZ29vc2VNYXAucHJvdG90eXBlLCAnJF9fcGF0aCcsIHtcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IGZhbHNlXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vbmdvb3NlTWFwLnByb3RvdHlwZSwgJyRfX3NjaGVtYVR5cGUnLCB7XG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiBmYWxzZVxufSk7XG5cbi8qKlxuICogU2V0IHRvIGB0cnVlYCBmb3IgYWxsIE1vbmdvb3NlIG1hcCBpbnN0YW5jZXNcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHByb3BlcnR5ICRpc01vbmdvb3NlTWFwXG4gKiBAbWVtYmVyT2YgTW9uZ29vc2VNYXBcbiAqIEBpbnN0YW5jZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb25nb29zZU1hcC5wcm90b3R5cGUsICckaXNNb25nb29zZU1hcCcsIHtcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIHdyaXRhYmxlOiBmYWxzZSxcbiAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTW9uZ29vc2VNYXAucHJvdG90eXBlLCAnJF9fZGVmZXJyZWRDYWxscycsIHtcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIHdyaXRhYmxlOiBmYWxzZSxcbiAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG4vKipcbiAqIFNpbmNlIG1hcHMgYXJlIHN0b3JlZCBhcyBvYmplY3RzIHVuZGVyIHRoZSBob29kLCBrZXlzIG11c3QgYmUgc3RyaW5nc1xuICogYW5kIGNhbid0IGNvbnRhaW4gYW55IGludmFsaWQgY2hhcmFjdGVyc1xuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY2hlY2tWYWxpZEtleShrZXkpIHtcbiAgY29uc3Qga2V5VHlwZSA9IHR5cGVvZiBrZXk7XG4gIGlmIChrZXlUeXBlICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE1vbmdvb3NlIG1hcHMgb25seSBzdXBwb3J0IHN0cmluZyBrZXlzLCBnb3QgJHtrZXlUeXBlfWApO1xuICB9XG4gIGlmIChrZXkuc3RhcnRzV2l0aCgnJCcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBNb25nb29zZSBtYXBzIGRvIG5vdCBzdXBwb3J0IGtleXMgdGhhdCBzdGFydCB3aXRoIFwiJFwiLCBnb3QgXCIke2tleX1cImApO1xuICB9XG4gIGlmIChrZXkuaW5jbHVkZXMoJy4nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTW9uZ29vc2UgbWFwcyBkbyBub3Qgc3VwcG9ydCBrZXlzIHRoYXQgY29udGFpbiBcIi5cIiwgZ290IFwiJHtrZXl9XCJgKTtcbiAgfVxuICBpZiAoc3BlY2lhbFByb3BlcnRpZXMuaGFzKGtleSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE1vbmdvb3NlIG1hcHMgZG8gbm90IHN1cHBvcnQgcmVzZXJ2ZWQga2V5IG5hbWUgXCIke2tleX1cImApO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTW9uZ29vc2VNYXA7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/types/map.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/types/objectid.js":
/*!**************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/types/objectid.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * ObjectId type constructor\n *\n * #### Example:\n *\n *     const id = new mongoose.Types.ObjectId;\n *\n * @constructor ObjectId\n */\n\n\n\nconst ObjectId = (__webpack_require__(/*! bson */ \"../backend/node_modules/bson/lib/bson.cjs\").ObjectId);\nconst objectIdSymbol = (__webpack_require__(/*! ../helpers/symbols */ \"../backend/node_modules/mongoose/lib/helpers/symbols.js\").objectIdSymbol);\n\n/**\n * Getter for convenience with populate, see gh-6115\n * @api private\n */\n\nObject.defineProperty(ObjectId.prototype, '_id', {\n  enumerable: false,\n  configurable: true,\n  get: function() {\n    return this;\n  }\n});\n\n/*!\n * Convenience `valueOf()` to allow comparing ObjectIds using double equals re: gh-7299\n */\n\nif (!ObjectId.prototype.hasOwnProperty('valueOf')) {\n  ObjectId.prototype.valueOf = function objectIdValueOf() {\n    return this.toString();\n  };\n}\n\nObjectId.prototype[objectIdSymbol] = true;\n\nmodule.exports = ObjectId;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL29iamVjdGlkLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixpQkFBaUIsdUZBQXdCO0FBQ3pDLHVCQUF1Qix5SEFBNEM7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdHlwZXMvb2JqZWN0aWQuanM/YjkxZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE9iamVjdElkIHR5cGUgY29uc3RydWN0b3JcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGlkID0gbmV3IG1vbmdvb3NlLlR5cGVzLk9iamVjdElkO1xuICpcbiAqIEBjb25zdHJ1Y3RvciBPYmplY3RJZFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgT2JqZWN0SWQgPSByZXF1aXJlKCdic29uJykuT2JqZWN0SWQ7XG5jb25zdCBvYmplY3RJZFN5bWJvbCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvc3ltYm9scycpLm9iamVjdElkU3ltYm9sO1xuXG4vKipcbiAqIEdldHRlciBmb3IgY29udmVuaWVuY2Ugd2l0aCBwb3B1bGF0ZSwgc2VlIGdoLTYxMTVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3RJZC5wcm90b3R5cGUsICdfaWQnLCB7XG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pO1xuXG4vKiFcbiAqIENvbnZlbmllbmNlIGB2YWx1ZU9mKClgIHRvIGFsbG93IGNvbXBhcmluZyBPYmplY3RJZHMgdXNpbmcgZG91YmxlIGVxdWFscyByZTogZ2gtNzI5OVxuICovXG5cbmlmICghT2JqZWN0SWQucHJvdG90eXBlLmhhc093blByb3BlcnR5KCd2YWx1ZU9mJykpIHtcbiAgT2JqZWN0SWQucHJvdG90eXBlLnZhbHVlT2YgPSBmdW5jdGlvbiBvYmplY3RJZFZhbHVlT2YoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgfTtcbn1cblxuT2JqZWN0SWQucHJvdG90eXBlW29iamVjdElkU3ltYm9sXSA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0SWQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/types/objectid.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/types/subdocument.js":
/*!*****************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/types/subdocument.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Document = __webpack_require__(/*! ../document */ \"../backend/node_modules/mongoose/lib/document.js\");\nconst immediate = __webpack_require__(/*! ../helpers/immediate */ \"../backend/node_modules/mongoose/lib/helpers/immediate.js\");\nconst internalToObjectOptions = (__webpack_require__(/*! ../options */ \"../backend/node_modules/mongoose/lib/options.js\").internalToObjectOptions);\nconst util = __webpack_require__(/*! util */ \"util\");\nconst utils = __webpack_require__(/*! ../utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\n\nmodule.exports = Subdocument;\n\n/**\n * Subdocument constructor.\n *\n * @inherits Document\n * @api private\n */\n\nfunction Subdocument(value, fields, parent, skipId, options) {\n  if (typeof skipId === 'object' && skipId != null && options == null) {\n    options = skipId;\n    skipId = undefined;\n  }\n  if (parent != null) {\n    // If setting a nested path, should copy isNew from parent re: gh-7048\n    const parentOptions = { isNew: parent.isNew };\n    if ('defaults' in parent.$__) {\n      parentOptions.defaults = parent.$__.defaults;\n    }\n    options = Object.assign(parentOptions, options);\n  }\n  if (options != null && options.path != null) {\n    this.$basePath = options.path;\n  }\n  Document.call(this, value, fields, skipId, options);\n\n  delete this.$__.priorDoc;\n}\n\nSubdocument.prototype = Object.create(Document.prototype);\n\nObject.defineProperty(Subdocument.prototype, '$isSubdocument', {\n  configurable: false,\n  writable: false,\n  value: true\n});\n\nObject.defineProperty(Subdocument.prototype, '$isSingleNested', {\n  configurable: false,\n  writable: false,\n  value: true\n});\n\n/*!\n * ignore\n */\n\nSubdocument.prototype.toBSON = function() {\n  return this.toObject(internalToObjectOptions);\n};\n\n/**\n * Used as a stub for middleware\n *\n * #### Note:\n *\n * _This is a no-op. Does not actually save the doc to the db._\n *\n * @param {Function} [fn]\n * @return {Promise} resolved Promise\n * @api private\n */\n\nSubdocument.prototype.save = async function save(options) {\n  options = options || {};\n\n  if (!options.suppressWarning) {\n    utils.warn('mongoose: calling `save()` on a subdoc does **not** save ' +\n      'the document to MongoDB, it only runs save middleware. ' +\n      'Use `subdoc.save({ suppressWarning: true })` to hide this warning ' +\n      'if you\\'re sure this behavior is right for your app.');\n  }\n\n  return new Promise((resolve, reject) => {\n    this.$__save((err) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve(this);\n    });\n  });\n};\n\n/**\n * Given a path relative to this document, return the path relative\n * to the top-level document.\n * @param {String} path\n * @method $__fullPath\n * @memberOf Subdocument\n * @instance\n * @returns {String}\n * @api private\n */\n\nSubdocument.prototype.$__fullPath = function(path) {\n  if (!this.$__.fullPath) {\n    this.ownerDocument();\n  }\n\n  return path ?\n    this.$__.fullPath + '.' + path :\n    this.$__.fullPath;\n};\n\n/**\n * Given a path relative to this document, return the path relative\n * to the top-level document.\n * @param {String} p\n * @returns {String}\n * @method $__pathRelativeToParent\n * @memberOf Subdocument\n * @instance\n * @api private\n */\n\nSubdocument.prototype.$__pathRelativeToParent = function(p) {\n  if (p == null) {\n    return this.$basePath;\n  }\n  return [this.$basePath, p].join('.');\n};\n\n/**\n * Used as a stub for middleware\n *\n * #### Note:\n *\n * _This is a no-op. Does not actually save the doc to the db._\n *\n * @param {Function} [fn]\n * @method $__save\n * @api private\n */\n\nSubdocument.prototype.$__save = function(fn) {\n  return immediate(() => fn(null, this));\n};\n\n/*!\n * ignore\n */\n\nSubdocument.prototype.$isValid = function(path) {\n  const parent = this.$parent();\n  const fullPath = this.$__pathRelativeToParent(path);\n  if (parent != null && fullPath != null) {\n    return parent.$isValid(fullPath);\n  }\n  return Document.prototype.$isValid.call(this, path);\n};\n\n/*!\n * ignore\n */\n\nSubdocument.prototype.markModified = function(path) {\n  Document.prototype.markModified.call(this, path);\n  const parent = this.$parent();\n  const fullPath = this.$__pathRelativeToParent(path);\n\n  if (parent == null || fullPath == null) {\n    return;\n  }\n\n  const myPath = this.$__pathRelativeToParent().replace(/\\.$/, '');\n  if (parent.isDirectModified(myPath) || this.isNew) {\n    return;\n  }\n  this.$__parent.markModified(fullPath, this);\n};\n\n/*!\n * ignore\n */\n\nSubdocument.prototype.isModified = function(paths, options, modifiedPaths) {\n  const parent = this.$parent();\n  if (parent != null) {\n    if (Array.isArray(paths) || typeof paths === 'string') {\n      paths = (Array.isArray(paths) ? paths : paths.split(' '));\n      paths = paths.map(p => this.$__pathRelativeToParent(p)).filter(p => p != null);\n    } else if (!paths) {\n      paths = this.$__pathRelativeToParent();\n    }\n\n    return parent.$isModified(paths, options, modifiedPaths);\n  }\n\n  return Document.prototype.isModified.call(this, paths, options, modifiedPaths);\n};\n\n/**\n * Marks a path as valid, removing existing validation errors.\n *\n * @param {String} path the field to mark as valid\n * @api private\n * @method $markValid\n * @memberOf Subdocument\n */\n\nSubdocument.prototype.$markValid = function(path) {\n  Document.prototype.$markValid.call(this, path);\n  const parent = this.$parent();\n  const fullPath = this.$__pathRelativeToParent(path);\n  if (parent != null && fullPath != null) {\n    parent.$markValid(fullPath);\n  }\n};\n\n/*!\n * ignore\n */\n\nSubdocument.prototype.invalidate = function(path, err, val) {\n  Document.prototype.invalidate.call(this, path, err, val);\n\n  const parent = this.$parent();\n  const fullPath = this.$__pathRelativeToParent(path);\n  if (parent != null && fullPath != null) {\n    parent.invalidate(fullPath, err, val);\n  } else if (err.kind === 'cast' || err.name === 'CastError' || fullPath == null) {\n    throw err;\n  }\n\n  return this.ownerDocument().$__.validationError;\n};\n\n/*!\n * ignore\n */\n\nSubdocument.prototype.$ignore = function(path) {\n  Document.prototype.$ignore.call(this, path);\n  const parent = this.$parent();\n  const fullPath = this.$__pathRelativeToParent(path);\n  if (parent != null && fullPath != null) {\n    parent.$ignore(fullPath);\n  }\n};\n\n/**\n * Returns the top level document of this sub-document.\n *\n * @return {Document}\n */\n\nSubdocument.prototype.ownerDocument = function() {\n  if (this.$__.ownerDocument) {\n    return this.$__.ownerDocument;\n  }\n\n  let parent = this; // eslint-disable-line consistent-this\n  const paths = [];\n  const seenDocs = new Set([parent]);\n\n  while (true) {\n    if (typeof parent.$__pathRelativeToParent !== 'function') {\n      break;\n    }\n    paths.unshift(parent.$__pathRelativeToParent(void 0, true));\n    const _parent = parent.$parent();\n    if (_parent == null) {\n      break;\n    }\n    parent = _parent;\n    if (seenDocs.has(parent)) {\n      throw new Error('Infinite subdocument loop: subdoc with _id ' + parent._id + ' is a parent of itself');\n    }\n\n    seenDocs.add(parent);\n  }\n\n  this.$__.fullPath = paths.join('.');\n\n  this.$__.ownerDocument = parent;\n  return this.$__.ownerDocument;\n};\n\n/*!\n * ignore\n */\n\nSubdocument.prototype.$__fullPathWithIndexes = function() {\n  let parent = this; // eslint-disable-line consistent-this\n  const paths = [];\n  const seenDocs = new Set([parent]);\n\n  while (true) {\n    if (typeof parent.$__pathRelativeToParent !== 'function') {\n      break;\n    }\n    paths.unshift(parent.$__pathRelativeToParent(void 0, false));\n    const _parent = parent.$parent();\n    if (_parent == null) {\n      break;\n    }\n    parent = _parent;\n    if (seenDocs.has(parent)) {\n      throw new Error('Infinite subdocument loop: subdoc with _id ' + parent._id + ' is a parent of itself');\n    }\n\n    seenDocs.add(parent);\n  }\n\n  return paths.join('.');\n};\n\n/**\n * Returns this sub-documents parent document.\n *\n * @api public\n */\n\nSubdocument.prototype.parent = function() {\n  return this.$__parent;\n};\n\n/**\n * Returns this sub-documents parent document.\n *\n * @api public\n * @method $parent\n */\n\nSubdocument.prototype.$parent = Subdocument.prototype.parent;\n\n/**\n * no-op for hooks\n * @param {Function} cb\n * @method $__deleteOne\n * @memberOf Subdocument\n * @instance\n * @api private\n */\n\nSubdocument.prototype.$__deleteOne = function(cb) {\n  if (cb == null) {\n    return;\n  }\n  return cb(null, this);\n};\n\n/**\n * ignore\n * @method $__removeFromParent\n * @memberOf Subdocument\n * @instance\n * @api private\n */\n\nSubdocument.prototype.$__removeFromParent = function() {\n  this.$__parent.set(this.$basePath, null);\n};\n\n/**\n * Null-out this subdoc\n *\n * @param {Object} [options]\n * @param {Function} [callback] optional callback for compatibility with Document.prototype.remove\n */\n\nSubdocument.prototype.deleteOne = function(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  registerRemoveListener(this);\n\n  // If removing entire doc, no need to remove subdoc\n  if (!options || !options.noop) {\n    this.$__removeFromParent();\n  }\n\n  return this.$__deleteOne(callback);\n};\n\n/*!\n * ignore\n */\n\nSubdocument.prototype.populate = function() {\n  throw new Error('Mongoose does not support calling populate() on nested ' +\n    'docs. Instead of `doc.nested.populate(\"path\")`, use ' +\n    '`doc.populate(\"nested.path\")`');\n};\n\n/**\n * Helper for console.log\n *\n * @api public\n */\n\nSubdocument.prototype.inspect = function() {\n  return this.toObject();\n};\n\nif (util.inspect.custom) {\n  // Avoid Node deprecation warning DEP0079\n  Subdocument.prototype[util.inspect.custom] = Subdocument.prototype.inspect;\n}\n\n/**\n * Registers remove event listeners for triggering\n * on subdocuments.\n *\n * @param {Subdocument} sub\n * @api private\n */\n\nfunction registerRemoveListener(sub) {\n  let owner = sub.ownerDocument();\n\n  function emitRemove() {\n    owner.$removeListener('save', emitRemove);\n    owner.$removeListener('deleteOne', emitRemove);\n    sub.emit('deleteOne', sub);\n    sub.constructor.emit('deleteOne', sub);\n    owner = sub = null;\n  }\n\n  owner.$on('save', emitRemove);\n  owner.$on('deleteOne', emitRemove);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL3N1YmRvY3VtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGlCQUFpQixtQkFBTyxDQUFDLHFFQUFhO0FBQ3RDLGtCQUFrQixtQkFBTyxDQUFDLHVGQUFzQjtBQUNoRCxnQ0FBZ0Msa0hBQTZDO0FBQzdFLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixjQUFjLG1CQUFPLENBQUMsK0RBQVU7O0FBRWhDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdUJBQXVCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi90eXBlcy9zdWJkb2N1bWVudC5qcz9iNzM4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRG9jdW1lbnQgPSByZXF1aXJlKCcuLi9kb2N1bWVudCcpO1xuY29uc3QgaW1tZWRpYXRlID0gcmVxdWlyZSgnLi4vaGVscGVycy9pbW1lZGlhdGUnKTtcbmNvbnN0IGludGVybmFsVG9PYmplY3RPcHRpb25zID0gcmVxdWlyZSgnLi4vb3B0aW9ucycpLmludGVybmFsVG9PYmplY3RPcHRpb25zO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdWJkb2N1bWVudDtcblxuLyoqXG4gKiBTdWJkb2N1bWVudCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAaW5oZXJpdHMgRG9jdW1lbnRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIFN1YmRvY3VtZW50KHZhbHVlLCBmaWVsZHMsIHBhcmVudCwgc2tpcElkLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygc2tpcElkID09PSAnb2JqZWN0JyAmJiBza2lwSWQgIT0gbnVsbCAmJiBvcHRpb25zID09IG51bGwpIHtcbiAgICBvcHRpb25zID0gc2tpcElkO1xuICAgIHNraXBJZCA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAocGFyZW50ICE9IG51bGwpIHtcbiAgICAvLyBJZiBzZXR0aW5nIGEgbmVzdGVkIHBhdGgsIHNob3VsZCBjb3B5IGlzTmV3IGZyb20gcGFyZW50IHJlOiBnaC03MDQ4XG4gICAgY29uc3QgcGFyZW50T3B0aW9ucyA9IHsgaXNOZXc6IHBhcmVudC5pc05ldyB9O1xuICAgIGlmICgnZGVmYXVsdHMnIGluIHBhcmVudC4kX18pIHtcbiAgICAgIHBhcmVudE9wdGlvbnMuZGVmYXVsdHMgPSBwYXJlbnQuJF9fLmRlZmF1bHRzO1xuICAgIH1cbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihwYXJlbnRPcHRpb25zLCBvcHRpb25zKTtcbiAgfVxuICBpZiAob3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMucGF0aCAhPSBudWxsKSB7XG4gICAgdGhpcy4kYmFzZVBhdGggPSBvcHRpb25zLnBhdGg7XG4gIH1cbiAgRG9jdW1lbnQuY2FsbCh0aGlzLCB2YWx1ZSwgZmllbGRzLCBza2lwSWQsIG9wdGlvbnMpO1xuXG4gIGRlbGV0ZSB0aGlzLiRfXy5wcmlvckRvYztcbn1cblxuU3ViZG9jdW1lbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShEb2N1bWVudC5wcm90b3R5cGUpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU3ViZG9jdW1lbnQucHJvdG90eXBlLCAnJGlzU3ViZG9jdW1lbnQnLCB7XG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIHdyaXRhYmxlOiBmYWxzZSxcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU3ViZG9jdW1lbnQucHJvdG90eXBlLCAnJGlzU2luZ2xlTmVzdGVkJywge1xuICBjb25maWd1cmFibGU6IGZhbHNlLFxuICB3cml0YWJsZTogZmFsc2UsXG4gIHZhbHVlOiB0cnVlXG59KTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TdWJkb2N1bWVudC5wcm90b3R5cGUudG9CU09OID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRvT2JqZWN0KGludGVybmFsVG9PYmplY3RPcHRpb25zKTtcbn07XG5cbi8qKlxuICogVXNlZCBhcyBhIHN0dWIgZm9yIG1pZGRsZXdhcmVcbiAqXG4gKiAjIyMjIE5vdGU6XG4gKlxuICogX1RoaXMgaXMgYSBuby1vcC4gRG9lcyBub3QgYWN0dWFsbHkgc2F2ZSB0aGUgZG9jIHRvIHRoZSBkYi5fXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UHJvbWlzZX0gcmVzb2x2ZWQgUHJvbWlzZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU3ViZG9jdW1lbnQucHJvdG90eXBlLnNhdmUgPSBhc3luYyBmdW5jdGlvbiBzYXZlKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKCFvcHRpb25zLnN1cHByZXNzV2FybmluZykge1xuICAgIHV0aWxzLndhcm4oJ21vbmdvb3NlOiBjYWxsaW5nIGBzYXZlKClgIG9uIGEgc3ViZG9jIGRvZXMgKipub3QqKiBzYXZlICcgK1xuICAgICAgJ3RoZSBkb2N1bWVudCB0byBNb25nb0RCLCBpdCBvbmx5IHJ1bnMgc2F2ZSBtaWRkbGV3YXJlLiAnICtcbiAgICAgICdVc2UgYHN1YmRvYy5zYXZlKHsgc3VwcHJlc3NXYXJuaW5nOiB0cnVlIH0pYCB0byBoaWRlIHRoaXMgd2FybmluZyAnICtcbiAgICAgICdpZiB5b3VcXCdyZSBzdXJlIHRoaXMgYmVoYXZpb3IgaXMgcmlnaHQgZm9yIHlvdXIgYXBwLicpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB0aGlzLiRfX3NhdmUoKGVycikgPT4ge1xuICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBHaXZlbiBhIHBhdGggcmVsYXRpdmUgdG8gdGhpcyBkb2N1bWVudCwgcmV0dXJuIHRoZSBwYXRoIHJlbGF0aXZlXG4gKiB0byB0aGUgdG9wLWxldmVsIGRvY3VtZW50LlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEBtZXRob2QgJF9fZnVsbFBhdGhcbiAqIEBtZW1iZXJPZiBTdWJkb2N1bWVudFxuICogQGluc3RhbmNlXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU3ViZG9jdW1lbnQucHJvdG90eXBlLiRfX2Z1bGxQYXRoID0gZnVuY3Rpb24ocGF0aCkge1xuICBpZiAoIXRoaXMuJF9fLmZ1bGxQYXRoKSB7XG4gICAgdGhpcy5vd25lckRvY3VtZW50KCk7XG4gIH1cblxuICByZXR1cm4gcGF0aCA/XG4gICAgdGhpcy4kX18uZnVsbFBhdGggKyAnLicgKyBwYXRoIDpcbiAgICB0aGlzLiRfXy5mdWxsUGF0aDtcbn07XG5cbi8qKlxuICogR2l2ZW4gYSBwYXRoIHJlbGF0aXZlIHRvIHRoaXMgZG9jdW1lbnQsIHJldHVybiB0aGUgcGF0aCByZWxhdGl2ZVxuICogdG8gdGhlIHRvcC1sZXZlbCBkb2N1bWVudC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICogQG1ldGhvZCAkX19wYXRoUmVsYXRpdmVUb1BhcmVudFxuICogQG1lbWJlck9mIFN1YmRvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblN1YmRvY3VtZW50LnByb3RvdHlwZS4kX19wYXRoUmVsYXRpdmVUb1BhcmVudCA9IGZ1bmN0aW9uKHApIHtcbiAgaWYgKHAgPT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLiRiYXNlUGF0aDtcbiAgfVxuICByZXR1cm4gW3RoaXMuJGJhc2VQYXRoLCBwXS5qb2luKCcuJyk7XG59O1xuXG4vKipcbiAqIFVzZWQgYXMgYSBzdHViIGZvciBtaWRkbGV3YXJlXG4gKlxuICogIyMjIyBOb3RlOlxuICpcbiAqIF9UaGlzIGlzIGEgbm8tb3AuIERvZXMgbm90IGFjdHVhbGx5IHNhdmUgdGhlIGRvYyB0byB0aGUgZGIuX1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEBtZXRob2QgJF9fc2F2ZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU3ViZG9jdW1lbnQucHJvdG90eXBlLiRfX3NhdmUgPSBmdW5jdGlvbihmbikge1xuICByZXR1cm4gaW1tZWRpYXRlKCgpID0+IGZuKG51bGwsIHRoaXMpKTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU3ViZG9jdW1lbnQucHJvdG90eXBlLiRpc1ZhbGlkID0gZnVuY3Rpb24ocGF0aCkge1xuICBjb25zdCBwYXJlbnQgPSB0aGlzLiRwYXJlbnQoKTtcbiAgY29uc3QgZnVsbFBhdGggPSB0aGlzLiRfX3BhdGhSZWxhdGl2ZVRvUGFyZW50KHBhdGgpO1xuICBpZiAocGFyZW50ICE9IG51bGwgJiYgZnVsbFBhdGggIT0gbnVsbCkge1xuICAgIHJldHVybiBwYXJlbnQuJGlzVmFsaWQoZnVsbFBhdGgpO1xuICB9XG4gIHJldHVybiBEb2N1bWVudC5wcm90b3R5cGUuJGlzVmFsaWQuY2FsbCh0aGlzLCBwYXRoKTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU3ViZG9jdW1lbnQucHJvdG90eXBlLm1hcmtNb2RpZmllZCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgRG9jdW1lbnQucHJvdG90eXBlLm1hcmtNb2RpZmllZC5jYWxsKHRoaXMsIHBhdGgpO1xuICBjb25zdCBwYXJlbnQgPSB0aGlzLiRwYXJlbnQoKTtcbiAgY29uc3QgZnVsbFBhdGggPSB0aGlzLiRfX3BhdGhSZWxhdGl2ZVRvUGFyZW50KHBhdGgpO1xuXG4gIGlmIChwYXJlbnQgPT0gbnVsbCB8fCBmdWxsUGF0aCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgbXlQYXRoID0gdGhpcy4kX19wYXRoUmVsYXRpdmVUb1BhcmVudCgpLnJlcGxhY2UoL1xcLiQvLCAnJyk7XG4gIGlmIChwYXJlbnQuaXNEaXJlY3RNb2RpZmllZChteVBhdGgpIHx8IHRoaXMuaXNOZXcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy4kX19wYXJlbnQubWFya01vZGlmaWVkKGZ1bGxQYXRoLCB0aGlzKTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU3ViZG9jdW1lbnQucHJvdG90eXBlLmlzTW9kaWZpZWQgPSBmdW5jdGlvbihwYXRocywgb3B0aW9ucywgbW9kaWZpZWRQYXRocykge1xuICBjb25zdCBwYXJlbnQgPSB0aGlzLiRwYXJlbnQoKTtcbiAgaWYgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGF0aHMpIHx8IHR5cGVvZiBwYXRocyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHBhdGhzID0gKEFycmF5LmlzQXJyYXkocGF0aHMpID8gcGF0aHMgOiBwYXRocy5zcGxpdCgnICcpKTtcbiAgICAgIHBhdGhzID0gcGF0aHMubWFwKHAgPT4gdGhpcy4kX19wYXRoUmVsYXRpdmVUb1BhcmVudChwKSkuZmlsdGVyKHAgPT4gcCAhPSBudWxsKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRocykge1xuICAgICAgcGF0aHMgPSB0aGlzLiRfX3BhdGhSZWxhdGl2ZVRvUGFyZW50KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmVudC4kaXNNb2RpZmllZChwYXRocywgb3B0aW9ucywgbW9kaWZpZWRQYXRocyk7XG4gIH1cblxuICByZXR1cm4gRG9jdW1lbnQucHJvdG90eXBlLmlzTW9kaWZpZWQuY2FsbCh0aGlzLCBwYXRocywgb3B0aW9ucywgbW9kaWZpZWRQYXRocyk7XG59O1xuXG4vKipcbiAqIE1hcmtzIGEgcGF0aCBhcyB2YWxpZCwgcmVtb3ZpbmcgZXhpc3RpbmcgdmFsaWRhdGlvbiBlcnJvcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdGhlIGZpZWxkIHRvIG1hcmsgYXMgdmFsaWRcbiAqIEBhcGkgcHJpdmF0ZVxuICogQG1ldGhvZCAkbWFya1ZhbGlkXG4gKiBAbWVtYmVyT2YgU3ViZG9jdW1lbnRcbiAqL1xuXG5TdWJkb2N1bWVudC5wcm90b3R5cGUuJG1hcmtWYWxpZCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgRG9jdW1lbnQucHJvdG90eXBlLiRtYXJrVmFsaWQuY2FsbCh0aGlzLCBwYXRoKTtcbiAgY29uc3QgcGFyZW50ID0gdGhpcy4kcGFyZW50KCk7XG4gIGNvbnN0IGZ1bGxQYXRoID0gdGhpcy4kX19wYXRoUmVsYXRpdmVUb1BhcmVudChwYXRoKTtcbiAgaWYgKHBhcmVudCAhPSBudWxsICYmIGZ1bGxQYXRoICE9IG51bGwpIHtcbiAgICBwYXJlbnQuJG1hcmtWYWxpZChmdWxsUGF0aCk7XG4gIH1cbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU3ViZG9jdW1lbnQucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbihwYXRoLCBlcnIsIHZhbCkge1xuICBEb2N1bWVudC5wcm90b3R5cGUuaW52YWxpZGF0ZS5jYWxsKHRoaXMsIHBhdGgsIGVyciwgdmFsKTtcblxuICBjb25zdCBwYXJlbnQgPSB0aGlzLiRwYXJlbnQoKTtcbiAgY29uc3QgZnVsbFBhdGggPSB0aGlzLiRfX3BhdGhSZWxhdGl2ZVRvUGFyZW50KHBhdGgpO1xuICBpZiAocGFyZW50ICE9IG51bGwgJiYgZnVsbFBhdGggIT0gbnVsbCkge1xuICAgIHBhcmVudC5pbnZhbGlkYXRlKGZ1bGxQYXRoLCBlcnIsIHZhbCk7XG4gIH0gZWxzZSBpZiAoZXJyLmtpbmQgPT09ICdjYXN0JyB8fCBlcnIubmFtZSA9PT0gJ0Nhc3RFcnJvcicgfHwgZnVsbFBhdGggPT0gbnVsbCkge1xuICAgIHRocm93IGVycjtcbiAgfVxuXG4gIHJldHVybiB0aGlzLm93bmVyRG9jdW1lbnQoKS4kX18udmFsaWRhdGlvbkVycm9yO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5TdWJkb2N1bWVudC5wcm90b3R5cGUuJGlnbm9yZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgRG9jdW1lbnQucHJvdG90eXBlLiRpZ25vcmUuY2FsbCh0aGlzLCBwYXRoKTtcbiAgY29uc3QgcGFyZW50ID0gdGhpcy4kcGFyZW50KCk7XG4gIGNvbnN0IGZ1bGxQYXRoID0gdGhpcy4kX19wYXRoUmVsYXRpdmVUb1BhcmVudChwYXRoKTtcbiAgaWYgKHBhcmVudCAhPSBudWxsICYmIGZ1bGxQYXRoICE9IG51bGwpIHtcbiAgICBwYXJlbnQuJGlnbm9yZShmdWxsUGF0aCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdG9wIGxldmVsIGRvY3VtZW50IG9mIHRoaXMgc3ViLWRvY3VtZW50LlxuICpcbiAqIEByZXR1cm4ge0RvY3VtZW50fVxuICovXG5cblN1YmRvY3VtZW50LnByb3RvdHlwZS5vd25lckRvY3VtZW50ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLiRfXy5vd25lckRvY3VtZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuJF9fLm93bmVyRG9jdW1lbnQ7XG4gIH1cblxuICBsZXQgcGFyZW50ID0gdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXRoaXNcbiAgY29uc3QgcGF0aHMgPSBbXTtcbiAgY29uc3Qgc2VlbkRvY3MgPSBuZXcgU2V0KFtwYXJlbnRdKTtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmICh0eXBlb2YgcGFyZW50LiRfX3BhdGhSZWxhdGl2ZVRvUGFyZW50ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcGF0aHMudW5zaGlmdChwYXJlbnQuJF9fcGF0aFJlbGF0aXZlVG9QYXJlbnQodm9pZCAwLCB0cnVlKSk7XG4gICAgY29uc3QgX3BhcmVudCA9IHBhcmVudC4kcGFyZW50KCk7XG4gICAgaWYgKF9wYXJlbnQgPT0gbnVsbCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHBhcmVudCA9IF9wYXJlbnQ7XG4gICAgaWYgKHNlZW5Eb2NzLmhhcyhwYXJlbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luZmluaXRlIHN1YmRvY3VtZW50IGxvb3A6IHN1YmRvYyB3aXRoIF9pZCAnICsgcGFyZW50Ll9pZCArICcgaXMgYSBwYXJlbnQgb2YgaXRzZWxmJyk7XG4gICAgfVxuXG4gICAgc2VlbkRvY3MuYWRkKHBhcmVudCk7XG4gIH1cblxuICB0aGlzLiRfXy5mdWxsUGF0aCA9IHBhdGhzLmpvaW4oJy4nKTtcblxuICB0aGlzLiRfXy5vd25lckRvY3VtZW50ID0gcGFyZW50O1xuICByZXR1cm4gdGhpcy4kX18ub3duZXJEb2N1bWVudDtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuU3ViZG9jdW1lbnQucHJvdG90eXBlLiRfX2Z1bGxQYXRoV2l0aEluZGV4ZXMgPSBmdW5jdGlvbigpIHtcbiAgbGV0IHBhcmVudCA9IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC10aGlzXG4gIGNvbnN0IHBhdGhzID0gW107XG4gIGNvbnN0IHNlZW5Eb2NzID0gbmV3IFNldChbcGFyZW50XSk7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAodHlwZW9mIHBhcmVudC4kX19wYXRoUmVsYXRpdmVUb1BhcmVudCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHBhdGhzLnVuc2hpZnQocGFyZW50LiRfX3BhdGhSZWxhdGl2ZVRvUGFyZW50KHZvaWQgMCwgZmFsc2UpKTtcbiAgICBjb25zdCBfcGFyZW50ID0gcGFyZW50LiRwYXJlbnQoKTtcbiAgICBpZiAoX3BhcmVudCA9PSBudWxsKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcGFyZW50ID0gX3BhcmVudDtcbiAgICBpZiAoc2VlbkRvY3MuaGFzKHBhcmVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5maW5pdGUgc3ViZG9jdW1lbnQgbG9vcDogc3ViZG9jIHdpdGggX2lkICcgKyBwYXJlbnQuX2lkICsgJyBpcyBhIHBhcmVudCBvZiBpdHNlbGYnKTtcbiAgICB9XG5cbiAgICBzZWVuRG9jcy5hZGQocGFyZW50KTtcbiAgfVxuXG4gIHJldHVybiBwYXRocy5qb2luKCcuJyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhpcyBzdWItZG9jdW1lbnRzIHBhcmVudCBkb2N1bWVudC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblN1YmRvY3VtZW50LnByb3RvdHlwZS5wYXJlbnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuJF9fcGFyZW50O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoaXMgc3ViLWRvY3VtZW50cyBwYXJlbnQgZG9jdW1lbnQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBtZXRob2QgJHBhcmVudFxuICovXG5cblN1YmRvY3VtZW50LnByb3RvdHlwZS4kcGFyZW50ID0gU3ViZG9jdW1lbnQucHJvdG90eXBlLnBhcmVudDtcblxuLyoqXG4gKiBuby1vcCBmb3IgaG9va3NcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAbWV0aG9kICRfX2RlbGV0ZU9uZVxuICogQG1lbWJlck9mIFN1YmRvY3VtZW50XG4gKiBAaW5zdGFuY2VcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblN1YmRvY3VtZW50LnByb3RvdHlwZS4kX19kZWxldGVPbmUgPSBmdW5jdGlvbihjYikge1xuICBpZiAoY2IgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4gY2IobnVsbCwgdGhpcyk7XG59O1xuXG4vKipcbiAqIGlnbm9yZVxuICogQG1ldGhvZCAkX19yZW1vdmVGcm9tUGFyZW50XG4gKiBAbWVtYmVyT2YgU3ViZG9jdW1lbnRcbiAqIEBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU3ViZG9jdW1lbnQucHJvdG90eXBlLiRfX3JlbW92ZUZyb21QYXJlbnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy4kX19wYXJlbnQuc2V0KHRoaXMuJGJhc2VQYXRoLCBudWxsKTtcbn07XG5cbi8qKlxuICogTnVsbC1vdXQgdGhpcyBzdWJkb2NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIG9wdGlvbmFsIGNhbGxiYWNrIGZvciBjb21wYXRpYmlsaXR5IHdpdGggRG9jdW1lbnQucHJvdG90eXBlLnJlbW92ZVxuICovXG5cblN1YmRvY3VtZW50LnByb3RvdHlwZS5kZWxldGVPbmUgPSBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgcmVnaXN0ZXJSZW1vdmVMaXN0ZW5lcih0aGlzKTtcblxuICAvLyBJZiByZW1vdmluZyBlbnRpcmUgZG9jLCBubyBuZWVkIHRvIHJlbW92ZSBzdWJkb2NcbiAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLm5vb3ApIHtcbiAgICB0aGlzLiRfX3JlbW92ZUZyb21QYXJlbnQoKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLiRfX2RlbGV0ZU9uZShjYWxsYmFjayk7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblN1YmRvY3VtZW50LnByb3RvdHlwZS5wb3B1bGF0ZSA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ01vbmdvb3NlIGRvZXMgbm90IHN1cHBvcnQgY2FsbGluZyBwb3B1bGF0ZSgpIG9uIG5lc3RlZCAnICtcbiAgICAnZG9jcy4gSW5zdGVhZCBvZiBgZG9jLm5lc3RlZC5wb3B1bGF0ZShcInBhdGhcIilgLCB1c2UgJyArXG4gICAgJ2Bkb2MucG9wdWxhdGUoXCJuZXN0ZWQucGF0aFwiKWAnKTtcbn07XG5cbi8qKlxuICogSGVscGVyIGZvciBjb25zb2xlLmxvZ1xuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU3ViZG9jdW1lbnQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9PYmplY3QoKTtcbn07XG5cbmlmICh1dGlsLmluc3BlY3QuY3VzdG9tKSB7XG4gIC8vIEF2b2lkIE5vZGUgZGVwcmVjYXRpb24gd2FybmluZyBERVAwMDc5XG4gIFN1YmRvY3VtZW50LnByb3RvdHlwZVt1dGlsLmluc3BlY3QuY3VzdG9tXSA9IFN1YmRvY3VtZW50LnByb3RvdHlwZS5pbnNwZWN0O1xufVxuXG4vKipcbiAqIFJlZ2lzdGVycyByZW1vdmUgZXZlbnQgbGlzdGVuZXJzIGZvciB0cmlnZ2VyaW5nXG4gKiBvbiBzdWJkb2N1bWVudHMuXG4gKlxuICogQHBhcmFtIHtTdWJkb2N1bWVudH0gc3ViXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiByZWdpc3RlclJlbW92ZUxpc3RlbmVyKHN1Yikge1xuICBsZXQgb3duZXIgPSBzdWIub3duZXJEb2N1bWVudCgpO1xuXG4gIGZ1bmN0aW9uIGVtaXRSZW1vdmUoKSB7XG4gICAgb3duZXIuJHJlbW92ZUxpc3RlbmVyKCdzYXZlJywgZW1pdFJlbW92ZSk7XG4gICAgb3duZXIuJHJlbW92ZUxpc3RlbmVyKCdkZWxldGVPbmUnLCBlbWl0UmVtb3ZlKTtcbiAgICBzdWIuZW1pdCgnZGVsZXRlT25lJywgc3ViKTtcbiAgICBzdWIuY29uc3RydWN0b3IuZW1pdCgnZGVsZXRlT25lJywgc3ViKTtcbiAgICBvd25lciA9IHN1YiA9IG51bGw7XG4gIH1cblxuICBvd25lci4kb24oJ3NhdmUnLCBlbWl0UmVtb3ZlKTtcbiAgb3duZXIuJG9uKCdkZWxldGVPbmUnLCBlbWl0UmVtb3ZlKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/types/subdocument.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/types/uuid.js":
/*!**********************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/types/uuid.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/**\n * UUID type constructor\n *\n * #### Example:\n *\n *     const id = new mongoose.Types.UUID();\n *\n * @constructor UUID\n */\n\n\n\nmodule.exports = __webpack_require__(/*! bson */ \"../backend/node_modules/bson/lib/bson.cjs\").UUID;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3R5cGVzL3V1aWQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLGtHQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL21vbmdvb3NlL2xpYi90eXBlcy91dWlkLmpzPzM3NjQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVVUlEIHR5cGUgY29uc3RydWN0b3JcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKlxuICogICAgIGNvbnN0IGlkID0gbmV3IG1vbmdvb3NlLlR5cGVzLlVVSUQoKTtcbiAqXG4gKiBAY29uc3RydWN0b3IgVVVJRFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdic29uJykuVVVJRDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/types/uuid.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/utils.js":
/*!*****************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/utils.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/*!\n * Module dependencies.\n */\n\nconst UUID = (__webpack_require__(/*! bson */ \"../backend/node_modules/bson/lib/bson.cjs\").UUID);\nconst ms = __webpack_require__(/*! ms */ \"../backend/node_modules/mongoose/node_modules/ms/index.js\");\nconst mpath = __webpack_require__(/*! mpath */ \"../backend/node_modules/mpath/index.js\");\nconst ObjectId = __webpack_require__(/*! ./types/objectid */ \"../backend/node_modules/mongoose/lib/types/objectid.js\");\nconst PopulateOptions = __webpack_require__(/*! ./options/populateOptions */ \"../backend/node_modules/mongoose/lib/options/populateOptions.js\");\nconst clone = __webpack_require__(/*! ./helpers/clone */ \"../backend/node_modules/mongoose/lib/helpers/clone.js\");\nconst immediate = __webpack_require__(/*! ./helpers/immediate */ \"../backend/node_modules/mongoose/lib/helpers/immediate.js\");\nconst isObject = __webpack_require__(/*! ./helpers/isObject */ \"../backend/node_modules/mongoose/lib/helpers/isObject.js\");\nconst isMongooseArray = __webpack_require__(/*! ./types/array/isMongooseArray */ \"../backend/node_modules/mongoose/lib/types/array/isMongooseArray.js\");\nconst isMongooseDocumentArray = __webpack_require__(/*! ./types/documentArray/isMongooseDocumentArray */ \"../backend/node_modules/mongoose/lib/types/documentArray/isMongooseDocumentArray.js\");\nconst isBsonType = __webpack_require__(/*! ./helpers/isBsonType */ \"../backend/node_modules/mongoose/lib/helpers/isBsonType.js\");\nconst getFunctionName = __webpack_require__(/*! ./helpers/getFunctionName */ \"../backend/node_modules/mongoose/lib/helpers/getFunctionName.js\");\nconst isMongooseObject = __webpack_require__(/*! ./helpers/isMongooseObject */ \"../backend/node_modules/mongoose/lib/helpers/isMongooseObject.js\");\nconst promiseOrCallback = __webpack_require__(/*! ./helpers/promiseOrCallback */ \"../backend/node_modules/mongoose/lib/helpers/promiseOrCallback.js\");\nconst schemaMerge = __webpack_require__(/*! ./helpers/schema/merge */ \"../backend/node_modules/mongoose/lib/helpers/schema/merge.js\");\nconst specialProperties = __webpack_require__(/*! ./helpers/specialProperties */ \"../backend/node_modules/mongoose/lib/helpers/specialProperties.js\");\nconst { trustedSymbol } = __webpack_require__(/*! ./helpers/query/trusted */ \"../backend/node_modules/mongoose/lib/helpers/query/trusted.js\");\n\nlet Document;\n\nexports.specialProperties = specialProperties;\n\nexports.isMongooseArray = isMongooseArray.isMongooseArray;\nexports.isMongooseDocumentArray = isMongooseDocumentArray.isMongooseDocumentArray;\nexports.registerMongooseArray = isMongooseArray.registerMongooseArray;\nexports.registerMongooseDocumentArray = isMongooseDocumentArray.registerMongooseDocumentArray;\n\nconst oneSpaceRE = /\\s/;\nconst manySpaceRE = /\\s+/;\n\n/**\n * Produces a collection name from model `name`. By default, just returns\n * the model name\n *\n * @param {String} name a model name\n * @param {Function} pluralize function that pluralizes the collection name\n * @return {String} a collection name\n * @api private\n */\n\nexports.toCollectionName = function(name, pluralize) {\n  if (name === 'system.profile') {\n    return name;\n  }\n  if (name === 'system.indexes') {\n    return name;\n  }\n  if (typeof pluralize === 'function') {\n    return pluralize(name);\n  }\n  return name;\n};\n\n/**\n * Determines if `a` and `b` are deep equal.\n *\n * Modified from node/lib/assert.js\n *\n * @param {any} a a value to compare to `b`\n * @param {any} b a value to compare to `a`\n * @return {Boolean}\n * @api private\n */\n\nexports.deepEqual = function deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== 'object' || typeof b !== 'object') {\n    return a === b;\n  }\n\n  if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime();\n  }\n\n  if ((isBsonType(a, 'ObjectId') && isBsonType(b, 'ObjectId')) ||\n      (isBsonType(a, 'Decimal128') && isBsonType(b, 'Decimal128'))) {\n    return a.toString() === b.toString();\n  }\n\n  if (a instanceof RegExp && b instanceof RegExp) {\n    return a.source === b.source &&\n        a.ignoreCase === b.ignoreCase &&\n        a.multiline === b.multiline &&\n        a.global === b.global &&\n        a.dotAll === b.dotAll &&\n        a.unicode === b.unicode &&\n        a.sticky === b.sticky &&\n        a.hasIndices === b.hasIndices;\n  }\n\n  if (a == null || b == null) {\n    return false;\n  }\n\n  if (a.prototype !== b.prototype) {\n    return false;\n  }\n\n  if (a instanceof Map || b instanceof Map) {\n    if (!(a instanceof Map) || !(b instanceof Map)) {\n      return false;\n    }\n    return deepEqual(Array.from(a.keys()), Array.from(b.keys())) &&\n      deepEqual(Array.from(a.values()), Array.from(b.values()));\n  }\n\n  // Handle MongooseNumbers\n  if (a instanceof Number && b instanceof Number) {\n    return a.valueOf() === b.valueOf();\n  }\n\n  if (Buffer.isBuffer(a)) {\n    return exports.buffer.areEqual(a, b);\n  }\n\n  if (Array.isArray(a) || Array.isArray(b)) {\n    if (!Array.isArray(a) || !Array.isArray(b)) {\n      return false;\n    }\n    const len = a.length;\n    if (len !== b.length) {\n      return false;\n    }\n    for (let i = 0; i < len; ++i) {\n      if (!deepEqual(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  if (a.$__ != null) {\n    a = a._doc;\n  } else if (isMongooseObject(a)) {\n    a = a.toObject();\n  }\n\n  if (b.$__ != null) {\n    b = b._doc;\n  } else if (isMongooseObject(b)) {\n    b = b.toObject();\n  }\n\n  const ka = Object.keys(a);\n  const kb = Object.keys(b);\n  const kaLength = ka.length;\n\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (kaLength !== kb.length) {\n    return false;\n  }\n\n  // ~~~cheap key test\n  for (let i = kaLength - 1; i >= 0; i--) {\n    if (ka[i] !== kb[i]) {\n      return false;\n    }\n  }\n\n  // equivalent values for every corresponding key, and\n  // ~~~possibly expensive deep test\n  for (const key of ka) {\n    if (!deepEqual(a[key], b[key])) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Get the last element of an array\n * @param {Array} arr\n */\n\nexports.last = function(arr) {\n  if (arr.length > 0) {\n    return arr[arr.length - 1];\n  }\n  return void 0;\n};\n\n/*!\n * ignore\n */\n\nexports.promiseOrCallback = promiseOrCallback;\n\n/*!\n * ignore\n */\n\nexports.cloneArrays = function cloneArrays(arr) {\n  if (!Array.isArray(arr)) {\n    return arr;\n  }\n\n  return arr.map(el => exports.cloneArrays(el));\n};\n\n/*!\n * ignore\n */\n\nexports.omit = function omit(obj, keys) {\n  if (keys == null) {\n    return Object.assign({}, obj);\n  }\n  if (!Array.isArray(keys)) {\n    keys = [keys];\n  }\n\n  const ret = Object.assign({}, obj);\n  for (const key of keys) {\n    delete ret[key];\n  }\n  return ret;\n};\n\n/**\n * Merges `from` into `to` without overwriting existing properties.\n *\n * @param {Object} to\n * @param {Object} from\n * @param {Object} [options]\n * @param {String} [path]\n * @api private\n */\n\nexports.merge = function merge(to, from, options, path) {\n  options = options || {};\n\n  const keys = Object.keys(from);\n  let i = 0;\n  const len = keys.length;\n  let key;\n\n  if (from[trustedSymbol]) {\n    to[trustedSymbol] = from[trustedSymbol];\n  }\n\n  path = path || '';\n  const omitNested = options.omitNested || {};\n\n  while (i < len) {\n    key = keys[i++];\n    if (options.omit && options.omit[key]) {\n      continue;\n    }\n    if (omitNested[path]) {\n      continue;\n    }\n    if (specialProperties.has(key)) {\n      continue;\n    }\n    if (to[key] == null) {\n      to[key] = from[key];\n    } else if (exports.isObject(from[key])) {\n      if (!exports.isObject(to[key])) {\n        to[key] = {};\n      }\n      if (from[key] != null) {\n        // Skip merging schemas if we're creating a discriminator schema and\n        // base schema has a given path as a single nested but discriminator schema\n        // has the path as a document array, or vice versa (gh-9534)\n        if (options.isDiscriminatorSchemaMerge &&\n            (from[key].$isSingleNested && to[key].$isMongooseDocumentArray) ||\n            (from[key].$isMongooseDocumentArray && to[key].$isSingleNested)) {\n          continue;\n        } else if (from[key].instanceOfSchema) {\n          if (to[key].instanceOfSchema) {\n            schemaMerge(to[key], from[key].clone(), options.isDiscriminatorSchemaMerge);\n          } else {\n            to[key] = from[key].clone();\n          }\n          continue;\n        } else if (isBsonType(from[key], 'ObjectId')) {\n          to[key] = new ObjectId(from[key]);\n          continue;\n        }\n      }\n      merge(to[key], from[key], options, path ? path + '.' + key : key);\n    } else if (options.overwrite) {\n      to[key] = from[key];\n    }\n  }\n};\n\n/**\n * Applies toObject recursively.\n *\n * @param {Document|Array|Object} obj\n * @return {Object}\n * @api private\n */\n\nexports.toObject = function toObject(obj) {\n  Document || (Document = __webpack_require__(/*! ./document */ \"../backend/node_modules/mongoose/lib/document.js\"));\n  let ret;\n\n  if (obj == null) {\n    return obj;\n  }\n\n  if (obj instanceof Document) {\n    return obj.toObject();\n  }\n\n  if (Array.isArray(obj)) {\n    ret = [];\n\n    for (const doc of obj) {\n      ret.push(toObject(doc));\n    }\n\n    return ret;\n  }\n\n  if (exports.isPOJO(obj)) {\n    ret = {};\n\n    if (obj[trustedSymbol]) {\n      ret[trustedSymbol] = obj[trustedSymbol];\n    }\n\n    for (const k of Object.keys(obj)) {\n      if (specialProperties.has(k)) {\n        continue;\n      }\n      ret[k] = toObject(obj[k]);\n    }\n\n    return ret;\n  }\n\n  return obj;\n};\n\nexports.isObject = isObject;\n\n/**\n * Determines if `arg` is a plain old JavaScript object (POJO). Specifically,\n * `arg` must be an object but not an instance of any special class, like String,\n * ObjectId, etc.\n *\n * `Object.getPrototypeOf()` is part of ES5: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf\n *\n * @param {Object|Array|String|Function|RegExp|any} arg\n * @api private\n * @return {Boolean}\n */\n\nexports.isPOJO = __webpack_require__(/*! ./helpers/isPOJO */ \"../backend/node_modules/mongoose/lib/helpers/isPOJO.js\");\n\n/**\n * Determines if `arg` is an object that isn't an instance of a built-in value\n * class, like Array, Buffer, ObjectId, etc.\n * @param {Any} val\n */\n\nexports.isNonBuiltinObject = function isNonBuiltinObject(val) {\n  return typeof val === 'object' &&\n    !exports.isNativeObject(val) &&\n    !exports.isMongooseType(val) &&\n    !(val instanceof UUID) &&\n    val != null;\n};\n\n/**\n * Determines if `obj` is a built-in object like an array, date, boolean,\n * etc.\n * @param {Any} arg\n */\n\nexports.isNativeObject = function(arg) {\n  return Array.isArray(arg) ||\n    arg instanceof Date ||\n    arg instanceof Boolean ||\n    arg instanceof Number ||\n    arg instanceof String;\n};\n\n/**\n * Determines if `val` is an object that has no own keys\n * @param {Any} val\n */\n\nexports.isEmptyObject = function(val) {\n  return val != null &&\n    typeof val === 'object' &&\n    Object.keys(val).length === 0;\n};\n\n/**\n * Search if `obj` or any POJOs nested underneath `obj` has a property named\n * `key`\n * @param {Object} obj\n * @param {String} key\n */\n\nexports.hasKey = function hasKey(obj, key) {\n  const props = Object.keys(obj);\n  for (const prop of props) {\n    if (prop === key) {\n      return true;\n    }\n    if (exports.isPOJO(obj[prop]) && exports.hasKey(obj[prop], key)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * process.nextTick helper.\n *\n * Wraps `callback` in a try/catch + nextTick.\n *\n * node-mongodb-native has a habit of state corruption when an error is immediately thrown from within a collection callback.\n *\n * @param {Function} callback\n * @api private\n */\n\nexports.tick = function tick(callback) {\n  if (typeof callback !== 'function') {\n    return;\n  }\n  return function() {\n    try {\n      callback.apply(this, arguments);\n    } catch (err) {\n      // only nextTick on err to get out of\n      // the event loop and avoid state corruption.\n      immediate(function() {\n        throw err;\n      });\n    }\n  };\n};\n\n/**\n * Returns true if `v` is an object that can be serialized as a primitive in\n * MongoDB\n * @param {Any} v\n */\n\nexports.isMongooseType = function(v) {\n  return isBsonType(v, 'ObjectId') || isBsonType(v, 'Decimal128') || v instanceof Buffer;\n};\n\nexports.isMongooseObject = isMongooseObject;\n\n/**\n * Converts `expires` options of index objects to `expiresAfterSeconds` options for MongoDB.\n *\n * @param {Object} object\n * @api private\n */\n\nexports.expires = function expires(object) {\n  if (!(object && object.constructor.name === 'Object')) {\n    return;\n  }\n  if (!('expires' in object)) {\n    return;\n  }\n\n  object.expireAfterSeconds = (typeof object.expires !== 'string')\n    ? object.expires\n    : Math.round(ms(object.expires) / 1000);\n  delete object.expires;\n};\n\n/**\n * populate helper\n * @param {String} path\n * @param {String} select\n * @param {Model} model\n * @param {Object} match\n * @param {Object} options\n * @param {Any} subPopulate\n * @param {Boolean} justOne\n * @param {Boolean} count\n */\n\nexports.populate = function populate(path, select, model, match, options, subPopulate, justOne, count) {\n  // might have passed an object specifying all arguments\n  let obj = null;\n  if (arguments.length === 1) {\n    if (path instanceof PopulateOptions) {\n      // If reusing old populate docs, avoid reusing `_docs` because that may\n      // lead to bugs and memory leaks. See gh-11641\n      path._docs = [];\n      path._childDocs = [];\n      return [path];\n    }\n\n    if (Array.isArray(path)) {\n      const singles = makeSingles(path);\n      return singles.map(o => exports.populate(o)[0]);\n    }\n\n    if (exports.isObject(path)) {\n      obj = Object.assign({}, path);\n    } else {\n      obj = { path: path };\n    }\n  } else if (typeof model === 'object') {\n    obj = {\n      path: path,\n      select: select,\n      match: model,\n      options: match\n    };\n  } else {\n    obj = {\n      path: path,\n      select: select,\n      model: model,\n      match: match,\n      options: options,\n      populate: subPopulate,\n      justOne: justOne,\n      count: count\n    };\n  }\n\n  if (typeof obj.path !== 'string') {\n    throw new TypeError('utils.populate: invalid path. Expected string. Got typeof `' + typeof path + '`');\n  }\n\n  return _populateObj(obj);\n\n  // The order of select/conditions args is opposite Model.find but\n  // necessary to keep backward compatibility (select could be\n  // an array, string, or object literal).\n  function makeSingles(arr) {\n    const ret = [];\n    arr.forEach(function(obj) {\n      if (oneSpaceRE.test(obj.path)) {\n        const paths = obj.path.split(manySpaceRE);\n        paths.forEach(function(p) {\n          const copy = Object.assign({}, obj);\n          copy.path = p;\n          ret.push(copy);\n        });\n      } else {\n        ret.push(obj);\n      }\n    });\n\n    return ret;\n  }\n};\n\nfunction _populateObj(obj) {\n  if (Array.isArray(obj.populate)) {\n    const ret = [];\n    obj.populate.forEach(function(obj) {\n      if (oneSpaceRE.test(obj.path)) {\n        const copy = Object.assign({}, obj);\n        const paths = copy.path.split(manySpaceRE);\n        paths.forEach(function(p) {\n          copy.path = p;\n          ret.push(exports.populate(copy)[0]);\n        });\n      } else {\n        ret.push(exports.populate(obj)[0]);\n      }\n    });\n    obj.populate = exports.populate(ret);\n  } else if (obj.populate != null && typeof obj.populate === 'object') {\n    obj.populate = exports.populate(obj.populate);\n  }\n\n  const ret = [];\n  const paths = oneSpaceRE.test(obj.path) ? obj.path.split(manySpaceRE) : [obj.path];\n  if (obj.options != null) {\n    obj.options = clone(obj.options);\n  }\n\n  for (const path of paths) {\n    ret.push(new PopulateOptions(Object.assign({}, obj, { path: path })));\n  }\n\n  return ret;\n}\n\n/**\n * Return the value of `obj` at the given `path`.\n *\n * @param {String} path\n * @param {Object} obj\n * @param {Any} map\n */\n\nexports.getValue = function(path, obj, map) {\n  return mpath.get(path, obj, getValueLookup, map);\n};\n\n/*!\n * ignore\n */\n\nconst mapGetterOptions = Object.freeze({ getters: false });\n\nfunction getValueLookup(obj, part) {\n  let _from = obj?._doc || obj;\n  if (_from != null && _from.isMongooseArrayProxy) {\n    _from = _from.__array;\n  }\n  return _from instanceof Map ?\n    _from.get(part, mapGetterOptions) :\n    _from[part];\n}\n\n/**\n * Sets the value of `obj` at the given `path`.\n *\n * @param {String} path\n * @param {Anything} val\n * @param {Object} obj\n * @param {Any} map\n * @param {Any} _copying\n */\n\nexports.setValue = function(path, val, obj, map, _copying) {\n  mpath.set(path, val, obj, '_doc', map, _copying);\n};\n\n/**\n * Returns an array of values from object `o`.\n *\n * @param {Object} o\n * @return {Array}\n * @api private\n */\n\nexports.object = {};\nexports.object.vals = function vals(o) {\n  const keys = Object.keys(o);\n  let i = keys.length;\n  const ret = [];\n\n  while (i--) {\n    ret.push(o[keys[i]]);\n  }\n\n  return ret;\n};\n\nconst hop = Object.prototype.hasOwnProperty;\n\n/**\n * Safer helper for hasOwnProperty checks\n *\n * @param {Object} obj\n * @param {String} prop\n */\n\nexports.object.hasOwnProperty = function(obj, prop) {\n  return hop.call(obj, prop);\n};\n\n/**\n * Determine if `val` is null or undefined\n *\n * @param {Any} val\n * @return {Boolean}\n */\n\nexports.isNullOrUndefined = function(val) {\n  return val === null || val === undefined;\n};\n\n/*!\n * ignore\n */\n\nexports.array = {};\n\n/**\n * Flattens an array.\n *\n * [ 1, [ 2, 3, [4] ]] -> [1,2,3,4]\n *\n * @param {Array} arr\n * @param {Function} [filter] If passed, will be invoked with each item in the array. If `filter` returns a falsy value, the item will not be included in the results.\n * @param {Array} ret\n * @return {Array}\n * @api private\n */\n\nexports.array.flatten = function flatten(arr, filter, ret) {\n  ret || (ret = []);\n\n  arr.forEach(function(item) {\n    if (Array.isArray(item)) {\n      flatten(item, filter, ret);\n    } else {\n      if (!filter || filter(item)) {\n        ret.push(item);\n      }\n    }\n  });\n\n  return ret;\n};\n\n/*!\n * ignore\n */\n\nconst _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nexports.hasUserDefinedProperty = function(obj, key) {\n  if (obj == null) {\n    return false;\n  }\n\n  if (Array.isArray(key)) {\n    for (const k of key) {\n      if (exports.hasUserDefinedProperty(obj, k)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  if (_hasOwnProperty.call(obj, key)) {\n    return true;\n  }\n  if (typeof obj === 'object' && key in obj) {\n    const v = obj[key];\n    return v !== Object.prototype[key] && v !== Array.prototype[key];\n  }\n\n  return false;\n};\n\n/*!\n * ignore\n */\n\nconst MAX_ARRAY_INDEX = Math.pow(2, 32) - 1;\n\nexports.isArrayIndex = function(val) {\n  if (typeof val === 'number') {\n    return val >= 0 && val <= MAX_ARRAY_INDEX;\n  }\n  if (typeof val === 'string') {\n    if (!/^\\d+$/.test(val)) {\n      return false;\n    }\n    val = +val;\n    return val >= 0 && val <= MAX_ARRAY_INDEX;\n  }\n\n  return false;\n};\n\n/**\n * Removes duplicate values from an array\n *\n * [1, 2, 3, 3, 5] => [1, 2, 3, 5]\n * [ ObjectId(\"550988ba0c19d57f697dc45e\"), ObjectId(\"550988ba0c19d57f697dc45e\") ]\n *    => [ObjectId(\"550988ba0c19d57f697dc45e\")]\n *\n * @param {Array} arr\n * @return {Array}\n * @api private\n */\n\nexports.array.unique = function(arr) {\n  const primitives = new Set();\n  const ids = new Set();\n  const ret = [];\n\n  for (const item of arr) {\n    if (typeof item === 'number' || typeof item === 'string' || item == null) {\n      if (primitives.has(item)) {\n        continue;\n      }\n      ret.push(item);\n      primitives.add(item);\n    } else if (isBsonType(item, 'ObjectId')) {\n      if (ids.has(item.toString())) {\n        continue;\n      }\n      ret.push(item);\n      ids.add(item.toString());\n    } else {\n      ret.push(item);\n    }\n  }\n\n  return ret;\n};\n\nexports.buffer = {};\n\n/**\n * Determines if two buffers are equal.\n *\n * @param {Buffer} a\n * @param {Object} b\n */\n\nexports.buffer.areEqual = function(a, b) {\n  if (!Buffer.isBuffer(a)) {\n    return false;\n  }\n  if (!Buffer.isBuffer(b)) {\n    return false;\n  }\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0, len = a.length; i < len; ++i) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexports.getFunctionName = getFunctionName;\n\n/**\n * Decorate buffers\n * @param {Object} destination\n * @param {Object} source\n */\n\nexports.decorate = function(destination, source) {\n  for (const key in source) {\n    if (specialProperties.has(key)) {\n      continue;\n    }\n    destination[key] = source[key];\n  }\n};\n\n/**\n * merges to with a copy of from\n *\n * @param {Object} to\n * @param {Object} fromObj\n * @api private\n */\n\nexports.mergeClone = function(to, fromObj) {\n  if (isMongooseObject(fromObj)) {\n    fromObj = fromObj.toObject({\n      transform: false,\n      virtuals: false,\n      depopulate: true,\n      getters: false,\n      flattenDecimals: false\n    });\n  }\n  const keys = Object.keys(fromObj);\n  const len = keys.length;\n  let i = 0;\n  let key;\n\n  while (i < len) {\n    key = keys[i++];\n    if (specialProperties.has(key)) {\n      continue;\n    }\n    if (typeof to[key] === 'undefined') {\n      to[key] = clone(fromObj[key], {\n        transform: false,\n        virtuals: false,\n        depopulate: true,\n        getters: false,\n        flattenDecimals: false\n      });\n    } else {\n      let val = fromObj[key];\n      if (val != null && val.valueOf && !(val instanceof Date)) {\n        val = val.valueOf();\n      }\n      if (exports.isObject(val)) {\n        let obj = val;\n        if (isMongooseObject(val) && !val.isMongooseBuffer) {\n          obj = obj.toObject({\n            transform: false,\n            virtuals: false,\n            depopulate: true,\n            getters: false,\n            flattenDecimals: false\n          });\n        }\n        if (val.isMongooseBuffer) {\n          obj = Buffer.from(obj);\n        }\n        exports.mergeClone(to[key], obj);\n      } else {\n        to[key] = clone(val, {\n          flattenDecimals: false\n        });\n      }\n    }\n  }\n};\n\n/**\n * Executes a function on each element of an array (like _.each)\n *\n * @param {Array} arr\n * @param {Function} fn\n * @api private\n */\n\nexports.each = function(arr, fn) {\n  for (const item of arr) {\n    fn(item);\n  }\n};\n\n/**\n * Rename an object key, while preserving its position in the object\n *\n * @param {Object} oldObj\n * @param {String|Number} oldKey\n * @param {String|Number} newKey\n * @api private\n */\nexports.renameObjKey = function(oldObj, oldKey, newKey) {\n  const keys = Object.keys(oldObj);\n  return keys.reduce(\n    (acc, val) => {\n      if (val === oldKey) {\n        acc[newKey] = oldObj[oldKey];\n      } else {\n        acc[val] = oldObj[val];\n      }\n      return acc;\n    },\n    {}\n  );\n};\n\n/*!\n * ignore\n */\n\nexports.getOption = function(name) {\n  const sources = Array.prototype.slice.call(arguments, 1);\n\n  for (const source of sources) {\n    if (source == null) {\n      continue;\n    }\n    if (source[name] != null) {\n      return source[name];\n    }\n  }\n\n  return null;\n};\n\n/*!\n * ignore\n */\n\nexports.noop = function() {};\n\nexports.errorToPOJO = function errorToPOJO(error) {\n  const isError = error instanceof Error;\n  if (!isError) {\n    throw new Error('`error` must be `instanceof Error`.');\n  }\n\n  const ret = {};\n  for (const properyName of Object.getOwnPropertyNames(error)) {\n    ret[properyName] = error[properyName];\n  }\n  return ret;\n};\n\n/*!\n * ignore\n */\n\nexports.warn = function warn(message) {\n  return process.emitWarning(message, { code: 'MONGOOSE' });\n};\n\n\nexports.injectTimestampsOption = function injectTimestampsOption(writeOperation, timestampsOption) {\n  if (timestampsOption == null) {\n    return;\n  }\n  writeOperation.timestamps = timestampsOption;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLG1GQUFvQjtBQUNqQyxXQUFXLG1CQUFPLENBQUMscUVBQUk7QUFDdkIsY0FBYyxtQkFBTyxDQUFDLHFEQUFPO0FBQzdCLGlCQUFpQixtQkFBTyxDQUFDLGdGQUFrQjtBQUMzQyx3QkFBd0IsbUJBQU8sQ0FBQyxrR0FBMkI7QUFDM0QsY0FBYyxtQkFBTyxDQUFDLDhFQUFpQjtBQUN2QyxrQkFBa0IsbUJBQU8sQ0FBQyxzRkFBcUI7QUFDL0MsaUJBQWlCLG1CQUFPLENBQUMsb0ZBQW9CO0FBQzdDLHdCQUF3QixtQkFBTyxDQUFDLDBHQUErQjtBQUMvRCxnQ0FBZ0MsbUJBQU8sQ0FBQywwSUFBK0M7QUFDdkYsbUJBQW1CLG1CQUFPLENBQUMsd0ZBQXNCO0FBQ2pELHdCQUF3QixtQkFBTyxDQUFDLGtHQUEyQjtBQUMzRCx5QkFBeUIsbUJBQU8sQ0FBQyxvR0FBNEI7QUFDN0QsMEJBQTBCLG1CQUFPLENBQUMsc0dBQTZCO0FBQy9ELG9CQUFvQixtQkFBTyxDQUFDLDRGQUF3QjtBQUNwRCwwQkFBMEIsbUJBQU8sQ0FBQyxzR0FBNkI7QUFDL0QsUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLDhGQUF5Qjs7QUFFM0Q7O0FBRUEseUJBQXlCOztBQUV6Qix1QkFBdUI7QUFDdkIsK0JBQStCO0FBQy9CLDZCQUE2QjtBQUM3QixxQ0FBcUM7O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FB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Li4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3V0aWxzLmpzP2RlZTgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgVVVJRCA9IHJlcXVpcmUoJ2Jzb24nKS5VVUlEO1xuY29uc3QgbXMgPSByZXF1aXJlKCdtcycpO1xuY29uc3QgbXBhdGggPSByZXF1aXJlKCdtcGF0aCcpO1xuY29uc3QgT2JqZWN0SWQgPSByZXF1aXJlKCcuL3R5cGVzL29iamVjdGlkJyk7XG5jb25zdCBQb3B1bGF0ZU9wdGlvbnMgPSByZXF1aXJlKCcuL29wdGlvbnMvcG9wdWxhdGVPcHRpb25zJyk7XG5jb25zdCBjbG9uZSA9IHJlcXVpcmUoJy4vaGVscGVycy9jbG9uZScpO1xuY29uc3QgaW1tZWRpYXRlID0gcmVxdWlyZSgnLi9oZWxwZXJzL2ltbWVkaWF0ZScpO1xuY29uc3QgaXNPYmplY3QgPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNPYmplY3QnKTtcbmNvbnN0IGlzTW9uZ29vc2VBcnJheSA9IHJlcXVpcmUoJy4vdHlwZXMvYXJyYXkvaXNNb25nb29zZUFycmF5Jyk7XG5jb25zdCBpc01vbmdvb3NlRG9jdW1lbnRBcnJheSA9IHJlcXVpcmUoJy4vdHlwZXMvZG9jdW1lbnRBcnJheS9pc01vbmdvb3NlRG9jdW1lbnRBcnJheScpO1xuY29uc3QgaXNCc29uVHlwZSA9IHJlcXVpcmUoJy4vaGVscGVycy9pc0Jzb25UeXBlJyk7XG5jb25zdCBnZXRGdW5jdGlvbk5hbWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvZ2V0RnVuY3Rpb25OYW1lJyk7XG5jb25zdCBpc01vbmdvb3NlT2JqZWN0ID0gcmVxdWlyZSgnLi9oZWxwZXJzL2lzTW9uZ29vc2VPYmplY3QnKTtcbmNvbnN0IHByb21pc2VPckNhbGxiYWNrID0gcmVxdWlyZSgnLi9oZWxwZXJzL3Byb21pc2VPckNhbGxiYWNrJyk7XG5jb25zdCBzY2hlbWFNZXJnZSA9IHJlcXVpcmUoJy4vaGVscGVycy9zY2hlbWEvbWVyZ2UnKTtcbmNvbnN0IHNwZWNpYWxQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NwZWNpYWxQcm9wZXJ0aWVzJyk7XG5jb25zdCB7IHRydXN0ZWRTeW1ib2wgfSA9IHJlcXVpcmUoJy4vaGVscGVycy9xdWVyeS90cnVzdGVkJyk7XG5cbmxldCBEb2N1bWVudDtcblxuZXhwb3J0cy5zcGVjaWFsUHJvcGVydGllcyA9IHNwZWNpYWxQcm9wZXJ0aWVzO1xuXG5leHBvcnRzLmlzTW9uZ29vc2VBcnJheSA9IGlzTW9uZ29vc2VBcnJheS5pc01vbmdvb3NlQXJyYXk7XG5leHBvcnRzLmlzTW9uZ29vc2VEb2N1bWVudEFycmF5ID0gaXNNb25nb29zZURvY3VtZW50QXJyYXkuaXNNb25nb29zZURvY3VtZW50QXJyYXk7XG5leHBvcnRzLnJlZ2lzdGVyTW9uZ29vc2VBcnJheSA9IGlzTW9uZ29vc2VBcnJheS5yZWdpc3Rlck1vbmdvb3NlQXJyYXk7XG5leHBvcnRzLnJlZ2lzdGVyTW9uZ29vc2VEb2N1bWVudEFycmF5ID0gaXNNb25nb29zZURvY3VtZW50QXJyYXkucmVnaXN0ZXJNb25nb29zZURvY3VtZW50QXJyYXk7XG5cbmNvbnN0IG9uZVNwYWNlUkUgPSAvXFxzLztcbmNvbnN0IG1hbnlTcGFjZVJFID0gL1xccysvO1xuXG4vKipcbiAqIFByb2R1Y2VzIGEgY29sbGVjdGlvbiBuYW1lIGZyb20gbW9kZWwgYG5hbWVgLiBCeSBkZWZhdWx0LCBqdXN0IHJldHVybnNcbiAqIHRoZSBtb2RlbCBuYW1lXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgYSBtb2RlbCBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwbHVyYWxpemUgZnVuY3Rpb24gdGhhdCBwbHVyYWxpemVzIHRoZSBjb2xsZWN0aW9uIG5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ30gYSBjb2xsZWN0aW9uIG5hbWVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMudG9Db2xsZWN0aW9uTmFtZSA9IGZ1bmN0aW9uKG5hbWUsIHBsdXJhbGl6ZSkge1xuICBpZiAobmFtZSA9PT0gJ3N5c3RlbS5wcm9maWxlJykge1xuICAgIHJldHVybiBuYW1lO1xuICB9XG4gIGlmIChuYW1lID09PSAnc3lzdGVtLmluZGV4ZXMnKSB7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBwbHVyYWxpemUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gcGx1cmFsaXplKG5hbWUpO1xuICB9XG4gIHJldHVybiBuYW1lO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGBhYCBhbmQgYGJgIGFyZSBkZWVwIGVxdWFsLlxuICpcbiAqIE1vZGlmaWVkIGZyb20gbm9kZS9saWIvYXNzZXJ0LmpzXG4gKlxuICogQHBhcmFtIHthbnl9IGEgYSB2YWx1ZSB0byBjb21wYXJlIHRvIGBiYFxuICogQHBhcmFtIHthbnl9IGIgYSB2YWx1ZSB0byBjb21wYXJlIHRvIGBhYFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZGVlcEVxdWFsID0gZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYSAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIH1cblxuICBpZiAoYSBpbnN0YW5jZW9mIERhdGUgJiYgYiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpO1xuICB9XG5cbiAgaWYgKChpc0Jzb25UeXBlKGEsICdPYmplY3RJZCcpICYmIGlzQnNvblR5cGUoYiwgJ09iamVjdElkJykpIHx8XG4gICAgICAoaXNCc29uVHlwZShhLCAnRGVjaW1hbDEyOCcpICYmIGlzQnNvblR5cGUoYiwgJ0RlY2ltYWwxMjgnKSkpIHtcbiAgICByZXR1cm4gYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCk7XG4gIH1cblxuICBpZiAoYSBpbnN0YW5jZW9mIFJlZ0V4cCAmJiBiIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIGEuc291cmNlID09PSBiLnNvdXJjZSAmJlxuICAgICAgICBhLmlnbm9yZUNhc2UgPT09IGIuaWdub3JlQ2FzZSAmJlxuICAgICAgICBhLm11bHRpbGluZSA9PT0gYi5tdWx0aWxpbmUgJiZcbiAgICAgICAgYS5nbG9iYWwgPT09IGIuZ2xvYmFsICYmXG4gICAgICAgIGEuZG90QWxsID09PSBiLmRvdEFsbCAmJlxuICAgICAgICBhLnVuaWNvZGUgPT09IGIudW5pY29kZSAmJlxuICAgICAgICBhLnN0aWNreSA9PT0gYi5zdGlja3kgJiZcbiAgICAgICAgYS5oYXNJbmRpY2VzID09PSBiLmhhc0luZGljZXM7XG4gIH1cblxuICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChhLnByb3RvdHlwZSAhPT0gYi5wcm90b3R5cGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoYSBpbnN0YW5jZW9mIE1hcCB8fCBiIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgaWYgKCEoYSBpbnN0YW5jZW9mIE1hcCkgfHwgIShiIGluc3RhbmNlb2YgTWFwKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZGVlcEVxdWFsKEFycmF5LmZyb20oYS5rZXlzKCkpLCBBcnJheS5mcm9tKGIua2V5cygpKSkgJiZcbiAgICAgIGRlZXBFcXVhbChBcnJheS5mcm9tKGEudmFsdWVzKCkpLCBBcnJheS5mcm9tKGIudmFsdWVzKCkpKTtcbiAgfVxuXG4gIC8vIEhhbmRsZSBNb25nb29zZU51bWJlcnNcbiAgaWYgKGEgaW5zdGFuY2VvZiBOdW1iZXIgJiYgYiBpbnN0YW5jZW9mIE51bWJlcikge1xuICAgIHJldHVybiBhLnZhbHVlT2YoKSA9PT0gYi52YWx1ZU9mKCk7XG4gIH1cblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGEpKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuYnVmZmVyLmFyZUVxdWFsKGEsIGIpO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoYSkgfHwgQXJyYXkuaXNBcnJheShiKSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhKSB8fCAhQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBsZW4gPSBhLmxlbmd0aDtcbiAgICBpZiAobGVuICE9PSBiLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBpZiAoIWRlZXBFcXVhbChhW2ldLCBiW2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGEuJF9fICE9IG51bGwpIHtcbiAgICBhID0gYS5fZG9jO1xuICB9IGVsc2UgaWYgKGlzTW9uZ29vc2VPYmplY3QoYSkpIHtcbiAgICBhID0gYS50b09iamVjdCgpO1xuICB9XG5cbiAgaWYgKGIuJF9fICE9IG51bGwpIHtcbiAgICBiID0gYi5fZG9jO1xuICB9IGVsc2UgaWYgKGlzTW9uZ29vc2VPYmplY3QoYikpIHtcbiAgICBiID0gYi50b09iamVjdCgpO1xuICB9XG5cbiAgY29uc3Qga2EgPSBPYmplY3Qua2V5cyhhKTtcbiAgY29uc3Qga2IgPSBPYmplY3Qua2V5cyhiKTtcbiAgY29uc3Qga2FMZW5ndGggPSBrYS5sZW5ndGg7XG5cbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthTGVuZ3RoICE9PSBrYi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyB+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGxldCBpID0ga2FMZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPT0ga2JbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvLyB+fn5wb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0XG4gIGZvciAoY29uc3Qga2V5IG9mIGthKSB7XG4gICAgaWYgKCFkZWVwRXF1YWwoYVtrZXldLCBiW2tleV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIGFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqL1xuXG5leHBvcnRzLmxhc3QgPSBmdW5jdGlvbihhcnIpIHtcbiAgaWYgKGFyci5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGFyclthcnIubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZXhwb3J0cy5wcm9taXNlT3JDYWxsYmFjayA9IHByb21pc2VPckNhbGxiYWNrO1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmV4cG9ydHMuY2xvbmVBcnJheXMgPSBmdW5jdGlvbiBjbG9uZUFycmF5cyhhcnIpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICByZXR1cm4gYXJyO1xuICB9XG5cbiAgcmV0dXJuIGFyci5tYXAoZWwgPT4gZXhwb3J0cy5jbG9uZUFycmF5cyhlbCkpO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5leHBvcnRzLm9taXQgPSBmdW5jdGlvbiBvbWl0KG9iaiwga2V5cykge1xuICBpZiAoa2V5cyA9PSBudWxsKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG9iaik7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KGtleXMpKSB7XG4gICAga2V5cyA9IFtrZXlzXTtcbiAgfVxuXG4gIGNvbnN0IHJldCA9IE9iamVjdC5hc3NpZ24oe30sIG9iaik7XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBkZWxldGUgcmV0W2tleV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogTWVyZ2VzIGBmcm9tYCBpbnRvIGB0b2Agd2l0aG91dCBvdmVyd3JpdGluZyBleGlzdGluZyBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b1xuICogQHBhcmFtIHtPYmplY3R9IGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGF0aF1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMubWVyZ2UgPSBmdW5jdGlvbiBtZXJnZSh0bywgZnJvbSwgb3B0aW9ucywgcGF0aCkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZnJvbSk7XG4gIGxldCBpID0gMDtcbiAgY29uc3QgbGVuID0ga2V5cy5sZW5ndGg7XG4gIGxldCBrZXk7XG5cbiAgaWYgKGZyb21bdHJ1c3RlZFN5bWJvbF0pIHtcbiAgICB0b1t0cnVzdGVkU3ltYm9sXSA9IGZyb21bdHJ1c3RlZFN5bWJvbF07XG4gIH1cblxuICBwYXRoID0gcGF0aCB8fCAnJztcbiAgY29uc3Qgb21pdE5lc3RlZCA9IG9wdGlvbnMub21pdE5lc3RlZCB8fCB7fTtcblxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGtleSA9IGtleXNbaSsrXTtcbiAgICBpZiAob3B0aW9ucy5vbWl0ICYmIG9wdGlvbnMub21pdFtrZXldKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG9taXROZXN0ZWRbcGF0aF0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoc3BlY2lhbFByb3BlcnRpZXMuaGFzKGtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodG9ba2V5XSA9PSBudWxsKSB7XG4gICAgICB0b1trZXldID0gZnJvbVtrZXldO1xuICAgIH0gZWxzZSBpZiAoZXhwb3J0cy5pc09iamVjdChmcm9tW2tleV0pKSB7XG4gICAgICBpZiAoIWV4cG9ydHMuaXNPYmplY3QodG9ba2V5XSkpIHtcbiAgICAgICAgdG9ba2V5XSA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKGZyb21ba2V5XSAhPSBudWxsKSB7XG4gICAgICAgIC8vIFNraXAgbWVyZ2luZyBzY2hlbWFzIGlmIHdlJ3JlIGNyZWF0aW5nIGEgZGlzY3JpbWluYXRvciBzY2hlbWEgYW5kXG4gICAgICAgIC8vIGJhc2Ugc2NoZW1hIGhhcyBhIGdpdmVuIHBhdGggYXMgYSBzaW5nbGUgbmVzdGVkIGJ1dCBkaXNjcmltaW5hdG9yIHNjaGVtYVxuICAgICAgICAvLyBoYXMgdGhlIHBhdGggYXMgYSBkb2N1bWVudCBhcnJheSwgb3IgdmljZSB2ZXJzYSAoZ2gtOTUzNClcbiAgICAgICAgaWYgKG9wdGlvbnMuaXNEaXNjcmltaW5hdG9yU2NoZW1hTWVyZ2UgJiZcbiAgICAgICAgICAgIChmcm9tW2tleV0uJGlzU2luZ2xlTmVzdGVkICYmIHRvW2tleV0uJGlzTW9uZ29vc2VEb2N1bWVudEFycmF5KSB8fFxuICAgICAgICAgICAgKGZyb21ba2V5XS4kaXNNb25nb29zZURvY3VtZW50QXJyYXkgJiYgdG9ba2V5XS4kaXNTaW5nbGVOZXN0ZWQpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZnJvbVtrZXldLmluc3RhbmNlT2ZTY2hlbWEpIHtcbiAgICAgICAgICBpZiAodG9ba2V5XS5pbnN0YW5jZU9mU2NoZW1hKSB7XG4gICAgICAgICAgICBzY2hlbWFNZXJnZSh0b1trZXldLCBmcm9tW2tleV0uY2xvbmUoKSwgb3B0aW9ucy5pc0Rpc2NyaW1pbmF0b3JTY2hlbWFNZXJnZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvW2tleV0gPSBmcm9tW2tleV0uY2xvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNCc29uVHlwZShmcm9tW2tleV0sICdPYmplY3RJZCcpKSB7XG4gICAgICAgICAgdG9ba2V5XSA9IG5ldyBPYmplY3RJZChmcm9tW2tleV0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtZXJnZSh0b1trZXldLCBmcm9tW2tleV0sIG9wdGlvbnMsIHBhdGggPyBwYXRoICsgJy4nICsga2V5IDoga2V5KTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMub3ZlcndyaXRlKSB7XG4gICAgICB0b1trZXldID0gZnJvbVtrZXldO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBBcHBsaWVzIHRvT2JqZWN0IHJlY3Vyc2l2ZWx5LlxuICpcbiAqIEBwYXJhbSB7RG9jdW1lbnR8QXJyYXl8T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChvYmopIHtcbiAgRG9jdW1lbnQgfHwgKERvY3VtZW50ID0gcmVxdWlyZSgnLi9kb2N1bWVudCcpKTtcbiAgbGV0IHJldDtcblxuICBpZiAob2JqID09IG51bGwpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgaWYgKG9iaiBpbnN0YW5jZW9mIERvY3VtZW50KSB7XG4gICAgcmV0dXJuIG9iai50b09iamVjdCgpO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIHJldCA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBkb2Mgb2Ygb2JqKSB7XG4gICAgICByZXQucHVzaCh0b09iamVjdChkb2MpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgaWYgKGV4cG9ydHMuaXNQT0pPKG9iaikpIHtcbiAgICByZXQgPSB7fTtcblxuICAgIGlmIChvYmpbdHJ1c3RlZFN5bWJvbF0pIHtcbiAgICAgIHJldFt0cnVzdGVkU3ltYm9sXSA9IG9ialt0cnVzdGVkU3ltYm9sXTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXMob2JqKSkge1xuICAgICAgaWYgKHNwZWNpYWxQcm9wZXJ0aWVzLmhhcyhrKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJldFtrXSA9IHRvT2JqZWN0KG9ialtrXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBgYXJnYCBpcyBhIHBsYWluIG9sZCBKYXZhU2NyaXB0IG9iamVjdCAoUE9KTykuIFNwZWNpZmljYWxseSxcbiAqIGBhcmdgIG11c3QgYmUgYW4gb2JqZWN0IGJ1dCBub3QgYW4gaW5zdGFuY2Ugb2YgYW55IHNwZWNpYWwgY2xhc3MsIGxpa2UgU3RyaW5nLFxuICogT2JqZWN0SWQsIGV0Yy5cbiAqXG4gKiBgT2JqZWN0LmdldFByb3RvdHlwZU9mKClgIGlzIHBhcnQgb2YgRVM1OiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvZ2V0UHJvdG90eXBlT2ZcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheXxTdHJpbmd8RnVuY3Rpb258UmVnRXhwfGFueX0gYXJnXG4gKiBAYXBpIHByaXZhdGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZXhwb3J0cy5pc1BPSk8gPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNQT0pPJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBgYXJnYCBpcyBhbiBvYmplY3QgdGhhdCBpc24ndCBhbiBpbnN0YW5jZSBvZiBhIGJ1aWx0LWluIHZhbHVlXG4gKiBjbGFzcywgbGlrZSBBcnJheSwgQnVmZmVyLCBPYmplY3RJZCwgZXRjLlxuICogQHBhcmFtIHtBbnl9IHZhbFxuICovXG5cbmV4cG9ydHMuaXNOb25CdWlsdGluT2JqZWN0ID0gZnVuY3Rpb24gaXNOb25CdWlsdGluT2JqZWN0KHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiZcbiAgICAhZXhwb3J0cy5pc05hdGl2ZU9iamVjdCh2YWwpICYmXG4gICAgIWV4cG9ydHMuaXNNb25nb29zZVR5cGUodmFsKSAmJlxuICAgICEodmFsIGluc3RhbmNlb2YgVVVJRCkgJiZcbiAgICB2YWwgIT0gbnVsbDtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBgb2JqYCBpcyBhIGJ1aWx0LWluIG9iamVjdCBsaWtlIGFuIGFycmF5LCBkYXRlLCBib29sZWFuLFxuICogZXRjLlxuICogQHBhcmFtIHtBbnl9IGFyZ1xuICovXG5cbmV4cG9ydHMuaXNOYXRpdmVPYmplY3QgPSBmdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKSB8fFxuICAgIGFyZyBpbnN0YW5jZW9mIERhdGUgfHxcbiAgICBhcmcgaW5zdGFuY2VvZiBCb29sZWFuIHx8XG4gICAgYXJnIGluc3RhbmNlb2YgTnVtYmVyIHx8XG4gICAgYXJnIGluc3RhbmNlb2YgU3RyaW5nO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGB2YWxgIGlzIGFuIG9iamVjdCB0aGF0IGhhcyBubyBvd24ga2V5c1xuICogQHBhcmFtIHtBbnl9IHZhbFxuICovXG5cbmV4cG9ydHMuaXNFbXB0eU9iamVjdCA9IGZ1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdmFsICE9IG51bGwgJiZcbiAgICB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJlxuICAgIE9iamVjdC5rZXlzKHZhbCkubGVuZ3RoID09PSAwO1xufTtcblxuLyoqXG4gKiBTZWFyY2ggaWYgYG9iamAgb3IgYW55IFBPSk9zIG5lc3RlZCB1bmRlcm5lYXRoIGBvYmpgIGhhcyBhIHByb3BlcnR5IG5hbWVkXG4gKiBga2V5YFxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICovXG5cbmV4cG9ydHMuaGFzS2V5ID0gZnVuY3Rpb24gaGFzS2V5KG9iaiwga2V5KSB7XG4gIGNvbnN0IHByb3BzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yIChjb25zdCBwcm9wIG9mIHByb3BzKSB7XG4gICAgaWYgKHByb3AgPT09IGtleSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChleHBvcnRzLmlzUE9KTyhvYmpbcHJvcF0pICYmIGV4cG9ydHMuaGFzS2V5KG9ialtwcm9wXSwga2V5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogcHJvY2Vzcy5uZXh0VGljayBoZWxwZXIuXG4gKlxuICogV3JhcHMgYGNhbGxiYWNrYCBpbiBhIHRyeS9jYXRjaCArIG5leHRUaWNrLlxuICpcbiAqIG5vZGUtbW9uZ29kYi1uYXRpdmUgaGFzIGEgaGFiaXQgb2Ygc3RhdGUgY29ycnVwdGlvbiB3aGVuIGFuIGVycm9yIGlzIGltbWVkaWF0ZWx5IHRocm93biBmcm9tIHdpdGhpbiBhIGNvbGxlY3Rpb24gY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMudGljayA9IGZ1bmN0aW9uIHRpY2soY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBvbmx5IG5leHRUaWNrIG9uIGVyciB0byBnZXQgb3V0IG9mXG4gICAgICAvLyB0aGUgZXZlbnQgbG9vcCBhbmQgYXZvaWQgc3RhdGUgY29ycnVwdGlvbi5cbiAgICAgIGltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYHZgIGlzIGFuIG9iamVjdCB0aGF0IGNhbiBiZSBzZXJpYWxpemVkIGFzIGEgcHJpbWl0aXZlIGluXG4gKiBNb25nb0RCXG4gKiBAcGFyYW0ge0FueX0gdlxuICovXG5cbmV4cG9ydHMuaXNNb25nb29zZVR5cGUgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiBpc0Jzb25UeXBlKHYsICdPYmplY3RJZCcpIHx8IGlzQnNvblR5cGUodiwgJ0RlY2ltYWwxMjgnKSB8fCB2IGluc3RhbmNlb2YgQnVmZmVyO1xufTtcblxuZXhwb3J0cy5pc01vbmdvb3NlT2JqZWN0ID0gaXNNb25nb29zZU9iamVjdDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgZXhwaXJlc2Agb3B0aW9ucyBvZiBpbmRleCBvYmplY3RzIHRvIGBleHBpcmVzQWZ0ZXJTZWNvbmRzYCBvcHRpb25zIGZvciBNb25nb0RCLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZXhwaXJlcyA9IGZ1bmN0aW9uIGV4cGlyZXMob2JqZWN0KSB7XG4gIGlmICghKG9iamVjdCAmJiBvYmplY3QuY29uc3RydWN0b3IubmFtZSA9PT0gJ09iamVjdCcpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghKCdleHBpcmVzJyBpbiBvYmplY3QpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb2JqZWN0LmV4cGlyZUFmdGVyU2Vjb25kcyA9ICh0eXBlb2Ygb2JqZWN0LmV4cGlyZXMgIT09ICdzdHJpbmcnKVxuICAgID8gb2JqZWN0LmV4cGlyZXNcbiAgICA6IE1hdGgucm91bmQobXMob2JqZWN0LmV4cGlyZXMpIC8gMTAwMCk7XG4gIGRlbGV0ZSBvYmplY3QuZXhwaXJlcztcbn07XG5cbi8qKlxuICogcG9wdWxhdGUgaGVscGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdFxuICogQHBhcmFtIHtNb2RlbH0gbW9kZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXRjaFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7QW55fSBzdWJQb3B1bGF0ZVxuICogQHBhcmFtIHtCb29sZWFufSBqdXN0T25lXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNvdW50XG4gKi9cblxuZXhwb3J0cy5wb3B1bGF0ZSA9IGZ1bmN0aW9uIHBvcHVsYXRlKHBhdGgsIHNlbGVjdCwgbW9kZWwsIG1hdGNoLCBvcHRpb25zLCBzdWJQb3B1bGF0ZSwganVzdE9uZSwgY291bnQpIHtcbiAgLy8gbWlnaHQgaGF2ZSBwYXNzZWQgYW4gb2JqZWN0IHNwZWNpZnlpbmcgYWxsIGFyZ3VtZW50c1xuICBsZXQgb2JqID0gbnVsbDtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAocGF0aCBpbnN0YW5jZW9mIFBvcHVsYXRlT3B0aW9ucykge1xuICAgICAgLy8gSWYgcmV1c2luZyBvbGQgcG9wdWxhdGUgZG9jcywgYXZvaWQgcmV1c2luZyBgX2RvY3NgIGJlY2F1c2UgdGhhdCBtYXlcbiAgICAgIC8vIGxlYWQgdG8gYnVncyBhbmQgbWVtb3J5IGxlYWtzLiBTZWUgZ2gtMTE2NDFcbiAgICAgIHBhdGguX2RvY3MgPSBbXTtcbiAgICAgIHBhdGguX2NoaWxkRG9jcyA9IFtdO1xuICAgICAgcmV0dXJuIFtwYXRoXTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgICAgY29uc3Qgc2luZ2xlcyA9IG1ha2VTaW5nbGVzKHBhdGgpO1xuICAgICAgcmV0dXJuIHNpbmdsZXMubWFwKG8gPT4gZXhwb3J0cy5wb3B1bGF0ZShvKVswXSk7XG4gICAgfVxuXG4gICAgaWYgKGV4cG9ydHMuaXNPYmplY3QocGF0aCkpIHtcbiAgICAgIG9iaiA9IE9iamVjdC5hc3NpZ24oe30sIHBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmogPSB7IHBhdGg6IHBhdGggfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZGVsID09PSAnb2JqZWN0Jykge1xuICAgIG9iaiA9IHtcbiAgICAgIHBhdGg6IHBhdGgsXG4gICAgICBzZWxlY3Q6IHNlbGVjdCxcbiAgICAgIG1hdGNoOiBtb2RlbCxcbiAgICAgIG9wdGlvbnM6IG1hdGNoXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBvYmogPSB7XG4gICAgICBwYXRoOiBwYXRoLFxuICAgICAgc2VsZWN0OiBzZWxlY3QsXG4gICAgICBtb2RlbDogbW9kZWwsXG4gICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgcG9wdWxhdGU6IHN1YlBvcHVsYXRlLFxuICAgICAganVzdE9uZToganVzdE9uZSxcbiAgICAgIGNvdW50OiBjb3VudFxuICAgIH07XG4gIH1cblxuICBpZiAodHlwZW9mIG9iai5wYXRoICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3V0aWxzLnBvcHVsYXRlOiBpbnZhbGlkIHBhdGguIEV4cGVjdGVkIHN0cmluZy4gR290IHR5cGVvZiBgJyArIHR5cGVvZiBwYXRoICsgJ2AnKTtcbiAgfVxuXG4gIHJldHVybiBfcG9wdWxhdGVPYmoob2JqKTtcblxuICAvLyBUaGUgb3JkZXIgb2Ygc2VsZWN0L2NvbmRpdGlvbnMgYXJncyBpcyBvcHBvc2l0ZSBNb2RlbC5maW5kIGJ1dFxuICAvLyBuZWNlc3NhcnkgdG8ga2VlcCBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IChzZWxlY3QgY291bGQgYmVcbiAgLy8gYW4gYXJyYXksIHN0cmluZywgb3Igb2JqZWN0IGxpdGVyYWwpLlxuICBmdW5jdGlvbiBtYWtlU2luZ2xlcyhhcnIpIHtcbiAgICBjb25zdCByZXQgPSBbXTtcbiAgICBhcnIuZm9yRWFjaChmdW5jdGlvbihvYmopIHtcbiAgICAgIGlmIChvbmVTcGFjZVJFLnRlc3Qob2JqLnBhdGgpKSB7XG4gICAgICAgIGNvbnN0IHBhdGhzID0gb2JqLnBhdGguc3BsaXQobWFueVNwYWNlUkUpO1xuICAgICAgICBwYXRocy5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqKTtcbiAgICAgICAgICBjb3B5LnBhdGggPSBwO1xuICAgICAgICAgIHJldC5wdXNoKGNvcHkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldC5wdXNoKG9iaik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG59O1xuXG5mdW5jdGlvbiBfcG9wdWxhdGVPYmoob2JqKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG9iai5wb3B1bGF0ZSkpIHtcbiAgICBjb25zdCByZXQgPSBbXTtcbiAgICBvYmoucG9wdWxhdGUuZm9yRWFjaChmdW5jdGlvbihvYmopIHtcbiAgICAgIGlmIChvbmVTcGFjZVJFLnRlc3Qob2JqLnBhdGgpKSB7XG4gICAgICAgIGNvbnN0IGNvcHkgPSBPYmplY3QuYXNzaWduKHt9LCBvYmopO1xuICAgICAgICBjb25zdCBwYXRocyA9IGNvcHkucGF0aC5zcGxpdChtYW55U3BhY2VSRSk7XG4gICAgICAgIHBhdGhzLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICAgIGNvcHkucGF0aCA9IHA7XG4gICAgICAgICAgcmV0LnB1c2goZXhwb3J0cy5wb3B1bGF0ZShjb3B5KVswXSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0LnB1c2goZXhwb3J0cy5wb3B1bGF0ZShvYmopWzBdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBvYmoucG9wdWxhdGUgPSBleHBvcnRzLnBvcHVsYXRlKHJldCk7XG4gIH0gZWxzZSBpZiAob2JqLnBvcHVsYXRlICE9IG51bGwgJiYgdHlwZW9mIG9iai5wb3B1bGF0ZSA9PT0gJ29iamVjdCcpIHtcbiAgICBvYmoucG9wdWxhdGUgPSBleHBvcnRzLnBvcHVsYXRlKG9iai5wb3B1bGF0ZSk7XG4gIH1cblxuICBjb25zdCByZXQgPSBbXTtcbiAgY29uc3QgcGF0aHMgPSBvbmVTcGFjZVJFLnRlc3Qob2JqLnBhdGgpID8gb2JqLnBhdGguc3BsaXQobWFueVNwYWNlUkUpIDogW29iai5wYXRoXTtcbiAgaWYgKG9iai5vcHRpb25zICE9IG51bGwpIHtcbiAgICBvYmoub3B0aW9ucyA9IGNsb25lKG9iai5vcHRpb25zKTtcbiAgfVxuXG4gIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgIHJldC5wdXNoKG5ldyBQb3B1bGF0ZU9wdGlvbnMoT2JqZWN0LmFzc2lnbih7fSwgb2JqLCB7IHBhdGg6IHBhdGggfSkpKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSB2YWx1ZSBvZiBgb2JqYCBhdCB0aGUgZ2l2ZW4gYHBhdGhgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge0FueX0gbWFwXG4gKi9cblxuZXhwb3J0cy5nZXRWYWx1ZSA9IGZ1bmN0aW9uKHBhdGgsIG9iaiwgbWFwKSB7XG4gIHJldHVybiBtcGF0aC5nZXQocGF0aCwgb2JqLCBnZXRWYWx1ZUxvb2t1cCwgbWFwKTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuY29uc3QgbWFwR2V0dGVyT3B0aW9ucyA9IE9iamVjdC5mcmVlemUoeyBnZXR0ZXJzOiBmYWxzZSB9KTtcblxuZnVuY3Rpb24gZ2V0VmFsdWVMb29rdXAob2JqLCBwYXJ0KSB7XG4gIGxldCBfZnJvbSA9IG9iaj8uX2RvYyB8fCBvYmo7XG4gIGlmIChfZnJvbSAhPSBudWxsICYmIF9mcm9tLmlzTW9uZ29vc2VBcnJheVByb3h5KSB7XG4gICAgX2Zyb20gPSBfZnJvbS5fX2FycmF5O1xuICB9XG4gIHJldHVybiBfZnJvbSBpbnN0YW5jZW9mIE1hcCA/XG4gICAgX2Zyb20uZ2V0KHBhcnQsIG1hcEdldHRlck9wdGlvbnMpIDpcbiAgICBfZnJvbVtwYXJ0XTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBvZiBgb2JqYCBhdCB0aGUgZ2l2ZW4gYHBhdGhgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcGFyYW0ge0FueXRoaW5nfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7QW55fSBtYXBcbiAqIEBwYXJhbSB7QW55fSBfY29weWluZ1xuICovXG5cbmV4cG9ydHMuc2V0VmFsdWUgPSBmdW5jdGlvbihwYXRoLCB2YWwsIG9iaiwgbWFwLCBfY29weWluZykge1xuICBtcGF0aC5zZXQocGF0aCwgdmFsLCBvYmosICdfZG9jJywgbWFwLCBfY29weWluZyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgdmFsdWVzIGZyb20gb2JqZWN0IGBvYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb1xuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLm9iamVjdCA9IHt9O1xuZXhwb3J0cy5vYmplY3QudmFscyA9IGZ1bmN0aW9uIHZhbHMobykge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobyk7XG4gIGxldCBpID0ga2V5cy5sZW5ndGg7XG4gIGNvbnN0IHJldCA9IFtdO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXQucHVzaChvW2tleXNbaV1dKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5jb25zdCBob3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFNhZmVyIGhlbHBlciBmb3IgaGFzT3duUHJvcGVydHkgY2hlY2tzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BcbiAqL1xuXG5leHBvcnRzLm9iamVjdC5oYXNPd25Qcm9wZXJ0eSA9IGZ1bmN0aW9uKG9iaiwgcHJvcCkge1xuICByZXR1cm4gaG9wLmNhbGwob2JqLCBwcm9wKTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGB2YWxgIGlzIG51bGwgb3IgdW5kZWZpbmVkXG4gKlxuICogQHBhcmFtIHtBbnl9IHZhbFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gZnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQ7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmV4cG9ydHMuYXJyYXkgPSB7fTtcblxuLyoqXG4gKiBGbGF0dGVucyBhbiBhcnJheS5cbiAqXG4gKiBbIDEsIFsgMiwgMywgWzRdIF1dIC0+IFsxLDIsMyw0XVxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZpbHRlcl0gSWYgcGFzc2VkLCB3aWxsIGJlIGludm9rZWQgd2l0aCBlYWNoIGl0ZW0gaW4gdGhlIGFycmF5LiBJZiBgZmlsdGVyYCByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIHRoZSBpdGVtIHdpbGwgbm90IGJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHRzLlxuICogQHBhcmFtIHtBcnJheX0gcmV0XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuYXJyYXkuZmxhdHRlbiA9IGZ1bmN0aW9uIGZsYXR0ZW4oYXJyLCBmaWx0ZXIsIHJldCkge1xuICByZXQgfHwgKHJldCA9IFtdKTtcblxuICBhcnIuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgIGZsYXR0ZW4oaXRlbSwgZmlsdGVyLCByZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoaXRlbSkpIHtcbiAgICAgICAgcmV0LnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5jb25zdCBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5leHBvcnRzLmhhc1VzZXJEZWZpbmVkUHJvcGVydHkgPSBmdW5jdGlvbihvYmosIGtleSkge1xuICBpZiAob2JqID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShrZXkpKSB7XG4gICAgZm9yIChjb25zdCBrIG9mIGtleSkge1xuICAgICAgaWYgKGV4cG9ydHMuaGFzVXNlckRlZmluZWRQcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIGtleSBpbiBvYmopIHtcbiAgICBjb25zdCB2ID0gb2JqW2tleV07XG4gICAgcmV0dXJuIHYgIT09IE9iamVjdC5wcm90b3R5cGVba2V5XSAmJiB2ICE9PSBBcnJheS5wcm90b3R5cGVba2V5XTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuY29uc3QgTUFYX0FSUkFZX0lOREVYID0gTWF0aC5wb3coMiwgMzIpIC0gMTtcblxuZXhwb3J0cy5pc0FycmF5SW5kZXggPSBmdW5jdGlvbih2YWwpIHtcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbCA+PSAwICYmIHZhbCA8PSBNQVhfQVJSQVlfSU5ERVg7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCEvXlxcZCskLy50ZXN0KHZhbCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFsID0gK3ZhbDtcbiAgICByZXR1cm4gdmFsID49IDAgJiYgdmFsIDw9IE1BWF9BUlJBWV9JTkRFWDtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBkdXBsaWNhdGUgdmFsdWVzIGZyb20gYW4gYXJyYXlcbiAqXG4gKiBbMSwgMiwgMywgMywgNV0gPT4gWzEsIDIsIDMsIDVdXG4gKiBbIE9iamVjdElkKFwiNTUwOTg4YmEwYzE5ZDU3ZjY5N2RjNDVlXCIpLCBPYmplY3RJZChcIjU1MDk4OGJhMGMxOWQ1N2Y2OTdkYzQ1ZVwiKSBdXG4gKiAgICA9PiBbT2JqZWN0SWQoXCI1NTA5ODhiYTBjMTlkNTdmNjk3ZGM0NWVcIildXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuYXJyYXkudW5pcXVlID0gZnVuY3Rpb24oYXJyKSB7XG4gIGNvbnN0IHByaW1pdGl2ZXMgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IGlkcyA9IG5ldyBTZXQoKTtcbiAgY29uc3QgcmV0ID0gW107XG5cbiAgZm9yIChjb25zdCBpdGVtIG9mIGFycikge1xuICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnIHx8IGl0ZW0gPT0gbnVsbCkge1xuICAgICAgaWYgKHByaW1pdGl2ZXMuaGFzKGl0ZW0pKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmV0LnB1c2goaXRlbSk7XG4gICAgICBwcmltaXRpdmVzLmFkZChpdGVtKTtcbiAgICB9IGVsc2UgaWYgKGlzQnNvblR5cGUoaXRlbSwgJ09iamVjdElkJykpIHtcbiAgICAgIGlmIChpZHMuaGFzKGl0ZW0udG9TdHJpbmcoKSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXQucHVzaChpdGVtKTtcbiAgICAgIGlkcy5hZGQoaXRlbS50b1N0cmluZygpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmV4cG9ydHMuYnVmZmVyID0ge307XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0d28gYnVmZmVycyBhcmUgZXF1YWwuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gKi9cblxuZXhwb3J0cy5idWZmZXIuYXJlRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGEubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmV4cG9ydHMuZ2V0RnVuY3Rpb25OYW1lID0gZ2V0RnVuY3Rpb25OYW1lO1xuXG4vKipcbiAqIERlY29yYXRlIGJ1ZmZlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0aW5hdGlvblxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZVxuICovXG5cbmV4cG9ydHMuZGVjb3JhdGUgPSBmdW5jdGlvbihkZXN0aW5hdGlvbiwgc291cmNlKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZSkge1xuICAgIGlmIChzcGVjaWFsUHJvcGVydGllcy5oYXMoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGRlc3RpbmF0aW9uW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxufTtcblxuLyoqXG4gKiBtZXJnZXMgdG8gd2l0aCBhIGNvcHkgb2YgZnJvbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b1xuICogQHBhcmFtIHtPYmplY3R9IGZyb21PYmpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMubWVyZ2VDbG9uZSA9IGZ1bmN0aW9uKHRvLCBmcm9tT2JqKSB7XG4gIGlmIChpc01vbmdvb3NlT2JqZWN0KGZyb21PYmopKSB7XG4gICAgZnJvbU9iaiA9IGZyb21PYmoudG9PYmplY3Qoe1xuICAgICAgdHJhbnNmb3JtOiBmYWxzZSxcbiAgICAgIHZpcnR1YWxzOiBmYWxzZSxcbiAgICAgIGRlcG9wdWxhdGU6IHRydWUsXG4gICAgICBnZXR0ZXJzOiBmYWxzZSxcbiAgICAgIGZsYXR0ZW5EZWNpbWFsczogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZnJvbU9iaik7XG4gIGNvbnN0IGxlbiA9IGtleXMubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG4gIGxldCBrZXk7XG5cbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICBrZXkgPSBrZXlzW2krK107XG4gICAgaWYgKHNwZWNpYWxQcm9wZXJ0aWVzLmhhcyhrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0b1trZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdG9ba2V5XSA9IGNsb25lKGZyb21PYmpba2V5XSwge1xuICAgICAgICB0cmFuc2Zvcm06IGZhbHNlLFxuICAgICAgICB2aXJ0dWFsczogZmFsc2UsXG4gICAgICAgIGRlcG9wdWxhdGU6IHRydWUsXG4gICAgICAgIGdldHRlcnM6IGZhbHNlLFxuICAgICAgICBmbGF0dGVuRGVjaW1hbHM6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHZhbCA9IGZyb21PYmpba2V5XTtcbiAgICAgIGlmICh2YWwgIT0gbnVsbCAmJiB2YWwudmFsdWVPZiAmJiAhKHZhbCBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgIHZhbCA9IHZhbC52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgICBpZiAoZXhwb3J0cy5pc09iamVjdCh2YWwpKSB7XG4gICAgICAgIGxldCBvYmogPSB2YWw7XG4gICAgICAgIGlmIChpc01vbmdvb3NlT2JqZWN0KHZhbCkgJiYgIXZhbC5pc01vbmdvb3NlQnVmZmVyKSB7XG4gICAgICAgICAgb2JqID0gb2JqLnRvT2JqZWN0KHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogZmFsc2UsXG4gICAgICAgICAgICB2aXJ0dWFsczogZmFsc2UsXG4gICAgICAgICAgICBkZXBvcHVsYXRlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0dGVyczogZmFsc2UsXG4gICAgICAgICAgICBmbGF0dGVuRGVjaW1hbHM6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbC5pc01vbmdvb3NlQnVmZmVyKSB7XG4gICAgICAgICAgb2JqID0gQnVmZmVyLmZyb20ob2JqKTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRzLm1lcmdlQ2xvbmUodG9ba2V5XSwgb2JqKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvW2tleV0gPSBjbG9uZSh2YWwsIHtcbiAgICAgICAgICBmbGF0dGVuRGVjaW1hbHM6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhIGZ1bmN0aW9uIG9uIGVhY2ggZWxlbWVudCBvZiBhbiBhcnJheSAobGlrZSBfLmVhY2gpXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lYWNoID0gZnVuY3Rpb24oYXJyLCBmbikge1xuICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyKSB7XG4gICAgZm4oaXRlbSk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVuYW1lIGFuIG9iamVjdCBrZXksIHdoaWxlIHByZXNlcnZpbmcgaXRzIHBvc2l0aW9uIGluIHRoZSBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2xkT2JqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IG9sZEtleVxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBuZXdLZXlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5leHBvcnRzLnJlbmFtZU9iaktleSA9IGZ1bmN0aW9uKG9sZE9iaiwgb2xkS2V5LCBuZXdLZXkpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9sZE9iaik7XG4gIHJldHVybiBrZXlzLnJlZHVjZShcbiAgICAoYWNjLCB2YWwpID0+IHtcbiAgICAgIGlmICh2YWwgPT09IG9sZEtleSkge1xuICAgICAgICBhY2NbbmV3S2V5XSA9IG9sZE9ialtvbGRLZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWNjW3ZhbF0gPSBvbGRPYmpbdmFsXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSxcbiAgICB7fVxuICApO1xufTtcblxuLyohXG4gKiBpZ25vcmVcbiAqL1xuXG5leHBvcnRzLmdldE9wdGlvbiA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgY29uc3Qgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgZm9yIChjb25zdCBzb3VyY2Ugb2Ygc291cmNlcykge1xuICAgIGlmIChzb3VyY2UgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChzb3VyY2VbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHNvdXJjZVtuYW1lXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qIVxuICogaWdub3JlXG4gKi9cblxuZXhwb3J0cy5ub29wID0gZnVuY3Rpb24oKSB7fTtcblxuZXhwb3J0cy5lcnJvclRvUE9KTyA9IGZ1bmN0aW9uIGVycm9yVG9QT0pPKGVycm9yKSB7XG4gIGNvbnN0IGlzRXJyb3IgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yO1xuICBpZiAoIWlzRXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2BlcnJvcmAgbXVzdCBiZSBgaW5zdGFuY2VvZiBFcnJvcmAuJyk7XG4gIH1cblxuICBjb25zdCByZXQgPSB7fTtcbiAgZm9yIChjb25zdCBwcm9wZXJ5TmFtZSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhlcnJvcikpIHtcbiAgICByZXRbcHJvcGVyeU5hbWVdID0gZXJyb3JbcHJvcGVyeU5hbWVdO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cbmV4cG9ydHMud2FybiA9IGZ1bmN0aW9uIHdhcm4obWVzc2FnZSkge1xuICByZXR1cm4gcHJvY2Vzcy5lbWl0V2FybmluZyhtZXNzYWdlLCB7IGNvZGU6ICdNT05HT09TRScgfSk7XG59O1xuXG5cbmV4cG9ydHMuaW5qZWN0VGltZXN0YW1wc09wdGlvbiA9IGZ1bmN0aW9uIGluamVjdFRpbWVzdGFtcHNPcHRpb24od3JpdGVPcGVyYXRpb24sIHRpbWVzdGFtcHNPcHRpb24pIHtcbiAgaWYgKHRpbWVzdGFtcHNPcHRpb24gPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICB3cml0ZU9wZXJhdGlvbi50aW1lc3RhbXBzID0gdGltZXN0YW1wc09wdGlvbjtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/utils.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/validOptions.js":
/*!************************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/validOptions.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
eval("\n/*!\n * Valid mongoose options\n */\n\n\n\nconst VALID_OPTIONS = Object.freeze([\n  'allowDiskUse',\n  'applyPluginsToChildSchemas',\n  'applyPluginsToDiscriminators',\n  'autoCreate',\n  'autoIndex',\n  'autoSearchIndex',\n  'bufferCommands',\n  'bufferTimeoutMS',\n  'cloneSchemas',\n  'debug',\n  'id',\n  'timestamps.createdAt.immutable',\n  'maxTimeMS',\n  'objectIdGetter',\n  'overwriteModels',\n  'returnOriginal',\n  'runValidators',\n  'sanitizeFilter',\n  'sanitizeProjection',\n  'selectPopulatedPaths',\n  'setDefaultsOnInsert',\n  'strict',\n  'strictPopulate',\n  'strictQuery',\n  'toJSON',\n  'toObject',\n  'translateAliases'\n]);\n\nmodule.exports = VALID_OPTIONS;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3ZhbGlkT3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdmFsaWRPcHRpb25zLmpzP2M4YTgiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKiFcbiAqIFZhbGlkIG1vbmdvb3NlIG9wdGlvbnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IFZBTElEX09QVElPTlMgPSBPYmplY3QuZnJlZXplKFtcbiAgJ2FsbG93RGlza1VzZScsXG4gICdhcHBseVBsdWdpbnNUb0NoaWxkU2NoZW1hcycsXG4gICdhcHBseVBsdWdpbnNUb0Rpc2NyaW1pbmF0b3JzJyxcbiAgJ2F1dG9DcmVhdGUnLFxuICAnYXV0b0luZGV4JyxcbiAgJ2F1dG9TZWFyY2hJbmRleCcsXG4gICdidWZmZXJDb21tYW5kcycsXG4gICdidWZmZXJUaW1lb3V0TVMnLFxuICAnY2xvbmVTY2hlbWFzJyxcbiAgJ2RlYnVnJyxcbiAgJ2lkJyxcbiAgJ3RpbWVzdGFtcHMuY3JlYXRlZEF0LmltbXV0YWJsZScsXG4gICdtYXhUaW1lTVMnLFxuICAnb2JqZWN0SWRHZXR0ZXInLFxuICAnb3ZlcndyaXRlTW9kZWxzJyxcbiAgJ3JldHVybk9yaWdpbmFsJyxcbiAgJ3J1blZhbGlkYXRvcnMnLFxuICAnc2FuaXRpemVGaWx0ZXInLFxuICAnc2FuaXRpemVQcm9qZWN0aW9uJyxcbiAgJ3NlbGVjdFBvcHVsYXRlZFBhdGhzJyxcbiAgJ3NldERlZmF1bHRzT25JbnNlcnQnLFxuICAnc3RyaWN0JyxcbiAgJ3N0cmljdFBvcHVsYXRlJyxcbiAgJ3N0cmljdFF1ZXJ5JyxcbiAgJ3RvSlNPTicsXG4gICd0b09iamVjdCcsXG4gICd0cmFuc2xhdGVBbGlhc2VzJ1xuXSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVkFMSURfT1BUSU9OUztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/validOptions.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/lib/virtualType.js":
/*!***********************************************************!*\
  !*** ../backend/node_modules/mongoose/lib/virtualType.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst utils = __webpack_require__(/*! ./utils */ \"../backend/node_modules/mongoose/lib/utils.js\");\n\n/**\n * VirtualType constructor\n *\n * This is what mongoose uses to define virtual attributes via `Schema.prototype.virtual`.\n *\n * #### Example:\n *\n *     const fullname = schema.virtual('fullname');\n *     fullname instanceof mongoose.VirtualType // true\n *\n * @param {Object} options\n * @param {String|Function} [options.ref] if `ref` is not nullish, this becomes a [populated virtual](https://mongoosejs.com/docs/populate.html#populate-virtuals)\n * @param {String|Function} [options.localField] the local field to populate on if this is a populated virtual.\n * @param {String|Function} [options.foreignField] the foreign field to populate on if this is a populated virtual.\n * @param {Boolean} [options.justOne=false] by default, a populated virtual is an array. If you set `justOne`, the populated virtual will be a single doc or `null`.\n * @param {Boolean} [options.getters=false] if you set this to `true`, Mongoose will call any custom getters you defined on this virtual\n * @param {Boolean} [options.count=false] if you set this to `true`, `populate()` will set this virtual to the number of populated documents, as opposed to the documents themselves, using [`Query#countDocuments()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.countDocuments())\n * @param {Object|Function} [options.match=null] add an extra match condition to `populate()`\n * @param {Number} [options.limit=null] add a default `limit` to the `populate()` query\n * @param {Number} [options.skip=null] add a default `skip` to the `populate()` query\n * @param {Number} [options.perDocumentLimit=null] For legacy reasons, `limit` with `populate()` may give incorrect results because it only executes a single query for every document being populated. If you set `perDocumentLimit`, Mongoose will ensure correct `limit` per document by executing a separate query for each document to `populate()`. For example, `.find().populate({ path: 'test', perDocumentLimit: 2 })` will execute 2 additional queries if `.find()` returns 2 documents.\n * @param {Object} [options.options=null] Additional options like `limit` and `lean`.\n * @param {String} name\n * @api public\n */\n\nfunction VirtualType(options, name) {\n  this.path = name;\n  this.getters = [];\n  this.setters = [];\n  this.options = Object.assign({}, options);\n}\n\n/**\n * If no getters/setters, add a default\n *\n * @api private\n */\n\nVirtualType.prototype._applyDefaultGetters = function() {\n  if (this.getters.length > 0 || this.setters.length > 0) {\n    return;\n  }\n\n  const path = this.path;\n  const internalProperty = '$' + path;\n  this.getters.push(function() {\n    return this.$locals[internalProperty];\n  });\n  this.setters.push(function(v) {\n    this.$locals[internalProperty] = v;\n  });\n};\n\n/*!\n * ignore\n */\n\nVirtualType.prototype.clone = function() {\n  const clone = new VirtualType(this.options, this.path);\n  clone.getters = [].concat(this.getters);\n  clone.setters = [].concat(this.setters);\n  return clone;\n};\n\n/**\n * Adds a custom getter to this virtual.\n *\n * Mongoose calls the getter function with the below 3 parameters.\n *\n * - `value`: the value returned by the previous getter. If there is only one getter, `value` will be `undefined`.\n * - `virtual`: the virtual object you called `.get()` on.\n * - `doc`: the document this virtual is attached to. Equivalent to `this`.\n *\n * #### Example:\n *\n *     const virtual = schema.virtual('fullname');\n *     virtual.get(function(value, virtual, doc) {\n *       return this.name.first + ' ' + this.name.last;\n *     });\n *\n * @param {Function} fn\n * @return {VirtualType} this\n * @api public\n */\n\nVirtualType.prototype.get = function(fn) {\n  this.getters.push(fn);\n  return this;\n};\n\n/**\n * Adds a custom setter to this virtual.\n *\n * Mongoose calls the setter function with the below 3 parameters.\n *\n * - `value`: the value being set.\n * - `virtual`: the virtual object you're calling `.set()` on.\n * - `doc`: the document this virtual is attached to. Equivalent to `this`.\n *\n * #### Example:\n *\n *     const virtual = schema.virtual('fullname');\n *     virtual.set(function(value, virtual, doc) {\n *       const parts = value.split(' ');\n *       this.name.first = parts[0];\n *       this.name.last = parts[1];\n *     });\n *\n *     const Model = mongoose.model('Test', schema);\n *     const doc = new Model();\n *     // Calls the setter with `value = 'Jean-Luc Picard'`\n *     doc.fullname = 'Jean-Luc Picard';\n *     doc.name.first; // 'Jean-Luc'\n *     doc.name.last; // 'Picard'\n *\n * @param {Function} fn\n * @return {VirtualType} this\n * @api public\n */\n\nVirtualType.prototype.set = function(fn) {\n  this.setters.push(fn);\n  return this;\n};\n\n/**\n * Applies getters to `value`.\n *\n * @param {Object} value\n * @param {Document} doc The document this virtual is attached to\n * @return {Any} the value after applying all getters\n * @api public\n */\n\nVirtualType.prototype.applyGetters = function(value, doc) {\n  if (utils.hasUserDefinedProperty(this.options, ['ref', 'refPath']) &&\n      doc.$$populatedVirtuals &&\n      doc.$$populatedVirtuals.hasOwnProperty(this.path)) {\n    value = doc.$$populatedVirtuals[this.path];\n  }\n\n  let v = value;\n  for (const getter of this.getters) {\n    v = getter.call(doc, v, this, doc);\n  }\n  return v;\n};\n\n/**\n * Applies setters to `value`.\n *\n * @param {Object} value\n * @param {Document} doc\n * @return {Any} the value after applying all setters\n * @api public\n */\n\nVirtualType.prototype.applySetters = function(value, doc) {\n  let v = value;\n  for (const setter of this.setters) {\n    v = setter.call(doc, v, this, doc);\n  }\n  return v;\n};\n\n/*!\n * exports\n */\n\nmodule.exports = VirtualType;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2UvbGliL3ZpcnR1YWxUeXBlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyw4REFBUzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVEsd1dBQXdXLG1DQUFtQztBQUM5WixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZLGFBQWE7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHNCQUFzQjtBQUN0QjtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZLGFBQWE7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFlBQVksS0FBSztBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixZQUFZLEtBQUs7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9tb25nb29zZS9saWIvdmlydHVhbFR5cGUuanM/N2M4NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG4vKipcbiAqIFZpcnR1YWxUeXBlIGNvbnN0cnVjdG9yXG4gKlxuICogVGhpcyBpcyB3aGF0IG1vbmdvb3NlIHVzZXMgdG8gZGVmaW5lIHZpcnR1YWwgYXR0cmlidXRlcyB2aWEgYFNjaGVtYS5wcm90b3R5cGUudmlydHVhbGAuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBmdWxsbmFtZSA9IHNjaGVtYS52aXJ0dWFsKCdmdWxsbmFtZScpO1xuICogICAgIGZ1bGxuYW1lIGluc3RhbmNlb2YgbW9uZ29vc2UuVmlydHVhbFR5cGUgLy8gdHJ1ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gW29wdGlvbnMucmVmXSBpZiBgcmVmYCBpcyBub3QgbnVsbGlzaCwgdGhpcyBiZWNvbWVzIGEgW3BvcHVsYXRlZCB2aXJ0dWFsXShodHRwczovL21vbmdvb3NlanMuY29tL2RvY3MvcG9wdWxhdGUuaHRtbCNwb3B1bGF0ZS12aXJ0dWFscylcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBbb3B0aW9ucy5sb2NhbEZpZWxkXSB0aGUgbG9jYWwgZmllbGQgdG8gcG9wdWxhdGUgb24gaWYgdGhpcyBpcyBhIHBvcHVsYXRlZCB2aXJ0dWFsLlxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IFtvcHRpb25zLmZvcmVpZ25GaWVsZF0gdGhlIGZvcmVpZ24gZmllbGQgdG8gcG9wdWxhdGUgb24gaWYgdGhpcyBpcyBhIHBvcHVsYXRlZCB2aXJ0dWFsLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5qdXN0T25lPWZhbHNlXSBieSBkZWZhdWx0LCBhIHBvcHVsYXRlZCB2aXJ0dWFsIGlzIGFuIGFycmF5LiBJZiB5b3Ugc2V0IGBqdXN0T25lYCwgdGhlIHBvcHVsYXRlZCB2aXJ0dWFsIHdpbGwgYmUgYSBzaW5nbGUgZG9jIG9yIGBudWxsYC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZ2V0dGVycz1mYWxzZV0gaWYgeW91IHNldCB0aGlzIHRvIGB0cnVlYCwgTW9uZ29vc2Ugd2lsbCBjYWxsIGFueSBjdXN0b20gZ2V0dGVycyB5b3UgZGVmaW5lZCBvbiB0aGlzIHZpcnR1YWxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY291bnQ9ZmFsc2VdIGlmIHlvdSBzZXQgdGhpcyB0byBgdHJ1ZWAsIGBwb3B1bGF0ZSgpYCB3aWxsIHNldCB0aGlzIHZpcnR1YWwgdG8gdGhlIG51bWJlciBvZiBwb3B1bGF0ZWQgZG9jdW1lbnRzLCBhcyBvcHBvc2VkIHRvIHRoZSBkb2N1bWVudHMgdGhlbXNlbHZlcywgdXNpbmcgW2BRdWVyeSNjb3VudERvY3VtZW50cygpYF0oaHR0cHM6Ly9tb25nb29zZWpzLmNvbS9kb2NzL2FwaS9xdWVyeS5odG1sI1F1ZXJ5LnByb3RvdHlwZS5jb3VudERvY3VtZW50cygpKVxuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IFtvcHRpb25zLm1hdGNoPW51bGxdIGFkZCBhbiBleHRyYSBtYXRjaCBjb25kaXRpb24gdG8gYHBvcHVsYXRlKClgXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubGltaXQ9bnVsbF0gYWRkIGEgZGVmYXVsdCBgbGltaXRgIHRvIHRoZSBgcG9wdWxhdGUoKWAgcXVlcnlcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5za2lwPW51bGxdIGFkZCBhIGRlZmF1bHQgYHNraXBgIHRvIHRoZSBgcG9wdWxhdGUoKWAgcXVlcnlcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wZXJEb2N1bWVudExpbWl0PW51bGxdIEZvciBsZWdhY3kgcmVhc29ucywgYGxpbWl0YCB3aXRoIGBwb3B1bGF0ZSgpYCBtYXkgZ2l2ZSBpbmNvcnJlY3QgcmVzdWx0cyBiZWNhdXNlIGl0IG9ubHkgZXhlY3V0ZXMgYSBzaW5nbGUgcXVlcnkgZm9yIGV2ZXJ5IGRvY3VtZW50IGJlaW5nIHBvcHVsYXRlZC4gSWYgeW91IHNldCBgcGVyRG9jdW1lbnRMaW1pdGAsIE1vbmdvb3NlIHdpbGwgZW5zdXJlIGNvcnJlY3QgYGxpbWl0YCBwZXIgZG9jdW1lbnQgYnkgZXhlY3V0aW5nIGEgc2VwYXJhdGUgcXVlcnkgZm9yIGVhY2ggZG9jdW1lbnQgdG8gYHBvcHVsYXRlKClgLiBGb3IgZXhhbXBsZSwgYC5maW5kKCkucG9wdWxhdGUoeyBwYXRoOiAndGVzdCcsIHBlckRvY3VtZW50TGltaXQ6IDIgfSlgIHdpbGwgZXhlY3V0ZSAyIGFkZGl0aW9uYWwgcXVlcmllcyBpZiBgLmZpbmQoKWAgcmV0dXJucyAyIGRvY3VtZW50cy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5vcHRpb25zPW51bGxdIEFkZGl0aW9uYWwgb3B0aW9ucyBsaWtlIGBsaW1pdGAgYW5kIGBsZWFuYC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFZpcnR1YWxUeXBlKG9wdGlvbnMsIG5hbWUpIHtcbiAgdGhpcy5wYXRoID0gbmFtZTtcbiAgdGhpcy5nZXR0ZXJzID0gW107XG4gIHRoaXMuc2V0dGVycyA9IFtdO1xuICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBJZiBubyBnZXR0ZXJzL3NldHRlcnMsIGFkZCBhIGRlZmF1bHRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5WaXJ0dWFsVHlwZS5wcm90b3R5cGUuX2FwcGx5RGVmYXVsdEdldHRlcnMgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuZ2V0dGVycy5sZW5ndGggPiAwIHx8IHRoaXMuc2V0dGVycy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgcGF0aCA9IHRoaXMucGF0aDtcbiAgY29uc3QgaW50ZXJuYWxQcm9wZXJ0eSA9ICckJyArIHBhdGg7XG4gIHRoaXMuZ2V0dGVycy5wdXNoKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiRsb2NhbHNbaW50ZXJuYWxQcm9wZXJ0eV07XG4gIH0pO1xuICB0aGlzLnNldHRlcnMucHVzaChmdW5jdGlvbih2KSB7XG4gICAgdGhpcy4kbG9jYWxzW2ludGVybmFsUHJvcGVydHldID0gdjtcbiAgfSk7XG59O1xuXG4vKiFcbiAqIGlnbm9yZVxuICovXG5cblZpcnR1YWxUeXBlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBjbG9uZSA9IG5ldyBWaXJ0dWFsVHlwZSh0aGlzLm9wdGlvbnMsIHRoaXMucGF0aCk7XG4gIGNsb25lLmdldHRlcnMgPSBbXS5jb25jYXQodGhpcy5nZXR0ZXJzKTtcbiAgY2xvbmUuc2V0dGVycyA9IFtdLmNvbmNhdCh0aGlzLnNldHRlcnMpO1xuICByZXR1cm4gY2xvbmU7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBjdXN0b20gZ2V0dGVyIHRvIHRoaXMgdmlydHVhbC5cbiAqXG4gKiBNb25nb29zZSBjYWxscyB0aGUgZ2V0dGVyIGZ1bmN0aW9uIHdpdGggdGhlIGJlbG93IDMgcGFyYW1ldGVycy5cbiAqXG4gKiAtIGB2YWx1ZWA6IHRoZSB2YWx1ZSByZXR1cm5lZCBieSB0aGUgcHJldmlvdXMgZ2V0dGVyLiBJZiB0aGVyZSBpcyBvbmx5IG9uZSBnZXR0ZXIsIGB2YWx1ZWAgd2lsbCBiZSBgdW5kZWZpbmVkYC5cbiAqIC0gYHZpcnR1YWxgOiB0aGUgdmlydHVhbCBvYmplY3QgeW91IGNhbGxlZCBgLmdldCgpYCBvbi5cbiAqIC0gYGRvY2A6IHRoZSBkb2N1bWVudCB0aGlzIHZpcnR1YWwgaXMgYXR0YWNoZWQgdG8uIEVxdWl2YWxlbnQgdG8gYHRoaXNgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3QgdmlydHVhbCA9IHNjaGVtYS52aXJ0dWFsKCdmdWxsbmFtZScpO1xuICogICAgIHZpcnR1YWwuZ2V0KGZ1bmN0aW9uKHZhbHVlLCB2aXJ0dWFsLCBkb2MpIHtcbiAqICAgICAgIHJldHVybiB0aGlzLm5hbWUuZmlyc3QgKyAnICcgKyB0aGlzLm5hbWUubGFzdDtcbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7VmlydHVhbFR5cGV9IHRoaXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuVmlydHVhbFR5cGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGZuKSB7XG4gIHRoaXMuZ2V0dGVycy5wdXNoKGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBjdXN0b20gc2V0dGVyIHRvIHRoaXMgdmlydHVhbC5cbiAqXG4gKiBNb25nb29zZSBjYWxscyB0aGUgc2V0dGVyIGZ1bmN0aW9uIHdpdGggdGhlIGJlbG93IDMgcGFyYW1ldGVycy5cbiAqXG4gKiAtIGB2YWx1ZWA6IHRoZSB2YWx1ZSBiZWluZyBzZXQuXG4gKiAtIGB2aXJ0dWFsYDogdGhlIHZpcnR1YWwgb2JqZWN0IHlvdSdyZSBjYWxsaW5nIGAuc2V0KClgIG9uLlxuICogLSBgZG9jYDogdGhlIGRvY3VtZW50IHRoaXMgdmlydHVhbCBpcyBhdHRhY2hlZCB0by4gRXF1aXZhbGVudCB0byBgdGhpc2AuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCB2aXJ0dWFsID0gc2NoZW1hLnZpcnR1YWwoJ2Z1bGxuYW1lJyk7XG4gKiAgICAgdmlydHVhbC5zZXQoZnVuY3Rpb24odmFsdWUsIHZpcnR1YWwsIGRvYykge1xuICogICAgICAgY29uc3QgcGFydHMgPSB2YWx1ZS5zcGxpdCgnICcpO1xuICogICAgICAgdGhpcy5uYW1lLmZpcnN0ID0gcGFydHNbMF07XG4gKiAgICAgICB0aGlzLm5hbWUubGFzdCA9IHBhcnRzWzFdO1xuICogICAgIH0pO1xuICpcbiAqICAgICBjb25zdCBNb2RlbCA9IG1vbmdvb3NlLm1vZGVsKCdUZXN0Jywgc2NoZW1hKTtcbiAqICAgICBjb25zdCBkb2MgPSBuZXcgTW9kZWwoKTtcbiAqICAgICAvLyBDYWxscyB0aGUgc2V0dGVyIHdpdGggYHZhbHVlID0gJ0plYW4tTHVjIFBpY2FyZCdgXG4gKiAgICAgZG9jLmZ1bGxuYW1lID0gJ0plYW4tTHVjIFBpY2FyZCc7XG4gKiAgICAgZG9jLm5hbWUuZmlyc3Q7IC8vICdKZWFuLUx1YydcbiAqICAgICBkb2MubmFtZS5sYXN0OyAvLyAnUGljYXJkJ1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtWaXJ0dWFsVHlwZX0gdGhpc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5WaXJ0dWFsVHlwZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oZm4pIHtcbiAgdGhpcy5zZXR0ZXJzLnB1c2goZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQXBwbGllcyBnZXR0ZXJzIHRvIGB2YWx1ZWAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBkb2MgVGhlIGRvY3VtZW50IHRoaXMgdmlydHVhbCBpcyBhdHRhY2hlZCB0b1xuICogQHJldHVybiB7QW55fSB0aGUgdmFsdWUgYWZ0ZXIgYXBwbHlpbmcgYWxsIGdldHRlcnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuVmlydHVhbFR5cGUucHJvdG90eXBlLmFwcGx5R2V0dGVycyA9IGZ1bmN0aW9uKHZhbHVlLCBkb2MpIHtcbiAgaWYgKHV0aWxzLmhhc1VzZXJEZWZpbmVkUHJvcGVydHkodGhpcy5vcHRpb25zLCBbJ3JlZicsICdyZWZQYXRoJ10pICYmXG4gICAgICBkb2MuJCRwb3B1bGF0ZWRWaXJ0dWFscyAmJlxuICAgICAgZG9jLiQkcG9wdWxhdGVkVmlydHVhbHMuaGFzT3duUHJvcGVydHkodGhpcy5wYXRoKSkge1xuICAgIHZhbHVlID0gZG9jLiQkcG9wdWxhdGVkVmlydHVhbHNbdGhpcy5wYXRoXTtcbiAgfVxuXG4gIGxldCB2ID0gdmFsdWU7XG4gIGZvciAoY29uc3QgZ2V0dGVyIG9mIHRoaXMuZ2V0dGVycykge1xuICAgIHYgPSBnZXR0ZXIuY2FsbChkb2MsIHYsIHRoaXMsIGRvYyk7XG4gIH1cbiAgcmV0dXJuIHY7XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgc2V0dGVycyB0byBgdmFsdWVgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jXG4gKiBAcmV0dXJuIHtBbnl9IHRoZSB2YWx1ZSBhZnRlciBhcHBseWluZyBhbGwgc2V0dGVyc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5WaXJ0dWFsVHlwZS5wcm90b3R5cGUuYXBwbHlTZXR0ZXJzID0gZnVuY3Rpb24odmFsdWUsIGRvYykge1xuICBsZXQgdiA9IHZhbHVlO1xuICBmb3IgKGNvbnN0IHNldHRlciBvZiB0aGlzLnNldHRlcnMpIHtcbiAgICB2ID0gc2V0dGVyLmNhbGwoZG9jLCB2LCB0aGlzLCBkb2MpO1xuICB9XG4gIHJldHVybiB2O1xufTtcblxuLyohXG4gKiBleHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBWaXJ0dWFsVHlwZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/lib/virtualType.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/node_modules/ms/index.js":
/*!*****************************************************************!*\
  !*** ../backend/node_modules/mongoose/node_modules/ms/index.js ***!
  \*****************************************************************/
/***/ ((module) => {

eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2Uvbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvbW9uZ29vc2Uvbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzPzVjMjkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB3ID0gZCAqIDc7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWwpKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigtPyg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ3dlZWtzJzpcbiAgICBjYXNlICd3ZWVrJzpcbiAgICBjYXNlICd3JzpcbiAgICAgIHJldHVybiBuICogdztcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgZCwgJ2RheScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGgsICdob3VyJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIHMsICdzZWNvbmQnKTtcbiAgfVxuICByZXR1cm4gbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XG4gIHZhciBpc1BsdXJhbCA9IG1zQWJzID49IG4gKiAxLjU7XG4gIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbikgKyAnICcgKyBuYW1lICsgKGlzUGx1cmFsID8gJ3MnIDogJycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../backend/node_modules/mongoose/node_modules/ms/index.js\n");

/***/ }),

/***/ "../backend/node_modules/mongoose/package.json":
/*!*****************************************************!*\
  !*** ../backend/node_modules/mongoose/package.json ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"mongoose","description":"Mongoose MongoDB ODM","version":"8.3.2","author":"Guillermo Rauch <guillermo@learnboost.com>","keywords":["mongodb","document","model","schema","database","odm","data","datastore","query","nosql","orm","db"],"license":"MIT","dependencies":{"bson":"^6.5.0","kareem":"2.6.3","mongodb":"6.5.0","mpath":"0.9.0","mquery":"5.0.0","ms":"2.1.3","sift":"16.0.1"},"devDependencies":{"@babel/core":"7.24.3","@babel/preset-env":"7.24.3","@typescript-eslint/eslint-plugin":"^6.2.1","@typescript-eslint/parser":"^6.2.1","acquit":"1.3.0","acquit-ignore":"0.2.1","acquit-require":"0.1.1","assert-browserify":"2.0.0","axios":"1.1.3","babel-loader":"8.2.5","benchmark":"2.1.4","broken-link-checker":"^0.7.8","buffer":"^5.6.0","cheerio":"1.0.0-rc.12","crypto-browserify":"3.12.0","dotenv":"16.4.5","dox":"1.0.0","eslint":"8.57.0","eslint-plugin-markdown":"^4.0.1","eslint-plugin-mocha-no-only":"1.1.1","express":"^4.18.1","fs-extra":"~11.2.0","highlight.js":"11.8.0","lodash.isequal":"4.5.0","lodash.isequalwith":"4.4.0","markdownlint-cli2":"^0.12.1","marked":"4.3.0","mkdirp":"^3.0.1","mocha":"10.4.0","moment":"2.x","mongodb-memory-server":"8.15.1","ncp":"^2.0.0","nyc":"15.1.0","pug":"3.0.2","q":"1.5.1","sinon":"17.0.1","stream-browserify":"3.0.0","tsd":"0.31.0","typescript":"5.4.3","uuid":"9.0.1","webpack":"5.91.0"},"directories":{"lib":"./lib/mongoose"},"scripts":{"docs:clean":"npm run docs:clean:stable","docs:clean:stable":"rimraf index.html && rimraf -rf ./docs/*.html  && rimraf -rf ./docs/api && rimraf -rf ./docs/tutorials/*.html && rimraf -rf ./docs/typescript/*.html && rimraf -rf ./docs/*.html && rimraf -rf ./docs/source/_docs && rimraf -rf ./tmp","docs:clean:5x":"rimraf index.html && rimraf -rf ./docs/5.x && rimraf -rf ./docs/source/_docs && rimraf -rf ./tmp","docs:clean:6x":"rimraf index.html && rimraf -rf ./docs/6.x && rimraf -rf ./docs/source/_docs && rimraf -rf ./tmp","docs:copy:tmp":"mkdirp ./tmp/docs/css && mkdirp ./tmp/docs/js && mkdirp ./tmp/docs/images && mkdirp ./tmp/docs/tutorials && mkdirp ./tmp/docs/typescript && mkdirp ./tmp/docs/api && ncp ./docs/css ./tmp/docs/css --filter=.css$ && ncp ./docs/js ./tmp/docs/js --filter=.js$ && ncp ./docs/images ./tmp/docs/images && ncp ./docs/tutorials ./tmp/docs/tutorials && ncp ./docs/typescript ./tmp/docs/typescript && ncp ./docs/api ./tmp/docs/api && cp index.html ./tmp && cp docs/*.html ./tmp/docs/","docs:copy:tmp:5x":"rimraf ./docs/5.x && ncp ./tmp ./docs/5.x","docs:move:6x:tmp":"mv ./docs/6.x ./tmp","docs:copy:tmp:6x":"rimraf ./docs/6.x && ncp ./tmp ./docs/6.x","docs:checkout:gh-pages":"git checkout gh-pages","docs:checkout:5x":"git checkout 5.x","docs:checkout:6x":"git checkout 6.x","docs:generate":"node ./scripts/website.js","docs:generate:sponsorData":"node ./scripts/loadSponsorData.js","docs:merge:stable":"git merge master","docs:merge:5x":"git merge 5.x","docs:merge:6x":"git merge 6.x","docs:test":"npm run docs:generate","docs:view":"node ./scripts/static.js","docs:prepare:publish:stable":"npm run docs:checkout:gh-pages && npm run docs:merge:stable && npm run docs:generate","docs:prepare:publish:5x":"npm run docs:checkout:5x && npm run docs:merge:5x && npm run docs:clean:stable && npm run docs:generate && npm run docs:copy:tmp && npm run docs:checkout:gh-pages && npm run docs:copy:tmp:5x","docs:prepare:publish:6x":"npm run docs:checkout:6x && npm run docs:merge:6x && npm run docs:clean:stable && env DOCS_DEPLOY=true npm run docs:generate && npm run docs:move:6x:tmp && npm run docs:checkout:gh-pages && npm run docs:copy:tmp:6x","docs:prepare:publish:7x":"env DOCS_DEPLOY=true npm run docs:generate && npm run docs:checkout:gh-pages && rimraf ./docs/7.x && mv ./tmp ./docs/7.x","docs:check-links":"blc http://127.0.0.1:8089 -ro","lint":"eslint .","lint-js":"eslint . --ext .js --ext .cjs","lint-ts":"eslint . --ext .ts","lint-md":"markdownlint-cli2 \\"**/*.md\\"","build-browser":"(rm ./dist/* || true) && node ./scripts/build-browser.js","prepublishOnly":"npm run build-browser","release":"git pull && git push origin master --tags && npm publish","release-5x":"git pull origin 5.x && git push origin 5.x && git push origin 5.x --tags && npm publish --tag 5x","release-6x":"git pull origin 6.x && git push origin 6.x && git push origin 6.x --tags && npm publish --tag 6x","mongo":"node ./tools/repl.js","publish-7x":"npm publish --tag 7x","test":"mocha --exit ./test/*.test.js","test-deno":"deno run --allow-env --allow-read --allow-net --allow-run --allow-sys --allow-write ./test/deno.js","test-rs":"START_REPLICA_SET=1 mocha --timeout 30000 --exit ./test/*.test.js","test-tsd":"node ./test/types/check-types-filename && tsd","tdd":"mocha ./test/*.test.js --inspect --watch --recursive --watch-files ./**/*.{js,ts}","test-coverage":"nyc --reporter=html --reporter=text npm test","ts-benchmark":"cd ./benchmarks/typescript/simple && npm install && npm run benchmark | node ../../../scripts/tsc-diagnostics-check"},"main":"./index.js","types":"./types/index.d.ts","engines":{"node":">=16.20.1"},"bugs":{"url":"https://github.com/Automattic/mongoose/issues/new"},"repository":{"type":"git","url":"git://github.com/Automattic/mongoose.git"},"homepage":"https://mongoosejs.com","browser":"./dist/browser.umd.js","config":{"mongodbMemoryServer":{"disablePostinstall":true}},"funding":{"type":"opencollective","url":"https://opencollective.com/mongoose"},"tsd":{"directory":"test/types","compilerOptions":{"esModuleInterop":false,"strict":true,"allowSyntheticDefaultImports":true,"strictPropertyInitialization":false,"noImplicitAny":false,"strictNullChecks":true,"module":"commonjs","target":"ES2017"}}}');

/***/ })

};
;