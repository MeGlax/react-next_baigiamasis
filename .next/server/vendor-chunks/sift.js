/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sift";
exports.ids = ["vendor-chunks/sift"];
exports.modules = {

/***/ "../backend/node_modules/sift/index.js":
/*!*********************************************!*\
  !*** ../backend/node_modules/sift/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const lib = __webpack_require__(/*! ./lib */ \"../backend/node_modules/sift/lib/index.js\");\n\nmodule.exports = lib.default;\nObject.assign(module.exports, lib);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc2lmdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxZQUFZLG1CQUFPLENBQUMsd0RBQU87O0FBRTNCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uLi9iYWNrZW5kL25vZGVfbW9kdWxlcy9zaWZ0L2luZGV4LmpzPzI5MmMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgbGliID0gcmVxdWlyZShcIi4vbGliXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxpYi5kZWZhdWx0O1xuT2JqZWN0LmFzc2lnbihtb2R1bGUuZXhwb3J0cywgbGliKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../backend/node_modules/sift/index.js\n");

/***/ }),

/***/ "../backend/node_modules/sift/lib/index.js":
/*!*************************************************!*\
  !*** ../backend/node_modules/sift/lib/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("(function (global, factory) {\n     true ? factory(exports) :\n    0;\n}(this, (function (exports) { 'use strict';\n\n    /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation.\r\n\r\n    Permission to use, copy, modify, and/or distribute this software for any\r\n    purpose with or without fee is hereby granted.\r\n\r\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n    PERFORMANCE OF THIS SOFTWARE.\r\n    ***************************************************************************** */\r\n    /* global Reflect, Promise */\r\n\r\n    var extendStatics = function(d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n\r\n    function __extends(d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    }\n\n    var typeChecker = function (type) {\n        var typeString = \"[object \" + type + \"]\";\n        return function (value) {\n            return getClassName(value) === typeString;\n        };\n    };\n    var getClassName = function (value) { return Object.prototype.toString.call(value); };\n    var comparable = function (value) {\n        if (value instanceof Date) {\n            return value.getTime();\n        }\n        else if (isArray(value)) {\n            return value.map(comparable);\n        }\n        else if (value && typeof value.toJSON === \"function\") {\n            return value.toJSON();\n        }\n        return value;\n    };\n    var isArray = typeChecker(\"Array\");\n    var isObject = typeChecker(\"Object\");\n    var isFunction = typeChecker(\"Function\");\n    var isVanillaObject = function (value) {\n        return (value &&\n            (value.constructor === Object ||\n                value.constructor === Array ||\n                value.constructor.toString() === \"function Object() { [native code] }\" ||\n                value.constructor.toString() === \"function Array() { [native code] }\") &&\n            !value.toJSON);\n    };\n    var equals = function (a, b) {\n        if (a == null && a == b) {\n            return true;\n        }\n        if (a === b) {\n            return true;\n        }\n        if (Object.prototype.toString.call(a) !== Object.prototype.toString.call(b)) {\n            return false;\n        }\n        if (isArray(a)) {\n            if (a.length !== b.length) {\n                return false;\n            }\n            for (var i = 0, length_1 = a.length; i < length_1; i++) {\n                if (!equals(a[i], b[i]))\n                    return false;\n            }\n            return true;\n        }\n        else if (isObject(a)) {\n            if (Object.keys(a).length !== Object.keys(b).length) {\n                return false;\n            }\n            for (var key in a) {\n                if (!equals(a[key], b[key]))\n                    return false;\n            }\n            return true;\n        }\n        return false;\n    };\n\n    /**\n     * Walks through each value given the context - used for nested operations. E.g:\n     * { \"person.address\": { $eq: \"blarg\" }}\n     */\n    var walkKeyPathValues = function (item, keyPath, next, depth, key, owner) {\n        var currentKey = keyPath[depth];\n        // if array, then try matching. Might fall through for cases like:\n        // { $eq: [1, 2, 3] }, [ 1, 2, 3 ].\n        if (isArray(item) && isNaN(Number(currentKey))) {\n            for (var i = 0, length_1 = item.length; i < length_1; i++) {\n                // if FALSE is returned, then terminate walker. For operations, this simply\n                // means that the search critera was met.\n                if (!walkKeyPathValues(item[i], keyPath, next, depth, i, item)) {\n                    return false;\n                }\n            }\n        }\n        if (depth === keyPath.length || item == null) {\n            return next(item, key, owner, depth === 0);\n        }\n        return walkKeyPathValues(item[currentKey], keyPath, next, depth + 1, currentKey, item);\n    };\n    var BaseOperation = /** @class */ (function () {\n        function BaseOperation(params, owneryQuery, options, name) {\n            this.params = params;\n            this.owneryQuery = owneryQuery;\n            this.options = options;\n            this.name = name;\n            this.init();\n        }\n        BaseOperation.prototype.init = function () { };\n        BaseOperation.prototype.reset = function () {\n            this.done = false;\n            this.keep = false;\n        };\n        return BaseOperation;\n    }());\n    var GroupOperation = /** @class */ (function (_super) {\n        __extends(GroupOperation, _super);\n        function GroupOperation(params, owneryQuery, options, children) {\n            var _this = _super.call(this, params, owneryQuery, options) || this;\n            _this.children = children;\n            return _this;\n        }\n        /**\n         */\n        GroupOperation.prototype.reset = function () {\n            this.keep = false;\n            this.done = false;\n            for (var i = 0, length_2 = this.children.length; i < length_2; i++) {\n                this.children[i].reset();\n            }\n        };\n        /**\n         */\n        GroupOperation.prototype.childrenNext = function (item, key, owner, root) {\n            var done = true;\n            var keep = true;\n            for (var i = 0, length_3 = this.children.length; i < length_3; i++) {\n                var childOperation = this.children[i];\n                if (!childOperation.done) {\n                    childOperation.next(item, key, owner, root);\n                }\n                if (!childOperation.keep) {\n                    keep = false;\n                }\n                if (childOperation.done) {\n                    if (!childOperation.keep) {\n                        break;\n                    }\n                }\n                else {\n                    done = false;\n                }\n            }\n            this.done = done;\n            this.keep = keep;\n        };\n        return GroupOperation;\n    }(BaseOperation));\n    var NamedGroupOperation = /** @class */ (function (_super) {\n        __extends(NamedGroupOperation, _super);\n        function NamedGroupOperation(params, owneryQuery, options, children, name) {\n            var _this = _super.call(this, params, owneryQuery, options, children) || this;\n            _this.name = name;\n            return _this;\n        }\n        return NamedGroupOperation;\n    }(GroupOperation));\n    var QueryOperation = /** @class */ (function (_super) {\n        __extends(QueryOperation, _super);\n        function QueryOperation() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.propop = true;\n            return _this;\n        }\n        /**\n         */\n        QueryOperation.prototype.next = function (item, key, parent, root) {\n            this.childrenNext(item, key, parent, root);\n        };\n        return QueryOperation;\n    }(GroupOperation));\n    var NestedOperation = /** @class */ (function (_super) {\n        __extends(NestedOperation, _super);\n        function NestedOperation(keyPath, params, owneryQuery, options, children) {\n            var _this = _super.call(this, params, owneryQuery, options, children) || this;\n            _this.keyPath = keyPath;\n            _this.propop = true;\n            /**\n             */\n            _this._nextNestedValue = function (value, key, owner, root) {\n                _this.childrenNext(value, key, owner, root);\n                return !_this.done;\n            };\n            return _this;\n        }\n        /**\n         */\n        NestedOperation.prototype.next = function (item, key, parent) {\n            walkKeyPathValues(item, this.keyPath, this._nextNestedValue, 0, key, parent);\n        };\n        return NestedOperation;\n    }(GroupOperation));\n    var createTester = function (a, compare) {\n        if (a instanceof Function) {\n            return a;\n        }\n        if (a instanceof RegExp) {\n            return function (b) {\n                var result = typeof b === \"string\" && a.test(b);\n                a.lastIndex = 0;\n                return result;\n            };\n        }\n        var comparableA = comparable(a);\n        return function (b) { return compare(comparableA, comparable(b)); };\n    };\n    var EqualsOperation = /** @class */ (function (_super) {\n        __extends(EqualsOperation, _super);\n        function EqualsOperation() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.propop = true;\n            return _this;\n        }\n        EqualsOperation.prototype.init = function () {\n            this._test = createTester(this.params, this.options.compare);\n        };\n        EqualsOperation.prototype.next = function (item, key, parent) {\n            if (!Array.isArray(parent) || parent.hasOwnProperty(key)) {\n                if (this._test(item, key, parent)) {\n                    this.done = true;\n                    this.keep = true;\n                }\n            }\n        };\n        return EqualsOperation;\n    }(BaseOperation));\n    var createEqualsOperation = function (params, owneryQuery, options) { return new EqualsOperation(params, owneryQuery, options); };\n    var NopeOperation = /** @class */ (function (_super) {\n        __extends(NopeOperation, _super);\n        function NopeOperation() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.propop = true;\n            return _this;\n        }\n        NopeOperation.prototype.next = function () {\n            this.done = true;\n            this.keep = false;\n        };\n        return NopeOperation;\n    }(BaseOperation));\n    var numericalOperationCreator = function (createNumericalOperation) { return function (params, owneryQuery, options, name) {\n        if (params == null) {\n            return new NopeOperation(params, owneryQuery, options, name);\n        }\n        return createNumericalOperation(params, owneryQuery, options, name);\n    }; };\n    var numericalOperation = function (createTester) {\n        return numericalOperationCreator(function (params, owneryQuery, options, name) {\n            var typeofParams = typeof comparable(params);\n            var test = createTester(params);\n            return new EqualsOperation(function (b) {\n                return typeof comparable(b) === typeofParams && test(b);\n            }, owneryQuery, options, name);\n        });\n    };\n    var createNamedOperation = function (name, params, parentQuery, options) {\n        var operationCreator = options.operations[name];\n        if (!operationCreator) {\n            throwUnsupportedOperation(name);\n        }\n        return operationCreator(params, parentQuery, options, name);\n    };\n    var throwUnsupportedOperation = function (name) {\n        throw new Error(\"Unsupported operation: \" + name);\n    };\n    var containsOperation = function (query, options) {\n        for (var key in query) {\n            if (options.operations.hasOwnProperty(key) || key.charAt(0) === \"$\")\n                return true;\n        }\n        return false;\n    };\n    var createNestedOperation = function (keyPath, nestedQuery, parentKey, owneryQuery, options) {\n        if (containsOperation(nestedQuery, options)) {\n            var _a = createQueryOperations(nestedQuery, parentKey, options), selfOperations = _a[0], nestedOperations = _a[1];\n            if (nestedOperations.length) {\n                throw new Error(\"Property queries must contain only operations, or exact objects.\");\n            }\n            return new NestedOperation(keyPath, nestedQuery, owneryQuery, options, selfOperations);\n        }\n        return new NestedOperation(keyPath, nestedQuery, owneryQuery, options, [\n            new EqualsOperation(nestedQuery, owneryQuery, options)\n        ]);\n    };\n    var createQueryOperation = function (query, owneryQuery, _a) {\n        if (owneryQuery === void 0) { owneryQuery = null; }\n        var _b = _a === void 0 ? {} : _a, compare = _b.compare, operations = _b.operations;\n        var options = {\n            compare: compare || equals,\n            operations: Object.assign({}, operations || {})\n        };\n        var _c = createQueryOperations(query, null, options), selfOperations = _c[0], nestedOperations = _c[1];\n        var ops = [];\n        if (selfOperations.length) {\n            ops.push(new NestedOperation([], query, owneryQuery, options, selfOperations));\n        }\n        ops.push.apply(ops, nestedOperations);\n        if (ops.length === 1) {\n            return ops[0];\n        }\n        return new QueryOperation(query, owneryQuery, options, ops);\n    };\n    var createQueryOperations = function (query, parentKey, options) {\n        var selfOperations = [];\n        var nestedOperations = [];\n        if (!isVanillaObject(query)) {\n            selfOperations.push(new EqualsOperation(query, query, options));\n            return [selfOperations, nestedOperations];\n        }\n        for (var key in query) {\n            if (options.operations.hasOwnProperty(key)) {\n                var op = createNamedOperation(key, query[key], query, options);\n                if (op) {\n                    if (!op.propop && parentKey && !options.operations[parentKey]) {\n                        throw new Error(\"Malformed query. \" + key + \" cannot be matched against property.\");\n                    }\n                }\n                // probably just a flag for another operation (like $options)\n                if (op != null) {\n                    selfOperations.push(op);\n                }\n            }\n            else if (key.charAt(0) === \"$\") {\n                throwUnsupportedOperation(key);\n            }\n            else {\n                nestedOperations.push(createNestedOperation(key.split(\".\"), query[key], key, query, options));\n            }\n        }\n        return [selfOperations, nestedOperations];\n    };\n    var createOperationTester = function (operation) { return function (item, key, owner) {\n        operation.reset();\n        operation.next(item, key, owner);\n        return operation.keep;\n    }; };\n    var createQueryTester = function (query, options) {\n        if (options === void 0) { options = {}; }\n        return createOperationTester(createQueryOperation(query, null, options));\n    };\n\n    var $Ne = /** @class */ (function (_super) {\n        __extends($Ne, _super);\n        function $Ne() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.propop = true;\n            return _this;\n        }\n        $Ne.prototype.init = function () {\n            this._test = createTester(this.params, this.options.compare);\n        };\n        $Ne.prototype.reset = function () {\n            _super.prototype.reset.call(this);\n            this.keep = true;\n        };\n        $Ne.prototype.next = function (item) {\n            if (this._test(item)) {\n                this.done = true;\n                this.keep = false;\n            }\n        };\n        return $Ne;\n    }(BaseOperation));\n    // https://docs.mongodb.com/manual/reference/operator/query/elemMatch/\n    var $ElemMatch = /** @class */ (function (_super) {\n        __extends($ElemMatch, _super);\n        function $ElemMatch() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.propop = true;\n            return _this;\n        }\n        $ElemMatch.prototype.init = function () {\n            if (!this.params || typeof this.params !== \"object\") {\n                throw new Error(\"Malformed query. $elemMatch must by an object.\");\n            }\n            this._queryOperation = createQueryOperation(this.params, this.owneryQuery, this.options);\n        };\n        $ElemMatch.prototype.reset = function () {\n            _super.prototype.reset.call(this);\n            this._queryOperation.reset();\n        };\n        $ElemMatch.prototype.next = function (item) {\n            if (isArray(item)) {\n                for (var i = 0, length_1 = item.length; i < length_1; i++) {\n                    // reset query operation since item being tested needs to pass _all_ query\n                    // operations for it to be a success\n                    this._queryOperation.reset();\n                    var child = item[i];\n                    this._queryOperation.next(child, i, item, false);\n                    this.keep = this.keep || this._queryOperation.keep;\n                }\n                this.done = true;\n            }\n            else {\n                this.done = false;\n                this.keep = false;\n            }\n        };\n        return $ElemMatch;\n    }(BaseOperation));\n    var $Not = /** @class */ (function (_super) {\n        __extends($Not, _super);\n        function $Not() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.propop = true;\n            return _this;\n        }\n        $Not.prototype.init = function () {\n            this._queryOperation = createQueryOperation(this.params, this.owneryQuery, this.options);\n        };\n        $Not.prototype.reset = function () {\n            _super.prototype.reset.call(this);\n            this._queryOperation.reset();\n        };\n        $Not.prototype.next = function (item, key, owner, root) {\n            this._queryOperation.next(item, key, owner, root);\n            this.done = this._queryOperation.done;\n            this.keep = !this._queryOperation.keep;\n        };\n        return $Not;\n    }(BaseOperation));\n    var $Size = /** @class */ (function (_super) {\n        __extends($Size, _super);\n        function $Size() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.propop = true;\n            return _this;\n        }\n        $Size.prototype.init = function () { };\n        $Size.prototype.next = function (item) {\n            if (isArray(item) && item.length === this.params) {\n                this.done = true;\n                this.keep = true;\n            }\n            // if (parent && parent.length === this.params) {\n            //   this.done = true;\n            //   this.keep = true;\n            // }\n        };\n        return $Size;\n    }(BaseOperation));\n    var assertGroupNotEmpty = function (values) {\n        if (values.length === 0) {\n            throw new Error(\"$and/$or/$nor must be a nonempty array\");\n        }\n    };\n    var $Or = /** @class */ (function (_super) {\n        __extends($Or, _super);\n        function $Or() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.propop = false;\n            return _this;\n        }\n        $Or.prototype.init = function () {\n            var _this = this;\n            assertGroupNotEmpty(this.params);\n            this._ops = this.params.map(function (op) {\n                return createQueryOperation(op, null, _this.options);\n            });\n        };\n        $Or.prototype.reset = function () {\n            this.done = false;\n            this.keep = false;\n            for (var i = 0, length_2 = this._ops.length; i < length_2; i++) {\n                this._ops[i].reset();\n            }\n        };\n        $Or.prototype.next = function (item, key, owner) {\n            var done = false;\n            var success = false;\n            for (var i = 0, length_3 = this._ops.length; i < length_3; i++) {\n                var op = this._ops[i];\n                op.next(item, key, owner);\n                if (op.keep) {\n                    done = true;\n                    success = op.keep;\n                    break;\n                }\n            }\n            this.keep = success;\n            this.done = done;\n        };\n        return $Or;\n    }(BaseOperation));\n    var $Nor = /** @class */ (function (_super) {\n        __extends($Nor, _super);\n        function $Nor() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.propop = false;\n            return _this;\n        }\n        $Nor.prototype.next = function (item, key, owner) {\n            _super.prototype.next.call(this, item, key, owner);\n            this.keep = !this.keep;\n        };\n        return $Nor;\n    }($Or));\n    var $In = /** @class */ (function (_super) {\n        __extends($In, _super);\n        function $In() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.propop = true;\n            return _this;\n        }\n        $In.prototype.init = function () {\n            var _this = this;\n            this._testers = this.params.map(function (value) {\n                if (containsOperation(value, _this.options)) {\n                    throw new Error(\"cannot nest $ under \" + _this.name.toLowerCase());\n                }\n                return createTester(value, _this.options.compare);\n            });\n        };\n        $In.prototype.next = function (item, key, owner) {\n            var done = false;\n            var success = false;\n            for (var i = 0, length_4 = this._testers.length; i < length_4; i++) {\n                var test = this._testers[i];\n                if (test(item)) {\n                    done = true;\n                    success = true;\n                    break;\n                }\n            }\n            this.keep = success;\n            this.done = done;\n        };\n        return $In;\n    }(BaseOperation));\n    var $Nin = /** @class */ (function (_super) {\n        __extends($Nin, _super);\n        function $Nin(params, ownerQuery, options, name) {\n            var _this = _super.call(this, params, ownerQuery, options, name) || this;\n            _this.propop = true;\n            _this._in = new $In(params, ownerQuery, options, name);\n            return _this;\n        }\n        $Nin.prototype.next = function (item, key, owner, root) {\n            this._in.next(item, key, owner);\n            if (isArray(owner) && !root) {\n                if (this._in.keep) {\n                    this.keep = false;\n                    this.done = true;\n                }\n                else if (key == owner.length - 1) {\n                    this.keep = true;\n                    this.done = true;\n                }\n            }\n            else {\n                this.keep = !this._in.keep;\n                this.done = true;\n            }\n        };\n        $Nin.prototype.reset = function () {\n            _super.prototype.reset.call(this);\n            this._in.reset();\n        };\n        return $Nin;\n    }(BaseOperation));\n    var $Exists = /** @class */ (function (_super) {\n        __extends($Exists, _super);\n        function $Exists() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.propop = true;\n            return _this;\n        }\n        $Exists.prototype.next = function (item, key, owner) {\n            if (owner.hasOwnProperty(key) === this.params) {\n                this.done = true;\n                this.keep = true;\n            }\n        };\n        return $Exists;\n    }(BaseOperation));\n    var $And = /** @class */ (function (_super) {\n        __extends($And, _super);\n        function $And(params, owneryQuery, options, name) {\n            var _this = _super.call(this, params, owneryQuery, options, params.map(function (query) { return createQueryOperation(query, owneryQuery, options); }), name) || this;\n            _this.propop = false;\n            assertGroupNotEmpty(params);\n            return _this;\n        }\n        $And.prototype.next = function (item, key, owner, root) {\n            this.childrenNext(item, key, owner, root);\n        };\n        return $And;\n    }(NamedGroupOperation));\n    var $All = /** @class */ (function (_super) {\n        __extends($All, _super);\n        function $All(params, owneryQuery, options, name) {\n            var _this = _super.call(this, params, owneryQuery, options, params.map(function (query) { return createQueryOperation(query, owneryQuery, options); }), name) || this;\n            _this.propop = true;\n            return _this;\n        }\n        $All.prototype.next = function (item, key, owner, root) {\n            this.childrenNext(item, key, owner, root);\n        };\n        return $All;\n    }(NamedGroupOperation));\n    var $eq = function (params, owneryQuery, options) {\n        return new EqualsOperation(params, owneryQuery, options);\n    };\n    var $ne = function (params, owneryQuery, options, name) { return new $Ne(params, owneryQuery, options, name); };\n    var $or = function (params, owneryQuery, options, name) { return new $Or(params, owneryQuery, options, name); };\n    var $nor = function (params, owneryQuery, options, name) { return new $Nor(params, owneryQuery, options, name); };\n    var $elemMatch = function (params, owneryQuery, options, name) { return new $ElemMatch(params, owneryQuery, options, name); };\n    var $nin = function (params, owneryQuery, options, name) { return new $Nin(params, owneryQuery, options, name); };\n    var $in = function (params, owneryQuery, options, name) {\n        return new $In(params, owneryQuery, options, name);\n    };\n    var $lt = numericalOperation(function (params) { return function (b) { return b < params; }; });\n    var $lte = numericalOperation(function (params) { return function (b) { return b <= params; }; });\n    var $gt = numericalOperation(function (params) { return function (b) { return b > params; }; });\n    var $gte = numericalOperation(function (params) { return function (b) { return b >= params; }; });\n    var $mod = function (_a, owneryQuery, options) {\n        var mod = _a[0], equalsValue = _a[1];\n        return new EqualsOperation(function (b) { return comparable(b) % mod === equalsValue; }, owneryQuery, options);\n    };\n    var $exists = function (params, owneryQuery, options, name) { return new $Exists(params, owneryQuery, options, name); };\n    var $regex = function (pattern, owneryQuery, options) {\n        return new EqualsOperation(new RegExp(pattern, owneryQuery.$options), owneryQuery, options);\n    };\n    var $not = function (params, owneryQuery, options, name) { return new $Not(params, owneryQuery, options, name); };\n    var typeAliases = {\n        number: function (v) { return typeof v === \"number\"; },\n        string: function (v) { return typeof v === \"string\"; },\n        bool: function (v) { return typeof v === \"boolean\"; },\n        array: function (v) { return Array.isArray(v); },\n        null: function (v) { return v === null; },\n        timestamp: function (v) { return v instanceof Date; }\n    };\n    var $type = function (clazz, owneryQuery, options) {\n        return new EqualsOperation(function (b) {\n            if (typeof clazz === \"string\") {\n                if (!typeAliases[clazz]) {\n                    throw new Error(\"Type alias does not exist\");\n                }\n                return typeAliases[clazz](b);\n            }\n            return b != null ? b instanceof clazz || b.constructor === clazz : false;\n        }, owneryQuery, options);\n    };\n    var $and = function (params, ownerQuery, options, name) { return new $And(params, ownerQuery, options, name); };\n    var $all = function (params, ownerQuery, options, name) { return new $All(params, ownerQuery, options, name); };\n    var $size = function (params, ownerQuery, options) { return new $Size(params, ownerQuery, options, \"$size\"); };\n    var $options = function () { return null; };\n    var $where = function (params, ownerQuery, options) {\n        var test;\n        if (isFunction(params)) {\n            test = params;\n        }\n        else if (!process.env.CSP_ENABLED) {\n            test = new Function(\"obj\", \"return \" + params);\n        }\n        else {\n            throw new Error(\"In CSP mode, sift does not support strings in \\\"$where\\\" condition\");\n        }\n        return new EqualsOperation(function (b) { return test.bind(b)(b); }, ownerQuery, options);\n    };\n\n    var defaultOperations = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        $Size: $Size,\n        $eq: $eq,\n        $ne: $ne,\n        $or: $or,\n        $nor: $nor,\n        $elemMatch: $elemMatch,\n        $nin: $nin,\n        $in: $in,\n        $lt: $lt,\n        $lte: $lte,\n        $gt: $gt,\n        $gte: $gte,\n        $mod: $mod,\n        $exists: $exists,\n        $regex: $regex,\n        $not: $not,\n        $type: $type,\n        $and: $and,\n        $all: $all,\n        $size: $size,\n        $options: $options,\n        $where: $where\n    });\n\n    var createDefaultQueryOperation = function (query, ownerQuery, _a) {\n        var _b = _a === void 0 ? {} : _a, compare = _b.compare, operations = _b.operations;\n        return createQueryOperation(query, ownerQuery, {\n            compare: compare,\n            operations: Object.assign({}, defaultOperations, operations || {})\n        });\n    };\n    var createDefaultQueryTester = function (query, options) {\n        if (options === void 0) { options = {}; }\n        var op = createDefaultQueryOperation(query, null, options);\n        return createOperationTester(op);\n    };\n\n    exports.$Size = $Size;\n    exports.$all = $all;\n    exports.$and = $and;\n    exports.$elemMatch = $elemMatch;\n    exports.$eq = $eq;\n    exports.$exists = $exists;\n    exports.$gt = $gt;\n    exports.$gte = $gte;\n    exports.$in = $in;\n    exports.$lt = $lt;\n    exports.$lte = $lte;\n    exports.$mod = $mod;\n    exports.$ne = $ne;\n    exports.$nin = $nin;\n    exports.$nor = $nor;\n    exports.$not = $not;\n    exports.$options = $options;\n    exports.$or = $or;\n    exports.$regex = $regex;\n    exports.$size = $size;\n    exports.$type = $type;\n    exports.$where = $where;\n    exports.EqualsOperation = EqualsOperation;\n    exports.createDefaultQueryOperation = createDefaultQueryOperation;\n    exports.createEqualsOperation = createEqualsOperation;\n    exports.createOperationTester = createOperationTester;\n    exports.createQueryOperation = createQueryOperation;\n    exports.createQueryTester = createQueryTester;\n    exports.default = createDefaultQueryTester;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vYmFja2VuZC9ub2RlX21vZHVsZXMvc2lmdC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxJQUFJLEtBQTREO0FBQ2hFLElBQUksQ0FDb0Q7QUFDeEQsQ0FBQyw2QkFBNkI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGVBQWU7QUFDckYscUVBQXFFLGVBQWU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsY0FBYztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLG9CQUFvQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0Esb0RBQW9ELGNBQWM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGNBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSx3Q0FBd0Msa0JBQWtCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGNBQWM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxjQUFjO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxjQUFjO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHLDJEQUEyRDtBQUNqSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRywyREFBMkQ7QUFDaks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlELDhEQUE4RDtBQUM5RCwrREFBK0Q7QUFDL0QscUVBQXFFO0FBQ3JFLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsc0JBQXNCLHVCQUF1QjtBQUNsRyxzREFBc0Qsc0JBQXNCLHdCQUF3QjtBQUNwRyxxREFBcUQsc0JBQXNCLHVCQUF1QjtBQUNsRyxzREFBc0Qsc0JBQXNCLHdCQUF3QjtBQUNwRztBQUNBO0FBQ0Esa0RBQWtELDZDQUE2QztBQUMvRjtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQSwrQkFBK0IsK0JBQStCO0FBQzlELCtCQUErQiwrQkFBK0I7QUFDOUQsNkJBQTZCLGdDQUFnQztBQUM3RCw4QkFBOEIsMEJBQTBCO0FBQ3hELDZCQUE2QixvQkFBb0I7QUFDakQsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsOERBQThEO0FBQzlELDhEQUE4RDtBQUM5RCx5REFBeUQ7QUFDekQsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QseUJBQXlCO0FBQzNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLHdDQUF3QyxxQ0FBcUM7QUFDN0UsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbURBQW1ELGFBQWE7O0FBRWhFLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4uL2JhY2tlbmQvbm9kZV9tb2R1bGVzL3NpZnQvbGliL2luZGV4LmpzPzVjYjgiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLnNpZnQgPSB7fSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAgICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcbiAgICBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxuICAgIHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcbiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcbiAgICBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuICAgIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuICAgIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG4gICAgTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuICAgIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuICAgIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4gICAgLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9XG5cbiAgICB2YXIgdHlwZUNoZWNrZXIgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgdHlwZVN0cmluZyA9IFwiW29iamVjdCBcIiArIHR5cGUgKyBcIl1cIjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENsYXNzTmFtZSh2YWx1ZSkgPT09IHR5cGVTdHJpbmc7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpOyB9O1xuICAgIHZhciBjb21wYXJhYmxlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5nZXRUaW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXAoY29tcGFyYWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9KU09OKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgdmFyIGlzQXJyYXkgPSB0eXBlQ2hlY2tlcihcIkFycmF5XCIpO1xuICAgIHZhciBpc09iamVjdCA9IHR5cGVDaGVja2VyKFwiT2JqZWN0XCIpO1xuICAgIHZhciBpc0Z1bmN0aW9uID0gdHlwZUNoZWNrZXIoXCJGdW5jdGlvblwiKTtcbiAgICB2YXIgaXNWYW5pbGxhT2JqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiZcbiAgICAgICAgICAgICh2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0IHx8XG4gICAgICAgICAgICAgICAgdmFsdWUuY29uc3RydWN0b3IgPT09IEFycmF5IHx8XG4gICAgICAgICAgICAgICAgdmFsdWUuY29uc3RydWN0b3IudG9TdHJpbmcoKSA9PT0gXCJmdW5jdGlvbiBPYmplY3QoKSB7IFtuYXRpdmUgY29kZV0gfVwiIHx8XG4gICAgICAgICAgICAgICAgdmFsdWUuY29uc3RydWN0b3IudG9TdHJpbmcoKSA9PT0gXCJmdW5jdGlvbiBBcnJheSgpIHsgW25hdGl2ZSBjb2RlXSB9XCIpICYmXG4gICAgICAgICAgICAhdmFsdWUudG9KU09OKTtcbiAgICB9O1xuICAgIHZhciBlcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICBpZiAoYSA9PSBudWxsICYmIGEgPT0gYikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSkgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FycmF5KGEpKSB7XG4gICAgICAgICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aF8xID0gYS5sZW5ndGg7IGkgPCBsZW5ndGhfMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlcXVhbHMoYVtpXSwgYltpXSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KGEpKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoYSkubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gYSkge1xuICAgICAgICAgICAgICAgIGlmICghZXF1YWxzKGFba2V5XSwgYltrZXldKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBXYWxrcyB0aHJvdWdoIGVhY2ggdmFsdWUgZ2l2ZW4gdGhlIGNvbnRleHQgLSB1c2VkIGZvciBuZXN0ZWQgb3BlcmF0aW9ucy4gRS5nOlxuICAgICAqIHsgXCJwZXJzb24uYWRkcmVzc1wiOiB7ICRlcTogXCJibGFyZ1wiIH19XG4gICAgICovXG4gICAgdmFyIHdhbGtLZXlQYXRoVmFsdWVzID0gZnVuY3Rpb24gKGl0ZW0sIGtleVBhdGgsIG5leHQsIGRlcHRoLCBrZXksIG93bmVyKSB7XG4gICAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5UGF0aFtkZXB0aF07XG4gICAgICAgIC8vIGlmIGFycmF5LCB0aGVuIHRyeSBtYXRjaGluZy4gTWlnaHQgZmFsbCB0aHJvdWdoIGZvciBjYXNlcyBsaWtlOlxuICAgICAgICAvLyB7ICRlcTogWzEsIDIsIDNdIH0sIFsgMSwgMiwgMyBdLlxuICAgICAgICBpZiAoaXNBcnJheShpdGVtKSAmJiBpc05hTihOdW1iZXIoY3VycmVudEtleSkpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoXzEgPSBpdGVtLmxlbmd0aDsgaSA8IGxlbmd0aF8xOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBGQUxTRSBpcyByZXR1cm5lZCwgdGhlbiB0ZXJtaW5hdGUgd2Fsa2VyLiBGb3Igb3BlcmF0aW9ucywgdGhpcyBzaW1wbHlcbiAgICAgICAgICAgICAgICAvLyBtZWFucyB0aGF0IHRoZSBzZWFyY2ggY3JpdGVyYSB3YXMgbWV0LlxuICAgICAgICAgICAgICAgIGlmICghd2Fsa0tleVBhdGhWYWx1ZXMoaXRlbVtpXSwga2V5UGF0aCwgbmV4dCwgZGVwdGgsIGksIGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlcHRoID09PSBrZXlQYXRoLmxlbmd0aCB8fCBpdGVtID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KGl0ZW0sIGtleSwgb3duZXIsIGRlcHRoID09PSAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2Fsa0tleVBhdGhWYWx1ZXMoaXRlbVtjdXJyZW50S2V5XSwga2V5UGF0aCwgbmV4dCwgZGVwdGggKyAxLCBjdXJyZW50S2V5LCBpdGVtKTtcbiAgICB9O1xuICAgIHZhciBCYXNlT3BlcmF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBCYXNlT3BlcmF0aW9uKHBhcmFtcywgb3duZXJ5UXVlcnksIG9wdGlvbnMsIG5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICAgICAgdGhpcy5vd25lcnlRdWVyeSA9IG93bmVyeVF1ZXJ5O1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgfVxuICAgICAgICBCYXNlT3BlcmF0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICBCYXNlT3BlcmF0aW9uLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5rZWVwID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBCYXNlT3BlcmF0aW9uO1xuICAgIH0oKSk7XG4gICAgdmFyIEdyb3VwT3BlcmF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoR3JvdXBPcGVyYXRpb24sIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEdyb3VwT3BlcmF0aW9uKHBhcmFtcywgb3duZXJ5UXVlcnksIG9wdGlvbnMsIGNoaWxkcmVuKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwYXJhbXMsIG93bmVyeVF1ZXJ5LCBvcHRpb25zKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICovXG4gICAgICAgIEdyb3VwT3BlcmF0aW9uLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMua2VlcCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoXzIgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbmd0aF8yOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLnJlc2V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKi9cbiAgICAgICAgR3JvdXBPcGVyYXRpb24ucHJvdG90eXBlLmNoaWxkcmVuTmV4dCA9IGZ1bmN0aW9uIChpdGVtLCBrZXksIG93bmVyLCByb290KSB7XG4gICAgICAgICAgICB2YXIgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB2YXIga2VlcCA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoXzMgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbmd0aF8zOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRPcGVyYXRpb24gPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmICghY2hpbGRPcGVyYXRpb24uZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZE9wZXJhdGlvbi5uZXh0KGl0ZW0sIGtleSwgb3duZXIsIHJvb3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNoaWxkT3BlcmF0aW9uLmtlZXApIHtcbiAgICAgICAgICAgICAgICAgICAga2VlcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRPcGVyYXRpb24uZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkT3BlcmF0aW9uLmtlZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kb25lID0gZG9uZTtcbiAgICAgICAgICAgIHRoaXMua2VlcCA9IGtlZXA7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBHcm91cE9wZXJhdGlvbjtcbiAgICB9KEJhc2VPcGVyYXRpb24pKTtcbiAgICB2YXIgTmFtZWRHcm91cE9wZXJhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKE5hbWVkR3JvdXBPcGVyYXRpb24sIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIE5hbWVkR3JvdXBPcGVyYXRpb24ocGFyYW1zLCBvd25lcnlRdWVyeSwgb3B0aW9ucywgY2hpbGRyZW4sIG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHBhcmFtcywgb3duZXJ5UXVlcnksIG9wdGlvbnMsIGNoaWxkcmVuKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5hbWVkR3JvdXBPcGVyYXRpb247XG4gICAgfShHcm91cE9wZXJhdGlvbikpO1xuICAgIHZhciBRdWVyeU9wZXJhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFF1ZXJ5T3BlcmF0aW9uLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBRdWVyeU9wZXJhdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMucHJvcG9wID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICovXG4gICAgICAgIFF1ZXJ5T3BlcmF0aW9uLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKGl0ZW0sIGtleSwgcGFyZW50LCByb290KSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuTmV4dChpdGVtLCBrZXksIHBhcmVudCwgcm9vdCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBRdWVyeU9wZXJhdGlvbjtcbiAgICB9KEdyb3VwT3BlcmF0aW9uKSk7XG4gICAgdmFyIE5lc3RlZE9wZXJhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKE5lc3RlZE9wZXJhdGlvbiwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gTmVzdGVkT3BlcmF0aW9uKGtleVBhdGgsIHBhcmFtcywgb3duZXJ5UXVlcnksIG9wdGlvbnMsIGNoaWxkcmVuKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwYXJhbXMsIG93bmVyeVF1ZXJ5LCBvcHRpb25zLCBjaGlsZHJlbikgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLmtleVBhdGggPSBrZXlQYXRoO1xuICAgICAgICAgICAgX3RoaXMucHJvcG9wID0gdHJ1ZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfdGhpcy5fbmV4dE5lc3RlZFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBrZXksIG93bmVyLCByb290KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2hpbGRyZW5OZXh0KHZhbHVlLCBrZXksIG93bmVyLCByb290KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIV90aGlzLmRvbmU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKi9cbiAgICAgICAgTmVzdGVkT3BlcmF0aW9uLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKGl0ZW0sIGtleSwgcGFyZW50KSB7XG4gICAgICAgICAgICB3YWxrS2V5UGF0aFZhbHVlcyhpdGVtLCB0aGlzLmtleVBhdGgsIHRoaXMuX25leHROZXN0ZWRWYWx1ZSwgMCwga2V5LCBwYXJlbnQpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTmVzdGVkT3BlcmF0aW9uO1xuICAgIH0oR3JvdXBPcGVyYXRpb24pKTtcbiAgICB2YXIgY3JlYXRlVGVzdGVyID0gZnVuY3Rpb24gKGEsIGNvbXBhcmUpIHtcbiAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0eXBlb2YgYiA9PT0gXCJzdHJpbmdcIiAmJiBhLnRlc3QoYik7XG4gICAgICAgICAgICAgICAgYS5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb21wYXJhYmxlQSA9IGNvbXBhcmFibGUoYSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYikgeyByZXR1cm4gY29tcGFyZShjb21wYXJhYmxlQSwgY29tcGFyYWJsZShiKSk7IH07XG4gICAgfTtcbiAgICB2YXIgRXF1YWxzT3BlcmF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoRXF1YWxzT3BlcmF0aW9uLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBFcXVhbHNPcGVyYXRpb24oKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLnByb3BvcCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgRXF1YWxzT3BlcmF0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fdGVzdCA9IGNyZWF0ZVRlc3Rlcih0aGlzLnBhcmFtcywgdGhpcy5vcHRpb25zLmNvbXBhcmUpO1xuICAgICAgICB9O1xuICAgICAgICBFcXVhbHNPcGVyYXRpb24ucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoaXRlbSwga2V5LCBwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYXJlbnQpIHx8IHBhcmVudC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Rlc3QoaXRlbSwga2V5LCBwYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMua2VlcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRXF1YWxzT3BlcmF0aW9uO1xuICAgIH0oQmFzZU9wZXJhdGlvbikpO1xuICAgIHZhciBjcmVhdGVFcXVhbHNPcGVyYXRpb24gPSBmdW5jdGlvbiAocGFyYW1zLCBvd25lcnlRdWVyeSwgb3B0aW9ucykgeyByZXR1cm4gbmV3IEVxdWFsc09wZXJhdGlvbihwYXJhbXMsIG93bmVyeVF1ZXJ5LCBvcHRpb25zKTsgfTtcbiAgICB2YXIgTm9wZU9wZXJhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKE5vcGVPcGVyYXRpb24sIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIE5vcGVPcGVyYXRpb24oKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLnByb3BvcCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgTm9wZU9wZXJhdGlvbi5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmtlZXAgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE5vcGVPcGVyYXRpb247XG4gICAgfShCYXNlT3BlcmF0aW9uKSk7XG4gICAgdmFyIG51bWVyaWNhbE9wZXJhdGlvbkNyZWF0b3IgPSBmdW5jdGlvbiAoY3JlYXRlTnVtZXJpY2FsT3BlcmF0aW9uKSB7IHJldHVybiBmdW5jdGlvbiAocGFyYW1zLCBvd25lcnlRdWVyeSwgb3B0aW9ucywgbmFtZSkge1xuICAgICAgICBpZiAocGFyYW1zID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm9wZU9wZXJhdGlvbihwYXJhbXMsIG93bmVyeVF1ZXJ5LCBvcHRpb25zLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlTnVtZXJpY2FsT3BlcmF0aW9uKHBhcmFtcywgb3duZXJ5UXVlcnksIG9wdGlvbnMsIG5hbWUpO1xuICAgIH07IH07XG4gICAgdmFyIG51bWVyaWNhbE9wZXJhdGlvbiA9IGZ1bmN0aW9uIChjcmVhdGVUZXN0ZXIpIHtcbiAgICAgICAgcmV0dXJuIG51bWVyaWNhbE9wZXJhdGlvbkNyZWF0b3IoZnVuY3Rpb24gKHBhcmFtcywgb3duZXJ5UXVlcnksIG9wdGlvbnMsIG5hbWUpIHtcbiAgICAgICAgICAgIHZhciB0eXBlb2ZQYXJhbXMgPSB0eXBlb2YgY29tcGFyYWJsZShwYXJhbXMpO1xuICAgICAgICAgICAgdmFyIHRlc3QgPSBjcmVhdGVUZXN0ZXIocGFyYW1zKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXF1YWxzT3BlcmF0aW9uKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBjb21wYXJhYmxlKGIpID09PSB0eXBlb2ZQYXJhbXMgJiYgdGVzdChiKTtcbiAgICAgICAgICAgIH0sIG93bmVyeVF1ZXJ5LCBvcHRpb25zLCBuYW1lKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgY3JlYXRlTmFtZWRPcGVyYXRpb24gPSBmdW5jdGlvbiAobmFtZSwgcGFyYW1zLCBwYXJlbnRRdWVyeSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgb3BlcmF0aW9uQ3JlYXRvciA9IG9wdGlvbnMub3BlcmF0aW9uc1tuYW1lXTtcbiAgICAgICAgaWYgKCFvcGVyYXRpb25DcmVhdG9yKSB7XG4gICAgICAgICAgICB0aHJvd1Vuc3VwcG9ydGVkT3BlcmF0aW9uKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcGVyYXRpb25DcmVhdG9yKHBhcmFtcywgcGFyZW50UXVlcnksIG9wdGlvbnMsIG5hbWUpO1xuICAgIH07XG4gICAgdmFyIHRocm93VW5zdXBwb3J0ZWRPcGVyYXRpb24gPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBvcGVyYXRpb246IFwiICsgbmFtZSk7XG4gICAgfTtcbiAgICB2YXIgY29udGFpbnNPcGVyYXRpb24gPSBmdW5jdGlvbiAocXVlcnksIG9wdGlvbnMpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHF1ZXJ5KSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vcGVyYXRpb25zLmhhc093blByb3BlcnR5KGtleSkgfHwga2V5LmNoYXJBdCgwKSA9PT0gXCIkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgdmFyIGNyZWF0ZU5lc3RlZE9wZXJhdGlvbiA9IGZ1bmN0aW9uIChrZXlQYXRoLCBuZXN0ZWRRdWVyeSwgcGFyZW50S2V5LCBvd25lcnlRdWVyeSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoY29udGFpbnNPcGVyYXRpb24obmVzdGVkUXVlcnksIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBjcmVhdGVRdWVyeU9wZXJhdGlvbnMobmVzdGVkUXVlcnksIHBhcmVudEtleSwgb3B0aW9ucyksIHNlbGZPcGVyYXRpb25zID0gX2FbMF0sIG5lc3RlZE9wZXJhdGlvbnMgPSBfYVsxXTtcbiAgICAgICAgICAgIGlmIChuZXN0ZWRPcGVyYXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3BlcnR5IHF1ZXJpZXMgbXVzdCBjb250YWluIG9ubHkgb3BlcmF0aW9ucywgb3IgZXhhY3Qgb2JqZWN0cy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5lc3RlZE9wZXJhdGlvbihrZXlQYXRoLCBuZXN0ZWRRdWVyeSwgb3duZXJ5UXVlcnksIG9wdGlvbnMsIHNlbGZPcGVyYXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE5lc3RlZE9wZXJhdGlvbihrZXlQYXRoLCBuZXN0ZWRRdWVyeSwgb3duZXJ5UXVlcnksIG9wdGlvbnMsIFtcbiAgICAgICAgICAgIG5ldyBFcXVhbHNPcGVyYXRpb24obmVzdGVkUXVlcnksIG93bmVyeVF1ZXJ5LCBvcHRpb25zKVxuICAgICAgICBdKTtcbiAgICB9O1xuICAgIHZhciBjcmVhdGVRdWVyeU9wZXJhdGlvbiA9IGZ1bmN0aW9uIChxdWVyeSwgb3duZXJ5UXVlcnksIF9hKSB7XG4gICAgICAgIGlmIChvd25lcnlRdWVyeSA9PT0gdm9pZCAwKSB7IG93bmVyeVF1ZXJ5ID0gbnVsbDsgfVxuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgY29tcGFyZSA9IF9iLmNvbXBhcmUsIG9wZXJhdGlvbnMgPSBfYi5vcGVyYXRpb25zO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGNvbXBhcmU6IGNvbXBhcmUgfHwgZXF1YWxzLFxuICAgICAgICAgICAgb3BlcmF0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgb3BlcmF0aW9ucyB8fCB7fSlcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIF9jID0gY3JlYXRlUXVlcnlPcGVyYXRpb25zKHF1ZXJ5LCBudWxsLCBvcHRpb25zKSwgc2VsZk9wZXJhdGlvbnMgPSBfY1swXSwgbmVzdGVkT3BlcmF0aW9ucyA9IF9jWzFdO1xuICAgICAgICB2YXIgb3BzID0gW107XG4gICAgICAgIGlmIChzZWxmT3BlcmF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9wcy5wdXNoKG5ldyBOZXN0ZWRPcGVyYXRpb24oW10sIHF1ZXJ5LCBvd25lcnlRdWVyeSwgb3B0aW9ucywgc2VsZk9wZXJhdGlvbnMpKTtcbiAgICAgICAgfVxuICAgICAgICBvcHMucHVzaC5hcHBseShvcHMsIG5lc3RlZE9wZXJhdGlvbnMpO1xuICAgICAgICBpZiAob3BzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG9wc1swXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5T3BlcmF0aW9uKHF1ZXJ5LCBvd25lcnlRdWVyeSwgb3B0aW9ucywgb3BzKTtcbiAgICB9O1xuICAgIHZhciBjcmVhdGVRdWVyeU9wZXJhdGlvbnMgPSBmdW5jdGlvbiAocXVlcnksIHBhcmVudEtleSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgc2VsZk9wZXJhdGlvbnMgPSBbXTtcbiAgICAgICAgdmFyIG5lc3RlZE9wZXJhdGlvbnMgPSBbXTtcbiAgICAgICAgaWYgKCFpc1ZhbmlsbGFPYmplY3QocXVlcnkpKSB7XG4gICAgICAgICAgICBzZWxmT3BlcmF0aW9ucy5wdXNoKG5ldyBFcXVhbHNPcGVyYXRpb24ocXVlcnksIHF1ZXJ5LCBvcHRpb25zKSk7XG4gICAgICAgICAgICByZXR1cm4gW3NlbGZPcGVyYXRpb25zLCBuZXN0ZWRPcGVyYXRpb25zXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcXVlcnkpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9wZXJhdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHZhciBvcCA9IGNyZWF0ZU5hbWVkT3BlcmF0aW9uKGtleSwgcXVlcnlba2V5XSwgcXVlcnksIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChvcCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wLnByb3BvcCAmJiBwYXJlbnRLZXkgJiYgIW9wdGlvbnMub3BlcmF0aW9uc1twYXJlbnRLZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgcXVlcnkuIFwiICsga2V5ICsgXCIgY2Fubm90IGJlIG1hdGNoZWQgYWdhaW5zdCBwcm9wZXJ0eS5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcHJvYmFibHkganVzdCBhIGZsYWcgZm9yIGFub3RoZXIgb3BlcmF0aW9uIChsaWtlICRvcHRpb25zKVxuICAgICAgICAgICAgICAgIGlmIChvcCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGZPcGVyYXRpb25zLnB1c2gob3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleS5jaGFyQXQoMCkgPT09IFwiJFwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dVbnN1cHBvcnRlZE9wZXJhdGlvbihrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmVzdGVkT3BlcmF0aW9ucy5wdXNoKGNyZWF0ZU5lc3RlZE9wZXJhdGlvbihrZXkuc3BsaXQoXCIuXCIpLCBxdWVyeVtrZXldLCBrZXksIHF1ZXJ5LCBvcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtzZWxmT3BlcmF0aW9ucywgbmVzdGVkT3BlcmF0aW9uc107XG4gICAgfTtcbiAgICB2YXIgY3JlYXRlT3BlcmF0aW9uVGVzdGVyID0gZnVuY3Rpb24gKG9wZXJhdGlvbikgeyByZXR1cm4gZnVuY3Rpb24gKGl0ZW0sIGtleSwgb3duZXIpIHtcbiAgICAgICAgb3BlcmF0aW9uLnJlc2V0KCk7XG4gICAgICAgIG9wZXJhdGlvbi5uZXh0KGl0ZW0sIGtleSwgb3duZXIpO1xuICAgICAgICByZXR1cm4gb3BlcmF0aW9uLmtlZXA7XG4gICAgfTsgfTtcbiAgICB2YXIgY3JlYXRlUXVlcnlUZXN0ZXIgPSBmdW5jdGlvbiAocXVlcnksIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZU9wZXJhdGlvblRlc3RlcihjcmVhdGVRdWVyeU9wZXJhdGlvbihxdWVyeSwgbnVsbCwgb3B0aW9ucykpO1xuICAgIH07XG5cbiAgICB2YXIgJE5lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoJE5lLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiAkTmUoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLnByb3BvcCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgJE5lLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fdGVzdCA9IGNyZWF0ZVRlc3Rlcih0aGlzLnBhcmFtcywgdGhpcy5vcHRpb25zLmNvbXBhcmUpO1xuICAgICAgICB9O1xuICAgICAgICAkTmUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5yZXNldC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5rZWVwID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgJE5lLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl90ZXN0KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmtlZXAgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuICROZTtcbiAgICB9KEJhc2VPcGVyYXRpb24pKTtcbiAgICAvLyBodHRwczovL2RvY3MubW9uZ29kYi5jb20vbWFudWFsL3JlZmVyZW5jZS9vcGVyYXRvci9xdWVyeS9lbGVtTWF0Y2gvXG4gICAgdmFyICRFbGVtTWF0Y2ggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcygkRWxlbU1hdGNoLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiAkRWxlbU1hdGNoKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5wcm9wb3AgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgICRFbGVtTWF0Y2gucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyYW1zIHx8IHR5cGVvZiB0aGlzLnBhcmFtcyAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1hbGZvcm1lZCBxdWVyeS4gJGVsZW1NYXRjaCBtdXN0IGJ5IGFuIG9iamVjdC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9xdWVyeU9wZXJhdGlvbiA9IGNyZWF0ZVF1ZXJ5T3BlcmF0aW9uKHRoaXMucGFyYW1zLCB0aGlzLm93bmVyeVF1ZXJ5LCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICAkRWxlbU1hdGNoLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUucmVzZXQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3F1ZXJ5T3BlcmF0aW9uLnJlc2V0KCk7XG4gICAgICAgIH07XG4gICAgICAgICRFbGVtTWF0Y2gucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoXzEgPSBpdGVtLmxlbmd0aDsgaSA8IGxlbmd0aF8xOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzZXQgcXVlcnkgb3BlcmF0aW9uIHNpbmNlIGl0ZW0gYmVpbmcgdGVzdGVkIG5lZWRzIHRvIHBhc3MgX2FsbF8gcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgLy8gb3BlcmF0aW9ucyBmb3IgaXQgdG8gYmUgYSBzdWNjZXNzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXJ5T3BlcmF0aW9uLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGl0ZW1baV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXJ5T3BlcmF0aW9uLm5leHQoY2hpbGQsIGksIGl0ZW0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5rZWVwID0gdGhpcy5rZWVwIHx8IHRoaXMuX3F1ZXJ5T3BlcmF0aW9uLmtlZXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmtlZXAgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuICRFbGVtTWF0Y2g7XG4gICAgfShCYXNlT3BlcmF0aW9uKSk7XG4gICAgdmFyICROb3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcygkTm90LCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiAkTm90KCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5wcm9wb3AgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgICROb3QucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9xdWVyeU9wZXJhdGlvbiA9IGNyZWF0ZVF1ZXJ5T3BlcmF0aW9uKHRoaXMucGFyYW1zLCB0aGlzLm93bmVyeVF1ZXJ5LCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICAkTm90LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUucmVzZXQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3F1ZXJ5T3BlcmF0aW9uLnJlc2V0KCk7XG4gICAgICAgIH07XG4gICAgICAgICROb3QucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoaXRlbSwga2V5LCBvd25lciwgcm9vdCkge1xuICAgICAgICAgICAgdGhpcy5fcXVlcnlPcGVyYXRpb24ubmV4dChpdGVtLCBrZXksIG93bmVyLCByb290KTtcbiAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRoaXMuX3F1ZXJ5T3BlcmF0aW9uLmRvbmU7XG4gICAgICAgICAgICB0aGlzLmtlZXAgPSAhdGhpcy5fcXVlcnlPcGVyYXRpb24ua2VlcDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuICROb3Q7XG4gICAgfShCYXNlT3BlcmF0aW9uKSk7XG4gICAgdmFyICRTaXplID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoJFNpemUsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uICRTaXplKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5wcm9wb3AgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgICRTaXplLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAkU2l6ZS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICBpZiAoaXNBcnJheShpdGVtKSAmJiBpdGVtLmxlbmd0aCA9PT0gdGhpcy5wYXJhbXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMua2VlcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiAocGFyZW50ICYmIHBhcmVudC5sZW5ndGggPT09IHRoaXMucGFyYW1zKSB7XG4gICAgICAgICAgICAvLyAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAvLyAgIHRoaXMua2VlcCA9IHRydWU7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAkU2l6ZTtcbiAgICB9KEJhc2VPcGVyYXRpb24pKTtcbiAgICB2YXIgYXNzZXJ0R3JvdXBOb3RFbXB0eSA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIiRhbmQvJG9yLyRub3IgbXVzdCBiZSBhIG5vbmVtcHR5IGFycmF5XCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgJE9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoJE9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiAkT3IoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLnByb3BvcCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgICRPci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBhc3NlcnRHcm91cE5vdEVtcHR5KHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgIHRoaXMuX29wcyA9IHRoaXMucGFyYW1zLm1hcChmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlUXVlcnlPcGVyYXRpb24ob3AsIG51bGwsIF90aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgICRPci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMua2VlcCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aF8yID0gdGhpcy5fb3BzLmxlbmd0aDsgaSA8IGxlbmd0aF8yOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcHNbaV0ucmVzZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgJE9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKGl0ZW0sIGtleSwgb3duZXIpIHtcbiAgICAgICAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aF8zID0gdGhpcy5fb3BzLmxlbmd0aDsgaSA8IGxlbmd0aF8zOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb3AgPSB0aGlzLl9vcHNbaV07XG4gICAgICAgICAgICAgICAgb3AubmV4dChpdGVtLCBrZXksIG93bmVyKTtcbiAgICAgICAgICAgICAgICBpZiAob3Aua2VlcCkge1xuICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyA9IG9wLmtlZXA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMua2VlcCA9IHN1Y2Nlc3M7XG4gICAgICAgICAgICB0aGlzLmRvbmUgPSBkb25lO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gJE9yO1xuICAgIH0oQmFzZU9wZXJhdGlvbikpO1xuICAgIHZhciAkTm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoJE5vciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gJE5vcigpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMucHJvcG9wID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgJE5vci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIChpdGVtLCBrZXksIG93bmVyKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5leHQuY2FsbCh0aGlzLCBpdGVtLCBrZXksIG93bmVyKTtcbiAgICAgICAgICAgIHRoaXMua2VlcCA9ICF0aGlzLmtlZXA7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAkTm9yO1xuICAgIH0oJE9yKSk7XG4gICAgdmFyICRJbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKCRJbiwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gJEluKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5wcm9wb3AgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgICRJbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl90ZXN0ZXJzID0gdGhpcy5wYXJhbXMubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChjb250YWluc09wZXJhdGlvbih2YWx1ZSwgX3RoaXMub3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IG5lc3QgJCB1bmRlciBcIiArIF90aGlzLm5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVUZXN0ZXIodmFsdWUsIF90aGlzLm9wdGlvbnMuY29tcGFyZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgJEluLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKGl0ZW0sIGtleSwgb3duZXIpIHtcbiAgICAgICAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aF80ID0gdGhpcy5fdGVzdGVycy5sZW5ndGg7IGkgPCBsZW5ndGhfNDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlc3QgPSB0aGlzLl90ZXN0ZXJzW2ldO1xuICAgICAgICAgICAgICAgIGlmICh0ZXN0KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5rZWVwID0gc3VjY2VzcztcbiAgICAgICAgICAgIHRoaXMuZG9uZSA9IGRvbmU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAkSW47XG4gICAgfShCYXNlT3BlcmF0aW9uKSk7XG4gICAgdmFyICROaW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcygkTmluLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiAkTmluKHBhcmFtcywgb3duZXJRdWVyeSwgb3B0aW9ucywgbmFtZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcGFyYW1zLCBvd25lclF1ZXJ5LCBvcHRpb25zLCBuYW1lKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMucHJvcG9wID0gdHJ1ZTtcbiAgICAgICAgICAgIF90aGlzLl9pbiA9IG5ldyAkSW4ocGFyYW1zLCBvd25lclF1ZXJ5LCBvcHRpb25zLCBuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICAkTmluLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKGl0ZW0sIGtleSwgb3duZXIsIHJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2luLm5leHQoaXRlbSwga2V5LCBvd25lcik7XG4gICAgICAgICAgICBpZiAoaXNBcnJheShvd25lcikgJiYgIXJvb3QpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faW4ua2VlcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmtlZXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09IG93bmVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5rZWVwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmtlZXAgPSAhdGhpcy5faW4ua2VlcDtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAkTmluLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUucmVzZXQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2luLnJlc2V0KCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAkTmluO1xuICAgIH0oQmFzZU9wZXJhdGlvbikpO1xuICAgIHZhciAkRXhpc3RzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoJEV4aXN0cywgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gJEV4aXN0cygpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMucHJvcG9wID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICAkRXhpc3RzLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKGl0ZW0sIGtleSwgb3duZXIpIHtcbiAgICAgICAgICAgIGlmIChvd25lci5oYXNPd25Qcm9wZXJ0eShrZXkpID09PSB0aGlzLnBhcmFtcykge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5rZWVwID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuICRFeGlzdHM7XG4gICAgfShCYXNlT3BlcmF0aW9uKSk7XG4gICAgdmFyICRBbmQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcygkQW5kLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiAkQW5kKHBhcmFtcywgb3duZXJ5UXVlcnksIG9wdGlvbnMsIG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHBhcmFtcywgb3duZXJ5UXVlcnksIG9wdGlvbnMsIHBhcmFtcy5tYXAoZnVuY3Rpb24gKHF1ZXJ5KSB7IHJldHVybiBjcmVhdGVRdWVyeU9wZXJhdGlvbihxdWVyeSwgb3duZXJ5UXVlcnksIG9wdGlvbnMpOyB9KSwgbmFtZSkgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLnByb3BvcCA9IGZhbHNlO1xuICAgICAgICAgICAgYXNzZXJ0R3JvdXBOb3RFbXB0eShwYXJhbXMpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgICRBbmQucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoaXRlbSwga2V5LCBvd25lciwgcm9vdCkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbk5leHQoaXRlbSwga2V5LCBvd25lciwgcm9vdCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAkQW5kO1xuICAgIH0oTmFtZWRHcm91cE9wZXJhdGlvbikpO1xuICAgIHZhciAkQWxsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoJEFsbCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gJEFsbChwYXJhbXMsIG93bmVyeVF1ZXJ5LCBvcHRpb25zLCBuYW1lKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwYXJhbXMsIG93bmVyeVF1ZXJ5LCBvcHRpb25zLCBwYXJhbXMubWFwKGZ1bmN0aW9uIChxdWVyeSkgeyByZXR1cm4gY3JlYXRlUXVlcnlPcGVyYXRpb24ocXVlcnksIG93bmVyeVF1ZXJ5LCBvcHRpb25zKTsgfSksIG5hbWUpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5wcm9wb3AgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgICRBbGwucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoaXRlbSwga2V5LCBvd25lciwgcm9vdCkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbk5leHQoaXRlbSwga2V5LCBvd25lciwgcm9vdCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAkQWxsO1xuICAgIH0oTmFtZWRHcm91cE9wZXJhdGlvbikpO1xuICAgIHZhciAkZXEgPSBmdW5jdGlvbiAocGFyYW1zLCBvd25lcnlRdWVyeSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEVxdWFsc09wZXJhdGlvbihwYXJhbXMsIG93bmVyeVF1ZXJ5LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIHZhciAkbmUgPSBmdW5jdGlvbiAocGFyYW1zLCBvd25lcnlRdWVyeSwgb3B0aW9ucywgbmFtZSkgeyByZXR1cm4gbmV3ICROZShwYXJhbXMsIG93bmVyeVF1ZXJ5LCBvcHRpb25zLCBuYW1lKTsgfTtcbiAgICB2YXIgJG9yID0gZnVuY3Rpb24gKHBhcmFtcywgb3duZXJ5UXVlcnksIG9wdGlvbnMsIG5hbWUpIHsgcmV0dXJuIG5ldyAkT3IocGFyYW1zLCBvd25lcnlRdWVyeSwgb3B0aW9ucywgbmFtZSk7IH07XG4gICAgdmFyICRub3IgPSBmdW5jdGlvbiAocGFyYW1zLCBvd25lcnlRdWVyeSwgb3B0aW9ucywgbmFtZSkgeyByZXR1cm4gbmV3ICROb3IocGFyYW1zLCBvd25lcnlRdWVyeSwgb3B0aW9ucywgbmFtZSk7IH07XG4gICAgdmFyICRlbGVtTWF0Y2ggPSBmdW5jdGlvbiAocGFyYW1zLCBvd25lcnlRdWVyeSwgb3B0aW9ucywgbmFtZSkgeyByZXR1cm4gbmV3ICRFbGVtTWF0Y2gocGFyYW1zLCBvd25lcnlRdWVyeSwgb3B0aW9ucywgbmFtZSk7IH07XG4gICAgdmFyICRuaW4gPSBmdW5jdGlvbiAocGFyYW1zLCBvd25lcnlRdWVyeSwgb3B0aW9ucywgbmFtZSkgeyByZXR1cm4gbmV3ICROaW4ocGFyYW1zLCBvd25lcnlRdWVyeSwgb3B0aW9ucywgbmFtZSk7IH07XG4gICAgdmFyICRpbiA9IGZ1bmN0aW9uIChwYXJhbXMsIG93bmVyeVF1ZXJ5LCBvcHRpb25zLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgJEluKHBhcmFtcywgb3duZXJ5UXVlcnksIG9wdGlvbnMsIG5hbWUpO1xuICAgIH07XG4gICAgdmFyICRsdCA9IG51bWVyaWNhbE9wZXJhdGlvbihmdW5jdGlvbiAocGFyYW1zKSB7IHJldHVybiBmdW5jdGlvbiAoYikgeyByZXR1cm4gYiA8IHBhcmFtczsgfTsgfSk7XG4gICAgdmFyICRsdGUgPSBudW1lcmljYWxPcGVyYXRpb24oZnVuY3Rpb24gKHBhcmFtcykgeyByZXR1cm4gZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGIgPD0gcGFyYW1zOyB9OyB9KTtcbiAgICB2YXIgJGd0ID0gbnVtZXJpY2FsT3BlcmF0aW9uKGZ1bmN0aW9uIChwYXJhbXMpIHsgcmV0dXJuIGZ1bmN0aW9uIChiKSB7IHJldHVybiBiID4gcGFyYW1zOyB9OyB9KTtcbiAgICB2YXIgJGd0ZSA9IG51bWVyaWNhbE9wZXJhdGlvbihmdW5jdGlvbiAocGFyYW1zKSB7IHJldHVybiBmdW5jdGlvbiAoYikgeyByZXR1cm4gYiA+PSBwYXJhbXM7IH07IH0pO1xuICAgIHZhciAkbW9kID0gZnVuY3Rpb24gKF9hLCBvd25lcnlRdWVyeSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbW9kID0gX2FbMF0sIGVxdWFsc1ZhbHVlID0gX2FbMV07XG4gICAgICAgIHJldHVybiBuZXcgRXF1YWxzT3BlcmF0aW9uKGZ1bmN0aW9uIChiKSB7IHJldHVybiBjb21wYXJhYmxlKGIpICUgbW9kID09PSBlcXVhbHNWYWx1ZTsgfSwgb3duZXJ5UXVlcnksIG9wdGlvbnMpO1xuICAgIH07XG4gICAgdmFyICRleGlzdHMgPSBmdW5jdGlvbiAocGFyYW1zLCBvd25lcnlRdWVyeSwgb3B0aW9ucywgbmFtZSkgeyByZXR1cm4gbmV3ICRFeGlzdHMocGFyYW1zLCBvd25lcnlRdWVyeSwgb3B0aW9ucywgbmFtZSk7IH07XG4gICAgdmFyICRyZWdleCA9IGZ1bmN0aW9uIChwYXR0ZXJuLCBvd25lcnlRdWVyeSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEVxdWFsc09wZXJhdGlvbihuZXcgUmVnRXhwKHBhdHRlcm4sIG93bmVyeVF1ZXJ5LiRvcHRpb25zKSwgb3duZXJ5UXVlcnksIG9wdGlvbnMpO1xuICAgIH07XG4gICAgdmFyICRub3QgPSBmdW5jdGlvbiAocGFyYW1zLCBvd25lcnlRdWVyeSwgb3B0aW9ucywgbmFtZSkgeyByZXR1cm4gbmV3ICROb3QocGFyYW1zLCBvd25lcnlRdWVyeSwgb3B0aW9ucywgbmFtZSk7IH07XG4gICAgdmFyIHR5cGVBbGlhc2VzID0ge1xuICAgICAgICBudW1iZXI6IGZ1bmN0aW9uICh2KSB7IHJldHVybiB0eXBlb2YgdiA9PT0gXCJudW1iZXJcIjsgfSxcbiAgICAgICAgc3RyaW5nOiBmdW5jdGlvbiAodikgeyByZXR1cm4gdHlwZW9mIHYgPT09IFwic3RyaW5nXCI7IH0sXG4gICAgICAgIGJvb2w6IGZ1bmN0aW9uICh2KSB7IHJldHVybiB0eXBlb2YgdiA9PT0gXCJib29sZWFuXCI7IH0sXG4gICAgICAgIGFycmF5OiBmdW5jdGlvbiAodikgeyByZXR1cm4gQXJyYXkuaXNBcnJheSh2KTsgfSxcbiAgICAgICAgbnVsbDogZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYgPT09IG51bGw7IH0sXG4gICAgICAgIHRpbWVzdGFtcDogZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYgaW5zdGFuY2VvZiBEYXRlOyB9XG4gICAgfTtcbiAgICB2YXIgJHR5cGUgPSBmdW5jdGlvbiAoY2xhenosIG93bmVyeVF1ZXJ5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXF1YWxzT3BlcmF0aW9uKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNsYXp6ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0eXBlQWxpYXNlc1tjbGF6el0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHlwZSBhbGlhcyBkb2VzIG5vdCBleGlzdFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVBbGlhc2VzW2NsYXp6XShiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiICE9IG51bGwgPyBiIGluc3RhbmNlb2YgY2xhenogfHwgYi5jb25zdHJ1Y3RvciA9PT0gY2xhenogOiBmYWxzZTtcbiAgICAgICAgfSwgb3duZXJ5UXVlcnksIG9wdGlvbnMpO1xuICAgIH07XG4gICAgdmFyICRhbmQgPSBmdW5jdGlvbiAocGFyYW1zLCBvd25lclF1ZXJ5LCBvcHRpb25zLCBuYW1lKSB7IHJldHVybiBuZXcgJEFuZChwYXJhbXMsIG93bmVyUXVlcnksIG9wdGlvbnMsIG5hbWUpOyB9O1xuICAgIHZhciAkYWxsID0gZnVuY3Rpb24gKHBhcmFtcywgb3duZXJRdWVyeSwgb3B0aW9ucywgbmFtZSkgeyByZXR1cm4gbmV3ICRBbGwocGFyYW1zLCBvd25lclF1ZXJ5LCBvcHRpb25zLCBuYW1lKTsgfTtcbiAgICB2YXIgJHNpemUgPSBmdW5jdGlvbiAocGFyYW1zLCBvd25lclF1ZXJ5LCBvcHRpb25zKSB7IHJldHVybiBuZXcgJFNpemUocGFyYW1zLCBvd25lclF1ZXJ5LCBvcHRpb25zLCBcIiRzaXplXCIpOyB9O1xuICAgIHZhciAkb3B0aW9ucyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgdmFyICR3aGVyZSA9IGZ1bmN0aW9uIChwYXJhbXMsIG93bmVyUXVlcnksIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHRlc3Q7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHBhcmFtcykpIHtcbiAgICAgICAgICAgIHRlc3QgPSBwYXJhbXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXByb2Nlc3MuZW52LkNTUF9FTkFCTEVEKSB7XG4gICAgICAgICAgICB0ZXN0ID0gbmV3IEZ1bmN0aW9uKFwib2JqXCIsIFwicmV0dXJuIFwiICsgcGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluIENTUCBtb2RlLCBzaWZ0IGRvZXMgbm90IHN1cHBvcnQgc3RyaW5ncyBpbiBcXFwiJHdoZXJlXFxcIiBjb25kaXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFcXVhbHNPcGVyYXRpb24oZnVuY3Rpb24gKGIpIHsgcmV0dXJuIHRlc3QuYmluZChiKShiKTsgfSwgb3duZXJRdWVyeSwgb3B0aW9ucyk7XG4gICAgfTtcblxuICAgIHZhciBkZWZhdWx0T3BlcmF0aW9ucyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgICAkU2l6ZTogJFNpemUsXG4gICAgICAgICRlcTogJGVxLFxuICAgICAgICAkbmU6ICRuZSxcbiAgICAgICAgJG9yOiAkb3IsXG4gICAgICAgICRub3I6ICRub3IsXG4gICAgICAgICRlbGVtTWF0Y2g6ICRlbGVtTWF0Y2gsXG4gICAgICAgICRuaW46ICRuaW4sXG4gICAgICAgICRpbjogJGluLFxuICAgICAgICAkbHQ6ICRsdCxcbiAgICAgICAgJGx0ZTogJGx0ZSxcbiAgICAgICAgJGd0OiAkZ3QsXG4gICAgICAgICRndGU6ICRndGUsXG4gICAgICAgICRtb2Q6ICRtb2QsXG4gICAgICAgICRleGlzdHM6ICRleGlzdHMsXG4gICAgICAgICRyZWdleDogJHJlZ2V4LFxuICAgICAgICAkbm90OiAkbm90LFxuICAgICAgICAkdHlwZTogJHR5cGUsXG4gICAgICAgICRhbmQ6ICRhbmQsXG4gICAgICAgICRhbGw6ICRhbGwsXG4gICAgICAgICRzaXplOiAkc2l6ZSxcbiAgICAgICAgJG9wdGlvbnM6ICRvcHRpb25zLFxuICAgICAgICAkd2hlcmU6ICR3aGVyZVxuICAgIH0pO1xuXG4gICAgdmFyIGNyZWF0ZURlZmF1bHRRdWVyeU9wZXJhdGlvbiA9IGZ1bmN0aW9uIChxdWVyeSwgb3duZXJRdWVyeSwgX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIGNvbXBhcmUgPSBfYi5jb21wYXJlLCBvcGVyYXRpb25zID0gX2Iub3BlcmF0aW9ucztcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVF1ZXJ5T3BlcmF0aW9uKHF1ZXJ5LCBvd25lclF1ZXJ5LCB7XG4gICAgICAgICAgICBjb21wYXJlOiBjb21wYXJlLFxuICAgICAgICAgICAgb3BlcmF0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wZXJhdGlvbnMsIG9wZXJhdGlvbnMgfHwge30pXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdmFyIGNyZWF0ZURlZmF1bHRRdWVyeVRlc3RlciA9IGZ1bmN0aW9uIChxdWVyeSwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgb3AgPSBjcmVhdGVEZWZhdWx0UXVlcnlPcGVyYXRpb24ocXVlcnksIG51bGwsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gY3JlYXRlT3BlcmF0aW9uVGVzdGVyKG9wKTtcbiAgICB9O1xuXG4gICAgZXhwb3J0cy4kU2l6ZSA9ICRTaXplO1xuICAgIGV4cG9ydHMuJGFsbCA9ICRhbGw7XG4gICAgZXhwb3J0cy4kYW5kID0gJGFuZDtcbiAgICBleHBvcnRzLiRlbGVtTWF0Y2ggPSAkZWxlbU1hdGNoO1xuICAgIGV4cG9ydHMuJGVxID0gJGVxO1xuICAgIGV4cG9ydHMuJGV4aXN0cyA9ICRleGlzdHM7XG4gICAgZXhwb3J0cy4kZ3QgPSAkZ3Q7XG4gICAgZXhwb3J0cy4kZ3RlID0gJGd0ZTtcbiAgICBleHBvcnRzLiRpbiA9ICRpbjtcbiAgICBleHBvcnRzLiRsdCA9ICRsdDtcbiAgICBleHBvcnRzLiRsdGUgPSAkbHRlO1xuICAgIGV4cG9ydHMuJG1vZCA9ICRtb2Q7XG4gICAgZXhwb3J0cy4kbmUgPSAkbmU7XG4gICAgZXhwb3J0cy4kbmluID0gJG5pbjtcbiAgICBleHBvcnRzLiRub3IgPSAkbm9yO1xuICAgIGV4cG9ydHMuJG5vdCA9ICRub3Q7XG4gICAgZXhwb3J0cy4kb3B0aW9ucyA9ICRvcHRpb25zO1xuICAgIGV4cG9ydHMuJG9yID0gJG9yO1xuICAgIGV4cG9ydHMuJHJlZ2V4ID0gJHJlZ2V4O1xuICAgIGV4cG9ydHMuJHNpemUgPSAkc2l6ZTtcbiAgICBleHBvcnRzLiR0eXBlID0gJHR5cGU7XG4gICAgZXhwb3J0cy4kd2hlcmUgPSAkd2hlcmU7XG4gICAgZXhwb3J0cy5FcXVhbHNPcGVyYXRpb24gPSBFcXVhbHNPcGVyYXRpb247XG4gICAgZXhwb3J0cy5jcmVhdGVEZWZhdWx0UXVlcnlPcGVyYXRpb24gPSBjcmVhdGVEZWZhdWx0UXVlcnlPcGVyYXRpb247XG4gICAgZXhwb3J0cy5jcmVhdGVFcXVhbHNPcGVyYXRpb24gPSBjcmVhdGVFcXVhbHNPcGVyYXRpb247XG4gICAgZXhwb3J0cy5jcmVhdGVPcGVyYXRpb25UZXN0ZXIgPSBjcmVhdGVPcGVyYXRpb25UZXN0ZXI7XG4gICAgZXhwb3J0cy5jcmVhdGVRdWVyeU9wZXJhdGlvbiA9IGNyZWF0ZVF1ZXJ5T3BlcmF0aW9uO1xuICAgIGV4cG9ydHMuY3JlYXRlUXVlcnlUZXN0ZXIgPSBjcmVhdGVRdWVyeVRlc3RlcjtcbiAgICBleHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVEZWZhdWx0UXVlcnlUZXN0ZXI7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../backend/node_modules/sift/lib/index.js\n");

/***/ })

};
;